<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › mtd › nand.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>nand.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/include/linux/mtd/nand.h</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright © 2000-2010 David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
<span class="cm"> *                        Steven J. Hill &lt;sjhill@realitydiluted.com&gt;</span>
<span class="cm"> *		          Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * Info:</span>
<span class="cm"> *	Contains standard defines and IDs for NAND flash devices</span>
<span class="cm"> *</span>
<span class="cm"> * Changelog:</span>
<span class="cm"> *	See git changelog.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __LINUX_MTD_NAND_H</span>
<span class="cp">#define __LINUX_MTD_NAND_H</span>

<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/flashchip.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/bbm.h&gt;</span>

<span class="k">struct</span> <span class="n">mtd_info</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">nand_flash_dev</span><span class="p">;</span>
<span class="cm">/* Scan and identify a NAND device */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nand_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_chips</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * Separate phases of nand_scan(), allowing board driver to intervene</span>
<span class="cm"> * and override command or ECC setup according to flash type.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nand_scan_ident</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_chips</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">nand_flash_dev</span> <span class="o">*</span><span class="n">table</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nand_scan_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">);</span>

<span class="cm">/* Free resources held by the NAND device */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nand_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">);</span>

<span class="cm">/* Internal helper for board drivers which need to override command function */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nand_wait_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">);</span>

<span class="cm">/* locks all blocks present in the device */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nand_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* unlocks specified locked blocks */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nand_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* The maximum number of NAND chips in an array */</span>
<span class="cp">#define NAND_MAX_CHIPS		8</span>

<span class="cm">/*</span>
<span class="cm"> * This constant declares the max. oobsize / page, which</span>
<span class="cm"> * is supported now. If you add a chip with bigger oobsize/page</span>
<span class="cm"> * adjust this accordingly.</span>
<span class="cm"> */</span>
<span class="cp">#define NAND_MAX_OOBSIZE	576</span>
<span class="cp">#define NAND_MAX_PAGESIZE	8192</span>

<span class="cm">/*</span>
<span class="cm"> * Constants for hardware specific CLE/ALE/NCE function</span>
<span class="cm"> *</span>
<span class="cm"> * These are bits which can be or&#39;ed to set/clear multiple</span>
<span class="cm"> * bits in one go.</span>
<span class="cm"> */</span>
<span class="cm">/* Select the chip by setting nCE to low */</span>
<span class="cp">#define NAND_NCE		0x01</span>
<span class="cm">/* Select the command latch by setting CLE to high */</span>
<span class="cp">#define NAND_CLE		0x02</span>
<span class="cm">/* Select the address latch by setting ALE to high */</span>
<span class="cp">#define NAND_ALE		0x04</span>

<span class="cp">#define NAND_CTRL_CLE		(NAND_NCE | NAND_CLE)</span>
<span class="cp">#define NAND_CTRL_ALE		(NAND_NCE | NAND_ALE)</span>
<span class="cp">#define NAND_CTRL_CHANGE	0x80</span>

<span class="cm">/*</span>
<span class="cm"> * Standard NAND flash commands</span>
<span class="cm"> */</span>
<span class="cp">#define NAND_CMD_READ0		0</span>
<span class="cp">#define NAND_CMD_READ1		1</span>
<span class="cp">#define NAND_CMD_RNDOUT		5</span>
<span class="cp">#define NAND_CMD_PAGEPROG	0x10</span>
<span class="cp">#define NAND_CMD_READOOB	0x50</span>
<span class="cp">#define NAND_CMD_ERASE1		0x60</span>
<span class="cp">#define NAND_CMD_STATUS		0x70</span>
<span class="cp">#define NAND_CMD_STATUS_MULTI	0x71</span>
<span class="cp">#define NAND_CMD_SEQIN		0x80</span>
<span class="cp">#define NAND_CMD_RNDIN		0x85</span>
<span class="cp">#define NAND_CMD_READID		0x90</span>
<span class="cp">#define NAND_CMD_ERASE2		0xd0</span>
<span class="cp">#define NAND_CMD_PARAM		0xec</span>
<span class="cp">#define NAND_CMD_RESET		0xff</span>

<span class="cp">#define NAND_CMD_LOCK		0x2a</span>
<span class="cp">#define NAND_CMD_UNLOCK1	0x23</span>
<span class="cp">#define NAND_CMD_UNLOCK2	0x24</span>

<span class="cm">/* Extended commands for large page devices */</span>
<span class="cp">#define NAND_CMD_READSTART	0x30</span>
<span class="cp">#define NAND_CMD_RNDOUTSTART	0xE0</span>
<span class="cp">#define NAND_CMD_CACHEDPROG	0x15</span>

<span class="cm">/* Extended commands for AG-AND device */</span>
<span class="cm">/*</span>
<span class="cm"> * Note: the command for NAND_CMD_DEPLETE1 is really 0x00 but</span>
<span class="cm"> *       there is no way to distinguish that from NAND_CMD_READ0</span>
<span class="cm"> *       until the remaining sequence of commands has been completed</span>
<span class="cm"> *       so add a high order bit and mask it off in the command.</span>
<span class="cm"> */</span>
<span class="cp">#define NAND_CMD_DEPLETE1	0x100</span>
<span class="cp">#define NAND_CMD_DEPLETE2	0x38</span>
<span class="cp">#define NAND_CMD_STATUS_MULTI	0x71</span>
<span class="cp">#define NAND_CMD_STATUS_ERROR	0x72</span>
<span class="cm">/* multi-bank error status (banks 0-3) */</span>
<span class="cp">#define NAND_CMD_STATUS_ERROR0	0x73</span>
<span class="cp">#define NAND_CMD_STATUS_ERROR1	0x74</span>
<span class="cp">#define NAND_CMD_STATUS_ERROR2	0x75</span>
<span class="cp">#define NAND_CMD_STATUS_ERROR3	0x76</span>
<span class="cp">#define NAND_CMD_STATUS_RESET	0x7f</span>
<span class="cp">#define NAND_CMD_STATUS_CLEAR	0xff</span>

<span class="cp">#define NAND_CMD_NONE		-1</span>

<span class="cm">/* Status bits */</span>
<span class="cp">#define NAND_STATUS_FAIL	0x01</span>
<span class="cp">#define NAND_STATUS_FAIL_N1	0x02</span>
<span class="cp">#define NAND_STATUS_TRUE_READY	0x20</span>
<span class="cp">#define NAND_STATUS_READY	0x40</span>
<span class="cp">#define NAND_STATUS_WP		0x80</span>

<span class="cm">/*</span>
<span class="cm"> * Constants for ECC_MODES</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">NAND_ECC_NONE</span><span class="p">,</span>
	<span class="n">NAND_ECC_SOFT</span><span class="p">,</span>
	<span class="n">NAND_ECC_HW</span><span class="p">,</span>
	<span class="n">NAND_ECC_HW_SYNDROME</span><span class="p">,</span>
	<span class="n">NAND_ECC_HW_OOB_FIRST</span><span class="p">,</span>
	<span class="n">NAND_ECC_SOFT_BCH</span><span class="p">,</span>
<span class="p">}</span> <span class="n">nand_ecc_modes_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Constants for Hardware ECC</span>
<span class="cm"> */</span>
<span class="cm">/* Reset Hardware ECC for read */</span>
<span class="cp">#define NAND_ECC_READ		0</span>
<span class="cm">/* Reset Hardware ECC for write */</span>
<span class="cp">#define NAND_ECC_WRITE		1</span>
<span class="cm">/* Enable Hardware ECC before syndrome is read back from flash */</span>
<span class="cp">#define NAND_ECC_READSYN	2</span>

<span class="cm">/* Bit mask for flags passed to do_nand_read_ecc */</span>
<span class="cp">#define NAND_GET_DEVICE		0x80</span>


<span class="cm">/*</span>
<span class="cm"> * Option constants for bizarre disfunctionality and real</span>
<span class="cm"> * features.</span>
<span class="cm"> */</span>
<span class="cm">/* Buswidth is 16 bit */</span>
<span class="cp">#define NAND_BUSWIDTH_16	0x00000002</span>
<span class="cm">/* Device supports partial programming without padding */</span>
<span class="cp">#define NAND_NO_PADDING		0x00000004</span>
<span class="cm">/* Chip has cache program function */</span>
<span class="cp">#define NAND_CACHEPRG		0x00000008</span>
<span class="cm">/* Chip has copy back function */</span>
<span class="cp">#define NAND_COPYBACK		0x00000010</span>
<span class="cm">/*</span>
<span class="cm"> * AND Chip which has 4 banks and a confusing page / block</span>
<span class="cm"> * assignment. See Renesas datasheet for further information.</span>
<span class="cm"> */</span>
<span class="cp">#define NAND_IS_AND		0x00000020</span>
<span class="cm">/*</span>
<span class="cm"> * Chip has a array of 4 pages which can be read without</span>
<span class="cm"> * additional ready /busy waits.</span>
<span class="cm"> */</span>
<span class="cp">#define NAND_4PAGE_ARRAY	0x00000040</span>
<span class="cm">/*</span>
<span class="cm"> * Chip requires that BBT is periodically rewritten to prevent</span>
<span class="cm"> * bits from adjacent blocks from &#39;leaking&#39; in altering data.</span>
<span class="cm"> * This happens with the Renesas AG-AND chips, possibly others.</span>
<span class="cm"> */</span>
<span class="cp">#define BBT_AUTO_REFRESH	0x00000080</span>
<span class="cm">/*</span>
<span class="cm"> * Chip does not require ready check on read. True</span>
<span class="cm"> * for all large page devices, as they do not support</span>
<span class="cm"> * autoincrement.</span>
<span class="cm"> */</span>
<span class="cp">#define NAND_NO_READRDY		0x00000100</span>
<span class="cm">/* Chip does not allow subpage writes */</span>
<span class="cp">#define NAND_NO_SUBPAGE_WRITE	0x00000200</span>

<span class="cm">/* Device is one of &#39;new&#39; xD cards that expose fake nand command set */</span>
<span class="cp">#define NAND_BROKEN_XD		0x00000400</span>

<span class="cm">/* Device behaves just like nand, but is readonly */</span>
<span class="cp">#define NAND_ROM		0x00000800</span>

<span class="cm">/* Options valid for Samsung large page devices */</span>
<span class="cp">#define NAND_SAMSUNG_LP_OPTIONS \</span>
<span class="cp">	(NAND_NO_PADDING | NAND_CACHEPRG | NAND_COPYBACK)</span>

<span class="cm">/* Macros to identify the above */</span>
<span class="cp">#define NAND_MUST_PAD(chip) (!(chip-&gt;options &amp; NAND_NO_PADDING))</span>
<span class="cp">#define NAND_HAS_CACHEPROG(chip) ((chip-&gt;options &amp; NAND_CACHEPRG))</span>
<span class="cp">#define NAND_HAS_COPYBACK(chip) ((chip-&gt;options &amp; NAND_COPYBACK))</span>
<span class="cm">/* Large page NAND with SOFT_ECC should support subpage reads */</span>
<span class="cp">#define NAND_SUBPAGE_READ(chip) ((chip-&gt;ecc.mode == NAND_ECC_SOFT) \</span>
<span class="cp">					&amp;&amp; (chip-&gt;page_shift &gt; 9))</span>

<span class="cm">/* Mask to zero out the chip options, which come from the id table */</span>
<span class="cp">#define NAND_CHIPOPTIONS_MSK	0x0000ffff</span>

<span class="cm">/* Non chip related options */</span>
<span class="cm">/* This option skips the bbt scan during initialization. */</span>
<span class="cp">#define NAND_SKIP_BBTSCAN	0x00010000</span>
<span class="cm">/*</span>
<span class="cm"> * This option is defined if the board driver allocates its own buffers</span>
<span class="cm"> * (e.g. because it needs them DMA-coherent).</span>
<span class="cm"> */</span>
<span class="cp">#define NAND_OWN_BUFFERS	0x00020000</span>
<span class="cm">/* Chip may not exist, so silence any errors in scan */</span>
<span class="cp">#define NAND_SCAN_SILENT_NODEV	0x00040000</span>

<span class="cm">/* Options set by nand scan */</span>
<span class="cm">/* Nand scan has allocated controller struct */</span>
<span class="cp">#define NAND_CONTROLLER_ALLOC	0x80000000</span>

<span class="cm">/* Cell info constants */</span>
<span class="cp">#define NAND_CI_CHIPNR_MSK	0x03</span>
<span class="cp">#define NAND_CI_CELLTYPE_MSK	0x0C</span>

<span class="cm">/* Keep gcc happy */</span>
<span class="k">struct</span> <span class="n">nand_chip</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">nand_onfi_params</span> <span class="p">{</span>
	<span class="cm">/* rev info and features block */</span>
	<span class="cm">/* &#39;O&#39; &#39;N&#39; &#39;F&#39; &#39;I&#39;  */</span>
	<span class="n">u8</span> <span class="n">sig</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">revision</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">features</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">opt_cmd</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">22</span><span class="p">];</span>

	<span class="cm">/* manufacturer information block */</span>
	<span class="kt">char</span> <span class="n">manufacturer</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">model</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">jedec_id</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">date_code</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved2</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>

	<span class="cm">/* memory organization block */</span>
	<span class="n">__le32</span> <span class="n">byte_per_page</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">spare_bytes_per_page</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">data_bytes_per_ppage</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">spare_bytes_per_ppage</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">pages_per_block</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">blocks_per_lun</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">lun_count</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">addr_cycles</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bits_per_cell</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">bb_per_lun</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">block_endurance</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">guaranteed_good_blocks</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">guaranteed_block_endurance</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">programs_per_page</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ppage_attr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ecc_bits</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">interleaved_bits</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">interleaved_ops</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved3</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>

	<span class="cm">/* electrical parameter block */</span>
	<span class="n">u8</span> <span class="n">io_pin_capacitance_max</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">async_timing_mode</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">program_cache_timing_mode</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">t_prog</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">t_bers</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">t_r</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">t_ccs</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">src_sync_timing_mode</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">src_ssync_features</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">clk_pin_capacitance_typ</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">io_pin_capacitance_typ</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">input_pin_capacitance_typ</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">input_pin_capacitance_max</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">driver_strenght_support</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">t_int_r</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">t_ald</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved4</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>

	<span class="cm">/* vendor */</span>
	<span class="n">u8</span> <span class="n">reserved5</span><span class="p">[</span><span class="mi">90</span><span class="p">];</span>

	<span class="n">__le16</span> <span class="n">crc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cp">#define ONFI_CRC_BASE	0x4F4E</span>

<span class="cm">/**</span>
<span class="cm"> * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices</span>
<span class="cm"> * @lock:               protection lock</span>
<span class="cm"> * @active:		the mtd device which holds the controller currently</span>
<span class="cm"> * @wq:			wait queue to sleep on if a NAND operation is in</span>
<span class="cm"> *			progress used instead of the per chip wait queue</span>
<span class="cm"> *			when a hw controller is available.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nand_hw_control</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">active</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nand_ecc_ctrl - Control structure for ECC</span>
<span class="cm"> * @mode:	ECC mode</span>
<span class="cm"> * @steps:	number of ECC steps per page</span>
<span class="cm"> * @size:	data bytes per ECC step</span>
<span class="cm"> * @bytes:	ECC bytes per step</span>
<span class="cm"> * @strength:	max number of correctible bits per ECC step</span>
<span class="cm"> * @total:	total number of ECC bytes per page</span>
<span class="cm"> * @prepad:	padding information for syndrome based ECC generators</span>
<span class="cm"> * @postpad:	padding information for syndrome based ECC generators</span>
<span class="cm"> * @layout:	ECC layout control struct pointer</span>
<span class="cm"> * @priv:	pointer to private ECC control data</span>
<span class="cm"> * @hwctl:	function to control hardware ECC generator. Must only</span>
<span class="cm"> *		be provided if an hardware ECC is available</span>
<span class="cm"> * @calculate:	function for ECC calculation or readback from ECC hardware</span>
<span class="cm"> * @correct:	function for ECC correction, matching to ECC generator (sw/hw)</span>
<span class="cm"> * @read_page_raw:	function to read a raw page without ECC</span>
<span class="cm"> * @write_page_raw:	function to write a raw page without ECC</span>
<span class="cm"> * @read_page:	function to read a page according to the ECC generator</span>
<span class="cm"> *		requirements.</span>
<span class="cm"> * @read_subpage:	function to read parts of the page covered by ECC.</span>
<span class="cm"> * @write_page:	function to write a page according to the ECC generator</span>
<span class="cm"> *		requirements.</span>
<span class="cm"> * @write_oob_raw:	function to write chip OOB data without ECC</span>
<span class="cm"> * @read_oob_raw:	function to read chip OOB data without ECC</span>
<span class="cm"> * @read_oob:	function to read chip OOB data</span>
<span class="cm"> * @write_oob:	function to write chip OOB data</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nand_ecc_ctrl</span> <span class="p">{</span>
	<span class="n">nand_ecc_modes_t</span> <span class="n">mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">steps</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">total</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">strength</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prepad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">postpad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_ecclayout</span>	<span class="o">*</span><span class="n">layout</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hwctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">calculate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dat</span><span class="p">,</span>
			<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">ecc_code</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">correct</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dat</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">read_ecc</span><span class="p">,</span>
			<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">calc_ecc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_page_raw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oob_required</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_page_raw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oob_required</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_page</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oob_required</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_subpage</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			<span class="kt">uint32_t</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_page</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oob_required</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_oob_raw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_oob_raw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_oob</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_oob</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">page</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nand_buffers - buffer structure for read/write</span>
<span class="cm"> * @ecccalc:	buffer for calculated ECC</span>
<span class="cm"> * @ecccode:	buffer for ECC read from flash</span>
<span class="cm"> * @databuf:	buffer for data - dynamically sized</span>
<span class="cm"> *</span>
<span class="cm"> * Do not change the order of buffers. databuf and oobrbuf must be in</span>
<span class="cm"> * consecutive order.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nand_buffers</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>	<span class="n">ecccalc</span><span class="p">[</span><span class="n">NAND_MAX_OOBSIZE</span><span class="p">];</span>
	<span class="kt">uint8_t</span>	<span class="n">ecccode</span><span class="p">[</span><span class="n">NAND_MAX_OOBSIZE</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">databuf</span><span class="p">[</span><span class="n">NAND_MAX_PAGESIZE</span> <span class="o">+</span> <span class="n">NAND_MAX_OOBSIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nand_chip - NAND Private Flash Chip Data</span>
<span class="cm"> * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the</span>
<span class="cm"> *			flash device</span>
<span class="cm"> * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the</span>
<span class="cm"> *			flash device.</span>
<span class="cm"> * @read_byte:		[REPLACEABLE] read one byte from the chip</span>
<span class="cm"> * @read_word:		[REPLACEABLE] read one word from the chip</span>
<span class="cm"> * @write_buf:		[REPLACEABLE] write data from the buffer to the chip</span>
<span class="cm"> * @read_buf:		[REPLACEABLE] read data from the chip into the buffer</span>
<span class="cm"> * @verify_buf:		[REPLACEABLE] verify buffer contents against the chip</span>
<span class="cm"> *			data.</span>
<span class="cm"> * @select_chip:	[REPLACEABLE] select chip nr</span>
<span class="cm"> * @block_bad:		[REPLACEABLE] check, if the block is bad</span>
<span class="cm"> * @block_markbad:	[REPLACEABLE] mark the block bad</span>
<span class="cm"> * @cmd_ctrl:		[BOARDSPECIFIC] hardwarespecific function for controlling</span>
<span class="cm"> *			ALE/CLE/nCE. Also used to write command and address</span>
<span class="cm"> * @init_size:		[BOARDSPECIFIC] hardwarespecific function for setting</span>
<span class="cm"> *			mtd-&gt;oobsize, mtd-&gt;writesize and so on.</span>
<span class="cm"> *			@id_data contains the 8 bytes values of NAND_CMD_READID.</span>
<span class="cm"> *			Return with the bus width.</span>
<span class="cm"> * @dev_ready:		[BOARDSPECIFIC] hardwarespecific function for accessing</span>
<span class="cm"> *			device ready/busy line. If set to NULL no access to</span>
<span class="cm"> *			ready/busy is available and the ready/busy information</span>
<span class="cm"> *			is read from the chip status register.</span>
<span class="cm"> * @cmdfunc:		[REPLACEABLE] hardwarespecific function for writing</span>
<span class="cm"> *			commands to the chip.</span>
<span class="cm"> * @waitfunc:		[REPLACEABLE] hardwarespecific function for wait on</span>
<span class="cm"> *			ready.</span>
<span class="cm"> * @ecc:		[BOARDSPECIFIC] ECC control structure</span>
<span class="cm"> * @buffers:		buffer structure for read/write</span>
<span class="cm"> * @hwcontrol:		platform-specific hardware control structure</span>
<span class="cm"> * @erase_cmd:		[INTERN] erase command write function, selectable due</span>
<span class="cm"> *			to AND support.</span>
<span class="cm"> * @scan_bbt:		[REPLACEABLE] function to scan bad block table</span>
<span class="cm"> * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transferring</span>
<span class="cm"> *			data from array to read regs (tR).</span>
<span class="cm"> * @state:		[INTERN] the current state of the NAND device</span>
<span class="cm"> * @oob_poi:		&quot;poison value buffer,&quot; used for laying out OOB data</span>
<span class="cm"> *			before writing</span>
<span class="cm"> * @page_shift:		[INTERN] number of address bits in a page (column</span>
<span class="cm"> *			address bits).</span>
<span class="cm"> * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock</span>
<span class="cm"> * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry</span>
<span class="cm"> * @chip_shift:		[INTERN] number of address bits in one chip</span>
<span class="cm"> * @options:		[BOARDSPECIFIC] various chip options. They can partly</span>
<span class="cm"> *			be set to inform nand_scan about special functionality.</span>
<span class="cm"> *			See the defines for further explanation.</span>
<span class="cm"> * @bbt_options:	[INTERN] bad block specific options. All options used</span>
<span class="cm"> *			here must come from bbm.h. By default, these options</span>
<span class="cm"> *			will be copied to the appropriate nand_bbt_descr&#39;s.</span>
<span class="cm"> * @badblockpos:	[INTERN] position of the bad block marker in the oob</span>
<span class="cm"> *			area.</span>
<span class="cm"> * @badblockbits:	[INTERN] minimum number of set bits in a good block&#39;s</span>
<span class="cm"> *			bad block marker position; i.e., BBM == 11110111b is</span>
<span class="cm"> *			not bad when badblockbits == 7</span>
<span class="cm"> * @cellinfo:		[INTERN] MLC/multichip data from chip ident</span>
<span class="cm"> * @numchips:		[INTERN] number of physical chips</span>
<span class="cm"> * @chipsize:		[INTERN] the size of one chip for multichip arrays</span>
<span class="cm"> * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1</span>
<span class="cm"> * @pagebuf:		[INTERN] holds the pagenumber which is currently in</span>
<span class="cm"> *			data_buf.</span>
<span class="cm"> * @pagebuf_bitflips:	[INTERN] holds the bitflip count for the page which is</span>
<span class="cm"> *			currently in data_buf.</span>
<span class="cm"> * @subpagesize:	[INTERN] holds the subpagesize</span>
<span class="cm"> * @onfi_version:	[INTERN] holds the chip ONFI version (BCD encoded),</span>
<span class="cm"> *			non 0 if ONFI supported.</span>
<span class="cm"> * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is</span>
<span class="cm"> *			supported, 0 otherwise.</span>
<span class="cm"> * @ecclayout:		[REPLACEABLE] the default ECC placement scheme</span>
<span class="cm"> * @bbt:		[INTERN] bad block table pointer</span>
<span class="cm"> * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash</span>
<span class="cm"> *			lookup.</span>
<span class="cm"> * @bbt_md:		[REPLACEABLE] bad block table mirror descriptor</span>
<span class="cm"> * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial</span>
<span class="cm"> *			bad block scan.</span>
<span class="cm"> * @controller:		[REPLACEABLE] a pointer to a hardware controller</span>
<span class="cm"> *			structure which is shared among multiple independent</span>
<span class="cm"> *			devices.</span>
<span class="cm"> * @priv:		[OPTIONAL] pointer to private chip data</span>
<span class="cm"> * @errstat:		[OPTIONAL] hardware specific function to perform</span>
<span class="cm"> *			additional error status checks (determine if errors are</span>
<span class="cm"> *			correctable).</span>
<span class="cm"> * @write_page:		[REPLACEABLE] High-level page write function</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">nand_chip</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">IO_ADDR_R</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">IO_ADDR_W</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read_byte</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">);</span>
	<span class="n">u16</span> <span class="p">(</span><span class="o">*</span><span class="n">read_word</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_buf</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">read_buf</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">verify_buf</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">select_chip</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chip</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">block_bad</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">getchip</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">block_markbad</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd_ctrl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init_size</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">id_data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dev_ready</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cmdfunc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">command</span><span class="p">,</span> <span class="kt">int</span> <span class="n">column</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">page_addr</span><span class="p">);</span>
	<span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">waitfunc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">erase_cmd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">scan_bbt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">errstat</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_page</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oob_required</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">cached</span><span class="p">,</span> <span class="kt">int</span> <span class="n">raw</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">chip_delay</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">options</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bbt_options</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">page_shift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">phys_erase_shift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bbt_erase_shift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chip_shift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numchips</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">chipsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pagemask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pagebuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pagebuf_bitflips</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">subpagesize</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">cellinfo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">badblockpos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">badblockbits</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">onfi_version</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_onfi_params</span>	<span class="n">onfi_params</span><span class="p">;</span>

	<span class="n">flstate_t</span> <span class="n">state</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">oob_poi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_hw_control</span> <span class="o">*</span><span class="n">controller</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_ecclayout</span> <span class="o">*</span><span class="n">ecclayout</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">nand_ecc_ctrl</span> <span class="n">ecc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_buffers</span> <span class="o">*</span><span class="n">buffers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_hw_control</span> <span class="n">hwcontrol</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bbt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_bbt_descr</span> <span class="o">*</span><span class="n">bbt_td</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_bbt_descr</span> <span class="o">*</span><span class="n">bbt_md</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">nand_bbt_descr</span> <span class="o">*</span><span class="n">badblock_pattern</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * NAND Flash Manufacturer ID Codes</span>
<span class="cm"> */</span>
<span class="cp">#define NAND_MFR_TOSHIBA	0x98</span>
<span class="cp">#define NAND_MFR_SAMSUNG	0xec</span>
<span class="cp">#define NAND_MFR_FUJITSU	0x04</span>
<span class="cp">#define NAND_MFR_NATIONAL	0x8f</span>
<span class="cp">#define NAND_MFR_RENESAS	0x07</span>
<span class="cp">#define NAND_MFR_STMICRO	0x20</span>
<span class="cp">#define NAND_MFR_HYNIX		0xad</span>
<span class="cp">#define NAND_MFR_MICRON		0x2c</span>
<span class="cp">#define NAND_MFR_AMD		0x01</span>
<span class="cp">#define NAND_MFR_MACRONIX	0xc2</span>

<span class="cm">/**</span>
<span class="cm"> * struct nand_flash_dev - NAND Flash Device ID Structure</span>
<span class="cm"> * @name:	Identify the device type</span>
<span class="cm"> * @id:		device ID code</span>
<span class="cm"> * @pagesize:	Pagesize in bytes. Either 256 or 512 or 0</span>
<span class="cm"> *		If the pagesize is 0, then the real pagesize</span>
<span class="cm"> *		and the eraseize are determined from the</span>
<span class="cm"> *		extended id bytes in the chip</span>
<span class="cm"> * @erasesize:	Size of an erase block in the flash device.</span>
<span class="cm"> * @chipsize:	Total chipsize in Mega Bytes</span>
<span class="cm"> * @options:	Bitfield to store chip relevant options</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nand_flash_dev</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pagesize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">chipsize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">erasesize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">options</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nand_manufacturers - NAND Flash Manufacturer ID Structure</span>
<span class="cm"> * @name:	Manufacturer name</span>
<span class="cm"> * @id:		manufacturer ID code of device.</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">nand_manufacturers</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">nand_flash_dev</span> <span class="n">nand_flash_ids</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">nand_manufacturers</span> <span class="n">nand_manuf_ids</span><span class="p">[];</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">nand_scan_bbt</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_bbt_descr</span> <span class="o">*</span><span class="n">bd</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nand_update_bbt</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offs</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nand_default_bbt</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nand_isbad_bbt</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">allowbbt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nand_erase_nand</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">erase_info</span> <span class="o">*</span><span class="n">instr</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">allowbbt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nand_do_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct platform_nand_chip - chip level device structure</span>
<span class="cm"> * @nr_chips:		max. number of chips to scan for</span>
<span class="cm"> * @chip_offset:	chip number offset</span>
<span class="cm"> * @nr_partitions:	number of partitions pointed to by partitions (or zero)</span>
<span class="cm"> * @partitions:		mtd partition list</span>
<span class="cm"> * @chip_delay:		R/B delay value in us</span>
<span class="cm"> * @options:		Option flags, e.g. 16bit buswidth</span>
<span class="cm"> * @bbt_options:	BBT option flags, e.g. NAND_BBT_USE_FLASH</span>
<span class="cm"> * @ecclayout:		ECC layout info structure</span>
<span class="cm"> * @part_probe_types:	NULL-terminated array of probe types</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">platform_nand_chip</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_chips</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chip_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_partitions</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_partition</span> <span class="o">*</span><span class="n">partitions</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_ecclayout</span> <span class="o">*</span><span class="n">ecclayout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chip_delay</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">options</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bbt_options</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">part_probe_types</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Keep gcc happy */</span>
<span class="k">struct</span> <span class="n">platform_device</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct platform_nand_ctrl - controller level device structure</span>
<span class="cm"> * @probe:		platform specific function to probe/setup hardware</span>
<span class="cm"> * @remove:		platform specific function to remove/teardown hardware</span>
<span class="cm"> * @hwcontrol:		platform specific hardware control structure</span>
<span class="cm"> * @dev_ready:		platform specific function to read ready/busy pin</span>
<span class="cm"> * @select_chip:	platform specific chip select function</span>
<span class="cm"> * @cmd_ctrl:		platform specific function for controlling</span>
<span class="cm"> *			ALE/CLE/nCE. Also used to write command and address</span>
<span class="cm"> * @write_buf:		platform specific function for write buffer</span>
<span class="cm"> * @read_buf:		platform specific function for read buffer</span>
<span class="cm"> * @priv:		private data to transport driver specific settings</span>
<span class="cm"> *</span>
<span class="cm"> * All fields are optional and depend on the hardware driver requirements</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">platform_nand_ctrl</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hwcontrol</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dev_ready</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">select_chip</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chip</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd_ctrl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_buf</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">read_buf</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="p">(</span><span class="o">*</span><span class="n">read_byte</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct platform_nand_data - container structure for platform-specific data</span>
<span class="cm"> * @chip:		chip level chip structure</span>
<span class="cm"> * @ctrl:		controller level device structure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">platform_nand_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_nand_chip</span> <span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_nand_ctrl</span> <span class="n">ctrl</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Some helpers to access the data structures */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">platform_nand_chip</span> <span class="o">*</span><span class="nf">get_platform_nandchip</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __LINUX_MTD_NAND_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
