<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › tty_driver.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tty_driver.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_TTY_DRIVER_H</span>
<span class="cp">#define _LINUX_TTY_DRIVER_H</span>

<span class="cm">/*</span>
<span class="cm"> * This structure defines the interface between the low-level tty</span>
<span class="cm"> * driver and the tty routines.  The following routines can be</span>
<span class="cm"> * defined; unless noted otherwise, they are optional, and can be</span>
<span class="cm"> * filled in with a null pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * struct tty_struct * (*lookup)(struct tty_driver *self, int idx)</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the tty device corresponding to idx, NULL if there is not</span>
<span class="cm"> *	one currently in use and an ERR_PTR value on error. Called under</span>
<span class="cm"> *	tty_mutex (for now!)</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional method. Default behaviour is to use the ttys array</span>
<span class="cm"> *</span>
<span class="cm"> * int (*install)(struct tty_driver *self, struct tty_struct *tty)</span>
<span class="cm"> *</span>
<span class="cm"> *	Install a new tty into the tty driver internal tables. Used in</span>
<span class="cm"> *	conjunction with lookup and remove methods.</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional method. Default behaviour is to use the ttys array</span>
<span class="cm"> *</span>
<span class="cm"> * void (*remove)(struct tty_driver *self, struct tty_struct *tty)</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove a closed tty from the tty driver internal tables. Used in</span>
<span class="cm"> *	conjunction with lookup and remove methods.</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional method. Default behaviour is to use the ttys array</span>
<span class="cm"> *</span>
<span class="cm"> * int  (*open)(struct tty_struct * tty, struct file * filp);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This routine is called when a particular tty device is opened.</span>
<span class="cm"> * 	This routine is mandatory; if this routine is not filled in,</span>
<span class="cm"> * 	the attempted open will fail with ENODEV.</span>
<span class="cm"> *</span>
<span class="cm"> *	Required method.</span>
<span class="cm"> *     </span>
<span class="cm"> * void (*close)(struct tty_struct * tty, struct file * filp);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This routine is called when a particular tty device is closed.</span>
<span class="cm"> *</span>
<span class="cm"> *	Required method.</span>
<span class="cm"> *</span>
<span class="cm"> * void (*shutdown)(struct tty_struct * tty);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This routine is called synchronously when a particular tty device</span>
<span class="cm"> *	is closed for the last time freeing up the resources.</span>
<span class="cm"> *	Note that tty_shutdown() is not called if ops-&gt;shutdown is defined.</span>
<span class="cm"> *	This means one is responsible to take care of calling ops-&gt;remove (e.g.</span>
<span class="cm"> *	via tty_driver_remove_tty) and releasing tty-&gt;termios.</span>
<span class="cm"> *	Note that this hook may be called from *all* the contexts where one</span>
<span class="cm"> *	uses tty refcounting (e.g. tty_port_tty_get).</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * void (*cleanup)(struct tty_struct * tty);</span>
<span class="cm"> *</span>
<span class="cm"> *	This routine is called asynchronously when a particular tty device</span>
<span class="cm"> *	is closed for the last time freeing up the resources. This is</span>
<span class="cm"> *	actually the second part of shutdown for routines that might sleep.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * int (*write)(struct tty_struct * tty,</span>
<span class="cm"> * 		 const unsigned char *buf, int count);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This routine is called by the kernel to write a series of</span>
<span class="cm"> * 	characters to the tty device.  The characters may come from</span>
<span class="cm"> * 	user space or kernel space.  This routine will return the</span>
<span class="cm"> *	number of characters actually accepted for writing.</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional: Required for writable devices.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*put_char)(struct tty_struct *tty, unsigned char ch);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This routine is called by the kernel to write a single</span>
<span class="cm"> * 	character to the tty device.  If the kernel uses this routine,</span>
<span class="cm"> * 	it must call the flush_chars() routine (if defined) when it is</span>
<span class="cm"> * 	done stuffing characters into the driver.  If there is no room</span>
<span class="cm"> * 	in the queue, the character is ignored.</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional: Kernel will use the write method if not provided.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Do not call this function directly, call tty_put_char</span>
<span class="cm"> *</span>
<span class="cm"> * void (*flush_chars)(struct tty_struct *tty);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This routine is called by the kernel after it has written a</span>
<span class="cm"> * 	series of characters to the tty device using put_char().  </span>
<span class="cm"> *</span>
<span class="cm"> *	Optional:</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Do not call this function directly, call tty_driver_flush_chars</span>
<span class="cm"> * </span>
<span class="cm"> * int  (*write_room)(struct tty_struct *tty);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This routine returns the numbers of characters the tty driver</span>
<span class="cm"> * 	will accept for queuing to be written.  This number is subject</span>
<span class="cm"> * 	to change as output buffers get emptied, or if the output flow</span>
<span class="cm"> *	control is acted.</span>
<span class="cm"> *</span>
<span class="cm"> *	Required if write method is provided else not needed.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Do not call this function directly, call tty_write_room</span>
<span class="cm"> * </span>
<span class="cm"> * int  (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This routine allows the tty driver to implement</span>
<span class="cm"> *	device-specific ioctls.  If the ioctl number passed in cmd</span>
<span class="cm"> * 	is not recognized by the driver, it should return ENOIOCTLCMD.</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional</span>
<span class="cm"> *</span>
<span class="cm"> * long (*compat_ioctl)(struct tty_struct *tty,,</span>
<span class="cm"> * 	                unsigned int cmd, unsigned long arg);</span>
<span class="cm"> *</span>
<span class="cm"> * 	implement ioctl processing for 32 bit process on 64 bit system</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional</span>
<span class="cm"> * </span>
<span class="cm"> * void (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This routine allows the tty driver to be notified when</span>
<span class="cm"> * 	device&#39;s termios settings have changed.</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional: Called under the termios lock</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * void (*set_ldisc)(struct tty_struct *tty);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This routine allows the tty driver to be notified when the</span>
<span class="cm"> * 	device&#39;s termios settings have changed.</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional: Called under BKL (currently)</span>
<span class="cm"> * </span>
<span class="cm"> * void (*throttle)(struct tty_struct * tty);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This routine notifies the tty driver that input buffers for</span>
<span class="cm"> * 	the line discipline are close to full, and it should somehow</span>
<span class="cm"> * 	signal that no more characters should be sent to the tty.</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional: Always invoke via tty_throttle(), called under the</span>
<span class="cm"> *	termios lock.</span>
<span class="cm"> * </span>
<span class="cm"> * void (*unthrottle)(struct tty_struct * tty);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This routine notifies the tty drivers that it should signals</span>
<span class="cm"> * 	that characters can now be sent to the tty without fear of</span>
<span class="cm"> * 	overrunning the input buffers of the line disciplines.</span>
<span class="cm"> * </span>
<span class="cm"> *	Optional: Always invoke via tty_unthrottle(), called under the</span>
<span class="cm"> *	termios lock.</span>
<span class="cm"> *</span>
<span class="cm"> * void (*stop)(struct tty_struct *tty);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This routine notifies the tty driver that it should stop</span>
<span class="cm"> * 	outputting characters to the tty device.  </span>
<span class="cm"> *</span>
<span class="cm"> *	Optional:</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Call stop_tty not this method.</span>
<span class="cm"> * </span>
<span class="cm"> * void (*start)(struct tty_struct *tty);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This routine notifies the tty driver that it resume sending</span>
<span class="cm"> *	characters to the tty device.</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional:</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Call start_tty not this method.</span>
<span class="cm"> * </span>
<span class="cm"> * void (*hangup)(struct tty_struct *tty);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This routine notifies the tty driver that it should hang up the</span>
<span class="cm"> * 	tty device.</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional:</span>
<span class="cm"> *</span>
<span class="cm"> * int (*break_ctl)(struct tty_struct *tty, int state);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This optional routine requests the tty driver to turn on or</span>
<span class="cm"> * 	off BREAK status on the RS-232 port.  If state is -1,</span>
<span class="cm"> * 	then the BREAK status should be turned on; if state is 0, then</span>
<span class="cm"> * 	BREAK should be turned off.</span>
<span class="cm"> *</span>
<span class="cm"> * 	If this routine is implemented, the high-level tty driver will</span>
<span class="cm"> * 	handle the following ioctls: TCSBRK, TCSBRKP, TIOCSBRK,</span>
<span class="cm"> * 	TIOCCBRK.</span>
<span class="cm"> *</span>
<span class="cm"> *	If the driver sets TTY_DRIVER_HARDWARE_BREAK then the interface</span>
<span class="cm"> *	will also be called with actual times and the hardware is expected</span>
<span class="cm"> *	to do the delay work itself. 0 and -1 are still used for on/off.</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional: Required for TCSBRK/BRKP/etc handling.</span>
<span class="cm"> *</span>
<span class="cm"> * void (*wait_until_sent)(struct tty_struct *tty, int timeout);</span>
<span class="cm"> * </span>
<span class="cm"> * 	This routine waits until the device has written out all of the</span>
<span class="cm"> * 	characters in its transmitter FIFO.</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional: If not provided the device is assumed to have no FIFO</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Usually correct to call tty_wait_until_sent</span>
<span class="cm"> *</span>
<span class="cm"> * void (*send_xchar)(struct tty_struct *tty, char ch);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This routine is used to send a high-priority XON/XOFF</span>
<span class="cm"> * 	character to the device.</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional: If not provided then the write method is called under</span>
<span class="cm"> *	the atomic write lock to keep it serialized with the ldisc.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*resize)(struct tty_struct *tty, struct winsize *ws)</span>
<span class="cm"> *</span>
<span class="cm"> *	Called when a termios request is issued which changes the</span>
<span class="cm"> *	requested terminal geometry.</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional: the default action is to update the termios structure</span>
<span class="cm"> *	without error. This is usually the correct behaviour. Drivers should</span>
<span class="cm"> *	not force errors here if they are not resizable objects (eg a serial</span>
<span class="cm"> *	line). See tty_do_resize() if you need to wrap the standard method</span>
<span class="cm"> *	in your own logic - the usual case.</span>
<span class="cm"> *</span>
<span class="cm"> * void (*set_termiox)(struct tty_struct *tty, struct termiox *new);</span>
<span class="cm"> *</span>
<span class="cm"> *	Called when the device receives a termiox based ioctl. Passes down</span>
<span class="cm"> *	the requested data from user space. This method will not be invoked</span>
<span class="cm"> *	unless the tty also has a valid tty-&gt;termiox pointer.</span>
<span class="cm"> *</span>
<span class="cm"> *	Optional: Called under the termios lock</span>
<span class="cm"> *</span>
<span class="cm"> * int (*get_icount)(struct tty_struct *tty, struct serial_icounter *icount);</span>
<span class="cm"> *</span>
<span class="cm"> *	Called when the device receives a TIOCGICOUNT ioctl. Passed a kernel</span>
<span class="cm"> *	structure to complete. This method is optional and will only be called</span>
<span class="cm"> *	if provided (otherwise EINVAL will be returned).</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/cdev.h&gt;</span>
<span class="cp">#include &lt;linux/termios.h&gt;</span>

<span class="k">struct</span> <span class="n">tty_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">tty_driver</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">serial_icounter_struct</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">tty_operations</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">lookup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">install</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">filp</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">filp</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cleanup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="n">tty</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">put_char</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">flush_chars</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">write_room</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">chars_in_buffer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
	<span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">compat_ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_termios</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span> <span class="n">old</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">throttle</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="n">tty</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">unthrottle</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="n">tty</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">stop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hangup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">break_ctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">flush_buffer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_ldisc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">wait_until_sent</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">send_xchar</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">tiocmget</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">tiocmset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">set</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clear</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resize</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">winsize</span> <span class="o">*</span><span class="n">ws</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_termiox</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">termiox</span> <span class="o">*</span><span class="n">tnew</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_icount</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">serial_icounter_struct</span> <span class="o">*</span><span class="n">icount</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_CONSOLE_POLL</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">poll_init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">poll_get_char</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">poll_put_char</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">proc_fops</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tty_driver</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">magic</span><span class="p">;</span>		<span class="cm">/* magic number for this structure */</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">kref</span><span class="p">;</span>	<span class="cm">/* Reference management */</span>
	<span class="k">struct</span> <span class="n">cdev</span> <span class="n">cdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span>	<span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">driver_name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">name_base</span><span class="p">;</span>	<span class="cm">/* offset of printed name */</span>
	<span class="kt">int</span>	<span class="n">major</span><span class="p">;</span>		<span class="cm">/* major device number */</span>
	<span class="kt">int</span>	<span class="n">minor_start</span><span class="p">;</span>	<span class="cm">/* start of minor device number */</span>
	<span class="kt">int</span>	<span class="n">num</span><span class="p">;</span>		<span class="cm">/* number of devices allocated */</span>
	<span class="kt">short</span>	<span class="n">type</span><span class="p">;</span>		<span class="cm">/* type of tty driver */</span>
	<span class="kt">short</span>	<span class="n">subtype</span><span class="p">;</span>	<span class="cm">/* subtype of tty driver */</span>
	<span class="k">struct</span> <span class="n">ktermios</span> <span class="n">init_termios</span><span class="p">;</span> <span class="cm">/* Initial termios */</span>
	<span class="kt">int</span>	<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* tty driver flags */</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc_entry</span><span class="p">;</span> <span class="cm">/* /proc fs entry */</span>
	<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">other</span><span class="p">;</span> <span class="cm">/* only used for the PTY driver */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Pointer to the tty data structures</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">**</span><span class="n">ttys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ktermios</span> <span class="o">**</span><span class="n">termios</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">driver_state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Driver methods</span>
<span class="cm">	 */</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">tty_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tty_drivers</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">tty_drivers</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">__alloc_tty_driver</span><span class="p">(</span><span class="kt">int</span> <span class="n">lines</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">put_tty_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_set_operations</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">tty_operations</span> <span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">tty_find_polling_driver</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">line</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_driver_kref_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>

<span class="cp">#define alloc_tty_driver(lines) __alloc_tty_driver(lines, THIS_MODULE)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="nf">tty_driver_kref_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* tty driver magic number */</span>
<span class="cp">#define TTY_DRIVER_MAGIC		0x5402</span>

<span class="cm">/*</span>
<span class="cm"> * tty driver flags</span>
<span class="cm"> * </span>
<span class="cm"> * TTY_DRIVER_RESET_TERMIOS --- requests the tty layer to reset the</span>
<span class="cm"> * 	termios setting when the last process has closed the device.</span>
<span class="cm"> * 	Used for PTY&#39;s, in particular.</span>
<span class="cm"> * </span>
<span class="cm"> * TTY_DRIVER_REAL_RAW --- if set, indicates that the driver will</span>
<span class="cm"> * 	guarantee never not to set any special character handling</span>
<span class="cm"> * 	flags if ((IGNBRK || (!BRKINT &amp;&amp; !PARMRK)) &amp;&amp; (IGNPAR ||</span>
<span class="cm"> * 	!INPCK)).  That is, if there is no reason for the driver to</span>
<span class="cm"> * 	send notifications of parity and break characters up to the</span>
<span class="cm"> * 	line driver, it won&#39;t do so.  This allows the line driver to</span>
<span class="cm"> *	optimize for this case if this flag is set.  (Note that there</span>
<span class="cm"> * 	is also a promise, if the above case is true, not to signal</span>
<span class="cm"> * 	overruns, either.)</span>
<span class="cm"> *</span>
<span class="cm"> * TTY_DRIVER_DYNAMIC_DEV --- if set, the individual tty devices need</span>
<span class="cm"> *	to be registered with a call to tty_register_device() when the</span>
<span class="cm"> *	device is found in the system and unregistered with a call to</span>
<span class="cm"> *	tty_unregister_device() so the devices will be show up</span>
<span class="cm"> *	properly in sysfs.  If not set, driver-&gt;num entries will be</span>
<span class="cm"> *	created by the tty core in sysfs when tty_register_driver() is</span>
<span class="cm"> *	called.  This is to be used by drivers that have tty devices</span>
<span class="cm"> *	that can appear and disappear while the main tty driver is</span>
<span class="cm"> *	registered with the tty core.</span>
<span class="cm"> *</span>
<span class="cm"> * TTY_DRIVER_DEVPTS_MEM -- don&#39;t use the standard arrays, instead</span>
<span class="cm"> *	use dynamic memory keyed through the devpts filesystem.  This</span>
<span class="cm"> *	is only applicable to the pty driver.</span>
<span class="cm"> *</span>
<span class="cm"> * TTY_DRIVER_HARDWARE_BREAK -- hardware handles break signals. Pass</span>
<span class="cm"> *	the requested timeout to the caller instead of using a simple</span>
<span class="cm"> *	on/off interface.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define TTY_DRIVER_INSTALLED		0x0001</span>
<span class="cp">#define TTY_DRIVER_RESET_TERMIOS	0x0002</span>
<span class="cp">#define TTY_DRIVER_REAL_RAW		0x0004</span>
<span class="cp">#define TTY_DRIVER_DYNAMIC_DEV		0x0008</span>
<span class="cp">#define TTY_DRIVER_DEVPTS_MEM		0x0010</span>
<span class="cp">#define TTY_DRIVER_HARDWARE_BREAK	0x0020</span>

<span class="cm">/* tty driver types */</span>
<span class="cp">#define TTY_DRIVER_TYPE_SYSTEM		0x0001</span>
<span class="cp">#define TTY_DRIVER_TYPE_CONSOLE		0x0002</span>
<span class="cp">#define TTY_DRIVER_TYPE_SERIAL		0x0003</span>
<span class="cp">#define TTY_DRIVER_TYPE_PTY		0x0004</span>
<span class="cp">#define TTY_DRIVER_TYPE_SCC		0x0005	</span><span class="cm">/* scc driver */</span><span class="cp"></span>
<span class="cp">#define TTY_DRIVER_TYPE_SYSCONS		0x0006</span>

<span class="cm">/* system subtypes (magic, used by tty_io.c) */</span>
<span class="cp">#define SYSTEM_TYPE_TTY			0x0001</span>
<span class="cp">#define SYSTEM_TYPE_CONSOLE		0x0002</span>
<span class="cp">#define SYSTEM_TYPE_SYSCONS		0x0003</span>
<span class="cp">#define SYSTEM_TYPE_SYSPTMX		0x0004</span>

<span class="cm">/* pty subtypes (magic, used by tty_io.c) */</span>
<span class="cp">#define PTY_TYPE_MASTER			0x0001</span>
<span class="cp">#define PTY_TYPE_SLAVE			0x0002</span>

<span class="cm">/* serial subtype definitions */</span>
<span class="cp">#define SERIAL_TYPE_NORMAL	1</span>

<span class="cp">#endif </span><span class="cm">/* #ifdef _LINUX_TTY_DRIVER_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
