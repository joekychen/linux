<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › fd.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>fd.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_FD_H</span>
<span class="cp">#define _LINUX_FD_H</span>

<span class="cp">#include &lt;linux/ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>

<span class="cm">/* New file layout: Now the ioctl definitions immediately follow the</span>
<span class="cm"> * definitions of the structures that they use */</span>

<span class="cm">/*</span>
<span class="cm"> * Geometry</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">floppy_struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">size</span><span class="p">,</span>		<span class="cm">/* nr of sectors total */</span>
			<span class="n">sect</span><span class="p">,</span>		<span class="cm">/* sectors per track */</span>
			<span class="n">head</span><span class="p">,</span>		<span class="cm">/* nr of heads */</span>
			<span class="n">track</span><span class="p">,</span>		<span class="cm">/* nr of tracks */</span>
			<span class="n">stretch</span><span class="p">;</span>	<span class="cm">/* bit 0 !=0 means double track steps */</span>
					<span class="cm">/* bit 1 != 0 means swap sides */</span>
					<span class="cm">/* bits 2..9 give the first sector */</span>
					<span class="cm">/*  number (the LSB is flipped) */</span>
<span class="cp">#define FD_STRETCH 1</span>
<span class="cp">#define FD_SWAPSIDES 2</span>
<span class="cp">#define FD_ZEROBASED 4</span>
<span class="cp">#define FD_SECTBASEMASK 0x3FC</span>
<span class="cp">#define FD_MKSECTBASE(s) (((s) ^ 1) &lt;&lt; 2)</span>
<span class="cp">#define FD_SECTBASE(floppy) ((((floppy)-&gt;stretch &amp; FD_SECTBASEMASK) &gt;&gt; 2) ^ 1)</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">gap</span><span class="p">,</span>		<span class="cm">/* gap1 size */</span>

			<span class="n">rate</span><span class="p">,</span>		<span class="cm">/* data rate. |= 0x40 for perpendicular */</span>
<span class="cp">#define FD_2M 0x4</span>
<span class="cp">#define FD_SIZECODEMASK 0x38</span>
<span class="cp">#define FD_SIZECODE(floppy) (((((floppy)-&gt;rate&amp;FD_SIZECODEMASK)&gt;&gt; 3)+ 2) %8)</span>
<span class="cp">#define FD_SECTSIZE(floppy) ( (floppy)-&gt;rate &amp; FD_2M ? \</span>
<span class="cp">			     512 : 128 &lt;&lt; FD_SIZECODE(floppy) )</span>
<span class="cp">#define FD_PERP 0x40</span>

			<span class="n">spec1</span><span class="p">,</span>		<span class="cm">/* stepping rate, head unload time */</span>
			<span class="n">fmt_gap</span><span class="p">;</span>	<span class="cm">/* gap2 size */</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span> <span class="n">name</span><span class="p">;</span> <span class="cm">/* used only for predefined formats */</span>
<span class="p">};</span>


<span class="cm">/* commands needing write access have 0x40 set */</span>
<span class="cm">/* commands needing super user access have 0x80 set */</span>

<span class="cp">#define FDCLRPRM _IO(2, 0x41)</span>
<span class="cm">/* clear user-defined parameters */</span>

<span class="cp">#define FDSETPRM _IOW(2, 0x42, struct floppy_struct) </span>
<span class="cp">#define FDSETMEDIAPRM FDSETPRM</span>
<span class="cm">/* set user-defined parameters for current media */</span>

<span class="cp">#define FDDEFPRM _IOW(2, 0x43, struct floppy_struct) </span>
<span class="cp">#define FDGETPRM _IOR(2, 0x04, struct floppy_struct)</span>
<span class="cp">#define FDDEFMEDIAPRM FDDEFPRM</span>
<span class="cp">#define FDGETMEDIAPRM FDGETPRM</span>
<span class="cm">/* set/get disk parameters */</span>


<span class="cp">#define	FDMSGON  _IO(2,0x45)</span>
<span class="cp">#define	FDMSGOFF _IO(2,0x46)</span>
<span class="cm">/* issue/don&#39;t issue kernel messages on media type change */</span>


<span class="cm">/* </span>
<span class="cm"> * Formatting (obsolete)</span>
<span class="cm"> */</span>
<span class="cp">#define FD_FILL_BYTE 0xF6 </span><span class="cm">/* format fill byte. */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">format_descr</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">,</span><span class="n">head</span><span class="p">,</span><span class="n">track</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define FDFMTBEG _IO(2,0x47)</span>
<span class="cm">/* begin formatting a disk */</span>
<span class="cp">#define	FDFMTTRK _IOW(2,0x48, struct format_descr)</span>
<span class="cm">/* format the specified track */</span>
<span class="cp">#define FDFMTEND _IO(2,0x49)</span>
<span class="cm">/* end formatting a disk */</span>


<span class="cm">/*</span>
<span class="cm"> * Error thresholds</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">floppy_max_errors</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>
	  <span class="n">abort</span><span class="p">,</span>      <span class="cm">/* number of errors to be reached before aborting */</span>
	  <span class="n">read_track</span><span class="p">,</span> <span class="cm">/* maximal number of errors permitted to read an</span>
<span class="cm">		       * entire track at once */</span>
	  <span class="n">reset</span><span class="p">,</span>      <span class="cm">/* maximal number of errors before a reset is tried */</span>
	  <span class="n">recal</span><span class="p">,</span>      <span class="cm">/* maximal number of errors before a recalibrate is</span>
<span class="cm">		       * tried */</span>

	  <span class="cm">/*</span>
<span class="cm">	   * Threshold for reporting FDC errors to the console.</span>
<span class="cm">	   * Setting this to zero may flood your screen when using</span>
<span class="cm">	   * ultra cheap floppies ;-)</span>
<span class="cm">	   */</span>
	  <span class="n">reporting</span><span class="p">;</span>

<span class="p">};</span>

<span class="cp">#define FDSETEMSGTRESH	_IO(2,0x4a)</span>
<span class="cm">/* set fdc error reporting threshold */</span>

<span class="cp">#define FDFLUSH  _IO(2,0x4b)</span>
<span class="cm">/* flush buffers for media; either for verifying media, or for</span>
<span class="cm"> * handling a media change without closing the file descriptor */</span>

<span class="cp">#define FDSETMAXERRS _IOW(2, 0x4c, struct floppy_max_errors)</span>
<span class="cp">#define FDGETMAXERRS _IOR(2, 0x0e, struct floppy_max_errors)</span>
<span class="cm">/* set/get abortion and read_track threshold. See also floppy_drive_params</span>
<span class="cm"> * structure */</span>


<span class="k">typedef</span> <span class="kt">char</span> <span class="n">floppy_drive_name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="cp">#define FDGETDRVTYP _IOR(2, 0x0f, floppy_drive_name)</span>
<span class="cm">/* get drive type: 5 1/4 or 3 1/2 */</span>


<span class="cm">/*</span>
<span class="cm"> * Drive parameters (user modifiable)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">floppy_drive_params</span> <span class="p">{</span>
	<span class="kt">signed</span> <span class="kt">char</span> <span class="n">cmos</span><span class="p">;</span>		<span class="cm">/* CMOS type */</span>
	
	<span class="cm">/* Spec2 is (HLD&lt;&lt;1 | ND), where HLD is head load time (1=2ms, 2=4 ms </span>
<span class="cm">	 * etc) and ND is set means no DMA. Hardcoded to 6 (HLD=6ms, use DMA).</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_dtr</span><span class="p">;</span>		<span class="cm">/* Step rate, usec */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hlt</span><span class="p">;</span>     		<span class="cm">/* Head load/settle time, msec */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hut</span><span class="p">;</span>     		<span class="cm">/* Head unload time (remnant of </span>
<span class="cm">					 * 8&quot; drives) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">srt</span><span class="p">;</span>     		<span class="cm">/* Step rate, usec */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spinup</span><span class="p">;</span>		<span class="cm">/* time needed for spinup (expressed</span>
<span class="cm">					 * in jiffies) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spindown</span><span class="p">;</span>		<span class="cm">/* timeout needed for spindown */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">spindown_offset</span><span class="p">;</span>	<span class="cm">/* decides in which position the disk</span>
<span class="cm">					 * will stop */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">select_delay</span><span class="p">;</span>	<span class="cm">/* delay to wait after select */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">rps</span><span class="p">;</span>		<span class="cm">/* rotations per second */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tracks</span><span class="p">;</span>		<span class="cm">/* maximum number of tracks */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>		<span class="cm">/* timeout for interrupt requests */</span>
	
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">interleave_sect</span><span class="p">;</span>	<span class="cm">/* if there are more sectors, use </span>
<span class="cm">					 * interleave */</span>
	
	<span class="k">struct</span> <span class="n">floppy_max_errors</span> <span class="n">max_errors</span><span class="p">;</span>
	
	<span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>			<span class="cm">/* various flags, including ftd_msg */</span>
<span class="cm">/*</span>
<span class="cm"> * Announce successful media type detection and media information loss after</span>
<span class="cm"> * disk changes.</span>
<span class="cm"> * Also used to enable/disable printing of overrun warnings.</span>
<span class="cm"> */</span>

<span class="cp">#define FTD_MSG 0x10</span>
<span class="cp">#define FD_BROKEN_DCL 0x20</span>
<span class="cp">#define FD_DEBUG 0x02</span>
<span class="cp">#define FD_SILENT_DCL_CLEAR 0x4</span>
<span class="cp">#define FD_INVERTED_DCL 0x80 </span><span class="cm">/* must be 0x80, because of hardware </span>
<span class="cm">				considerations */</span><span class="cp"></span>

	<span class="kt">char</span> <span class="n">read_track</span><span class="p">;</span>		<span class="cm">/* use readtrack during probing? */</span>

<span class="cm">/*</span>
<span class="cm"> * Auto-detection. Each drive type has eight formats which are</span>
<span class="cm"> * used in succession to try to read the disk. If the FDC cannot lock onto</span>
<span class="cm"> * the disk, the next format is tried. This uses the variable &#39;probing&#39;.</span>
<span class="cm"> */</span>
	<span class="kt">short</span> <span class="n">autodetect</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>		<span class="cm">/* autodetected formats */</span>
	
	<span class="kt">int</span> <span class="n">checkfreq</span><span class="p">;</span> <span class="cm">/* how often should the drive be checked for disk </span>
<span class="cm">			* changes */</span>
	<span class="kt">int</span> <span class="n">native_format</span><span class="p">;</span> <span class="cm">/* native format of this drive */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">FD_NEED_TWADDLE_BIT</span><span class="p">,</span>	<span class="cm">/* more magic */</span>
	<span class="n">FD_VERIFY_BIT</span><span class="p">,</span>		<span class="cm">/* inquire for write protection */</span>
	<span class="n">FD_DISK_NEWCHANGE_BIT</span><span class="p">,</span>	<span class="cm">/* change detected, and no action undertaken yet</span>
<span class="cm">				 * to clear media change status */</span>
	<span class="n">FD_UNUSED_BIT</span><span class="p">,</span>
	<span class="n">FD_DISK_CHANGED_BIT</span><span class="p">,</span>	<span class="cm">/* disk has been changed since last i/o */</span>
	<span class="n">FD_DISK_WRITABLE_BIT</span>	<span class="cm">/* disk is writable */</span>
<span class="p">};</span>

<span class="cp">#define FDSETDRVPRM _IOW(2, 0x90, struct floppy_drive_params)</span>
<span class="cp">#define FDGETDRVPRM _IOR(2, 0x11, struct floppy_drive_params)</span>
<span class="cm">/* set/get drive parameters */</span>


<span class="cm">/*</span>
<span class="cm"> * Current drive state (not directly modifiable by user, readonly)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">floppy_drive_struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="cm">/* values for these flags */</span>
<span class="cp">#define FD_NEED_TWADDLE (1 &lt;&lt; FD_NEED_TWADDLE_BIT)</span>
<span class="cp">#define FD_VERIFY (1 &lt;&lt; FD_VERIFY_BIT)</span>
<span class="cp">#define FD_DISK_NEWCHANGE (1 &lt;&lt; FD_DISK_NEWCHANGE_BIT)</span>
<span class="cp">#define FD_DISK_CHANGED (1 &lt;&lt; FD_DISK_CHANGED_BIT)</span>
<span class="cp">#define FD_DISK_WRITABLE (1 &lt;&lt; FD_DISK_WRITABLE_BIT)</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spinup_date</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">select_date</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_read_date</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">probed_format</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">track</span><span class="p">;</span> <span class="cm">/* current track */</span>
	<span class="kt">short</span> <span class="n">maxblock</span><span class="p">;</span> <span class="cm">/* id of highest block read */</span>
	<span class="kt">short</span> <span class="n">maxtrack</span><span class="p">;</span> <span class="cm">/* id of highest half track read */</span>
	<span class="kt">int</span> <span class="n">generation</span><span class="p">;</span> <span class="cm">/* how many diskchanges? */</span>

<span class="cm">/*</span>
<span class="cm"> * (User-provided) media information is _not_ discarded after a media change</span>
<span class="cm"> * if the corresponding keep_data flag is non-zero. Positive values are</span>
<span class="cm"> * decremented after each probe.</span>
<span class="cm"> */</span>
	<span class="kt">int</span> <span class="n">keep_data</span><span class="p">;</span>
	
	<span class="cm">/* Prevent &quot;aliased&quot; accesses. */</span>
	<span class="kt">int</span> <span class="n">fd_ref</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd_device</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_checked</span><span class="p">;</span> <span class="cm">/* when was the drive last checked for a disk </span>
<span class="cm">			   * change? */</span>
	
	<span class="kt">char</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bufblocks</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define FDGETDRVSTAT _IOR(2, 0x12, struct floppy_drive_struct)</span>
<span class="cp">#define FDPOLLDRVSTAT _IOR(2, 0x13, struct floppy_drive_struct)</span>
<span class="cm">/* get drive state: GET returns the cached state, POLL polls for new state */</span>


<span class="cm">/*</span>
<span class="cm"> * reset FDC</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">reset_mode</span> <span class="p">{</span>
	<span class="n">FD_RESET_IF_NEEDED</span><span class="p">,</span>	<span class="cm">/* reset only if the reset flags is set */</span>
	<span class="n">FD_RESET_IF_RAWCMD</span><span class="p">,</span>	<span class="cm">/* obsolete */</span>
	<span class="n">FD_RESET_ALWAYS</span>		<span class="cm">/* reset always */</span>
<span class="p">};</span>
<span class="cp">#define FDRESET _IO(2, 0x54)</span>


<span class="cm">/*</span>
<span class="cm"> * FDC state</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">floppy_fdc_state</span> <span class="p">{</span>	
	<span class="kt">int</span> <span class="n">spec1</span><span class="p">;</span>		<span class="cm">/* spec1 value last used */</span>
	<span class="kt">int</span> <span class="n">spec2</span><span class="p">;</span>		<span class="cm">/* spec2 value last used */</span>
	<span class="kt">int</span> <span class="n">dtr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">version</span><span class="p">;</span>	<span class="cm">/* FDC version code */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>	<span class="cm">/* io address */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rawcmd</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reset</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">need_configure</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">perp_mode</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">has_fifo</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">driver_version</span><span class="p">;</span>	<span class="cm">/* version code for floppy driver */</span>
<span class="cp">#define FD_DRIVER_VERSION 0x100</span>
<span class="cm">/* user programs using the floppy API should use floppy_fdc_state to</span>
<span class="cm"> * get the version number of the floppy driver that they are running</span>
<span class="cm"> * on. If this version number is bigger than the one compiled into the</span>
<span class="cm"> * user program (the FD_DRIVER_VERSION define), it should be prepared</span>
<span class="cm"> * to bigger structures</span>
<span class="cm"> */</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">track</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="cm">/* Position of the heads of the 4 units attached to this FDC,</span>
<span class="cm">	 * as stored on the FDC. In the future, the position as stored</span>
<span class="cm">	 * on the FDC might not agree with the actual physical</span>
<span class="cm">	 * position of these drive heads. By allowing such</span>
<span class="cm">	 * disagreement, it will be possible to reset the FDC without</span>
<span class="cm">	 * incurring the expensive cost of repositioning all heads.</span>
<span class="cm">	 * Right now, these positions are hard wired to 0. */</span>

<span class="p">};</span>

<span class="cp">#define FDGETFDCSTAT _IOR(2, 0x15, struct floppy_fdc_state)</span>


<span class="cm">/*</span>
<span class="cm"> * Asynchronous Write error tracking</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">floppy_write_errors</span> <span class="p">{</span>
	<span class="cm">/* Write error logging.</span>
<span class="cm">	 *</span>
<span class="cm">	 * These fields can be cleared with the FDWERRORCLR ioctl.</span>
<span class="cm">	 * Only writes that were attempted but failed due to a physical media</span>
<span class="cm">	 * error are logged.  write(2) calls that fail and return an error code</span>
<span class="cm">	 * to the user process are not counted.</span>
<span class="cm">	 */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">write_errors</span><span class="p">;</span>  <span class="cm">/* number of physical write errors </span>
<span class="cm">				     * encountered */</span>
	
	<span class="cm">/* position of first and last write errors */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_error_sector</span><span class="p">;</span>
	<span class="kt">int</span>           <span class="n">first_error_generation</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_error_sector</span><span class="p">;</span>
	<span class="kt">int</span>           <span class="n">last_error_generation</span><span class="p">;</span>
	
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">badness</span><span class="p">;</span> <span class="cm">/* highest retry count for a read or write </span>
<span class="cm">			       * operation */</span>
<span class="p">};</span>

<span class="cp">#define FDWERRORCLR  _IO(2, 0x56)</span>
<span class="cm">/* clear write error and badness information */</span>
<span class="cp">#define FDWERRORGET  _IOR(2, 0x17, struct floppy_write_errors)</span>
<span class="cm">/* get write error and badness information */</span>


<span class="cm">/*</span>
<span class="cm"> * Raw commands</span>
<span class="cm"> */</span>
<span class="cm">/* new interface flag: now we can do them in batches */</span>
<span class="cp">#define FDHAVEBATCHEDRAWCMD</span>

<span class="k">struct</span> <span class="n">floppy_raw_cmd</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#define FD_RAW_READ 1</span>
<span class="cp">#define FD_RAW_WRITE 2</span>
<span class="cp">#define FD_RAW_NO_MOTOR 4</span>
<span class="cp">#define FD_RAW_DISK_CHANGE 4 </span><span class="cm">/* out: disk change flag was set */</span><span class="cp"></span>
<span class="cp">#define FD_RAW_INTR 8    </span><span class="cm">/* wait for an interrupt */</span><span class="cp"></span>
<span class="cp">#define FD_RAW_SPIN 0x10 </span><span class="cm">/* spin up the disk for this command */</span><span class="cp"></span>
<span class="cp">#define FD_RAW_NO_MOTOR_AFTER 0x20 </span><span class="cm">/* switch the motor off after command </span>
<span class="cm">				    * completion */</span><span class="cp"></span>
<span class="cp">#define FD_RAW_NEED_DISK 0x40  </span><span class="cm">/* this command needs a disk to be present */</span><span class="cp"></span>
<span class="cp">#define FD_RAW_NEED_SEEK 0x80  </span><span class="cm">/* this command uses an implied seek (soft) */</span><span class="cp"></span>

<span class="cm">/* more &quot;in&quot; flags */</span>
<span class="cp">#define FD_RAW_MORE 0x100  </span><span class="cm">/* more records follow */</span><span class="cp"></span>
<span class="cp">#define FD_RAW_STOP_IF_FAILURE 0x200 </span><span class="cm">/* stop if we encounter a failure */</span><span class="cp"></span>
<span class="cp">#define FD_RAW_STOP_IF_SUCCESS 0x400 </span><span class="cm">/* stop if command successful */</span><span class="cp"></span>
<span class="cp">#define FD_RAW_SOFTFAILURE 0x800 </span><span class="cm">/* consider the return value for failure</span>
<span class="cm">				  * detection too */</span><span class="cp"></span>

<span class="cm">/* more &quot;out&quot; flags */</span>
<span class="cp">#define FD_RAW_FAILURE 0x10000 </span><span class="cm">/* command sent to fdc, fdc returned error */</span><span class="cp"></span>
<span class="cp">#define FD_RAW_HARDFAILURE 0x20000 </span><span class="cm">/* fdc had to be reset, or timed out */</span><span class="cp"></span>

	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kernel_data</span><span class="p">;</span> <span class="cm">/* location of data buffer in the kernel */</span>
	<span class="k">struct</span> <span class="n">floppy_raw_cmd</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> <span class="cm">/* used for chaining of raw cmd&#39;s </span>
<span class="cm">				      * within the kernel */</span>
	<span class="kt">long</span> <span class="n">length</span><span class="p">;</span> <span class="cm">/* in: length of dma transfer. out: remaining bytes */</span>
	<span class="kt">long</span> <span class="n">phys_length</span><span class="p">;</span> <span class="cm">/* physical length, if different from dma length */</span>
	<span class="kt">int</span> <span class="n">buffer_length</span><span class="p">;</span> <span class="cm">/* length of allocated buffer */</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">rate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reply_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reply</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">track</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">resultcode</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reserved2</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define FDRAWCMD _IO(2, 0x58)</span>
<span class="cm">/* send a raw command to the fdc. Structure size not included, because of</span>
<span class="cm"> * batches */</span>

<span class="cp">#define FDTWADDLE _IO(2, 0x59)</span>
<span class="cm">/* flicker motor-on bit before reading a sector. Experimental */</span>


<span class="cp">#define FDEJECT _IO(2, 0x5a)</span>
<span class="cm">/* eject the disk */</span>


<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>

<span class="k">struct</span> <span class="n">compat_floppy_struct</span> <span class="p">{</span>
	<span class="n">compat_uint_t</span>	<span class="n">size</span><span class="p">;</span>
	<span class="n">compat_uint_t</span>	<span class="n">sect</span><span class="p">;</span>
	<span class="n">compat_uint_t</span>	<span class="n">head</span><span class="p">;</span>
	<span class="n">compat_uint_t</span>	<span class="n">track</span><span class="p">;</span>
	<span class="n">compat_uint_t</span>	<span class="n">stretch</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">gap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">rate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">spec1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">fmt_gap</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">compat_caddr_t</span> <span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define FDGETPRM32 _IOR(2, 0x04, struct compat_floppy_struct)</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
