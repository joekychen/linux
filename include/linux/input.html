<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › input.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>input.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _INPUT_H</span>
<span class="cp">#define _INPUT_H</span>

<span class="cm">/*</span>
<span class="cm"> * Copyright (c) 1999-2002 Vojtech Pavlik</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;sys/time.h&gt;</span>
<span class="cp">#include &lt;sys/ioctl.h&gt;</span>
<span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The event structure itself</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">input_event</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">time</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">code</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Protocol version.</span>
<span class="cm"> */</span>

<span class="cp">#define EV_VERSION		0x010001</span>

<span class="cm">/*</span>
<span class="cm"> * IOCTLs (0x00 - 0x7f)</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">input_id</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">bustype</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">vendor</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">product</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">version</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct input_absinfo - used by EVIOCGABS/EVIOCSABS ioctls</span>
<span class="cm"> * @value: latest reported value for the axis.</span>
<span class="cm"> * @minimum: specifies minimum value for the axis.</span>
<span class="cm"> * @maximum: specifies maximum value for the axis.</span>
<span class="cm"> * @fuzz: specifies fuzz value that is used to filter noise from</span>
<span class="cm"> *	the event stream.</span>
<span class="cm"> * @flat: values that are within this value will be discarded by</span>
<span class="cm"> *	joydev interface and reported as 0 instead.</span>
<span class="cm"> * @resolution: specifies resolution for the values reported for</span>
<span class="cm"> *	the axis.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that input core does not clamp reported values to the</span>
<span class="cm"> * [minimum, maximum] limits, such task is left to userspace.</span>
<span class="cm"> *</span>
<span class="cm"> * Resolution for main axes (ABS_X, ABS_Y, ABS_Z) is reported in</span>
<span class="cm"> * units per millimeter (units/mm), resolution for rotational axes</span>
<span class="cm"> * (ABS_RX, ABS_RY, ABS_RZ) is reported in units per radian.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">input_absinfo</span> <span class="p">{</span>
	<span class="n">__s32</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">minimum</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">maximum</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">fuzz</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">flat</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">resolution</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct input_keymap_entry - used by EVIOCGKEYCODE/EVIOCSKEYCODE ioctls</span>
<span class="cm"> * @scancode: scancode represented in machine-endian form.</span>
<span class="cm"> * @len: length of the scancode that resides in @scancode buffer.</span>
<span class="cm"> * @index: index in the keymap, may be used instead of scancode</span>
<span class="cm"> * @flags: allows to specify how kernel should handle the request. For</span>
<span class="cm"> *	example, setting INPUT_KEYMAP_BY_INDEX flag indicates that kernel</span>
<span class="cm"> *	should perform lookup in keymap by @index instead of @scancode</span>
<span class="cm"> * @keycode: key code assigned to this scancode</span>
<span class="cm"> *</span>
<span class="cm"> * The structure is used to retrieve and modify keymap data. Users have</span>
<span class="cm"> * option of performing lookup either by @scancode itself or by @index</span>
<span class="cm"> * in keymap entry. EVIOCGKEYCODE will also return scancode or index</span>
<span class="cm"> * (depending on which element was used to perform lookup).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">input_keymap_entry</span> <span class="p">{</span>
<span class="cp">#define INPUT_KEYMAP_BY_INDEX	(1 &lt;&lt; 0)</span>
	<span class="n">__u8</span>  <span class="n">flags</span><span class="p">;</span>
	<span class="n">__u8</span>  <span class="n">len</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">keycode</span><span class="p">;</span>
	<span class="n">__u8</span>  <span class="n">scancode</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define EVIOCGVERSION		_IOR(&#39;E&#39;, 0x01, int)			</span><span class="cm">/* get driver version */</span><span class="cp"></span>
<span class="cp">#define EVIOCGID		_IOR(&#39;E&#39;, 0x02, struct input_id)	</span><span class="cm">/* get device ID */</span><span class="cp"></span>
<span class="cp">#define EVIOCGREP		_IOR(&#39;E&#39;, 0x03, unsigned int[2])	</span><span class="cm">/* get repeat settings */</span><span class="cp"></span>
<span class="cp">#define EVIOCSREP		_IOW(&#39;E&#39;, 0x03, unsigned int[2])	</span><span class="cm">/* set repeat settings */</span><span class="cp"></span>

<span class="cp">#define EVIOCGKEYCODE		_IOR(&#39;E&#39;, 0x04, unsigned int[2])        </span><span class="cm">/* get keycode */</span><span class="cp"></span>
<span class="cp">#define EVIOCGKEYCODE_V2	_IOR(&#39;E&#39;, 0x04, struct input_keymap_entry)</span>
<span class="cp">#define EVIOCSKEYCODE		_IOW(&#39;E&#39;, 0x04, unsigned int[2])        </span><span class="cm">/* set keycode */</span><span class="cp"></span>
<span class="cp">#define EVIOCSKEYCODE_V2	_IOW(&#39;E&#39;, 0x04, struct input_keymap_entry)</span>

<span class="cp">#define EVIOCGNAME(len)		_IOC(_IOC_READ, &#39;E&#39;, 0x06, len)		</span><span class="cm">/* get device name */</span><span class="cp"></span>
<span class="cp">#define EVIOCGPHYS(len)		_IOC(_IOC_READ, &#39;E&#39;, 0x07, len)		</span><span class="cm">/* get physical location */</span><span class="cp"></span>
<span class="cp">#define EVIOCGUNIQ(len)		_IOC(_IOC_READ, &#39;E&#39;, 0x08, len)		</span><span class="cm">/* get unique identifier */</span><span class="cp"></span>
<span class="cp">#define EVIOCGPROP(len)		_IOC(_IOC_READ, &#39;E&#39;, 0x09, len)		</span><span class="cm">/* get device properties */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * EVIOCGMTSLOTS(len) - get MT slot values</span>
<span class="cm"> *</span>
<span class="cm"> * The ioctl buffer argument should be binary equivalent to</span>
<span class="cm"> *</span>
<span class="cm"> * struct input_mt_request_layout {</span>
<span class="cm"> *	__u32 code;</span>
<span class="cm"> *	__s32 values[num_slots];</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> * where num_slots is the (arbitrary) number of MT slots to extract.</span>
<span class="cm"> *</span>
<span class="cm"> * The ioctl size argument (len) is the size of the buffer, which</span>
<span class="cm"> * should satisfy len = (num_slots + 1) * sizeof(__s32).  If len is</span>
<span class="cm"> * too small to fit all available slots, the first num_slots are</span>
<span class="cm"> * returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Before the call, code is set to the wanted ABS_MT event type. On</span>
<span class="cm"> * return, values[] is filled with the slot values for the specified</span>
<span class="cm"> * ABS_MT code.</span>
<span class="cm"> *</span>
<span class="cm"> * If the request code is not an ABS_MT value, -EINVAL is returned.</span>
<span class="cm"> */</span>
<span class="cp">#define EVIOCGMTSLOTS(len)	_IOC(_IOC_READ, &#39;E&#39;, 0x0a, len)</span>

<span class="cp">#define EVIOCGKEY(len)		_IOC(_IOC_READ, &#39;E&#39;, 0x18, len)		</span><span class="cm">/* get global key state */</span><span class="cp"></span>
<span class="cp">#define EVIOCGLED(len)		_IOC(_IOC_READ, &#39;E&#39;, 0x19, len)		</span><span class="cm">/* get all LEDs */</span><span class="cp"></span>
<span class="cp">#define EVIOCGSND(len)		_IOC(_IOC_READ, &#39;E&#39;, 0x1a, len)		</span><span class="cm">/* get all sounds status */</span><span class="cp"></span>
<span class="cp">#define EVIOCGSW(len)		_IOC(_IOC_READ, &#39;E&#39;, 0x1b, len)		</span><span class="cm">/* get all switch states */</span><span class="cp"></span>

<span class="cp">#define EVIOCGBIT(ev,len)	_IOC(_IOC_READ, &#39;E&#39;, 0x20 + (ev), len)	</span><span class="cm">/* get event bits */</span><span class="cp"></span>
<span class="cp">#define EVIOCGABS(abs)		_IOR(&#39;E&#39;, 0x40 + (abs), struct input_absinfo)	</span><span class="cm">/* get abs value/limits */</span><span class="cp"></span>
<span class="cp">#define EVIOCSABS(abs)		_IOW(&#39;E&#39;, 0xc0 + (abs), struct input_absinfo)	</span><span class="cm">/* set abs value/limits */</span><span class="cp"></span>

<span class="cp">#define EVIOCSFF		_IOC(_IOC_WRITE, &#39;E&#39;, 0x80, sizeof(struct ff_effect))	</span><span class="cm">/* send a force effect to a force feedback device */</span><span class="cp"></span>
<span class="cp">#define EVIOCRMFF		_IOW(&#39;E&#39;, 0x81, int)			</span><span class="cm">/* Erase a force effect */</span><span class="cp"></span>
<span class="cp">#define EVIOCGEFFECTS		_IOR(&#39;E&#39;, 0x84, int)			</span><span class="cm">/* Report number of effects playable at the same time */</span><span class="cp"></span>

<span class="cp">#define EVIOCGRAB		_IOW(&#39;E&#39;, 0x90, int)			</span><span class="cm">/* Grab/Release device */</span><span class="cp"></span>

<span class="cp">#define EVIOCSCLOCKID		_IOW(&#39;E&#39;, 0xa0, int)			</span><span class="cm">/* Set clockid to be used for timestamps */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Device properties and quirks</span>
<span class="cm"> */</span>

<span class="cp">#define INPUT_PROP_POINTER		0x00	</span><span class="cm">/* needs a pointer */</span><span class="cp"></span>
<span class="cp">#define INPUT_PROP_DIRECT		0x01	</span><span class="cm">/* direct input devices */</span><span class="cp"></span>
<span class="cp">#define INPUT_PROP_BUTTONPAD		0x02	</span><span class="cm">/* has button(s) under pad */</span><span class="cp"></span>
<span class="cp">#define INPUT_PROP_SEMI_MT		0x03	</span><span class="cm">/* touch rectangle only */</span><span class="cp"></span>

<span class="cp">#define INPUT_PROP_MAX			0x1f</span>
<span class="cp">#define INPUT_PROP_CNT			(INPUT_PROP_MAX + 1)</span>

<span class="cm">/*</span>
<span class="cm"> * Event types</span>
<span class="cm"> */</span>

<span class="cp">#define EV_SYN			0x00</span>
<span class="cp">#define EV_KEY			0x01</span>
<span class="cp">#define EV_REL			0x02</span>
<span class="cp">#define EV_ABS			0x03</span>
<span class="cp">#define EV_MSC			0x04</span>
<span class="cp">#define EV_SW			0x05</span>
<span class="cp">#define EV_LED			0x11</span>
<span class="cp">#define EV_SND			0x12</span>
<span class="cp">#define EV_REP			0x14</span>
<span class="cp">#define EV_FF			0x15</span>
<span class="cp">#define EV_PWR			0x16</span>
<span class="cp">#define EV_FF_STATUS		0x17</span>
<span class="cp">#define EV_MAX			0x1f</span>
<span class="cp">#define EV_CNT			(EV_MAX+1)</span>

<span class="cm">/*</span>
<span class="cm"> * Synchronization events.</span>
<span class="cm"> */</span>

<span class="cp">#define SYN_REPORT		0</span>
<span class="cp">#define SYN_CONFIG		1</span>
<span class="cp">#define SYN_MT_REPORT		2</span>
<span class="cp">#define SYN_DROPPED		3</span>

<span class="cm">/*</span>
<span class="cm"> * Keys and buttons</span>
<span class="cm"> *</span>
<span class="cm"> * Most of the keys/buttons are modeled after USB HUT 1.12</span>
<span class="cm"> * (see http://www.usb.org/developers/hidpage).</span>
<span class="cm"> * Abbreviations in the comments:</span>
<span class="cm"> * AC - Application Control</span>
<span class="cm"> * AL - Application Launch Button</span>
<span class="cm"> * SC - System Control</span>
<span class="cm"> */</span>

<span class="cp">#define KEY_RESERVED		0</span>
<span class="cp">#define KEY_ESC			1</span>
<span class="cp">#define KEY_1			2</span>
<span class="cp">#define KEY_2			3</span>
<span class="cp">#define KEY_3			4</span>
<span class="cp">#define KEY_4			5</span>
<span class="cp">#define KEY_5			6</span>
<span class="cp">#define KEY_6			7</span>
<span class="cp">#define KEY_7			8</span>
<span class="cp">#define KEY_8			9</span>
<span class="cp">#define KEY_9			10</span>
<span class="cp">#define KEY_0			11</span>
<span class="cp">#define KEY_MINUS		12</span>
<span class="cp">#define KEY_EQUAL		13</span>
<span class="cp">#define KEY_BACKSPACE		14</span>
<span class="cp">#define KEY_TAB			15</span>
<span class="cp">#define KEY_Q			16</span>
<span class="cp">#define KEY_W			17</span>
<span class="cp">#define KEY_E			18</span>
<span class="cp">#define KEY_R			19</span>
<span class="cp">#define KEY_T			20</span>
<span class="cp">#define KEY_Y			21</span>
<span class="cp">#define KEY_U			22</span>
<span class="cp">#define KEY_I			23</span>
<span class="cp">#define KEY_O			24</span>
<span class="cp">#define KEY_P			25</span>
<span class="cp">#define KEY_LEFTBRACE		26</span>
<span class="cp">#define KEY_RIGHTBRACE		27</span>
<span class="cp">#define KEY_ENTER		28</span>
<span class="cp">#define KEY_LEFTCTRL		29</span>
<span class="cp">#define KEY_A			30</span>
<span class="cp">#define KEY_S			31</span>
<span class="cp">#define KEY_D			32</span>
<span class="cp">#define KEY_F			33</span>
<span class="cp">#define KEY_G			34</span>
<span class="cp">#define KEY_H			35</span>
<span class="cp">#define KEY_J			36</span>
<span class="cp">#define KEY_K			37</span>
<span class="cp">#define KEY_L			38</span>
<span class="cp">#define KEY_SEMICOLON		39</span>
<span class="cp">#define KEY_APOSTROPHE		40</span>
<span class="cp">#define KEY_GRAVE		41</span>
<span class="cp">#define KEY_LEFTSHIFT		42</span>
<span class="cp">#define KEY_BACKSLASH		43</span>
<span class="cp">#define KEY_Z			44</span>
<span class="cp">#define KEY_X			45</span>
<span class="cp">#define KEY_C			46</span>
<span class="cp">#define KEY_V			47</span>
<span class="cp">#define KEY_B			48</span>
<span class="cp">#define KEY_N			49</span>
<span class="cp">#define KEY_M			50</span>
<span class="cp">#define KEY_COMMA		51</span>
<span class="cp">#define KEY_DOT			52</span>
<span class="cp">#define KEY_SLASH		53</span>
<span class="cp">#define KEY_RIGHTSHIFT		54</span>
<span class="cp">#define KEY_KPASTERISK		55</span>
<span class="cp">#define KEY_LEFTALT		56</span>
<span class="cp">#define KEY_SPACE		57</span>
<span class="cp">#define KEY_CAPSLOCK		58</span>
<span class="cp">#define KEY_F1			59</span>
<span class="cp">#define KEY_F2			60</span>
<span class="cp">#define KEY_F3			61</span>
<span class="cp">#define KEY_F4			62</span>
<span class="cp">#define KEY_F5			63</span>
<span class="cp">#define KEY_F6			64</span>
<span class="cp">#define KEY_F7			65</span>
<span class="cp">#define KEY_F8			66</span>
<span class="cp">#define KEY_F9			67</span>
<span class="cp">#define KEY_F10			68</span>
<span class="cp">#define KEY_NUMLOCK		69</span>
<span class="cp">#define KEY_SCROLLLOCK		70</span>
<span class="cp">#define KEY_KP7			71</span>
<span class="cp">#define KEY_KP8			72</span>
<span class="cp">#define KEY_KP9			73</span>
<span class="cp">#define KEY_KPMINUS		74</span>
<span class="cp">#define KEY_KP4			75</span>
<span class="cp">#define KEY_KP5			76</span>
<span class="cp">#define KEY_KP6			77</span>
<span class="cp">#define KEY_KPPLUS		78</span>
<span class="cp">#define KEY_KP1			79</span>
<span class="cp">#define KEY_KP2			80</span>
<span class="cp">#define KEY_KP3			81</span>
<span class="cp">#define KEY_KP0			82</span>
<span class="cp">#define KEY_KPDOT		83</span>

<span class="cp">#define KEY_ZENKAKUHANKAKU	85</span>
<span class="cp">#define KEY_102ND		86</span>
<span class="cp">#define KEY_F11			87</span>
<span class="cp">#define KEY_F12			88</span>
<span class="cp">#define KEY_RO			89</span>
<span class="cp">#define KEY_KATAKANA		90</span>
<span class="cp">#define KEY_HIRAGANA		91</span>
<span class="cp">#define KEY_HENKAN		92</span>
<span class="cp">#define KEY_KATAKANAHIRAGANA	93</span>
<span class="cp">#define KEY_MUHENKAN		94</span>
<span class="cp">#define KEY_KPJPCOMMA		95</span>
<span class="cp">#define KEY_KPENTER		96</span>
<span class="cp">#define KEY_RIGHTCTRL		97</span>
<span class="cp">#define KEY_KPSLASH		98</span>
<span class="cp">#define KEY_SYSRQ		99</span>
<span class="cp">#define KEY_RIGHTALT		100</span>
<span class="cp">#define KEY_LINEFEED		101</span>
<span class="cp">#define KEY_HOME		102</span>
<span class="cp">#define KEY_UP			103</span>
<span class="cp">#define KEY_PAGEUP		104</span>
<span class="cp">#define KEY_LEFT		105</span>
<span class="cp">#define KEY_RIGHT		106</span>
<span class="cp">#define KEY_END			107</span>
<span class="cp">#define KEY_DOWN		108</span>
<span class="cp">#define KEY_PAGEDOWN		109</span>
<span class="cp">#define KEY_INSERT		110</span>
<span class="cp">#define KEY_DELETE		111</span>
<span class="cp">#define KEY_MACRO		112</span>
<span class="cp">#define KEY_MUTE		113</span>
<span class="cp">#define KEY_VOLUMEDOWN		114</span>
<span class="cp">#define KEY_VOLUMEUP		115</span>
<span class="cp">#define KEY_POWER		116	</span><span class="cm">/* SC System Power Down */</span><span class="cp"></span>
<span class="cp">#define KEY_KPEQUAL		117</span>
<span class="cp">#define KEY_KPPLUSMINUS		118</span>
<span class="cp">#define KEY_PAUSE		119</span>
<span class="cp">#define KEY_SCALE		120	</span><span class="cm">/* AL Compiz Scale (Expose) */</span><span class="cp"></span>

<span class="cp">#define KEY_KPCOMMA		121</span>
<span class="cp">#define KEY_HANGEUL		122</span>
<span class="cp">#define KEY_HANGUEL		KEY_HANGEUL</span>
<span class="cp">#define KEY_HANJA		123</span>
<span class="cp">#define KEY_YEN			124</span>
<span class="cp">#define KEY_LEFTMETA		125</span>
<span class="cp">#define KEY_RIGHTMETA		126</span>
<span class="cp">#define KEY_COMPOSE		127</span>

<span class="cp">#define KEY_STOP		128	</span><span class="cm">/* AC Stop */</span><span class="cp"></span>
<span class="cp">#define KEY_AGAIN		129</span>
<span class="cp">#define KEY_PROPS		130	</span><span class="cm">/* AC Properties */</span><span class="cp"></span>
<span class="cp">#define KEY_UNDO		131	</span><span class="cm">/* AC Undo */</span><span class="cp"></span>
<span class="cp">#define KEY_FRONT		132</span>
<span class="cp">#define KEY_COPY		133	</span><span class="cm">/* AC Copy */</span><span class="cp"></span>
<span class="cp">#define KEY_OPEN		134	</span><span class="cm">/* AC Open */</span><span class="cp"></span>
<span class="cp">#define KEY_PASTE		135	</span><span class="cm">/* AC Paste */</span><span class="cp"></span>
<span class="cp">#define KEY_FIND		136	</span><span class="cm">/* AC Search */</span><span class="cp"></span>
<span class="cp">#define KEY_CUT			137	</span><span class="cm">/* AC Cut */</span><span class="cp"></span>
<span class="cp">#define KEY_HELP		138	</span><span class="cm">/* AL Integrated Help Center */</span><span class="cp"></span>
<span class="cp">#define KEY_MENU		139	</span><span class="cm">/* Menu (show menu) */</span><span class="cp"></span>
<span class="cp">#define KEY_CALC		140	</span><span class="cm">/* AL Calculator */</span><span class="cp"></span>
<span class="cp">#define KEY_SETUP		141</span>
<span class="cp">#define KEY_SLEEP		142	</span><span class="cm">/* SC System Sleep */</span><span class="cp"></span>
<span class="cp">#define KEY_WAKEUP		143	</span><span class="cm">/* System Wake Up */</span><span class="cp"></span>
<span class="cp">#define KEY_FILE		144	</span><span class="cm">/* AL Local Machine Browser */</span><span class="cp"></span>
<span class="cp">#define KEY_SENDFILE		145</span>
<span class="cp">#define KEY_DELETEFILE		146</span>
<span class="cp">#define KEY_XFER		147</span>
<span class="cp">#define KEY_PROG1		148</span>
<span class="cp">#define KEY_PROG2		149</span>
<span class="cp">#define KEY_WWW			150	</span><span class="cm">/* AL Internet Browser */</span><span class="cp"></span>
<span class="cp">#define KEY_MSDOS		151</span>
<span class="cp">#define KEY_COFFEE		152	</span><span class="cm">/* AL Terminal Lock/Screensaver */</span><span class="cp"></span>
<span class="cp">#define KEY_SCREENLOCK		KEY_COFFEE</span>
<span class="cp">#define KEY_DIRECTION		153</span>
<span class="cp">#define KEY_CYCLEWINDOWS	154</span>
<span class="cp">#define KEY_MAIL		155</span>
<span class="cp">#define KEY_BOOKMARKS		156	</span><span class="cm">/* AC Bookmarks */</span><span class="cp"></span>
<span class="cp">#define KEY_COMPUTER		157</span>
<span class="cp">#define KEY_BACK		158	</span><span class="cm">/* AC Back */</span><span class="cp"></span>
<span class="cp">#define KEY_FORWARD		159	</span><span class="cm">/* AC Forward */</span><span class="cp"></span>
<span class="cp">#define KEY_CLOSECD		160</span>
<span class="cp">#define KEY_EJECTCD		161</span>
<span class="cp">#define KEY_EJECTCLOSECD	162</span>
<span class="cp">#define KEY_NEXTSONG		163</span>
<span class="cp">#define KEY_PLAYPAUSE		164</span>
<span class="cp">#define KEY_PREVIOUSSONG	165</span>
<span class="cp">#define KEY_STOPCD		166</span>
<span class="cp">#define KEY_RECORD		167</span>
<span class="cp">#define KEY_REWIND		168</span>
<span class="cp">#define KEY_PHONE		169	</span><span class="cm">/* Media Select Telephone */</span><span class="cp"></span>
<span class="cp">#define KEY_ISO			170</span>
<span class="cp">#define KEY_CONFIG		171	</span><span class="cm">/* AL Consumer Control Configuration */</span><span class="cp"></span>
<span class="cp">#define KEY_HOMEPAGE		172	</span><span class="cm">/* AC Home */</span><span class="cp"></span>
<span class="cp">#define KEY_REFRESH		173	</span><span class="cm">/* AC Refresh */</span><span class="cp"></span>
<span class="cp">#define KEY_EXIT		174	</span><span class="cm">/* AC Exit */</span><span class="cp"></span>
<span class="cp">#define KEY_MOVE		175</span>
<span class="cp">#define KEY_EDIT		176</span>
<span class="cp">#define KEY_SCROLLUP		177</span>
<span class="cp">#define KEY_SCROLLDOWN		178</span>
<span class="cp">#define KEY_KPLEFTPAREN		179</span>
<span class="cp">#define KEY_KPRIGHTPAREN	180</span>
<span class="cp">#define KEY_NEW			181	</span><span class="cm">/* AC New */</span><span class="cp"></span>
<span class="cp">#define KEY_REDO		182	</span><span class="cm">/* AC Redo/Repeat */</span><span class="cp"></span>

<span class="cp">#define KEY_F13			183</span>
<span class="cp">#define KEY_F14			184</span>
<span class="cp">#define KEY_F15			185</span>
<span class="cp">#define KEY_F16			186</span>
<span class="cp">#define KEY_F17			187</span>
<span class="cp">#define KEY_F18			188</span>
<span class="cp">#define KEY_F19			189</span>
<span class="cp">#define KEY_F20			190</span>
<span class="cp">#define KEY_F21			191</span>
<span class="cp">#define KEY_F22			192</span>
<span class="cp">#define KEY_F23			193</span>
<span class="cp">#define KEY_F24			194</span>

<span class="cp">#define KEY_PLAYCD		200</span>
<span class="cp">#define KEY_PAUSECD		201</span>
<span class="cp">#define KEY_PROG3		202</span>
<span class="cp">#define KEY_PROG4		203</span>
<span class="cp">#define KEY_DASHBOARD		204	</span><span class="cm">/* AL Dashboard */</span><span class="cp"></span>
<span class="cp">#define KEY_SUSPEND		205</span>
<span class="cp">#define KEY_CLOSE		206	</span><span class="cm">/* AC Close */</span><span class="cp"></span>
<span class="cp">#define KEY_PLAY		207</span>
<span class="cp">#define KEY_FASTFORWARD		208</span>
<span class="cp">#define KEY_BASSBOOST		209</span>
<span class="cp">#define KEY_PRINT		210	</span><span class="cm">/* AC Print */</span><span class="cp"></span>
<span class="cp">#define KEY_HP			211</span>
<span class="cp">#define KEY_CAMERA		212</span>
<span class="cp">#define KEY_SOUND		213</span>
<span class="cp">#define KEY_QUESTION		214</span>
<span class="cp">#define KEY_EMAIL		215</span>
<span class="cp">#define KEY_CHAT		216</span>
<span class="cp">#define KEY_SEARCH		217</span>
<span class="cp">#define KEY_CONNECT		218</span>
<span class="cp">#define KEY_FINANCE		219	</span><span class="cm">/* AL Checkbook/Finance */</span><span class="cp"></span>
<span class="cp">#define KEY_SPORT		220</span>
<span class="cp">#define KEY_SHOP		221</span>
<span class="cp">#define KEY_ALTERASE		222</span>
<span class="cp">#define KEY_CANCEL		223	</span><span class="cm">/* AC Cancel */</span><span class="cp"></span>
<span class="cp">#define KEY_BRIGHTNESSDOWN	224</span>
<span class="cp">#define KEY_BRIGHTNESSUP	225</span>
<span class="cp">#define KEY_MEDIA		226</span>

<span class="cp">#define KEY_SWITCHVIDEOMODE	227	</span><span class="cm">/* Cycle between available video</span>
<span class="cm">					   outputs (Monitor/LCD/TV-out/etc) */</span><span class="cp"></span>
<span class="cp">#define KEY_KBDILLUMTOGGLE	228</span>
<span class="cp">#define KEY_KBDILLUMDOWN	229</span>
<span class="cp">#define KEY_KBDILLUMUP		230</span>

<span class="cp">#define KEY_SEND		231	</span><span class="cm">/* AC Send */</span><span class="cp"></span>
<span class="cp">#define KEY_REPLY		232	</span><span class="cm">/* AC Reply */</span><span class="cp"></span>
<span class="cp">#define KEY_FORWARDMAIL		233	</span><span class="cm">/* AC Forward Msg */</span><span class="cp"></span>
<span class="cp">#define KEY_SAVE		234	</span><span class="cm">/* AC Save */</span><span class="cp"></span>
<span class="cp">#define KEY_DOCUMENTS		235</span>

<span class="cp">#define KEY_BATTERY		236</span>

<span class="cp">#define KEY_BLUETOOTH		237</span>
<span class="cp">#define KEY_WLAN		238</span>
<span class="cp">#define KEY_UWB			239</span>

<span class="cp">#define KEY_UNKNOWN		240</span>

<span class="cp">#define KEY_VIDEO_NEXT		241	</span><span class="cm">/* drive next video source */</span><span class="cp"></span>
<span class="cp">#define KEY_VIDEO_PREV		242	</span><span class="cm">/* drive previous video source */</span><span class="cp"></span>
<span class="cp">#define KEY_BRIGHTNESS_CYCLE	243	</span><span class="cm">/* brightness up, after max is min */</span><span class="cp"></span>
<span class="cp">#define KEY_BRIGHTNESS_ZERO	244	</span><span class="cm">/* brightness off, use ambient */</span><span class="cp"></span>
<span class="cp">#define KEY_DISPLAY_OFF		245	</span><span class="cm">/* display device to off state */</span><span class="cp"></span>

<span class="cp">#define KEY_WIMAX		246</span>
<span class="cp">#define KEY_RFKILL		247	</span><span class="cm">/* Key that controls all radios */</span><span class="cp"></span>

<span class="cp">#define KEY_MICMUTE		248	</span><span class="cm">/* Mute / unmute the microphone */</span><span class="cp"></span>

<span class="cm">/* Code 255 is reserved for special needs of AT keyboard driver */</span>

<span class="cp">#define BTN_MISC		0x100</span>
<span class="cp">#define BTN_0			0x100</span>
<span class="cp">#define BTN_1			0x101</span>
<span class="cp">#define BTN_2			0x102</span>
<span class="cp">#define BTN_3			0x103</span>
<span class="cp">#define BTN_4			0x104</span>
<span class="cp">#define BTN_5			0x105</span>
<span class="cp">#define BTN_6			0x106</span>
<span class="cp">#define BTN_7			0x107</span>
<span class="cp">#define BTN_8			0x108</span>
<span class="cp">#define BTN_9			0x109</span>

<span class="cp">#define BTN_MOUSE		0x110</span>
<span class="cp">#define BTN_LEFT		0x110</span>
<span class="cp">#define BTN_RIGHT		0x111</span>
<span class="cp">#define BTN_MIDDLE		0x112</span>
<span class="cp">#define BTN_SIDE		0x113</span>
<span class="cp">#define BTN_EXTRA		0x114</span>
<span class="cp">#define BTN_FORWARD		0x115</span>
<span class="cp">#define BTN_BACK		0x116</span>
<span class="cp">#define BTN_TASK		0x117</span>

<span class="cp">#define BTN_JOYSTICK		0x120</span>
<span class="cp">#define BTN_TRIGGER		0x120</span>
<span class="cp">#define BTN_THUMB		0x121</span>
<span class="cp">#define BTN_THUMB2		0x122</span>
<span class="cp">#define BTN_TOP			0x123</span>
<span class="cp">#define BTN_TOP2		0x124</span>
<span class="cp">#define BTN_PINKIE		0x125</span>
<span class="cp">#define BTN_BASE		0x126</span>
<span class="cp">#define BTN_BASE2		0x127</span>
<span class="cp">#define BTN_BASE3		0x128</span>
<span class="cp">#define BTN_BASE4		0x129</span>
<span class="cp">#define BTN_BASE5		0x12a</span>
<span class="cp">#define BTN_BASE6		0x12b</span>
<span class="cp">#define BTN_DEAD		0x12f</span>

<span class="cp">#define BTN_GAMEPAD		0x130</span>
<span class="cp">#define BTN_A			0x130</span>
<span class="cp">#define BTN_B			0x131</span>
<span class="cp">#define BTN_C			0x132</span>
<span class="cp">#define BTN_X			0x133</span>
<span class="cp">#define BTN_Y			0x134</span>
<span class="cp">#define BTN_Z			0x135</span>
<span class="cp">#define BTN_TL			0x136</span>
<span class="cp">#define BTN_TR			0x137</span>
<span class="cp">#define BTN_TL2			0x138</span>
<span class="cp">#define BTN_TR2			0x139</span>
<span class="cp">#define BTN_SELECT		0x13a</span>
<span class="cp">#define BTN_START		0x13b</span>
<span class="cp">#define BTN_MODE		0x13c</span>
<span class="cp">#define BTN_THUMBL		0x13d</span>
<span class="cp">#define BTN_THUMBR		0x13e</span>

<span class="cp">#define BTN_DIGI		0x140</span>
<span class="cp">#define BTN_TOOL_PEN		0x140</span>
<span class="cp">#define BTN_TOOL_RUBBER		0x141</span>
<span class="cp">#define BTN_TOOL_BRUSH		0x142</span>
<span class="cp">#define BTN_TOOL_PENCIL		0x143</span>
<span class="cp">#define BTN_TOOL_AIRBRUSH	0x144</span>
<span class="cp">#define BTN_TOOL_FINGER		0x145</span>
<span class="cp">#define BTN_TOOL_MOUSE		0x146</span>
<span class="cp">#define BTN_TOOL_LENS		0x147</span>
<span class="cp">#define BTN_TOOL_QUINTTAP	0x148	</span><span class="cm">/* Five fingers on trackpad */</span><span class="cp"></span>
<span class="cp">#define BTN_TOUCH		0x14a</span>
<span class="cp">#define BTN_STYLUS		0x14b</span>
<span class="cp">#define BTN_STYLUS2		0x14c</span>
<span class="cp">#define BTN_TOOL_DOUBLETAP	0x14d</span>
<span class="cp">#define BTN_TOOL_TRIPLETAP	0x14e</span>
<span class="cp">#define BTN_TOOL_QUADTAP	0x14f	</span><span class="cm">/* Four fingers on trackpad */</span><span class="cp"></span>

<span class="cp">#define BTN_WHEEL		0x150</span>
<span class="cp">#define BTN_GEAR_DOWN		0x150</span>
<span class="cp">#define BTN_GEAR_UP		0x151</span>

<span class="cp">#define KEY_OK			0x160</span>
<span class="cp">#define KEY_SELECT		0x161</span>
<span class="cp">#define KEY_GOTO		0x162</span>
<span class="cp">#define KEY_CLEAR		0x163</span>
<span class="cp">#define KEY_POWER2		0x164</span>
<span class="cp">#define KEY_OPTION		0x165</span>
<span class="cp">#define KEY_INFO		0x166	</span><span class="cm">/* AL OEM Features/Tips/Tutorial */</span><span class="cp"></span>
<span class="cp">#define KEY_TIME		0x167</span>
<span class="cp">#define KEY_VENDOR		0x168</span>
<span class="cp">#define KEY_ARCHIVE		0x169</span>
<span class="cp">#define KEY_PROGRAM		0x16a	</span><span class="cm">/* Media Select Program Guide */</span><span class="cp"></span>
<span class="cp">#define KEY_CHANNEL		0x16b</span>
<span class="cp">#define KEY_FAVORITES		0x16c</span>
<span class="cp">#define KEY_EPG			0x16d</span>
<span class="cp">#define KEY_PVR			0x16e	</span><span class="cm">/* Media Select Home */</span><span class="cp"></span>
<span class="cp">#define KEY_MHP			0x16f</span>
<span class="cp">#define KEY_LANGUAGE		0x170</span>
<span class="cp">#define KEY_TITLE		0x171</span>
<span class="cp">#define KEY_SUBTITLE		0x172</span>
<span class="cp">#define KEY_ANGLE		0x173</span>
<span class="cp">#define KEY_ZOOM		0x174</span>
<span class="cp">#define KEY_MODE		0x175</span>
<span class="cp">#define KEY_KEYBOARD		0x176</span>
<span class="cp">#define KEY_SCREEN		0x177</span>
<span class="cp">#define KEY_PC			0x178	</span><span class="cm">/* Media Select Computer */</span><span class="cp"></span>
<span class="cp">#define KEY_TV			0x179	</span><span class="cm">/* Media Select TV */</span><span class="cp"></span>
<span class="cp">#define KEY_TV2			0x17a	</span><span class="cm">/* Media Select Cable */</span><span class="cp"></span>
<span class="cp">#define KEY_VCR			0x17b	</span><span class="cm">/* Media Select VCR */</span><span class="cp"></span>
<span class="cp">#define KEY_VCR2		0x17c	</span><span class="cm">/* VCR Plus */</span><span class="cp"></span>
<span class="cp">#define KEY_SAT			0x17d	</span><span class="cm">/* Media Select Satellite */</span><span class="cp"></span>
<span class="cp">#define KEY_SAT2		0x17e</span>
<span class="cp">#define KEY_CD			0x17f	</span><span class="cm">/* Media Select CD */</span><span class="cp"></span>
<span class="cp">#define KEY_TAPE		0x180	</span><span class="cm">/* Media Select Tape */</span><span class="cp"></span>
<span class="cp">#define KEY_RADIO		0x181</span>
<span class="cp">#define KEY_TUNER		0x182	</span><span class="cm">/* Media Select Tuner */</span><span class="cp"></span>
<span class="cp">#define KEY_PLAYER		0x183</span>
<span class="cp">#define KEY_TEXT		0x184</span>
<span class="cp">#define KEY_DVD			0x185	</span><span class="cm">/* Media Select DVD */</span><span class="cp"></span>
<span class="cp">#define KEY_AUX			0x186</span>
<span class="cp">#define KEY_MP3			0x187</span>
<span class="cp">#define KEY_AUDIO		0x188	</span><span class="cm">/* AL Audio Browser */</span><span class="cp"></span>
<span class="cp">#define KEY_VIDEO		0x189	</span><span class="cm">/* AL Movie Browser */</span><span class="cp"></span>
<span class="cp">#define KEY_DIRECTORY		0x18a</span>
<span class="cp">#define KEY_LIST		0x18b</span>
<span class="cp">#define KEY_MEMO		0x18c	</span><span class="cm">/* Media Select Messages */</span><span class="cp"></span>
<span class="cp">#define KEY_CALENDAR		0x18d</span>
<span class="cp">#define KEY_RED			0x18e</span>
<span class="cp">#define KEY_GREEN		0x18f</span>
<span class="cp">#define KEY_YELLOW		0x190</span>
<span class="cp">#define KEY_BLUE		0x191</span>
<span class="cp">#define KEY_CHANNELUP		0x192	</span><span class="cm">/* Channel Increment */</span><span class="cp"></span>
<span class="cp">#define KEY_CHANNELDOWN		0x193	</span><span class="cm">/* Channel Decrement */</span><span class="cp"></span>
<span class="cp">#define KEY_FIRST		0x194</span>
<span class="cp">#define KEY_LAST		0x195	</span><span class="cm">/* Recall Last */</span><span class="cp"></span>
<span class="cp">#define KEY_AB			0x196</span>
<span class="cp">#define KEY_NEXT		0x197</span>
<span class="cp">#define KEY_RESTART		0x198</span>
<span class="cp">#define KEY_SLOW		0x199</span>
<span class="cp">#define KEY_SHUFFLE		0x19a</span>
<span class="cp">#define KEY_BREAK		0x19b</span>
<span class="cp">#define KEY_PREVIOUS		0x19c</span>
<span class="cp">#define KEY_DIGITS		0x19d</span>
<span class="cp">#define KEY_TEEN		0x19e</span>
<span class="cp">#define KEY_TWEN		0x19f</span>
<span class="cp">#define KEY_VIDEOPHONE		0x1a0	</span><span class="cm">/* Media Select Video Phone */</span><span class="cp"></span>
<span class="cp">#define KEY_GAMES		0x1a1	</span><span class="cm">/* Media Select Games */</span><span class="cp"></span>
<span class="cp">#define KEY_ZOOMIN		0x1a2	</span><span class="cm">/* AC Zoom In */</span><span class="cp"></span>
<span class="cp">#define KEY_ZOOMOUT		0x1a3	</span><span class="cm">/* AC Zoom Out */</span><span class="cp"></span>
<span class="cp">#define KEY_ZOOMRESET		0x1a4	</span><span class="cm">/* AC Zoom */</span><span class="cp"></span>
<span class="cp">#define KEY_WORDPROCESSOR	0x1a5	</span><span class="cm">/* AL Word Processor */</span><span class="cp"></span>
<span class="cp">#define KEY_EDITOR		0x1a6	</span><span class="cm">/* AL Text Editor */</span><span class="cp"></span>
<span class="cp">#define KEY_SPREADSHEET		0x1a7	</span><span class="cm">/* AL Spreadsheet */</span><span class="cp"></span>
<span class="cp">#define KEY_GRAPHICSEDITOR	0x1a8	</span><span class="cm">/* AL Graphics Editor */</span><span class="cp"></span>
<span class="cp">#define KEY_PRESENTATION	0x1a9	</span><span class="cm">/* AL Presentation App */</span><span class="cp"></span>
<span class="cp">#define KEY_DATABASE		0x1aa	</span><span class="cm">/* AL Database App */</span><span class="cp"></span>
<span class="cp">#define KEY_NEWS		0x1ab	</span><span class="cm">/* AL Newsreader */</span><span class="cp"></span>
<span class="cp">#define KEY_VOICEMAIL		0x1ac	</span><span class="cm">/* AL Voicemail */</span><span class="cp"></span>
<span class="cp">#define KEY_ADDRESSBOOK		0x1ad	</span><span class="cm">/* AL Contacts/Address Book */</span><span class="cp"></span>
<span class="cp">#define KEY_MESSENGER		0x1ae	</span><span class="cm">/* AL Instant Messaging */</span><span class="cp"></span>
<span class="cp">#define KEY_DISPLAYTOGGLE	0x1af	</span><span class="cm">/* Turn display (LCD) on and off */</span><span class="cp"></span>
<span class="cp">#define KEY_SPELLCHECK		0x1b0   </span><span class="cm">/* AL Spell Check */</span><span class="cp"></span>
<span class="cp">#define KEY_LOGOFF		0x1b1   </span><span class="cm">/* AL Logoff */</span><span class="cp"></span>

<span class="cp">#define KEY_DOLLAR		0x1b2</span>
<span class="cp">#define KEY_EURO		0x1b3</span>

<span class="cp">#define KEY_FRAMEBACK		0x1b4	</span><span class="cm">/* Consumer - transport controls */</span><span class="cp"></span>
<span class="cp">#define KEY_FRAMEFORWARD	0x1b5</span>
<span class="cp">#define KEY_CONTEXT_MENU	0x1b6	</span><span class="cm">/* GenDesc - system context menu */</span><span class="cp"></span>
<span class="cp">#define KEY_MEDIA_REPEAT	0x1b7	</span><span class="cm">/* Consumer - transport control */</span><span class="cp"></span>
<span class="cp">#define KEY_10CHANNELSUP	0x1b8	</span><span class="cm">/* 10 channels up (10+) */</span><span class="cp"></span>
<span class="cp">#define KEY_10CHANNELSDOWN	0x1b9	</span><span class="cm">/* 10 channels down (10-) */</span><span class="cp"></span>
<span class="cp">#define KEY_IMAGES		0x1ba	</span><span class="cm">/* AL Image Browser */</span><span class="cp"></span>

<span class="cp">#define KEY_DEL_EOL		0x1c0</span>
<span class="cp">#define KEY_DEL_EOS		0x1c1</span>
<span class="cp">#define KEY_INS_LINE		0x1c2</span>
<span class="cp">#define KEY_DEL_LINE		0x1c3</span>

<span class="cp">#define KEY_FN			0x1d0</span>
<span class="cp">#define KEY_FN_ESC		0x1d1</span>
<span class="cp">#define KEY_FN_F1		0x1d2</span>
<span class="cp">#define KEY_FN_F2		0x1d3</span>
<span class="cp">#define KEY_FN_F3		0x1d4</span>
<span class="cp">#define KEY_FN_F4		0x1d5</span>
<span class="cp">#define KEY_FN_F5		0x1d6</span>
<span class="cp">#define KEY_FN_F6		0x1d7</span>
<span class="cp">#define KEY_FN_F7		0x1d8</span>
<span class="cp">#define KEY_FN_F8		0x1d9</span>
<span class="cp">#define KEY_FN_F9		0x1da</span>
<span class="cp">#define KEY_FN_F10		0x1db</span>
<span class="cp">#define KEY_FN_F11		0x1dc</span>
<span class="cp">#define KEY_FN_F12		0x1dd</span>
<span class="cp">#define KEY_FN_1		0x1de</span>
<span class="cp">#define KEY_FN_2		0x1df</span>
<span class="cp">#define KEY_FN_D		0x1e0</span>
<span class="cp">#define KEY_FN_E		0x1e1</span>
<span class="cp">#define KEY_FN_F		0x1e2</span>
<span class="cp">#define KEY_FN_S		0x1e3</span>
<span class="cp">#define KEY_FN_B		0x1e4</span>

<span class="cp">#define KEY_BRL_DOT1		0x1f1</span>
<span class="cp">#define KEY_BRL_DOT2		0x1f2</span>
<span class="cp">#define KEY_BRL_DOT3		0x1f3</span>
<span class="cp">#define KEY_BRL_DOT4		0x1f4</span>
<span class="cp">#define KEY_BRL_DOT5		0x1f5</span>
<span class="cp">#define KEY_BRL_DOT6		0x1f6</span>
<span class="cp">#define KEY_BRL_DOT7		0x1f7</span>
<span class="cp">#define KEY_BRL_DOT8		0x1f8</span>
<span class="cp">#define KEY_BRL_DOT9		0x1f9</span>
<span class="cp">#define KEY_BRL_DOT10		0x1fa</span>

<span class="cp">#define KEY_NUMERIC_0		0x200	</span><span class="cm">/* used by phones, remote controls, */</span><span class="cp"></span>
<span class="cp">#define KEY_NUMERIC_1		0x201	</span><span class="cm">/* and other keypads */</span><span class="cp"></span>
<span class="cp">#define KEY_NUMERIC_2		0x202</span>
<span class="cp">#define KEY_NUMERIC_3		0x203</span>
<span class="cp">#define KEY_NUMERIC_4		0x204</span>
<span class="cp">#define KEY_NUMERIC_5		0x205</span>
<span class="cp">#define KEY_NUMERIC_6		0x206</span>
<span class="cp">#define KEY_NUMERIC_7		0x207</span>
<span class="cp">#define KEY_NUMERIC_8		0x208</span>
<span class="cp">#define KEY_NUMERIC_9		0x209</span>
<span class="cp">#define KEY_NUMERIC_STAR	0x20a</span>
<span class="cp">#define KEY_NUMERIC_POUND	0x20b</span>

<span class="cp">#define KEY_CAMERA_FOCUS	0x210</span>
<span class="cp">#define KEY_WPS_BUTTON		0x211	</span><span class="cm">/* WiFi Protected Setup key */</span><span class="cp"></span>

<span class="cp">#define KEY_TOUCHPAD_TOGGLE	0x212	</span><span class="cm">/* Request switch touchpad on or off */</span><span class="cp"></span>
<span class="cp">#define KEY_TOUCHPAD_ON		0x213</span>
<span class="cp">#define KEY_TOUCHPAD_OFF	0x214</span>

<span class="cp">#define KEY_CAMERA_ZOOMIN	0x215</span>
<span class="cp">#define KEY_CAMERA_ZOOMOUT	0x216</span>
<span class="cp">#define KEY_CAMERA_UP		0x217</span>
<span class="cp">#define KEY_CAMERA_DOWN		0x218</span>
<span class="cp">#define KEY_CAMERA_LEFT		0x219</span>
<span class="cp">#define KEY_CAMERA_RIGHT	0x21a</span>

<span class="cp">#define BTN_TRIGGER_HAPPY		0x2c0</span>
<span class="cp">#define BTN_TRIGGER_HAPPY1		0x2c0</span>
<span class="cp">#define BTN_TRIGGER_HAPPY2		0x2c1</span>
<span class="cp">#define BTN_TRIGGER_HAPPY3		0x2c2</span>
<span class="cp">#define BTN_TRIGGER_HAPPY4		0x2c3</span>
<span class="cp">#define BTN_TRIGGER_HAPPY5		0x2c4</span>
<span class="cp">#define BTN_TRIGGER_HAPPY6		0x2c5</span>
<span class="cp">#define BTN_TRIGGER_HAPPY7		0x2c6</span>
<span class="cp">#define BTN_TRIGGER_HAPPY8		0x2c7</span>
<span class="cp">#define BTN_TRIGGER_HAPPY9		0x2c8</span>
<span class="cp">#define BTN_TRIGGER_HAPPY10		0x2c9</span>
<span class="cp">#define BTN_TRIGGER_HAPPY11		0x2ca</span>
<span class="cp">#define BTN_TRIGGER_HAPPY12		0x2cb</span>
<span class="cp">#define BTN_TRIGGER_HAPPY13		0x2cc</span>
<span class="cp">#define BTN_TRIGGER_HAPPY14		0x2cd</span>
<span class="cp">#define BTN_TRIGGER_HAPPY15		0x2ce</span>
<span class="cp">#define BTN_TRIGGER_HAPPY16		0x2cf</span>
<span class="cp">#define BTN_TRIGGER_HAPPY17		0x2d0</span>
<span class="cp">#define BTN_TRIGGER_HAPPY18		0x2d1</span>
<span class="cp">#define BTN_TRIGGER_HAPPY19		0x2d2</span>
<span class="cp">#define BTN_TRIGGER_HAPPY20		0x2d3</span>
<span class="cp">#define BTN_TRIGGER_HAPPY21		0x2d4</span>
<span class="cp">#define BTN_TRIGGER_HAPPY22		0x2d5</span>
<span class="cp">#define BTN_TRIGGER_HAPPY23		0x2d6</span>
<span class="cp">#define BTN_TRIGGER_HAPPY24		0x2d7</span>
<span class="cp">#define BTN_TRIGGER_HAPPY25		0x2d8</span>
<span class="cp">#define BTN_TRIGGER_HAPPY26		0x2d9</span>
<span class="cp">#define BTN_TRIGGER_HAPPY27		0x2da</span>
<span class="cp">#define BTN_TRIGGER_HAPPY28		0x2db</span>
<span class="cp">#define BTN_TRIGGER_HAPPY29		0x2dc</span>
<span class="cp">#define BTN_TRIGGER_HAPPY30		0x2dd</span>
<span class="cp">#define BTN_TRIGGER_HAPPY31		0x2de</span>
<span class="cp">#define BTN_TRIGGER_HAPPY32		0x2df</span>
<span class="cp">#define BTN_TRIGGER_HAPPY33		0x2e0</span>
<span class="cp">#define BTN_TRIGGER_HAPPY34		0x2e1</span>
<span class="cp">#define BTN_TRIGGER_HAPPY35		0x2e2</span>
<span class="cp">#define BTN_TRIGGER_HAPPY36		0x2e3</span>
<span class="cp">#define BTN_TRIGGER_HAPPY37		0x2e4</span>
<span class="cp">#define BTN_TRIGGER_HAPPY38		0x2e5</span>
<span class="cp">#define BTN_TRIGGER_HAPPY39		0x2e6</span>
<span class="cp">#define BTN_TRIGGER_HAPPY40		0x2e7</span>

<span class="cm">/* We avoid low common keys in module aliases so they don&#39;t get huge. */</span>
<span class="cp">#define KEY_MIN_INTERESTING	KEY_MUTE</span>
<span class="cp">#define KEY_MAX			0x2ff</span>
<span class="cp">#define KEY_CNT			(KEY_MAX+1)</span>

<span class="cm">/*</span>
<span class="cm"> * Relative axes</span>
<span class="cm"> */</span>

<span class="cp">#define REL_X			0x00</span>
<span class="cp">#define REL_Y			0x01</span>
<span class="cp">#define REL_Z			0x02</span>
<span class="cp">#define REL_RX			0x03</span>
<span class="cp">#define REL_RY			0x04</span>
<span class="cp">#define REL_RZ			0x05</span>
<span class="cp">#define REL_HWHEEL		0x06</span>
<span class="cp">#define REL_DIAL		0x07</span>
<span class="cp">#define REL_WHEEL		0x08</span>
<span class="cp">#define REL_MISC		0x09</span>
<span class="cp">#define REL_MAX			0x0f</span>
<span class="cp">#define REL_CNT			(REL_MAX+1)</span>

<span class="cm">/*</span>
<span class="cm"> * Absolute axes</span>
<span class="cm"> */</span>

<span class="cp">#define ABS_X			0x00</span>
<span class="cp">#define ABS_Y			0x01</span>
<span class="cp">#define ABS_Z			0x02</span>
<span class="cp">#define ABS_RX			0x03</span>
<span class="cp">#define ABS_RY			0x04</span>
<span class="cp">#define ABS_RZ			0x05</span>
<span class="cp">#define ABS_THROTTLE		0x06</span>
<span class="cp">#define ABS_RUDDER		0x07</span>
<span class="cp">#define ABS_WHEEL		0x08</span>
<span class="cp">#define ABS_GAS			0x09</span>
<span class="cp">#define ABS_BRAKE		0x0a</span>
<span class="cp">#define ABS_HAT0X		0x10</span>
<span class="cp">#define ABS_HAT0Y		0x11</span>
<span class="cp">#define ABS_HAT1X		0x12</span>
<span class="cp">#define ABS_HAT1Y		0x13</span>
<span class="cp">#define ABS_HAT2X		0x14</span>
<span class="cp">#define ABS_HAT2Y		0x15</span>
<span class="cp">#define ABS_HAT3X		0x16</span>
<span class="cp">#define ABS_HAT3Y		0x17</span>
<span class="cp">#define ABS_PRESSURE		0x18</span>
<span class="cp">#define ABS_DISTANCE		0x19</span>
<span class="cp">#define ABS_TILT_X		0x1a</span>
<span class="cp">#define ABS_TILT_Y		0x1b</span>
<span class="cp">#define ABS_TOOL_WIDTH		0x1c</span>

<span class="cp">#define ABS_VOLUME		0x20</span>

<span class="cp">#define ABS_MISC		0x28</span>

<span class="cp">#define ABS_MT_SLOT		0x2f	</span><span class="cm">/* MT slot being modified */</span><span class="cp"></span>
<span class="cp">#define ABS_MT_TOUCH_MAJOR	0x30	</span><span class="cm">/* Major axis of touching ellipse */</span><span class="cp"></span>
<span class="cp">#define ABS_MT_TOUCH_MINOR	0x31	</span><span class="cm">/* Minor axis (omit if circular) */</span><span class="cp"></span>
<span class="cp">#define ABS_MT_WIDTH_MAJOR	0x32	</span><span class="cm">/* Major axis of approaching ellipse */</span><span class="cp"></span>
<span class="cp">#define ABS_MT_WIDTH_MINOR	0x33	</span><span class="cm">/* Minor axis (omit if circular) */</span><span class="cp"></span>
<span class="cp">#define ABS_MT_ORIENTATION	0x34	</span><span class="cm">/* Ellipse orientation */</span><span class="cp"></span>
<span class="cp">#define ABS_MT_POSITION_X	0x35	</span><span class="cm">/* Center X ellipse position */</span><span class="cp"></span>
<span class="cp">#define ABS_MT_POSITION_Y	0x36	</span><span class="cm">/* Center Y ellipse position */</span><span class="cp"></span>
<span class="cp">#define ABS_MT_TOOL_TYPE	0x37	</span><span class="cm">/* Type of touching device */</span><span class="cp"></span>
<span class="cp">#define ABS_MT_BLOB_ID		0x38	</span><span class="cm">/* Group a set of packets as a blob */</span><span class="cp"></span>
<span class="cp">#define ABS_MT_TRACKING_ID	0x39	</span><span class="cm">/* Unique ID of initiated contact */</span><span class="cp"></span>
<span class="cp">#define ABS_MT_PRESSURE		0x3a	</span><span class="cm">/* Pressure on contact area */</span><span class="cp"></span>
<span class="cp">#define ABS_MT_DISTANCE		0x3b	</span><span class="cm">/* Contact hover distance */</span><span class="cp"></span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cm">/* Implementation details, userspace should not care about these */</span>
<span class="cp">#define ABS_MT_FIRST		ABS_MT_TOUCH_MAJOR</span>
<span class="cp">#define ABS_MT_LAST		ABS_MT_DISTANCE</span>
<span class="cp">#endif</span>

<span class="cp">#define ABS_MAX			0x3f</span>
<span class="cp">#define ABS_CNT			(ABS_MAX+1)</span>

<span class="cm">/*</span>
<span class="cm"> * Switch events</span>
<span class="cm"> */</span>

<span class="cp">#define SW_LID			0x00  </span><span class="cm">/* set = lid shut */</span><span class="cp"></span>
<span class="cp">#define SW_TABLET_MODE		0x01  </span><span class="cm">/* set = tablet mode */</span><span class="cp"></span>
<span class="cp">#define SW_HEADPHONE_INSERT	0x02  </span><span class="cm">/* set = inserted */</span><span class="cp"></span>
<span class="cp">#define SW_RFKILL_ALL		0x03  </span><span class="cm">/* rfkill master switch, type &quot;any&quot;</span>
<span class="cm">					 set = radio enabled */</span><span class="cp"></span>
<span class="cp">#define SW_RADIO		SW_RFKILL_ALL	</span><span class="cm">/* deprecated */</span><span class="cp"></span>
<span class="cp">#define SW_MICROPHONE_INSERT	0x04  </span><span class="cm">/* set = inserted */</span><span class="cp"></span>
<span class="cp">#define SW_DOCK			0x05  </span><span class="cm">/* set = plugged into dock */</span><span class="cp"></span>
<span class="cp">#define SW_LINEOUT_INSERT	0x06  </span><span class="cm">/* set = inserted */</span><span class="cp"></span>
<span class="cp">#define SW_JACK_PHYSICAL_INSERT 0x07  </span><span class="cm">/* set = mechanical switch set */</span><span class="cp"></span>
<span class="cp">#define SW_VIDEOOUT_INSERT	0x08  </span><span class="cm">/* set = inserted */</span><span class="cp"></span>
<span class="cp">#define SW_CAMERA_LENS_COVER	0x09  </span><span class="cm">/* set = lens covered */</span><span class="cp"></span>
<span class="cp">#define SW_KEYPAD_SLIDE		0x0a  </span><span class="cm">/* set = keypad slide out */</span><span class="cp"></span>
<span class="cp">#define SW_FRONT_PROXIMITY	0x0b  </span><span class="cm">/* set = front proximity sensor active */</span><span class="cp"></span>
<span class="cp">#define SW_ROTATE_LOCK		0x0c  </span><span class="cm">/* set = rotate locked/disabled */</span><span class="cp"></span>
<span class="cp">#define SW_LINEIN_INSERT	0x0d  </span><span class="cm">/* set = inserted */</span><span class="cp"></span>
<span class="cp">#define SW_MAX			0x0f</span>
<span class="cp">#define SW_CNT			(SW_MAX+1)</span>

<span class="cm">/*</span>
<span class="cm"> * Misc events</span>
<span class="cm"> */</span>

<span class="cp">#define MSC_SERIAL		0x00</span>
<span class="cp">#define MSC_PULSELED		0x01</span>
<span class="cp">#define MSC_GESTURE		0x02</span>
<span class="cp">#define MSC_RAW			0x03</span>
<span class="cp">#define MSC_SCAN		0x04</span>
<span class="cp">#define MSC_MAX			0x07</span>
<span class="cp">#define MSC_CNT			(MSC_MAX+1)</span>

<span class="cm">/*</span>
<span class="cm"> * LEDs</span>
<span class="cm"> */</span>

<span class="cp">#define LED_NUML		0x00</span>
<span class="cp">#define LED_CAPSL		0x01</span>
<span class="cp">#define LED_SCROLLL		0x02</span>
<span class="cp">#define LED_COMPOSE		0x03</span>
<span class="cp">#define LED_KANA		0x04</span>
<span class="cp">#define LED_SLEEP		0x05</span>
<span class="cp">#define LED_SUSPEND		0x06</span>
<span class="cp">#define LED_MUTE		0x07</span>
<span class="cp">#define LED_MISC		0x08</span>
<span class="cp">#define LED_MAIL		0x09</span>
<span class="cp">#define LED_CHARGING		0x0a</span>
<span class="cp">#define LED_MAX			0x0f</span>
<span class="cp">#define LED_CNT			(LED_MAX+1)</span>

<span class="cm">/*</span>
<span class="cm"> * Autorepeat values</span>
<span class="cm"> */</span>

<span class="cp">#define REP_DELAY		0x00</span>
<span class="cp">#define REP_PERIOD		0x01</span>
<span class="cp">#define REP_MAX			0x01</span>
<span class="cp">#define REP_CNT			(REP_MAX+1)</span>

<span class="cm">/*</span>
<span class="cm"> * Sounds</span>
<span class="cm"> */</span>

<span class="cp">#define SND_CLICK		0x00</span>
<span class="cp">#define SND_BELL		0x01</span>
<span class="cp">#define SND_TONE		0x02</span>
<span class="cp">#define SND_MAX			0x07</span>
<span class="cp">#define SND_CNT			(SND_MAX+1)</span>

<span class="cm">/*</span>
<span class="cm"> * IDs.</span>
<span class="cm"> */</span>

<span class="cp">#define ID_BUS			0</span>
<span class="cp">#define ID_VENDOR		1</span>
<span class="cp">#define ID_PRODUCT		2</span>
<span class="cp">#define ID_VERSION		3</span>

<span class="cp">#define BUS_PCI			0x01</span>
<span class="cp">#define BUS_ISAPNP		0x02</span>
<span class="cp">#define BUS_USB			0x03</span>
<span class="cp">#define BUS_HIL			0x04</span>
<span class="cp">#define BUS_BLUETOOTH		0x05</span>
<span class="cp">#define BUS_VIRTUAL		0x06</span>

<span class="cp">#define BUS_ISA			0x10</span>
<span class="cp">#define BUS_I8042		0x11</span>
<span class="cp">#define BUS_XTKBD		0x12</span>
<span class="cp">#define BUS_RS232		0x13</span>
<span class="cp">#define BUS_GAMEPORT		0x14</span>
<span class="cp">#define BUS_PARPORT		0x15</span>
<span class="cp">#define BUS_AMIGA		0x16</span>
<span class="cp">#define BUS_ADB			0x17</span>
<span class="cp">#define BUS_I2C			0x18</span>
<span class="cp">#define BUS_HOST		0x19</span>
<span class="cp">#define BUS_GSC			0x1A</span>
<span class="cp">#define BUS_ATARI		0x1B</span>
<span class="cp">#define BUS_SPI			0x1C</span>

<span class="cm">/*</span>
<span class="cm"> * MT_TOOL types</span>
<span class="cm"> */</span>
<span class="cp">#define MT_TOOL_FINGER		0</span>
<span class="cp">#define MT_TOOL_PEN		1</span>
<span class="cp">#define MT_TOOL_MAX		1</span>

<span class="cm">/*</span>
<span class="cm"> * Values describing the status of a force-feedback effect</span>
<span class="cm"> */</span>
<span class="cp">#define FF_STATUS_STOPPED	0x00</span>
<span class="cp">#define FF_STATUS_PLAYING	0x01</span>
<span class="cp">#define FF_STATUS_MAX		0x01</span>

<span class="cm">/*</span>
<span class="cm"> * Structures used in ioctls to upload effects to a device</span>
<span class="cm"> * They are pieces of a bigger structure (called ff_effect)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * All duration values are expressed in ms. Values above 32767 ms (0x7fff)</span>
<span class="cm"> * should not be used and have unspecified results.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct ff_replay - defines scheduling of the force-feedback effect</span>
<span class="cm"> * @length: duration of the effect</span>
<span class="cm"> * @delay: delay before effect should start playing</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ff_replay</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">delay</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ff_trigger - defines what triggers the force-feedback effect</span>
<span class="cm"> * @button: number of the button triggering the effect</span>
<span class="cm"> * @interval: controls how soon the effect can be re-triggered</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ff_trigger</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">button</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">interval</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ff_envelope - generic force-feedback effect envelope</span>
<span class="cm"> * @attack_length: duration of the attack (ms)</span>
<span class="cm"> * @attack_level: level at the beginning of the attack</span>
<span class="cm"> * @fade_length: duration of fade (ms)</span>
<span class="cm"> * @fade_level: level at the end of fade</span>
<span class="cm"> *</span>
<span class="cm"> * The @attack_level and @fade_level are absolute values; when applying</span>
<span class="cm"> * envelope force-feedback core will convert to positive/negative</span>
<span class="cm"> * value based on polarity of the default level of the effect.</span>
<span class="cm"> * Valid range for the attack and fade levels is 0x0000 - 0x7fff</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ff_envelope</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">attack_length</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">attack_level</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">fade_length</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">fade_level</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ff_constant_effect - defines parameters of a constant force-feedback effect</span>
<span class="cm"> * @level: strength of the effect; may be negative</span>
<span class="cm"> * @envelope: envelope data</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ff_constant_effect</span> <span class="p">{</span>
	<span class="n">__s16</span> <span class="n">level</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ff_envelope</span> <span class="n">envelope</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ff_ramp_effect - defines parameters of a ramp force-feedback effect</span>
<span class="cm"> * @start_level: beginning strength of the effect; may be negative</span>
<span class="cm"> * @end_level: final strength of the effect; may be negative</span>
<span class="cm"> * @envelope: envelope data</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ff_ramp_effect</span> <span class="p">{</span>
	<span class="n">__s16</span> <span class="n">start_level</span><span class="p">;</span>
	<span class="n">__s16</span> <span class="n">end_level</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ff_envelope</span> <span class="n">envelope</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ff_condition_effect - defines a spring or friction force-feedback effect</span>
<span class="cm"> * @right_saturation: maximum level when joystick moved all way to the right</span>
<span class="cm"> * @left_saturation: same for the left side</span>
<span class="cm"> * @right_coeff: controls how fast the force grows when the joystick moves</span>
<span class="cm"> *	to the right</span>
<span class="cm"> * @left_coeff: same for the left side</span>
<span class="cm"> * @deadband: size of the dead zone, where no force is produced</span>
<span class="cm"> * @center: position of the dead zone</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ff_condition_effect</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">right_saturation</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">left_saturation</span><span class="p">;</span>

	<span class="n">__s16</span> <span class="n">right_coeff</span><span class="p">;</span>
	<span class="n">__s16</span> <span class="n">left_coeff</span><span class="p">;</span>

	<span class="n">__u16</span> <span class="n">deadband</span><span class="p">;</span>
	<span class="n">__s16</span> <span class="n">center</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ff_periodic_effect - defines parameters of a periodic force-feedback effect</span>
<span class="cm"> * @waveform: kind of the effect (wave)</span>
<span class="cm"> * @period: period of the wave (ms)</span>
<span class="cm"> * @magnitude: peak value</span>
<span class="cm"> * @offset: mean value of the wave (roughly)</span>
<span class="cm"> * @phase: &#39;horizontal&#39; shift</span>
<span class="cm"> * @envelope: envelope data</span>
<span class="cm"> * @custom_len: number of samples (FF_CUSTOM only)</span>
<span class="cm"> * @custom_data: buffer of samples (FF_CUSTOM only)</span>
<span class="cm"> *</span>
<span class="cm"> * Known waveforms - FF_SQUARE, FF_TRIANGLE, FF_SINE, FF_SAW_UP,</span>
<span class="cm"> * FF_SAW_DOWN, FF_CUSTOM. The exact syntax FF_CUSTOM is undefined</span>
<span class="cm"> * for the time being as no driver supports it yet.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: the data pointed by custom_data is copied by the driver.</span>
<span class="cm"> * You can therefore dispose of the memory after the upload/update.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ff_periodic_effect</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">waveform</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">period</span><span class="p">;</span>
	<span class="n">__s16</span> <span class="n">magnitude</span><span class="p">;</span>
	<span class="n">__s16</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">phase</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ff_envelope</span> <span class="n">envelope</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">custom_len</span><span class="p">;</span>
	<span class="n">__s16</span> <span class="n">__user</span> <span class="o">*</span><span class="n">custom_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ff_rumble_effect - defines parameters of a periodic force-feedback effect</span>
<span class="cm"> * @strong_magnitude: magnitude of the heavy motor</span>
<span class="cm"> * @weak_magnitude: magnitude of the light one</span>
<span class="cm"> *</span>
<span class="cm"> * Some rumble pads have two motors of different weight. Strong_magnitude</span>
<span class="cm"> * represents the magnitude of the vibration generated by the heavy one.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ff_rumble_effect</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">strong_magnitude</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">weak_magnitude</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ff_effect - defines force feedback effect</span>
<span class="cm"> * @type: type of the effect (FF_CONSTANT, FF_PERIODIC, FF_RAMP, FF_SPRING,</span>
<span class="cm"> *	FF_FRICTION, FF_DAMPER, FF_RUMBLE, FF_INERTIA, or FF_CUSTOM)</span>
<span class="cm"> * @id: an unique id assigned to an effect</span>
<span class="cm"> * @direction: direction of the effect</span>
<span class="cm"> * @trigger: trigger conditions (struct ff_trigger)</span>
<span class="cm"> * @replay: scheduling of the effect (struct ff_replay)</span>
<span class="cm"> * @u: effect-specific structure (one of ff_constant_effect, ff_ramp_effect,</span>
<span class="cm"> *	ff_periodic_effect, ff_condition_effect, ff_rumble_effect) further</span>
<span class="cm"> *	defining effect parameters</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is sent through ioctl from the application to the driver.</span>
<span class="cm"> * To create a new effect application should set its @id to -1; the kernel</span>
<span class="cm"> * will return assigned @id which can later be used to update or delete</span>
<span class="cm"> * this effect.</span>
<span class="cm"> *</span>
<span class="cm"> * Direction of the effect is encoded as follows:</span>
<span class="cm"> *	0 deg -&gt; 0x0000 (down)</span>
<span class="cm"> *	90 deg -&gt; 0x4000 (left)</span>
<span class="cm"> *	180 deg -&gt; 0x8000 (up)</span>
<span class="cm"> *	270 deg -&gt; 0xC000 (right)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ff_effect</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__s16</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">direction</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ff_trigger</span> <span class="n">trigger</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ff_replay</span> <span class="n">replay</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ff_constant_effect</span> <span class="n">constant</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ff_ramp_effect</span> <span class="n">ramp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ff_periodic_effect</span> <span class="n">periodic</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ff_condition_effect</span> <span class="n">condition</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/* One for each axis */</span>
		<span class="k">struct</span> <span class="n">ff_rumble_effect</span> <span class="n">rumble</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Force feedback effect types</span>
<span class="cm"> */</span>

<span class="cp">#define FF_RUMBLE	0x50</span>
<span class="cp">#define FF_PERIODIC	0x51</span>
<span class="cp">#define FF_CONSTANT	0x52</span>
<span class="cp">#define FF_SPRING	0x53</span>
<span class="cp">#define FF_FRICTION	0x54</span>
<span class="cp">#define FF_DAMPER	0x55</span>
<span class="cp">#define FF_INERTIA	0x56</span>
<span class="cp">#define FF_RAMP		0x57</span>

<span class="cp">#define FF_EFFECT_MIN	FF_RUMBLE</span>
<span class="cp">#define FF_EFFECT_MAX	FF_RAMP</span>

<span class="cm">/*</span>
<span class="cm"> * Force feedback periodic effect types</span>
<span class="cm"> */</span>

<span class="cp">#define FF_SQUARE	0x58</span>
<span class="cp">#define FF_TRIANGLE	0x59</span>
<span class="cp">#define FF_SINE		0x5a</span>
<span class="cp">#define FF_SAW_UP	0x5b</span>
<span class="cp">#define FF_SAW_DOWN	0x5c</span>
<span class="cp">#define FF_CUSTOM	0x5d</span>

<span class="cp">#define FF_WAVEFORM_MIN	FF_SQUARE</span>
<span class="cp">#define FF_WAVEFORM_MAX	FF_CUSTOM</span>

<span class="cm">/*</span>
<span class="cm"> * Set ff device properties</span>
<span class="cm"> */</span>

<span class="cp">#define FF_GAIN		0x60</span>
<span class="cp">#define FF_AUTOCENTER	0x61</span>

<span class="cp">#define FF_MAX		0x7f</span>
<span class="cp">#define FF_CNT		(FF_MAX+1)</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/*</span>
<span class="cm"> * In-kernel definitions.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/mod_devicetable.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * struct input_dev - represents an input device</span>
<span class="cm"> * @name: name of the device</span>
<span class="cm"> * @phys: physical path to the device in the system hierarchy</span>
<span class="cm"> * @uniq: unique identification code for the device (if device has it)</span>
<span class="cm"> * @id: id of the device (struct input_id)</span>
<span class="cm"> * @propbit: bitmap of device properties and quirks</span>
<span class="cm"> * @evbit: bitmap of types of events supported by the device (EV_KEY,</span>
<span class="cm"> *	EV_REL, etc.)</span>
<span class="cm"> * @keybit: bitmap of keys/buttons this device has</span>
<span class="cm"> * @relbit: bitmap of relative axes for the device</span>
<span class="cm"> * @absbit: bitmap of absolute axes for the device</span>
<span class="cm"> * @mscbit: bitmap of miscellaneous events supported by the device</span>
<span class="cm"> * @ledbit: bitmap of leds present on the device</span>
<span class="cm"> * @sndbit: bitmap of sound effects supported by the device</span>
<span class="cm"> * @ffbit: bitmap of force feedback effects supported by the device</span>
<span class="cm"> * @swbit: bitmap of switches present on the device</span>
<span class="cm"> * @hint_events_per_packet: average number of events generated by the</span>
<span class="cm"> *	device in a packet (between EV_SYN/SYN_REPORT events). Used by</span>
<span class="cm"> *	event handlers to estimate size of the buffer needed to hold</span>
<span class="cm"> *	events.</span>
<span class="cm"> * @keycodemax: size of keycode table</span>
<span class="cm"> * @keycodesize: size of elements in keycode table</span>
<span class="cm"> * @keycode: map of scancodes to keycodes for this device</span>
<span class="cm"> * @getkeycode: optional legacy method to retrieve current keymap.</span>
<span class="cm"> * @setkeycode: optional method to alter current keymap, used to implement</span>
<span class="cm"> *	sparse keymaps. If not supplied default mechanism will be used.</span>
<span class="cm"> *	The method is being called while holding event_lock and thus must</span>
<span class="cm"> *	not sleep</span>
<span class="cm"> * @ff: force feedback structure associated with the device if device</span>
<span class="cm"> *	supports force feedback effects</span>
<span class="cm"> * @repeat_key: stores key code of the last key pressed; used to implement</span>
<span class="cm"> *	software autorepeat</span>
<span class="cm"> * @timer: timer for software autorepeat</span>
<span class="cm"> * @rep: current values for autorepeat parameters (delay, rate)</span>
<span class="cm"> * @mt: pointer to array of struct input_mt_slot holding current values</span>
<span class="cm"> *	of tracked contacts</span>
<span class="cm"> * @mtsize: number of MT slots the device uses</span>
<span class="cm"> * @slot: MT slot currently being transmitted</span>
<span class="cm"> * @trkid: stores MT tracking ID for the current contact</span>
<span class="cm"> * @absinfo: array of &amp;struct input_absinfo elements holding information</span>
<span class="cm"> *	about absolute axes (current value, min, max, flat, fuzz,</span>
<span class="cm"> *	resolution)</span>
<span class="cm"> * @key: reflects current state of device&#39;s keys/buttons</span>
<span class="cm"> * @led: reflects current state of device&#39;s LEDs</span>
<span class="cm"> * @snd: reflects current state of sound effects</span>
<span class="cm"> * @sw: reflects current state of device&#39;s switches</span>
<span class="cm"> * @open: this method is called when the very first user calls</span>
<span class="cm"> *	input_open_device(). The driver must prepare the device</span>
<span class="cm"> *	to start generating events (start polling thread,</span>
<span class="cm"> *	request an IRQ, submit URB, etc.)</span>
<span class="cm"> * @close: this method is called when the very last user calls</span>
<span class="cm"> *	input_close_device().</span>
<span class="cm"> * @flush: purges the device. Most commonly used to get rid of force</span>
<span class="cm"> *	feedback effects loaded into the device when disconnecting</span>
<span class="cm"> *	from it</span>
<span class="cm"> * @event: event handler for events sent _to_ the device, like EV_LED</span>
<span class="cm"> *	or EV_SND. The device is expected to carry out the requested</span>
<span class="cm"> *	action (turn on a LED, play sound, etc.) The call is protected</span>
<span class="cm"> *	by @event_lock and must not sleep</span>
<span class="cm"> * @grab: input handle that currently has the device grabbed (via</span>
<span class="cm"> *	EVIOCGRAB ioctl). When a handle grabs a device it becomes sole</span>
<span class="cm"> *	recipient for all input events coming from the device</span>
<span class="cm"> * @event_lock: this spinlock is is taken when input core receives</span>
<span class="cm"> *	and processes a new event for the device (in input_event()).</span>
<span class="cm"> *	Code that accesses and/or modifies parameters of a device</span>
<span class="cm"> *	(such as keymap or absmin, absmax, absfuzz, etc.) after device</span>
<span class="cm"> *	has been registered with input core must take this lock.</span>
<span class="cm"> * @mutex: serializes calls to open(), close() and flush() methods</span>
<span class="cm"> * @users: stores number of users (input handlers) that opened this</span>
<span class="cm"> *	device. It is used by input_open_device() and input_close_device()</span>
<span class="cm"> *	to make sure that dev-&gt;open() is only called when the first</span>
<span class="cm"> *	user opens device and dev-&gt;close() is called when the very</span>
<span class="cm"> *	last user closes the device</span>
<span class="cm"> * @going_away: marks devices that are in a middle of unregistering and</span>
<span class="cm"> *	causes input_open_device*() fail with -ENODEV.</span>
<span class="cm"> * @sync: set to %true when there were no new events since last EV_SYN</span>
<span class="cm"> * @dev: driver model&#39;s view of this device</span>
<span class="cm"> * @h_list: list of input handles associated with the device. When</span>
<span class="cm"> *	accessing the list dev-&gt;mutex must be held</span>
<span class="cm"> * @node: used to place the device onto input_dev_list</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">input_dev</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">phys</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uniq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">input_id</span> <span class="n">id</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">propbit</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">INPUT_PROP_CNT</span><span class="p">)];</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">evbit</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">EV_CNT</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">keybit</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">KEY_CNT</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">relbit</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">REL_CNT</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">absbit</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">ABS_CNT</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mscbit</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">MSC_CNT</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ledbit</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">LED_CNT</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sndbit</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">SND_CNT</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ffbit</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">FF_CNT</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">swbit</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">SW_CNT</span><span class="p">)];</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hint_events_per_packet</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">keycodemax</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">keycodesize</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">keycode</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">setkeycode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">input_keymap_entry</span> <span class="o">*</span><span class="n">ke</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">old_keycode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">getkeycode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">input_keymap_entry</span> <span class="o">*</span><span class="n">ke</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">ff_device</span> <span class="o">*</span><span class="n">ff</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">repeat_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">rep</span><span class="p">[</span><span class="n">REP_CNT</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">input_mt_slot</span> <span class="o">*</span><span class="n">mt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mtsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">trkid</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">input_absinfo</span> <span class="o">*</span><span class="n">absinfo</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">key</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">KEY_CNT</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">led</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">LED_CNT</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">snd</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">SND_CNT</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sw</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">SW_CNT</span><span class="p">)];</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">input_handle</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">grab</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">event_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">users</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">going_away</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">sync</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">h_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">node</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define to_input_dev(d) container_of(d, struct input_dev, dev)</span>

<span class="cm">/*</span>
<span class="cm"> * Verify that we are in sync with input_device_id mod_devicetable.h #defines</span>
<span class="cm"> */</span>

<span class="cp">#if EV_MAX != INPUT_DEVICE_ID_EV_MAX</span>
<span class="cp">#error &quot;EV_MAX and INPUT_DEVICE_ID_EV_MAX do not match&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#if KEY_MIN_INTERESTING != INPUT_DEVICE_ID_KEY_MIN_INTERESTING</span>
<span class="cp">#error &quot;KEY_MIN_INTERESTING and INPUT_DEVICE_ID_KEY_MIN_INTERESTING do not match&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#if KEY_MAX != INPUT_DEVICE_ID_KEY_MAX</span>
<span class="cp">#error &quot;KEY_MAX and INPUT_DEVICE_ID_KEY_MAX do not match&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#if REL_MAX != INPUT_DEVICE_ID_REL_MAX</span>
<span class="cp">#error &quot;REL_MAX and INPUT_DEVICE_ID_REL_MAX do not match&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#if ABS_MAX != INPUT_DEVICE_ID_ABS_MAX</span>
<span class="cp">#error &quot;ABS_MAX and INPUT_DEVICE_ID_ABS_MAX do not match&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#if MSC_MAX != INPUT_DEVICE_ID_MSC_MAX</span>
<span class="cp">#error &quot;MSC_MAX and INPUT_DEVICE_ID_MSC_MAX do not match&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#if LED_MAX != INPUT_DEVICE_ID_LED_MAX</span>
<span class="cp">#error &quot;LED_MAX and INPUT_DEVICE_ID_LED_MAX do not match&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#if SND_MAX != INPUT_DEVICE_ID_SND_MAX</span>
<span class="cp">#error &quot;SND_MAX and INPUT_DEVICE_ID_SND_MAX do not match&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#if FF_MAX != INPUT_DEVICE_ID_FF_MAX</span>
<span class="cp">#error &quot;FF_MAX and INPUT_DEVICE_ID_FF_MAX do not match&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#if SW_MAX != INPUT_DEVICE_ID_SW_MAX</span>
<span class="cp">#error &quot;SW_MAX and INPUT_DEVICE_ID_SW_MAX do not match&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#define INPUT_DEVICE_ID_MATCH_DEVICE \</span>
<span class="cp">	(INPUT_DEVICE_ID_MATCH_BUS | INPUT_DEVICE_ID_MATCH_VENDOR | INPUT_DEVICE_ID_MATCH_PRODUCT)</span>
<span class="cp">#define INPUT_DEVICE_ID_MATCH_DEVICE_AND_VERSION \</span>
<span class="cp">	(INPUT_DEVICE_ID_MATCH_DEVICE | INPUT_DEVICE_ID_MATCH_VERSION)</span>

<span class="k">struct</span> <span class="n">input_handle</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct input_handler - implements one of interfaces for input devices</span>
<span class="cm"> * @private: driver-specific data</span>
<span class="cm"> * @event: event handler. This method is being called by input core with</span>
<span class="cm"> *	interrupts disabled and dev-&gt;event_lock spinlock held and so</span>
<span class="cm"> *	it may not sleep</span>
<span class="cm"> * @filter: similar to @event; separates normal event handlers from</span>
<span class="cm"> *	&quot;filters&quot;.</span>
<span class="cm"> * @match: called after comparing device&#39;s id with handler&#39;s id_table</span>
<span class="cm"> *	to perform fine-grained matching between device and handler</span>
<span class="cm"> * @connect: called when attaching a handler to an input device</span>
<span class="cm"> * @disconnect: disconnects a handler from input device</span>
<span class="cm"> * @start: starts handler for given handle. This function is called by</span>
<span class="cm"> *	input core right after connect() method and also when a process</span>
<span class="cm"> *	that &quot;grabbed&quot; a device releases it</span>
<span class="cm"> * @fops: file operations this driver implements</span>
<span class="cm"> * @minor: beginning of range of 32 minors for devices this driver</span>
<span class="cm"> *	can provide</span>
<span class="cm"> * @name: name of the handler, to be shown in /proc/bus/input/handlers</span>
<span class="cm"> * @id_table: pointer to a table of input_device_ids this driver can</span>
<span class="cm"> *	handle</span>
<span class="cm"> * @h_list: list of input handles associated with the handler</span>
<span class="cm"> * @node: for placing the driver onto input_handler_list</span>
<span class="cm"> *</span>
<span class="cm"> * Input handlers attach to input devices and create input handles. There</span>
<span class="cm"> * are likely several handlers attached to any given input device at the</span>
<span class="cm"> * same time. All of them will get their copy of input event generated by</span>
<span class="cm"> * the device.</span>
<span class="cm"> *</span>
<span class="cm"> * The very same structure is used to implement input filters. Input core</span>
<span class="cm"> * allows filters to run first and will not pass event to regular handlers</span>
<span class="cm"> * if any of the filters indicate that the event should be filtered (by</span>
<span class="cm"> * returning %true from their filter() method).</span>
<span class="cm"> *</span>
<span class="cm"> * Note that input core serializes calls to connect() and disconnect()</span>
<span class="cm"> * methods.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">input_handler</span> <span class="p">{</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">filter</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span> <span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span> <span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">input_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">minor</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">input_device_id</span> <span class="o">*</span><span class="n">id_table</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">h_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">node</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct input_handle - links input device with an input handler</span>
<span class="cm"> * @private: handler-specific data</span>
<span class="cm"> * @open: counter showing whether the handle is &#39;open&#39;, i.e. should deliver</span>
<span class="cm"> *	events from its device</span>
<span class="cm"> * @name: name given to the handle by handler that created it</span>
<span class="cm"> * @dev: input device the handle is attached to</span>
<span class="cm"> * @handler: handler that works with the device through this handle</span>
<span class="cm"> * @d_node: used to put the handle on device&#39;s list of attached handles</span>
<span class="cm"> * @h_node: used to put the handle on handler&#39;s list of handles from which</span>
<span class="cm"> *	it gets events</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">input_handle</span> <span class="p">{</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">open</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">input_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">d_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">h_node</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">input_allocate_device</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">input_free_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="nf">input_get_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span> <span class="o">?</span> <span class="n">to_input_dev</span><span class="p">(</span><span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">input_put_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">input_get_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">input_set_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">input_register_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">input_unregister_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">input_reset_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">input_register_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_handler</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">input_unregister_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_handler</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">input_handler_for_each_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_handler</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_handle</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">));</span>

<span class="kt">int</span> <span class="n">input_register_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_handle</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">input_unregister_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_handle</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">input_grab_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_handle</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">input_release_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_handle</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">input_open_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_handle</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">input_close_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_handle</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">input_flush_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">input_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">input_inject_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">input_report_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">input_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">EV_KEY</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="o">!!</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">input_report_rel</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">input_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">EV_REL</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">input_report_abs</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">input_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">EV_ABS</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">input_report_ff_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">input_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">EV_FF_STATUS</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">input_report_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">input_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">EV_SW</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="o">!!</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">input_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">input_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">EV_SYN</span><span class="p">,</span> <span class="n">SYN_REPORT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">input_mt_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">input_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">EV_SYN</span><span class="p">,</span> <span class="n">SYN_MT_REPORT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">input_set_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * input_set_events_per_packet - tell handlers about the driver event rate</span>
<span class="cm"> * @dev: the input device used by the driver</span>
<span class="cm"> * @n_events: the average number of events between calls to input_sync()</span>
<span class="cm"> *</span>
<span class="cm"> * If the event rate sent from a device is unusually large, use this</span>
<span class="cm"> * function to set the expected event rate. This will allow handlers</span>
<span class="cm"> * to set up an appropriate buffer size for the event stream, in order</span>
<span class="cm"> * to minimize information loss.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">input_set_events_per_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_events</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hint_events_per_packet</span> <span class="o">=</span> <span class="n">n_events</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">input_alloc_absinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">input_set_abs_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">axis</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fuzz</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flat</span><span class="p">);</span>

<span class="cp">#define INPUT_GENERATE_ABS_ACCESSORS(_suffix, _item)			\</span>
<span class="cp">static inline int input_abs_get_##_suffix(struct input_dev *dev,	\</span>
<span class="cp">					  unsigned int axis)		\</span>
<span class="cp">{									\</span>
<span class="cp">	return dev-&gt;absinfo ? dev-&gt;absinfo[axis]._item : 0;		\</span>
<span class="cp">}									\</span>
<span class="cp">									\</span>
<span class="cp">static inline void input_abs_set_##_suffix(struct input_dev *dev,	\</span>
<span class="cp">					   unsigned int axis, int val)	\</span>
<span class="cp">{									\</span>
<span class="cp">	input_alloc_absinfo(dev);					\</span>
<span class="cp">	if (dev-&gt;absinfo)						\</span>
<span class="cp">		dev-&gt;absinfo[axis]._item = val;				\</span>
<span class="cp">}</span>

<span class="n">INPUT_GENERATE_ABS_ACCESSORS</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="n">INPUT_GENERATE_ABS_ACCESSORS</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">minimum</span><span class="p">)</span>
<span class="n">INPUT_GENERATE_ABS_ACCESSORS</span><span class="p">(</span><span class="n">max</span><span class="p">,</span> <span class="n">maximum</span><span class="p">)</span>
<span class="n">INPUT_GENERATE_ABS_ACCESSORS</span><span class="p">(</span><span class="n">fuzz</span><span class="p">,</span> <span class="n">fuzz</span><span class="p">)</span>
<span class="n">INPUT_GENERATE_ABS_ACCESSORS</span><span class="p">(</span><span class="n">flat</span><span class="p">,</span> <span class="n">flat</span><span class="p">)</span>
<span class="n">INPUT_GENERATE_ABS_ACCESSORS</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>

<span class="kt">int</span> <span class="n">input_scancode_to_scalar</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">input_keymap_entry</span> <span class="o">*</span><span class="n">ke</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">scancode</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">input_get_keycode</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">input_keymap_entry</span> <span class="o">*</span><span class="n">ke</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">input_set_keycode</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">input_keymap_entry</span> <span class="o">*</span><span class="n">ke</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">class</span> <span class="n">input_class</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ff_device - force-feedback part of an input device</span>
<span class="cm"> * @upload: Called to upload an new effect into device</span>
<span class="cm"> * @erase: Called to erase an effect from device</span>
<span class="cm"> * @playback: Called to request device to start playing specified effect</span>
<span class="cm"> * @set_gain: Called to set specified gain</span>
<span class="cm"> * @set_autocenter: Called to auto-center device</span>
<span class="cm"> * @destroy: called by input core when parent input device is being</span>
<span class="cm"> *	destroyed</span>
<span class="cm"> * @private: driver-specific data, will be freed automatically</span>
<span class="cm"> * @ffbit: bitmap of force feedback capabilities truly supported by</span>
<span class="cm"> *	device (not emulated like ones in input_dev-&gt;ffbit)</span>
<span class="cm"> * @mutex: mutex for serializing access to the device</span>
<span class="cm"> * @max_effects: maximum number of effects supported by device</span>
<span class="cm"> * @effects: pointer to an array of effects currently loaded into device</span>
<span class="cm"> * @effect_owners: array of effect owners; when file handle owning</span>
<span class="cm"> *	an effect gets closed the effect is automatically erased</span>
<span class="cm"> *</span>
<span class="cm"> * Every force-feedback device must implement upload() and playback()</span>
<span class="cm"> * methods; erase() is optional. set_gain() and set_autocenter() need</span>
<span class="cm"> * only be implemented if driver sets up FF_GAIN and FF_AUTOCENTER</span>
<span class="cm"> * bits.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that playback(), set_gain() and set_autocenter() are called with</span>
<span class="cm"> * dev-&gt;event_lock spinlock held and interrupts off and thus may not</span>
<span class="cm"> * sleep.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ff_device</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">upload</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ff_effect</span> <span class="o">*</span><span class="n">effect</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ff_effect</span> <span class="o">*</span><span class="n">old</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">erase</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">effect_id</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">playback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">effect_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_gain</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">gain</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_autocenter</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">magnitude</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ff_device</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ffbit</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">FF_CNT</span><span class="p">)];</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">max_effects</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ff_effect</span> <span class="o">*</span><span class="n">effects</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">effect_owners</span><span class="p">[];</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">input_ff_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_effects</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">input_ff_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">input_ff_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">input_ff_upload</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ff_effect</span> <span class="o">*</span><span class="n">effect</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">input_ff_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">effect_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">input_ff_create_memless</span><span class="p">(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">play_effect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ff_effect</span> <span class="o">*</span><span class="p">));</span>

<span class="cp">#endif</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
