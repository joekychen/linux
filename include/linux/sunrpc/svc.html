<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › sunrpc › svc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>svc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/include/linux/sunrpc/svc.h</span>
<span class="cm"> *</span>
<span class="cm"> * RPC server declarations.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1995, 1996 Olaf Kirch &lt;okir@monad.swb.de&gt;</span>
<span class="cm"> */</span>


<span class="cp">#ifndef SUNRPC_SVC_H</span>
<span class="cp">#define SUNRPC_SVC_H</span>

<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/in6.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/types.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/xdr.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/auth.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/svcauth.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * This is the RPC server thread function prototype</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">svc_thread_fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* statistics for svc_pool structures */</span>
<span class="k">struct</span> <span class="n">svc_pool_stats</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">packets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">sockets_queued</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">threads_woken</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">threads_timedout</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * RPC service thread pool.</span>
<span class="cm"> *</span>
<span class="cm"> * Pool of threads and temporary sockets.  Generally there is only</span>
<span class="cm"> * a single one of these per RPC service, but on NUMA machines those</span>
<span class="cm"> * services that can benefit from it (i.e. nfs but not lockd) will</span>
<span class="cm"> * have one pool per NUMA node.  This optimisation reduces cross-</span>
<span class="cm"> * node traffic on multi-node NUMA NFS servers.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">svc_pool</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sp_id</span><span class="p">;</span>	    	<span class="cm">/* pool id; also node id on NUMA */</span>
	<span class="n">spinlock_t</span>		<span class="n">sp_lock</span><span class="p">;</span>	<span class="cm">/* protects all fields */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">sp_threads</span><span class="p">;</span>	<span class="cm">/* idle server threads */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">sp_sockets</span><span class="p">;</span>	<span class="cm">/* pending sockets */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sp_nrthreads</span><span class="p">;</span>	<span class="cm">/* # of threads in pool */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">sp_all_threads</span><span class="p">;</span>	<span class="cm">/* all server threads */</span>
	<span class="k">struct</span> <span class="n">svc_pool_stats</span>	<span class="n">sp_stats</span><span class="p">;</span>	<span class="cm">/* statistics on pool operation */</span>
<span class="p">}</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * RPC service.</span>
<span class="cm"> *</span>
<span class="cm"> * An RPC service is a ``daemon,&#39;&#39; possibly multithreaded, which</span>
<span class="cm"> * receives and processes incoming RPC messages.</span>
<span class="cm"> * It has one or more transport sockets associated with it, and maintains</span>
<span class="cm"> * a list of idle threads waiting for input.</span>
<span class="cm"> *</span>
<span class="cm"> * We currently do not support more than one RPC program per daemon.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">svc_serv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_program</span> <span class="o">*</span>	<span class="n">sv_program</span><span class="p">;</span>	<span class="cm">/* RPC program */</span>
	<span class="k">struct</span> <span class="n">svc_stat</span> <span class="o">*</span>	<span class="n">sv_stats</span><span class="p">;</span>	<span class="cm">/* RPC statistics */</span>
	<span class="n">spinlock_t</span>		<span class="n">sv_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sv_nrthreads</span><span class="p">;</span>	<span class="cm">/* # of server threads */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sv_maxconn</span><span class="p">;</span>	<span class="cm">/* max connections allowed or</span>
<span class="cm">						 * &#39;0&#39; causing max to be based</span>
<span class="cm">						 * on number of threads. */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sv_max_payload</span><span class="p">;</span>	<span class="cm">/* datagram payload size */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sv_max_mesg</span><span class="p">;</span>	<span class="cm">/* max_payload + 1 page for overheads */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sv_xdrsize</span><span class="p">;</span>	<span class="cm">/* XDR buffer size */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">sv_permsocks</span><span class="p">;</span>	<span class="cm">/* all permanent sockets */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">sv_tempsocks</span><span class="p">;</span>	<span class="cm">/* all temporary sockets */</span>
	<span class="kt">int</span>			<span class="n">sv_tmpcnt</span><span class="p">;</span>	<span class="cm">/* count of temporary sockets */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">sv_temptimer</span><span class="p">;</span>	<span class="cm">/* timer for aging temporary sockets */</span>

	<span class="kt">char</span> <span class="o">*</span>			<span class="n">sv_name</span><span class="p">;</span>	<span class="cm">/* service name */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sv_nrpools</span><span class="p">;</span>	<span class="cm">/* number of thread pools */</span>
	<span class="k">struct</span> <span class="n">svc_pool</span> <span class="o">*</span>	<span class="n">sv_pools</span><span class="p">;</span>	<span class="cm">/* array of thread pools */</span>

	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">sv_shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
						<span class="cm">/* Callback to use when last thread</span>
<span class="cm">						 * exits.</span>
<span class="cm">						 */</span>

	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span>		<span class="n">sv_module</span><span class="p">;</span>	<span class="cm">/* optional module to count when</span>
<span class="cm">						 * adding threads */</span>
	<span class="n">svc_thread_fn</span>		<span class="n">sv_function</span><span class="p">;</span>	<span class="cm">/* main function for threads */</span>
<span class="cp">#if defined(CONFIG_SUNRPC_BACKCHANNEL)</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">sv_cb_list</span><span class="p">;</span>	<span class="cm">/* queue for callback requests</span>
<span class="cm">						 * that arrive over the same</span>
<span class="cm">						 * connection */</span>
	<span class="n">spinlock_t</span>		<span class="n">sv_cb_lock</span><span class="p">;</span>	<span class="cm">/* protects the svc_cb_list */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">sv_cb_waitq</span><span class="p">;</span>	<span class="cm">/* sleep here if there are no</span>
<span class="cm">						 * entries in the svc_cb_list */</span>
	<span class="k">struct</span> <span class="n">svc_xprt</span>		<span class="o">*</span><span class="n">sv_bc_xprt</span><span class="p">;</span>	<span class="cm">/* callback on fore channel */</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SUNRPC_BACKCHANNEL */</span><span class="cp"></span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * We use sv_nrthreads as a reference count.  svc_destroy() drops</span>
<span class="cm"> * this refcount, so we need to bump it up around operations that</span>
<span class="cm"> * change the number of threads.  Horrible, but there it is.</span>
<span class="cm"> * Should be called with the BKL held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">svc_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum payload size supported by a kernel RPC server.</span>
<span class="cm"> * This is use to determine the max number of pages nfsd is</span>
<span class="cm"> * willing to return in a single READ operation.</span>
<span class="cm"> *</span>
<span class="cm"> * These happen to all be powers of 2, which is not strictly</span>
<span class="cm"> * necessary but helps enforce the real limitation, which is</span>
<span class="cm"> * that they should be multiples of PAGE_CACHE_SIZE.</span>
<span class="cm"> *</span>
<span class="cm"> * For UDP transports, a block plus NFS,RPC, and UDP headers</span>
<span class="cm"> * has to fit into the IP datagram limit of 64K.  The largest</span>
<span class="cm"> * feasible number for all known page sizes is probably 48K,</span>
<span class="cm"> * but we choose 32K here.  This is the same as the historical</span>
<span class="cm"> * Linux limit; someone who cares more about NFS/UDP performance</span>
<span class="cm"> * can test a larger number.</span>
<span class="cm"> *</span>
<span class="cm"> * For TCP transports we have more freedom.  A size of 1MB is</span>
<span class="cm"> * chosen to match the client limit.  Other OSes are known to</span>
<span class="cm"> * have larger limits, but those numbers are probably beyond</span>
<span class="cm"> * the point of diminishing returns.</span>
<span class="cm"> */</span>
<span class="cp">#define RPCSVC_MAXPAYLOAD	(1*1024*1024u)</span>
<span class="cp">#define RPCSVC_MAXPAYLOAD_TCP	RPCSVC_MAXPAYLOAD</span>
<span class="cp">#define RPCSVC_MAXPAYLOAD_UDP	(32*1024u)</span>

<span class="k">extern</span> <span class="n">u32</span> <span class="n">svc_max_payload</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * RPC Requsts and replies are stored in one or more pages.</span>
<span class="cm"> * We maintain an array of pages for each server thread.</span>
<span class="cm"> * Requests are copied into these pages as they arrive.  Remaining</span>
<span class="cm"> * pages are available to write the reply into.</span>
<span class="cm"> *</span>
<span class="cm"> * Pages are sent using -&gt;sendpage so each server thread needs to</span>
<span class="cm"> * allocate more to replace those used in sending.  To help keep track</span>
<span class="cm"> * of these pages we have a receive list where all pages initialy live,</span>
<span class="cm"> * and a send list where pages are moved to when there are to be part</span>
<span class="cm"> * of a reply.</span>
<span class="cm"> *</span>
<span class="cm"> * We use xdr_buf for holding responses as it fits well with NFS</span>
<span class="cm"> * read responses (that have a header, and some data pages, and possibly</span>
<span class="cm"> * a tail) and means we can share some client side routines.</span>
<span class="cm"> *</span>
<span class="cm"> * The xdr_buf.head kvec always points to the first page in the rq_*pages</span>
<span class="cm"> * list.  The xdr_buf.pages pointer points to the second page on that</span>
<span class="cm"> * list.  xdr_buf.tail points to the end of the first page.</span>
<span class="cm"> * This assumes that the non-page part of an rpc reply will fit</span>
<span class="cm"> * in a page - NFSd ensures this.  lockd also has no trouble.</span>
<span class="cm"> *</span>
<span class="cm"> * Each request/reply pair can have at most one &quot;payload&quot;, plus two pages,</span>
<span class="cm"> * one for the request, and one for the reply.</span>
<span class="cm"> * We using -&gt;sendfile to return read data, we might need one extra page</span>
<span class="cm"> * if the request is not page-aligned.  So add another &#39;1&#39;.</span>
<span class="cm"> */</span>
<span class="cp">#define RPCSVC_MAXPAGES		((RPCSVC_MAXPAYLOAD+PAGE_SIZE-1)/PAGE_SIZE \</span>
<span class="cp">				+ 2 + 1)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">svc_getnl</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">iov</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">val</span><span class="p">,</span> <span class="o">*</span><span class="n">vp</span><span class="p">;</span>
	<span class="n">vp</span> <span class="o">=</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="n">vp</span><span class="o">++</span><span class="p">;</span>
	<span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">vp</span><span class="p">;</span>
	<span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be32</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">svc_putnl</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">vp</span> <span class="o">=</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">;</span>
	<span class="o">*</span><span class="n">vp</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__be32</span> <span class="nf">svc_getu32</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">iov</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">val</span><span class="p">,</span> <span class="o">*</span><span class="n">vp</span><span class="p">;</span>
	<span class="n">vp</span> <span class="o">=</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="n">vp</span><span class="o">++</span><span class="p">;</span>
	<span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">vp</span><span class="p">;</span>
	<span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be32</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">svc_ungetu32</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">iov</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">vp</span> <span class="o">=</span> <span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">vp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">svc_putu32</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">vp</span> <span class="o">=</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">;</span>
	<span class="o">*</span><span class="n">vp</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be32</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The context of a single thread, including the request currently being</span>
<span class="cm"> * processed.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">svc_rqst</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">rq_list</span><span class="p">;</span>	<span class="cm">/* idle list */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">rq_all</span><span class="p">;</span>		<span class="cm">/* all threads list */</span>
	<span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span>	<span class="n">rq_xprt</span><span class="p">;</span>	<span class="cm">/* transport ptr */</span>

	<span class="k">struct</span> <span class="n">sockaddr_storage</span>	<span class="n">rq_addr</span><span class="p">;</span>	<span class="cm">/* peer address */</span>
	<span class="kt">size_t</span>			<span class="n">rq_addrlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span>	<span class="n">rq_daddr</span><span class="p">;</span>	<span class="cm">/* dest addr of request</span>
<span class="cm">						 *  - reply from here */</span>
	<span class="kt">size_t</span>			<span class="n">rq_daddrlen</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span>	<span class="n">rq_server</span><span class="p">;</span>	<span class="cm">/* RPC service definition */</span>
	<span class="k">struct</span> <span class="n">svc_pool</span> <span class="o">*</span>	<span class="n">rq_pool</span><span class="p">;</span>	<span class="cm">/* thread pool */</span>
	<span class="k">struct</span> <span class="n">svc_procedure</span> <span class="o">*</span>	<span class="n">rq_procinfo</span><span class="p">;</span>	<span class="cm">/* procedure info */</span>
	<span class="k">struct</span> <span class="n">auth_ops</span> <span class="o">*</span>	<span class="n">rq_authop</span><span class="p">;</span>	<span class="cm">/* authentication flavour */</span>
	<span class="k">struct</span> <span class="n">svc_cred</span>		<span class="n">rq_cred</span><span class="p">;</span>	<span class="cm">/* auth info */</span>
	<span class="kt">void</span> <span class="o">*</span>			<span class="n">rq_xprt_ctxt</span><span class="p">;</span>	<span class="cm">/* transport specific context ptr */</span>
	<span class="k">struct</span> <span class="n">svc_deferred_req</span><span class="o">*</span><span class="n">rq_deferred</span><span class="p">;</span>	<span class="cm">/* deferred request we are replaying */</span>
	<span class="kt">int</span>			<span class="n">rq_usedeferral</span><span class="p">;</span>	<span class="cm">/* use deferral */</span>

	<span class="kt">size_t</span>			<span class="n">rq_xprt_hlen</span><span class="p">;</span>	<span class="cm">/* xprt header len */</span>
	<span class="k">struct</span> <span class="n">xdr_buf</span>		<span class="n">rq_arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xdr_buf</span>		<span class="n">rq_res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>		<span class="n">rq_pages</span><span class="p">[</span><span class="n">RPCSVC_MAXPAGES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>		<span class="o">*</span><span class="n">rq_respages</span><span class="p">;</span>	<span class="cm">/* points into rq_pages */</span>
	<span class="kt">int</span>			<span class="n">rq_resused</span><span class="p">;</span>	<span class="cm">/* number of pages used for result */</span>

	<span class="k">struct</span> <span class="n">kvec</span>		<span class="n">rq_vec</span><span class="p">[</span><span class="n">RPCSVC_MAXPAGES</span><span class="p">];</span> <span class="cm">/* generally useful.. */</span>

	<span class="n">__be32</span>			<span class="n">rq_xid</span><span class="p">;</span>		<span class="cm">/* transmission id */</span>
	<span class="n">u32</span>			<span class="n">rq_prog</span><span class="p">;</span>	<span class="cm">/* program number */</span>
	<span class="n">u32</span>			<span class="n">rq_vers</span><span class="p">;</span>	<span class="cm">/* program version */</span>
	<span class="n">u32</span>			<span class="n">rq_proc</span><span class="p">;</span>	<span class="cm">/* procedure number */</span>
	<span class="n">u32</span>			<span class="n">rq_prot</span><span class="p">;</span>	<span class="cm">/* IP protocol */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>
				<span class="n">rq_secure</span>  <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* secure port */</span>

	<span class="kt">void</span> <span class="o">*</span>			<span class="n">rq_argp</span><span class="p">;</span>	<span class="cm">/* decoded arguments */</span>
	<span class="kt">void</span> <span class="o">*</span>			<span class="n">rq_resp</span><span class="p">;</span>	<span class="cm">/* xdr&#39;d results */</span>
	<span class="kt">void</span> <span class="o">*</span>			<span class="n">rq_auth_data</span><span class="p">;</span>	<span class="cm">/* flavor-specific data */</span>

	<span class="kt">int</span>			<span class="n">rq_reserved</span><span class="p">;</span>	<span class="cm">/* space on socket outq</span>
<span class="cm">						 * reserved for this request</span>
<span class="cm">						 */</span>

	<span class="k">struct</span> <span class="n">cache_req</span>	<span class="n">rq_chandle</span><span class="p">;</span>	<span class="cm">/* handle passed to caches for </span>
<span class="cm">						 * request delaying </span>
<span class="cm">						 */</span>
	<span class="n">bool</span>			<span class="n">rq_dropme</span><span class="p">;</span>
	<span class="cm">/* Catering to nfsd */</span>
	<span class="k">struct</span> <span class="n">auth_domain</span> <span class="o">*</span>	<span class="n">rq_client</span><span class="p">;</span>	<span class="cm">/* RPC peer info */</span>
	<span class="k">struct</span> <span class="n">auth_domain</span> <span class="o">*</span>	<span class="n">rq_gssclient</span><span class="p">;</span>	<span class="cm">/* &quot;gss/&quot;-style peer info */</span>
	<span class="kt">int</span>			<span class="n">rq_cachetype</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_cacherep</span> <span class="o">*</span>	<span class="n">rq_cacherep</span><span class="p">;</span>	<span class="cm">/* cache info */</span>
	<span class="kt">int</span>			<span class="n">rq_splice_ok</span><span class="p">;</span>   <span class="cm">/* turned off in gss privacy</span>
<span class="cm">						 * to prevent encrypting page</span>
<span class="cm">						 * cache pages */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">rq_wait</span><span class="p">;</span>	<span class="cm">/* synchronization */</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">rq_task</span><span class="p">;</span>	<span class="cm">/* service thread */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Rigorous type checking on sockaddr type conversions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="nf">svc_addr_in</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">rqst</span><span class="o">-&gt;</span><span class="n">rq_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="nf">svc_addr_in6</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">rqst</span><span class="o">-&gt;</span><span class="n">rq_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="nf">svc_addr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">rqst</span><span class="o">-&gt;</span><span class="n">rq_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="nf">svc_daddr_in</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">rqst</span><span class="o">-&gt;</span><span class="n">rq_daddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="nf">svc_daddr_in6</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">rqst</span><span class="o">-&gt;</span><span class="n">rq_daddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="nf">svc_daddr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">rqst</span><span class="o">-&gt;</span><span class="n">rq_daddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check buffer bounds after decoding arguments</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">xdr_argsize_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">vec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_arg</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">cp</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">iov_base</span>
		<span class="o">&amp;&amp;</span> <span class="n">cp</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">xdr_ressize_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">vec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>

	<span class="n">vec</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">cp</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">svc_free_res_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resused</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pp</span> <span class="o">=</span> <span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_respages</span> <span class="o">+</span>
				    <span class="o">--</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resused</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_page</span><span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">);</span>
			<span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">svc_deferred_req</span> <span class="p">{</span>
	<span class="n">u32</span>			<span class="n">prot</span><span class="p">;</span>	<span class="cm">/* protocol (UDP or TCP) */</span>
	<span class="k">struct</span> <span class="n">svc_xprt</span>		<span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span>	<span class="n">addr</span><span class="p">;</span>	<span class="cm">/* where reply must go */</span>
	<span class="kt">size_t</span>			<span class="n">addrlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span>	<span class="n">daddr</span><span class="p">;</span>	<span class="cm">/* where reply must come from */</span>
	<span class="kt">size_t</span>			<span class="n">daddrlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_deferred_req</span> <span class="n">handle</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">xprt_hlen</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">argslen</span><span class="p">;</span>
	<span class="n">__be32</span>			<span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * List of RPC programs on the same transport endpoint</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">svc_program</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_program</span> <span class="o">*</span>	<span class="n">pg_next</span><span class="p">;</span>	<span class="cm">/* other programs (same xprt) */</span>
	<span class="n">u32</span>			<span class="n">pg_prog</span><span class="p">;</span>	<span class="cm">/* program number */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pg_lovers</span><span class="p">;</span>	<span class="cm">/* lowest version */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pg_hivers</span><span class="p">;</span>	<span class="cm">/* lowest version */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pg_nvers</span><span class="p">;</span>	<span class="cm">/* number of versions */</span>
	<span class="k">struct</span> <span class="n">svc_version</span> <span class="o">**</span>	<span class="n">pg_vers</span><span class="p">;</span>	<span class="cm">/* version array */</span>
	<span class="kt">char</span> <span class="o">*</span>			<span class="n">pg_name</span><span class="p">;</span>	<span class="cm">/* service name */</span>
	<span class="kt">char</span> <span class="o">*</span>			<span class="n">pg_class</span><span class="p">;</span>	<span class="cm">/* class name: services sharing authentication */</span>
	<span class="k">struct</span> <span class="n">svc_stat</span> <span class="o">*</span>	<span class="n">pg_stats</span><span class="p">;</span>	<span class="cm">/* rpc statistics */</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">pg_authenticate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * RPC program version</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">svc_version</span> <span class="p">{</span>
	<span class="n">u32</span>			<span class="n">vs_vers</span><span class="p">;</span>	<span class="cm">/* version number */</span>
	<span class="n">u32</span>			<span class="n">vs_nproc</span><span class="p">;</span>	<span class="cm">/* number of procedures */</span>
	<span class="k">struct</span> <span class="n">svc_procedure</span> <span class="o">*</span>	<span class="n">vs_proc</span><span class="p">;</span>	<span class="cm">/* per-procedure info */</span>
	<span class="n">u32</span>			<span class="n">vs_xdrsize</span><span class="p">;</span>	<span class="cm">/* xdrsize needed for this version */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">vs_hidden</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Don&#39;t register with portmapper.</span>
<span class="cm">						 * Only used for nfsacl so far. */</span>

	<span class="cm">/* Override dispatch function (e.g. when caching replies).</span>
<span class="cm">	 * A return value of 0 means drop the request. </span>
<span class="cm">	 * vs_dispatch == NULL means use default dispatcher.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">vs_dispatch</span><span class="p">)(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * RPC procedure info</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">__be32</span>	<span class="p">(</span><span class="o">*</span><span class="n">svc_procfunc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">argp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">resp</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">svc_procedure</span> <span class="p">{</span>
	<span class="n">svc_procfunc</span>		<span class="n">pc_func</span><span class="p">;</span>	<span class="cm">/* process the request */</span>
	<span class="n">kxdrproc_t</span>		<span class="n">pc_decode</span><span class="p">;</span>	<span class="cm">/* XDR decode args */</span>
	<span class="n">kxdrproc_t</span>		<span class="n">pc_encode</span><span class="p">;</span>	<span class="cm">/* XDR encode result */</span>
	<span class="n">kxdrproc_t</span>		<span class="n">pc_release</span><span class="p">;</span>	<span class="cm">/* XDR free result */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pc_argsize</span><span class="p">;</span>	<span class="cm">/* argument struct size */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pc_ressize</span><span class="p">;</span>	<span class="cm">/* result struct size */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pc_count</span><span class="p">;</span>	<span class="cm">/* call count */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pc_cachetype</span><span class="p">;</span>	<span class="cm">/* cache info (NFS) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pc_xdrressize</span><span class="p">;</span>	<span class="cm">/* maximum size of XDR reply */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Function prototypes.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">svc_rpcb_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">svc_rpcb_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">svc_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">svc_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_program</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">));</span>
<span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">svc_prepare_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">svc_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="kt">void</span>		   <span class="n">svc_exit_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span>  <span class="n">svc_create_pooled</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_program</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
			<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">),</span>
			<span class="n">svc_thread_fn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span>		   <span class="n">svc_set_num_threads</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_pool</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span>		   <span class="n">svc_pool_stats_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="kt">void</span>		   <span class="n">svc_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>		   <span class="n">svc_shutdown_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span>		   <span class="n">svc_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span>		   <span class="n">bc_svc_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span>		   <span class="n">svc_register</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span><span class="p">);</span>

<span class="kt">void</span>		   <span class="n">svc_wake_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>		   <span class="n">svc_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">space</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">svc_pool</span> <span class="o">*</span>  <span class="n">svc_pool_for_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span>		   <span class="n">svc_print_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>

<span class="cp">#define	RPC_MAX_ADDRBUFLEN	(63U)</span>

<span class="cm">/*</span>
<span class="cm"> * When we want to reduce the size of the reserved space in the response</span>
<span class="cm"> * buffer, we need to take into account the size of any checksum data that</span>
<span class="cm"> * may be at the end of the packet. This is difficult to determine exactly</span>
<span class="cm"> * for all cases without actually generating the checksum, so we just use a</span>
<span class="cm"> * static value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">svc_reserve_auth</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">space</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">added_space</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_authop</span><span class="o">-&gt;</span><span class="n">flavour</span><span class="p">)</span>
		<span class="n">added_space</span> <span class="o">=</span> <span class="n">RPC_MAX_AUTH_SIZE</span><span class="p">;</span>
	<span class="n">svc_reserve</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">space</span> <span class="o">+</span> <span class="n">added_space</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* SUNRPC_SVC_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
