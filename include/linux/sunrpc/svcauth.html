<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › sunrpc › svcauth.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>svcauth.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/include/linux/sunrpc/svcauth.h</span>
<span class="cm"> *</span>
<span class="cm"> * RPC server-side authentication stuff.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1995, 1996 Olaf Kirch &lt;okir@monad.swb.de&gt;</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_SUNRPC_SVCAUTH_H_</span>
<span class="cp">#define _LINUX_SUNRPC_SVCAUTH_H_</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/msg_prot.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/cache.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/cred.h&gt;</span>

<span class="k">struct</span> <span class="n">svc_cred</span> <span class="p">{</span>
	<span class="n">uid_t</span>			<span class="n">cr_uid</span><span class="p">;</span>
	<span class="n">gid_t</span>			<span class="n">cr_gid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">group_info</span>	<span class="o">*</span><span class="n">cr_group_info</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">cr_flavor</span><span class="p">;</span> <span class="cm">/* pseudoflavor */</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">cr_principal</span><span class="p">;</span> <span class="cm">/* for gss */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_svc_cred</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">cr_group_info</span><span class="p">)</span>
		<span class="n">put_group_info</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">cr_group_info</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">cr_principal</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">svc_rqst</span><span class="p">;</span>		<span class="cm">/* forward decl */</span>
<span class="k">struct</span> <span class="n">in6_addr</span><span class="p">;</span>

<span class="cm">/* Authentication is done in the context of a domain.</span>
<span class="cm"> *</span>
<span class="cm"> * Currently, the nfs server uses the auth_domain to stand</span>
<span class="cm"> * for the &quot;client&quot; listed in /etc/exports.</span>
<span class="cm"> *</span>
<span class="cm"> * More generally, a domain might represent a group of clients using</span>
<span class="cm"> * a common mechanism for authentication and having a common mapping</span>
<span class="cm"> * between local identity (uid) and network identity.  All clients</span>
<span class="cm"> * in a domain have similar general access rights.  Each domain can</span>
<span class="cm"> * contain multiple principals which will have different specific right</span>
<span class="cm"> * based on normal Discretionary Access Control.</span>
<span class="cm"> *</span>
<span class="cm"> * A domain is created by an authentication flavour module based on name</span>
<span class="cm"> * only.  Userspace then fills in detail on demand.</span>
<span class="cm"> *</span>
<span class="cm"> * In the case of auth_unix and auth_null, the auth_domain is also</span>
<span class="cm"> * associated with entries in another cache representing the mapping</span>
<span class="cm"> * of ip addresses to the given client.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">auth_domain</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kref</span>		<span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">hash</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">auth_ops</span>		<span class="o">*</span><span class="n">flavour</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Each authentication flavour registers an auth_ops</span>
<span class="cm"> * structure.</span>
<span class="cm"> * name is simply the name.</span>
<span class="cm"> * flavour gives the auth flavour. It determines where the flavour is registered</span>
<span class="cm"> * accept() is given a request and should verify it.</span>
<span class="cm"> *   It should inspect the authenticator and verifier, and possibly the data.</span>
<span class="cm"> *    If there is a problem with the authentication *authp should be set.</span>
<span class="cm"> *    The return value of accept() can indicate:</span>
<span class="cm"> *      OK - authorised. client and credential are set in rqstp.</span>
<span class="cm"> *           reqbuf points to arguments</span>
<span class="cm"> *           resbuf points to good place for results.  verfier</span>
<span class="cm"> *             is (probably) already in place.  Certainly space is</span>
<span class="cm"> *	       reserved for it.</span>
<span class="cm"> *      DROP - simply drop the request. It may have been deferred</span>
<span class="cm"> *      GARBAGE - rpc garbage_args error</span>
<span class="cm"> *      SYSERR - rpc system_err error</span>
<span class="cm"> *      DENIED - authp holds reason for denial.</span>
<span class="cm"> *      COMPLETE - the reply is encoded already and ready to be sent; no</span>
<span class="cm"> *		further processing is necessary.  (This is used for processing</span>
<span class="cm"> *		null procedure calls which are used to set up encryption</span>
<span class="cm"> *		contexts.)</span>
<span class="cm"> *</span>
<span class="cm"> *   accept is passed the proc number so that it can accept NULL rpc requests</span>
<span class="cm"> *   even if it cannot authenticate the client (as is sometimes appropriate).</span>
<span class="cm"> *</span>
<span class="cm"> * release() is given a request after the procedure has been run.</span>
<span class="cm"> *  It should sign/encrypt the results if needed</span>
<span class="cm"> * It should return:</span>
<span class="cm"> *    OK - the resbuf is ready to be sent</span>
<span class="cm"> *    DROP - the reply should be quitely dropped</span>
<span class="cm"> *    DENIED - authp holds a reason for MSG_DENIED</span>
<span class="cm"> *    SYSERR - rpc system_err</span>
<span class="cm"> *</span>
<span class="cm"> * domain_release()</span>
<span class="cm"> *   This call releases a domain.</span>
<span class="cm"> * set_client()</span>
<span class="cm"> *   Givens a pending request (struct svc_rqst), finds and assigns</span>
<span class="cm"> *   an appropriate &#39;auth_domain&#39; as the client.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">auth_ops</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span>	<span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">flavour</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">accept</span><span class="p">)(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">authp</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">domain_release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">auth_domain</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_client</span><span class="p">)(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define	SVC_GARBAGE	1</span>
<span class="cp">#define	SVC_SYSERR	2</span>
<span class="cp">#define	SVC_VALID	3</span>
<span class="cp">#define	SVC_NEGATIVE	4</span>
<span class="cp">#define	SVC_OK		5</span>
<span class="cp">#define	SVC_DROP	6</span>
<span class="cp">#define	SVC_CLOSE	7	</span><span class="cm">/* Like SVC_DROP, but request is definitely</span>
<span class="cm">				 * lost so if there is a tcp connection, it</span>
<span class="cm">				 * should be closed</span>
<span class="cm">				 */</span><span class="cp"></span>
<span class="cp">#define	SVC_DENIED	8</span>
<span class="cp">#define	SVC_PENDING	9</span>
<span class="cp">#define	SVC_COMPLETE	10</span>

<span class="k">struct</span> <span class="n">svc_xprt</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span>	<span class="n">svc_authenticate</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">authp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	<span class="n">svc_authorise</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	<span class="n">svc_set_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	<span class="n">svc_auth_register</span><span class="p">(</span><span class="n">rpc_authflavor_t</span> <span class="n">flavor</span><span class="p">,</span> <span class="k">struct</span> <span class="n">auth_ops</span> <span class="o">*</span><span class="n">aops</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	<span class="n">svc_auth_unregister</span><span class="p">(</span><span class="n">rpc_authflavor_t</span> <span class="n">flavor</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">auth_domain</span> <span class="o">*</span><span class="n">unix_domain_find</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">auth_domain_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">auth_domain</span> <span class="o">*</span><span class="n">item</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">auth_unix_add_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">auth_domain</span> <span class="o">*</span><span class="n">dom</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">auth_domain</span> <span class="o">*</span><span class="n">auth_domain_lookup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">auth_domain</span> <span class="o">*</span><span class="n">new</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">auth_domain</span> <span class="o">*</span><span class="n">auth_domain_find</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">auth_domain</span> <span class="o">*</span><span class="n">auth_unix_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">auth_unix_forget_old</span><span class="p">(</span><span class="k">struct</span> <span class="n">auth_domain</span> <span class="o">*</span><span class="n">dom</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">svcauth_unix_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">svcauth_unix_info_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">xpt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">svcauth_unix_set_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">unix_gid_cache_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">unix_gid_cache_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">hash_str</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">name</span><span class="o">++</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">len</span><span class="p">;</span> <span class="n">len</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">len</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span><span class="o">/</span><span class="mi">8</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
			<span class="n">hash</span> <span class="o">=</span> <span class="n">hash_long</span><span class="p">(</span><span class="n">hash</span><span class="o">^</span><span class="n">l</span><span class="p">,</span> <span class="n">BITS_PER_LONG</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">hash_mem</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">len</span><span class="p">;</span> <span class="n">len</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">;</span>
		<span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">len</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span><span class="o">/</span><span class="mi">8</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
			<span class="n">hash</span> <span class="o">=</span> <span class="n">hash_long</span><span class="p">(</span><span class="n">hash</span><span class="o">^</span><span class="n">l</span><span class="p">,</span> <span class="n">BITS_PER_LONG</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_SUNRPC_SVCAUTH_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
