<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › sunrpc › msg_prot.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>msg_prot.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/include/linux/sunrpc/msg_prot.h</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1996, Olaf Kirch &lt;okir@monad.swb.de&gt;</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_SUNRPC_MSGPROT_H_</span>
<span class="cp">#define _LINUX_SUNRPC_MSGPROT_H_</span>

<span class="cp">#ifdef __KERNEL__ </span><span class="cm">/* user programs should get these from the rpc header files */</span><span class="cp"></span>

<span class="cp">#define RPC_VERSION 2</span>

<span class="cm">/* size of an XDR encoding unit in bytes, i.e. 32bit */</span>
<span class="cp">#define XDR_UNIT	(4)</span>

<span class="cm">/* spec defines authentication flavor as an unsigned 32 bit integer */</span>
<span class="k">typedef</span> <span class="n">u32</span>	<span class="n">rpc_authflavor_t</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">rpc_auth_flavors</span> <span class="p">{</span>
	<span class="n">RPC_AUTH_NULL</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RPC_AUTH_UNIX</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">RPC_AUTH_SHORT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">RPC_AUTH_DES</span>   <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">RPC_AUTH_KRB</span>   <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">RPC_AUTH_GSS</span>   <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">RPC_AUTH_MAXFLAVOR</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="cm">/* pseudoflavors: */</span>
	<span class="n">RPC_AUTH_GSS_KRB5</span>  <span class="o">=</span> <span class="mi">390003</span><span class="p">,</span>
	<span class="n">RPC_AUTH_GSS_KRB5I</span> <span class="o">=</span> <span class="mi">390004</span><span class="p">,</span>
	<span class="n">RPC_AUTH_GSS_KRB5P</span> <span class="o">=</span> <span class="mi">390005</span><span class="p">,</span>
	<span class="n">RPC_AUTH_GSS_LKEY</span>  <span class="o">=</span> <span class="mi">390006</span><span class="p">,</span>
	<span class="n">RPC_AUTH_GSS_LKEYI</span> <span class="o">=</span> <span class="mi">390007</span><span class="p">,</span>
	<span class="n">RPC_AUTH_GSS_LKEYP</span> <span class="o">=</span> <span class="mi">390008</span><span class="p">,</span>
	<span class="n">RPC_AUTH_GSS_SPKM</span>  <span class="o">=</span> <span class="mi">390009</span><span class="p">,</span>
	<span class="n">RPC_AUTH_GSS_SPKMI</span> <span class="o">=</span> <span class="mi">390010</span><span class="p">,</span>
	<span class="n">RPC_AUTH_GSS_SPKMP</span> <span class="o">=</span> <span class="mi">390011</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Maximum size (in bytes) of an rpc credential or verifier */</span>
<span class="cp">#define RPC_MAX_AUTH_SIZE (400)</span>

<span class="k">enum</span> <span class="n">rpc_msg_type</span> <span class="p">{</span>
	<span class="n">RPC_CALL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RPC_REPLY</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">rpc_reply_stat</span> <span class="p">{</span>
	<span class="n">RPC_MSG_ACCEPTED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RPC_MSG_DENIED</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">rpc_accept_stat</span> <span class="p">{</span>
	<span class="n">RPC_SUCCESS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RPC_PROG_UNAVAIL</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">RPC_PROG_MISMATCH</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">RPC_PROC_UNAVAIL</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">RPC_GARBAGE_ARGS</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">RPC_SYSTEM_ERR</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="cm">/* internal use only */</span>
	<span class="n">RPC_DROP_REPLY</span> <span class="o">=</span> <span class="mi">60000</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">rpc_reject_stat</span> <span class="p">{</span>
	<span class="n">RPC_MISMATCH</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RPC_AUTH_ERROR</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">rpc_auth_stat</span> <span class="p">{</span>
	<span class="n">RPC_AUTH_OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RPC_AUTH_BADCRED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">RPC_AUTH_REJECTEDCRED</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">RPC_AUTH_BADVERF</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">RPC_AUTH_REJECTEDVERF</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">RPC_AUTH_TOOWEAK</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="cm">/* RPCSEC_GSS errors */</span>
	<span class="n">RPCSEC_GSS_CREDPROBLEM</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
	<span class="n">RPCSEC_GSS_CTXPROBLEM</span> <span class="o">=</span> <span class="mi">14</span>
<span class="p">};</span>

<span class="cp">#define RPC_MAXNETNAMELEN	256</span>

<span class="cm">/*</span>
<span class="cm"> * From RFC 1831:</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;A record is composed of one or more record fragments.  A record</span>
<span class="cm"> *  fragment is a four-byte header followed by 0 to (2**31) - 1 bytes of</span>
<span class="cm"> *  fragment data.  The bytes encode an unsigned binary number; as with</span>
<span class="cm"> *  XDR integers, the byte order is from highest to lowest.  The number</span>
<span class="cm"> *  encodes two values -- a boolean which indicates whether the fragment</span>
<span class="cm"> *  is the last fragment of the record (bit value 1 implies the fragment</span>
<span class="cm"> *  is the last fragment) and a 31-bit unsigned binary value which is the</span>
<span class="cm"> *  length in bytes of the fragment&#39;s data.  The boolean value is the</span>
<span class="cm"> *  highest-order bit of the header; the length is the 31 low-order bits.</span>
<span class="cm"> *  (Note that this record specification is NOT in XDR standard form!)&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * The Linux RPC client always sends its requests in a single record</span>
<span class="cm"> * fragment, limiting the maximum payload size for stream transports to</span>
<span class="cm"> * 2GB.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="n">__be32</span>	<span class="n">rpc_fraghdr</span><span class="p">;</span>

<span class="cp">#define	RPC_LAST_STREAM_FRAGMENT	(1U &lt;&lt; 31)</span>
<span class="cp">#define	RPC_FRAGMENT_SIZE_MASK		(~RPC_LAST_STREAM_FRAGMENT)</span>
<span class="cp">#define	RPC_MAX_FRAGMENT_SIZE		((1U &lt;&lt; 31) - 1)</span>

<span class="cm">/*</span>
<span class="cm"> * RPC call and reply header size as number of 32bit words (verifier</span>
<span class="cm"> * size computed separately, see below)</span>
<span class="cm"> */</span>
<span class="cp">#define RPC_CALLHDRSIZE		(6)</span>
<span class="cp">#define RPC_REPHDRSIZE		(4)</span>


<span class="cm">/*</span>
<span class="cm"> * Maximum RPC header size, including authentication,</span>
<span class="cm"> * as number of 32bit words (see RFCs 1831, 1832).</span>
<span class="cm"> *</span>
<span class="cm"> *	xid			    1 xdr unit = 4 bytes</span>
<span class="cm"> *	mtype			    1</span>
<span class="cm"> *	rpc_version		    1</span>
<span class="cm"> *	program			    1</span>
<span class="cm"> *	prog_version		    1</span>
<span class="cm"> *	procedure		    1</span>
<span class="cm"> *	cred {</span>
<span class="cm"> *	    flavor		    1</span>
<span class="cm"> *	    length		    1</span>
<span class="cm"> *	    body&lt;RPC_MAX_AUTH_SIZE&gt; 100 xdr units = 400 bytes</span>
<span class="cm"> *	}</span>
<span class="cm"> *	verf {</span>
<span class="cm"> *	    flavor		    1</span>
<span class="cm"> *	    length		    1</span>
<span class="cm"> *	    body&lt;RPC_MAX_AUTH_SIZE&gt; 100 xdr units = 400 bytes</span>
<span class="cm"> *	}</span>
<span class="cm"> *	TOTAL			    210 xdr units = 840 bytes</span>
<span class="cm"> */</span>
<span class="cp">#define RPC_MAX_HEADER_WITH_AUTH \</span>
<span class="cp">	(RPC_CALLHDRSIZE + 2*(2+RPC_MAX_AUTH_SIZE/4))</span>

<span class="cm">/*</span>
<span class="cm"> * RFC1833/RFC3530 rpcbind (v3+) well-known netid&#39;s.</span>
<span class="cm"> */</span>
<span class="cp">#define RPCBIND_NETID_UDP	&quot;udp&quot;</span>
<span class="cp">#define RPCBIND_NETID_TCP	&quot;tcp&quot;</span>
<span class="cp">#define RPCBIND_NETID_UDP6	&quot;udp6&quot;</span>
<span class="cp">#define RPCBIND_NETID_TCP6	&quot;tcp6&quot;</span>
<span class="cp">#define RPCBIND_NETID_LOCAL	&quot;local&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Note that RFC 1833 does not put any size restrictions on the</span>
<span class="cm"> * netid string, but all currently defined netid&#39;s fit in 4 bytes.</span>
<span class="cm"> */</span>
<span class="cp">#define RPCBIND_MAXNETIDLEN	(4u)</span>

<span class="cm">/*</span>
<span class="cm"> * Universal addresses are introduced in RFC 1833 and further spelled</span>
<span class="cm"> * out in RFC 3530.  RPCBIND_MAXUADDRLEN defines a maximum byte length</span>
<span class="cm"> * of a universal address for use in allocating buffers and character</span>
<span class="cm"> * arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * Quoting RFC 3530, section 2.2:</span>
<span class="cm"> *</span>
<span class="cm"> * For TCP over IPv4 and for UDP over IPv4, the format of r_addr is the</span>
<span class="cm"> * US-ASCII string:</span>
<span class="cm"> *</span>
<span class="cm"> *	h1.h2.h3.h4.p1.p2</span>
<span class="cm"> *</span>
<span class="cm"> * The prefix, &quot;h1.h2.h3.h4&quot;, is the standard textual form for</span>
<span class="cm"> * representing an IPv4 address, which is always four octets long.</span>
<span class="cm"> * Assuming big-endian ordering, h1, h2, h3, and h4, are respectively,</span>
<span class="cm"> * the first through fourth octets each converted to ASCII-decimal.</span>
<span class="cm"> * Assuming big-endian ordering, p1 and p2 are, respectively, the first</span>
<span class="cm"> * and second octets each converted to ASCII-decimal.  For example, if a</span>
<span class="cm"> * host, in big-endian order, has an address of 0x0A010307 and there is</span>
<span class="cm"> * a service listening on, in big endian order, port 0x020F (decimal</span>
<span class="cm"> * 527), then the complete universal address is &quot;10.1.3.7.2.15&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * ...</span>
<span class="cm"> *</span>
<span class="cm"> * For TCP over IPv6 and for UDP over IPv6, the format of r_addr is the</span>
<span class="cm"> * US-ASCII string:</span>
<span class="cm"> *</span>
<span class="cm"> *	x1:x2:x3:x4:x5:x6:x7:x8.p1.p2</span>
<span class="cm"> *</span>
<span class="cm"> * The suffix &quot;p1.p2&quot; is the service port, and is computed the same way</span>
<span class="cm"> * as with universal addresses for TCP and UDP over IPv4.  The prefix,</span>
<span class="cm"> * &quot;x1:x2:x3:x4:x5:x6:x7:x8&quot;, is the standard textual form for</span>
<span class="cm"> * representing an IPv6 address as defined in Section 2.2 of [RFC2373].</span>
<span class="cm"> * Additionally, the two alternative forms specified in Section 2.2 of</span>
<span class="cm"> * [RFC2373] are also acceptable.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/inet.h&gt;</span>

<span class="cm">/* Maximum size of the port number part of a universal address */</span>
<span class="cp">#define RPCBIND_MAXUADDRPLEN	sizeof(&quot;.255.255&quot;)</span>

<span class="cm">/* Maximum size of an IPv4 universal address */</span>
<span class="cp">#define RPCBIND_MAXUADDR4LEN	\</span>
<span class="cp">		(INET_ADDRSTRLEN + RPCBIND_MAXUADDRPLEN)</span>

<span class="cm">/* Maximum size of an IPv6 universal address */</span>
<span class="cp">#define RPCBIND_MAXUADDR6LEN	\</span>
<span class="cp">		(INET6_ADDRSTRLEN + RPCBIND_MAXUADDRPLEN)</span>

<span class="cm">/* Assume INET6_ADDRSTRLEN will always be larger than INET_ADDRSTRLEN... */</span>
<span class="cp">#define RPCBIND_MAXUADDRLEN	RPCBIND_MAXUADDR6LEN</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _LINUX_SUNRPC_MSGPROT_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
