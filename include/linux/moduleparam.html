<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › moduleparam.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>moduleparam.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_MODULE_PARAMS_H</span>
<span class="cp">#define _LINUX_MODULE_PARAMS_H</span>
<span class="cm">/* (C) Copyright 2001, 2002 Rusty Russell IBM Corporation */</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/stringify.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>

<span class="cm">/* You can override this manually, but generally this should match the</span>
<span class="cm">   module name. */</span>
<span class="cp">#ifdef MODULE</span>
<span class="cp">#define MODULE_PARAM_PREFIX </span><span class="cm">/* empty */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define MODULE_PARAM_PREFIX KBUILD_MODNAME &quot;.&quot;</span>
<span class="cp">#endif</span>

<span class="cm">/* Chosen so that structs with an unsigned long line up. */</span>
<span class="cp">#define MAX_PARAM_PREFIX_LEN (64 - sizeof(unsigned long))</span>

<span class="cp">#define ___module_cat(a,b) __mod_ ## a ## b</span>
<span class="cp">#define __module_cat(a,b) ___module_cat(a,b)</span>
<span class="cp">#ifdef MODULE</span>
<span class="cp">#define __MODULE_INFO(tag, name, info)					  \</span>
<span class="cp">static const char __module_cat(name,__LINE__)[]				  \</span>
<span class="cp">  __used __attribute__((section(&quot;.modinfo&quot;), unused, aligned(1)))	  \</span>
<span class="cp">  = __stringify(tag) &quot;=&quot; info</span>
<span class="cp">#else  </span><span class="cm">/* !MODULE */</span><span class="cp"></span>
<span class="cm">/* This struct is here for syntactic coherency, it is not used */</span>
<span class="cp">#define __MODULE_INFO(tag, name, info)					  \</span>
<span class="cp">  struct __module_cat(name,__LINE__) {}</span>
<span class="cp">#endif</span>
<span class="cp">#define __MODULE_PARM_TYPE(name, _type)					  \</span>
<span class="cp">  __MODULE_INFO(parmtype, name##type, #name &quot;:&quot; _type)</span>

<span class="cm">/* One for each parameter, describing how to use it.  Some files do</span>
<span class="cm">   multiple of these per line, so can&#39;t just use MODULE_INFO. */</span>
<span class="cp">#define MODULE_PARM_DESC(_parm, desc) \</span>
<span class="cp">	__MODULE_INFO(parm, _parm, #_parm &quot;:&quot; desc)</span>

<span class="k">struct</span> <span class="n">kernel_param</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="p">{</span>
	<span class="cm">/* Returns 0, or -errno.  arg is in kp-&gt;arg. */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
	<span class="cm">/* Returns length written or -errno.  Buffer is 4k (ie. be short!) */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
	<span class="cm">/* Optional function to free kp-&gt;arg when module unloaded. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kernel_param</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">perm</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">level</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">;</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">kparam_string</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">kparam_array</span> <span class="o">*</span><span class="n">arr</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cm">/* Special one for strings we want to copy into */</span>
<span class="k">struct</span> <span class="n">kparam_string</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxlen</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Special one for arrays */</span>
<span class="k">struct</span> <span class="n">kparam_array</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">elemsize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">num</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * module_param - typesafe helper for a module/cmdline parameter</span>
<span class="cm"> * @value: the variable to alter, and exposed parameter name.</span>
<span class="cm"> * @type: the type of the parameter</span>
<span class="cm"> * @perm: visibility in sysfs.</span>
<span class="cm"> *</span>
<span class="cm"> * @value becomes the module parameter, or (prefixed by KBUILD_MODNAME and a</span>
<span class="cm"> * &quot;.&quot;) the kernel commandline parameter.  Note that - is changed to _, so</span>
<span class="cm"> * the user can use &quot;foo-bar=1&quot; even for variable &quot;foo_bar&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * @perm is 0 if the the variable is not to appear in sysfs, or 0444</span>
<span class="cm"> * for world-readable, 0644 for root-writable, etc.  Note that if it</span>
<span class="cm"> * is writable, you may need to use kparam_block_sysfs_write() around</span>
<span class="cm"> * accesses (esp. charp, which can be kfreed when it changes).</span>
<span class="cm"> *</span>
<span class="cm"> * The @type is simply pasted to refer to a param_ops_##type and a</span>
<span class="cm"> * param_check_##type: for convenience many standard types are provided but</span>
<span class="cm"> * you can create your own by defining those variables.</span>
<span class="cm"> *</span>
<span class="cm"> * Standard types are:</span>
<span class="cm"> *	byte, short, ushort, int, uint, long, ulong</span>
<span class="cm"> *	charp: a character pointer</span>
<span class="cm"> *	bool: a bool, values 0/1, y/n, Y/N.</span>
<span class="cm"> *	invbool: the above, only sense-reversed (N = true).</span>
<span class="cm"> */</span>
<span class="cp">#define module_param(name, type, perm)				\</span>
<span class="cp">	module_param_named(name, name, type, perm)</span>

<span class="cm">/**</span>
<span class="cm"> * module_param_named - typesafe helper for a renamed module/cmdline parameter</span>
<span class="cm"> * @name: a valid C identifier which is the parameter name.</span>
<span class="cm"> * @value: the actual lvalue to alter.</span>
<span class="cm"> * @type: the type of the parameter</span>
<span class="cm"> * @perm: visibility in sysfs.</span>
<span class="cm"> *</span>
<span class="cm"> * Usually it&#39;s a good idea to have variable names and user-exposed names the</span>
<span class="cm"> * same, but that&#39;s harder if the variable must be non-static or is inside a</span>
<span class="cm"> * structure.  This allows exposure under a different name.</span>
<span class="cm"> */</span>
<span class="cp">#define module_param_named(name, value, type, perm)			   \</span>
<span class="cp">	param_check_##type(name, &amp;(value));				   \</span>
<span class="cp">	module_param_cb(name, &amp;param_ops_##type, &amp;value, perm);		   \</span>
<span class="cp">	__MODULE_PARM_TYPE(name, #type)</span>

<span class="cm">/**</span>
<span class="cm"> * module_param_cb - general callback for a module/cmdline parameter</span>
<span class="cm"> * @name: a valid C identifier which is the parameter name.</span>
<span class="cm"> * @ops: the set &amp; get operations for this parameter.</span>
<span class="cm"> * @perm: visibility in sysfs.</span>
<span class="cm"> *</span>
<span class="cm"> * The ops can have NULL set or get functions.</span>
<span class="cm"> */</span>
<span class="cp">#define module_param_cb(name, ops, arg, perm)				      \</span>
<span class="cp">	__module_param_call(MODULE_PARAM_PREFIX, name, ops, arg, perm, -1)</span>

<span class="cm">/**</span>
<span class="cm"> * &lt;level&gt;_param_cb - general callback for a module/cmdline parameter</span>
<span class="cm"> *                    to be evaluated before certain initcall level</span>
<span class="cm"> * @name: a valid C identifier which is the parameter name.</span>
<span class="cm"> * @ops: the set &amp; get operations for this parameter.</span>
<span class="cm"> * @perm: visibility in sysfs.</span>
<span class="cm"> *</span>
<span class="cm"> * The ops can have NULL set or get functions.</span>
<span class="cm"> */</span>
<span class="cp">#define __level_param_cb(name, ops, arg, perm, level)			\</span>
<span class="cp">	__module_param_call(MODULE_PARAM_PREFIX, name, ops, arg, perm, level)</span>

<span class="cp">#define core_param_cb(name, ops, arg, perm)		\</span>
<span class="cp">	__level_param_cb(name, ops, arg, perm, 1)</span>

<span class="cp">#define postcore_param_cb(name, ops, arg, perm)		\</span>
<span class="cp">	__level_param_cb(name, ops, arg, perm, 2)</span>

<span class="cp">#define arch_param_cb(name, ops, arg, perm)		\</span>
<span class="cp">	__level_param_cb(name, ops, arg, perm, 3)</span>

<span class="cp">#define subsys_param_cb(name, ops, arg, perm)		\</span>
<span class="cp">	__level_param_cb(name, ops, arg, perm, 4)</span>

<span class="cp">#define fs_param_cb(name, ops, arg, perm)		\</span>
<span class="cp">	__level_param_cb(name, ops, arg, perm, 5)</span>

<span class="cp">#define device_param_cb(name, ops, arg, perm)		\</span>
<span class="cp">	__level_param_cb(name, ops, arg, perm, 6)</span>

<span class="cp">#define late_param_cb(name, ops, arg, perm)		\</span>
<span class="cp">	__level_param_cb(name, ops, arg, perm, 7)</span>

<span class="cm">/* On alpha, ia64 and ppc64 relocations to global data cannot go into</span>
<span class="cm">   read-only sections (which is part of respective UNIX ABI on these</span>
<span class="cm">   platforms). So &#39;const&#39; makes no sense and even causes compile failures</span>
<span class="cm">   with some compilers. */</span>
<span class="cp">#if defined(CONFIG_ALPHA) || defined(CONFIG_IA64) || defined(CONFIG_PPC64)</span>
<span class="cp">#define __moduleparam_const</span>
<span class="cp">#else</span>
<span class="cp">#define __moduleparam_const const</span>
<span class="cp">#endif</span>

<span class="cm">/* This is the fundamental function for registering boot/module</span>
<span class="cm">   parameters. */</span>
<span class="cp">#define __module_param_call(prefix, name, ops, arg, perm, level)	\</span>
<span class="cp">	</span><span class="cm">/* Default value instead of permissions? */</span><span class="cp">			\</span>
<span class="cp">	static int __param_perm_check_##name __attribute__((unused)) =	\</span>
<span class="cp">	BUILD_BUG_ON_ZERO((perm) &lt; 0 || (perm) &gt; 0777 || ((perm) &amp; 2))	\</span>
<span class="cp">	+ BUILD_BUG_ON_ZERO(sizeof(&quot;&quot;prefix) &gt; MAX_PARAM_PREFIX_LEN);	\</span>
<span class="cp">	static const char __param_str_##name[] = prefix #name;		\</span>
<span class="cp">	static struct kernel_param __moduleparam_const __param_##name	\</span>
<span class="cp">	__used								\</span>
<span class="cp">    __attribute__ ((unused,__section__ (&quot;__param&quot;),aligned(sizeof(void *)))) \</span>
<span class="cp">	= { __param_str_##name, ops, perm, level, { arg } }</span>

<span class="cm">/* Obsolete - use module_param_cb() */</span>
<span class="cp">#define module_param_call(name, set, get, arg, perm)			\</span>
<span class="cp">	static struct kernel_param_ops __param_ops_##name =		\</span>
<span class="cp">		 { (void *)set, (void *)get };				\</span>
<span class="cp">	__module_param_call(MODULE_PARAM_PREFIX,			\</span>
<span class="cp">			    name, &amp;__param_ops_##name, arg,		\</span>
<span class="cp">			    (perm) + sizeof(__check_old_set_param(set))*0, -1)</span>

<span class="cm">/* We don&#39;t get oldget: it&#39;s often a new-style param_get_uint, etc. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">__check_old_set_param</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">oldset</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kparam_block_sysfs_write - make sure a parameter isn&#39;t written via sysfs.</span>
<span class="cm"> * @name: the name of the parameter</span>
<span class="cm"> *</span>
<span class="cm"> * There&#39;s no point blocking write on a paramter that isn&#39;t writable via sysfs!</span>
<span class="cm"> */</span>
<span class="cp">#define kparam_block_sysfs_write(name)			\</span>
<span class="cp">	do {						\</span>
<span class="cp">		BUG_ON(!(__param_##name.perm &amp; 0222));	\</span>
<span class="cp">		__kernel_param_lock();			\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/**</span>
<span class="cm"> * kparam_unblock_sysfs_write - allows sysfs to write to a parameter again.</span>
<span class="cm"> * @name: the name of the parameter</span>
<span class="cm"> */</span>
<span class="cp">#define kparam_unblock_sysfs_write(name)		\</span>
<span class="cp">	do {						\</span>
<span class="cp">		BUG_ON(!(__param_##name.perm &amp; 0222));	\</span>
<span class="cp">		__kernel_param_unlock();		\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/**</span>
<span class="cm"> * kparam_block_sysfs_read - make sure a parameter isn&#39;t read via sysfs.</span>
<span class="cm"> * @name: the name of the parameter</span>
<span class="cm"> *</span>
<span class="cm"> * This also blocks sysfs writes.</span>
<span class="cm"> */</span>
<span class="cp">#define kparam_block_sysfs_read(name)			\</span>
<span class="cp">	do {						\</span>
<span class="cp">		BUG_ON(!(__param_##name.perm &amp; 0444));	\</span>
<span class="cp">		__kernel_param_lock();			\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/**</span>
<span class="cm"> * kparam_unblock_sysfs_read - allows sysfs to read a parameter again.</span>
<span class="cm"> * @name: the name of the parameter</span>
<span class="cm"> */</span>
<span class="cp">#define kparam_unblock_sysfs_read(name)			\</span>
<span class="cp">	do {						\</span>
<span class="cp">		BUG_ON(!(__param_##name.perm &amp; 0444));	\</span>
<span class="cp">		__kernel_param_unlock();		\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#ifdef CONFIG_SYSFS</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__kernel_param_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__kernel_param_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__kernel_param_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__kernel_param_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef MODULE</span>
<span class="cm">/**</span>
<span class="cm"> * core_param - define a historical core kernel parameter.</span>
<span class="cm"> * @name: the name of the cmdline and sysfs parameter (often the same as var)</span>
<span class="cm"> * @var: the variable</span>
<span class="cm"> * @type: the type of the parameter</span>
<span class="cm"> * @perm: visibility in sysfs</span>
<span class="cm"> *</span>
<span class="cm"> * core_param is just like module_param(), but cannot be modular and</span>
<span class="cm"> * doesn&#39;t add a prefix (such as &quot;printk.&quot;).  This is for compatibility</span>
<span class="cm"> * with __setup(), and it makes sense as truly core parameters aren&#39;t</span>
<span class="cm"> * tied to the particular file they&#39;re in.</span>
<span class="cm"> */</span>
<span class="cp">#define core_param(name, var, type, perm)				\</span>
<span class="cp">	param_check_##type(name, &amp;(var));				\</span>
<span class="cp">	__module_param_call(&quot;&quot;, name, &amp;param_ops_##type, &amp;var, perm, -1)</span>
<span class="cp">#endif </span><span class="cm">/* !MODULE */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * module_param_string - a char array parameter</span>
<span class="cm"> * @name: the name of the parameter</span>
<span class="cm"> * @string: the string variable</span>
<span class="cm"> * @len: the maximum length of the string, incl. terminator</span>
<span class="cm"> * @perm: visibility in sysfs.</span>
<span class="cm"> *</span>
<span class="cm"> * This actually copies the string when it&#39;s set (unlike type charp).</span>
<span class="cm"> * @len is usually just sizeof(string).</span>
<span class="cm"> */</span>
<span class="cp">#define module_param_string(name, string, len, perm)			\</span>
<span class="cp">	static const struct kparam_string __param_string_##name		\</span>
<span class="cp">		= { len, string };					\</span>
<span class="cp">	__module_param_call(MODULE_PARAM_PREFIX, name,			\</span>
<span class="cp">			    &amp;param_ops_string,				\</span>
<span class="cp">			    .str = &amp;__param_string_##name, perm, -1);	\</span>
<span class="cp">	__MODULE_PARM_TYPE(name, &quot;string&quot;)</span>

<span class="cm">/**</span>
<span class="cm"> * parameq - checks if two parameter names match</span>
<span class="cm"> * @name1: parameter name 1</span>
<span class="cm"> * @name2: parameter name 2</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if the two parameter names are equal.</span>
<span class="cm"> * Dashes (-) are considered equal to underscores (_).</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">parameq</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name2</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * parameqn - checks if two parameter names match</span>
<span class="cm"> * @name1: parameter name 1</span>
<span class="cm"> * @name2: parameter name 2</span>
<span class="cm"> * @n: the length to compare</span>
<span class="cm"> *</span>
<span class="cm"> * Similar to parameq(), except it compares @n characters.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">parameqn</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>

<span class="cm">/* Called on module insert or kernel boot */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">parse_args</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		      <span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="n">num</span><span class="p">,</span>
		      <span class="n">s16</span> <span class="n">level_min</span><span class="p">,</span>
		      <span class="n">s16</span> <span class="n">level_max</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">unknown</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">doing</span><span class="p">));</span>

<span class="cm">/* Called by module remove. */</span>
<span class="cp">#ifdef CONFIG_SYSFS</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">destroy_params</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">num</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">destroy_params</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_SYSFS */</span><span class="cp"></span>

<span class="cm">/* All the helper functions */</span>
<span class="cm">/* The macros to do compile-time type checking stolen from Jakub</span>
<span class="cm">   Jelinek, who IIRC came up with this idea for the 2.4 module init code. */</span>
<span class="cp">#define __param_check(name, p, type) \</span>
<span class="cp">	static inline type *__check_##name(void) { return(p); }</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">param_ops_byte</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_set_byte</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_get_byte</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="cp">#define param_check_byte(name, p) __param_check(name, p, unsigned char)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">param_ops_short</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_set_short</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_get_short</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="cp">#define param_check_short(name, p) __param_check(name, p, short)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">param_ops_ushort</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_set_ushort</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_get_ushort</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="cp">#define param_check_ushort(name, p) __param_check(name, p, unsigned short)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">param_ops_int</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_set_int</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_get_int</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="cp">#define param_check_int(name, p) __param_check(name, p, int)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">param_ops_uint</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_set_uint</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_get_uint</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="cp">#define param_check_uint(name, p) __param_check(name, p, unsigned int)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">param_ops_long</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_set_long</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_get_long</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="cp">#define param_check_long(name, p) __param_check(name, p, long)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">param_ops_ulong</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_set_ulong</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_get_ulong</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="cp">#define param_check_ulong(name, p) __param_check(name, p, unsigned long)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">param_ops_charp</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_set_charp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_get_charp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="cp">#define param_check_charp(name, p) __param_check(name, p, char *)</span>

<span class="cm">/* We used to allow int as well as bool.  We&#39;re taking that away! */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">param_ops_bool</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_set_bool</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_get_bool</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="cp">#define param_check_bool(name, p) __param_check(name, p, bool)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">param_ops_invbool</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_set_invbool</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_get_invbool</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="cp">#define param_check_invbool(name, p) __param_check(name, p, bool)</span>

<span class="cm">/* An int, which can only be set like a bool (though it shows as an int). */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">param_ops_bint</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_set_bint</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="cp">#define param_get_bint param_get_int</span>
<span class="cp">#define param_check_bint param_check_int</span>

<span class="cm">/**</span>
<span class="cm"> * module_param_array - a parameter which is an array of some type</span>
<span class="cm"> * @name: the name of the array variable</span>
<span class="cm"> * @type: the type, as per module_param()</span>
<span class="cm"> * @nump: optional pointer filled in with the number written</span>
<span class="cm"> * @perm: visibility in sysfs</span>
<span class="cm"> *</span>
<span class="cm"> * Input and output are as comma-separated values.  Commas inside values</span>
<span class="cm"> * don&#39;t work properly (eg. an array of charp).</span>
<span class="cm"> *</span>
<span class="cm"> * ARRAY_SIZE(@name) is used to determine the number of elements in the</span>
<span class="cm"> * array, so the definition must be visible.</span>
<span class="cm"> */</span>
<span class="cp">#define module_param_array(name, type, nump, perm)		\</span>
<span class="cp">	module_param_array_named(name, name, type, nump, perm)</span>

<span class="cm">/**</span>
<span class="cm"> * module_param_array_named - renamed parameter which is an array of some type</span>
<span class="cm"> * @name: a valid C identifier which is the parameter name</span>
<span class="cm"> * @array: the name of the array variable</span>
<span class="cm"> * @type: the type, as per module_param()</span>
<span class="cm"> * @nump: optional pointer filled in with the number written</span>
<span class="cm"> * @perm: visibility in sysfs</span>
<span class="cm"> *</span>
<span class="cm"> * This exposes a different name than the actual variable name.  See</span>
<span class="cm"> * module_param_named() for why this might be necessary.</span>
<span class="cm"> */</span>
<span class="cp">#define module_param_array_named(name, array, type, nump, perm)		\</span>
<span class="cp">	param_check_##type(name, &amp;(array)[0]);				\</span>
<span class="cp">	static const struct kparam_array __param_arr_##name		\</span>
<span class="cp">	= { .max = ARRAY_SIZE(array), .num = nump,                      \</span>
<span class="cp">	    .ops = &amp;param_ops_##type,					\</span>
<span class="cp">	    .elemsize = sizeof(array[0]), .elem = array };		\</span>
<span class="cp">	__module_param_call(MODULE_PARAM_PREFIX, name,			\</span>
<span class="cp">			    &amp;param_array_ops,				\</span>
<span class="cp">			    .arr = &amp;__param_arr_##name,			\</span>
<span class="cp">			    perm, -1);					\</span>
<span class="cp">	__MODULE_PARM_TYPE(name, &quot;array of &quot; #type)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">param_array_ops</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kernel_param_ops</span> <span class="n">param_ops_string</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_set_copystring</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">param_get_string</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>

<span class="cm">/* for exporting parameters in /sys/parameters */</span>

<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_SYSFS) &amp;&amp; defined(CONFIG_MODULES)</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">module_param_sysfs_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kparam</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_params</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">module_param_sysfs_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">module_param_sysfs_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kparam</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">module_param_sysfs_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_MODULE_PARAMS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
