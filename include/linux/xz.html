<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › xz.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xz.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * XZ decompressor</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Lasse Collin &lt;lasse.collin@tukaani.org&gt;</span>
<span class="cm"> *          Igor Pavlov &lt;http://7-zip.org/&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file has been put into the public domain.</span>
<span class="cm"> * You can do whatever you want with this file.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef XZ_H</span>
<span class="cp">#define XZ_H</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#	include &lt;linux/stddef.h&gt;</span>
<span class="cp">#	include &lt;linux/types.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#	include &lt;stddef.h&gt;</span>
<span class="cp">#	include &lt;stdint.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/* In Linux, this is used to make extern functions static when needed. */</span>
<span class="cp">#ifndef XZ_EXTERN</span>
<span class="cp">#	define XZ_EXTERN extern</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * enum xz_mode - Operation mode</span>
<span class="cm"> *</span>
<span class="cm"> * @XZ_SINGLE:              Single-call mode. This uses less RAM than</span>
<span class="cm"> *                          than multi-call modes, because the LZMA2</span>
<span class="cm"> *                          dictionary doesn&#39;t need to be allocated as</span>
<span class="cm"> *                          part of the decoder state. All required data</span>
<span class="cm"> *                          structures are allocated at initialization,</span>
<span class="cm"> *                          so xz_dec_run() cannot return XZ_MEM_ERROR.</span>
<span class="cm"> * @XZ_PREALLOC:            Multi-call mode with preallocated LZMA2</span>
<span class="cm"> *                          dictionary buffer. All data structures are</span>
<span class="cm"> *                          allocated at initialization, so xz_dec_run()</span>
<span class="cm"> *                          cannot return XZ_MEM_ERROR.</span>
<span class="cm"> * @XZ_DYNALLOC:            Multi-call mode. The LZMA2 dictionary is</span>
<span class="cm"> *                          allocated once the required size has been</span>
<span class="cm"> *                          parsed from the stream headers. If the</span>
<span class="cm"> *                          allocation fails, xz_dec_run() will return</span>
<span class="cm"> *                          XZ_MEM_ERROR.</span>
<span class="cm"> *</span>
<span class="cm"> * It is possible to enable support only for a subset of the above</span>
<span class="cm"> * modes at compile time by defining XZ_DEC_SINGLE, XZ_DEC_PREALLOC,</span>
<span class="cm"> * or XZ_DEC_DYNALLOC. The xz_dec kernel module is always compiled</span>
<span class="cm"> * with support for all operation modes, but the preboot code may</span>
<span class="cm"> * be built with fewer features to minimize code size.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xz_mode</span> <span class="p">{</span>
	<span class="n">XZ_SINGLE</span><span class="p">,</span>
	<span class="n">XZ_PREALLOC</span><span class="p">,</span>
	<span class="n">XZ_DYNALLOC</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum xz_ret - Return codes</span>
<span class="cm"> * @XZ_OK:                  Everything is OK so far. More input or more</span>
<span class="cm"> *                          output space is required to continue. This</span>
<span class="cm"> *                          return code is possible only in multi-call mode</span>
<span class="cm"> *                          (XZ_PREALLOC or XZ_DYNALLOC).</span>
<span class="cm"> * @XZ_STREAM_END:          Operation finished successfully.</span>
<span class="cm"> * @XZ_UNSUPPORTED_CHECK:   Integrity check type is not supported. Decoding</span>
<span class="cm"> *                          is still possible in multi-call mode by simply</span>
<span class="cm"> *                          calling xz_dec_run() again.</span>
<span class="cm"> *                          Note that this return value is used only if</span>
<span class="cm"> *                          XZ_DEC_ANY_CHECK was defined at build time,</span>
<span class="cm"> *                          which is not used in the kernel. Unsupported</span>
<span class="cm"> *                          check types return XZ_OPTIONS_ERROR if</span>
<span class="cm"> *                          XZ_DEC_ANY_CHECK was not defined at build time.</span>
<span class="cm"> * @XZ_MEM_ERROR:           Allocating memory failed. This return code is</span>
<span class="cm"> *                          possible only if the decoder was initialized</span>
<span class="cm"> *                          with XZ_DYNALLOC. The amount of memory that was</span>
<span class="cm"> *                          tried to be allocated was no more than the</span>
<span class="cm"> *                          dict_max argument given to xz_dec_init().</span>
<span class="cm"> * @XZ_MEMLIMIT_ERROR:      A bigger LZMA2 dictionary would be needed than</span>
<span class="cm"> *                          allowed by the dict_max argument given to</span>
<span class="cm"> *                          xz_dec_init(). This return value is possible</span>
<span class="cm"> *                          only in multi-call mode (XZ_PREALLOC or</span>
<span class="cm"> *                          XZ_DYNALLOC); the single-call mode (XZ_SINGLE)</span>
<span class="cm"> *                          ignores the dict_max argument.</span>
<span class="cm"> * @XZ_FORMAT_ERROR:        File format was not recognized (wrong magic</span>
<span class="cm"> *                          bytes).</span>
<span class="cm"> * @XZ_OPTIONS_ERROR:       This implementation doesn&#39;t support the requested</span>
<span class="cm"> *                          compression options. In the decoder this means</span>
<span class="cm"> *                          that the header CRC32 matches, but the header</span>
<span class="cm"> *                          itself specifies something that we don&#39;t support.</span>
<span class="cm"> * @XZ_DATA_ERROR:          Compressed data is corrupt.</span>
<span class="cm"> * @XZ_BUF_ERROR:           Cannot make any progress. Details are slightly</span>
<span class="cm"> *                          different between multi-call and single-call</span>
<span class="cm"> *                          mode; more information below.</span>
<span class="cm"> *</span>
<span class="cm"> * In multi-call mode, XZ_BUF_ERROR is returned when two consecutive calls</span>
<span class="cm"> * to XZ code cannot consume any input and cannot produce any new output.</span>
<span class="cm"> * This happens when there is no new input available, or the output buffer</span>
<span class="cm"> * is full while at least one output byte is still pending. Assuming your</span>
<span class="cm"> * code is not buggy, you can get this error only when decoding a compressed</span>
<span class="cm"> * stream that is truncated or otherwise corrupt.</span>
<span class="cm"> *</span>
<span class="cm"> * In single-call mode, XZ_BUF_ERROR is returned only when the output buffer</span>
<span class="cm"> * is too small or the compressed input is corrupt in a way that makes the</span>
<span class="cm"> * decoder produce more output than the caller expected. When it is</span>
<span class="cm"> * (relatively) clear that the compressed input is truncated, XZ_DATA_ERROR</span>
<span class="cm"> * is used instead of XZ_BUF_ERROR.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xz_ret</span> <span class="p">{</span>
	<span class="n">XZ_OK</span><span class="p">,</span>
	<span class="n">XZ_STREAM_END</span><span class="p">,</span>
	<span class="n">XZ_UNSUPPORTED_CHECK</span><span class="p">,</span>
	<span class="n">XZ_MEM_ERROR</span><span class="p">,</span>
	<span class="n">XZ_MEMLIMIT_ERROR</span><span class="p">,</span>
	<span class="n">XZ_FORMAT_ERROR</span><span class="p">,</span>
	<span class="n">XZ_OPTIONS_ERROR</span><span class="p">,</span>
	<span class="n">XZ_DATA_ERROR</span><span class="p">,</span>
	<span class="n">XZ_BUF_ERROR</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct xz_buf - Passing input and output buffers to XZ code</span>
<span class="cm"> * @in:         Beginning of the input buffer. This may be NULL if and only</span>
<span class="cm"> *              if in_pos is equal to in_size.</span>
<span class="cm"> * @in_pos:     Current position in the input buffer. This must not exceed</span>
<span class="cm"> *              in_size.</span>
<span class="cm"> * @in_size:    Size of the input buffer</span>
<span class="cm"> * @out:        Beginning of the output buffer. This may be NULL if and only</span>
<span class="cm"> *              if out_pos is equal to out_size.</span>
<span class="cm"> * @out_pos:    Current position in the output buffer. This must not exceed</span>
<span class="cm"> *              out_size.</span>
<span class="cm"> * @out_size:   Size of the output buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Only the contents of the output buffer from out[out_pos] onward, and</span>
<span class="cm"> * the variables in_pos and out_pos are modified by the XZ code.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xz_buf</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">in</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">in_pos</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">in_size</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">out</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">out_pos</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">out_size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct xz_dec - Opaque type to hold the XZ decoder state</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xz_dec</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * xz_dec_init() - Allocate and initialize a XZ decoder state</span>
<span class="cm"> * @mode:       Operation mode</span>
<span class="cm"> * @dict_max:   Maximum size of the LZMA2 dictionary (history buffer) for</span>
<span class="cm"> *              multi-call decoding. This is ignored in single-call mode</span>
<span class="cm"> *              (mode == XZ_SINGLE). LZMA2 dictionary is always 2^n bytes</span>
<span class="cm"> *              or 2^n + 2^(n-1) bytes (the latter sizes are less common</span>
<span class="cm"> *              in practice), so other values for dict_max don&#39;t make sense.</span>
<span class="cm"> *              In the kernel, dictionary sizes of 64 KiB, 128 KiB, 256 KiB,</span>
<span class="cm"> *              512 KiB, and 1 MiB are probably the only reasonable values,</span>
<span class="cm"> *              except for kernel and initramfs images where a bigger</span>
<span class="cm"> *              dictionary can be fine and useful.</span>
<span class="cm"> *</span>
<span class="cm"> * Single-call mode (XZ_SINGLE): xz_dec_run() decodes the whole stream at</span>
<span class="cm"> * once. The caller must provide enough output space or the decoding will</span>
<span class="cm"> * fail. The output space is used as the dictionary buffer, which is why</span>
<span class="cm"> * there is no need to allocate the dictionary as part of the decoder&#39;s</span>
<span class="cm"> * internal state.</span>
<span class="cm"> *</span>
<span class="cm"> * Because the output buffer is used as the workspace, streams encoded using</span>
<span class="cm"> * a big dictionary are not a problem in single-call mode. It is enough that</span>
<span class="cm"> * the output buffer is big enough to hold the actual uncompressed data; it</span>
<span class="cm"> * can be smaller than the dictionary size stored in the stream headers.</span>
<span class="cm"> *</span>
<span class="cm"> * Multi-call mode with preallocated dictionary (XZ_PREALLOC): dict_max bytes</span>
<span class="cm"> * of memory is preallocated for the LZMA2 dictionary. This way there is no</span>
<span class="cm"> * risk that xz_dec_run() could run out of memory, since xz_dec_run() will</span>
<span class="cm"> * never allocate any memory. Instead, if the preallocated dictionary is too</span>
<span class="cm"> * small for decoding the given input stream, xz_dec_run() will return</span>
<span class="cm"> * XZ_MEMLIMIT_ERROR. Thus, it is important to know what kind of data will be</span>
<span class="cm"> * decoded to avoid allocating excessive amount of memory for the dictionary.</span>
<span class="cm"> *</span>
<span class="cm"> * Multi-call mode with dynamically allocated dictionary (XZ_DYNALLOC):</span>
<span class="cm"> * dict_max specifies the maximum allowed dictionary size that xz_dec_run()</span>
<span class="cm"> * may allocate once it has parsed the dictionary size from the stream</span>
<span class="cm"> * headers. This way excessive allocations can be avoided while still</span>
<span class="cm"> * limiting the maximum memory usage to a sane value to prevent running the</span>
<span class="cm"> * system out of memory when decompressing streams from untrusted sources.</span>
<span class="cm"> *</span>
<span class="cm"> * On success, xz_dec_init() returns a pointer to struct xz_dec, which is</span>
<span class="cm"> * ready to be used with xz_dec_run(). If memory allocation fails,</span>
<span class="cm"> * xz_dec_init() returns NULL.</span>
<span class="cm"> */</span>
<span class="n">XZ_EXTERN</span> <span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">xz_dec_init</span><span class="p">(</span><span class="k">enum</span> <span class="n">xz_mode</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">dict_max</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * xz_dec_run() - Run the XZ decoder</span>
<span class="cm"> * @s:          Decoder state allocated using xz_dec_init()</span>
<span class="cm"> * @b:          Input and output buffers</span>
<span class="cm"> *</span>
<span class="cm"> * The possible return values depend on build options and operation mode.</span>
<span class="cm"> * See enum xz_ret for details.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that if an error occurs in single-call mode (return value is not</span>
<span class="cm"> * XZ_STREAM_END), b-&gt;in_pos and b-&gt;out_pos are not modified and the</span>
<span class="cm"> * contents of the output buffer from b-&gt;out[b-&gt;out_pos] onward are</span>
<span class="cm"> * undefined. This is true even after XZ_BUF_ERROR, because with some filter</span>
<span class="cm"> * chains, there may be a second pass over the output buffer, and this pass</span>
<span class="cm"> * cannot be properly done if the output buffer is truncated. Thus, you</span>
<span class="cm"> * cannot give the single-call decoder a too small buffer and then expect to</span>
<span class="cm"> * get that amount valid data from the beginning of the stream. You must use</span>
<span class="cm"> * the multi-call decoder if you don&#39;t want to uncompress the whole stream.</span>
<span class="cm"> */</span>
<span class="n">XZ_EXTERN</span> <span class="k">enum</span> <span class="n">xz_ret</span> <span class="n">xz_dec_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xz_buf</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * xz_dec_reset() - Reset an already allocated decoder state</span>
<span class="cm"> * @s:          Decoder state allocated using xz_dec_init()</span>
<span class="cm"> *</span>
<span class="cm"> * This function can be used to reset the multi-call decoder state without</span>
<span class="cm"> * freeing and reallocating memory with xz_dec_end() and xz_dec_init().</span>
<span class="cm"> *</span>
<span class="cm"> * In single-call mode, xz_dec_reset() is always called in the beginning of</span>
<span class="cm"> * xz_dec_run(). Thus, explicit call to xz_dec_reset() is useful only in</span>
<span class="cm"> * multi-call mode.</span>
<span class="cm"> */</span>
<span class="n">XZ_EXTERN</span> <span class="kt">void</span> <span class="n">xz_dec_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * xz_dec_end() - Free the memory allocated for the decoder state</span>
<span class="cm"> * @s:          Decoder state allocated using xz_dec_init(). If s is NULL,</span>
<span class="cm"> *              this function does nothing.</span>
<span class="cm"> */</span>
<span class="n">XZ_EXTERN</span> <span class="kt">void</span> <span class="n">xz_dec_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Standalone build (userspace build or in-kernel build for boot time use)</span>
<span class="cm"> * needs a CRC32 implementation. For normal in-kernel use, kernel&#39;s own</span>
<span class="cm"> * CRC32 module is used instead, and users of this module don&#39;t need to</span>
<span class="cm"> * care about the functions below.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef XZ_INTERNAL_CRC32</span>
<span class="cp">#	ifdef __KERNEL__</span>
<span class="cp">#		define XZ_INTERNAL_CRC32 0</span>
<span class="cp">#	else</span>
<span class="cp">#		define XZ_INTERNAL_CRC32 1</span>
<span class="cp">#	endif</span>
<span class="cp">#endif</span>

<span class="cp">#if XZ_INTERNAL_CRC32</span>
<span class="cm">/*</span>
<span class="cm"> * This must be called before any other xz_* function to initialize</span>
<span class="cm"> * the CRC32 lookup table.</span>
<span class="cm"> */</span>
<span class="n">XZ_EXTERN</span> <span class="kt">void</span> <span class="n">xz_crc32_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Update CRC32 value using the polynomial from IEEE-802.3. To start a new</span>
<span class="cm"> * calculation, the third argument must be zero. To continue the calculation,</span>
<span class="cm"> * the previously returned value is passed as the third argument.</span>
<span class="cm"> */</span>
<span class="n">XZ_EXTERN</span> <span class="kt">uint32_t</span> <span class="n">xz_crc32</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
