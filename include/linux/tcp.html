<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › tcp.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tcp.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * INET		An implementation of the TCP/IP protocol suite for the LINUX</span>
<span class="cm"> *		operating system.  INET is implemented using the  BSD Socket</span>
<span class="cm"> *		interface as the means of communication with the user level.</span>
<span class="cm"> *</span>
<span class="cm"> *		Definitions for the TCP protocol.</span>
<span class="cm"> *</span>
<span class="cm"> * Version:	@(#)tcp.h	1.0.2	04/28/93</span>
<span class="cm"> *</span>
<span class="cm"> * Author:	Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *		This program is free software; you can redistribute it and/or</span>
<span class="cm"> *		modify it under the terms of the GNU General Public License</span>
<span class="cm"> *		as published by the Free Software Foundation; either version</span>
<span class="cm"> *		2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _LINUX_TCP_H</span>
<span class="cp">#define _LINUX_TCP_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>

<span class="k">struct</span> <span class="n">tcphdr</span> <span class="p">{</span>
	<span class="n">__be16</span>	<span class="n">source</span><span class="p">;</span>
	<span class="n">__be16</span>	<span class="n">dest</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">seq</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">ack_seq</span><span class="p">;</span>
<span class="cp">#if defined(__LITTLE_ENDIAN_BITFIELD)</span>
	<span class="n">__u16</span>	<span class="n">res1</span><span class="o">:</span><span class="mi">4</span><span class="p">,</span>
		<span class="nl">doff:</span><span class="mi">4</span><span class="p">,</span>
		<span class="nl">fin:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">syn:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">rst:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">psh:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">ack:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">urg:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">ece:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">cwr:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#elif defined(__BIG_ENDIAN_BITFIELD)</span>
	<span class="n">__u16</span>	<span class="n">doff</span><span class="o">:</span><span class="mi">4</span><span class="p">,</span>
		<span class="nl">res1:</span><span class="mi">4</span><span class="p">,</span>
		<span class="nl">cwr:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">ece:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">urg:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">ack:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">psh:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">rst:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">syn:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">fin:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#error	&quot;Adjust your &lt;asm/byteorder.h&gt; defines&quot;</span>
<span class="cp">#endif	</span>
	<span class="n">__be16</span>	<span class="n">window</span><span class="p">;</span>
	<span class="n">__sum16</span>	<span class="n">check</span><span class="p">;</span>
	<span class="n">__be16</span>	<span class="n">urg_ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	The union cast uses a gcc extension to avoid aliasing problems</span>
<span class="cm"> *  (union is compatible to any of its members)</span>
<span class="cm"> *  This means this part of the code is -fstrict-aliasing safe now.</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">tcp_word_hdr</span> <span class="p">{</span> 
	<span class="k">struct</span> <span class="n">tcphdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">__be32</span> 		  <span class="n">words</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">};</span> 

<span class="cp">#define tcp_flag_word(tp) ( ((union tcp_word_hdr *)(tp))-&gt;words [3]) </span>

<span class="k">enum</span> <span class="p">{</span> 
	<span class="n">TCP_FLAG_CWR</span> <span class="o">=</span> <span class="n">__constant_cpu_to_be32</span><span class="p">(</span><span class="mh">0x00800000</span><span class="p">),</span>
	<span class="n">TCP_FLAG_ECE</span> <span class="o">=</span> <span class="n">__constant_cpu_to_be32</span><span class="p">(</span><span class="mh">0x00400000</span><span class="p">),</span>
	<span class="n">TCP_FLAG_URG</span> <span class="o">=</span> <span class="n">__constant_cpu_to_be32</span><span class="p">(</span><span class="mh">0x00200000</span><span class="p">),</span>
	<span class="n">TCP_FLAG_ACK</span> <span class="o">=</span> <span class="n">__constant_cpu_to_be32</span><span class="p">(</span><span class="mh">0x00100000</span><span class="p">),</span>
	<span class="n">TCP_FLAG_PSH</span> <span class="o">=</span> <span class="n">__constant_cpu_to_be32</span><span class="p">(</span><span class="mh">0x00080000</span><span class="p">),</span>
	<span class="n">TCP_FLAG_RST</span> <span class="o">=</span> <span class="n">__constant_cpu_to_be32</span><span class="p">(</span><span class="mh">0x00040000</span><span class="p">),</span>
	<span class="n">TCP_FLAG_SYN</span> <span class="o">=</span> <span class="n">__constant_cpu_to_be32</span><span class="p">(</span><span class="mh">0x00020000</span><span class="p">),</span>
	<span class="n">TCP_FLAG_FIN</span> <span class="o">=</span> <span class="n">__constant_cpu_to_be32</span><span class="p">(</span><span class="mh">0x00010000</span><span class="p">),</span>
	<span class="n">TCP_RESERVED_BITS</span> <span class="o">=</span> <span class="n">__constant_cpu_to_be32</span><span class="p">(</span><span class="mh">0x0F000000</span><span class="p">),</span>
	<span class="n">TCP_DATA_OFFSET</span> <span class="o">=</span> <span class="n">__constant_cpu_to_be32</span><span class="p">(</span><span class="mh">0xF0000000</span><span class="p">)</span>
<span class="p">};</span> 

<span class="cm">/*</span>
<span class="cm"> * TCP general constants</span>
<span class="cm"> */</span>
<span class="cp">#define TCP_MSS_DEFAULT		 536U	</span><span class="cm">/* IPv4 (RFC1122, RFC2581) */</span><span class="cp"></span>
<span class="cp">#define TCP_MSS_DESIRED		1220U	</span><span class="cm">/* IPv6 (tunneled), EDNS0 (RFC3226) */</span><span class="cp"></span>

<span class="cm">/* TCP socket options */</span>
<span class="cp">#define TCP_NODELAY		1	</span><span class="cm">/* Turn off Nagle&#39;s algorithm. */</span><span class="cp"></span>
<span class="cp">#define TCP_MAXSEG		2	</span><span class="cm">/* Limit MSS */</span><span class="cp"></span>
<span class="cp">#define TCP_CORK		3	</span><span class="cm">/* Never send partially complete segments */</span><span class="cp"></span>
<span class="cp">#define TCP_KEEPIDLE		4	</span><span class="cm">/* Start keeplives after this period */</span><span class="cp"></span>
<span class="cp">#define TCP_KEEPINTVL		5	</span><span class="cm">/* Interval between keepalives */</span><span class="cp"></span>
<span class="cp">#define TCP_KEEPCNT		6	</span><span class="cm">/* Number of keepalives before death */</span><span class="cp"></span>
<span class="cp">#define TCP_SYNCNT		7	</span><span class="cm">/* Number of SYN retransmits */</span><span class="cp"></span>
<span class="cp">#define TCP_LINGER2		8	</span><span class="cm">/* Life time of orphaned FIN-WAIT-2 state */</span><span class="cp"></span>
<span class="cp">#define TCP_DEFER_ACCEPT	9	</span><span class="cm">/* Wake up listener only when data arrive */</span><span class="cp"></span>
<span class="cp">#define TCP_WINDOW_CLAMP	10	</span><span class="cm">/* Bound advertised window */</span><span class="cp"></span>
<span class="cp">#define TCP_INFO		11	</span><span class="cm">/* Information about this connection. */</span><span class="cp"></span>
<span class="cp">#define TCP_QUICKACK		12	</span><span class="cm">/* Block/reenable quick acks */</span><span class="cp"></span>
<span class="cp">#define TCP_CONGESTION		13	</span><span class="cm">/* Congestion control algorithm */</span><span class="cp"></span>
<span class="cp">#define TCP_MD5SIG		14	</span><span class="cm">/* TCP MD5 Signature (RFC2385) */</span><span class="cp"></span>
<span class="cp">#define TCP_COOKIE_TRANSACTIONS	15	</span><span class="cm">/* TCP Cookie Transactions */</span><span class="cp"></span>
<span class="cp">#define TCP_THIN_LINEAR_TIMEOUTS 16      </span><span class="cm">/* Use linear timeouts for thin streams*/</span><span class="cp"></span>
<span class="cp">#define TCP_THIN_DUPACK         17      </span><span class="cm">/* Fast retrans. after 1 dupack */</span><span class="cp"></span>
<span class="cp">#define TCP_USER_TIMEOUT	18	</span><span class="cm">/* How long for loss retry before timeout */</span><span class="cp"></span>
<span class="cp">#define TCP_REPAIR		19	</span><span class="cm">/* TCP sock is under repair right now */</span><span class="cp"></span>
<span class="cp">#define TCP_REPAIR_QUEUE	20</span>
<span class="cp">#define TCP_QUEUE_SEQ		21</span>
<span class="cp">#define TCP_REPAIR_OPTIONS	22</span>

<span class="k">struct</span> <span class="n">tcp_repair_opt</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">opt_code</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">opt_val</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">TCP_NO_QUEUE</span><span class="p">,</span>
	<span class="n">TCP_RECV_QUEUE</span><span class="p">,</span>
	<span class="n">TCP_SEND_QUEUE</span><span class="p">,</span>
	<span class="n">TCP_QUEUES_NR</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* for TCP_INFO socket option */</span>
<span class="cp">#define TCPI_OPT_TIMESTAMPS	1</span>
<span class="cp">#define TCPI_OPT_SACK		2</span>
<span class="cp">#define TCPI_OPT_WSCALE		4</span>
<span class="cp">#define TCPI_OPT_ECN		8 </span><span class="cm">/* ECN was negociated at TCP session init */</span><span class="cp"></span>
<span class="cp">#define TCPI_OPT_ECN_SEEN	16 </span><span class="cm">/* we received at least one packet with ECT */</span><span class="cp"></span>

<span class="k">enum</span> <span class="n">tcp_ca_state</span> <span class="p">{</span>
	<span class="n">TCP_CA_Open</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="cp">#define TCPF_CA_Open	(1&lt;&lt;TCP_CA_Open)</span>
	<span class="n">TCP_CA_Disorder</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="cp">#define TCPF_CA_Disorder (1&lt;&lt;TCP_CA_Disorder)</span>
	<span class="n">TCP_CA_CWR</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="cp">#define TCPF_CA_CWR	(1&lt;&lt;TCP_CA_CWR)</span>
	<span class="n">TCP_CA_Recovery</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="cp">#define TCPF_CA_Recovery (1&lt;&lt;TCP_CA_Recovery)</span>
	<span class="n">TCP_CA_Loss</span> <span class="o">=</span> <span class="mi">4</span>
<span class="cp">#define TCPF_CA_Loss	(1&lt;&lt;TCP_CA_Loss)</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tcp_info</span> <span class="p">{</span>
	<span class="n">__u8</span>	<span class="n">tcpi_state</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">tcpi_ca_state</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">tcpi_retransmits</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">tcpi_probes</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">tcpi_backoff</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">tcpi_options</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">tcpi_snd_wscale</span> <span class="o">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">tcpi_rcv_wscale</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">__u32</span>	<span class="n">tcpi_rto</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_ato</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_snd_mss</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_rcv_mss</span><span class="p">;</span>

	<span class="n">__u32</span>	<span class="n">tcpi_unacked</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_sacked</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_lost</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_retrans</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_fackets</span><span class="p">;</span>

	<span class="cm">/* Times. */</span>
	<span class="n">__u32</span>	<span class="n">tcpi_last_data_sent</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_last_ack_sent</span><span class="p">;</span>     <span class="cm">/* Not remembered, sorry. */</span>
	<span class="n">__u32</span>	<span class="n">tcpi_last_data_recv</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_last_ack_recv</span><span class="p">;</span>

	<span class="cm">/* Metrics. */</span>
	<span class="n">__u32</span>	<span class="n">tcpi_pmtu</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_rcv_ssthresh</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_rtt</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_rttvar</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_snd_ssthresh</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_snd_cwnd</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_advmss</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_reordering</span><span class="p">;</span>

	<span class="n">__u32</span>	<span class="n">tcpi_rcv_rtt</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tcpi_rcv_space</span><span class="p">;</span>

	<span class="n">__u32</span>	<span class="n">tcpi_total_retrans</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* for TCP_MD5SIG socket option */</span>
<span class="cp">#define TCP_MD5SIG_MAXKEYLEN	80</span>

<span class="k">struct</span> <span class="n">tcp_md5sig</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">__kernel_sockaddr_storage</span> <span class="n">tcpm_addr</span><span class="p">;</span>	<span class="cm">/* address associated */</span>
	<span class="n">__u16</span>	<span class="n">__tcpm_pad1</span><span class="p">;</span>				<span class="cm">/* zero */</span>
	<span class="n">__u16</span>	<span class="n">tcpm_keylen</span><span class="p">;</span>				<span class="cm">/* key length */</span>
	<span class="n">__u32</span>	<span class="n">__tcpm_pad2</span><span class="p">;</span>				<span class="cm">/* zero */</span>
	<span class="n">__u8</span>	<span class="n">tcpm_key</span><span class="p">[</span><span class="n">TCP_MD5SIG_MAXKEYLEN</span><span class="p">];</span>		<span class="cm">/* key (binary) */</span>
<span class="p">};</span>

<span class="cm">/* for TCP_COOKIE_TRANSACTIONS (TCPCT) socket option */</span>
<span class="cp">#define TCP_COOKIE_MIN		 8		</span><span class="cm">/*  64-bits */</span><span class="cp"></span>
<span class="cp">#define TCP_COOKIE_MAX		16		</span><span class="cm">/* 128-bits */</span><span class="cp"></span>
<span class="cp">#define TCP_COOKIE_PAIR_SIZE	(2*TCP_COOKIE_MAX)</span>

<span class="cm">/* Flags for both getsockopt and setsockopt */</span>
<span class="cp">#define TCP_COOKIE_IN_ALWAYS	(1 &lt;&lt; 0)	</span><span class="cm">/* Discard SYN without cookie */</span><span class="cp"></span>
<span class="cp">#define TCP_COOKIE_OUT_NEVER	(1 &lt;&lt; 1)	</span><span class="cm">/* Prohibit outgoing cookies,</span>
<span class="cm">						 * supercedes everything. */</span><span class="cp"></span>

<span class="cm">/* Flags for getsockopt */</span>
<span class="cp">#define TCP_S_DATA_IN		(1 &lt;&lt; 2)	</span><span class="cm">/* Was data received? */</span><span class="cp"></span>
<span class="cp">#define TCP_S_DATA_OUT		(1 &lt;&lt; 3)	</span><span class="cm">/* Was data sent? */</span><span class="cp"></span>

<span class="cm">/* TCP_COOKIE_TRANSACTIONS data */</span>
<span class="k">struct</span> <span class="n">tcp_cookie_transactions</span> <span class="p">{</span>
	<span class="n">__u16</span>	<span class="n">tcpct_flags</span><span class="p">;</span>			<span class="cm">/* see above */</span>
	<span class="n">__u8</span>	<span class="n">__tcpct_pad1</span><span class="p">;</span>			<span class="cm">/* zero */</span>
	<span class="n">__u8</span>	<span class="n">tcpct_cookie_desired</span><span class="p">;</span>		<span class="cm">/* bytes */</span>
	<span class="n">__u16</span>	<span class="n">tcpct_s_data_desired</span><span class="p">;</span>		<span class="cm">/* bytes of variable data */</span>
	<span class="n">__u16</span>	<span class="n">tcpct_used</span><span class="p">;</span>			<span class="cm">/* bytes in value */</span>
	<span class="n">__u8</span>	<span class="n">tcpct_value</span><span class="p">[</span><span class="n">TCP_MSS_DEFAULT</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/dmaengine.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/inet_connection_sock.h&gt;</span>
<span class="cp">#include &lt;net/inet_timewait_sock.h&gt;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="nf">tcp_hdr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tcp_hdrlen</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tcp_optlen</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This defines a selective acknowledgement block. */</span>
<span class="k">struct</span> <span class="n">tcp_sack_block_wire</span> <span class="p">{</span>
	<span class="n">__be32</span>	<span class="n">start_seq</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">end_seq</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tcp_sack_block</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">start_seq</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">end_seq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*These are used to set the sack_ok field in struct tcp_options_received */</span>
<span class="cp">#define TCP_SACK_SEEN     (1 &lt;&lt; 0)   </span><span class="cm">/*1 = peer is SACK capable, */</span><span class="cp"></span>
<span class="cp">#define TCP_FACK_ENABLED  (1 &lt;&lt; 1)   </span><span class="cm">/*1 = FACK is enabled locally*/</span><span class="cp"></span>
<span class="cp">#define TCP_DSACK_SEEN    (1 &lt;&lt; 2)   </span><span class="cm">/*1 = DSACK was received from peer*/</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">tcp_options_received</span> <span class="p">{</span>
<span class="cm">/*	PAWS/RTTM data	*/</span>
	<span class="kt">long</span>	<span class="n">ts_recent_stamp</span><span class="p">;</span><span class="cm">/* Time we stored ts_recent (for aging) */</span>
	<span class="n">u32</span>	<span class="n">ts_recent</span><span class="p">;</span>	<span class="cm">/* Time stamp to echo next		*/</span>
	<span class="n">u32</span>	<span class="n">rcv_tsval</span><span class="p">;</span>	<span class="cm">/* Time stamp value             	*/</span>
	<span class="n">u32</span>	<span class="n">rcv_tsecr</span><span class="p">;</span>	<span class="cm">/* Time stamp echo reply        	*/</span>
	<span class="n">u16</span> 	<span class="n">saw_tstamp</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* Saw TIMESTAMP on last packet		*/</span>
		<span class="n">tstamp_ok</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* TIMESTAMP seen on SYN packet		*/</span>
		<span class="n">dsack</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* D-SACK is scheduled			*/</span>
		<span class="n">wscale_ok</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* Wscale seen on SYN packet		*/</span>
		<span class="n">sack_ok</span> <span class="o">:</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/* SACK seen on SYN packet		*/</span>
		<span class="n">snd_wscale</span> <span class="o">:</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/* Window scaling received from sender	*/</span>
		<span class="n">rcv_wscale</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>	<span class="cm">/* Window scaling to send to receiver	*/</span>
	<span class="n">u8</span>	<span class="n">cookie_plus</span><span class="o">:</span><span class="mi">6</span><span class="p">,</span>	<span class="cm">/* bytes in authenticator/cookie option	*/</span>
		<span class="nl">cookie_out_never:</span><span class="mi">1</span><span class="p">,</span>
		<span class="nl">cookie_in_always:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">num_sacks</span><span class="p">;</span>	<span class="cm">/* Number of SACK blocks		*/</span>
	<span class="n">u16</span>	<span class="n">user_mss</span><span class="p">;</span>	<span class="cm">/* mss requested by user in ioctl	*/</span>
	<span class="n">u16</span>	<span class="n">mss_clamp</span><span class="p">;</span>	<span class="cm">/* Maximal mss, negotiated at connection setup */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_clear_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_options_received</span> <span class="o">*</span><span class="n">rx_opt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">tstamp_ok</span> <span class="o">=</span> <span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">sack_ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">wscale_ok</span> <span class="o">=</span> <span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">snd_wscale</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">cookie_plus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is the max number of SACKS that we&#39;ll generate and process. It&#39;s safe</span>
<span class="cm"> * to increase this, although since:</span>
<span class="cm"> *   size = TCPOLEN_SACK_BASE_ALIGNED (4) + n * TCPOLEN_SACK_PERBLOCK (8)</span>
<span class="cm"> * only four options will fit in a standard TCP header */</span>
<span class="cp">#define TCP_NUM_SACKS 4</span>

<span class="k">struct</span> <span class="n">tcp_cookie_values</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">tcp_request_sock_ops</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">tcp_request_sock</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_request_sock</span> 	<span class="n">req</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
	<span class="cm">/* Only used by TCP MD5 Signature so far. */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_request_sock_ops</span> <span class="o">*</span><span class="n">af_specific</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">u32</span>				<span class="n">rcv_isn</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">snt_isn</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">snt_synack</span><span class="p">;</span> <span class="cm">/* synack sent time */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tcp_request_sock</span> <span class="o">*</span><span class="nf">tcp_rsk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tcp_request_sock</span> <span class="o">*</span><span class="p">)</span><span class="n">req</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="p">{</span>
	<span class="cm">/* inet_connection_sock has to be the first member of tcp_sock */</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span>	<span class="n">inet_conn</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">tcp_header_len</span><span class="p">;</span>	<span class="cm">/* Bytes of tcp header to send		*/</span>
	<span class="n">u16</span>	<span class="n">xmit_size_goal_segs</span><span class="p">;</span> <span class="cm">/* Goal for segmenting output packets */</span>

<span class="cm">/*</span>
<span class="cm"> *	Header prediction flags</span>
<span class="cm"> *	0x5?10 &lt;&lt; 16 + snd_wnd in net byte order</span>
<span class="cm"> */</span>
	<span class="n">__be32</span>	<span class="n">pred_flags</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *	RFC793 variables by their proper names. This means you can</span>
<span class="cm"> *	read the code and the spec side by side (and laugh ...)</span>
<span class="cm"> *	See RFC793 and RFC1122. The RFC writes these in capitals.</span>
<span class="cm"> */</span>
 	<span class="n">u32</span>	<span class="n">rcv_nxt</span><span class="p">;</span>	<span class="cm">/* What we want to receive next 	*/</span>
	<span class="n">u32</span>	<span class="n">copied_seq</span><span class="p">;</span>	<span class="cm">/* Head of yet unread data		*/</span>
	<span class="n">u32</span>	<span class="n">rcv_wup</span><span class="p">;</span>	<span class="cm">/* rcv_nxt on last window update sent	*/</span>
 	<span class="n">u32</span>	<span class="n">snd_nxt</span><span class="p">;</span>	<span class="cm">/* Next sequence we send		*/</span>

 	<span class="n">u32</span>	<span class="n">snd_una</span><span class="p">;</span>	<span class="cm">/* First byte we want an ack for	*/</span>
 	<span class="n">u32</span>	<span class="n">snd_sml</span><span class="p">;</span>	<span class="cm">/* Last byte of the most recently transmitted small packet */</span>
	<span class="n">u32</span>	<span class="n">rcv_tstamp</span><span class="p">;</span>	<span class="cm">/* timestamp of last received ACK (for keepalives) */</span>
	<span class="n">u32</span>	<span class="n">lsndtime</span><span class="p">;</span>	<span class="cm">/* timestamp of last sent data packet (for restart window) */</span>

	<span class="cm">/* Data for direct copy to user */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff_head</span>	<span class="n">prequeue</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">task</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">iovec</span>		<span class="o">*</span><span class="n">iov</span><span class="p">;</span>
		<span class="kt">int</span>			<span class="n">memory</span><span class="p">;</span>
		<span class="kt">int</span>			<span class="n">len</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NET_DMA</span>
		<span class="cm">/* members for async copy */</span>
		<span class="k">struct</span> <span class="n">dma_chan</span>		<span class="o">*</span><span class="n">dma_chan</span><span class="p">;</span>
		<span class="kt">int</span>			<span class="n">wakeup</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dma_pinned_list</span>	<span class="o">*</span><span class="n">pinned_list</span><span class="p">;</span>
		<span class="n">dma_cookie_t</span>		<span class="n">dma_cookie</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="n">ucopy</span><span class="p">;</span>

	<span class="n">u32</span>	<span class="n">snd_wl1</span><span class="p">;</span>	<span class="cm">/* Sequence for window update		*/</span>
	<span class="n">u32</span>	<span class="n">snd_wnd</span><span class="p">;</span>	<span class="cm">/* The window we expect to receive	*/</span>
	<span class="n">u32</span>	<span class="n">max_window</span><span class="p">;</span>	<span class="cm">/* Maximal window ever seen from peer	*/</span>
	<span class="n">u32</span>	<span class="n">mss_cache</span><span class="p">;</span>	<span class="cm">/* Cached effective mss, not including SACKS */</span>

	<span class="n">u32</span>	<span class="n">window_clamp</span><span class="p">;</span>	<span class="cm">/* Maximal window to advertise		*/</span>
	<span class="n">u32</span>	<span class="n">rcv_ssthresh</span><span class="p">;</span>	<span class="cm">/* Current window clamp			*/</span>

	<span class="n">u32</span>	<span class="n">frto_highmark</span><span class="p">;</span>	<span class="cm">/* snd_nxt when RTO occurred */</span>
	<span class="n">u16</span>	<span class="n">advmss</span><span class="p">;</span>		<span class="cm">/* Advertised MSS			*/</span>
	<span class="n">u8</span>	<span class="n">frto_counter</span><span class="p">;</span>	<span class="cm">/* Number of new acks after RTO */</span>
	<span class="n">u8</span>	<span class="n">nonagle</span>     <span class="o">:</span> <span class="mi">4</span><span class="p">,</span><span class="cm">/* Disable Nagle algorithm?             */</span>
		<span class="n">thin_lto</span>    <span class="o">:</span> <span class="mi">1</span><span class="p">,</span><span class="cm">/* Use linear timeouts for thin streams */</span>
		<span class="n">thin_dupack</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span><span class="cm">/* Fast retransmit on first dupack      */</span>
		<span class="n">repair</span>      <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="n">unused</span>      <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">repair_queue</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">do_early_retrans</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span><span class="cm">/* Enable RFC5827 early-retransmit  */</span>
		<span class="nl">early_retrans_delayed:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Delayed ER timer installed */</span>

<span class="cm">/* RTT measurement */</span>
	<span class="n">u32</span>	<span class="n">srtt</span><span class="p">;</span>		<span class="cm">/* smoothed round trip time &lt;&lt; 3	*/</span>
	<span class="n">u32</span>	<span class="n">mdev</span><span class="p">;</span>		<span class="cm">/* medium deviation			*/</span>
	<span class="n">u32</span>	<span class="n">mdev_max</span><span class="p">;</span>	<span class="cm">/* maximal mdev for the last rtt period	*/</span>
	<span class="n">u32</span>	<span class="n">rttvar</span><span class="p">;</span>		<span class="cm">/* smoothed mdev_max			*/</span>
	<span class="n">u32</span>	<span class="n">rtt_seq</span><span class="p">;</span>	<span class="cm">/* sequence number to update rttvar	*/</span>

	<span class="n">u32</span>	<span class="n">packets_out</span><span class="p">;</span>	<span class="cm">/* Packets which are &quot;in flight&quot;	*/</span>
	<span class="n">u32</span>	<span class="n">retrans_out</span><span class="p">;</span>	<span class="cm">/* Retransmitted packets out		*/</span>

	<span class="n">u16</span>	<span class="n">urg_data</span><span class="p">;</span>	<span class="cm">/* Saved octet of OOB data and control flags */</span>
	<span class="n">u8</span>	<span class="n">ecn_flags</span><span class="p">;</span>	<span class="cm">/* ECN status bits.			*/</span>
	<span class="n">u8</span>	<span class="n">reordering</span><span class="p">;</span>	<span class="cm">/* Packet reordering metric.		*/</span>
	<span class="n">u32</span>	<span class="n">snd_up</span><span class="p">;</span>		<span class="cm">/* Urgent pointer		*/</span>

	<span class="n">u8</span>	<span class="n">keepalive_probes</span><span class="p">;</span> <span class="cm">/* num of allowed keep alive probes	*/</span>
<span class="cm">/*</span>
<span class="cm"> *      Options received (usually on last packet, some only on SYN packets).</span>
<span class="cm"> */</span>
	<span class="k">struct</span> <span class="n">tcp_options_received</span> <span class="n">rx_opt</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *	Slow start and congestion control (see also Nagle, and Karn &amp; Partridge)</span>
<span class="cm"> */</span>
 	<span class="n">u32</span>	<span class="n">snd_ssthresh</span><span class="p">;</span>	<span class="cm">/* Slow start size threshold		*/</span>
 	<span class="n">u32</span>	<span class="n">snd_cwnd</span><span class="p">;</span>	<span class="cm">/* Sending congestion window		*/</span>
	<span class="n">u32</span>	<span class="n">snd_cwnd_cnt</span><span class="p">;</span>	<span class="cm">/* Linear increase counter		*/</span>
	<span class="n">u32</span>	<span class="n">snd_cwnd_clamp</span><span class="p">;</span> <span class="cm">/* Do not allow snd_cwnd to grow above this */</span>
	<span class="n">u32</span>	<span class="n">snd_cwnd_used</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">snd_cwnd_stamp</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">prior_cwnd</span><span class="p">;</span>	<span class="cm">/* Congestion window at start of Recovery. */</span>
	<span class="n">u32</span>	<span class="n">prr_delivered</span><span class="p">;</span>	<span class="cm">/* Number of newly delivered packets to</span>
<span class="cm">				 * receiver in Recovery. */</span>
	<span class="n">u32</span>	<span class="n">prr_out</span><span class="p">;</span>	<span class="cm">/* Total number of pkts sent during Recovery. */</span>

 	<span class="n">u32</span>	<span class="n">rcv_wnd</span><span class="p">;</span>	<span class="cm">/* Current receiver window		*/</span>
	<span class="n">u32</span>	<span class="n">write_seq</span><span class="p">;</span>	<span class="cm">/* Tail(+1) of data held in tcp send buffer */</span>
	<span class="n">u32</span>	<span class="n">pushed_seq</span><span class="p">;</span>	<span class="cm">/* Last pushed seq, required to talk to windows */</span>
	<span class="n">u32</span>	<span class="n">lost_out</span><span class="p">;</span>	<span class="cm">/* Lost packets			*/</span>
	<span class="n">u32</span>	<span class="n">sacked_out</span><span class="p">;</span>	<span class="cm">/* SACK&#39;d packets			*/</span>
	<span class="n">u32</span>	<span class="n">fackets_out</span><span class="p">;</span>	<span class="cm">/* FACK&#39;d packets			*/</span>
	<span class="n">u32</span>	<span class="n">tso_deferred</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">bytes_acked</span><span class="p">;</span>	<span class="cm">/* Appropriate Byte Counting - RFC3465 */</span>

	<span class="cm">/* from STCP, retrans queue hinting */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span> <span class="n">lost_skb_hint</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">scoreboard_skb_hint</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">retransmit_skb_hint</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sk_buff_head</span>	<span class="n">out_of_order_queue</span><span class="p">;</span> <span class="cm">/* Out of order segments go here */</span>

	<span class="cm">/* SACKs data, these 2 need to be together (see tcp_options_write) */</span>
	<span class="k">struct</span> <span class="n">tcp_sack_block</span> <span class="n">duplicate_sack</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* D-SACK block */</span>
	<span class="k">struct</span> <span class="n">tcp_sack_block</span> <span class="n">selective_acks</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="cm">/* The SACKS themselves*/</span>

	<span class="k">struct</span> <span class="n">tcp_sack_block</span> <span class="n">recv_sack_cache</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">highest_sack</span><span class="p">;</span>   <span class="cm">/* skb just after the highest</span>
<span class="cm">					 * skb with SACKed bit set</span>
<span class="cm">					 * (validity guaranteed only if</span>
<span class="cm">					 * sacked_out &gt; 0)</span>
<span class="cm">					 */</span>

	<span class="kt">int</span>     <span class="n">lost_cnt_hint</span><span class="p">;</span>
	<span class="n">u32</span>     <span class="n">retransmit_high</span><span class="p">;</span>	<span class="cm">/* L-bits may be on up to this seqno */</span>

	<span class="n">u32</span>	<span class="n">lost_retrans_low</span><span class="p">;</span>	<span class="cm">/* Sent seq after any rxmit (lowest) */</span>

	<span class="n">u32</span>	<span class="n">prior_ssthresh</span><span class="p">;</span> <span class="cm">/* ssthresh saved at recovery start	*/</span>
	<span class="n">u32</span>	<span class="n">high_seq</span><span class="p">;</span>	<span class="cm">/* snd_nxt at onset of congestion	*/</span>

	<span class="n">u32</span>	<span class="n">retrans_stamp</span><span class="p">;</span>	<span class="cm">/* Timestamp of the last retransmit,</span>
<span class="cm">				 * also used in SYN-SENT to remember stamp of</span>
<span class="cm">				 * the first SYN. */</span>
	<span class="n">u32</span>	<span class="n">undo_marker</span><span class="p">;</span>	<span class="cm">/* tracking retrans started here. */</span>
	<span class="kt">int</span>	<span class="n">undo_retrans</span><span class="p">;</span>	<span class="cm">/* number of undoable retransmissions. */</span>
	<span class="n">u32</span>	<span class="n">total_retrans</span><span class="p">;</span>	<span class="cm">/* Total retransmits for entire connection */</span>

	<span class="n">u32</span>	<span class="n">urg_seq</span><span class="p">;</span>	<span class="cm">/* Seq of received urgent pointer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">keepalive_time</span><span class="p">;</span>	  <span class="cm">/* time before keep alive takes place */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">keepalive_intvl</span><span class="p">;</span>  <span class="cm">/* time interval between keep alive probes */</span>

	<span class="kt">int</span>			<span class="n">linger2</span><span class="p">;</span>

<span class="cm">/* Receiver side RTT estimation */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u32</span>	<span class="n">rtt</span><span class="p">;</span>
		<span class="n">u32</span>	<span class="n">seq</span><span class="p">;</span>
		<span class="n">u32</span>	<span class="n">time</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">rcv_rtt_est</span><span class="p">;</span>

<span class="cm">/* Receiver queue space */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">space</span><span class="p">;</span>
		<span class="n">u32</span>	<span class="n">seq</span><span class="p">;</span>
		<span class="n">u32</span>	<span class="n">time</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">rcvq_space</span><span class="p">;</span>

<span class="cm">/* TCP-specific MTU probe information. */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u32</span>		  <span class="n">probe_seq_start</span><span class="p">;</span>
		<span class="n">u32</span>		  <span class="n">probe_seq_end</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">mtu_probe</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
<span class="cm">/* TCP AF-Specific parts; only used by MD5 Signature support so far */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock_af_ops</span>	<span class="o">*</span><span class="n">af_specific</span><span class="p">;</span>

<span class="cm">/* TCP MD5 Signature Option information */</span>
	<span class="k">struct</span> <span class="n">tcp_md5sig_info</span>	<span class="n">__rcu</span> <span class="o">*</span><span class="n">md5sig_info</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* When the cookie options are generated and exchanged, then this</span>
<span class="cm">	 * object holds a reference to them (cookie_values-&gt;kref).  Also</span>
<span class="cm">	 * contains related tcp_cookie_transactions fields.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">tcp_cookie_values</span>  <span class="o">*</span><span class="n">cookie_values</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="nf">tcp_sk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="p">)</span><span class="n">sk</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">tcp_timewait_sock</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_timewait_sock</span> <span class="n">tw_sk</span><span class="p">;</span>
	<span class="n">u32</span>			  <span class="n">tw_rcv_nxt</span><span class="p">;</span>
	<span class="n">u32</span>			  <span class="n">tw_snd_nxt</span><span class="p">;</span>
	<span class="n">u32</span>			  <span class="n">tw_rcv_wnd</span><span class="p">;</span>
	<span class="n">u32</span>			  <span class="n">tw_ts_recent</span><span class="p">;</span>
	<span class="kt">long</span>			  <span class="n">tw_ts_recent_stamp</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
	<span class="k">struct</span> <span class="n">tcp_md5sig_key</span>	<span class="o">*</span><span class="n">tw_md5_key</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* Few sockets in timewait have cookies; in that case, then this</span>
<span class="cm">	 * object holds a reference to them (tw_cookie_values-&gt;kref).</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">tcp_cookie_values</span>  <span class="o">*</span><span class="n">tw_cookie_values</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tcp_timewait_sock</span> <span class="o">*</span><span class="nf">tcp_twsk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tcp_timewait_sock</span> <span class="o">*</span><span class="p">)</span><span class="n">sk</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif	</span><span class="cm">/* _LINUX_TCP_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
