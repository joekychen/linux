<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › nilfs2_fs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>nilfs2_fs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * nilfs2_fs.h - NILFS2 on-disk structures and common declarations.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2008 Nippon Telegraph and Telephone Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU Lesser General Public License as published</span>
<span class="cm"> * by the Free Software Foundation; either version 2.1 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU Lesser General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU Lesser General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Koji Sato &lt;koji@osrg.net&gt;</span>
<span class="cm"> *            Ryusuke Konishi &lt;ryusuke@osrg.net&gt;</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> *  linux/include/linux/ext2_fs.h</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992, 1993, 1994, 1995</span>
<span class="cm"> * Remy Card (card@masi.ibp.fr)</span>
<span class="cm"> * Laboratoire MASI - Institut Blaise Pascal</span>
<span class="cm"> * Universite Pierre et Marie Curie (Paris VI)</span>
<span class="cm"> *</span>
<span class="cm"> *  from</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/include/linux/minix_fs.h</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_NILFS_FS_H</span>
<span class="cp">#define _LINUX_NILFS_FS_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/magic.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>


<span class="cp">#define NILFS_INODE_BMAP_SIZE	7</span>
<span class="cm">/**</span>
<span class="cm"> * struct nilfs_inode - structure of an inode on disk</span>
<span class="cm"> * @i_blocks: blocks count</span>
<span class="cm"> * @i_size: size in bytes</span>
<span class="cm"> * @i_ctime: creation time (seconds)</span>
<span class="cm"> * @i_mtime: modification time (seconds)</span>
<span class="cm"> * @i_ctime_nsec: creation time (nano seconds)</span>
<span class="cm"> * @i_mtime_nsec: modification time (nano seconds)</span>
<span class="cm"> * @i_uid: user id</span>
<span class="cm"> * @i_gid: group id</span>
<span class="cm"> * @i_mode: file mode</span>
<span class="cm"> * @i_links_count: links count</span>
<span class="cm"> * @i_flags: file flags</span>
<span class="cm"> * @i_bmap: block mapping</span>
<span class="cm"> * @i_xattr: extended attributes</span>
<span class="cm"> * @i_generation: file generation (for NFS)</span>
<span class="cm"> * @i_pad:	padding</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_inode</span> <span class="p">{</span>
	<span class="n">__le64</span>	<span class="n">i_blocks</span><span class="p">;</span>
	<span class="n">__le64</span>	<span class="n">i_size</span><span class="p">;</span>
	<span class="n">__le64</span>	<span class="n">i_ctime</span><span class="p">;</span>
	<span class="n">__le64</span>	<span class="n">i_mtime</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">i_ctime_nsec</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">i_mtime_nsec</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">i_uid</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">i_gid</span><span class="p">;</span>
	<span class="n">__le16</span>	<span class="n">i_mode</span><span class="p">;</span>
	<span class="n">__le16</span>	<span class="n">i_links_count</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">i_flags</span><span class="p">;</span>
	<span class="n">__le64</span>	<span class="n">i_bmap</span><span class="p">[</span><span class="n">NILFS_INODE_BMAP_SIZE</span><span class="p">];</span>
<span class="cp">#define i_device_code	i_bmap[0]</span>
	<span class="n">__le64</span>	<span class="n">i_xattr</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">i_generation</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">i_pad</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_super_root - structure of super root</span>
<span class="cm"> * @sr_sum: check sum</span>
<span class="cm"> * @sr_bytes: byte count of the structure</span>
<span class="cm"> * @sr_flags: flags (reserved)</span>
<span class="cm"> * @sr_nongc_ctime: write time of the last segment not for cleaner operation</span>
<span class="cm"> * @sr_dat: DAT file inode</span>
<span class="cm"> * @sr_cpfile: checkpoint file inode</span>
<span class="cm"> * @sr_sufile: segment usage file inode</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_super_root</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">sr_sum</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">sr_bytes</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">sr_flags</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">sr_nongc_ctime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode</span> <span class="n">sr_dat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode</span> <span class="n">sr_cpfile</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode</span> <span class="n">sr_sufile</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define NILFS_SR_MDT_OFFSET(inode_size, i)  \</span>
<span class="cp">	((unsigned long)&amp;((struct nilfs_super_root *)0)-&gt;sr_dat + \</span>
<span class="cp">			(inode_size) * (i))</span>
<span class="cp">#define NILFS_SR_DAT_OFFSET(inode_size)     NILFS_SR_MDT_OFFSET(inode_size, 0)</span>
<span class="cp">#define NILFS_SR_CPFILE_OFFSET(inode_size)  NILFS_SR_MDT_OFFSET(inode_size, 1)</span>
<span class="cp">#define NILFS_SR_SUFILE_OFFSET(inode_size)  NILFS_SR_MDT_OFFSET(inode_size, 2)</span>
<span class="cp">#define NILFS_SR_BYTES(inode_size)	    NILFS_SR_MDT_OFFSET(inode_size, 3)</span>

<span class="cm">/*</span>
<span class="cm"> * Maximal mount counts</span>
<span class="cm"> */</span>
<span class="cp">#define NILFS_DFL_MAX_MNT_COUNT		50      </span><span class="cm">/* 50 mounts */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * File system states (sbp-&gt;s_state, nilfs-&gt;ns_mount_state)</span>
<span class="cm"> */</span>
<span class="cp">#define NILFS_VALID_FS			0x0001  </span><span class="cm">/* Unmounted cleanly */</span><span class="cp"></span>
<span class="cp">#define NILFS_ERROR_FS			0x0002  </span><span class="cm">/* Errors detected */</span><span class="cp"></span>
<span class="cp">#define NILFS_RESIZE_FS			0x0004	</span><span class="cm">/* Resize required */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Mount flags (sbi-&gt;s_mount_opt)</span>
<span class="cm"> */</span>
<span class="cp">#define NILFS_MOUNT_ERROR_MODE		0x0070  </span><span class="cm">/* Error mode mask */</span><span class="cp"></span>
<span class="cp">#define NILFS_MOUNT_ERRORS_CONT		0x0010  </span><span class="cm">/* Continue on errors */</span><span class="cp"></span>
<span class="cp">#define NILFS_MOUNT_ERRORS_RO		0x0020  </span><span class="cm">/* Remount fs ro on errors */</span><span class="cp"></span>
<span class="cp">#define NILFS_MOUNT_ERRORS_PANIC	0x0040  </span><span class="cm">/* Panic on errors */</span><span class="cp"></span>
<span class="cp">#define NILFS_MOUNT_BARRIER		0x1000  </span><span class="cm">/* Use block barriers */</span><span class="cp"></span>
<span class="cp">#define NILFS_MOUNT_STRICT_ORDER	0x2000  </span><span class="cm">/* Apply strict in-order</span>
<span class="cm">						   semantics also for data */</span><span class="cp"></span>
<span class="cp">#define NILFS_MOUNT_NORECOVERY		0x4000  </span><span class="cm">/* Disable write access during</span>
<span class="cm">						   mount-time recovery */</span><span class="cp"></span>
<span class="cp">#define NILFS_MOUNT_DISCARD		0x8000  </span><span class="cm">/* Issue DISCARD requests */</span><span class="cp"></span>


<span class="cm">/**</span>
<span class="cm"> * struct nilfs_super_block - structure of super block on disk</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le32</span>	<span class="n">s_rev_level</span><span class="p">;</span>		<span class="cm">/* Revision level */</span>
	<span class="n">__le16</span>	<span class="n">s_minor_rev_level</span><span class="p">;</span>	<span class="cm">/* minor revision level */</span>
	<span class="n">__le16</span>	<span class="n">s_magic</span><span class="p">;</span>		<span class="cm">/* Magic signature */</span>

	<span class="n">__le16</span>  <span class="n">s_bytes</span><span class="p">;</span>		<span class="cm">/* Bytes count of CRC calculation</span>
<span class="cm">					   for this structure. s_reserved</span>
<span class="cm">					   is excluded. */</span>
	<span class="n">__le16</span>  <span class="n">s_flags</span><span class="p">;</span>		<span class="cm">/* flags */</span>
	<span class="n">__le32</span>  <span class="n">s_crc_seed</span><span class="p">;</span>		<span class="cm">/* Seed value of CRC calculation */</span>
<span class="cm">/*10*/</span>	<span class="n">__le32</span>	<span class="n">s_sum</span><span class="p">;</span>			<span class="cm">/* Check sum of super block */</span>

	<span class="n">__le32</span>	<span class="n">s_log_block_size</span><span class="p">;</span>	<span class="cm">/* Block size represented as follows</span>
<span class="cm">					   blocksize =</span>
<span class="cm">					       1 &lt;&lt; (s_log_block_size + 10) */</span>
	<span class="n">__le64</span>  <span class="n">s_nsegments</span><span class="p">;</span>		<span class="cm">/* Number of segments in filesystem */</span>
<span class="cm">/*20*/</span>	<span class="n">__le64</span>  <span class="n">s_dev_size</span><span class="p">;</span>		<span class="cm">/* block device size in bytes */</span>
	<span class="n">__le64</span>	<span class="n">s_first_data_block</span><span class="p">;</span>	<span class="cm">/* 1st seg disk block number */</span>
<span class="cm">/*30*/</span>	<span class="n">__le32</span>  <span class="n">s_blocks_per_segment</span><span class="p">;</span>   <span class="cm">/* number of blocks per full segment */</span>
	<span class="n">__le32</span>	<span class="n">s_r_segments_percentage</span><span class="p">;</span> <span class="cm">/* Reserved segments percentage */</span>

	<span class="n">__le64</span>  <span class="n">s_last_cno</span><span class="p">;</span>		<span class="cm">/* Last checkpoint number */</span>
<span class="cm">/*40*/</span>	<span class="n">__le64</span>  <span class="n">s_last_pseg</span><span class="p">;</span>		<span class="cm">/* disk block addr pseg written last */</span>
	<span class="n">__le64</span>  <span class="n">s_last_seq</span><span class="p">;</span>             <span class="cm">/* seq. number of seg written last */</span>
<span class="cm">/*50*/</span>	<span class="n">__le64</span>	<span class="n">s_free_blocks_count</span><span class="p">;</span>	<span class="cm">/* Free blocks count */</span>

	<span class="n">__le64</span>	<span class="n">s_ctime</span><span class="p">;</span>		<span class="cm">/* Creation time (execution time of</span>
<span class="cm">					   newfs) */</span>
<span class="cm">/*60*/</span>	<span class="n">__le64</span>	<span class="n">s_mtime</span><span class="p">;</span>		<span class="cm">/* Mount time */</span>
	<span class="n">__le64</span>	<span class="n">s_wtime</span><span class="p">;</span>		<span class="cm">/* Write time */</span>
<span class="cm">/*70*/</span>	<span class="n">__le16</span>	<span class="n">s_mnt_count</span><span class="p">;</span>		<span class="cm">/* Mount count */</span>
	<span class="n">__le16</span>	<span class="n">s_max_mnt_count</span><span class="p">;</span>	<span class="cm">/* Maximal mount count */</span>
	<span class="n">__le16</span>	<span class="n">s_state</span><span class="p">;</span>		<span class="cm">/* File system state */</span>
	<span class="n">__le16</span>	<span class="n">s_errors</span><span class="p">;</span>		<span class="cm">/* Behaviour when detecting errors */</span>
	<span class="n">__le64</span>	<span class="n">s_lastcheck</span><span class="p">;</span>		<span class="cm">/* time of last check */</span>

<span class="cm">/*80*/</span>	<span class="n">__le32</span>	<span class="n">s_checkinterval</span><span class="p">;</span>	<span class="cm">/* max. time between checks */</span>
	<span class="n">__le32</span>	<span class="n">s_creator_os</span><span class="p">;</span>		<span class="cm">/* OS */</span>
	<span class="n">__le16</span>	<span class="n">s_def_resuid</span><span class="p">;</span>		<span class="cm">/* Default uid for reserved blocks */</span>
	<span class="n">__le16</span>	<span class="n">s_def_resgid</span><span class="p">;</span>		<span class="cm">/* Default gid for reserved blocks */</span>
	<span class="n">__le32</span>	<span class="n">s_first_ino</span><span class="p">;</span>		<span class="cm">/* First non-reserved inode */</span>

<span class="cm">/*90*/</span>	<span class="n">__le16</span>  <span class="n">s_inode_size</span><span class="p">;</span>		<span class="cm">/* Size of an inode */</span>
	<span class="n">__le16</span>  <span class="n">s_dat_entry_size</span><span class="p">;</span>       <span class="cm">/* Size of a dat entry */</span>
	<span class="n">__le16</span>  <span class="n">s_checkpoint_size</span><span class="p">;</span>      <span class="cm">/* Size of a checkpoint */</span>
	<span class="n">__le16</span>	<span class="n">s_segment_usage_size</span><span class="p">;</span>	<span class="cm">/* Size of a segment usage */</span>

<span class="cm">/*98*/</span>	<span class="n">__u8</span>	<span class="n">s_uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>		<span class="cm">/* 128-bit uuid for volume */</span>
<span class="cm">/*A8*/</span>	<span class="kt">char</span>	<span class="n">s_volume_name</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>	<span class="cm">/* volume name */</span>

<span class="cm">/*F8*/</span>	<span class="n">__le32</span>  <span class="n">s_c_interval</span><span class="p">;</span>           <span class="cm">/* Commit interval of segment */</span>
	<span class="n">__le32</span>  <span class="n">s_c_block_max</span><span class="p">;</span>          <span class="cm">/* Threshold of data amount for</span>
<span class="cm">					   the segment construction */</span>
<span class="cm">/*100*/</span>	<span class="n">__le64</span>  <span class="n">s_feature_compat</span><span class="p">;</span>	<span class="cm">/* Compatible feature set */</span>
	<span class="n">__le64</span>  <span class="n">s_feature_compat_ro</span><span class="p">;</span>	<span class="cm">/* Read-only compatible feature set */</span>
	<span class="n">__le64</span>  <span class="n">s_feature_incompat</span><span class="p">;</span>	<span class="cm">/* Incompatible feature set */</span>
	<span class="n">__u32</span>	<span class="n">s_reserved</span><span class="p">[</span><span class="mi">186</span><span class="p">];</span>	<span class="cm">/* padding to the end of the block */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Codes for operating systems</span>
<span class="cm"> */</span>
<span class="cp">#define NILFS_OS_LINUX		0</span>
<span class="cm">/* Codes from 1 to 4 are reserved to keep compatibility with ext2 creator-OS */</span>

<span class="cm">/*</span>
<span class="cm"> * Revision levels</span>
<span class="cm"> */</span>
<span class="cp">#define NILFS_CURRENT_REV	2	</span><span class="cm">/* current major revision */</span><span class="cp"></span>
<span class="cp">#define NILFS_MINOR_REV		0	</span><span class="cm">/* minor revision */</span><span class="cp"></span>
<span class="cp">#define NILFS_MIN_SUPP_REV	2	</span><span class="cm">/* minimum supported revision */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Feature set definitions</span>
<span class="cm"> *</span>
<span class="cm"> * If there is a bit set in the incompatible feature set that the kernel</span>
<span class="cm"> * doesn&#39;t know about, it should refuse to mount the filesystem.</span>
<span class="cm"> */</span>
<span class="cp">#define NILFS_FEATURE_COMPAT_RO_BLOCK_COUNT	0x00000001ULL</span>

<span class="cp">#define NILFS_FEATURE_COMPAT_SUPP	0ULL</span>
<span class="cp">#define NILFS_FEATURE_COMPAT_RO_SUPP	NILFS_FEATURE_COMPAT_RO_BLOCK_COUNT</span>
<span class="cp">#define NILFS_FEATURE_INCOMPAT_SUPP	0ULL</span>

<span class="cm">/*</span>
<span class="cm"> * Bytes count of super_block for CRC-calculation</span>
<span class="cm"> */</span>
<span class="cp">#define NILFS_SB_BYTES  \</span>
<span class="cp">	((long)&amp;((struct nilfs_super_block *)0)-&gt;s_reserved)</span>

<span class="cm">/*</span>
<span class="cm"> * Special inode number</span>
<span class="cm"> */</span>
<span class="cp">#define NILFS_ROOT_INO		2	</span><span class="cm">/* Root file inode */</span><span class="cp"></span>
<span class="cp">#define NILFS_DAT_INO		3	</span><span class="cm">/* DAT file */</span><span class="cp"></span>
<span class="cp">#define NILFS_CPFILE_INO	4	</span><span class="cm">/* checkpoint file */</span><span class="cp"></span>
<span class="cp">#define NILFS_SUFILE_INO	5	</span><span class="cm">/* segment usage file */</span><span class="cp"></span>
<span class="cp">#define NILFS_IFILE_INO		6	</span><span class="cm">/* ifile */</span><span class="cp"></span>
<span class="cp">#define NILFS_ATIME_INO		7	</span><span class="cm">/* Atime file (reserved) */</span><span class="cp"></span>
<span class="cp">#define NILFS_XATTR_INO		8	</span><span class="cm">/* Xattribute file (reserved) */</span><span class="cp"></span>
<span class="cp">#define NILFS_SKETCH_INO	10	</span><span class="cm">/* Sketch file */</span><span class="cp"></span>
<span class="cp">#define NILFS_USER_INO		11	</span><span class="cm">/* Fisrt user&#39;s file inode number */</span><span class="cp"></span>

<span class="cp">#define NILFS_SB_OFFSET_BYTES	1024	</span><span class="cm">/* byte offset of nilfs superblock */</span><span class="cp"></span>

<span class="cp">#define NILFS_SEG_MIN_BLOCKS	16	</span><span class="cm">/* Minimum number of blocks in</span>
<span class="cm">					   a full segment */</span><span class="cp"></span>
<span class="cp">#define NILFS_PSEG_MIN_BLOCKS	2	</span><span class="cm">/* Minimum number of blocks in</span>
<span class="cm">					   a partial segment */</span><span class="cp"></span>
<span class="cp">#define NILFS_MIN_NRSVSEGS	8	</span><span class="cm">/* Minimum number of reserved</span>
<span class="cm">					   segments */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * We call DAT, cpfile, and sufile root metadata files.  Inodes of</span>
<span class="cm"> * these files are written in super root block instead of ifile, and</span>
<span class="cm"> * garbage collector doesn&#39;t keep any past versions of these files.</span>
<span class="cm"> */</span>
<span class="cp">#define NILFS_ROOT_METADATA_FILE(ino) \</span>
<span class="cp">	((ino) &gt;= NILFS_DAT_INO &amp;&amp; (ino) &lt;= NILFS_SUFILE_INO)</span>

<span class="cm">/*</span>
<span class="cm"> * bytes offset of secondary super block</span>
<span class="cm"> */</span>
<span class="cp">#define NILFS_SB2_OFFSET_BYTES(devsize)	((((devsize) &gt;&gt; 12) - 1) &lt;&lt; 12)</span>

<span class="cm">/*</span>
<span class="cm"> * Maximal count of links to a file</span>
<span class="cm"> */</span>
<span class="cp">#define NILFS_LINK_MAX		32000</span>

<span class="cm">/*</span>
<span class="cm"> * Structure of a directory entry</span>
<span class="cm"> *  (Same as ext2)</span>
<span class="cm"> */</span>

<span class="cp">#define NILFS_NAME_LEN 255</span>

<span class="cm">/*</span>
<span class="cm"> * Block size limitations</span>
<span class="cm"> */</span>
<span class="cp">#define NILFS_MIN_BLOCK_SIZE		1024</span>
<span class="cp">#define NILFS_MAX_BLOCK_SIZE		65536</span>

<span class="cm">/*</span>
<span class="cm"> * The new version of the directory entry.  Since V0 structures are</span>
<span class="cm"> * stored in intel byte order, and the name_len field could never be</span>
<span class="cm"> * bigger than 255 chars, it&#39;s safe to reclaim the extra byte for the</span>
<span class="cm"> * file_type field.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_dir_entry</span> <span class="p">{</span>
	<span class="n">__le64</span>	<span class="n">inode</span><span class="p">;</span>			<span class="cm">/* Inode number */</span>
	<span class="n">__le16</span>	<span class="n">rec_len</span><span class="p">;</span>		<span class="cm">/* Directory entry length */</span>
	<span class="n">__u8</span>	<span class="n">name_len</span><span class="p">;</span>		<span class="cm">/* Name length */</span>
	<span class="n">__u8</span>	<span class="n">file_type</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">name</span><span class="p">[</span><span class="n">NILFS_NAME_LEN</span><span class="p">];</span>	<span class="cm">/* File name */</span>
	<span class="kt">char</span>    <span class="n">pad</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * NILFS directory file types.  Only the low 3 bits are used.  The</span>
<span class="cm"> * other bits are reserved for now.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">NILFS_FT_UNKNOWN</span><span class="p">,</span>
	<span class="n">NILFS_FT_REG_FILE</span><span class="p">,</span>
	<span class="n">NILFS_FT_DIR</span><span class="p">,</span>
	<span class="n">NILFS_FT_CHRDEV</span><span class="p">,</span>
	<span class="n">NILFS_FT_BLKDEV</span><span class="p">,</span>
	<span class="n">NILFS_FT_FIFO</span><span class="p">,</span>
	<span class="n">NILFS_FT_SOCK</span><span class="p">,</span>
	<span class="n">NILFS_FT_SYMLINK</span><span class="p">,</span>
	<span class="n">NILFS_FT_MAX</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * NILFS_DIR_PAD defines the directory entries boundaries</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: It must be a multiple of 8</span>
<span class="cm"> */</span>
<span class="cp">#define NILFS_DIR_PAD			8</span>
<span class="cp">#define NILFS_DIR_ROUND			(NILFS_DIR_PAD - 1)</span>
<span class="cp">#define NILFS_DIR_REC_LEN(name_len)	(((name_len) + 12 + NILFS_DIR_ROUND) &amp; \</span>
<span class="cp">					~NILFS_DIR_ROUND)</span>
<span class="cp">#define NILFS_MAX_REC_LEN		((1&lt;&lt;16)-1)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">nilfs_rec_len_from_disk</span><span class="p">(</span><span class="n">__le16</span> <span class="n">dlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dlen</span><span class="p">);</span>

<span class="cp">#if !defined(__KERNEL__) || (PAGE_CACHE_SIZE &gt;= 65536)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">NILFS_MAX_REC_LEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__le16</span> <span class="nf">nilfs_rec_len_to_disk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if !defined(__KERNEL__) || (PAGE_CACHE_SIZE &gt;= 65536)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">NILFS_MAX_REC_LEN</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_finfo - file information</span>
<span class="cm"> * @fi_ino: inode number</span>
<span class="cm"> * @fi_cno: checkpoint number</span>
<span class="cm"> * @fi_nblocks: number of blocks (including intermediate blocks)</span>
<span class="cm"> * @fi_ndatablk: number of file data blocks</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_finfo</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">fi_ino</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">fi_cno</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">fi_nblocks</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">fi_ndatablk</span><span class="p">;</span>
	<span class="cm">/* array of virtual block numbers */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_binfo_v - information for the block to which a virtual block number is assigned</span>
<span class="cm"> * @bi_vblocknr: virtual block number</span>
<span class="cm"> * @bi_blkoff: block offset</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_binfo_v</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">bi_vblocknr</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">bi_blkoff</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_binfo_dat - information for the block which belongs to the DAT file</span>
<span class="cm"> * @bi_blkoff: block offset</span>
<span class="cm"> * @bi_level: level</span>
<span class="cm"> * @bi_pad: padding</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_binfo_dat</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">bi_blkoff</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">bi_level</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">bi_pad</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * union nilfs_binfo: block information</span>
<span class="cm"> * @bi_v: nilfs_binfo_v structure</span>
<span class="cm"> * @bi_dat: nilfs_binfo_dat structure</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">nilfs_binfo</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_binfo_v</span> <span class="n">bi_v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_binfo_dat</span> <span class="n">bi_dat</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_segment_summary - segment summary</span>
<span class="cm"> * @ss_datasum: checksum of data</span>
<span class="cm"> * @ss_sumsum: checksum of segment summary</span>
<span class="cm"> * @ss_magic: magic number</span>
<span class="cm"> * @ss_bytes: size of this structure in bytes</span>
<span class="cm"> * @ss_flags: flags</span>
<span class="cm"> * @ss_seq: sequence number</span>
<span class="cm"> * @ss_create: creation timestamp</span>
<span class="cm"> * @ss_next: next segment</span>
<span class="cm"> * @ss_nblocks: number of blocks</span>
<span class="cm"> * @ss_nfinfo: number of finfo structures</span>
<span class="cm"> * @ss_sumbytes: total size of segment summary in bytes</span>
<span class="cm"> * @ss_pad: padding</span>
<span class="cm"> * @ss_cno: checkpoint number</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_segment_summary</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">ss_datasum</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ss_sumsum</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ss_magic</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ss_bytes</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ss_flags</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">ss_seq</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">ss_create</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">ss_next</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ss_nblocks</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ss_nfinfo</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ss_sumbytes</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ss_pad</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">ss_cno</span><span class="p">;</span>
	<span class="cm">/* array of finfo structures */</span>
<span class="p">};</span>

<span class="cp">#define NILFS_SEGSUM_MAGIC	0x1eaffa11  </span><span class="cm">/* segment summary magic number */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Segment summary flags</span>
<span class="cm"> */</span>
<span class="cp">#define NILFS_SS_LOGBGN 0x0001  </span><span class="cm">/* begins a logical segment */</span><span class="cp"></span>
<span class="cp">#define NILFS_SS_LOGEND 0x0002  </span><span class="cm">/* ends a logical segment */</span><span class="cp"></span>
<span class="cp">#define NILFS_SS_SR     0x0004  </span><span class="cm">/* has super root */</span><span class="cp"></span>
<span class="cp">#define NILFS_SS_SYNDT  0x0008  </span><span class="cm">/* includes data only updates */</span><span class="cp"></span>
<span class="cp">#define NILFS_SS_GC     0x0010  </span><span class="cm">/* segment written for cleaner operation */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_btree_node - B-tree node</span>
<span class="cm"> * @bn_flags: flags</span>
<span class="cm"> * @bn_level: level</span>
<span class="cm"> * @bn_nchildren: number of children</span>
<span class="cm"> * @bn_pad: padding</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_btree_node</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="n">bn_flags</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">bn_level</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">bn_nchildren</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">bn_pad</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* flags */</span>
<span class="cp">#define NILFS_BTREE_NODE_ROOT   0x01</span>

<span class="cm">/* level */</span>
<span class="cp">#define NILFS_BTREE_LEVEL_DATA          0</span>
<span class="cp">#define NILFS_BTREE_LEVEL_NODE_MIN      (NILFS_BTREE_LEVEL_DATA + 1)</span>
<span class="cp">#define NILFS_BTREE_LEVEL_MAX           14</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_palloc_group_desc - block group descriptor</span>
<span class="cm"> * @pg_nfrees: number of free entries in block group</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_palloc_group_desc</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">pg_nfrees</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_dat_entry - disk address translation entry</span>
<span class="cm"> * @de_blocknr: block number</span>
<span class="cm"> * @de_start: start checkpoint number</span>
<span class="cm"> * @de_end: end checkpoint number</span>
<span class="cm"> * @de_rsv: reserved for future use</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_dat_entry</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">de_blocknr</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">de_start</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">de_end</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">de_rsv</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_snapshot_list - snapshot list</span>
<span class="cm"> * @ssl_next: next checkpoint number on snapshot list</span>
<span class="cm"> * @ssl_prev: previous checkpoint number on snapshot list</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_snapshot_list</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">ssl_next</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">ssl_prev</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_checkpoint - checkpoint structure</span>
<span class="cm"> * @cp_flags: flags</span>
<span class="cm"> * @cp_checkpoints_count: checkpoints count in a block</span>
<span class="cm"> * @cp_snapshot_list: snapshot list</span>
<span class="cm"> * @cp_cno: checkpoint number</span>
<span class="cm"> * @cp_create: creation timestamp</span>
<span class="cm"> * @cp_nblk_inc: number of blocks incremented by this checkpoint</span>
<span class="cm"> * @cp_inodes_count: inodes count</span>
<span class="cm"> * @cp_blocks_count: blocks count</span>
<span class="cm"> * @cp_ifile_inode: inode of ifile</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_checkpoint</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">cp_flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">cp_checkpoints_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_snapshot_list</span> <span class="n">cp_snapshot_list</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">cp_cno</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">cp_create</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">cp_nblk_inc</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">cp_inodes_count</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">cp_blocks_count</span><span class="p">;</span>

	<span class="cm">/* Do not change the byte offset of ifile inode.</span>
<span class="cm">	   To keep the compatibility of the disk format,</span>
<span class="cm">	   additional fields should be added behind cp_ifile_inode. */</span>
	<span class="k">struct</span> <span class="n">nilfs_inode</span> <span class="n">cp_ifile_inode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* checkpoint flags */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">NILFS_CHECKPOINT_SNAPSHOT</span><span class="p">,</span>
	<span class="n">NILFS_CHECKPOINT_INVALID</span><span class="p">,</span>
	<span class="n">NILFS_CHECKPOINT_SKETCH</span><span class="p">,</span>
	<span class="n">NILFS_CHECKPOINT_MINOR</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define NILFS_CHECKPOINT_FNS(flag, name)				\</span>
<span class="cp">static inline void							\</span>
<span class="cp">nilfs_checkpoint_set_##name(struct nilfs_checkpoint *cp)		\</span>
<span class="cp">{									\</span>
<span class="cp">	cp-&gt;cp_flags = cpu_to_le32(le32_to_cpu(cp-&gt;cp_flags) |		\</span>
<span class="cp">				   (1UL &lt;&lt; NILFS_CHECKPOINT_##flag));	\</span>
<span class="cp">}									\</span>
<span class="cp">static inline void							\</span>
<span class="cp">nilfs_checkpoint_clear_##name(struct nilfs_checkpoint *cp)		\</span>
<span class="cp">{									\</span>
<span class="cp">	cp-&gt;cp_flags = cpu_to_le32(le32_to_cpu(cp-&gt;cp_flags) &amp;		\</span>
<span class="cp">				   ~(1UL &lt;&lt; NILFS_CHECKPOINT_##flag));	\</span>
<span class="cp">}									\</span>
<span class="cp">static inline int							\</span>
<span class="cp">nilfs_checkpoint_##name(const struct nilfs_checkpoint *cp)		\</span>
<span class="cp">{									\</span>
<span class="cp">	return !!(le32_to_cpu(cp-&gt;cp_flags) &amp;				\</span>
<span class="cp">		  (1UL &lt;&lt; NILFS_CHECKPOINT_##flag));			\</span>
<span class="cp">}</span>

<span class="n">NILFS_CHECKPOINT_FNS</span><span class="p">(</span><span class="n">SNAPSHOT</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">)</span>
<span class="n">NILFS_CHECKPOINT_FNS</span><span class="p">(</span><span class="n">INVALID</span><span class="p">,</span> <span class="n">invalid</span><span class="p">)</span>
<span class="n">NILFS_CHECKPOINT_FNS</span><span class="p">(</span><span class="n">MINOR</span><span class="p">,</span> <span class="n">minor</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_cpinfo - checkpoint information</span>
<span class="cm"> * @ci_flags: flags</span>
<span class="cm"> * @ci_pad: padding</span>
<span class="cm"> * @ci_cno: checkpoint number</span>
<span class="cm"> * @ci_create: creation timestamp</span>
<span class="cm"> * @ci_nblk_inc: number of blocks incremented by this checkpoint</span>
<span class="cm"> * @ci_inodes_count: inodes count</span>
<span class="cm"> * @ci_blocks_count: blocks count</span>
<span class="cm"> * @ci_next: next checkpoint number in snapshot list</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_cpinfo</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">ci_flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ci_pad</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ci_cno</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ci_create</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ci_nblk_inc</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ci_inodes_count</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ci_blocks_count</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ci_next</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define NILFS_CPINFO_FNS(flag, name)					\</span>
<span class="cp">static inline int							\</span>
<span class="cp">nilfs_cpinfo_##name(const struct nilfs_cpinfo *cpinfo)			\</span>
<span class="cp">{									\</span>
<span class="cp">	return !!(cpinfo-&gt;ci_flags &amp; (1UL &lt;&lt; NILFS_CHECKPOINT_##flag));	\</span>
<span class="cp">}</span>

<span class="n">NILFS_CPINFO_FNS</span><span class="p">(</span><span class="n">SNAPSHOT</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">)</span>
<span class="n">NILFS_CPINFO_FNS</span><span class="p">(</span><span class="n">INVALID</span><span class="p">,</span> <span class="n">invalid</span><span class="p">)</span>
<span class="n">NILFS_CPINFO_FNS</span><span class="p">(</span><span class="n">MINOR</span><span class="p">,</span> <span class="n">minor</span><span class="p">)</span>


<span class="cm">/**</span>
<span class="cm"> * struct nilfs_cpfile_header - checkpoint file header</span>
<span class="cm"> * @ch_ncheckpoints: number of checkpoints</span>
<span class="cm"> * @ch_nsnapshots: number of snapshots</span>
<span class="cm"> * @ch_snapshot_list: snapshot list</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_cpfile_header</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">ch_ncheckpoints</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">ch_nsnapshots</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_snapshot_list</span> <span class="n">ch_snapshot_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define NILFS_CPFILE_FIRST_CHECKPOINT_OFFSET	\</span>
<span class="cp">	((sizeof(struct nilfs_cpfile_header) +				\</span>
<span class="cp">	  sizeof(struct nilfs_checkpoint) - 1) /			\</span>
<span class="cp">			sizeof(struct nilfs_checkpoint))</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_segment_usage - segment usage</span>
<span class="cm"> * @su_lastmod: last modified timestamp</span>
<span class="cm"> * @su_nblocks: number of blocks in segment</span>
<span class="cm"> * @su_flags: flags</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_segment_usage</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">su_lastmod</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">su_nblocks</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">su_flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* segment usage flag */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">NILFS_SEGMENT_USAGE_ACTIVE</span><span class="p">,</span>
	<span class="n">NILFS_SEGMENT_USAGE_DIRTY</span><span class="p">,</span>
	<span class="n">NILFS_SEGMENT_USAGE_ERROR</span><span class="p">,</span>

	<span class="cm">/* ... */</span>
<span class="p">};</span>

<span class="cp">#define NILFS_SEGMENT_USAGE_FNS(flag, name)				\</span>
<span class="cp">static inline void							\</span>
<span class="cp">nilfs_segment_usage_set_##name(struct nilfs_segment_usage *su)		\</span>
<span class="cp">{									\</span>
<span class="cp">	su-&gt;su_flags = cpu_to_le32(le32_to_cpu(su-&gt;su_flags) |		\</span>
<span class="cp">				   (1UL &lt;&lt; NILFS_SEGMENT_USAGE_##flag));\</span>
<span class="cp">}									\</span>
<span class="cp">static inline void							\</span>
<span class="cp">nilfs_segment_usage_clear_##name(struct nilfs_segment_usage *su)	\</span>
<span class="cp">{									\</span>
<span class="cp">	su-&gt;su_flags =							\</span>
<span class="cp">		cpu_to_le32(le32_to_cpu(su-&gt;su_flags) &amp;			\</span>
<span class="cp">			    ~(1UL &lt;&lt; NILFS_SEGMENT_USAGE_##flag));      \</span>
<span class="cp">}									\</span>
<span class="cp">static inline int							\</span>
<span class="cp">nilfs_segment_usage_##name(const struct nilfs_segment_usage *su)	\</span>
<span class="cp">{									\</span>
<span class="cp">	return !!(le32_to_cpu(su-&gt;su_flags) &amp;				\</span>
<span class="cp">		  (1UL &lt;&lt; NILFS_SEGMENT_USAGE_##flag));			\</span>
<span class="cp">}</span>

<span class="n">NILFS_SEGMENT_USAGE_FNS</span><span class="p">(</span><span class="n">ACTIVE</span><span class="p">,</span> <span class="n">active</span><span class="p">)</span>
<span class="n">NILFS_SEGMENT_USAGE_FNS</span><span class="p">(</span><span class="n">DIRTY</span><span class="p">,</span> <span class="n">dirty</span><span class="p">)</span>
<span class="n">NILFS_SEGMENT_USAGE_FNS</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="n">nilfs_segment_usage_set_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_segment_usage</span> <span class="o">*</span><span class="n">su</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">su</span><span class="o">-&gt;</span><span class="n">su_lastmod</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">su</span><span class="o">-&gt;</span><span class="n">su_nblocks</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">su</span><span class="o">-&gt;</span><span class="n">su_flags</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="n">nilfs_segment_usage_clean</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nilfs_segment_usage</span> <span class="o">*</span><span class="n">su</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">su</span><span class="o">-&gt;</span><span class="n">su_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_sufile_header - segment usage file header</span>
<span class="cm"> * @sh_ncleansegs: number of clean segments</span>
<span class="cm"> * @sh_ndirtysegs: number of dirty segments</span>
<span class="cm"> * @sh_last_alloc: last allocated segment number</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_sufile_header</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">sh_ncleansegs</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">sh_ndirtysegs</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">sh_last_alloc</span><span class="p">;</span>
	<span class="cm">/* ... */</span>
<span class="p">};</span>

<span class="cp">#define NILFS_SUFILE_FIRST_SEGMENT_USAGE_OFFSET	\</span>
<span class="cp">	((sizeof(struct nilfs_sufile_header) +				\</span>
<span class="cp">	  sizeof(struct nilfs_segment_usage) - 1) /			\</span>
<span class="cp">			 sizeof(struct nilfs_segment_usage))</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_suinfo - segment usage information</span>
<span class="cm"> * @sui_lastmod:</span>
<span class="cm"> * @sui_nblocks:</span>
<span class="cm"> * @sui_flags:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_suinfo</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">sui_lastmod</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sui_nblocks</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sui_flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define NILFS_SUINFO_FNS(flag, name)					\</span>
<span class="cp">static inline int							\</span>
<span class="cp">nilfs_suinfo_##name(const struct nilfs_suinfo *si)			\</span>
<span class="cp">{									\</span>
<span class="cp">	return si-&gt;sui_flags &amp; (1UL &lt;&lt; NILFS_SEGMENT_USAGE_##flag);	\</span>
<span class="cp">}</span>

<span class="n">NILFS_SUINFO_FNS</span><span class="p">(</span><span class="n">ACTIVE</span><span class="p">,</span> <span class="n">active</span><span class="p">)</span>
<span class="n">NILFS_SUINFO_FNS</span><span class="p">(</span><span class="n">DIRTY</span><span class="p">,</span> <span class="n">dirty</span><span class="p">)</span>
<span class="n">NILFS_SUINFO_FNS</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">nilfs_suinfo_clean</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nilfs_suinfo</span> <span class="o">*</span><span class="n">si</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">sui_flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ioctl */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">NILFS_CHECKPOINT</span><span class="p">,</span>
	<span class="n">NILFS_SNAPSHOT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_cpmode -</span>
<span class="cm"> * @cc_cno:</span>
<span class="cm"> * @cc_mode:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_cpmode</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">cm_cno</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">cm_mode</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">cm_pad</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_argv - argument vector</span>
<span class="cm"> * @v_base:</span>
<span class="cm"> * @v_nmembs:</span>
<span class="cm"> * @v_size:</span>
<span class="cm"> * @v_flags:</span>
<span class="cm"> * @v_index:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_argv</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">v_base</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">v_nmembs</span><span class="p">;</span>	<span class="cm">/* number of members */</span>
	<span class="n">__u16</span> <span class="n">v_size</span><span class="p">;</span>	<span class="cm">/* size of members */</span>
	<span class="n">__u16</span> <span class="n">v_flags</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">v_index</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_period -</span>
<span class="cm"> * @p_start:</span>
<span class="cm"> * @p_end:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_period</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">p_start</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">p_end</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_cpstat -</span>
<span class="cm"> * @cs_cno: checkpoint number</span>
<span class="cm"> * @cs_ncps: number of checkpoints</span>
<span class="cm"> * @cs_nsss: number of snapshots</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_cpstat</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">cs_cno</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">cs_ncps</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">cs_nsss</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_sustat -</span>
<span class="cm"> * @ss_nsegs: number of segments</span>
<span class="cm"> * @ss_ncleansegs: number of clean segments</span>
<span class="cm"> * @ss_ndirtysegs: number of dirty segments</span>
<span class="cm"> * @ss_ctime: creation time of the last segment</span>
<span class="cm"> * @ss_nongc_ctime: creation time of the last segment not for GC</span>
<span class="cm"> * @ss_prot_seq: least sequence number of segments which must not be reclaimed</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_sustat</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">ss_nsegs</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ss_ncleansegs</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ss_ndirtysegs</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ss_ctime</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ss_nongc_ctime</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ss_prot_seq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_vinfo - virtual block number information</span>
<span class="cm"> * @vi_vblocknr:</span>
<span class="cm"> * @vi_start:</span>
<span class="cm"> * @vi_end:</span>
<span class="cm"> * @vi_blocknr:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_vinfo</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">vi_vblocknr</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">vi_start</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">vi_end</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">vi_blocknr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_vdesc -</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_vdesc</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">vd_ino</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">vd_cno</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">vd_vblocknr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_period</span> <span class="n">vd_period</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">vd_blocknr</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">vd_offset</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">vd_flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">vd_pad</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nilfs_bdesc -</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nilfs_bdesc</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">bd_ino</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">bd_oblocknr</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">bd_blocknr</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">bd_offset</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">bd_level</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">bd_pad</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define NILFS_IOCTL_IDENT		&#39;n&#39;</span>

<span class="cp">#define NILFS_IOCTL_CHANGE_CPMODE  \</span>
<span class="cp">	_IOW(NILFS_IOCTL_IDENT, 0x80, struct nilfs_cpmode)</span>
<span class="cp">#define NILFS_IOCTL_DELETE_CHECKPOINT  \</span>
<span class="cp">	_IOW(NILFS_IOCTL_IDENT, 0x81, __u64)</span>
<span class="cp">#define NILFS_IOCTL_GET_CPINFO  \</span>
<span class="cp">	_IOR(NILFS_IOCTL_IDENT, 0x82, struct nilfs_argv)</span>
<span class="cp">#define NILFS_IOCTL_GET_CPSTAT  \</span>
<span class="cp">	_IOR(NILFS_IOCTL_IDENT, 0x83, struct nilfs_cpstat)</span>
<span class="cp">#define NILFS_IOCTL_GET_SUINFO  \</span>
<span class="cp">	_IOR(NILFS_IOCTL_IDENT, 0x84, struct nilfs_argv)</span>
<span class="cp">#define NILFS_IOCTL_GET_SUSTAT  \</span>
<span class="cp">	_IOR(NILFS_IOCTL_IDENT, 0x85, struct nilfs_sustat)</span>
<span class="cp">#define NILFS_IOCTL_GET_VINFO  \</span>
<span class="cp">	_IOWR(NILFS_IOCTL_IDENT, 0x86, struct nilfs_argv)</span>
<span class="cp">#define NILFS_IOCTL_GET_BDESCS  \</span>
<span class="cp">	_IOWR(NILFS_IOCTL_IDENT, 0x87, struct nilfs_argv)</span>
<span class="cp">#define NILFS_IOCTL_CLEAN_SEGMENTS  \</span>
<span class="cp">	_IOW(NILFS_IOCTL_IDENT, 0x88, struct nilfs_argv[5])</span>
<span class="cp">#define NILFS_IOCTL_SYNC  \</span>
<span class="cp">	_IOR(NILFS_IOCTL_IDENT, 0x8A, __u64)</span>
<span class="cp">#define NILFS_IOCTL_RESIZE  \</span>
<span class="cp">	_IOW(NILFS_IOCTL_IDENT, 0x8B, __u64)</span>
<span class="cp">#define NILFS_IOCTL_SET_ALLOC_RANGE  \</span>
<span class="cp">	_IOW(NILFS_IOCTL_IDENT, 0x8C, __u64[2])</span>

<span class="cp">#endif	</span><span class="cm">/* _LINUX_NILFS_FS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
