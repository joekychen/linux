<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › buffer_head.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>buffer_head.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * include/linux/buffer_head.h</span>
<span class="cm"> *</span>
<span class="cm"> * Everything to do with buffer_heads.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_BUFFER_HEAD_H</span>
<span class="cp">#define _LINUX_BUFFER_HEAD_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cp">#ifdef CONFIG_BLOCK</span>

<span class="k">enum</span> <span class="n">bh_state_bits</span> <span class="p">{</span>
	<span class="n">BH_Uptodate</span><span class="p">,</span>	<span class="cm">/* Contains valid data */</span>
	<span class="n">BH_Dirty</span><span class="p">,</span>	<span class="cm">/* Is dirty */</span>
	<span class="n">BH_Lock</span><span class="p">,</span>	<span class="cm">/* Is locked */</span>
	<span class="n">BH_Req</span><span class="p">,</span>		<span class="cm">/* Has been submitted for I/O */</span>
	<span class="n">BH_Uptodate_Lock</span><span class="p">,</span><span class="cm">/* Used by the first bh in a page, to serialise</span>
<span class="cm">			  * IO completion of other buffers in the page</span>
<span class="cm">			  */</span>

	<span class="n">BH_Mapped</span><span class="p">,</span>	<span class="cm">/* Has a disk mapping */</span>
	<span class="n">BH_New</span><span class="p">,</span>		<span class="cm">/* Disk mapping was newly created by get_block */</span>
	<span class="n">BH_Async_Read</span><span class="p">,</span>	<span class="cm">/* Is under end_buffer_async_read I/O */</span>
	<span class="n">BH_Async_Write</span><span class="p">,</span>	<span class="cm">/* Is under end_buffer_async_write I/O */</span>
	<span class="n">BH_Delay</span><span class="p">,</span>	<span class="cm">/* Buffer is not yet allocated on disk */</span>
	<span class="n">BH_Boundary</span><span class="p">,</span>	<span class="cm">/* Block is followed by a discontiguity */</span>
	<span class="n">BH_Write_EIO</span><span class="p">,</span>	<span class="cm">/* I/O error on write */</span>
	<span class="n">BH_Unwritten</span><span class="p">,</span>	<span class="cm">/* Buffer is allocated on disk but not written */</span>
	<span class="n">BH_Quiet</span><span class="p">,</span>	<span class="cm">/* Buffer Error Prinks to be quiet */</span>

	<span class="n">BH_PrivateStart</span><span class="p">,</span><span class="cm">/* not a state bit, but the first bit available</span>
<span class="cm">			 * for private allocation by other entities</span>
<span class="cm">			 */</span>
<span class="p">};</span>

<span class="cp">#define MAX_BUF_PER_PAGE (PAGE_CACHE_SIZE / 512)</span>

<span class="k">struct</span> <span class="n">page</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">buffer_head</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">address_space</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">bh_end_io_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Historically, a buffer_head was used to map a single block</span>
<span class="cm"> * within a page, and of course as the unit of I/O through the</span>
<span class="cm"> * filesystem and block layers.  Nowadays the basic I/O unit</span>
<span class="cm"> * is the bio, and buffer_heads are used for extracting block</span>
<span class="cm"> * mappings (via a get_block_t call), for tracking state within</span>
<span class="cm"> * a page (via a page_mapping) and for wrapping bio submission</span>
<span class="cm"> * for backward compatibility reasons (e.g. submit_bh).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b_state</span><span class="p">;</span>		<span class="cm">/* buffer state bitmap (see above) */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">b_this_page</span><span class="p">;</span><span class="cm">/* circular list of page&#39;s buffers */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">b_page</span><span class="p">;</span>		<span class="cm">/* the page this bh is mapped to */</span>

	<span class="n">sector_t</span> <span class="n">b_blocknr</span><span class="p">;</span>		<span class="cm">/* start block number */</span>
	<span class="kt">size_t</span> <span class="n">b_size</span><span class="p">;</span>			<span class="cm">/* size of mapping */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">b_data</span><span class="p">;</span>			<span class="cm">/* pointer to data within the page */</span>

	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">b_bdev</span><span class="p">;</span>
	<span class="n">bh_end_io_t</span> <span class="o">*</span><span class="n">b_end_io</span><span class="p">;</span>		<span class="cm">/* I/O completion */</span>
 	<span class="kt">void</span> <span class="o">*</span><span class="n">b_private</span><span class="p">;</span>		<span class="cm">/* reserved for b_end_io */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">b_assoc_buffers</span><span class="p">;</span> <span class="cm">/* associated with another mapping */</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">b_assoc_map</span><span class="p">;</span>	<span class="cm">/* mapping this buffer is</span>
<span class="cm">						   associated with */</span>
	<span class="n">atomic_t</span> <span class="n">b_count</span><span class="p">;</span>		<span class="cm">/* users using this buffer_head */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * macro tricks to expand the set_buffer_foo(), clear_buffer_foo()</span>
<span class="cm"> * and buffer_foo() functions.</span>
<span class="cm"> */</span>
<span class="cp">#define BUFFER_FNS(bit, name)						\</span>
<span class="cp">static inline void set_buffer_##name(struct buffer_head *bh)		\</span>
<span class="cp">{									\</span>
<span class="cp">	set_bit(BH_##bit, &amp;(bh)-&gt;b_state);				\</span>
<span class="cp">}									\</span>
<span class="cp">static inline void clear_buffer_##name(struct buffer_head *bh)		\</span>
<span class="cp">{									\</span>
<span class="cp">	clear_bit(BH_##bit, &amp;(bh)-&gt;b_state);				\</span>
<span class="cp">}									\</span>
<span class="cp">static inline int buffer_##name(const struct buffer_head *bh)		\</span>
<span class="cp">{									\</span>
<span class="cp">	return test_bit(BH_##bit, &amp;(bh)-&gt;b_state);			\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * test_set_buffer_foo() and test_clear_buffer_foo()</span>
<span class="cm"> */</span>
<span class="cp">#define TAS_BUFFER_FNS(bit, name)					\</span>
<span class="cp">static inline int test_set_buffer_##name(struct buffer_head *bh)	\</span>
<span class="cp">{									\</span>
<span class="cp">	return test_and_set_bit(BH_##bit, &amp;(bh)-&gt;b_state);		\</span>
<span class="cp">}									\</span>
<span class="cp">static inline int test_clear_buffer_##name(struct buffer_head *bh)	\</span>
<span class="cp">{									\</span>
<span class="cp">	return test_and_clear_bit(BH_##bit, &amp;(bh)-&gt;b_state);		\</span>
<span class="cp">}									\</span>

<span class="cm">/*</span>
<span class="cm"> * Emit the buffer bitops functions.   Note that there are also functions</span>
<span class="cm"> * of the form &quot;mark_buffer_foo()&quot;.  These are higher-level functions which</span>
<span class="cm"> * do something in addition to setting a b_state bit.</span>
<span class="cm"> */</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">Uptodate</span><span class="p">,</span> <span class="n">uptodate</span><span class="p">)</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">Dirty</span><span class="p">,</span> <span class="n">dirty</span><span class="p">)</span>
<span class="n">TAS_BUFFER_FNS</span><span class="p">(</span><span class="n">Dirty</span><span class="p">,</span> <span class="n">dirty</span><span class="p">)</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">Lock</span><span class="p">,</span> <span class="n">locked</span><span class="p">)</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">Req</span><span class="p">,</span> <span class="n">req</span><span class="p">)</span>
<span class="n">TAS_BUFFER_FNS</span><span class="p">(</span><span class="n">Req</span><span class="p">,</span> <span class="n">req</span><span class="p">)</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">Mapped</span><span class="p">,</span> <span class="n">mapped</span><span class="p">)</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">New</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">Async_Read</span><span class="p">,</span> <span class="n">async_read</span><span class="p">)</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">Async_Write</span><span class="p">,</span> <span class="n">async_write</span><span class="p">)</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">Delay</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">Boundary</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">Write_EIO</span><span class="p">,</span> <span class="n">write_io_error</span><span class="p">)</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">Unwritten</span><span class="p">,</span> <span class="n">unwritten</span><span class="p">)</span>

<span class="cp">#define bh_offset(bh)		((unsigned long)(bh)-&gt;b_data &amp; ~PAGE_MASK)</span>
<span class="cp">#define touch_buffer(bh)	mark_page_accessed(bh-&gt;b_page)</span>

<span class="cm">/* If we *know* page-&gt;private refers to buffer_heads */</span>
<span class="cp">#define page_buffers(page)					\</span>
<span class="cp">	({							\</span>
<span class="cp">		BUG_ON(!PagePrivate(page));			\</span>
<span class="cp">		((struct buffer_head *)page_private(page));	\</span>
<span class="cp">	})</span>
<span class="cp">#define page_has_buffers(page)	PagePrivate(page)</span>

<span class="cm">/*</span>
<span class="cm"> * Declarations</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">init_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span> <span class="n">bh_end_io_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">set_bh_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">try_to_free_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">alloc_page_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">retry</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">create_empty_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b_state</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">end_buffer_read_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">end_buffer_write_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">end_buffer_async_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">);</span>

<span class="cm">/* Things to do with buffers at mapping-&gt;private_list */</span>
<span class="kt">void</span> <span class="n">mark_buffer_dirty_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">inode_has_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">invalidate_inode_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">remove_inode_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sync_mapping_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">unmap_underlying_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">mark_buffer_async_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__wait_on_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">bh_waitq_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">__find_get_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">size</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">__getblk</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__brelse</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__bforget</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__breadahead</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">__bread</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">invalidate_bh_lrus</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">alloc_buffer_head</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">free_buffer_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">unlock_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__lock_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ll_rw_block</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">[]);</span>
<span class="kt">int</span> <span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__sync_dirty_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">write_dirty_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">submit_bh</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">write_boundary_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			<span class="n">sector_t</span> <span class="n">bblock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bh_uptodate_or_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bh_submit_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">buffer_heads_over_limit</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Generic address_space_operations implementations for buffer_head-backed</span>
<span class="cm"> * address_spaces.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">block_invalidatepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">block_write_full_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">block_write_full_page_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">,</span> <span class="n">bh_end_io_t</span> <span class="o">*</span><span class="n">handler</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">block_read_full_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span><span class="o">*</span><span class="p">,</span> <span class="n">get_block_t</span><span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">block_is_partially_uptodate</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">read_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">from</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">block_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__block_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span>
		<span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">block_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span>
				<span class="n">loff_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">generic_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span>
				<span class="n">loff_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">page_zero_new_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">to</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">cont_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span>
			<span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="p">,</span>
			<span class="n">get_block_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">generic_cont_expand_simple</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">block_commit_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">to</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__block_page_mkwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">,</span>
				<span class="n">get_block_t</span> <span class="n">get_block</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">block_page_mkwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">,</span>
				<span class="n">get_block_t</span> <span class="n">get_block</span><span class="p">);</span>
<span class="cm">/* Convert errno to return value from -&gt;page_mkwrite() call */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">block_page_mkwrite_return</span><span class="p">(</span><span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_LOCKED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_NOPAGE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_RETRY</span><span class="p">;</span>
	<span class="cm">/* -ENOSPC, -EDQUOT, -EIO ... */</span>
	<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">sector_t</span> <span class="n">generic_block_bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">block_truncate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">nobh_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="p">,</span> <span class="n">get_block_t</span><span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">nobh_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span>
				<span class="n">loff_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">nobh_truncate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">nobh_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">,</span>
                        <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">buffer_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * inline definitions</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">attach_page_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">page_cache_get</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">SetPagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">set_page_private</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">get_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">smp_mb__before_atomic_dec</span><span class="p">();</span>
        <span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">brelse</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span>
		<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bforget</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span>
		<span class="n">__bforget</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>
<span class="nf">sb_bread</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__bread</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">sb_breadahead</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__breadahead</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>
<span class="nf">sb_getblk</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__getblk</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>
<span class="nf">sb_find_get_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__find_get_block</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">map_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">;</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wait_on_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="n">__wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">trylock_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit_lock</span><span class="p">(</span><span class="n">BH_Lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lock_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="n">__lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__set_page_dirty_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_BLOCK */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">buffer_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">try_to_free_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">inode_has_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">invalidate_inode_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">remove_inode_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sync_mapping_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_BLOCK */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _LINUX_BUFFER_HEAD_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
