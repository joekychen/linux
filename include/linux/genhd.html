<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › genhd.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>genhd.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_GENHD_H</span>
<span class="cp">#define _LINUX_GENHD_H</span>

<span class="cm">/*</span>
<span class="cm"> * 	genhd.h Copyright (C) 1992 Drew Eckhardt</span>
<span class="cm"> *	Generic hard disk header file by  </span>
<span class="cm"> * 		Drew Eckhardt</span>
<span class="cm"> *</span>
<span class="cm"> *		&lt;drew@colorado.edu&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kdev_t.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#ifdef CONFIG_BLOCK</span>

<span class="cp">#define kobj_to_dev(k)		container_of((k), struct device, kobj)</span>
<span class="cp">#define dev_to_disk(device)	container_of((device), struct gendisk, part0.__dev)</span>
<span class="cp">#define dev_to_part(device)	container_of((device), struct hd_struct, __dev)</span>
<span class="cp">#define disk_to_dev(disk)	(&amp;(disk)-&gt;part0.__dev)</span>
<span class="cp">#define part_to_dev(part)	(&amp;((part)-&gt;__dev))</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="n">part_type</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">block_depr</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">class</span> <span class="n">block_class</span><span class="p">;</span>

<span class="k">enum</span> <span class="p">{</span>
<span class="cm">/* These three have identical behaviour; use the second one if DOS FDISK gets</span>
<span class="cm">   confused about extended/logical partitions starting past cylinder 1023. */</span>
	<span class="n">DOS_EXTENDED_PARTITION</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">LINUX_EXTENDED_PARTITION</span> <span class="o">=</span> <span class="mh">0x85</span><span class="p">,</span>
	<span class="n">WIN98_EXTENDED_PARTITION</span> <span class="o">=</span> <span class="mh">0x0f</span><span class="p">,</span>

	<span class="n">SUN_WHOLE_DISK</span> <span class="o">=</span> <span class="n">DOS_EXTENDED_PARTITION</span><span class="p">,</span>

	<span class="n">LINUX_SWAP_PARTITION</span> <span class="o">=</span> <span class="mh">0x82</span><span class="p">,</span>
	<span class="n">LINUX_DATA_PARTITION</span> <span class="o">=</span> <span class="mh">0x83</span><span class="p">,</span>
	<span class="n">LINUX_LVM_PARTITION</span> <span class="o">=</span> <span class="mh">0x8e</span><span class="p">,</span>
	<span class="n">LINUX_RAID_PARTITION</span> <span class="o">=</span> <span class="mh">0xfd</span><span class="p">,</span>	<span class="cm">/* autodetect RAID partition */</span>

	<span class="n">SOLARIS_X86_PARTITION</span> <span class="o">=</span>	<span class="n">LINUX_SWAP_PARTITION</span><span class="p">,</span>
	<span class="n">NEW_SOLARIS_X86_PARTITION</span> <span class="o">=</span> <span class="mh">0xbf</span><span class="p">,</span>

	<span class="n">DM6_AUX1PARTITION</span> <span class="o">=</span> <span class="mh">0x51</span><span class="p">,</span>	<span class="cm">/* no DDO:  use xlated geom */</span>
	<span class="n">DM6_AUX3PARTITION</span> <span class="o">=</span> <span class="mh">0x53</span><span class="p">,</span>	<span class="cm">/* no DDO:  use xlated geom */</span>
	<span class="n">DM6_PARTITION</span> <span class="o">=</span>	<span class="mh">0x54</span><span class="p">,</span>		<span class="cm">/* has DDO: use xlated geom &amp; offset */</span>
	<span class="n">EZD_PARTITION</span> <span class="o">=</span>	<span class="mh">0x55</span><span class="p">,</span>		<span class="cm">/* EZ-DRIVE */</span>

	<span class="n">FREEBSD_PARTITION</span> <span class="o">=</span> <span class="mh">0xa5</span><span class="p">,</span>	<span class="cm">/* FreeBSD Partition ID */</span>
	<span class="n">OPENBSD_PARTITION</span> <span class="o">=</span> <span class="mh">0xa6</span><span class="p">,</span>	<span class="cm">/* OpenBSD Partition ID */</span>
	<span class="n">NETBSD_PARTITION</span> <span class="o">=</span> <span class="mh">0xa9</span><span class="p">,</span>	<span class="cm">/* NetBSD Partition ID */</span>
	<span class="n">BSDI_PARTITION</span> <span class="o">=</span> <span class="mh">0xb7</span><span class="p">,</span>		<span class="cm">/* BSDI Partition ID */</span>
	<span class="n">MINIX_PARTITION</span> <span class="o">=</span> <span class="mh">0x81</span><span class="p">,</span>		<span class="cm">/* Minix Partition ID */</span>
	<span class="n">UNIXWARE_PARTITION</span> <span class="o">=</span> <span class="mh">0x63</span><span class="p">,</span>	<span class="cm">/* Same as GNU_HURD and SCO Unix */</span>
<span class="p">};</span>

<span class="cp">#define DISK_MAX_PARTS			256</span>
<span class="cp">#define DISK_NAME_LEN			32</span>

<span class="cp">#include &lt;linux/major.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>

<span class="k">struct</span> <span class="n">partition</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">boot_ind</span><span class="p">;</span>		<span class="cm">/* 0x80 - active */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">head</span><span class="p">;</span>		<span class="cm">/* starting head */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sector</span><span class="p">;</span>		<span class="cm">/* starting sector */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cyl</span><span class="p">;</span>		<span class="cm">/* starting cylinder */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sys_ind</span><span class="p">;</span>		<span class="cm">/* What partition type */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">end_head</span><span class="p">;</span>		<span class="cm">/* end head */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">end_sector</span><span class="p">;</span>	<span class="cm">/* end sector */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">end_cyl</span><span class="p">;</span>		<span class="cm">/* end cylinder */</span>
	<span class="n">__le32</span> <span class="n">start_sect</span><span class="p">;</span>	<span class="cm">/* starting sector counting from 0 */</span>
	<span class="n">__le32</span> <span class="n">nr_sects</span><span class="p">;</span>		<span class="cm">/* nr of sectors in partition */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">disk_stats</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sectors</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* READs and WRITEs */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ios</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">merges</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ticks</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_ticks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time_in_queue</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define PARTITION_META_INFO_VOLNAMELTH	64</span>
<span class="cp">#define PARTITION_META_INFO_UUIDLTH	16</span>

<span class="k">struct</span> <span class="n">partition_meta_info</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">uuid</span><span class="p">[</span><span class="n">PARTITION_META_INFO_UUIDLTH</span><span class="p">];</span>	<span class="cm">/* always big endian */</span>
	<span class="n">u8</span> <span class="n">volname</span><span class="p">[</span><span class="n">PARTITION_META_INFO_VOLNAMELTH</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hd_struct</span> <span class="p">{</span>
	<span class="n">sector_t</span> <span class="n">start_sect</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">nr_sects</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">alignment_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">discard_alignment</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">__dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">holder_dir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">policy</span><span class="p">,</span> <span class="n">partno</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">partition_meta_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_FAIL_MAKE_REQUEST</span>
	<span class="kt">int</span> <span class="n">make_it_fail</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stamp</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">in_flight</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="cp">#ifdef	CONFIG_SMP</span>
	<span class="k">struct</span> <span class="n">disk_stats</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">dkstats</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">struct</span> <span class="n">disk_stats</span> <span class="n">dkstats</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">atomic_t</span> <span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu_head</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define GENHD_FL_REMOVABLE			1</span>
<span class="cm">/* 2 is unused */</span>
<span class="cp">#define GENHD_FL_MEDIA_CHANGE_NOTIFY		4</span>
<span class="cp">#define GENHD_FL_CD				8</span>
<span class="cp">#define GENHD_FL_UP				16</span>
<span class="cp">#define GENHD_FL_SUPPRESS_PARTITION_INFO	32</span>
<span class="cp">#define GENHD_FL_EXT_DEVT			64 </span><span class="cm">/* allow extended devt */</span><span class="cp"></span>
<span class="cp">#define GENHD_FL_NATIVE_CAPACITY		128</span>
<span class="cp">#define GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE	256</span>
<span class="cp">#define GENHD_FL_NO_PART_SCAN			512</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">DISK_EVENT_MEDIA_CHANGE</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* media changed */</span>
	<span class="n">DISK_EVENT_EJECT_REQUEST</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/* eject requested */</span>
<span class="p">};</span>

<span class="cp">#define BLK_SCSI_MAX_CMDS	(256)</span>
<span class="cp">#define BLK_SCSI_CMD_PER_LONG	(BLK_SCSI_MAX_CMDS / (sizeof(long) * 8))</span>

<span class="k">struct</span> <span class="n">blk_scsi_cmd_filter</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">read_ok</span><span class="p">[</span><span class="n">BLK_SCSI_CMD_PER_LONG</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">write_ok</span><span class="p">[</span><span class="n">BLK_SCSI_CMD_PER_LONG</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">disk_part_tbl</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu_head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">last_lookup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">part</span><span class="p">[];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">disk_events</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">gendisk</span> <span class="p">{</span>
	<span class="cm">/* major, first_minor and minors are input parameters only,</span>
<span class="cm">	 * don&#39;t use directly.  Use disk_devt() and disk_max_parts().</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">major</span><span class="p">;</span>			<span class="cm">/* major number of driver */</span>
	<span class="kt">int</span> <span class="n">first_minor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">minors</span><span class="p">;</span>                     <span class="cm">/* maximum number of minors, =1 for</span>
<span class="cm">                                         * disks that can&#39;t be partitioned. */</span>

	<span class="kt">char</span> <span class="n">disk_name</span><span class="p">[</span><span class="n">DISK_NAME_LEN</span><span class="p">];</span>	<span class="cm">/* name of major driver */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">devnode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">,</span> <span class="n">umode_t</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">events</span><span class="p">;</span>		<span class="cm">/* supported events */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">async_events</span><span class="p">;</span>	<span class="cm">/* async events, subset of all */</span>

	<span class="cm">/* Array of pointers to partitions indexed by partno.</span>
<span class="cm">	 * Protected with matching bdev lock but stat and other</span>
<span class="cm">	 * non-critical accesses use RCU.  Always access through</span>
<span class="cm">	 * helpers.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">disk_part_tbl</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">part_tbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="n">part0</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">block_device_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">private_data</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">driverfs_dev</span><span class="p">;</span>  <span class="c1">// FIXME: remove</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">slave_dir</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">timer_rand_state</span> <span class="o">*</span><span class="n">random</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">sync_io</span><span class="p">;</span>		<span class="cm">/* RAID */</span>
	<span class="k">struct</span> <span class="n">disk_events</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>
<span class="cp">#ifdef  CONFIG_BLK_DEV_INTEGRITY</span>
	<span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="n">integrity</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="n">node_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="nf">part_to_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">part</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">partno</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">part_to_dev</span><span class="p">(</span><span class="n">part</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">part_to_dev</span><span class="p">(</span><span class="n">part</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">part_pack_uuid</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">uuid_str</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">to</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">hex_to_bin</span><span class="p">(</span><span class="o">*</span><span class="n">uuid_str</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">hex_to_bin</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">uuid_str</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)));</span>
		<span class="n">uuid_str</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">3</span>:
		<span class="k">case</span> <span class="mi">5</span>:
		<span class="k">case</span> <span class="mi">7</span>:
		<span class="k">case</span> <span class="mi">9</span>:
			<span class="n">uuid_str</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">disk_max_parts</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GENHD_FL_EXT_DEVT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">DISK_MAX_PARTS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">minors</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">disk_part_scan_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">disk_max_parts</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GENHD_FL_NO_PART_SCAN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">dev_t</span> <span class="nf">disk_devt</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">devt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">dev_t</span> <span class="nf">part_devt</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">part_to_dev</span><span class="p">(</span><span class="n">part</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">devt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">disk_get_part</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">partno</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">disk_put_part</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">part</span><span class="p">))</span>
		<span class="n">put_device</span><span class="p">(</span><span class="n">part_to_dev</span><span class="p">(</span><span class="n">part</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Smarter partition iterator without context limits.</span>
<span class="cm"> */</span>
<span class="cp">#define DISK_PITER_REVERSE	(1 &lt;&lt; 0) </span><span class="cm">/* iterate in the reverse direction */</span><span class="cp"></span>
<span class="cp">#define DISK_PITER_INCL_EMPTY	(1 &lt;&lt; 1) </span><span class="cm">/* include 0-sized parts */</span><span class="cp"></span>
<span class="cp">#define DISK_PITER_INCL_PART0	(1 &lt;&lt; 2) </span><span class="cm">/* include partition 0 */</span><span class="cp"></span>
<span class="cp">#define DISK_PITER_INCL_EMPTY_PART0 (1 &lt;&lt; 3) </span><span class="cm">/* include empty partition 0 */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">disk_part_iter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span>		<span class="o">*</span><span class="n">disk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hd_struct</span>	<span class="o">*</span><span class="n">part</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">disk_part_iter_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">disk_part_iter</span> <span class="o">*</span><span class="n">piter</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">disk_part_iter_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">disk_part_iter</span> <span class="o">*</span><span class="n">piter</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">disk_part_iter_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">disk_part_iter</span> <span class="o">*</span><span class="n">piter</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">disk_map_sector_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span>
					     <span class="n">sector_t</span> <span class="n">sector</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Macros to operate on percpu disk statistics:</span>
<span class="cm"> *</span>
<span class="cm"> * {disk|part|all}_stat_{add|sub|inc|dec}() modify the stat counters</span>
<span class="cm"> * and should be called between disk_stat_lock() and</span>
<span class="cm"> * disk_stat_unlock().</span>
<span class="cm"> *</span>
<span class="cm"> * part_stat_read() can be called at any time.</span>
<span class="cm"> *</span>
<span class="cm"> * part_stat_{add|set_all}() and {init|free}_part_stats are for</span>
<span class="cm"> * internal use only.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef	CONFIG_SMP</span>
<span class="cp">#define part_stat_lock()	({ rcu_read_lock(); get_cpu(); })</span>
<span class="cp">#define part_stat_unlock()	do { put_cpu(); rcu_read_unlock(); } while (0)</span>

<span class="cp">#define __part_stat_add(cpu, part, field, addnd)			\</span>
<span class="cp">	(per_cpu_ptr((part)-&gt;dkstats, (cpu))-&gt;field += (addnd))</span>

<span class="cp">#define part_stat_read(part, field)					\</span>
<span class="cp">({									\</span>
<span class="cp">	typeof((part)-&gt;dkstats-&gt;field) res = 0;				\</span>
<span class="cp">	unsigned int _cpu;						\</span>
<span class="cp">	for_each_possible_cpu(_cpu)					\</span>
<span class="cp">		res += per_cpu_ptr((part)-&gt;dkstats, _cpu)-&gt;field;	\</span>
<span class="cp">	res;								\</span>
<span class="cp">})</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">part_stat_set_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">dkstats</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">value</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">disk_stats</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">init_part_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">part</span><span class="o">-&gt;</span><span class="n">dkstats</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">disk_stats</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">dkstats</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_part_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">dkstats</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_SMP */</span><span class="cp"></span>
<span class="cp">#define part_stat_lock()	({ rcu_read_lock(); 0; })</span>
<span class="cp">#define part_stat_unlock()	rcu_read_unlock()</span>

<span class="cp">#define __part_stat_add(cpu, part, field, addnd)				\</span>
<span class="cp">	((part)-&gt;dkstats.field += addnd)</span>

<span class="cp">#define part_stat_read(part, field)	((part)-&gt;dkstats.field)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">part_stat_set_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">dkstats</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">disk_stats</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">init_part_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_part_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cp">#define part_stat_add(cpu, part, field, addnd)	do {			\</span>
<span class="cp">	__part_stat_add((cpu), (part), field, addnd);			\</span>
<span class="cp">	if ((part)-&gt;partno)						\</span>
<span class="cp">		__part_stat_add((cpu), &amp;part_to_disk((part))-&gt;part0,	\</span>
<span class="cp">				field, addnd);				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define part_stat_dec(cpu, gendiskp, field)				\</span>
<span class="cp">	part_stat_add(cpu, gendiskp, field, -1)</span>
<span class="cp">#define part_stat_inc(cpu, gendiskp, field)				\</span>
<span class="cp">	part_stat_add(cpu, gendiskp, field, 1)</span>
<span class="cp">#define part_stat_sub(cpu, gendiskp, field, subnd)			\</span>
<span class="cp">	part_stat_add(cpu, gendiskp, field, -subnd)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">part_inc_in_flight</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">[</span><span class="n">rw</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">partno</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part_to_disk</span><span class="p">(</span><span class="n">part</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">.</span><span class="n">in_flight</span><span class="p">[</span><span class="n">rw</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">part_dec_in_flight</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">[</span><span class="n">rw</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">partno</span><span class="p">)</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part_to_disk</span><span class="p">(</span><span class="n">part</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">.</span><span class="n">in_flight</span><span class="p">[</span><span class="n">rw</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">part_in_flight</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">partition_meta_info</span> <span class="o">*</span><span class="nf">alloc_part_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disk</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">partition_meta_info</span><span class="p">),</span>
				    <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">partition_meta_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_part_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* block/blk-core.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">part_round_stats</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">);</span>

<span class="cm">/* block/genhd.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">add_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">del_gendisk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gp</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">get_gendisk</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">partno</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdget_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">partno</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_device_ro</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_disk_ro</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_disk_ro</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">.</span><span class="n">policy</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">disk_block_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">disk_unblock_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">disk_flush_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">disk_clear_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>

<span class="cm">/* drivers/char/random.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">add_disk_randomness</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rand_initialize_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">sector_t</span> <span class="nf">get_start_sect</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_part</span><span class="o">-&gt;</span><span class="n">start_sect</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">sector_t</span> <span class="nf">get_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">.</span><span class="n">nr_sects</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">.</span><span class="n">nr_sects</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SOLARIS_X86_PARTITION</span>

<span class="cp">#define SOLARIS_X86_NUMSLICE	16</span>
<span class="cp">#define SOLARIS_X86_VTOC_SANE	(0x600DDEEEUL)</span>

<span class="k">struct</span> <span class="n">solaris_x86_slice</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">s_tag</span><span class="p">;</span>		<span class="cm">/* ID tag of partition */</span>
	<span class="n">__le16</span> <span class="n">s_flag</span><span class="p">;</span>		<span class="cm">/* permission flags */</span>
	<span class="n">__le32</span> <span class="n">s_start</span><span class="p">;</span>		<span class="cm">/* start sector no of partition */</span>
	<span class="n">__le32</span> <span class="n">s_size</span><span class="p">;</span>		<span class="cm">/* # of blocks in partition */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">solaris_x86_vtoc</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">v_bootinfo</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* info needed by mboot (unsupported) */</span>
	<span class="n">__le32</span> <span class="n">v_sanity</span><span class="p">;</span>		<span class="cm">/* to verify vtoc sanity */</span>
	<span class="n">__le32</span> <span class="n">v_version</span><span class="p">;</span>		<span class="cm">/* layout version */</span>
	<span class="kt">char</span>	<span class="n">v_volume</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>		<span class="cm">/* volume name */</span>
	<span class="n">__le16</span>	<span class="n">v_sectorsz</span><span class="p">;</span>		<span class="cm">/* sector size in bytes */</span>
	<span class="n">__le16</span>	<span class="n">v_nparts</span><span class="p">;</span>		<span class="cm">/* number of partitions */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">v_reserved</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>	<span class="cm">/* free space */</span>
	<span class="k">struct</span> <span class="n">solaris_x86_slice</span>
		<span class="n">v_slice</span><span class="p">[</span><span class="n">SOLARIS_X86_NUMSLICE</span><span class="p">];</span> <span class="cm">/* slice headers */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timestamp</span><span class="p">[</span><span class="n">SOLARIS_X86_NUMSLICE</span><span class="p">];</span> <span class="cm">/* timestamp (unsupported) */</span>
	<span class="kt">char</span>	<span class="n">v_asciilabel</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>	<span class="cm">/* for compatibility */</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SOLARIS_X86_PARTITION */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_BSD_DISKLABEL</span>
<span class="cm">/*</span>
<span class="cm"> * BSD disklabel support by Yossi Gottlieb &lt;yogo@math.tau.ac.il&gt;</span>
<span class="cm"> * updated by Marc Espie &lt;Marc.Espie@openbsd.org&gt;</span>
<span class="cm"> */</span>

<span class="cm">/* check against BSD src/sys/sys/disklabel.h for consistency */</span>

<span class="cp">#define BSD_DISKMAGIC	(0x82564557UL)	</span><span class="cm">/* The disk magic number */</span><span class="cp"></span>
<span class="cp">#define BSD_MAXPARTITIONS	16</span>
<span class="cp">#define OPENBSD_MAXPARTITIONS	16</span>
<span class="cp">#define BSD_FS_UNUSED		0	</span><span class="cm">/* disklabel unused partition entry ID */</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">bsd_disklabel</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">d_magic</span><span class="p">;</span>		<span class="cm">/* the magic number */</span>
	<span class="n">__s16</span>	<span class="n">d_type</span><span class="p">;</span>			<span class="cm">/* drive type */</span>
	<span class="n">__s16</span>	<span class="n">d_subtype</span><span class="p">;</span>		<span class="cm">/* controller/d_type specific */</span>
	<span class="kt">char</span>	<span class="n">d_typename</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>		<span class="cm">/* type name, e.g. &quot;eagle&quot; */</span>
	<span class="kt">char</span>	<span class="n">d_packname</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>			<span class="cm">/* pack identifier */</span> 
	<span class="n">__u32</span>	<span class="n">d_secsize</span><span class="p">;</span>		<span class="cm">/* # of bytes per sector */</span>
	<span class="n">__u32</span>	<span class="n">d_nsectors</span><span class="p">;</span>		<span class="cm">/* # of data sectors per track */</span>
	<span class="n">__u32</span>	<span class="n">d_ntracks</span><span class="p">;</span>		<span class="cm">/* # of tracks per cylinder */</span>
	<span class="n">__u32</span>	<span class="n">d_ncylinders</span><span class="p">;</span>		<span class="cm">/* # of data cylinders per unit */</span>
	<span class="n">__u32</span>	<span class="n">d_secpercyl</span><span class="p">;</span>		<span class="cm">/* # of data sectors per cylinder */</span>
	<span class="n">__u32</span>	<span class="n">d_secperunit</span><span class="p">;</span>		<span class="cm">/* # of data sectors per unit */</span>
	<span class="n">__u16</span>	<span class="n">d_sparespertrack</span><span class="p">;</span>	<span class="cm">/* # of spare sectors per track */</span>
	<span class="n">__u16</span>	<span class="n">d_sparespercyl</span><span class="p">;</span>		<span class="cm">/* # of spare sectors per cylinder */</span>
	<span class="n">__u32</span>	<span class="n">d_acylinders</span><span class="p">;</span>		<span class="cm">/* # of alt. cylinders per unit */</span>
	<span class="n">__u16</span>	<span class="n">d_rpm</span><span class="p">;</span>			<span class="cm">/* rotational speed */</span>
	<span class="n">__u16</span>	<span class="n">d_interleave</span><span class="p">;</span>		<span class="cm">/* hardware sector interleave */</span>
	<span class="n">__u16</span>	<span class="n">d_trackskew</span><span class="p">;</span>		<span class="cm">/* sector 0 skew, per track */</span>
	<span class="n">__u16</span>	<span class="n">d_cylskew</span><span class="p">;</span>		<span class="cm">/* sector 0 skew, per cylinder */</span>
	<span class="n">__u32</span>	<span class="n">d_headswitch</span><span class="p">;</span>		<span class="cm">/* head switch time, usec */</span>
	<span class="n">__u32</span>	<span class="n">d_trkseek</span><span class="p">;</span>		<span class="cm">/* track-to-track seek, usec */</span>
	<span class="n">__u32</span>	<span class="n">d_flags</span><span class="p">;</span>		<span class="cm">/* generic flags */</span>
<span class="cp">#define NDDATA 5</span>
	<span class="n">__u32</span>	<span class="n">d_drivedata</span><span class="p">[</span><span class="n">NDDATA</span><span class="p">];</span>	<span class="cm">/* drive-type specific information */</span>
<span class="cp">#define NSPARE 5</span>
	<span class="n">__u32</span>	<span class="n">d_spare</span><span class="p">[</span><span class="n">NSPARE</span><span class="p">];</span>	<span class="cm">/* reserved for future use */</span>
	<span class="n">__le32</span>	<span class="n">d_magic2</span><span class="p">;</span>		<span class="cm">/* the magic number (again) */</span>
	<span class="n">__le16</span>	<span class="n">d_checksum</span><span class="p">;</span>		<span class="cm">/* xor of data incl. partitions */</span>

			<span class="cm">/* filesystem and partition information: */</span>
	<span class="n">__le16</span>	<span class="n">d_npartitions</span><span class="p">;</span>		<span class="cm">/* number of partitions in following */</span>
	<span class="n">__le32</span>	<span class="n">d_bbsize</span><span class="p">;</span>		<span class="cm">/* size of boot area at sn0, bytes */</span>
	<span class="n">__le32</span>	<span class="n">d_sbsize</span><span class="p">;</span>		<span class="cm">/* max size of fs superblock, bytes */</span>
	<span class="k">struct</span>	<span class="n">bsd_partition</span> <span class="p">{</span>		<span class="cm">/* the partition table */</span>
		<span class="n">__le32</span>	<span class="n">p_size</span><span class="p">;</span>		<span class="cm">/* number of sectors in partition */</span>
		<span class="n">__le32</span>	<span class="n">p_offset</span><span class="p">;</span>	<span class="cm">/* starting sector */</span>
		<span class="n">__le32</span>	<span class="n">p_fsize</span><span class="p">;</span>	<span class="cm">/* filesystem basic fragment size */</span>
		<span class="n">__u8</span>	<span class="n">p_fstype</span><span class="p">;</span>	<span class="cm">/* filesystem type, see below */</span>
		<span class="n">__u8</span>	<span class="n">p_frag</span><span class="p">;</span>		<span class="cm">/* filesystem fragments per block */</span>
		<span class="n">__le16</span>	<span class="n">p_cpg</span><span class="p">;</span>		<span class="cm">/* filesystem cylinders per group */</span>
	<span class="p">}</span> <span class="n">d_partitions</span><span class="p">[</span><span class="n">BSD_MAXPARTITIONS</span><span class="p">];</span>	<span class="cm">/* actually may be more */</span>
<span class="p">};</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_BSD_DISKLABEL */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_UNIXWARE_DISKLABEL</span>
<span class="cm">/*</span>
<span class="cm"> * Unixware slices support by Andrzej Krzysztofowicz &lt;ankry@mif.pg.gda.pl&gt;</span>
<span class="cm"> * and Krzysztof G. Baranowski &lt;kgb@knm.org.pl&gt;</span>
<span class="cm"> */</span>

<span class="cp">#define UNIXWARE_DISKMAGIC     (0xCA5E600DUL)	</span><span class="cm">/* The disk magic number */</span><span class="cp"></span>
<span class="cp">#define UNIXWARE_DISKMAGIC2    (0x600DDEEEUL)	</span><span class="cm">/* The slice table magic nr */</span><span class="cp"></span>
<span class="cp">#define UNIXWARE_NUMSLICE      16</span>
<span class="cp">#define UNIXWARE_FS_UNUSED     0		</span><span class="cm">/* Unused slice entry ID */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">unixware_slice</span> <span class="p">{</span>
	<span class="n">__le16</span>   <span class="n">s_label</span><span class="p">;</span>	<span class="cm">/* label */</span>
	<span class="n">__le16</span>   <span class="n">s_flags</span><span class="p">;</span>	<span class="cm">/* permission flags */</span>
	<span class="n">__le32</span>   <span class="n">start_sect</span><span class="p">;</span>	<span class="cm">/* starting sector */</span>
	<span class="n">__le32</span>   <span class="n">nr_sects</span><span class="p">;</span>	<span class="cm">/* number of sectors in slice */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">unixware_disklabel</span> <span class="p">{</span>
	<span class="n">__le32</span>   <span class="n">d_type</span><span class="p">;</span>               	<span class="cm">/* drive type */</span>
	<span class="n">__le32</span>   <span class="n">d_magic</span><span class="p">;</span>                <span class="cm">/* the magic number */</span>
	<span class="n">__le32</span>   <span class="n">d_version</span><span class="p">;</span>              <span class="cm">/* version number */</span>
	<span class="kt">char</span>    <span class="n">d_serial</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>           <span class="cm">/* serial number of the device */</span>
	<span class="n">__le32</span>   <span class="n">d_ncylinders</span><span class="p">;</span>           <span class="cm">/* # of data cylinders per device */</span>
	<span class="n">__le32</span>   <span class="n">d_ntracks</span><span class="p">;</span>              <span class="cm">/* # of tracks per cylinder */</span>
	<span class="n">__le32</span>   <span class="n">d_nsectors</span><span class="p">;</span>             <span class="cm">/* # of data sectors per track */</span>
	<span class="n">__le32</span>   <span class="n">d_secsize</span><span class="p">;</span>              <span class="cm">/* # of bytes per sector */</span>
	<span class="n">__le32</span>   <span class="n">d_part_start</span><span class="p">;</span>           <span class="cm">/* # of first sector of this partition */</span>
	<span class="n">__le32</span>   <span class="n">d_unknown1</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>         <span class="cm">/* ? */</span>
 	<span class="n">__le32</span>	<span class="n">d_alt_tbl</span><span class="p">;</span>              <span class="cm">/* byte offset of alternate table */</span>
 	<span class="n">__le32</span>	<span class="n">d_alt_len</span><span class="p">;</span>              <span class="cm">/* byte length of alternate table */</span>
 	<span class="n">__le32</span>	<span class="n">d_phys_cyl</span><span class="p">;</span>             <span class="cm">/* # of physical cylinders per device */</span>
 	<span class="n">__le32</span>	<span class="n">d_phys_trk</span><span class="p">;</span>             <span class="cm">/* # of physical tracks per cylinder */</span>
 	<span class="n">__le32</span>	<span class="n">d_phys_sec</span><span class="p">;</span>             <span class="cm">/* # of physical sectors per track */</span>
 	<span class="n">__le32</span>	<span class="n">d_phys_bytes</span><span class="p">;</span>           <span class="cm">/* # of physical bytes per sector */</span>
 	<span class="n">__le32</span>	<span class="n">d_unknown2</span><span class="p">;</span>             <span class="cm">/* ? */</span>
	<span class="n">__le32</span>   <span class="n">d_unknown3</span><span class="p">;</span>             <span class="cm">/* ? */</span>
	<span class="n">__le32</span>	<span class="n">d_pad</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>               <span class="cm">/* pad */</span>

	<span class="k">struct</span> <span class="n">unixware_vtoc</span> <span class="p">{</span>
		<span class="n">__le32</span>	<span class="n">v_magic</span><span class="p">;</span>		<span class="cm">/* the magic number */</span>
		<span class="n">__le32</span>	<span class="n">v_version</span><span class="p">;</span>		<span class="cm">/* version number */</span>
		<span class="kt">char</span>	<span class="n">v_name</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>		<span class="cm">/* volume name */</span>
		<span class="n">__le16</span>	<span class="n">v_nslices</span><span class="p">;</span>		<span class="cm">/* # of slices */</span>
		<span class="n">__le16</span>	<span class="n">v_unknown1</span><span class="p">;</span>		<span class="cm">/* ? */</span>
		<span class="n">__le32</span>	<span class="n">v_reserved</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>		<span class="cm">/* reserved */</span>
		<span class="k">struct</span> <span class="n">unixware_slice</span>
			<span class="n">v_slice</span><span class="p">[</span><span class="n">UNIXWARE_NUMSLICE</span><span class="p">];</span>	<span class="cm">/* slice headers */</span>
	<span class="p">}</span> <span class="n">vtoc</span><span class="p">;</span>

<span class="p">};</span>  <span class="cm">/* 408 */</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_UNIXWARE_DISKLABEL */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_MINIX_SUBPARTITION</span>
<span class="cp">#   define MINIX_NR_SUBPARTITIONS  4</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MINIX_SUBPARTITION */</span><span class="cp"></span>

<span class="cp">#define ADDPART_FLAG_NONE	0</span>
<span class="cp">#define ADDPART_FLAG_RAID	1</span>
<span class="cp">#define ADDPART_FLAG_WHOLEDISK	2</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_alloc_devt</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">,</span> <span class="n">dev_t</span> <span class="o">*</span><span class="n">devt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_free_devt</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">devt</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">dev_t</span> <span class="n">blk_lookup_devt</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">partno</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">disk_name</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">hd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">partno</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">disk_expand_part_tbl</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rescan_partitions</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">invalidate_partitions</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span> <span class="n">__must_check</span> <span class="n">add_partition</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span>
						     <span class="kt">int</span> <span class="n">partno</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">start</span><span class="p">,</span>
						     <span class="n">sector_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">partition_meta_info</span>
						       <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__delete_partition</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">delete_partition</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">printk_all_partitions</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">alloc_disk_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">minors</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">alloc_disk</span><span class="p">(</span><span class="kt">int</span> <span class="n">minors</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">get_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">put_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_register_region</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">devt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">range</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="n">dev_t</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">)(</span><span class="n">dev_t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_unregister_region</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">devt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">range</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">part_size_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">part_stat_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">part_inflight_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_FAIL_MAKE_REQUEST</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">part_fail_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">part_fail_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FAIL_MAKE_REQUEST */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hd_ref_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">smp_mb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hd_struct_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
	<span class="n">smp_mb__after_atomic_inc</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hd_struct_try_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hd_struct_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">))</span>
		<span class="n">__delete_partition</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_BLOCK */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">printk_all_partitions</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">dev_t</span> <span class="nf">blk_lookup_devt</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">partno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_t</span> <span class="n">devt</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">devt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_BLOCK */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_GENHD_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
