<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › a.out.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>a.out.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __A_OUT_GNU_H__</span>
<span class="cp">#define __A_OUT_GNU_H__</span>

<span class="cp">#define __GNU_EXEC_MACROS__</span>

<span class="cp">#ifndef __STRUCT_EXEC_OVERRIDE__</span>

<span class="cp">#include &lt;asm/a.out.h&gt;</span>

<span class="cp">#endif </span><span class="cm">/* __STRUCT_EXEC_OVERRIDE__ */</span><span class="cp"></span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cm">/* these go in the N_MACHTYPE field */</span>
<span class="k">enum</span> <span class="n">machine_type</span> <span class="p">{</span>
<span class="cp">#if defined (M_OLDSUN2)</span>
  <span class="n">M__OLDSUN2</span> <span class="o">=</span> <span class="n">M_OLDSUN2</span><span class="p">,</span>
<span class="cp">#else</span>
  <span class="n">M_OLDSUN2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#if defined (M_68010)</span>
  <span class="n">M__68010</span> <span class="o">=</span> <span class="n">M_68010</span><span class="p">,</span>
<span class="cp">#else</span>
  <span class="n">M_68010</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#if defined (M_68020)</span>
  <span class="n">M__68020</span> <span class="o">=</span> <span class="n">M_68020</span><span class="p">,</span>
<span class="cp">#else</span>
  <span class="n">M_68020</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#if defined (M_SPARC)</span>
  <span class="n">M__SPARC</span> <span class="o">=</span> <span class="n">M_SPARC</span><span class="p">,</span>
<span class="cp">#else</span>
  <span class="n">M_SPARC</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="cp">#endif</span>
  <span class="cm">/* skip a bunch so we don&#39;t run into any of sun&#39;s numbers */</span>
  <span class="n">M_386</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
  <span class="n">M_MIPS1</span> <span class="o">=</span> <span class="mi">151</span><span class="p">,</span>	<span class="cm">/* MIPS R3000/R3000 binary */</span>
  <span class="n">M_MIPS2</span> <span class="o">=</span> <span class="mi">152</span>		<span class="cm">/* MIPS R6000/R4000 binary */</span>
<span class="p">};</span>

<span class="cp">#if !defined (N_MAGIC)</span>
<span class="cp">#define N_MAGIC(exec) ((exec).a_info &amp; 0xffff)</span>
<span class="cp">#endif</span>
<span class="cp">#define N_MACHTYPE(exec) ((enum machine_type)(((exec).a_info &gt;&gt; 16) &amp; 0xff))</span>
<span class="cp">#define N_FLAGS(exec) (((exec).a_info &gt;&gt; 24) &amp; 0xff)</span>
<span class="cp">#define N_SET_INFO(exec, magic, type, flags) \</span>
<span class="cp">	((exec).a_info = ((magic) &amp; 0xffff) \</span>
<span class="cp">	 | (((int)(type) &amp; 0xff) &lt;&lt; 16) \</span>
<span class="cp">	 | (((flags) &amp; 0xff) &lt;&lt; 24))</span>
<span class="cp">#define N_SET_MAGIC(exec, magic) \</span>
<span class="cp">	((exec).a_info = (((exec).a_info &amp; 0xffff0000) | ((magic) &amp; 0xffff)))</span>

<span class="cp">#define N_SET_MACHTYPE(exec, machtype) \</span>
<span class="cp">	((exec).a_info = \</span>
<span class="cp">	 ((exec).a_info&amp;0xff00ffff) | ((((int)(machtype))&amp;0xff) &lt;&lt; 16))</span>

<span class="cp">#define N_SET_FLAGS(exec, flags) \</span>
<span class="cp">	((exec).a_info = \</span>
<span class="cp">	 ((exec).a_info&amp;0x00ffffff) | (((flags) &amp; 0xff) &lt;&lt; 24))</span>

<span class="cm">/* Code indicating object file or impure executable.  */</span>
<span class="cp">#define OMAGIC 0407</span>
<span class="cm">/* Code indicating pure executable.  */</span>
<span class="cp">#define NMAGIC 0410</span>
<span class="cm">/* Code indicating demand-paged executable.  */</span>
<span class="cp">#define ZMAGIC 0413</span>
<span class="cm">/* This indicates a demand-paged executable with the header in the text. </span>
<span class="cm">   The first page is unmapped to help trap NULL pointer references */</span>
<span class="cp">#define QMAGIC 0314</span>

<span class="cm">/* Code indicating core file.  */</span>
<span class="cp">#define CMAGIC 0421</span>

<span class="cp">#if !defined (N_BADMAG)</span>
<span class="cp">#define N_BADMAG(x)	  (N_MAGIC(x) != OMAGIC		\</span>
<span class="cp">			&amp;&amp; N_MAGIC(x) != NMAGIC		\</span>
<span class="cp">  			&amp;&amp; N_MAGIC(x) != ZMAGIC \</span>
<span class="cp">		        &amp;&amp; N_MAGIC(x) != QMAGIC)</span>
<span class="cp">#endif</span>

<span class="cp">#define _N_HDROFF(x) (1024 - sizeof (struct exec))</span>

<span class="cp">#if !defined (N_TXTOFF)</span>
<span class="cp">#define N_TXTOFF(x) \</span>
<span class="cp"> (N_MAGIC(x) == ZMAGIC ? _N_HDROFF((x)) + sizeof (struct exec) : \</span>
<span class="cp">  (N_MAGIC(x) == QMAGIC ? 0 : sizeof (struct exec)))</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined (N_DATOFF)</span>
<span class="cp">#define N_DATOFF(x) (N_TXTOFF(x) + (x).a_text)</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined (N_TRELOFF)</span>
<span class="cp">#define N_TRELOFF(x) (N_DATOFF(x) + (x).a_data)</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined (N_DRELOFF)</span>
<span class="cp">#define N_DRELOFF(x) (N_TRELOFF(x) + N_TRSIZE(x))</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined (N_SYMOFF)</span>
<span class="cp">#define N_SYMOFF(x) (N_DRELOFF(x) + N_DRSIZE(x))</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined (N_STROFF)</span>
<span class="cp">#define N_STROFF(x) (N_SYMOFF(x) + N_SYMSIZE(x))</span>
<span class="cp">#endif</span>

<span class="cm">/* Address of text segment in memory after it is loaded.  */</span>
<span class="cp">#if !defined (N_TXTADDR)</span>
<span class="cp">#define N_TXTADDR(x) (N_MAGIC(x) == QMAGIC ? PAGE_SIZE : 0)</span>
<span class="cp">#endif</span>

<span class="cm">/* Address of data segment in memory after it is loaded.</span>
<span class="cm">   Note that it is up to you to define SEGMENT_SIZE</span>
<span class="cm">   on machines not listed here.  */</span>
<span class="cp">#if defined(vax) || defined(hp300) || defined(pyr)</span>
<span class="cp">#define SEGMENT_SIZE page_size</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef	sony</span>
<span class="cp">#define	SEGMENT_SIZE	0x2000</span>
<span class="cp">#endif	</span><span class="cm">/* Sony.  */</span><span class="cp"></span>
<span class="cp">#ifdef is68k</span>
<span class="cp">#define SEGMENT_SIZE 0x20000</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(m68k) &amp;&amp; defined(PORTAR)</span>
<span class="cp">#define PAGE_SIZE 0x400</span>
<span class="cp">#define SEGMENT_SIZE PAGE_SIZE</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef linux</span>
<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(__i386__) || defined(__mc68000__)</span>
<span class="cp">#define SEGMENT_SIZE	1024</span>
<span class="cp">#else</span>
<span class="cp">#ifndef SEGMENT_SIZE</span>
<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#define SEGMENT_SIZE	PAGE_SIZE</span>
<span class="cp">#else</span>
<span class="cp">#define SEGMENT_SIZE   getpagesize()</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cp">#define _N_SEGMENT_ROUND(x) ALIGN(x, SEGMENT_SIZE)</span>

<span class="cp">#define _N_TXTENDADDR(x) (N_TXTADDR(x)+(x).a_text)</span>

<span class="cp">#ifndef N_DATADDR</span>
<span class="cp">#define N_DATADDR(x) \</span>
<span class="cp">    (N_MAGIC(x)==OMAGIC? (_N_TXTENDADDR(x)) \</span>
<span class="cp">     : (_N_SEGMENT_ROUND (_N_TXTENDADDR(x))))</span>
<span class="cp">#endif</span>

<span class="cm">/* Address of bss segment in memory after it is loaded.  */</span>
<span class="cp">#if !defined (N_BSSADDR)</span>
<span class="cp">#define N_BSSADDR(x) (N_DATADDR(x) + (x).a_data)</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined (N_NLIST_DECLARED)</span>
<span class="k">struct</span> <span class="n">nlist</span> <span class="p">{</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">n_name</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">nlist</span> <span class="o">*</span><span class="n">n_next</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">n_strx</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">n_un</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">n_type</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">n_other</span><span class="p">;</span>
  <span class="kt">short</span> <span class="n">n_desc</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n_value</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* no N_NLIST_DECLARED.  */</span><span class="cp"></span>

<span class="cp">#if !defined (N_UNDF)</span>
<span class="cp">#define N_UNDF 0</span>
<span class="cp">#endif</span>
<span class="cp">#if !defined (N_ABS)</span>
<span class="cp">#define N_ABS 2</span>
<span class="cp">#endif</span>
<span class="cp">#if !defined (N_TEXT)</span>
<span class="cp">#define N_TEXT 4</span>
<span class="cp">#endif</span>
<span class="cp">#if !defined (N_DATA)</span>
<span class="cp">#define N_DATA 6</span>
<span class="cp">#endif</span>
<span class="cp">#if !defined (N_BSS)</span>
<span class="cp">#define N_BSS 8</span>
<span class="cp">#endif</span>
<span class="cp">#if !defined (N_FN)</span>
<span class="cp">#define N_FN 15</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined (N_EXT)</span>
<span class="cp">#define N_EXT 1</span>
<span class="cp">#endif</span>
<span class="cp">#if !defined (N_TYPE)</span>
<span class="cp">#define N_TYPE 036</span>
<span class="cp">#endif</span>
<span class="cp">#if !defined (N_STAB)</span>
<span class="cp">#define N_STAB 0340</span>
<span class="cp">#endif</span>

<span class="cm">/* The following type indicates the definition of a symbol as being</span>
<span class="cm">   an indirect reference to another symbol.  The other symbol</span>
<span class="cm">   appears as an undefined reference, immediately following this symbol.</span>

<span class="cm">   Indirection is asymmetrical.  The other symbol&#39;s value will be used</span>
<span class="cm">   to satisfy requests for the indirect symbol, but not vice versa.</span>
<span class="cm">   If the other symbol does not have a definition, libraries will</span>
<span class="cm">   be searched to find a definition.  */</span>
<span class="cp">#define N_INDR 0xa</span>

<span class="cm">/* The following symbols refer to set elements.</span>
<span class="cm">   All the N_SET[ATDB] symbols with the same name form one set.</span>
<span class="cm">   Space is allocated for the set in the text section, and each set</span>
<span class="cm">   element&#39;s value is stored into one word of the space.</span>
<span class="cm">   The first word of the space is the length of the set (number of elements).</span>

<span class="cm">   The address of the set is made into an N_SETV symbol</span>
<span class="cm">   whose name is the same as the name of the set.</span>
<span class="cm">   This symbol acts like a N_DATA global symbol</span>
<span class="cm">   in that it can satisfy undefined external references.  */</span>

<span class="cm">/* These appear as input to LD, in a .o file.  */</span>
<span class="cp">#define	N_SETA	0x14		</span><span class="cm">/* Absolute set element symbol */</span><span class="cp"></span>
<span class="cp">#define	N_SETT	0x16		</span><span class="cm">/* Text set element symbol */</span><span class="cp"></span>
<span class="cp">#define	N_SETD	0x18		</span><span class="cm">/* Data set element symbol */</span><span class="cp"></span>
<span class="cp">#define	N_SETB	0x1A		</span><span class="cm">/* Bss set element symbol */</span><span class="cp"></span>

<span class="cm">/* This is output from LD.  */</span>
<span class="cp">#define N_SETV	0x1C		</span><span class="cm">/* Pointer to set vector in data area.  */</span><span class="cp"></span>

<span class="cp">#if !defined (N_RELOCATION_INFO_DECLARED)</span>
<span class="cm">/* This structure describes a single relocation to be performed.</span>
<span class="cm">   The text-relocation section of the file is a vector of these structures,</span>
<span class="cm">   all of which apply to the text section.</span>
<span class="cm">   Likewise, the data-relocation section applies to the data section.  */</span>

<span class="k">struct</span> <span class="n">relocation_info</span>
<span class="p">{</span>
  <span class="cm">/* Address (within segment) to be relocated.  */</span>
  <span class="kt">int</span> <span class="n">r_address</span><span class="p">;</span>
  <span class="cm">/* The meaning of r_symbolnum depends on r_extern.  */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r_symbolnum</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>
  <span class="cm">/* Nonzero means value is a pc-relative offset</span>
<span class="cm">     and it should be relocated for changes in its own address</span>
<span class="cm">     as well as for changes in the symbol or section specified.  */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r_pcrel</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="cm">/* Length (as exponent of 2) of the field to be relocated.</span>
<span class="cm">     Thus, a value of 2 indicates 1&lt;&lt;2 bytes.  */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r_length</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
  <span class="cm">/* 1 =&gt; relocate with value of symbol.</span>
<span class="cm">          r_symbolnum is the index of the symbol</span>
<span class="cm">	  in file&#39;s the symbol table.</span>
<span class="cm">     0 =&gt; relocate with the address of a segment.</span>
<span class="cm">          r_symbolnum is N_TEXT, N_DATA, N_BSS or N_ABS</span>
<span class="cm">	  (the N_EXT bit may be set also, but signifies nothing).  */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r_extern</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="cm">/* Four bits that aren&#39;t used, but when writing an object file</span>
<span class="cm">     it is desirable to clear them.  */</span>
<span class="cp">#ifdef NS32K</span>
  <span class="kt">unsigned</span> <span class="n">r_bsr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">r_disp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">r_pad</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
<span class="cp">#else</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r_pad</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* no N_RELOCATION_INFO_DECLARED.  */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/*__ASSEMBLY__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* __A_OUT_GNU_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
