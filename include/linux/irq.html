<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › irq.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>irq.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_IRQ_H</span>
<span class="cp">#define _LINUX_IRQ_H</span>

<span class="cm">/*</span>
<span class="cm"> * Please do not include this file in generic code.  There is currently</span>
<span class="cm"> * no requirement for any architecture to implement anything held</span>
<span class="cm"> * within this file.</span>
<span class="cm"> *</span>
<span class="cm"> * Thanks. --rmk</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/smp.h&gt;</span>

<span class="cp">#ifndef CONFIG_S390</span>

<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/irqreturn.h&gt;</span>
<span class="cp">#include &lt;linux/irqnr.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/topology.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>

<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/irq_regs.h&gt;</span>

<span class="k">struct</span> <span class="n">seq_file</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">irq_desc</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">irq_data</span><span class="p">;</span>
<span class="k">typedef</span>	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_flow_handler_t</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
<span class="k">typedef</span>	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_preflow_handler_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * IRQ line status.</span>
<span class="cm"> *</span>
<span class="cm"> * Bits 0-7 are the same as the IRQF_* bits in linux/interrupt.h</span>
<span class="cm"> *</span>
<span class="cm"> * IRQ_TYPE_NONE		- default, unspecified type</span>
<span class="cm"> * IRQ_TYPE_EDGE_RISING		- rising edge triggered</span>
<span class="cm"> * IRQ_TYPE_EDGE_FALLING	- falling edge triggered</span>
<span class="cm"> * IRQ_TYPE_EDGE_BOTH		- rising and falling edge triggered</span>
<span class="cm"> * IRQ_TYPE_LEVEL_HIGH		- high level triggered</span>
<span class="cm"> * IRQ_TYPE_LEVEL_LOW		- low level triggered</span>
<span class="cm"> * IRQ_TYPE_LEVEL_MASK		- Mask to filter out the level bits</span>
<span class="cm"> * IRQ_TYPE_SENSE_MASK		- Mask for all the above bits</span>
<span class="cm"> * IRQ_TYPE_DEFAULT		- For use by some PICs to ask irq_set_type</span>
<span class="cm"> *				  to setup the HW to a sane default (used</span>
<span class="cm"> *                                by irqdomain map() callbacks to synchronize</span>
<span class="cm"> *                                the HW state and SW flags for a newly</span>
<span class="cm"> *                                allocated descriptor).</span>
<span class="cm"> *</span>
<span class="cm"> * IRQ_TYPE_PROBE		- Special flag for probing in progress</span>
<span class="cm"> *</span>
<span class="cm"> * Bits which can be modified via irq_set/clear/modify_status_flags()</span>
<span class="cm"> * IRQ_LEVEL			- Interrupt is level type. Will be also</span>
<span class="cm"> *				  updated in the code when the above trigger</span>
<span class="cm"> *				  bits are modified via irq_set_irq_type()</span>
<span class="cm"> * IRQ_PER_CPU			- Mark an interrupt PER_CPU. Will protect</span>
<span class="cm"> *				  it from affinity setting</span>
<span class="cm"> * IRQ_NOPROBE			- Interrupt cannot be probed by autoprobing</span>
<span class="cm"> * IRQ_NOREQUEST		- Interrupt cannot be requested via</span>
<span class="cm"> *				  request_irq()</span>
<span class="cm"> * IRQ_NOTHREAD			- Interrupt cannot be threaded</span>
<span class="cm"> * IRQ_NOAUTOEN			- Interrupt is not automatically enabled in</span>
<span class="cm"> *				  request/setup_irq()</span>
<span class="cm"> * IRQ_NO_BALANCING		- Interrupt cannot be balanced (affinity set)</span>
<span class="cm"> * IRQ_MOVE_PCNTXT		- Interrupt can be migrated from process context</span>
<span class="cm"> * IRQ_NESTED_TRHEAD		- Interrupt nests into another thread</span>
<span class="cm"> * IRQ_PER_CPU_DEVID		- Dev_id is a per-cpu variable</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IRQ_TYPE_NONE</span>		<span class="o">=</span> <span class="mh">0x00000000</span><span class="p">,</span>
	<span class="n">IRQ_TYPE_EDGE_RISING</span>	<span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span>
	<span class="n">IRQ_TYPE_EDGE_FALLING</span>	<span class="o">=</span> <span class="mh">0x00000002</span><span class="p">,</span>
	<span class="n">IRQ_TYPE_EDGE_BOTH</span>	<span class="o">=</span> <span class="p">(</span><span class="n">IRQ_TYPE_EDGE_FALLING</span> <span class="o">|</span> <span class="n">IRQ_TYPE_EDGE_RISING</span><span class="p">),</span>
	<span class="n">IRQ_TYPE_LEVEL_HIGH</span>	<span class="o">=</span> <span class="mh">0x00000004</span><span class="p">,</span>
	<span class="n">IRQ_TYPE_LEVEL_LOW</span>	<span class="o">=</span> <span class="mh">0x00000008</span><span class="p">,</span>
	<span class="n">IRQ_TYPE_LEVEL_MASK</span>	<span class="o">=</span> <span class="p">(</span><span class="n">IRQ_TYPE_LEVEL_LOW</span> <span class="o">|</span> <span class="n">IRQ_TYPE_LEVEL_HIGH</span><span class="p">),</span>
	<span class="n">IRQ_TYPE_SENSE_MASK</span>	<span class="o">=</span> <span class="mh">0x0000000f</span><span class="p">,</span>
	<span class="n">IRQ_TYPE_DEFAULT</span>	<span class="o">=</span> <span class="n">IRQ_TYPE_SENSE_MASK</span><span class="p">,</span>

	<span class="n">IRQ_TYPE_PROBE</span>		<span class="o">=</span> <span class="mh">0x00000010</span><span class="p">,</span>

	<span class="n">IRQ_LEVEL</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">8</span><span class="p">),</span>
	<span class="n">IRQ_PER_CPU</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">9</span><span class="p">),</span>
	<span class="n">IRQ_NOPROBE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span>
	<span class="n">IRQ_NOREQUEST</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">),</span>
	<span class="n">IRQ_NOAUTOEN</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">),</span>
	<span class="n">IRQ_NO_BALANCING</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">),</span>
	<span class="n">IRQ_MOVE_PCNTXT</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">),</span>
	<span class="n">IRQ_NESTED_THREAD</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">),</span>
	<span class="n">IRQ_NOTHREAD</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">),</span>
	<span class="n">IRQ_PER_CPU_DEVID</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">),</span>
<span class="p">};</span>

<span class="cp">#define IRQF_MODIFY_MASK	\</span>
<span class="cp">	(IRQ_TYPE_SENSE_MASK | IRQ_NOPROBE | IRQ_NOREQUEST | \</span>
<span class="cp">	 IRQ_NOAUTOEN | IRQ_MOVE_PCNTXT | IRQ_LEVEL | IRQ_NO_BALANCING | \</span>
<span class="cp">	 IRQ_PER_CPU | IRQ_NESTED_THREAD | IRQ_NOTHREAD | IRQ_PER_CPU_DEVID)</span>

<span class="cp">#define IRQ_NO_BALANCING_MASK	(IRQ_PER_CPU | IRQ_NO_BALANCING)</span>

<span class="cm">/*</span>
<span class="cm"> * Return value for chip-&gt;irq_set_affinity()</span>
<span class="cm"> *</span>
<span class="cm"> * IRQ_SET_MASK_OK	- OK, core updates irq_data.affinity</span>
<span class="cm"> * IRQ_SET_MASK_NOCPY	- OK, chip did update irq_data.affinity</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IRQ_SET_MASK_OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IRQ_SET_MASK_OK_NOCOPY</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">msi_desc</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">irq_domain</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct irq_data - per irq and irq chip data passed down to chip functions</span>
<span class="cm"> * @irq:		interrupt number</span>
<span class="cm"> * @hwirq:		hardware interrupt number, local to the interrupt domain</span>
<span class="cm"> * @node:		node index useful for balancing</span>
<span class="cm"> * @state_use_accessors: status information for irq chip functions.</span>
<span class="cm"> *			Use accessor functions to deal with it</span>
<span class="cm"> * @chip:		low level interrupt hardware access</span>
<span class="cm"> * @domain:		Interrupt translation domain; responsible for mapping</span>
<span class="cm"> *			between hwirq number and linux irq number.</span>
<span class="cm"> * @handler_data:	per-IRQ data for the irq_chip methods</span>
<span class="cm"> * @chip_data:		platform-specific per-chip private data for the chip</span>
<span class="cm"> *			methods, to allow shared chip implementations</span>
<span class="cm"> * @msi_desc:		MSI descriptor</span>
<span class="cm"> * @affinity:		IRQ affinity on SMP</span>
<span class="cm"> *</span>
<span class="cm"> * The fields here need to overlay the ones in irq_desc until we</span>
<span class="cm"> * cleaned up the direct references and switched everything over to</span>
<span class="cm"> * irq_data.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">irq_data</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">irq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">hwirq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">state_use_accessors</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_chip</span>		<span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_domain</span>	<span class="o">*</span><span class="n">domain</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">handler_data</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">chip_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msi_desc</span>		<span class="o">*</span><span class="n">msi_desc</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">cpumask_var_t</span>		<span class="n">affinity</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Bit masks for irq_data.state</span>
<span class="cm"> *</span>
<span class="cm"> * IRQD_TRIGGER_MASK		- Mask for the trigger type bits</span>
<span class="cm"> * IRQD_SETAFFINITY_PENDING	- Affinity setting is pending</span>
<span class="cm"> * IRQD_NO_BALANCING		- Balancing disabled for this IRQ</span>
<span class="cm"> * IRQD_PER_CPU			- Interrupt is per cpu</span>
<span class="cm"> * IRQD_AFFINITY_SET		- Interrupt affinity was set</span>
<span class="cm"> * IRQD_LEVEL			- Interrupt is level triggered</span>
<span class="cm"> * IRQD_WAKEUP_STATE		- Interrupt is configured for wakeup</span>
<span class="cm"> *				  from suspend</span>
<span class="cm"> * IRDQ_MOVE_PCNTXT		- Interrupt can be moved in process</span>
<span class="cm"> *				  context</span>
<span class="cm"> * IRQD_IRQ_DISABLED		- Disabled state of the interrupt</span>
<span class="cm"> * IRQD_IRQ_MASKED		- Masked state of the interrupt</span>
<span class="cm"> * IRQD_IRQ_INPROGRESS		- In progress state of the interrupt</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IRQD_TRIGGER_MASK</span>		<span class="o">=</span> <span class="mh">0xf</span><span class="p">,</span>
	<span class="n">IRQD_SETAFFINITY_PENDING</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">8</span><span class="p">),</span>
	<span class="n">IRQD_NO_BALANCING</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span>
	<span class="n">IRQD_PER_CPU</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">),</span>
	<span class="n">IRQD_AFFINITY_SET</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">),</span>
	<span class="n">IRQD_LEVEL</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">),</span>
	<span class="n">IRQD_WAKEUP_STATE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">),</span>
	<span class="n">IRQD_MOVE_PCNTXT</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">),</span>
	<span class="n">IRQD_IRQ_DISABLED</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">),</span>
	<span class="n">IRQD_IRQ_MASKED</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">),</span>
	<span class="n">IRQD_IRQ_INPROGRESS</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">irqd_is_setaffinity_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">state_use_accessors</span> <span class="o">&amp;</span> <span class="n">IRQD_SETAFFINITY_PENDING</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">irqd_is_per_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">state_use_accessors</span> <span class="o">&amp;</span> <span class="n">IRQD_PER_CPU</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">irqd_can_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">state_use_accessors</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IRQD_PER_CPU</span> <span class="o">|</span> <span class="n">IRQD_NO_BALANCING</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">irqd_affinity_was_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">state_use_accessors</span> <span class="o">&amp;</span> <span class="n">IRQD_AFFINITY_SET</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irqd_mark_affinity_was_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">state_use_accessors</span> <span class="o">|=</span> <span class="n">IRQD_AFFINITY_SET</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">irqd_get_trigger_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">state_use_accessors</span> <span class="o">&amp;</span> <span class="n">IRQD_TRIGGER_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Must only be called inside irq_chip.irq_set_type() functions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irqd_set_trigger_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">u32</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">state_use_accessors</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IRQD_TRIGGER_MASK</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">state_use_accessors</span> <span class="o">|=</span> <span class="n">type</span> <span class="o">&amp;</span> <span class="n">IRQD_TRIGGER_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">irqd_is_level_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">state_use_accessors</span> <span class="o">&amp;</span> <span class="n">IRQD_LEVEL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">irqd_is_wakeup_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">state_use_accessors</span> <span class="o">&amp;</span> <span class="n">IRQD_WAKEUP_STATE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">irqd_can_move_in_process_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">state_use_accessors</span> <span class="o">&amp;</span> <span class="n">IRQD_MOVE_PCNTXT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">irqd_irq_disabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">state_use_accessors</span> <span class="o">&amp;</span> <span class="n">IRQD_IRQ_DISABLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">irqd_irq_masked</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">state_use_accessors</span> <span class="o">&amp;</span> <span class="n">IRQD_IRQ_MASKED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">irqd_irq_inprogress</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">state_use_accessors</span> <span class="o">&amp;</span> <span class="n">IRQD_IRQ_INPROGRESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Functions for chained handlers which can be enabled/disabled by the</span>
<span class="cm"> * standard disable_irq/enable_irq calls. Must be called with</span>
<span class="cm"> * irq_desc-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irqd_set_chained_irq_inprogress</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">state_use_accessors</span> <span class="o">|=</span> <span class="n">IRQD_IRQ_INPROGRESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irqd_clr_chained_irq_inprogress</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">state_use_accessors</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IRQD_IRQ_INPROGRESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">irq_hw_number_t</span> <span class="nf">irqd_to_hwirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hwirq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct irq_chip - hardware interrupt chip descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * @name:		name for /proc/interrupts</span>
<span class="cm"> * @irq_startup:	start up the interrupt (defaults to -&gt;enable if NULL)</span>
<span class="cm"> * @irq_shutdown:	shut down the interrupt (defaults to -&gt;disable if NULL)</span>
<span class="cm"> * @irq_enable:		enable the interrupt (defaults to chip-&gt;unmask if NULL)</span>
<span class="cm"> * @irq_disable:	disable the interrupt</span>
<span class="cm"> * @irq_ack:		start of a new interrupt</span>
<span class="cm"> * @irq_mask:		mask an interrupt source</span>
<span class="cm"> * @irq_mask_ack:	ack and mask an interrupt source</span>
<span class="cm"> * @irq_unmask:		unmask an interrupt source</span>
<span class="cm"> * @irq_eoi:		end of interrupt</span>
<span class="cm"> * @irq_set_affinity:	set the CPU affinity on SMP machines</span>
<span class="cm"> * @irq_retrigger:	resend an IRQ to the CPU</span>
<span class="cm"> * @irq_set_type:	set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ</span>
<span class="cm"> * @irq_set_wake:	enable/disable power-management wake-on of an IRQ</span>
<span class="cm"> * @irq_bus_lock:	function to lock access to slow bus (i2c) chips</span>
<span class="cm"> * @irq_bus_sync_unlock:function to sync and unlock slow bus (i2c) chips</span>
<span class="cm"> * @irq_cpu_online:	configure an interrupt source for a secondary CPU</span>
<span class="cm"> * @irq_cpu_offline:	un-configure an interrupt source for a secondary CPU</span>
<span class="cm"> * @irq_suspend:	function called from core code on suspend once per chip</span>
<span class="cm"> * @irq_resume:		function called from core code on resume once per chip</span>
<span class="cm"> * @irq_pm_shutdown:	function called from core code on shutdown once per chip</span>
<span class="cm"> * @irq_print_chip:	optional to print special chip info in show_interrupts</span>
<span class="cm"> * @flags:		chip specific flags</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">irq_chip</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">irq_startup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_enable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_disable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_ack</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_mask</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_mask_ack</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_unmask</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_eoi</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_set_affinity</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_retrigger</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_set_type</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flow_type</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_set_wake</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">on</span><span class="p">);</span>

	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_bus_lock</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_bus_sync_unlock</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_cpu_online</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_cpu_offline</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_pm_shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">irq_print_chip</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * irq_chip specific flags</span>
<span class="cm"> *</span>
<span class="cm"> * IRQCHIP_SET_TYPE_MASKED:	Mask before calling chip.irq_set_type()</span>
<span class="cm"> * IRQCHIP_EOI_IF_HANDLED:	Only issue irq_eoi() when irq was handled</span>
<span class="cm"> * IRQCHIP_MASK_ON_SUSPEND:	Mask non wake irqs in the suspend path</span>
<span class="cm"> * IRQCHIP_ONOFFLINE_ENABLED:	Only call irq_on/off_line callbacks</span>
<span class="cm"> *				when irq enabled</span>
<span class="cm"> * IRQCHIP_SKIP_SET_WAKE:	Skip chip.irq_set_wake(), for this irq chip</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IRQCHIP_SET_TYPE_MASKED</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">0</span><span class="p">),</span>
	<span class="n">IRQCHIP_EOI_IF_HANDLED</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">1</span><span class="p">),</span>
	<span class="n">IRQCHIP_MASK_ON_SUSPEND</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">2</span><span class="p">),</span>
	<span class="n">IRQCHIP_ONOFFLINE_ENABLED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">3</span><span class="p">),</span>
	<span class="n">IRQCHIP_SKIP_SET_WAKE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">4</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/* This include will go away once we isolated irq_desc usage to core code */</span>
<span class="cp">#include &lt;linux/irqdesc.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Pick up the arch-dependent methods:</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;asm/hw_irq.h&gt;</span>

<span class="cp">#ifndef NR_IRQS_LEGACY</span>
<span class="cp"># define NR_IRQS_LEGACY 0</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef ARCH_IRQ_INIT_FLAGS</span>
<span class="cp"># define ARCH_IRQ_INIT_FLAGS	0</span>
<span class="cp">#endif</span>

<span class="cp">#define IRQ_DEFAULT_INIT_FLAGS	ARCH_IRQ_INIT_FLAGS</span>

<span class="k">struct</span> <span class="n">irqaction</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">setup_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">new</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">remove_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">act</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">setup_percpu_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">new</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">remove_percpu_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">act</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">irq_cpu_online</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">irq_cpu_offline</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__irq_set_affinity_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>  <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_GENERIC_HARDIRQS</span>

<span class="cp">#if defined(CONFIG_SMP) &amp;&amp; defined(CONFIG_GENERIC_PENDING_IRQ)</span>
<span class="kt">void</span> <span class="n">irq_move_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">irq_move_masked_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_move_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_move_masked_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">no_irq_affinity</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Built-in IRQ handlers for various IRQ types,</span>
<span class="cm"> * callable via desc-&gt;handle_irq()</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">handle_level_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">handle_fasteoi_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">handle_edge_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">handle_edge_eoi_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">handle_simple_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">handle_percpu_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">handle_percpu_devid_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">handle_bad_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">handle_nested_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>

<span class="cm">/* Handling of unhandled and spurious interrupts: */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">note_interrupt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
			   <span class="n">irqreturn_t</span> <span class="n">action_ret</span><span class="p">);</span>


<span class="cm">/* Enable/disable irq debugging output: */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">noirqdebug_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>

<span class="cm">/* Checks whether the interrupt can be requested by request_irq(): */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">can_request_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">);</span>

<span class="cm">/* Dummy irq-chip implementations: */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">no_irq_chip</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">dummy_irq_chip</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span>
<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			      <span class="n">irq_flow_handler_t</span> <span class="n">handle</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_set_chip_and_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
					    <span class="n">irq_flow_handler_t</span> <span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">irq_set_percpu_devid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span>
<span class="n">__irq_set_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_flow_handler_t</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_chained</span><span class="p">,</span>
		  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">irq_set_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_flow_handler_t</span> <span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__irq_set_handler</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set a highlevel chained flow handler for a given IRQ.</span>
<span class="cm"> * (a chained handler is automatically enabled and set to</span>
<span class="cm"> *  IRQ_NOREQUEST, IRQ_NOPROBE, and IRQ_NOTHREAD)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">irq_set_chained_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_flow_handler_t</span> <span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__irq_set_handler</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">irq_modify_status</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">set</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_set_status_flags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq_modify_status</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_clear_status_flags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq_modify_status</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">clr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_set_noprobe</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq_modify_status</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IRQ_NOPROBE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_set_probe</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq_modify_status</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">IRQ_NOPROBE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_set_nothread</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq_modify_status</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IRQ_NOTHREAD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_set_thread</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq_modify_status</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">IRQ_NOTHREAD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_set_nested_thread</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">bool</span> <span class="n">nest</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nest</span><span class="p">)</span>
		<span class="n">irq_set_status_flags</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">IRQ_NESTED_THREAD</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">irq_clear_status_flags</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">IRQ_NESTED_THREAD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_set_percpu_devid_flags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq_set_status_flags</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span>
			     <span class="n">IRQ_NOAUTOEN</span> <span class="o">|</span> <span class="n">IRQ_PER_CPU</span> <span class="o">|</span> <span class="n">IRQ_NOTHREAD</span> <span class="o">|</span>
			     <span class="n">IRQ_NOPROBE</span> <span class="o">|</span> <span class="n">IRQ_PER_CPU_DEVID</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Handle dynamic irq creation and destruction */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">create_irq_nr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_want</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">create_irq</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">destroy_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Dynamic irq helper functions. Obsolete. Use irq_alloc_desc* and</span>
<span class="cm"> * irq_free_desc instead.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dynamic_irq_cleanup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dynamic_irq_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dynamic_irq_cleanup</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Set/get chip/data for an IRQ: */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">irq_set_chip</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">irq_set_handler_data</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">irq_set_chip_data</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">irq_set_irq_type</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">irq_set_msi_desc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msi_desc</span> <span class="o">*</span><span class="n">entry</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">irq_get_irq_data</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="nf">irq_get_chip</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">irq_get_irq_data</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">d</span> <span class="o">?</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">chip</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="nf">irq_data_get_irq_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">irq_get_chip_data</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">irq_get_irq_data</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">d</span> <span class="o">?</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">chip_data</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">irq_data_get_irq_chip_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">chip_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">irq_get_handler_data</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">irq_get_irq_data</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">d</span> <span class="o">?</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">handler_data</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">irq_data_get_irq_handler_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">handler_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">msi_desc</span> <span class="o">*</span><span class="nf">irq_get_msi_desc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">irq_get_irq_data</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">d</span> <span class="o">?</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">msi_desc</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">msi_desc</span> <span class="o">*</span><span class="nf">irq_data_get_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">msi_desc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__irq_alloc_descs</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">);</span>

<span class="cm">/* use macros to avoid needing export.h for THIS_MODULE */</span>
<span class="cp">#define irq_alloc_descs(irq, from, cnt, node)	\</span>
<span class="cp">	__irq_alloc_descs(irq, from, cnt, node, THIS_MODULE)</span>

<span class="cp">#define irq_alloc_desc(node)			\</span>
<span class="cp">	irq_alloc_descs(-1, 0, 1, node)</span>

<span class="cp">#define irq_alloc_desc_at(at, node)		\</span>
<span class="cp">	irq_alloc_descs(at, at, 1, node)</span>

<span class="cp">#define irq_alloc_desc_from(from, node)		\</span>
<span class="cp">	irq_alloc_descs(-1, from, 1, node)</span>

<span class="kt">void</span> <span class="n">irq_free_descs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">irq_reserve_irqs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_free_desc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq_free_descs</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">irq_reserve_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">irq_reserve_irqs</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef irq_reg_writel</span>
<span class="cp"># define irq_reg_writel(val, addr)	writel(val, addr)</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef irq_reg_readl</span>
<span class="cp"># define irq_reg_readl(addr)		readl(addr)</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * struct irq_chip_regs - register offsets for struct irq_gci</span>
<span class="cm"> * @enable:	Enable register offset to reg_base</span>
<span class="cm"> * @disable:	Disable register offset to reg_base</span>
<span class="cm"> * @mask:	Mask register offset to reg_base</span>
<span class="cm"> * @ack:	Ack register offset to reg_base</span>
<span class="cm"> * @eoi:	Eoi register offset to reg_base</span>
<span class="cm"> * @type:	Type configuration register offset to reg_base</span>
<span class="cm"> * @polarity:	Polarity configuration register offset to reg_base</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">irq_chip_regs</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">enable</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">disable</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ack</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">eoi</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">polarity</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct irq_chip_type - Generic interrupt chip instance for a flow type</span>
<span class="cm"> * @chip:		The real interrupt chip which provides the callbacks</span>
<span class="cm"> * @regs:		Register offsets for this chip</span>
<span class="cm"> * @handler:		Flow handler associated with this chip</span>
<span class="cm"> * @type:		Chip can handle these flow types</span>
<span class="cm"> *</span>
<span class="cm"> * A irq_generic_chip can have several instances of irq_chip_type when</span>
<span class="cm"> * it requires different functions and register offsets for different</span>
<span class="cm"> * flow types.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">irq_chip_type</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_chip</span>		<span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_chip_regs</span>	<span class="n">regs</span><span class="p">;</span>
	<span class="n">irq_flow_handler_t</span>	<span class="n">handler</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct irq_chip_generic - Generic irq chip data structure</span>
<span class="cm"> * @lock:		Lock to protect register and cache data access</span>
<span class="cm"> * @reg_base:		Register base address (virtual)</span>
<span class="cm"> * @irq_base:		Interrupt base nr for this chip</span>
<span class="cm"> * @irq_cnt:		Number of interrupts handled by this chip</span>
<span class="cm"> * @mask_cache:		Cached mask register</span>
<span class="cm"> * @type_cache:		Cached type register</span>
<span class="cm"> * @polarity_cache:	Cached polarity register</span>
<span class="cm"> * @wake_enabled:	Interrupt can wakeup from suspend</span>
<span class="cm"> * @wake_active:	Interrupt is marked as an wakeup from suspend source</span>
<span class="cm"> * @num_ct:		Number of available irq_chip_type instances (usually 1)</span>
<span class="cm"> * @private:		Private data for non generic chip callbacks</span>
<span class="cm"> * @list:		List head for keeping track of instances</span>
<span class="cm"> * @chip_types:		Array of interrupt irq_chip_types</span>
<span class="cm"> *</span>
<span class="cm"> * Note, that irq_chip_generic can have multiple irq_chip_type</span>
<span class="cm"> * implementations which can be associated to a particular irq line of</span>
<span class="cm"> * an irq_chip_generic instance. That allows to share and protect</span>
<span class="cm"> * state in an irq_chip_generic instance when we need to implement</span>
<span class="cm"> * different flow mechanisms (level/edge) for it.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">irq_chip_generic</span> <span class="p">{</span>
	<span class="n">raw_spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">reg_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">irq_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">irq_cnt</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">mask_cache</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">type_cache</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">polarity_cache</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">wake_enabled</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">wake_active</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">num_ct</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_chip_type</span>	<span class="n">chip_types</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum irq_gc_flags - Initialization flags for generic irq chips</span>
<span class="cm"> * @IRQ_GC_INIT_MASK_CACHE:	Initialize the mask_cache by reading mask reg</span>
<span class="cm"> * @IRQ_GC_INIT_NESTED_LOCK:	Set the lock class of the irqs to nested for</span>
<span class="cm"> *				irq chips which need to call irq_set_wake() on</span>
<span class="cm"> *				the parent irq. Usually GPIO implementations</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">irq_gc_flags</span> <span class="p">{</span>
	<span class="n">IRQ_GC_INIT_MASK_CACHE</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IRQ_GC_INIT_NESTED_LOCK</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Generic chip callback functions */</span>
<span class="kt">void</span> <span class="n">irq_gc_noop</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">irq_gc_mask_disable_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">irq_gc_mask_set_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">irq_gc_mask_clr_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">irq_gc_unmask_enable_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">irq_gc_ack_set_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">irq_gc_ack_clr_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">irq_gc_mask_disable_reg_and_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">irq_gc_eoi</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">irq_gc_set_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">on</span><span class="p">);</span>

<span class="cm">/* Setup functions for irq_chip_generic */</span>
<span class="k">struct</span> <span class="n">irq_chip_generic</span> <span class="o">*</span>
<span class="n">irq_alloc_generic_chip</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_ct</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_base</span><span class="p">,</span>
		       <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg_base</span><span class="p">,</span> <span class="n">irq_flow_handler_t</span> <span class="n">handler</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">irq_setup_generic_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_chip_generic</span> <span class="o">*</span><span class="n">gc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msk</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">irq_gc_flags</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clr</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">set</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">irq_setup_alt_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">irq_remove_generic_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_chip_generic</span> <span class="o">*</span><span class="n">gc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msk</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">set</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">irq_chip_type</span> <span class="o">*</span><span class="nf">irq_data_get_chip_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_chip_type</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define IRQ_MSK(n) (u32)((n) &lt; 32 ? ((1 &lt;&lt; (n)) - 1) : UINT_MAX)</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_gc_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_chip_generic</span> <span class="o">*</span><span class="n">gc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_gc_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_chip_generic</span> <span class="o">*</span><span class="n">gc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_gc_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_chip_generic</span> <span class="o">*</span><span class="n">gc</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_gc_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_chip_generic</span> <span class="o">*</span><span class="n">gc</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_GENERIC_HARDIRQS */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_S390 */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_IRQ_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
