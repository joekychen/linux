<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › device.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>device.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * device.h - generic, centralized driver model</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2001-2003 Patrick Mochel &lt;mochel@osdl.org&gt;</span>
<span class="cm"> * Copyright (c) 2004-2009 Greg Kroah-Hartman &lt;gregkh@suse.de&gt;</span>
<span class="cm"> * Copyright (c) 2008-2009 Novell Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPLv2</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/driver-model/ for more information.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _DEVICE_H_</span>
<span class="cp">#define _DEVICE_H_</span>

<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/kobject.h&gt;</span>
<span class="cp">#include &lt;linux/klist.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/lockdep.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &lt;asm/device.h&gt;</span>

<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">device_private</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">device_driver</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">driver_private</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">class</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">subsys_private</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">bus_type</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">device_node</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">iommu_ops</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">bus_attribute</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">attribute</span>	<span class="n">attr</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define BUS_ATTR(_name, _mode, _show, _store)	\</span>
<span class="cp">struct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show, _store)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">bus_create_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">bus_attribute</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bus_remove_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bus_attribute</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct bus_type - The bus type of the device</span>
<span class="cm"> *</span>
<span class="cm"> * @name:	The name of the bus.</span>
<span class="cm"> * @dev_name:	Used for subsystems to enumerate devices like (&quot;foo%u&quot;, dev-&gt;id).</span>
<span class="cm"> * @dev_root:	Default device to use as the parent.</span>
<span class="cm"> * @bus_attrs:	Default attributes of the bus.</span>
<span class="cm"> * @dev_attrs:	Default attributes of the devices on the bus.</span>
<span class="cm"> * @drv_attrs:	Default attributes of the device drivers on the bus.</span>
<span class="cm"> * @match:	Called, perhaps multiple times, whenever a new device or driver</span>
<span class="cm"> *		is added for this bus. It should return a nonzero value if the</span>
<span class="cm"> *		given device can be handled by the given driver.</span>
<span class="cm"> * @uevent:	Called when a device is added, removed, or a few other things</span>
<span class="cm"> *		that generate uevents to add the environment variables.</span>
<span class="cm"> * @probe:	Called when a new device or driver add to this bus, and callback</span>
<span class="cm"> *		the specific driver&#39;s probe to initial the matched device.</span>
<span class="cm"> * @remove:	Called when a device removed from this bus.</span>
<span class="cm"> * @shutdown:	Called at shut-down time to quiesce the device.</span>
<span class="cm"> * @suspend:	Called when a device on this bus wants to go to sleep mode.</span>
<span class="cm"> * @resume:	Called to bring a device on this bus out of sleep mode.</span>
<span class="cm"> * @pm:		Power management operations of this bus, callback the specific</span>
<span class="cm"> *		device driver&#39;s pm-ops.</span>
<span class="cm"> * @iommu_ops:  IOMMU specific operations for this bus, used to attach IOMMU</span>
<span class="cm"> *              driver implementations to a bus and allow the driver to do</span>
<span class="cm"> *              bus-specific setup</span>
<span class="cm"> * @p:		The private data of the driver core, only the driver core can</span>
<span class="cm"> *		touch this.</span>
<span class="cm"> *</span>
<span class="cm"> * A bus is a channel between the processor and one or more devices. For the</span>
<span class="cm"> * purposes of the device model, all devices are connected via a bus, even if</span>
<span class="cm"> * it is an internal, virtual, &quot;platform&quot; bus. Buses can plug into each other.</span>
<span class="cm"> * A USB controller is usually a PCI device, for example. The device model</span>
<span class="cm"> * represents the actual connections between buses and the devices they control.</span>
<span class="cm"> * A bus is represented by the bus_type structure. It contains the name, the</span>
<span class="cm"> * default attributes, the bus&#39; methods, PM operations, and the driver core&#39;s</span>
<span class="cm"> * private data.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bus_type</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">dev_name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bus_attribute</span>	<span class="o">*</span><span class="n">bus_attrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_attribute</span>	<span class="o">*</span><span class="n">dev_attrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">driver_attribute</span>	<span class="o">*</span><span class="n">drv_attrs</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">uevent</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">iommu_ops</span> <span class="o">*</span><span class="n">iommu_ops</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">subsys_private</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* This is a #define to keep the compiler from merging different</span>
<span class="cm"> * instances of the __key variable */</span>
<span class="cp">#define bus_register(subsys)			\</span>
<span class="cp">({						\</span>
<span class="cp">	static struct lock_class_key __key;	\</span>
<span class="cp">	__bus_register(subsys, &amp;__key);	\</span>
<span class="cp">})</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">__bus_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bus_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">bus_rescan_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

<span class="cm">/* iterator helpers for buses */</span>
<span class="k">struct</span> <span class="n">subsys_dev_iter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist_iter</span>		<span class="n">ki</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">device_type</span>	<span class="o">*</span><span class="n">type</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">subsys_dev_iter_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">subsys_dev_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">subsys</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">subsys_dev_iter_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">subsys_dev_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">subsys_dev_iter_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">subsys_dev_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">bus_for_each_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">bus_find_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">bus_find_device_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">subsys_find_device_by_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">hint</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bus_for_each_drv</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">void</span> <span class="n">bus_sort_breadthfirst</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">b</span><span class="p">));</span>
<span class="cm">/*</span>
<span class="cm"> * Bus notifiers: Get notified of addition/removal of devices</span>
<span class="cm"> * and binding/unbinding of drivers to devices.</span>
<span class="cm"> * In the long run, it should be a replacement for the platform</span>
<span class="cm"> * notify hooks.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">notifier_block</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">bus_register_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">bus_unregister_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>

<span class="cm">/* All 4 notifers below get called with the target struct device *</span>
<span class="cm"> * as an argument. Note that those functions are likely to be called</span>
<span class="cm"> * with the device lock held in the core, so be careful.</span>
<span class="cm"> */</span>
<span class="cp">#define BUS_NOTIFY_ADD_DEVICE		0x00000001 </span><span class="cm">/* device added */</span><span class="cp"></span>
<span class="cp">#define BUS_NOTIFY_DEL_DEVICE		0x00000002 </span><span class="cm">/* device removed */</span><span class="cp"></span>
<span class="cp">#define BUS_NOTIFY_BIND_DRIVER		0x00000003 </span><span class="cm">/* driver about to be</span>
<span class="cm">						      bound */</span><span class="cp"></span>
<span class="cp">#define BUS_NOTIFY_BOUND_DRIVER		0x00000004 </span><span class="cm">/* driver bound to device */</span><span class="cp"></span>
<span class="cp">#define BUS_NOTIFY_UNBIND_DRIVER	0x00000005 </span><span class="cm">/* driver about to be</span>
<span class="cm">						      unbound */</span><span class="cp"></span>
<span class="cp">#define BUS_NOTIFY_UNBOUND_DRIVER	0x00000006 </span><span class="cm">/* driver is unbound</span>
<span class="cm">						      from the device */</span><span class="cp"></span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">bus_get_kset</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="n">bus_get_device_klist</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct device_driver - The basic device driver structure</span>
<span class="cm"> * @name:	Name of the device driver.</span>
<span class="cm"> * @bus:	The bus which the device of this driver belongs to.</span>
<span class="cm"> * @owner:	The module owner.</span>
<span class="cm"> * @mod_name:	Used for built-in modules.</span>
<span class="cm"> * @suppress_bind_attrs: Disables bind/unbind via sysfs.</span>
<span class="cm"> * @of_match_table: The open firmware table.</span>
<span class="cm"> * @probe:	Called to query the existence of a specific device,</span>
<span class="cm"> *		whether this driver can work with it, and bind the driver</span>
<span class="cm"> *		to a specific device.</span>
<span class="cm"> * @remove:	Called when the device is removed from the system to</span>
<span class="cm"> *		unbind a device from this driver.</span>
<span class="cm"> * @shutdown:	Called at shut-down time to quiesce the device.</span>
<span class="cm"> * @suspend:	Called to put the device to sleep mode. Usually to a</span>
<span class="cm"> *		low power state.</span>
<span class="cm"> * @resume:	Called to bring a device from sleep mode.</span>
<span class="cm"> * @groups:	Default attributes that get created by the driver core</span>
<span class="cm"> *		automatically.</span>
<span class="cm"> * @pm:		Power management operations of the device which matched</span>
<span class="cm"> *		this driver.</span>
<span class="cm"> * @p:		Driver core&#39;s private data, no one other than the driver</span>
<span class="cm"> *		core can touch this.</span>
<span class="cm"> *</span>
<span class="cm"> * The device driver-model tracks all of the drivers known to the system.</span>
<span class="cm"> * The main reason for this tracking is to enable the driver core to match</span>
<span class="cm"> * up drivers with new devices. Once drivers are known objects within the</span>
<span class="cm"> * system, however, a number of other things become possible. Device drivers</span>
<span class="cm"> * can export information and configuration variables that are independent</span>
<span class="cm"> * of any specific device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_driver</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bus_type</span>		<span class="o">*</span><span class="n">bus</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">module</span>		<span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">mod_name</span><span class="p">;</span>	<span class="cm">/* used for built-in modules */</span>

	<span class="n">bool</span> <span class="n">suppress_bind_attrs</span><span class="p">;</span>	<span class="cm">/* disables bind/unbind via sysfs */</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span>	<span class="o">*</span><span class="n">of_match_table</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">**</span><span class="n">groups</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">driver_private</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">driver_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">driver_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver_find</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">driver_probe_done</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wait_for_device_probe</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="cm">/* sysfs interface for exporting driver attributes */</span>

<span class="k">struct</span> <span class="n">driver_attribute</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define DRIVER_ATTR(_name, _mode, _show, _store)	\</span>
<span class="cp">struct driver_attribute driver_attr_##_name =		\</span>
<span class="cp">	__ATTR(_name, _mode, _show, _store)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">driver_create_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">driver_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">driver_remove_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">driver_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">driver_for_each_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
					       <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					       <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
							 <span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">driver_find_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>

<span class="cm">/**</span>
<span class="cm"> * struct subsys_interface - interfaces to device functions</span>
<span class="cm"> * @name:       name of the device function</span>
<span class="cm"> * @subsys:     subsytem of the devices to attach to</span>
<span class="cm"> * @node:       the list of functions registered at the subsystem</span>
<span class="cm"> * @add_dev:    device hookup to device function handler</span>
<span class="cm"> * @remove_dev: device hookup to device function handler</span>
<span class="cm"> *</span>
<span class="cm"> * Simple interfaces attached to a subsystem. Multiple interfaces can</span>
<span class="cm"> * attach to a subsystem and its devices. Unlike drivers, they do not</span>
<span class="cm"> * exclusively claim or control devices. Interfaces usually represent</span>
<span class="cm"> * a specific functionality of a subsystem/class of devices.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">subsys_interface</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">subsys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">add_dev</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">subsys_interface</span> <span class="o">*</span><span class="n">sif</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remove_dev</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">subsys_interface</span> <span class="o">*</span><span class="n">sif</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">subsys_interface_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">subsys_interface</span> <span class="o">*</span><span class="n">sif</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">subsys_interface_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">subsys_interface</span> <span class="o">*</span><span class="n">sif</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">subsys_system_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">subsys</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">**</span><span class="n">groups</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct class - device classes</span>
<span class="cm"> * @name:	Name of the class.</span>
<span class="cm"> * @owner:	The module owner.</span>
<span class="cm"> * @class_attrs: Default attributes of this class.</span>
<span class="cm"> * @dev_attrs:	Default attributes of the devices belong to the class.</span>
<span class="cm"> * @dev_bin_attrs: Default binary attributes of the devices belong to the class.</span>
<span class="cm"> * @dev_kobj:	The kobject that represents this class and links it into the hierarchy.</span>
<span class="cm"> * @dev_uevent:	Called when a device is added, removed from this class, or a</span>
<span class="cm"> *		few other things that generate uevents to add the environment</span>
<span class="cm"> *		variables.</span>
<span class="cm"> * @devnode:	Callback to provide the devtmpfs.</span>
<span class="cm"> * @class_release: Called to release this class.</span>
<span class="cm"> * @dev_release: Called to release the device.</span>
<span class="cm"> * @suspend:	Used to put the device to sleep mode, usually to a low power</span>
<span class="cm"> *		state.</span>
<span class="cm"> * @resume:	Used to bring the device from the sleep mode.</span>
<span class="cm"> * @ns_type:	Callbacks so sysfs can detemine namespaces.</span>
<span class="cm"> * @namespace:	Namespace of the device belongs to this class.</span>
<span class="cm"> * @pm:		The default device power management operations of this class.</span>
<span class="cm"> * @p:		The private data of the driver core, no one other than the</span>
<span class="cm"> *		driver core can touch this.</span>
<span class="cm"> *</span>
<span class="cm"> * A class is a higher-level view of a device that abstracts out low-level</span>
<span class="cm"> * implementation details. Drivers may see a SCSI disk or an ATA disk, but,</span>
<span class="cm"> * at the class level, they are all simply disks. Classes allow user space</span>
<span class="cm"> * to work with devices based on what they do, rather than how they are</span>
<span class="cm"> * connected or how they work.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">class</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span>		<span class="o">*</span><span class="n">owner</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">class_attribute</span>		<span class="o">*</span><span class="n">class_attrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_attribute</span>		<span class="o">*</span><span class="n">dev_attrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bin_attribute</span>		<span class="o">*</span><span class="n">dev_bin_attrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span>			<span class="o">*</span><span class="n">dev_kobj</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dev_uevent</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">devnode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">umode_t</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">class_release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dev_release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">kobj_ns_type_operations</span> <span class="o">*</span><span class="n">ns_type</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">namespace</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">subsys_private</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">class_dev_iter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist_iter</span>		<span class="n">ki</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">device_type</span>	<span class="o">*</span><span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">sysfs_dev_block_kobj</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">sysfs_dev_char_kobj</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">__class_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">class_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">);</span>

<span class="cm">/* This is a #define to keep the compiler from merging different</span>
<span class="cm"> * instances of the __key variable */</span>
<span class="cp">#define class_register(class)			\</span>
<span class="cp">({						\</span>
<span class="cp">	static struct lock_class_key __key;	\</span>
<span class="cp">	__class_register(class, &amp;__key);	\</span>
<span class="cp">})</span>

<span class="k">struct</span> <span class="n">class_compat</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">class_compat</span> <span class="o">*</span><span class="n">class_compat_register</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">class_compat_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">class_compat</span> <span class="o">*</span><span class="n">cls</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">class_compat_create_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">class_compat</span> <span class="o">*</span><span class="n">cls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device_link</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">class_compat_remove_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">class_compat</span> <span class="o">*</span><span class="n">cls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device_link</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">class_dev_iter_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">class_dev_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">class_dev_iter_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">class_dev_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">class_dev_iter_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">class_dev_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">class_for_each_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">class_find_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">class_attribute</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span> <span class="k">struct</span> <span class="n">class_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span> <span class="k">struct</span> <span class="n">class_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">namespace</span><span class="p">)(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">class_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define CLASS_ATTR(_name, _mode, _show, _store)			\</span>
<span class="cp">struct class_attribute class_attr_##_name = __ATTR(_name, _mode, _show, _store)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">class_create_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">class_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">class_remove_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">class_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="cm">/* Simple class attribute that is just a static string */</span>

<span class="k">struct</span> <span class="n">class_attribute_string</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">class_attribute</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Currently read-only only */</span>
<span class="cp">#define _CLASS_ATTR_STRING(_name, _mode, _str) \</span>
<span class="cp">	{ __ATTR(_name, _mode, show_class_attr_string, NULL), _str }</span>
<span class="cp">#define CLASS_ATTR_STRING(_name, _mode, _str) \</span>
<span class="cp">	struct class_attribute_string class_attr_##_name = \</span>
<span class="cp">		_CLASS_ATTR_STRING(_name, _mode, _str)</span>

<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">show_class_attr_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span> <span class="k">struct</span> <span class="n">class_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
                        <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">class_interface</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">class</span>		<span class="o">*</span><span class="n">class</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">add_dev</span><span class="p">)</span>		<span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">class_interface</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove_dev</span><span class="p">)</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">class_interface</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">class_interface_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">class_interface</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">class_interface_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">class_interface</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">class</span> <span class="o">*</span> <span class="n">__must_check</span> <span class="n">__class_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
						  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">class_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">cls</span><span class="p">);</span>

<span class="cm">/* This is a #define to keep the compiler from merging different</span>
<span class="cm"> * instances of the __key variable */</span>
<span class="cp">#define class_create(owner, name)		\</span>
<span class="cp">({						\</span>
<span class="cp">	static struct lock_class_key __key;	\</span>
<span class="cp">	__class_create(owner, name, &amp;__key);	\</span>
<span class="cp">})</span>

<span class="cm">/*</span>
<span class="cm"> * The type of device, &quot;struct device&quot; is embedded in. A class</span>
<span class="cm"> * or bus can contain devices of different types</span>
<span class="cm"> * like &quot;partitions&quot; and &quot;disks&quot;, &quot;mouse&quot; and &quot;event&quot;.</span>
<span class="cm"> * This identifies the device type and carries type-specific</span>
<span class="cm"> * information, equivalent to the kobj_type of a kobject.</span>
<span class="cm"> * If &quot;name&quot; is specified, the uevent will contain it in</span>
<span class="cm"> * the DEVTYPE variable.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_type</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">**</span><span class="n">groups</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">uevent</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">devnode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">umode_t</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* interface for exporting device attributes */</span>
<span class="k">struct</span> <span class="n">device_attribute</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">attribute</span>	<span class="n">attr</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dev_ext_attribute</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">var</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">ssize_t</span> <span class="n">device_show_ulong</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">device_store_ulong</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">device_show_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">device_store_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>

<span class="cp">#define DEVICE_ATTR(_name, _mode, _show, _store) \</span>
<span class="cp">	struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)</span>
<span class="cp">#define DEVICE_ULONG_ATTR(_name, _mode, _var) \</span>
<span class="cp">	struct dev_ext_attribute dev_attr_##_name = \</span>
<span class="cp">		{ __ATTR(_name, _mode, device_show_ulong, device_store_ulong), &amp;(_var) }</span>
<span class="cp">#define DEVICE_INT_ATTR(_name, _mode, _var) \</span>
<span class="cp">	struct dev_ext_attribute dev_attr_##_name = \</span>
<span class="cp">		{ __ATTR(_name, _mode, device_show_int, device_store_int), &amp;(_var) }</span>
<span class="cp">#define DEVICE_ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store) \</span>
<span class="cp">	struct device_attribute dev_attr_##_name =		\</span>
<span class="cp">		__ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">device_create_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">entry</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">device_remove_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">device_create_bin_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">device_remove_bin_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">device_schedule_callback_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">),</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">);</span>

<span class="cm">/* This is a macro to avoid include problems with THIS_MODULE */</span>
<span class="cp">#define device_schedule_callback(dev, func)			\</span>
<span class="cp">	device_schedule_callback_owner(dev, func, THIS_MODULE)</span>

<span class="cm">/* device resource management */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dr_release_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dr_match_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">match_data</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_DEVRES</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">__devres_alloc</span><span class="p">(</span><span class="n">dr_release_t</span> <span class="n">release</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#define devres_alloc(release, size, gfp) \</span>
<span class="cp">	__devres_alloc(release, size, gfp, #release)</span>
<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">devres_alloc</span><span class="p">(</span><span class="n">dr_release_t</span> <span class="n">release</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">devres_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">devres_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">devres_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dr_release_t</span> <span class="n">release</span><span class="p">,</span>
			 <span class="n">dr_match_t</span> <span class="n">match</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">match_data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">devres_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">new_res</span><span class="p">,</span>
			<span class="n">dr_match_t</span> <span class="n">match</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">match_data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">devres_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dr_release_t</span> <span class="n">release</span><span class="p">,</span>
			   <span class="n">dr_match_t</span> <span class="n">match</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">match_data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">devres_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dr_release_t</span> <span class="n">release</span><span class="p">,</span>
			  <span class="n">dr_match_t</span> <span class="n">match</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">match_data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">devres_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dr_release_t</span> <span class="n">release</span><span class="p">,</span>
			  <span class="n">dr_match_t</span> <span class="n">match</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">match_data</span><span class="p">);</span>

<span class="cm">/* devres group */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">__must_check</span> <span class="n">devres_open_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span>
					     <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">devres_close_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">devres_remove_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">devres_release_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>

<span class="cm">/* managed kzalloc/kfree for device drivers, no kmalloc, always use kzalloc */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">devm_kzalloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">devm_kfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">devm_request_and_ioremap</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">device_dma_parameters</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * a low level driver may set these to teach IOMMU code about</span>
<span class="cm">	 * sg limitations.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_segment_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">segment_boundary_mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct device - The basic device structure</span>
<span class="cm"> * @parent:	The device&#39;s &quot;parent&quot; device, the device to which it is attached.</span>
<span class="cm"> * 		In most cases, a parent device is some sort of bus or host</span>
<span class="cm"> * 		controller. If parent is NULL, the device, is a top-level device,</span>
<span class="cm"> * 		which is not usually what you want.</span>
<span class="cm"> * @p:		Holds the private data of the driver core portions of the device.</span>
<span class="cm"> * 		See the comment of the struct device_private for detail.</span>
<span class="cm"> * @kobj:	A top-level, abstract class from which other classes are derived.</span>
<span class="cm"> * @init_name:	Initial name of the device.</span>
<span class="cm"> * @type:	The type of device.</span>
<span class="cm"> * 		This identifies the device type and carries type-specific</span>
<span class="cm"> * 		information.</span>
<span class="cm"> * @mutex:	Mutex to synchronize calls to its driver.</span>
<span class="cm"> * @bus:	Type of bus device is on.</span>
<span class="cm"> * @driver:	Which driver has allocated this</span>
<span class="cm"> * @platform_data: Platform data specific to the device.</span>
<span class="cm"> * 		Example: For devices on custom boards, as typical of embedded</span>
<span class="cm"> * 		and SOC based hardware, Linux often uses platform_data to point</span>
<span class="cm"> * 		to board-specific structures describing devices and how they</span>
<span class="cm"> * 		are wired.  That can include what ports are available, chip</span>
<span class="cm"> * 		variants, which GPIO pins act in what additional roles, and so</span>
<span class="cm"> * 		on.  This shrinks the &quot;Board Support Packages&quot; (BSPs) and</span>
<span class="cm"> * 		minimizes board-specific #ifdefs in drivers.</span>
<span class="cm"> * @power:	For device power management.</span>
<span class="cm"> * 		See Documentation/power/devices.txt for details.</span>
<span class="cm"> * @pm_domain:	Provide callbacks that are executed during system suspend,</span>
<span class="cm"> * 		hibernation, system resume and during runtime PM transitions</span>
<span class="cm"> * 		along with subsystem-level and driver-level callbacks.</span>
<span class="cm"> * @numa_node:	NUMA node this device is close to.</span>
<span class="cm"> * @dma_mask:	Dma mask (if dma&#39;ble device).</span>
<span class="cm"> * @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all</span>
<span class="cm"> * 		hardware supports 64-bit addresses for consistent allocations</span>
<span class="cm"> * 		such descriptors.</span>
<span class="cm"> * @dma_parms:	A low level driver may set these to teach IOMMU code about</span>
<span class="cm"> * 		segment limitations.</span>
<span class="cm"> * @dma_pools:	Dma pools (if dma&#39;ble device).</span>
<span class="cm"> * @dma_mem:	Internal for coherent mem override.</span>
<span class="cm"> * @archdata:	For arch-specific additions.</span>
<span class="cm"> * @of_node:	Associated device tree node.</span>
<span class="cm"> * @devt:	For creating the sysfs &quot;dev&quot;.</span>
<span class="cm"> * @id:		device instance</span>
<span class="cm"> * @devres_lock: Spinlock to protect the resource of the device.</span>
<span class="cm"> * @devres_head: The resources list of the device.</span>
<span class="cm"> * @knode_class: The node used to add the device to the class list.</span>
<span class="cm"> * @class:	The class of the device.</span>
<span class="cm"> * @groups:	Optional attribute groups.</span>
<span class="cm"> * @release:	Callback to free the device after all references have</span>
<span class="cm"> * 		gone away. This should be set by the allocator of the</span>
<span class="cm"> * 		device (i.e. the bus driver that discovered the device).</span>
<span class="cm"> *</span>
<span class="cm"> * At the lowest level, every device in a Linux system is represented by an</span>
<span class="cm"> * instance of struct device. The device structure contains the information</span>
<span class="cm"> * that the device model core needs to model the system. Most subsystems,</span>
<span class="cm"> * however, track additional information about the devices they host. As a</span>
<span class="cm"> * result, it is rare for devices to be represented by bare device structures;</span>
<span class="cm"> * instead, that structure, like kobject structures, is usually embedded within</span>
<span class="cm"> * a higher-level representation of the device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device_private</span>	<span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">init_name</span><span class="p">;</span> <span class="cm">/* initial name of the device */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">mutex</span><span class="p">;</span>	<span class="cm">/* mutex to synchronize calls to</span>
<span class="cm">					 * its driver.</span>
<span class="cm">					 */</span>

	<span class="k">struct</span> <span class="n">bus_type</span>	<span class="o">*</span><span class="n">bus</span><span class="p">;</span>		<span class="cm">/* type of bus device is on */</span>
	<span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>	<span class="cm">/* which driver has allocated this</span>
<span class="cm">					   device */</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">platform_data</span><span class="p">;</span>	<span class="cm">/* Platform specific data, device</span>
<span class="cm">					   core doesn&#39;t touch it */</span>
	<span class="k">struct</span> <span class="n">dev_pm_info</span>	<span class="n">power</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_pm_domain</span>	<span class="o">*</span><span class="n">pm_domain</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="kt">int</span>		<span class="n">numa_node</span><span class="p">;</span>	<span class="cm">/* NUMA node this device is close to */</span>
<span class="cp">#endif</span>
	<span class="n">u64</span>		<span class="o">*</span><span class="n">dma_mask</span><span class="p">;</span>	<span class="cm">/* dma mask (if dma&#39;able device) */</span>
	<span class="n">u64</span>		<span class="n">coherent_dma_mask</span><span class="p">;</span><span class="cm">/* Like dma_mask, but for</span>
<span class="cm">					     alloc_coherent mappings as</span>
<span class="cm">					     not all hardware supports</span>
<span class="cm">					     64 bit addresses for consistent</span>
<span class="cm">					     allocations such descriptors. */</span>

	<span class="k">struct</span> <span class="n">device_dma_parameters</span> <span class="o">*</span><span class="n">dma_parms</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">dma_pools</span><span class="p">;</span>	<span class="cm">/* dma pools (if dma&#39;ble) */</span>

	<span class="k">struct</span> <span class="n">dma_coherent_mem</span>	<span class="o">*</span><span class="n">dma_mem</span><span class="p">;</span> <span class="cm">/* internal for coherent mem</span>
<span class="cm">					     override */</span>
<span class="cp">#ifdef CONFIG_CMA</span>
	<span class="k">struct</span> <span class="n">cma</span> <span class="o">*</span><span class="n">cma_area</span><span class="p">;</span>		<span class="cm">/* contiguous memory area for dma</span>
<span class="cm">					   allocations */</span>
<span class="cp">#endif</span>
	<span class="cm">/* arch specific additions */</span>
	<span class="k">struct</span> <span class="n">dev_archdata</span>	<span class="n">archdata</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device_node</span>	<span class="o">*</span><span class="n">of_node</span><span class="p">;</span> <span class="cm">/* associated device tree node */</span>

	<span class="n">dev_t</span>			<span class="n">devt</span><span class="p">;</span>	<span class="cm">/* dev_t, creates the sysfs &quot;dev&quot; */</span>
	<span class="n">u32</span>			<span class="n">id</span><span class="p">;</span>	<span class="cm">/* device instance */</span>

	<span class="n">spinlock_t</span>		<span class="n">devres_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">devres_head</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">klist_node</span>	<span class="n">knode_class</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">class</span>		<span class="o">*</span><span class="n">class</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">**</span><span class="n">groups</span><span class="p">;</span>	<span class="cm">/* optional groups */</span>

	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* Get the wakeup routines, which depend on struct device */</span>
<span class="cp">#include &lt;linux/pm_wakeup.h&gt;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">dev_name</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Use the init name until the kobject becomes available */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">init_name</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">init_name</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">kobject_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dev_set_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="p">...);</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dev_to_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">numa_node</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_dev_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">numa_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dev_to_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_dev_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pm_subsys_data</span> <span class="o">*</span><span class="nf">dev_to_psd</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">subsys_data</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">dev_get_uevent_suppress</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">uevent_suppress</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dev_set_uevent_suppress</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">uevent_suppress</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">device_is_registered</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">state_in_sysfs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">device_enable_async_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">is_prepared</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">async_suspend</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">device_disable_async_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">is_prepared</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">async_suspend</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">device_async_suspend_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">async_suspend</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pm_suspend_ignore_children</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">ignore_children</span> <span class="o">=</span> <span class="n">enable</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">device_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">device_trylock</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">device_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">driver_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * High level routines for use by the bus drivers</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">device_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">device_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">device_initialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">device_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">device_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">device_for_each_child</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device_find_child</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">device_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">new_name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">device_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">new_parent</span><span class="p">,</span>
		       <span class="k">enum</span> <span class="n">dpm_order</span> <span class="n">dpm_order</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">device_get_devnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="n">umode_t</span> <span class="o">*</span><span class="n">mode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">tmp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_get_drvdata</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_set_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Root device objects for grouping under /sys/devices</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">__root_device_register</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This is a macro to avoid include problems with THIS_MODULE,</span>
<span class="cm"> * just as per what is done for device_schedule_callback() above.</span>
<span class="cm"> */</span>
<span class="cp">#define root_device_register(name) \</span>
<span class="cp">	__root_device_register(name, THIS_MODULE)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">root_device_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">dev_get_platdata</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">platform_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Manual binding of a device to driver. See drivers/base/bus.c</span>
<span class="cm"> * for information on use.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">device_bind_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">device_release_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">__must_check</span> <span class="n">device_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">driver_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">device_reprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Easy functions for dynamically creating devices on the fly</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device_create_vargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">cls</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
					  <span class="n">dev_t</span> <span class="n">devt</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="o">*</span><span class="n">drvdata</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span>
					  <span class="kt">va_list</span> <span class="n">vargs</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">cls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
			     <span class="n">dev_t</span> <span class="n">devt</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">drvdata</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">device_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">cls</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">devt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Platform &quot;fixup&quot; functions - allow the platform to have their say</span>
<span class="cm"> * about devices and actions that the general device layer doesn&#39;t</span>
<span class="cm"> * know about.</span>
<span class="cm"> */</span>
<span class="cm">/* Notify platform of device discovery */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">platform_notify</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">platform_notify_remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * get_device - atomically increment the reference count for the device.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">get_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">put_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">wait_for_device_probe</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEVTMPFS</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">devtmpfs_create_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">devtmpfs_delete_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">devtmpfs_mount</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mntdir</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">devtmpfs_create_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">devtmpfs_delete_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">devtmpfs_mount</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mountpoint</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* drivers/base/power/shutdown.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">device_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* debugging and troubleshooting/diagnostic helpers. */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_driver_string</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>


<span class="cp">#ifdef CONFIG_PRINTK</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__dev_printk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">va_format</span> <span class="o">*</span><span class="n">vaf</span><span class="p">);</span>
<span class="k">extern</span> <span class="nf">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dev_printk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
	<span class="p">;</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dev_emerg</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dev_alert</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dev_crit</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dev_err</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dev_warn</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dev_notice</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">_dev_info</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__dev_printk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">va_format</span> <span class="o">*</span><span class="n">vaf</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="nf">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dev_printk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="nf">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dev_emerg</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="nf">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dev_crit</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="nf">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dev_alert</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="nf">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dev_err</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="nf">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dev_warn</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="nf">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dev_notice</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="nf">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">_dev_info</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#endif</span>

<span class="cp">#define dev_level_ratelimited(dev_level, dev, fmt, ...)			\</span>
<span class="cp">do {									\</span>
<span class="cp">	static DEFINE_RATELIMIT_STATE(_rs,				\</span>
<span class="cp">				      DEFAULT_RATELIMIT_INTERVAL,	\</span>
<span class="cp">				      DEFAULT_RATELIMIT_BURST);		\</span>
<span class="cp">	if (__ratelimit(&amp;_rs))						\</span>
<span class="cp">		dev_level(dev, fmt, ##__VA_ARGS__);			\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define dev_emerg_ratelimited(dev, fmt, ...)				\</span>
<span class="cp">	dev_level_ratelimited(dev_emerg, dev, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define dev_alert_ratelimited(dev, fmt, ...)				\</span>
<span class="cp">	dev_level_ratelimited(dev_alert, dev, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define dev_crit_ratelimited(dev, fmt, ...)				\</span>
<span class="cp">	dev_level_ratelimited(dev_crit, dev, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define dev_err_ratelimited(dev, fmt, ...)				\</span>
<span class="cp">	dev_level_ratelimited(dev_err, dev, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define dev_warn_ratelimited(dev, fmt, ...)				\</span>
<span class="cp">	dev_level_ratelimited(dev_warn, dev, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define dev_notice_ratelimited(dev, fmt, ...)				\</span>
<span class="cp">	dev_level_ratelimited(dev_notice, dev, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define dev_info_ratelimited(dev, fmt, ...)				\</span>
<span class="cp">	dev_level_ratelimited(dev_info, dev, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define dev_dbg_ratelimited(dev, fmt, ...)				\</span>
<span class="cp">	dev_level_ratelimited(dev_dbg, dev, fmt, ##__VA_ARGS__)</span>

<span class="cm">/*</span>
<span class="cm"> * Stupid hackaround for existing uses of non-printk uses dev_info</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the definition of dev_info below is actually _dev_info</span>
<span class="cm"> * and a macro is used to avoid redefining dev_info</span>
<span class="cm"> */</span>

<span class="cp">#define dev_info(dev, fmt, arg...) _dev_info(dev, fmt, ##arg)</span>

<span class="cp">#if defined(CONFIG_DYNAMIC_DEBUG)</span>
<span class="cp">#define dev_dbg(dev, format, ...)		     \</span>
<span class="cp">do {						     \</span>
<span class="cp">	dynamic_dev_dbg(dev, format, ##__VA_ARGS__); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#elif defined(DEBUG)</span>
<span class="cp">#define dev_dbg(dev, format, arg...)		\</span>
<span class="cp">	dev_printk(KERN_DEBUG, dev, format, ##arg)</span>
<span class="cp">#else</span>
<span class="cp">#define dev_dbg(dev, format, arg...)				\</span>
<span class="cp">({								\</span>
<span class="cp">	if (0)							\</span>
<span class="cp">		dev_printk(KERN_DEBUG, dev, format, ##arg);	\</span>
<span class="cp">	0;							\</span>
<span class="cp">})</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef VERBOSE_DEBUG</span>
<span class="cp">#define dev_vdbg	dev_dbg</span>
<span class="cp">#else</span>
<span class="cp">#define dev_vdbg(dev, format, arg...)				\</span>
<span class="cp">({								\</span>
<span class="cp">	if (0)							\</span>
<span class="cp">		dev_printk(KERN_DEBUG, dev, format, ##arg);	\</span>
<span class="cp">	0;							\</span>
<span class="cp">})</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * dev_WARN*() acts like dev_printk(), but with the key difference</span>
<span class="cm"> * of using a WARN/WARN_ON to get the message out, including the</span>
<span class="cm"> * file/line information and a backtrace.</span>
<span class="cm"> */</span>
<span class="cp">#define dev_WARN(dev, format, arg...) \</span>
<span class="cp">	WARN(1, &quot;Device: %s\n&quot; format, dev_driver_string(dev), ## arg);</span>

<span class="cp">#define dev_WARN_ONCE(dev, condition, format, arg...) \</span>
<span class="cp">	WARN_ONCE(condition, &quot;Device %s\n&quot; format, \</span>
<span class="cp">			dev_driver_string(dev), ## arg)</span>

<span class="cm">/* Create alias, so I can be autoloaded. */</span>
<span class="cp">#define MODULE_ALIAS_CHARDEV(major,minor) \</span>
<span class="cp">	MODULE_ALIAS(&quot;char-major-&quot; __stringify(major) &quot;-&quot; __stringify(minor))</span>
<span class="cp">#define MODULE_ALIAS_CHARDEV_MAJOR(major) \</span>
<span class="cp">	MODULE_ALIAS(&quot;char-major-&quot; __stringify(major) &quot;-*&quot;)</span>

<span class="cp">#ifdef CONFIG_SYSFS_DEPRECATED</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">sysfs_deprecated</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#define sysfs_deprecated 0</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * module_driver() - Helper macro for drivers that don&#39;t do anything</span>
<span class="cm"> * special in module init/exit. This eliminates a lot of boilerplate.</span>
<span class="cm"> * Each module may only use this macro once, and calling it replaces</span>
<span class="cm"> * module_init() and module_exit().</span>
<span class="cm"> *</span>
<span class="cm"> * @__driver: driver name</span>
<span class="cm"> * @__register: register function for this driver type</span>
<span class="cm"> * @__unregister: unregister function for this driver type</span>
<span class="cm"> * @...: Additional arguments to be passed to __register and __unregister.</span>
<span class="cm"> *</span>
<span class="cm"> * Use this macro to construct bus specific macros for registering</span>
<span class="cm"> * drivers, and do not use it on its own.</span>
<span class="cm"> */</span>
<span class="cp">#define module_driver(__driver, __register, __unregister, ...) \</span>
<span class="cp">static int __init __driver##_init(void) \</span>
<span class="cp">{ \</span>
<span class="cp">	return __register(&amp;(__driver) , ##__VA_ARGS__); \</span>
<span class="cp">} \</span>
<span class="cp">module_init(__driver##_init); \</span>
<span class="cp">static void __exit __driver##_exit(void) \</span>
<span class="cp">{ \</span>
<span class="cp">	__unregister(&amp;(__driver) , ##__VA_ARGS__); \</span>
<span class="cp">} \</span>
<span class="cp">module_exit(__driver##_exit);</span>

<span class="cp">#endif </span><span class="cm">/* _DEVICE_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
