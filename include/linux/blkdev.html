<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › blkdev.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>blkdev.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_BLKDEV_H</span>
<span class="cp">#define _LINUX_BLKDEV_H</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>

<span class="cp">#ifdef CONFIG_BLOCK</span>

<span class="cp">#include &lt;linux/major.h&gt;</span>
<span class="cp">#include &lt;linux/genhd.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/stringify.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/bsg.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>

<span class="cp">#include &lt;asm/scatterlist.h&gt;</span>

<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">scsi_ioctl_command</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">request_queue</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">elevator_queue</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">request_pm_state</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">blk_trace</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">request</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sg_io_hdr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">bsg_job</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">blkcg_gq</span><span class="p">;</span>

<span class="cp">#define BLKDEV_MIN_RQ	4</span>
<span class="cp">#define BLKDEV_MAX_RQ	128	</span><span class="cm">/* Default maximum */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Maximum number of blkcg policies allowed to be registered concurrently.</span>
<span class="cm"> * Defined here to simplify include dependency.</span>
<span class="cm"> */</span>
<span class="cp">#define BLKCG_MAX_POLS		2</span>

<span class="k">struct</span> <span class="n">request</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">rq_end_io_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">request_list</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * count[], starved[], and wait[] are indexed by</span>
<span class="cm">	 * BLK_RW_SYNC/BLK_RW_ASYNC</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">starved</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">elvpriv</span><span class="p">;</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">rq_pool</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wait</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * request command types</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">rq_cmd_type_bits</span> <span class="p">{</span>
	<span class="n">REQ_TYPE_FS</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* fs request */</span>
	<span class="n">REQ_TYPE_BLOCK_PC</span><span class="p">,</span>		<span class="cm">/* scsi command */</span>
	<span class="n">REQ_TYPE_SENSE</span><span class="p">,</span>			<span class="cm">/* sense request */</span>
	<span class="n">REQ_TYPE_PM_SUSPEND</span><span class="p">,</span>		<span class="cm">/* suspend request */</span>
	<span class="n">REQ_TYPE_PM_RESUME</span><span class="p">,</span>		<span class="cm">/* resume request */</span>
	<span class="n">REQ_TYPE_PM_SHUTDOWN</span><span class="p">,</span>		<span class="cm">/* shutdown request */</span>
	<span class="n">REQ_TYPE_SPECIAL</span><span class="p">,</span>		<span class="cm">/* driver defined type */</span>
	<span class="cm">/*</span>
<span class="cm">	 * for ATA/ATAPI devices. this really doesn&#39;t belong here, ide should</span>
<span class="cm">	 * use REQ_TYPE_SPECIAL and use rq-&gt;cmd[0] with the range of driver</span>
<span class="cm">	 * private REQ_LB opcodes to differentiate what type of request this is</span>
<span class="cm">	 */</span>
	<span class="n">REQ_TYPE_ATA_TASKFILE</span><span class="p">,</span>
	<span class="n">REQ_TYPE_ATA_PC</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define BLK_MAX_CDB	16</span>

<span class="cm">/*</span>
<span class="cm"> * try to put the fields that are referenced together in the same cacheline.</span>
<span class="cm"> * if you modify this structure, be sure to check block/blk-core.c:blk_rq_init()</span>
<span class="cm"> * as well!</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">queuelist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">call_single_data</span> <span class="n">csd</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd_flags</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">rq_cmd_type_bits</span> <span class="n">cmd_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">atomic_flags</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* the following two fields are internal, NEVER access directly */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__data_len</span><span class="p">;</span>	<span class="cm">/* total data len */</span>
	<span class="n">sector_t</span> <span class="n">__sector</span><span class="p">;</span>		<span class="cm">/* sector cursor */</span>

	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">biotail</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">hash</span><span class="p">;</span>	<span class="cm">/* merge hash */</span>
	<span class="cm">/*</span>
<span class="cm">	 * The rb_node is only used inside the io scheduler, requests</span>
<span class="cm">	 * are pruned when moved to the dispatch queue. So let the</span>
<span class="cm">	 * completion_data share space with the rb_node.</span>
<span class="cm">	 */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb_node</span><span class="p">;</span>	<span class="cm">/* sort/lookup */</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">completion_data</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * Three pointers are available for the IO schedulers, if they need</span>
<span class="cm">	 * more they have to dynamically allocate it.  Flush requests are</span>
<span class="cm">	 * never put on the IO scheduler. So let the flush fields share</span>
<span class="cm">	 * space with the elevator data.</span>
<span class="cm">	 */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">io_cq</span>		<span class="o">*</span><span class="n">icq</span><span class="p">;</span>
			<span class="kt">void</span>			<span class="o">*</span><span class="n">priv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">elv</span><span class="p">;</span>

		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">seq</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
			<span class="n">rq_end_io_fn</span>		<span class="o">*</span><span class="n">saved_end_io</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">flush</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">rq_disk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_time</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_BLK_CGROUP</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">start_time_ns</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">io_start_time_ns</span><span class="p">;</span>    <span class="cm">/* when passed to hardware */</span>
<span class="cp">#endif</span>
	<span class="cm">/* Number of scatter-gather DMA addr+len pairs after</span>
<span class="cm">	 * physical address coalescing is performed.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">nr_phys_segments</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_BLK_DEV_INTEGRITY)</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">nr_integrity_segments</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ioprio</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">ref_count</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">special</span><span class="p">;</span>		<span class="cm">/* opaque pointer available for LLD use */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>		<span class="cm">/* kaddr of the current segment if available */</span>

	<span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">errors</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * when request is used as a packet command carrier</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__cmd</span><span class="p">[</span><span class="n">BLK_MAX_CDB</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cmd_len</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">extra_len</span><span class="p">;</span>	<span class="cm">/* length of alignment and padding */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sense_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resid_len</span><span class="p">;</span>	<span class="cm">/* residual count */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">sense</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">timeout_list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * completion callback.</span>
<span class="cm">	 */</span>
	<span class="n">rq_end_io_fn</span> <span class="o">*</span><span class="n">end_io</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">end_io_data</span><span class="p">;</span>

	<span class="cm">/* for bidi */</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">next_rq</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">req_get_ioprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">ioprio</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * State information carried for REQ_TYPE_PM_SUSPEND and REQ_TYPE_PM_RESUME</span>
<span class="cm"> * requests. Some step values could eventually be made generic.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">request_pm_state</span>
<span class="p">{</span>
	<span class="cm">/* PM state machine step value, currently driver specific */</span>
	<span class="kt">int</span>	<span class="n">pm_step</span><span class="p">;</span>
	<span class="cm">/* requested PM state value (S1, S2, S3, S4, ...) */</span>
	<span class="n">u32</span>	<span class="n">pm_state</span><span class="p">;</span>
	<span class="kt">void</span><span class="o">*</span>	<span class="n">data</span><span class="p">;</span>		<span class="cm">/* for driver use */</span>
<span class="p">};</span>

<span class="cp">#include &lt;linux/elevator.h&gt;</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">request_fn_proc</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">make_request_fn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="n">prep_rq_fn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">unprep_rq_fn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">bio_vec</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">bvec_merge_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bi_bdev</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">bi_sector</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">bi_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bi_rw</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="n">merge_bvec_fn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bvec_merge_data</span> <span class="o">*</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">softirq_done_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="n">dma_drain_needed_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="n">lld_busy_fn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="n">bsg_job_fn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bsg_job</span> <span class="o">*</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">blk_eh_timer_return</span> <span class="p">{</span>
	<span class="n">BLK_EH_NOT_HANDLED</span><span class="p">,</span>
	<span class="n">BLK_EH_HANDLED</span><span class="p">,</span>
	<span class="n">BLK_EH_RESET_TIMER</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">blk_eh_timer_return</span> <span class="p">(</span><span class="n">rq_timed_out_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">blk_queue_state</span> <span class="p">{</span>
	<span class="n">Queue_down</span><span class="p">,</span>
	<span class="n">Queue_up</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">blk_queue_tag</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">**</span><span class="n">tag_index</span><span class="p">;</span>	<span class="cm">/* map of busy tags */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">tag_map</span><span class="p">;</span>		<span class="cm">/* bit map of free/busy tags */</span>
	<span class="kt">int</span> <span class="n">busy</span><span class="p">;</span>			<span class="cm">/* current depth */</span>
	<span class="kt">int</span> <span class="n">max_depth</span><span class="p">;</span>			<span class="cm">/* what we will send to device */</span>
	<span class="kt">int</span> <span class="n">real_max_depth</span><span class="p">;</span>		<span class="cm">/* what the array can hold */</span>
	<span class="n">atomic_t</span> <span class="n">refcnt</span><span class="p">;</span>		<span class="cm">/* map can be shared */</span>
<span class="p">};</span>

<span class="cp">#define BLK_SCSI_MAX_CMDS	(256)</span>
<span class="cp">#define BLK_SCSI_CMD_PER_LONG	(BLK_SCSI_MAX_CMDS / (sizeof(long) * 8))</span>

<span class="k">struct</span> <span class="n">queue_limits</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">bounce_pfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">seg_boundary_mask</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">max_hw_sectors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">max_sectors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">max_segment_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">physical_block_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">alignment_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">io_min</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">io_opt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">max_discard_sectors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">discard_granularity</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">discard_alignment</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">logical_block_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">max_segments</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">max_integrity_segments</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">misaligned</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">discard_misaligned</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">cluster</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">discard_zeroes_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">request_queue</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Together with queue_head for cacheline sharing</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">queue_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span>		<span class="o">*</span><span class="n">last_merge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span>	<span class="o">*</span><span class="n">elevator</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * the queue request freelist, one for reads and one for writes</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">request_list</span>	<span class="n">rq</span><span class="p">;</span>

	<span class="n">request_fn_proc</span>		<span class="o">*</span><span class="n">request_fn</span><span class="p">;</span>
	<span class="n">make_request_fn</span>		<span class="o">*</span><span class="n">make_request_fn</span><span class="p">;</span>
	<span class="n">prep_rq_fn</span>		<span class="o">*</span><span class="n">prep_rq_fn</span><span class="p">;</span>
	<span class="n">unprep_rq_fn</span>		<span class="o">*</span><span class="n">unprep_rq_fn</span><span class="p">;</span>
	<span class="n">merge_bvec_fn</span>		<span class="o">*</span><span class="n">merge_bvec_fn</span><span class="p">;</span>
	<span class="n">softirq_done_fn</span>		<span class="o">*</span><span class="n">softirq_done_fn</span><span class="p">;</span>
	<span class="n">rq_timed_out_fn</span>		<span class="o">*</span><span class="n">rq_timed_out_fn</span><span class="p">;</span>
	<span class="n">dma_drain_needed_fn</span>	<span class="o">*</span><span class="n">dma_drain_needed</span><span class="p">;</span>
	<span class="n">lld_busy_fn</span>		<span class="o">*</span><span class="n">lld_busy_fn</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Dispatch queue sorting</span>
<span class="cm">	 */</span>
	<span class="n">sector_t</span>		<span class="n">end_sector</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span>		<span class="o">*</span><span class="n">boundary_rq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Delayed queue handling</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">delay_work</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">backing_dev_info</span>	<span class="n">backing_dev_info</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The queue owner gets to use this for whatever they like.</span>
<span class="cm">	 * ll_rw_blk doesn&#39;t touch it.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">queuedata</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * various queue flags, see QUEUE_* below</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">queue_flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * ida allocated id for this queue.  Used to index queues from</span>
<span class="cm">	 * ioctx.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="n">id</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * queue needs bounce pages for pages above this limit</span>
<span class="cm">	 */</span>
	<span class="n">gfp_t</span>			<span class="n">bounce_gfp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * protects queue structures from reentrancy. -&gt;__queue_lock should</span>
<span class="cm">	 * _never_ be used directly, it is queue private. always use</span>
<span class="cm">	 * -&gt;queue_lock.</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span>		<span class="n">__queue_lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="o">*</span><span class="n">queue_lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * queue kobject</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * queue settings</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">nr_requests</span><span class="p">;</span>	<span class="cm">/* Max # of requests */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nr_congestion_on</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nr_congestion_off</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nr_batching</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">dma_drain_size</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">dma_drain_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">dma_pad_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">dma_alignment</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">blk_queue_tag</span>	<span class="o">*</span><span class="n">queue_tags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">tag_busy_list</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nr_sorted</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">in_flight</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">rq_timeout</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">timeout</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">timeout_list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">icq_list</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_BLK_CGROUP</span>
	<span class="n">DECLARE_BITMAP</span>		<span class="p">(</span><span class="n">blkcg_pols</span><span class="p">,</span> <span class="n">BLKCG_MAX_POLS</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">blkcg_gq</span>		<span class="o">*</span><span class="n">root_blkg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">blkg_list</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">queue_limits</span>	<span class="n">limits</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * sg stuff</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sg_timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sg_reserved_size</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">node</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_BLK_DEV_IO_TRACE</span>
	<span class="k">struct</span> <span class="n">blk_trace</span>	<span class="o">*</span><span class="n">blk_trace</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * for flush operations</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flush_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flush_not_queueable</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flush_queue_delayed</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flush_pending_idx</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flush_running_idx</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flush_pending_since</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">flush_queue</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">flush_data_in_flight</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span>		<span class="n">flush_rq</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">sysfs_lock</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">bypass_depth</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_BLK_DEV_BSG)</span>
	<span class="n">bsg_job_fn</span>		<span class="o">*</span><span class="n">bsg_job_fn</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">bsg_job_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bsg_class_device</span> <span class="n">bsg_dev</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_BLK_CGROUP</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">all_q_node</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_BLK_DEV_THROTTLING</span>
	<span class="cm">/* Throttle data */</span>
	<span class="k">struct</span> <span class="n">throtl_data</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#define QUEUE_FLAG_QUEUED	1	</span><span class="cm">/* uses generic tag queueing */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_STOPPED	2	</span><span class="cm">/* queue is stopped */</span><span class="cp"></span>
<span class="cp">#define	QUEUE_FLAG_SYNCFULL	3	</span><span class="cm">/* read queue has been filled */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_ASYNCFULL	4	</span><span class="cm">/* write queue has been filled */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_DEAD		5	</span><span class="cm">/* queue being torn down */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_BYPASS	6	</span><span class="cm">/* act as dumb FIFO queue */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_BIDI		7	</span><span class="cm">/* queue supports bidi requests */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_NOMERGES     8	</span><span class="cm">/* disable merge attempts */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_SAME_COMP	9	</span><span class="cm">/* complete on same CPU-group */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_FAIL_IO     10	</span><span class="cm">/* fake timeout */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_STACKABLE   11	</span><span class="cm">/* supports request stacking */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_NONROT      12	</span><span class="cm">/* non-rotational device (SSD) */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_VIRT        QUEUE_FLAG_NONROT </span><span class="cm">/* paravirt device */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_IO_STAT     13	</span><span class="cm">/* do IO stats */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_DISCARD     14	</span><span class="cm">/* supports DISCARD */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_NOXMERGES   15	</span><span class="cm">/* No extended merges */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_ADD_RANDOM  16	</span><span class="cm">/* Contributes to random pool */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_SECDISCARD  17	</span><span class="cm">/* supports SECDISCARD */</span><span class="cp"></span>
<span class="cp">#define QUEUE_FLAG_SAME_FORCE  18	</span><span class="cm">/* force complete on same CPU */</span><span class="cp"></span>

<span class="cp">#define QUEUE_FLAG_DEFAULT	((1 &lt;&lt; QUEUE_FLAG_IO_STAT) |		\</span>
<span class="cp">				 (1 &lt;&lt; QUEUE_FLAG_STACKABLE)	|	\</span>
<span class="cp">				 (1 &lt;&lt; QUEUE_FLAG_SAME_COMP)	|	\</span>
<span class="cp">				 (1 &lt;&lt; QUEUE_FLAG_ADD_RANDOM))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">queue_lockdep_assert_held</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">)</span>
		<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">queue_flag_set_unlocked</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">queue_flag_test_and_clear</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">queue_lockdep_assert_held</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">queue_flag_test_and_set</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">queue_lockdep_assert_held</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">queue_flag_set</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">queue_lockdep_assert_held</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">queue_flag_clear_unlocked</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">queue_in_flight</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">queue_flag_clear</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">queue_lockdep_assert_held</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define blk_queue_tagged(q)	test_bit(QUEUE_FLAG_QUEUED, &amp;(q)-&gt;queue_flags)</span>
<span class="cp">#define blk_queue_stopped(q)	test_bit(QUEUE_FLAG_STOPPED, &amp;(q)-&gt;queue_flags)</span>
<span class="cp">#define blk_queue_dead(q)	test_bit(QUEUE_FLAG_DEAD, &amp;(q)-&gt;queue_flags)</span>
<span class="cp">#define blk_queue_bypass(q)	test_bit(QUEUE_FLAG_BYPASS, &amp;(q)-&gt;queue_flags)</span>
<span class="cp">#define blk_queue_nomerges(q)	test_bit(QUEUE_FLAG_NOMERGES, &amp;(q)-&gt;queue_flags)</span>
<span class="cp">#define blk_queue_noxmerges(q)	\</span>
<span class="cp">	test_bit(QUEUE_FLAG_NOXMERGES, &amp;(q)-&gt;queue_flags)</span>
<span class="cp">#define blk_queue_nonrot(q)	test_bit(QUEUE_FLAG_NONROT, &amp;(q)-&gt;queue_flags)</span>
<span class="cp">#define blk_queue_io_stat(q)	test_bit(QUEUE_FLAG_IO_STAT, &amp;(q)-&gt;queue_flags)</span>
<span class="cp">#define blk_queue_add_random(q)	test_bit(QUEUE_FLAG_ADD_RANDOM, &amp;(q)-&gt;queue_flags)</span>
<span class="cp">#define blk_queue_stackable(q)	\</span>
<span class="cp">	test_bit(QUEUE_FLAG_STACKABLE, &amp;(q)-&gt;queue_flags)</span>
<span class="cp">#define blk_queue_discard(q)	test_bit(QUEUE_FLAG_DISCARD, &amp;(q)-&gt;queue_flags)</span>
<span class="cp">#define blk_queue_secdiscard(q)	(blk_queue_discard(q) &amp;&amp; \</span>
<span class="cp">	test_bit(QUEUE_FLAG_SECDISCARD, &amp;(q)-&gt;queue_flags))</span>

<span class="cp">#define blk_noretry_request(rq) \</span>
<span class="cp">	((rq)-&gt;cmd_flags &amp; (REQ_FAILFAST_DEV|REQ_FAILFAST_TRANSPORT| \</span>
<span class="cp">			     REQ_FAILFAST_DRIVER))</span>

<span class="cp">#define blk_account_rq(rq) \</span>
<span class="cp">	(((rq)-&gt;cmd_flags &amp; REQ_STARTED) &amp;&amp; \</span>
<span class="cp">	 ((rq)-&gt;cmd_type == REQ_TYPE_FS || \</span>
<span class="cp">	  ((rq)-&gt;cmd_flags &amp; REQ_DISCARD)))</span>

<span class="cp">#define blk_pm_request(rq)	\</span>
<span class="cp">	((rq)-&gt;cmd_type == REQ_TYPE_PM_SUSPEND || \</span>
<span class="cp">	 (rq)-&gt;cmd_type == REQ_TYPE_PM_RESUME)</span>

<span class="cp">#define blk_rq_cpu_valid(rq)	((rq)-&gt;cpu != -1)</span>
<span class="cp">#define blk_bidi_rq(rq)		((rq)-&gt;next_rq != NULL)</span>
<span class="cm">/* rq-&gt;queuelist of dequeued request must be list_empty() */</span>
<span class="cp">#define blk_queued_rq(rq)	(!list_empty(&amp;(rq)-&gt;queuelist))</span>

<span class="cp">#define list_entry_rq(ptr)	list_entry((ptr), struct request, queuelist)</span>

<span class="cp">#define rq_data_dir(rq)		((rq)-&gt;cmd_flags &amp; 1)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">blk_queue_cluster</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">cluster</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We regard a request as sync, if either a read or a sync write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rw_is_sync</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rw_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">rw_flags</span> <span class="o">&amp;</span> <span class="n">REQ_WRITE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">rw_flags</span> <span class="o">&amp;</span> <span class="n">REQ_SYNC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rq_is_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rw_is_sync</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blk_queue_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sync</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">QUEUE_FLAG_SYNCFULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">QUEUE_FLAG_ASYNCFULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_set_queue_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sync</span><span class="p">)</span>
		<span class="n">queue_flag_set</span><span class="p">(</span><span class="n">QUEUE_FLAG_SYNCFULL</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">queue_flag_set</span><span class="p">(</span><span class="n">QUEUE_FLAG_ASYNCFULL</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_clear_queue_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sync</span><span class="p">)</span>
		<span class="n">queue_flag_clear</span><span class="p">(</span><span class="n">QUEUE_FLAG_SYNCFULL</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">queue_flag_clear</span><span class="p">(</span><span class="n">QUEUE_FLAG_ASYNCFULL</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * mergeable request must not have _NOMERGE or _BARRIER bit set, nor may</span>
<span class="cm"> * it already be started by driver.</span>
<span class="cm"> */</span>
<span class="cp">#define RQ_NOMERGE_FLAGS	\</span>
<span class="cp">	(REQ_NOMERGE | REQ_STARTED | REQ_SOFTBARRIER | REQ_FLUSH | REQ_FUA)</span>
<span class="cp">#define rq_mergeable(rq)	\</span>
<span class="cp">	(!((rq)-&gt;cmd_flags &amp; RQ_NOMERGE_FLAGS) &amp;&amp; \</span>
<span class="cp">	 (((rq)-&gt;cmd_flags &amp; REQ_DISCARD) || \</span>
<span class="cp">	  (rq)-&gt;cmd_type == REQ_TYPE_FS))</span>

<span class="cm">/*</span>
<span class="cm"> * q-&gt;prep_rq_fn return values</span>
<span class="cm"> */</span>
<span class="cp">#define BLKPREP_OK		0	</span><span class="cm">/* serve it */</span><span class="cp"></span>
<span class="cp">#define BLKPREP_KILL		1	</span><span class="cm">/* fatal error, kill */</span><span class="cp"></span>
<span class="cp">#define BLKPREP_DEFER		2	</span><span class="cm">/* leave on queue */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blk_max_low_pfn</span><span class="p">,</span> <span class="n">blk_max_pfn</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * standard bounce addresses:</span>
<span class="cm"> *</span>
<span class="cm"> * BLK_BOUNCE_HIGH	: bounce all highmem pages</span>
<span class="cm"> * BLK_BOUNCE_ANY	: don&#39;t bounce anything</span>
<span class="cm"> * BLK_BOUNCE_ISA	: bounce pages above ISA DMA boundary</span>
<span class="cm"> */</span>

<span class="cp">#if BITS_PER_LONG == 32</span>
<span class="cp">#define BLK_BOUNCE_HIGH		((u64)blk_max_low_pfn &lt;&lt; PAGE_SHIFT)</span>
<span class="cp">#else</span>
<span class="cp">#define BLK_BOUNCE_HIGH		-1ULL</span>
<span class="cp">#endif</span>
<span class="cp">#define BLK_BOUNCE_ANY		(-1ULL)</span>
<span class="cp">#define BLK_BOUNCE_ISA		(DMA_BIT_MASK(24))</span>

<span class="cm">/*</span>
<span class="cm"> * default timeout for SG_IO if none specified</span>
<span class="cm"> */</span>
<span class="cp">#define BLK_DEFAULT_SG_TIMEOUT	(60 * HZ)</span>
<span class="cp">#define BLK_MIN_SG_TIMEOUT	(7 * HZ)</span>

<span class="cp">#ifdef CONFIG_BOUNCE</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">init_emergency_isa_pool</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_bounce</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">**</span><span class="n">bio</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">init_emergency_isa_pool</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_queue_bounce</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">**</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MMU */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">rq_map_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_order</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_entries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">null_mapped</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">from_user</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">req_iterator</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* This should not be used directly - use rq_for_each_segment */</span>
<span class="cp">#define for_each_bio(_bio)		\</span>
<span class="cp">	for (; _bio; _bio = _bio-&gt;bi_next)</span>
<span class="cp">#define __rq_for_each_bio(_bio, rq)	\</span>
<span class="cp">	if ((rq-&gt;bio))			\</span>
<span class="cp">		for (_bio = (rq)-&gt;bio; _bio; _bio = _bio-&gt;bi_next)</span>

<span class="cp">#define rq_for_each_segment(bvl, _rq, _iter)			\</span>
<span class="cp">	__rq_for_each_bio(_iter.bio, _rq)			\</span>
<span class="cp">		bio_for_each_segment(bvl, _iter.bio, _iter.i)</span>

<span class="cp">#define rq_iter_last(rq, _iter)					\</span>
<span class="cp">		(_iter.bio-&gt;bi_next == NULL &amp;&amp; _iter.i == _iter.bio-&gt;bi_vcnt-1)</span>

<span class="cp">#ifndef ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE</span>
<span class="cp"># error	&quot;You should define ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE for your platform&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rq_flush_dcache_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rq_flush_dcache_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_register_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_unregister_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">generic_make_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_rq_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_put_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__blk_put_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">blk_get_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">blk_make_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span>
					<span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_requeue_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_add_request_payload</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_rq_check_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_lld_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_rq_prep_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq_src</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bio_ctr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_rq_unprep_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_insert_cloned_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_delay_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_recount_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_verify_blk_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_cmd_blk_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_cmd_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sg_scsi_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">scsi_ioctl_command</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * A queue has just exitted congestion.  Note this in the global counter of</span>
<span class="cm"> * congested queues, and wake up anyone who was waiting for requests to be</span>
<span class="cm"> * put back.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_clear_queue_congested</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bdi_congested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">,</span> <span class="n">sync</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A queue has just entered congestion.  Flag that in the queue&#39;s VM-visible</span>
<span class="cm"> * state flags and increment the global gounter of congested queues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_set_queue_congested</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bdi_congested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">,</span> <span class="n">sync</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_start_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_stop_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_sync_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__blk_stop_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__blk_run_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_run_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_run_queue_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_rq_map_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">rq_map_data</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
			   <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_rq_unmap_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_rq_map_kern</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_rq_map_user_iov</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">rq_map_data</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sg_iovec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_execute_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_execute_rq_nowait</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">rq_end_io_fn</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="nf">bdev_get_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * blk_rq_pos()			: the current sector</span>
<span class="cm"> * blk_rq_bytes()		: bytes left in the entire request</span>
<span class="cm"> * blk_rq_cur_bytes()		: bytes left in the current segment</span>
<span class="cm"> * blk_rq_err_bytes()		: bytes left till the next error boundary</span>
<span class="cm"> * blk_rq_sectors()		: sectors left in the entire request</span>
<span class="cm"> * blk_rq_cur_sectors()		: sectors left in the current segment</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">sector_t</span> <span class="nf">blk_rq_pos</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">__sector</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">blk_rq_bytes</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">__data_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blk_rq_cur_bytes</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">?</span> <span class="n">bio_cur_bytes</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blk_rq_err_bytes</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">blk_rq_sectors</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">blk_rq_cur_sectors</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blk_rq_cur_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Request issue related functions.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">blk_peek_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_start_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">blk_fetch_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Request completion related functions.</span>
<span class="cm"> *</span>
<span class="cm"> * blk_update_request() completes given number of bytes and updates</span>
<span class="cm"> * the request without completing it.</span>
<span class="cm"> *</span>
<span class="cm"> * blk_end_request() and friends.  __blk_end_request() must be called</span>
<span class="cm"> * with the request queue spinlock acquired.</span>
<span class="cm"> *</span>
<span class="cm"> * Several drivers define their own end_request and call</span>
<span class="cm"> * blk_end_request() for parts of the original function.</span>
<span class="cm"> * This prevents code duplication in drivers.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">blk_update_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_bytes</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">blk_end_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_bytes</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_end_request_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">blk_end_request_cur</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">blk_end_request_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">__blk_end_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_bytes</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__blk_end_request_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">__blk_end_request_cur</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">__blk_end_request_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_complete_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__blk_complete_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_abort_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_unprep_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Access functions for manipulating queue properties</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">blk_init_queue_node</span><span class="p">(</span><span class="n">request_fn_proc</span> <span class="o">*</span><span class="n">rfn</span><span class="p">,</span>
					<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">blk_init_queue</span><span class="p">(</span><span class="n">request_fn_proc</span> <span class="o">*</span><span class="p">,</span> <span class="n">spinlock_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">blk_init_allocated_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span>
						      <span class="n">request_fn_proc</span> <span class="o">*</span><span class="p">,</span> <span class="n">spinlock_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_make_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="n">make_request_fn</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_bounce_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_limits_max_hw_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_max_hw_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_max_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_max_segment_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_max_discard_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_discard_sectors</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_logical_block_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_physical_block_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_alignment_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alignment</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_limits_io_min</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">limits</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_io_min</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_limits_io_opt</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">limits</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_io_opt</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_set_default_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">lim</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_set_stacking_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">lim</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_stack_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span>
			    <span class="n">sector_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">bdev_stack_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			    <span class="n">sector_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">disk_stack_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			      <span class="n">sector_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_stack_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_dma_pad</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_update_dma_pad</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_queue_dma_drain</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			       <span class="n">dma_drain_needed_fn</span> <span class="o">*</span><span class="n">dma_drain_needed</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_lld_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">lld_busy_fn</span> <span class="o">*</span><span class="n">fn</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_segment_boundary</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_prep_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="n">prep_rq_fn</span> <span class="o">*</span><span class="n">pfn</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_unprep_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="n">unprep_rq_fn</span> <span class="o">*</span><span class="n">ufn</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_merge_bvec</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="n">merge_bvec_fn</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_dma_alignment</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_update_dma_alignment</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_softirq_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="n">softirq_done_fn</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_rq_timed_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="n">rq_timed_out_fn</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_rq_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flush</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_flush_queueable</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">bool</span> <span class="n">queueable</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">blk_get_backing_dev_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_rq_map_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_dump_rq_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">nr_blockdev_pages</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="n">bool</span> <span class="n">__must_check</span> <span class="n">blk_get_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">blk_alloc_queue</span><span class="p">(</span><span class="n">gfp_t</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">blk_alloc_queue_node</span><span class="p">(</span><span class="n">gfp_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_put_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * blk_plug permits building a queue of related requests by holding the I/O</span>
<span class="cm"> * fragments for a short period. This allows merging of sequential requests</span>
<span class="cm"> * into single larger request. As the requests are moved from a per-task list to</span>
<span class="cm"> * the device&#39;s request_queue in a batch, this results in improved scalability</span>
<span class="cm"> * as the lock contention for request_queue lock is reduced.</span>
<span class="cm"> *</span>
<span class="cm"> * It is ok not to disable preemption when adding the request to the plug list</span>
<span class="cm"> * or when attempting a merge, because blk_schedule_flush_list() will only flush</span>
<span class="cm"> * the plug list when the task sleeps by itself. For details, please see</span>
<span class="cm"> * schedule() where blk_schedule_flush_plug() is called.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">blk_plug</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">magic</span><span class="p">;</span> <span class="cm">/* detect uninitialized use-cases */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span> <span class="cm">/* requests */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cb_list</span><span class="p">;</span> <span class="cm">/* md requires an unplug callback */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">should_sort</span><span class="p">;</span> <span class="cm">/* list to be sorted before flushing? */</span>
<span class="p">};</span>
<span class="cp">#define BLK_MAX_REQUEST_COUNT 16</span>

<span class="k">struct</span> <span class="n">blk_plug_cb</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">blk_plug_cb</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_start_plug</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_plug</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_finish_plug</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_plug</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_flush_plug_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_plug</span> <span class="o">*</span><span class="p">,</span> <span class="n">bool</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_flush_plug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blk_plug</span> <span class="o">*</span><span class="n">plug</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">plug</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">plug</span><span class="p">)</span>
		<span class="n">blk_flush_plug_list</span><span class="p">(</span><span class="n">plug</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_schedule_flush_plug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blk_plug</span> <span class="o">*</span><span class="n">plug</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">plug</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">plug</span><span class="p">)</span>
		<span class="n">blk_flush_plug_list</span><span class="p">(</span><span class="n">plug</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">blk_needs_flush_plug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blk_plug</span> <span class="o">*</span><span class="n">plug</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">plug</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">plug</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="o">-&gt;</span><span class="n">cb_list</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * tag stuff</span>
<span class="cm"> */</span>
<span class="cp">#define blk_rq_tagged(rq)		((rq)-&gt;cmd_flags &amp; REQ_QUEUED)</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_queue_start_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">blk_queue_find_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_end_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_queue_init_tags</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">blk_queue_tag</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_free_tags</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_queue_resize_tags</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_queue_invalidate_tags</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">blk_queue_tag</span> <span class="o">*</span><span class="n">blk_init_tags</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_free_tags</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_queue_tag</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">blk_map_queue_find_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_queue_tag</span> <span class="o">*</span><span class="n">bqt</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bqt</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">tag</span> <span class="o">&gt;=</span> <span class="n">bqt</span><span class="o">-&gt;</span><span class="n">real_max_depth</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bqt</span><span class="o">-&gt;</span><span class="n">tag_index</span><span class="p">[</span><span class="n">tag</span><span class="p">];</span>
<span class="p">}</span>

<span class="cp">#define BLKDEV_DISCARD_SECURE  0x01    </span><span class="cm">/* secure discard */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">blkdev_issue_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">,</span> <span class="n">sector_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blkdev_issue_discard</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">,</span>
		<span class="n">sector_t</span> <span class="n">nr_sects</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blkdev_issue_zeroout</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">,</span>
			<span class="n">sector_t</span> <span class="n">nr_sects</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sb_issue_discard</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span>
		<span class="n">sector_t</span> <span class="n">nr_blocks</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blkdev_issue_discard</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">,</span> <span class="n">block</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span> <span class="o">-</span> <span class="mi">9</span><span class="p">),</span>
				    <span class="n">nr_blocks</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span> <span class="o">-</span> <span class="mi">9</span><span class="p">),</span>
				    <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sb_issue_zeroout</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span>
		<span class="n">sector_t</span> <span class="n">nr_blocks</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blkdev_issue_zeroout</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">,</span>
				    <span class="n">block</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span> <span class="o">-</span> <span class="mi">9</span><span class="p">),</span>
				    <span class="n">nr_blocks</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span> <span class="o">-</span> <span class="mi">9</span><span class="p">),</span>
				    <span class="n">gfp_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_verify_command</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">has_write_perm</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">blk_default_limits</span> <span class="p">{</span>
	<span class="n">BLK_MAX_SEGMENTS</span>	<span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
	<span class="n">BLK_SAFE_MAX_SECTORS</span>	<span class="o">=</span> <span class="mi">255</span><span class="p">,</span>
	<span class="n">BLK_DEF_MAX_SECTORS</span>	<span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
	<span class="n">BLK_MAX_SEGMENT_SIZE</span>	<span class="o">=</span> <span class="mi">65536</span><span class="p">,</span>
	<span class="n">BLK_SEG_BOUNDARY_MASK</span>	<span class="o">=</span> <span class="mh">0xFFFFFFFFUL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define blkdev_entry_to_request(entry) list_entry((entry), struct request, queuelist)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">queue_bounce_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">bounce_pfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">queue_segment_boundary</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">seg_boundary_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">queue_max_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">max_sectors</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">queue_max_hw_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">max_hw_sectors</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">queue_max_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">max_segments</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">queue_max_segment_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">max_segment_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">queue_logical_block_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">logical_block_size</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">logical_block_size</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">bdev_logical_block_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_logical_block_size</span><span class="p">(</span><span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bdev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">queue_physical_block_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">physical_block_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bdev_physical_block_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_physical_block_size</span><span class="p">(</span><span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bdev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">queue_io_min</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">io_min</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bdev_io_min</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_io_min</span><span class="p">(</span><span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bdev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">queue_io_opt</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">io_opt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bdev_io_opt</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_io_opt</span><span class="p">(</span><span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bdev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">queue_alignment_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">misaligned</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">alignment_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">queue_limit_alignment_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">lim</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">granularity</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">lim</span><span class="o">-&gt;</span><span class="n">physical_block_size</span><span class="p">,</span> <span class="n">lim</span><span class="o">-&gt;</span><span class="n">io_min</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alignment</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">granularity</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">granularity</span> <span class="o">+</span> <span class="n">lim</span><span class="o">-&gt;</span><span class="n">alignment_offset</span> <span class="o">-</span> <span class="n">alignment</span><span class="p">)</span>
		<span class="o">&amp;</span> <span class="p">(</span><span class="n">granularity</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bdev_alignment_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">misaligned</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bdev</span> <span class="o">!=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_contains</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_part</span><span class="o">-&gt;</span><span class="n">alignment_offset</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">alignment_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">queue_discard_alignment</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">discard_misaligned</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">discard_alignment</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">queue_limit_discard_alignment</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">lim</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alignment</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lim</span><span class="o">-&gt;</span><span class="n">discard_granularity</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lim</span><span class="o">-&gt;</span><span class="n">max_discard_sectors</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">lim</span><span class="o">-&gt;</span><span class="n">discard_granularity</span> <span class="o">+</span> <span class="n">lim</span><span class="o">-&gt;</span><span class="n">discard_alignment</span> <span class="o">-</span> <span class="n">alignment</span><span class="p">)</span>
		<span class="o">&amp;</span> <span class="p">(</span><span class="n">lim</span><span class="o">-&gt;</span><span class="n">discard_granularity</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">queue_discard_zeroes_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">max_discard_sectors</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">discard_zeroes_data</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bdev_discard_zeroes_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_discard_zeroes_data</span><span class="p">(</span><span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bdev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">queue_dma_alignment</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span> <span class="o">?</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_alignment</span> <span class="o">:</span> <span class="mi">511</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blk_rq_aligned</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alignment</span> <span class="o">=</span> <span class="n">queue_dma_alignment</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_pad_mask</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="n">alignment</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="n">alignment</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* assumes size &gt; 256 */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">blksize_bits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">bits</span><span class="o">++</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">256</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">block_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_block_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">queue_flush_queueable</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flush_not_queueable</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">v</span><span class="p">;}</span> <span class="n">Sector</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">read_dev_sector</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span><span class="p">,</span> <span class="n">Sector</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_dev_sector</span><span class="p">(</span><span class="n">Sector</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">work_struct</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">kblockd_schedule_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_BLK_CGROUP</span>
<span class="cm">/*</span>
<span class="cm"> * This should not be using sched_clock(). A real patch is in progress</span>
<span class="cm"> * to fix this up, until that is in place we need to disable preemption</span>
<span class="cm"> * around sched_clock() in this function and set_io_start_time_ns().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_start_time_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">start_time_ns</span> <span class="o">=</span> <span class="n">sched_clock</span><span class="p">();</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_io_start_time_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">io_start_time_ns</span> <span class="o">=</span> <span class="n">sched_clock</span><span class="p">();</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">rq_start_time_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">start_time_ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">rq_io_start_time_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">io_start_time_ns</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_start_time_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_io_start_time_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">rq_start_time_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">rq_io_start_time_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#define MODULE_ALIAS_BLOCKDEV(major,minor) \</span>
<span class="cp">	MODULE_ALIAS(&quot;block-major-&quot; __stringify(major) &quot;-&quot; __stringify(minor))</span>
<span class="cp">#define MODULE_ALIAS_BLOCKDEV_MAJOR(major) \</span>
<span class="cp">	MODULE_ALIAS(&quot;block-major-&quot; __stringify(major) &quot;-*&quot;)</span>

<span class="cp">#if defined(CONFIG_BLK_DEV_INTEGRITY)</span>

<span class="cp">#define INTEGRITY_FLAG_READ	2	</span><span class="cm">/* verify data integrity on read */</span><span class="cp"></span>
<span class="cp">#define INTEGRITY_FLAG_WRITE	4	</span><span class="cm">/* generate data integrity on write */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">blk_integrity_exchg</span> <span class="p">{</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">prot_buf</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">data_buf</span><span class="p">;</span>
	<span class="n">sector_t</span>		<span class="n">sector</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">data_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">sector_size</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">disk_name</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">integrity_gen_fn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">blk_integrity_exchg</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="n">integrity_vrfy_fn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">blk_integrity_exchg</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">integrity_set_tag_fn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">integrity_get_tag_fn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">blk_integrity</span> <span class="p">{</span>
	<span class="n">integrity_gen_fn</span>	<span class="o">*</span><span class="n">generate_fn</span><span class="p">;</span>
	<span class="n">integrity_vrfy_fn</span>	<span class="o">*</span><span class="n">verify_fn</span><span class="p">;</span>
	<span class="n">integrity_set_tag_fn</span>	<span class="o">*</span><span class="n">set_tag_fn</span><span class="p">;</span>
	<span class="n">integrity_get_tag_fn</span>	<span class="o">*</span><span class="n">get_tag_fn</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">tuple_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">sector_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">tag_size</span><span class="p">;</span>

	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">kobject</span>		<span class="n">kobj</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">blk_integrity_is_initialized</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_integrity_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_integrity_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_integrity_compare</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_rq_map_integrity_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_rq_count_integrity_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_integrity_merge_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_integrity_merge_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="nf">bdev_get_integrity</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">integrity</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="nf">blk_get_integrity</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">integrity</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blk_integrity_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bio_integrity</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_queue_max_integrity_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">segs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">max_integrity_segments</span> <span class="o">=</span> <span class="n">segs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">short</span>
<span class="nf">queue_max_integrity_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">max_integrity_segments</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_BLK_DEV_INTEGRITY */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">bio</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">block_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">gendisk</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">blk_integrity</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blk_integrity_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blk_rq_count_integrity_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blk_rq_map_integrity_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="nf">bdev_get_integrity</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="nf">blk_get_integrity</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blk_integrity_compare</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blk_integrity_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_integrity_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_queue_max_integrity_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">segs</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">queue_max_integrity_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blk_integrity_merge_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">r1</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">r2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blk_integrity_merge_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">blk_integrity_is_initialized</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">g</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_BLK_DEV_INTEGRITY */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">block_device_operations</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compat_ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">direct_access</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span><span class="p">,</span>
						<span class="kt">void</span> <span class="o">**</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_events</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clearing</span><span class="p">);</span>
	<span class="cm">/* -&gt;media_changed() is DEPRECATED, use -&gt;check_events() instead */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">media_changed</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">unlock_native_capacity</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">revalidate_disk</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">getgeo</span><span class="p">)(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hd_geometry</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* this callback is with swap_lock and sometimes page table lock held */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">swap_slot_free_notify</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__blkdev_driver_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_BLOCK */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * stubs for when the block layer is configured out</span>
<span class="cm"> */</span>
<span class="cp">#define buffer_heads_over_limit 0</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">nr_blockdev_pages</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">blk_plug</span> <span class="p">{</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_start_plug</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_plug</span> <span class="o">*</span><span class="n">plug</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_finish_plug</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_plug</span> <span class="o">*</span><span class="n">plug</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_flush_plug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_schedule_flush_plug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">blk_needs_flush_plug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_BLOCK */</span><span class="cp"></span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
