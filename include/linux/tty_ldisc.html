<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › tty_ldisc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tty_ldisc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_TTY_LDISC_H</span>
<span class="cp">#define _LINUX_TTY_LDISC_H</span>

<span class="cm">/*</span>
<span class="cm"> * This structure defines the interface between the tty line discipline</span>
<span class="cm"> * implementation and the tty routines.  The following routines can be</span>
<span class="cm"> * defined; unless noted otherwise, they are optional, and can be</span>
<span class="cm"> * filled in with a null pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * int	(*open)(struct tty_struct *);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This function is called when the line discipline is associated</span>
<span class="cm"> * 	with the tty.  The line discipline can use this as an</span>
<span class="cm"> * 	opportunity to initialize any state needed by the ldisc routines.</span>
<span class="cm"> * </span>
<span class="cm"> * void	(*close)(struct tty_struct *);</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is called when the line discipline is being</span>
<span class="cm"> * 	shutdown, either because the tty is being closed or because</span>
<span class="cm"> * 	the tty is being changed to use a new line discipline</span>
<span class="cm"> * </span>
<span class="cm"> * void	(*flush_buffer)(struct tty_struct *tty);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This function instructs the line discipline to clear its</span>
<span class="cm"> * 	buffers of any input characters it may have queued to be</span>
<span class="cm"> * 	delivered to the user mode process.</span>
<span class="cm"> * </span>
<span class="cm"> * ssize_t (*chars_in_buffer)(struct tty_struct *tty);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This function returns the number of input characters the line</span>
<span class="cm"> *	discipline may have queued up to be delivered to the user mode</span>
<span class="cm"> *	process.</span>
<span class="cm"> * </span>
<span class="cm"> * ssize_t (*read)(struct tty_struct * tty, struct file * file,</span>
<span class="cm"> *		   unsigned char * buf, size_t nr);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This function is called when the user requests to read from</span>
<span class="cm"> * 	the tty.  The line discipline will return whatever characters</span>
<span class="cm"> * 	it has buffered up for the user.  If this function is not</span>
<span class="cm"> * 	defined, the user will receive an EIO error.</span>
<span class="cm"> * </span>
<span class="cm"> * ssize_t (*write)(struct tty_struct * tty, struct file * file,</span>
<span class="cm"> * 		    const unsigned char * buf, size_t nr);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This function is called when the user requests to write to the</span>
<span class="cm"> * 	tty.  The line discipline will deliver the characters to the</span>
<span class="cm"> * 	low-level tty device for transmission, optionally performing</span>
<span class="cm"> * 	some processing on the characters first.  If this function is</span>
<span class="cm"> * 	not defined, the user will receive an EIO error.</span>
<span class="cm"> * </span>
<span class="cm"> * int	(*ioctl)(struct tty_struct * tty, struct file * file,</span>
<span class="cm"> * 		 unsigned int cmd, unsigned long arg);</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is called when the user requests an ioctl which</span>
<span class="cm"> * 	is not handled by the tty layer or the low-level tty driver.</span>
<span class="cm"> * 	It is intended for ioctls which affect line discpline</span>
<span class="cm"> * 	operation.  Note that the search order for ioctls is (1) tty</span>
<span class="cm"> * 	layer, (2) tty low-level driver, (3) line discpline.  So a</span>
<span class="cm"> * 	low-level driver can &quot;grab&quot; an ioctl request before the line</span>
<span class="cm"> * 	discpline has a chance to see it.</span>
<span class="cm"> * </span>
<span class="cm"> * long	(*compat_ioctl)(struct tty_struct * tty, struct file * file,</span>
<span class="cm"> * 		        unsigned int cmd, unsigned long arg);</span>
<span class="cm"> *</span>
<span class="cm"> *      Process ioctl calls from 32-bit process on 64-bit system</span>
<span class="cm"> *</span>
<span class="cm"> * void	(*set_termios)(struct tty_struct *tty, struct ktermios * old);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This function notifies the line discpline that a change has</span>
<span class="cm"> * 	been made to the termios structure.</span>
<span class="cm"> * </span>
<span class="cm"> * int	(*poll)(struct tty_struct * tty, struct file * file,</span>
<span class="cm"> * 		  poll_table *wait);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This function is called when a user attempts to select/poll on a</span>
<span class="cm"> * 	tty device.  It is solely the responsibility of the line</span>
<span class="cm"> * 	discipline to handle poll requests.</span>
<span class="cm"> *</span>
<span class="cm"> * void	(*receive_buf)(struct tty_struct *, const unsigned char *cp,</span>
<span class="cm"> * 		       char *fp, int count);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This function is called by the low-level tty driver to send</span>
<span class="cm"> * 	characters received by the hardware to the line discpline for</span>
<span class="cm"> * 	processing.  &lt;cp&gt; is a pointer to the buffer of input</span>
<span class="cm"> * 	character received by the device.  &lt;fp&gt; is a pointer to a</span>
<span class="cm"> * 	pointer of flag bytes which indicate whether a character was</span>
<span class="cm"> * 	received with a parity error, etc.</span>
<span class="cm"> * </span>
<span class="cm"> * void	(*write_wakeup)(struct tty_struct *);</span>
<span class="cm"> *</span>
<span class="cm"> * 	This function is called by the low-level tty driver to signal</span>
<span class="cm"> * 	that line discpline should try to send more characters to the</span>
<span class="cm"> * 	low-level driver for transmission.  If the line discpline does</span>
<span class="cm"> * 	not have any more data to send, it can just return.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*hangup)(struct tty_struct *)</span>
<span class="cm"> *</span>
<span class="cm"> *	Called on a hangup. Tells the discipline that it should</span>
<span class="cm"> *	cease I/O to the tty driver. Can sleep. The driver should</span>
<span class="cm"> *	seek to perform this action quickly but should wait until</span>
<span class="cm"> *	any pending driver I/O is completed.</span>
<span class="cm"> *</span>
<span class="cm"> * void (*dcd_change)(struct tty_struct *tty, unsigned int status,</span>
<span class="cm"> *			struct pps_event_time *ts)</span>
<span class="cm"> *</span>
<span class="cm"> *	Tells the discipline that the DCD pin has changed its status and</span>
<span class="cm"> *	the relative timestamp. Pointer ts cannot be NULL.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/pps_kernel.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>

<span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">magic</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">num</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">flags</span><span class="p">;</span>
	
	<span class="cm">/*</span>
<span class="cm">	 * The following routines are called from above.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">flush_buffer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">ssize_t</span>	<span class="p">(</span><span class="o">*</span><span class="n">chars_in_buffer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">ssize_t</span>	<span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nr</span><span class="p">);</span>
	<span class="kt">ssize_t</span>	<span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nr</span><span class="p">);</span>	
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
	<span class="kt">long</span>	<span class="p">(</span><span class="o">*</span><span class="n">compat_ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_termios</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span> <span class="n">old</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">poll</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">hangup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	
	<span class="cm">/*</span>
<span class="cm">	 * The following routines are called from below.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">receive_buf</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">write_wakeup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">dcd_change</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pps_event_time</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">struct</span>  <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	
	<span class="kt">int</span> <span class="n">refcount</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">users</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wq_idle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define TTY_LDISC_MAGIC	0x5403</span>

<span class="cp">#define LDISC_FLAG_DEFINED	0x00000001</span>

<span class="cp">#define MODULE_ALIAS_LDISC(ldisc) \</span>
<span class="cp">	MODULE_ALIAS(&quot;tty-ldisc-&quot; __stringify(ldisc))</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_TTY_LDISC_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
