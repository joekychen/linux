<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › i2o.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>i2o.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * I2O kernel space accessible structures/APIs</span>
<span class="cm"> *</span>
<span class="cm"> * (c) Copyright 1999, 2000 Red Hat Software</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * This header file defined the I2O APIs/structures for use by</span>
<span class="cm"> * the I2O kernel modules.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _I2O_H</span>
<span class="cp">#define _I2O_H</span>

<span class="cp">#include &lt;linux/i2o-dev.h&gt;</span>

<span class="cm">/* How many different OSM&#39;s are we allowing */</span>
<span class="cp">#define I2O_MAX_DRIVERS		8</span>

<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;	</span><span class="cm">/* work_struct */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/semaphore.h&gt;	</span><span class="cm">/* Needed for MUTEX init macros */</span><span class="cp"></span>

<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cm">/* message queue empty */</span>
<span class="cp">#define I2O_QUEUE_EMPTY		0xffffffff</span>

<span class="cm">/*</span>
<span class="cm"> *	Cache strategies</span>
<span class="cm"> */</span>

<span class="cm">/*	The NULL strategy leaves everything up to the controller. This tends to be a</span>
<span class="cm"> *	pessimal but functional choice.</span>
<span class="cm"> */</span>
<span class="cp">#define CACHE_NULL		0</span>
<span class="cm">/*	Prefetch data when reading. We continually attempt to load the next 32 sectors</span>
<span class="cm"> *	into the controller cache.</span>
<span class="cm"> */</span>
<span class="cp">#define CACHE_PREFETCH		1</span>
<span class="cm">/*	Prefetch data when reading. We sometimes attempt to load the next 32 sectors</span>
<span class="cm"> *	into the controller cache. When an I/O is less &lt;= 8K we assume its probably</span>
<span class="cm"> *	not sequential and don&#39;t prefetch (default)</span>
<span class="cm"> */</span>
<span class="cp">#define CACHE_SMARTFETCH	2</span>
<span class="cm">/*	Data is written to the cache and then out on to the disk. The I/O must be</span>
<span class="cm"> *	physically on the medium before the write is acknowledged (default without</span>
<span class="cm"> *	NVRAM)</span>
<span class="cm"> */</span>
<span class="cp">#define CACHE_WRITETHROUGH	17</span>
<span class="cm">/*	Data is written to the cache and then out on to the disk. The controller</span>
<span class="cm"> *	is permitted to write back the cache any way it wants. (default if battery</span>
<span class="cm"> *	backed NVRAM is present). It can be useful to set this for swap regardless of</span>
<span class="cm"> *	battery state.</span>
<span class="cm"> */</span>
<span class="cp">#define CACHE_WRITEBACK		18</span>
<span class="cm">/*	Optimise for under powered controllers, especially on RAID1 and RAID0. We</span>
<span class="cm"> *	write large I/O&#39;s directly to disk bypassing the cache to avoid the extra</span>
<span class="cm"> *	memory copy hits. Small writes are writeback cached</span>
<span class="cm"> */</span>
<span class="cp">#define CACHE_SMARTBACK		19</span>
<span class="cm">/*	Optimise for under powered controllers, especially on RAID1 and RAID0. We</span>
<span class="cm"> *	write large I/O&#39;s directly to disk bypassing the cache to avoid the extra</span>
<span class="cm"> *	memory copy hits. Small writes are writethrough cached. Suitable for devices</span>
<span class="cm"> *	lacking battery backup</span>
<span class="cm"> */</span>
<span class="cp">#define CACHE_SMARTTHROUGH	20</span>

<span class="cm">/*</span>
<span class="cm"> *	Ioctl structures</span>
<span class="cm"> */</span>

<span class="cp">#define 	BLKI2OGRSTRAT	_IOR(&#39;2&#39;, 1, int)</span>
<span class="cp">#define 	BLKI2OGWSTRAT	_IOR(&#39;2&#39;, 2, int)</span>
<span class="cp">#define 	BLKI2OSRSTRAT	_IOW(&#39;2&#39;, 3, int)</span>
<span class="cp">#define 	BLKI2OSWSTRAT	_IOW(&#39;2&#39;, 4, int)</span>

<span class="cm">/*</span>
<span class="cm"> *	I2O Function codes</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	Executive Class</span>
<span class="cm"> */</span>
<span class="cp">#define	I2O_CMD_ADAPTER_ASSIGN		0xB3</span>
<span class="cp">#define	I2O_CMD_ADAPTER_READ		0xB2</span>
<span class="cp">#define	I2O_CMD_ADAPTER_RELEASE		0xB5</span>
<span class="cp">#define	I2O_CMD_BIOS_INFO_SET		0xA5</span>
<span class="cp">#define	I2O_CMD_BOOT_DEVICE_SET		0xA7</span>
<span class="cp">#define	I2O_CMD_CONFIG_VALIDATE		0xBB</span>
<span class="cp">#define	I2O_CMD_CONN_SETUP		0xCA</span>
<span class="cp">#define	I2O_CMD_DDM_DESTROY		0xB1</span>
<span class="cp">#define	I2O_CMD_DDM_ENABLE		0xD5</span>
<span class="cp">#define	I2O_CMD_DDM_QUIESCE		0xC7</span>
<span class="cp">#define	I2O_CMD_DDM_RESET		0xD9</span>
<span class="cp">#define	I2O_CMD_DDM_SUSPEND		0xAF</span>
<span class="cp">#define	I2O_CMD_DEVICE_ASSIGN		0xB7</span>
<span class="cp">#define	I2O_CMD_DEVICE_RELEASE		0xB9</span>
<span class="cp">#define	I2O_CMD_HRT_GET			0xA8</span>
<span class="cp">#define	I2O_CMD_ADAPTER_CLEAR		0xBE</span>
<span class="cp">#define	I2O_CMD_ADAPTER_CONNECT		0xC9</span>
<span class="cp">#define	I2O_CMD_ADAPTER_RESET		0xBD</span>
<span class="cp">#define	I2O_CMD_LCT_NOTIFY		0xA2</span>
<span class="cp">#define	I2O_CMD_OUTBOUND_INIT		0xA1</span>
<span class="cp">#define	I2O_CMD_PATH_ENABLE		0xD3</span>
<span class="cp">#define	I2O_CMD_PATH_QUIESCE		0xC5</span>
<span class="cp">#define	I2O_CMD_PATH_RESET		0xD7</span>
<span class="cp">#define	I2O_CMD_STATIC_MF_CREATE	0xDD</span>
<span class="cp">#define	I2O_CMD_STATIC_MF_RELEASE	0xDF</span>
<span class="cp">#define	I2O_CMD_STATUS_GET		0xA0</span>
<span class="cp">#define	I2O_CMD_SW_DOWNLOAD		0xA9</span>
<span class="cp">#define	I2O_CMD_SW_UPLOAD		0xAB</span>
<span class="cp">#define	I2O_CMD_SW_REMOVE		0xAD</span>
<span class="cp">#define	I2O_CMD_SYS_ENABLE		0xD1</span>
<span class="cp">#define	I2O_CMD_SYS_MODIFY		0xC1</span>
<span class="cp">#define	I2O_CMD_SYS_QUIESCE		0xC3</span>
<span class="cp">#define	I2O_CMD_SYS_TAB_SET		0xA3</span>

<span class="cm">/*</span>
<span class="cm"> * Utility Class</span>
<span class="cm"> */</span>
<span class="cp">#define I2O_CMD_UTIL_NOP		0x00</span>
<span class="cp">#define I2O_CMD_UTIL_ABORT		0x01</span>
<span class="cp">#define I2O_CMD_UTIL_CLAIM		0x09</span>
<span class="cp">#define I2O_CMD_UTIL_RELEASE		0x0B</span>
<span class="cp">#define I2O_CMD_UTIL_PARAMS_GET		0x06</span>
<span class="cp">#define I2O_CMD_UTIL_PARAMS_SET		0x05</span>
<span class="cp">#define I2O_CMD_UTIL_EVT_REGISTER	0x13</span>
<span class="cp">#define I2O_CMD_UTIL_EVT_ACK		0x14</span>
<span class="cp">#define I2O_CMD_UTIL_CONFIG_DIALOG	0x10</span>
<span class="cp">#define I2O_CMD_UTIL_DEVICE_RESERVE	0x0D</span>
<span class="cp">#define I2O_CMD_UTIL_DEVICE_RELEASE	0x0F</span>
<span class="cp">#define I2O_CMD_UTIL_LOCK		0x17</span>
<span class="cp">#define I2O_CMD_UTIL_LOCK_RELEASE	0x19</span>
<span class="cp">#define I2O_CMD_UTIL_REPLY_FAULT_NOTIFY	0x15</span>

<span class="cm">/*</span>
<span class="cm"> * SCSI Host Bus Adapter Class</span>
<span class="cm"> */</span>
<span class="cp">#define I2O_CMD_SCSI_EXEC		0x81</span>
<span class="cp">#define I2O_CMD_SCSI_ABORT		0x83</span>
<span class="cp">#define I2O_CMD_SCSI_BUSRESET		0x27</span>

<span class="cm">/*</span>
<span class="cm"> * Bus Adapter Class</span>
<span class="cm"> */</span>
<span class="cp">#define I2O_CMD_BUS_ADAPTER_RESET	0x85</span>
<span class="cp">#define I2O_CMD_BUS_RESET		0x87</span>
<span class="cp">#define I2O_CMD_BUS_SCAN		0x89</span>
<span class="cp">#define I2O_CMD_BUS_QUIESCE		0x8b</span>

<span class="cm">/*</span>
<span class="cm"> * Random Block Storage Class</span>
<span class="cm"> */</span>
<span class="cp">#define I2O_CMD_BLOCK_READ		0x30</span>
<span class="cp">#define I2O_CMD_BLOCK_WRITE		0x31</span>
<span class="cp">#define I2O_CMD_BLOCK_CFLUSH		0x37</span>
<span class="cp">#define I2O_CMD_BLOCK_MLOCK		0x49</span>
<span class="cp">#define I2O_CMD_BLOCK_MUNLOCK		0x4B</span>
<span class="cp">#define I2O_CMD_BLOCK_MMOUNT		0x41</span>
<span class="cp">#define I2O_CMD_BLOCK_MEJECT		0x43</span>
<span class="cp">#define I2O_CMD_BLOCK_POWER		0x70</span>

<span class="cp">#define I2O_CMD_PRIVATE			0xFF</span>

<span class="cm">/* Command status values  */</span>

<span class="cp">#define I2O_CMD_IN_PROGRESS	0x01</span>
<span class="cp">#define I2O_CMD_REJECTED	0x02</span>
<span class="cp">#define I2O_CMD_FAILED		0x03</span>
<span class="cp">#define I2O_CMD_COMPLETED	0x04</span>

<span class="cm">/* I2O API function return values */</span>

<span class="cp">#define I2O_RTN_NO_ERROR			0</span>
<span class="cp">#define I2O_RTN_NOT_INIT			1</span>
<span class="cp">#define I2O_RTN_FREE_Q_EMPTY			2</span>
<span class="cp">#define I2O_RTN_TCB_ERROR			3</span>
<span class="cp">#define I2O_RTN_TRANSACTION_ERROR		4</span>
<span class="cp">#define I2O_RTN_ADAPTER_ALREADY_INIT		5</span>
<span class="cp">#define I2O_RTN_MALLOC_ERROR			6</span>
<span class="cp">#define I2O_RTN_ADPTR_NOT_REGISTERED		7</span>
<span class="cp">#define I2O_RTN_MSG_REPLY_TIMEOUT		8</span>
<span class="cp">#define I2O_RTN_NO_STATUS			9</span>
<span class="cp">#define I2O_RTN_NO_FIRM_VER			10</span>
<span class="cp">#define	I2O_RTN_NO_LINK_SPEED			11</span>

<span class="cm">/* Reply message status defines for all messages */</span>

<span class="cp">#define I2O_REPLY_STATUS_SUCCESS                    	0x00</span>
<span class="cp">#define I2O_REPLY_STATUS_ABORT_DIRTY                	0x01</span>
<span class="cp">#define I2O_REPLY_STATUS_ABORT_NO_DATA_TRANSFER     	0x02</span>
<span class="cp">#define	I2O_REPLY_STATUS_ABORT_PARTIAL_TRANSFER		0x03</span>
<span class="cp">#define	I2O_REPLY_STATUS_ERROR_DIRTY			0x04</span>
<span class="cp">#define	I2O_REPLY_STATUS_ERROR_NO_DATA_TRANSFER		0x05</span>
<span class="cp">#define	I2O_REPLY_STATUS_ERROR_PARTIAL_TRANSFER		0x06</span>
<span class="cp">#define	I2O_REPLY_STATUS_PROCESS_ABORT_DIRTY		0x08</span>
<span class="cp">#define	I2O_REPLY_STATUS_PROCESS_ABORT_NO_DATA_TRANSFER	0x09</span>
<span class="cp">#define	I2O_REPLY_STATUS_PROCESS_ABORT_PARTIAL_TRANSFER	0x0A</span>
<span class="cp">#define	I2O_REPLY_STATUS_TRANSACTION_ERROR		0x0B</span>
<span class="cp">#define	I2O_REPLY_STATUS_PROGRESS_REPORT		0x80</span>

<span class="cm">/* Status codes and Error Information for Parameter functions */</span>

<span class="cp">#define I2O_PARAMS_STATUS_SUCCESS		0x00</span>
<span class="cp">#define I2O_PARAMS_STATUS_BAD_KEY_ABORT		0x01</span>
<span class="cp">#define I2O_PARAMS_STATUS_BAD_KEY_CONTINUE   	0x02</span>
<span class="cp">#define I2O_PARAMS_STATUS_BUFFER_FULL		0x03</span>
<span class="cp">#define I2O_PARAMS_STATUS_BUFFER_TOO_SMALL	0x04</span>
<span class="cp">#define I2O_PARAMS_STATUS_FIELD_UNREADABLE	0x05</span>
<span class="cp">#define I2O_PARAMS_STATUS_FIELD_UNWRITEABLE	0x06</span>
<span class="cp">#define I2O_PARAMS_STATUS_INSUFFICIENT_FIELDS	0x07</span>
<span class="cp">#define I2O_PARAMS_STATUS_INVALID_GROUP_ID	0x08</span>
<span class="cp">#define I2O_PARAMS_STATUS_INVALID_OPERATION	0x09</span>
<span class="cp">#define I2O_PARAMS_STATUS_NO_KEY_FIELD		0x0A</span>
<span class="cp">#define I2O_PARAMS_STATUS_NO_SUCH_FIELD		0x0B</span>
<span class="cp">#define I2O_PARAMS_STATUS_NON_DYNAMIC_GROUP	0x0C</span>
<span class="cp">#define I2O_PARAMS_STATUS_OPERATION_ERROR	0x0D</span>
<span class="cp">#define I2O_PARAMS_STATUS_SCALAR_ERROR		0x0E</span>
<span class="cp">#define I2O_PARAMS_STATUS_TABLE_ERROR		0x0F</span>
<span class="cp">#define I2O_PARAMS_STATUS_WRONG_GROUP_TYPE	0x10</span>

<span class="cm">/* DetailedStatusCode defines for Executive, DDM, Util and Transaction error</span>
<span class="cm"> * messages: Table 3-2 Detailed Status Codes.*/</span>

<span class="cp">#define I2O_DSC_SUCCESS                        0x0000</span>
<span class="cp">#define I2O_DSC_BAD_KEY                        0x0002</span>
<span class="cp">#define I2O_DSC_TCL_ERROR                      0x0003</span>
<span class="cp">#define I2O_DSC_REPLY_BUFFER_FULL              0x0004</span>
<span class="cp">#define I2O_DSC_NO_SUCH_PAGE                   0x0005</span>
<span class="cp">#define I2O_DSC_INSUFFICIENT_RESOURCE_SOFT     0x0006</span>
<span class="cp">#define I2O_DSC_INSUFFICIENT_RESOURCE_HARD     0x0007</span>
<span class="cp">#define I2O_DSC_CHAIN_BUFFER_TOO_LARGE         0x0009</span>
<span class="cp">#define I2O_DSC_UNSUPPORTED_FUNCTION           0x000A</span>
<span class="cp">#define I2O_DSC_DEVICE_LOCKED                  0x000B</span>
<span class="cp">#define I2O_DSC_DEVICE_RESET                   0x000C</span>
<span class="cp">#define I2O_DSC_INAPPROPRIATE_FUNCTION         0x000D</span>
<span class="cp">#define I2O_DSC_INVALID_INITIATOR_ADDRESS      0x000E</span>
<span class="cp">#define I2O_DSC_INVALID_MESSAGE_FLAGS          0x000F</span>
<span class="cp">#define I2O_DSC_INVALID_OFFSET                 0x0010</span>
<span class="cp">#define I2O_DSC_INVALID_PARAMETER              0x0011</span>
<span class="cp">#define I2O_DSC_INVALID_REQUEST                0x0012</span>
<span class="cp">#define I2O_DSC_INVALID_TARGET_ADDRESS         0x0013</span>
<span class="cp">#define I2O_DSC_MESSAGE_TOO_LARGE              0x0014</span>
<span class="cp">#define I2O_DSC_MESSAGE_TOO_SMALL              0x0015</span>
<span class="cp">#define I2O_DSC_MISSING_PARAMETER              0x0016</span>
<span class="cp">#define I2O_DSC_TIMEOUT                        0x0017</span>
<span class="cp">#define I2O_DSC_UNKNOWN_ERROR                  0x0018</span>
<span class="cp">#define I2O_DSC_UNKNOWN_FUNCTION               0x0019</span>
<span class="cp">#define I2O_DSC_UNSUPPORTED_VERSION            0x001A</span>
<span class="cp">#define I2O_DSC_DEVICE_BUSY                    0x001B</span>
<span class="cp">#define I2O_DSC_DEVICE_NOT_AVAILABLE           0x001C</span>

<span class="cm">/* DetailedStatusCode defines for Block Storage Operation: Table 6-7 Detailed</span>
<span class="cm">   Status Codes.*/</span>

<span class="cp">#define I2O_BSA_DSC_SUCCESS               0x0000</span>
<span class="cp">#define I2O_BSA_DSC_MEDIA_ERROR           0x0001</span>
<span class="cp">#define I2O_BSA_DSC_ACCESS_ERROR          0x0002</span>
<span class="cp">#define I2O_BSA_DSC_DEVICE_FAILURE        0x0003</span>
<span class="cp">#define I2O_BSA_DSC_DEVICE_NOT_READY      0x0004</span>
<span class="cp">#define I2O_BSA_DSC_MEDIA_NOT_PRESENT     0x0005</span>
<span class="cp">#define I2O_BSA_DSC_MEDIA_LOCKED          0x0006</span>
<span class="cp">#define I2O_BSA_DSC_MEDIA_FAILURE         0x0007</span>
<span class="cp">#define I2O_BSA_DSC_PROTOCOL_FAILURE      0x0008</span>
<span class="cp">#define I2O_BSA_DSC_BUS_FAILURE           0x0009</span>
<span class="cp">#define I2O_BSA_DSC_ACCESS_VIOLATION      0x000A</span>
<span class="cp">#define I2O_BSA_DSC_WRITE_PROTECTED       0x000B</span>
<span class="cp">#define I2O_BSA_DSC_DEVICE_RESET          0x000C</span>
<span class="cp">#define I2O_BSA_DSC_VOLUME_CHANGED        0x000D</span>
<span class="cp">#define I2O_BSA_DSC_TIMEOUT               0x000E</span>

<span class="cm">/* FailureStatusCodes, Table 3-3 Message Failure Codes */</span>

<span class="cp">#define I2O_FSC_TRANSPORT_SERVICE_SUSPENDED             0x81</span>
<span class="cp">#define I2O_FSC_TRANSPORT_SERVICE_TERMINATED            0x82</span>
<span class="cp">#define I2O_FSC_TRANSPORT_CONGESTION                    0x83</span>
<span class="cp">#define I2O_FSC_TRANSPORT_FAILURE                       0x84</span>
<span class="cp">#define I2O_FSC_TRANSPORT_STATE_ERROR                   0x85</span>
<span class="cp">#define I2O_FSC_TRANSPORT_TIME_OUT                      0x86</span>
<span class="cp">#define I2O_FSC_TRANSPORT_ROUTING_FAILURE               0x87</span>
<span class="cp">#define I2O_FSC_TRANSPORT_INVALID_VERSION               0x88</span>
<span class="cp">#define I2O_FSC_TRANSPORT_INVALID_OFFSET                0x89</span>
<span class="cp">#define I2O_FSC_TRANSPORT_INVALID_MSG_FLAGS             0x8A</span>
<span class="cp">#define I2O_FSC_TRANSPORT_FRAME_TOO_SMALL               0x8B</span>
<span class="cp">#define I2O_FSC_TRANSPORT_FRAME_TOO_LARGE               0x8C</span>
<span class="cp">#define I2O_FSC_TRANSPORT_INVALID_TARGET_ID             0x8D</span>
<span class="cp">#define I2O_FSC_TRANSPORT_INVALID_INITIATOR_ID          0x8E</span>
<span class="cp">#define I2O_FSC_TRANSPORT_INVALID_INITIATOR_CONTEXT     0x8F</span>
<span class="cp">#define I2O_FSC_TRANSPORT_UNKNOWN_FAILURE               0xFF</span>

<span class="cm">/* Device Claim Types */</span>
<span class="cp">#define	I2O_CLAIM_PRIMARY					0x01000000</span>
<span class="cp">#define	I2O_CLAIM_MANAGEMENT					0x02000000</span>
<span class="cp">#define	I2O_CLAIM_AUTHORIZED					0x03000000</span>
<span class="cp">#define	I2O_CLAIM_SECONDARY					0x04000000</span>

<span class="cm">/* Message header defines for VersionOffset */</span>
<span class="cp">#define I2OVER15	0x0001</span>
<span class="cp">#define I2OVER20	0x0002</span>

<span class="cm">/* Default is 1.5 */</span>
<span class="cp">#define I2OVERSION	I2OVER15</span>

<span class="cp">#define SGL_OFFSET_0    I2OVERSION</span>
<span class="cp">#define SGL_OFFSET_4    (0x0040 | I2OVERSION)</span>
<span class="cp">#define SGL_OFFSET_5    (0x0050 | I2OVERSION)</span>
<span class="cp">#define SGL_OFFSET_6    (0x0060 | I2OVERSION)</span>
<span class="cp">#define SGL_OFFSET_7    (0x0070 | I2OVERSION)</span>
<span class="cp">#define SGL_OFFSET_8    (0x0080 | I2OVERSION)</span>
<span class="cp">#define SGL_OFFSET_9    (0x0090 | I2OVERSION)</span>
<span class="cp">#define SGL_OFFSET_10   (0x00A0 | I2OVERSION)</span>
<span class="cp">#define SGL_OFFSET_11   (0x00B0 | I2OVERSION)</span>
<span class="cp">#define SGL_OFFSET_12   (0x00C0 | I2OVERSION)</span>
<span class="cp">#define SGL_OFFSET(x)   (((x)&lt;&lt;4) | I2OVERSION)</span>

<span class="cm">/* Transaction Reply Lists (TRL) Control Word structure */</span>
<span class="cp">#define TRL_SINGLE_FIXED_LENGTH		0x00</span>
<span class="cp">#define TRL_SINGLE_VARIABLE_LENGTH	0x40</span>
<span class="cp">#define TRL_MULTIPLE_FIXED_LENGTH	0x80</span>

 <span class="cm">/* msg header defines for MsgFlags */</span>
<span class="cp">#define MSG_STATIC	0x0100</span>
<span class="cp">#define MSG_64BIT_CNTXT	0x0200</span>
<span class="cp">#define MSG_MULTI_TRANS	0x1000</span>
<span class="cp">#define MSG_FAIL	0x2000</span>
<span class="cp">#define MSG_FINAL	0x4000</span>
<span class="cp">#define MSG_REPLY	0x8000</span>

 <span class="cm">/* minimum size msg */</span>
<span class="cp">#define THREE_WORD_MSG_SIZE	0x00030000</span>
<span class="cp">#define FOUR_WORD_MSG_SIZE	0x00040000</span>
<span class="cp">#define FIVE_WORD_MSG_SIZE	0x00050000</span>
<span class="cp">#define SIX_WORD_MSG_SIZE	0x00060000</span>
<span class="cp">#define SEVEN_WORD_MSG_SIZE	0x00070000</span>
<span class="cp">#define EIGHT_WORD_MSG_SIZE	0x00080000</span>
<span class="cp">#define NINE_WORD_MSG_SIZE	0x00090000</span>
<span class="cp">#define TEN_WORD_MSG_SIZE	0x000A0000</span>
<span class="cp">#define ELEVEN_WORD_MSG_SIZE	0x000B0000</span>
<span class="cp">#define I2O_MESSAGE_SIZE(x)	((x)&lt;&lt;16)</span>

<span class="cm">/* special TID assignments */</span>
<span class="cp">#define ADAPTER_TID		0</span>
<span class="cp">#define HOST_TID		1</span>

<span class="cm">/* outbound queue defines */</span>
<span class="cp">#define I2O_MAX_OUTBOUND_MSG_FRAMES	128</span>
<span class="cp">#define I2O_OUTBOUND_MSG_FRAME_SIZE	128	</span><span class="cm">/* in 32-bit words */</span><span class="cp"></span>

<span class="cm">/* inbound queue definitions */</span>
<span class="cp">#define I2O_MSG_INPOOL_MIN		32</span>
<span class="cp">#define I2O_INBOUND_MSG_FRAME_SIZE	128	</span><span class="cm">/* in 32-bit words */</span><span class="cp"></span>

<span class="cp">#define I2O_POST_WAIT_OK	0</span>
<span class="cp">#define I2O_POST_WAIT_TIMEOUT	-ETIMEDOUT</span>

<span class="cp">#define I2O_CONTEXT_LIST_MIN_LENGTH	15</span>
<span class="cp">#define I2O_CONTEXT_LIST_USED		0x01</span>
<span class="cp">#define I2O_CONTEXT_LIST_DELETED	0x02</span>

<span class="cm">/* timeouts */</span>
<span class="cp">#define I2O_TIMEOUT_INIT_OUTBOUND_QUEUE	15</span>
<span class="cp">#define I2O_TIMEOUT_MESSAGE_GET		5</span>
<span class="cp">#define I2O_TIMEOUT_RESET		30</span>
<span class="cp">#define I2O_TIMEOUT_STATUS_GET		5</span>
<span class="cp">#define I2O_TIMEOUT_LCT_GET		360</span>
<span class="cp">#define I2O_TIMEOUT_SCSI_SCB_ABORT	240</span>

<span class="cm">/* retries */</span>
<span class="cp">#define I2O_HRT_GET_TRIES		3</span>
<span class="cp">#define I2O_LCT_GET_TRIES		3</span>

<span class="cm">/* defines for max_sectors and max_phys_segments */</span>
<span class="cp">#define I2O_MAX_SECTORS			1024</span>
<span class="cp">#define I2O_MAX_SECTORS_LIMITED		128</span>
<span class="cp">#define I2O_MAX_PHYS_SEGMENTS		BLK_MAX_SEGMENTS</span>

<span class="cm">/*</span>
<span class="cm"> *	Message structures</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2o_message</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">version_offset</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
			<span class="n">u16</span> <span class="n">size</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">target_tid</span><span class="o">:</span><span class="mi">12</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">init_tid</span><span class="o">:</span><span class="mi">12</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">function</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">icntxt</span><span class="p">;</span>	<span class="cm">/* initiator context */</span>
			<span class="n">u32</span> <span class="n">tcntxt</span><span class="p">;</span>	<span class="cm">/* transaction context */</span>
		<span class="p">}</span> <span class="n">s</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">head</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="cm">/* List follows */</span>
	<span class="n">u32</span> <span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* MFA and I2O message used by mempool */</span>
<span class="k">struct</span> <span class="n">i2o_msg_mfa</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">mfa</span><span class="p">;</span>		<span class="cm">/* MFA returned by the controller */</span>
	<span class="k">struct</span> <span class="n">i2o_message</span> <span class="n">msg</span><span class="p">;</span>	<span class="cm">/* I2O message */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Each I2O device entity has one of these. There is one per device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2o_device</span> <span class="p">{</span>
	<span class="n">i2o_lct_entry</span> <span class="n">lct_data</span><span class="p">;</span>	<span class="cm">/* Device LCT information */</span>

	<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">iop</span><span class="p">;</span>	<span class="cm">/* Controlling IOP */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>	<span class="cm">/* node in IOP devices list */</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="n">device</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>	<span class="cm">/* device lock */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Event structure provided to the event handling function</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2o_event</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">i2o_dev</span><span class="p">;</span>	<span class="cm">/* I2O device pointer from which the</span>
<span class="cm">					   event reply was initiated */</span>
	<span class="n">u16</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* Size of data in 32-bit words */</span>
	<span class="n">u32</span> <span class="n">tcntxt</span><span class="p">;</span>		<span class="cm">/* Transaction context used at</span>
<span class="cm">				   registration */</span>
	<span class="n">u32</span> <span class="n">event_indicator</span><span class="p">;</span>	<span class="cm">/* Event indicator from reply */</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>		<span class="cm">/* Event data from reply */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	I2O classes which could be handled by the OSM</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2o_class_id</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">class_id</span><span class="o">:</span><span class="mi">12</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	I2O driver structure for OSMs</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2o_driver</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>		<span class="cm">/* OSM name */</span>
	<span class="kt">int</span> <span class="n">context</span><span class="p">;</span>		<span class="cm">/* Low 8 bits of the transaction info */</span>
	<span class="k">struct</span> <span class="n">i2o_class_id</span> <span class="o">*</span><span class="n">classes</span><span class="p">;</span>	<span class="cm">/* I2O classes that this OSM handles */</span>

	<span class="cm">/* Message reply handler */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">reply</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Event handler */</span>
	<span class="n">work_func_t</span> <span class="n">event</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">event_queue</span><span class="p">;</span>	<span class="cm">/* Event queue */</span>

	<span class="k">struct</span> <span class="n">device_driver</span> <span class="n">driver</span><span class="p">;</span>

	<span class="cm">/* notification of changes */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">notify_controller_add</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">notify_controller_remove</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">notify_device_add</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">notify_device_remove</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">semaphore</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Contains DMA mapped address information</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2o_dma</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">virt</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">phys</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Contains slab cache and mempool information</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2o_pool</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">slab</span><span class="p">;</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">mempool</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Contains IO mapped address information</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2o_io</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">virt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Context queue entry, used for 32-bit context on 64-bit systems</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2o_context_list_element</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">context</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Each I2O controller has one of these objects</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">unit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>	<span class="cm">/* PCI device */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">promise</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Promise controller */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">adaptec</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* DPT / Adaptec controller */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">raptor</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* split bar */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_quiesce</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* dont quiesce before reset */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">short_req</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* use small block sizes */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit_sectors</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* limit number of sectors / request */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pae_support</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* controller has 64-bit SGL support */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">devices</span><span class="p">;</span>	<span class="cm">/* list of I2O devices */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>	<span class="cm">/* Controller list */</span>

	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">in_port</span><span class="p">;</span>	<span class="cm">/* Inbout port address */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">out_port</span><span class="p">;</span>	<span class="cm">/* Outbound port address */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">irq_status</span><span class="p">;</span>	<span class="cm">/* Interrupt status register address */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">irq_mask</span><span class="p">;</span>	<span class="cm">/* Interrupt mask register address */</span>

	<span class="k">struct</span> <span class="n">i2o_dma</span> <span class="n">status</span><span class="p">;</span>	<span class="cm">/* IOP status block */</span>

	<span class="k">struct</span> <span class="n">i2o_dma</span> <span class="n">hrt</span><span class="p">;</span>	<span class="cm">/* HW Resource Table */</span>
	<span class="n">i2o_lct</span> <span class="o">*</span><span class="n">lct</span><span class="p">;</span>		<span class="cm">/* Logical Config Table */</span>
	<span class="k">struct</span> <span class="n">i2o_dma</span> <span class="n">dlct</span><span class="p">;</span>	<span class="cm">/* Temp LCT */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lct_lock</span><span class="p">;</span>	<span class="cm">/* Lock for LCT updates */</span>
	<span class="k">struct</span> <span class="n">i2o_dma</span> <span class="n">status_block</span><span class="p">;</span>	<span class="cm">/* IOP status block */</span>

	<span class="k">struct</span> <span class="n">i2o_io</span> <span class="n">base</span><span class="p">;</span>	<span class="cm">/* controller messaging unit */</span>
	<span class="k">struct</span> <span class="n">i2o_io</span> <span class="n">in_queue</span><span class="p">;</span>	<span class="cm">/* inbound message queue Host-&gt;IOP */</span>
	<span class="k">struct</span> <span class="n">i2o_dma</span> <span class="n">out_queue</span><span class="p">;</span>	<span class="cm">/* outbound message queue IOP-&gt;Host */</span>

	<span class="k">struct</span> <span class="n">i2o_pool</span> <span class="n">in_msg</span><span class="p">;</span>	<span class="cm">/* mempool for inbound messages */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">battery</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Has a battery backup */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">io_alloc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* An I/O resource was allocated */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mem_alloc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* A memory resource was allocated */</span>

	<span class="k">struct</span> <span class="n">resource</span> <span class="n">io_resource</span><span class="p">;</span>	<span class="cm">/* I/O resource allocated to the IOP */</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="n">mem_resource</span><span class="p">;</span>	<span class="cm">/* Mem resource allocated to the IOP */</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">exec</span><span class="p">;</span>	<span class="cm">/* Executive */</span>
<span class="cp">#if BITS_PER_LONG == 64</span>
	<span class="n">spinlock_t</span> <span class="n">context_list_lock</span><span class="p">;</span>	<span class="cm">/* lock for context_list */</span>
	<span class="n">atomic_t</span> <span class="n">context_list_counter</span><span class="p">;</span>	<span class="cm">/* needed for unique contexts */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">context_list</span><span class="p">;</span>	<span class="cm">/* list of context id&#39;s</span>
<span class="cm">					   and pointers */</span>
<span class="cp">#endif</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>	<span class="cm">/* lock for controller</span>
<span class="cm">				   configuration */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">driver_data</span><span class="p">[</span><span class="n">I2O_MAX_DRIVERS</span><span class="p">];</span>	<span class="cm">/* storage for drivers */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * I2O System table entry</span>
<span class="cm"> *</span>
<span class="cm"> * The system table contains information about all the IOPs in the</span>
<span class="cm"> * system.  It is sent to all IOPs so that they can create peer2peer</span>
<span class="cm"> * connections between them.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2o_sys_tbl_entry</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">org_id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">iop_id</span><span class="o">:</span><span class="mi">12</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved2</span><span class="o">:</span><span class="mi">20</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">seg_num</span><span class="o">:</span><span class="mi">12</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i2o_version</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">iop_state</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">msg_type</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">frame_size</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">reserved3</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_changed</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">iop_capabilities</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">inbound_low</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">inbound_high</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">i2o_sys_tbl</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">num_entries</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">version</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">reserved1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">change_ind</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved3</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_sys_tbl_entry</span> <span class="n">iops</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">i2o_controllers</span><span class="p">;</span>

<span class="cm">/* Message functions */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">i2o_msg_get_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2o_msg_post_wait_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2o_dma</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* IOP functions */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2o_status_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2o_event_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2o_driver</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
			      <span class="n">u32</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">i2o_iop_find_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">i2o_find_iop</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="cm">/* Functions needed for handling 64-bit pointers in 32-bit context */</span>
<span class="cp">#if BITS_PER_LONG == 64</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">i2o_cntxt_list_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">i2o_cntxt_list_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">i2o_cntxt_list_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">i2o_cntxt_list_get_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">i2o_ptr_low</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">i2o_ptr_high</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">ptr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">i2o_dma_low</span><span class="p">(</span><span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">dma_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">i2o_dma_high</span><span class="p">(</span><span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">dma_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">};</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">i2o_cntxt_list_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">i2o_cntxt_list_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u32</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">context</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">i2o_cntxt_list_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">i2o_cntxt_list_get_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">i2o_ptr_low</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">i2o_ptr_high</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">i2o_dma_low</span><span class="p">(</span><span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">dma_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">i2o_dma_high</span><span class="p">(</span><span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="n">u16</span> <span class="n">i2o_sg_tablesize</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u16</span> <span class="n">body_size</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">dma_addr_t</span> <span class="n">i2o_dma_map_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span>
					    <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					    <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
					    <span class="n">u32</span> <span class="o">**</span> <span class="n">sg_ptr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2o_dma_map_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sg_count</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="o">**</span> <span class="n">sg_ptr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2o_dma_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2o_dma</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2o_dma_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2o_dma</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2o_dma_realloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2o_dma</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
								<span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2o_pool_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_nr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2o_pool_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">);</span>
<span class="cm">/* I2O driver (OSM) functions */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2o_driver_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_driver</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2o_driver_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_driver</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_driver_notify_controller_add - Send notification of added controller</span>
<span class="cm"> *	@drv: I2O driver</span>
<span class="cm"> *	@c: I2O controller</span>
<span class="cm"> *</span>
<span class="cm"> *	Send notification of added controller to a single registered driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i2o_driver_notify_controller_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">notify_controller_add</span><span class="p">)</span>
		<span class="n">drv</span><span class="o">-&gt;</span><span class="n">notify_controller_add</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_driver_notify_controller_remove - Send notification of removed controller</span>
<span class="cm"> *	@drv: I2O driver</span>
<span class="cm"> *	@c: I2O controller</span>
<span class="cm"> *</span>
<span class="cm"> *	Send notification of removed controller to a single registered driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i2o_driver_notify_controller_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span>
						       <span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">notify_controller_remove</span><span class="p">)</span>
		<span class="n">drv</span><span class="o">-&gt;</span><span class="n">notify_controller_remove</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_driver_notify_device_add - Send notification of added device</span>
<span class="cm"> *	@drv: I2O driver</span>
<span class="cm"> *	@i2o_dev: the added i2o_device</span>
<span class="cm"> *</span>
<span class="cm"> *	Send notification of added device to a single registered driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i2o_driver_notify_device_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">i2o_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">notify_device_add</span><span class="p">)</span>
		<span class="n">drv</span><span class="o">-&gt;</span><span class="n">notify_device_add</span><span class="p">(</span><span class="n">i2o_dev</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_driver_notify_device_remove - Send notification of removed device</span>
<span class="cm"> *	@drv: I2O driver</span>
<span class="cm"> *	@i2o_dev: the added i2o_device</span>
<span class="cm"> *</span>
<span class="cm"> *	Send notification of removed device to a single registered driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i2o_driver_notify_device_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">i2o_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">notify_device_remove</span><span class="p">)</span>
		<span class="n">drv</span><span class="o">-&gt;</span><span class="n">notify_device_remove</span><span class="p">(</span><span class="n">i2o_dev</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2o_driver_notify_controller_add_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2o_driver_notify_controller_remove_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2o_driver_notify_device_add_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2o_driver_notify_device_remove_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* I2O device functions */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2o_device_claim</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2o_device_claim_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Exec OSM functions */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2o_exec_lct_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* device / driver / kobject conversion functions */</span>
<span class="cp">#define to_i2o_driver(drv) container_of(drv,struct i2o_driver, driver)</span>
<span class="cp">#define to_i2o_device(dev) container_of(dev, struct i2o_device, device)</span>
<span class="cp">#define to_i2o_controller(dev) container_of(dev, struct i2o_controller, device)</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_out_to_virt - Turn an I2O message to a virtual address</span>
<span class="cm"> *	@c: controller</span>
<span class="cm"> *	@m: message engine value</span>
<span class="cm"> *</span>
<span class="cm"> *	Turn a receive message from an I2O controller bus address into</span>
<span class="cm"> *	a Linux virtual address. The shared page frame is a linear block</span>
<span class="cm"> *	so we simply have to shift the offset. This function does not</span>
<span class="cm"> *	work for sender side messages as they are ioremap objects</span>
<span class="cm"> *	provided by the I2O controller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="nf">i2o_msg_out_to_virt</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
						      <span class="n">u32</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">out_queue</span><span class="p">.</span><span class="n">phys</span>
	       <span class="o">||</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">out_queue</span><span class="p">.</span><span class="n">phys</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">out_queue</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">out_queue</span><span class="p">.</span><span class="n">virt</span> <span class="o">+</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">out_queue</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_msg_in_to_virt - Turn an I2O message to a virtual address</span>
<span class="cm"> *	@c: controller</span>
<span class="cm"> *	@m: message engine value</span>
<span class="cm"> *</span>
<span class="cm"> *	Turn a send message from an I2O controller bus address into</span>
<span class="cm"> *	a Linux virtual address. The shared page frame is a linear block</span>
<span class="cm"> *	so we simply have to shift the offset. This function does not</span>
<span class="cm"> *	work for receive side messages as they are kmalloc objects</span>
<span class="cm"> *	in a different pool.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">i2o_message</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">i2o_msg_in_to_virt</span><span class="p">(</span><span class="k">struct</span>
							     <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
							     <span class="n">u32</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">in_queue</span><span class="p">.</span><span class="n">virt</span> <span class="o">+</span> <span class="n">m</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_msg_get - obtain an I2O message from the IOP</span>
<span class="cm"> *	@c: I2O controller</span>
<span class="cm"> *</span>
<span class="cm"> *	This function tries to get a message frame. If no message frame is</span>
<span class="cm"> *	available do not wait until one is available (see also i2o_msg_get_wait).</span>
<span class="cm"> *	The returned pointer to the message frame is not in I/O memory, it is</span>
<span class="cm"> *	allocated from a mempool. But because a MFA is allocated from the</span>
<span class="cm"> *	controller too it is guaranteed that i2o_msg_post() will never fail.</span>
<span class="cm"> *</span>
<span class="cm"> *	On a success a pointer to the message frame is returned. If the message</span>
<span class="cm"> *	queue is empty -EBUSY is returned and if no memory is available -ENOMEM</span>
<span class="cm"> *	is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="nf">i2o_msg_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_msg_mfa</span> <span class="o">*</span><span class="n">mmsg</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">in_msg</span><span class="p">.</span><span class="n">mempool</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mmsg</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">mmsg</span><span class="o">-&gt;</span><span class="n">mfa</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">in_port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mmsg</span><span class="o">-&gt;</span><span class="n">mfa</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">in_queue</span><span class="p">.</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">mfa</span> <span class="o">=</span> <span class="n">mmsg</span><span class="o">-&gt;</span><span class="n">mfa</span><span class="p">;</span>

		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mmsg</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">in_msg</span><span class="p">.</span><span class="n">mempool</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mfa</span> <span class="o">==</span> <span class="n">I2O_QUEUE_EMPTY</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EBUSY</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">mmsg</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_msg_post - Post I2O message to I2O controller</span>
<span class="cm"> *	@c: I2O controller to which the message should be send</span>
<span class="cm"> *	@msg: message returned by i2o_msg_get()</span>
<span class="cm"> *</span>
<span class="cm"> *	Post the message to the I2O controller and return immediately.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i2o_msg_post</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_msg_mfa</span> <span class="o">*</span><span class="n">mmsg</span><span class="p">;</span>

	<span class="n">mmsg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2o_msg_mfa</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">i2o_msg_in_to_virt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">mmsg</span><span class="o">-&gt;</span><span class="n">mfa</span><span class="p">),</span> <span class="n">msg</span><span class="p">,</span>
		    <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mmsg</span><span class="o">-&gt;</span><span class="n">mfa</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">in_port</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mmsg</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">in_msg</span><span class="p">.</span><span class="n">mempool</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * 	i2o_msg_post_wait - Post and wait a message and wait until return</span>
<span class="cm"> *	@c: controller</span>
<span class="cm"> *	@msg: message to post</span>
<span class="cm"> *	@timeout: time in seconds to wait</span>
<span class="cm"> *</span>
<span class="cm"> * 	This API allows an OSM to post a message and then be told whether or</span>
<span class="cm"> *	not the system received a successful reply. If the message times out</span>
<span class="cm"> *	then the value &#39;-ETIMEDOUT&#39; is returned.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">i2o_msg_post_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">i2o_msg_post_wait_mem</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_msg_nop_mfa - Returns a fetched MFA back to the controller</span>
<span class="cm"> *	@c: I2O controller from which the MFA was fetched</span>
<span class="cm"> *	@mfa: MFA which should be returned</span>
<span class="cm"> *</span>
<span class="cm"> *	This function must be used for preserved messages, because i2o_msg_nop()</span>
<span class="cm"> *	also returns the allocated memory back to the msg_pool mempool.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i2o_msg_nop_mfa</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mfa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_message</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nop</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">THREE_WORD_MSG_SIZE</span> <span class="o">|</span> <span class="n">SGL_OFFSET_0</span><span class="p">,</span>
		<span class="n">I2O_CMD_UTIL_NOP</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> <span class="n">HOST_TID</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span> <span class="n">ADAPTER_TID</span><span class="p">,</span>
		<span class="mh">0x00000000</span>
	<span class="p">};</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">i2o_msg_in_to_virt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">mfa</span><span class="p">);</span>
	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">nop</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nop</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mfa</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">in_port</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_msg_nop - Returns a message which is not used</span>
<span class="cm"> *	@c: I2O controller from which the message was created</span>
<span class="cm"> *	@msg: message which should be returned</span>
<span class="cm"> *</span>
<span class="cm"> *	If you fetch a message via i2o_msg_get, and can&#39;t use it, you must</span>
<span class="cm"> *	return the message with this function. Otherwise the MFA is lost as well</span>
<span class="cm"> *	as the allocated memory from the mempool.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i2o_msg_nop</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_msg_mfa</span> <span class="o">*</span><span class="n">mmsg</span><span class="p">;</span>
	<span class="n">mmsg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2o_msg_mfa</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="n">i2o_msg_nop_mfa</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">mmsg</span><span class="o">-&gt;</span><span class="n">mfa</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mmsg</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">in_msg</span><span class="p">.</span><span class="n">mempool</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_flush_reply - Flush reply from I2O controller</span>
<span class="cm"> *	@c: I2O controller</span>
<span class="cm"> *	@m: the message identifier</span>
<span class="cm"> *</span>
<span class="cm"> *	The I2O controller must be informed that the reply message is not needed</span>
<span class="cm"> *	anymore. If you forget to flush the reply, the message frame can&#39;t be</span>
<span class="cm"> *	used by the controller anymore and is therefore lost.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i2o_flush_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u32</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">out_port</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Endian handling wrapped into the macro - keeps the core code</span>
<span class="cm"> *	cleaner.</span>
<span class="cm"> */</span>

<span class="cp">#define i2o_raw_writel(val, mem)	__raw_writel(cpu_to_le32(val), mem)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2o_parm_field_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2o_parm_table_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/* debugging and troubleshooting/diagnostic helpers. */</span>
<span class="cp">#define osm_printk(level, format, arg...)  \</span>
<span class="cp">	printk(level &quot;%s: &quot; format, OSM_NAME , ## arg)</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define osm_debug(format, arg...) \</span>
<span class="cp">	osm_printk(KERN_DEBUG, format , ## arg)</span>
<span class="cp">#else</span>
<span class="cp">#define osm_debug(format, arg...) \</span>
<span class="cp">        do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#define osm_err(format, arg...)		\</span>
<span class="cp">	osm_printk(KERN_ERR, format , ## arg)</span>
<span class="cp">#define osm_info(format, arg...)		\</span>
<span class="cp">	osm_printk(KERN_INFO, format , ## arg)</span>
<span class="cp">#define osm_warn(format, arg...)		\</span>
<span class="cp">	osm_printk(KERN_WARNING, format , ## arg)</span>

<span class="cm">/* debugging functions */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2o_report_status</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2o_dump_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2o_dump_hrt</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2o_debug_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="cp">#endif				</span><span class="cm">/* _I2O_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
