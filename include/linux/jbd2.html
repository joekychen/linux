<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › jbd2.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>jbd2.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/include/linux/jbd2.h</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Stephen C. Tweedie &lt;sct@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1998-2000 Red Hat, Inc --- All Rights Reserved</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the Linux kernel and is made available under</span>
<span class="cm"> * the terms of the GNU General Public License, version 2, or at your</span>
<span class="cm"> * option, any later version, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> * Definitions for transaction data structures for the buffer cache</span>
<span class="cm"> * filesystem journaling support.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_JBD2_H</span>
<span class="cp">#define _LINUX_JBD2_H</span>

<span class="cm">/* Allow this file to be included directly into e2fsprogs */</span>
<span class="cp">#ifndef __KERNEL__</span>
<span class="cp">#include &quot;jfs_compat.h&quot;</span>
<span class="cp">#define JBD2_DEBUG</span>
<span class="cp">#define jfs_debug jbd_debug</span>
<span class="cp">#else</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/journal-head.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/bit_spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;crypto/hash.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#define journal_oom_retry 1</span>

<span class="cm">/*</span>
<span class="cm"> * Define JBD2_PARANIOD_IOFAIL to cause a kernel BUG() if ext4 finds</span>
<span class="cm"> * certain classes of error which can occur due to failed IOs.  Under</span>
<span class="cm"> * normal use we want ext4 to continue after such errors, because</span>
<span class="cm"> * hardware _can_ fail, but for debugging purposes when running tests on</span>
<span class="cm"> * known-good hardware we may want to trap these errors.</span>
<span class="cm"> */</span>
<span class="cp">#undef JBD2_PARANOID_IOFAIL</span>

<span class="cm">/*</span>
<span class="cm"> * The default maximum commit age, in seconds.</span>
<span class="cm"> */</span>
<span class="cp">#define JBD2_DEFAULT_MAX_COMMIT_AGE 5</span>

<span class="cp">#ifdef CONFIG_JBD2_DEBUG</span>
<span class="cm">/*</span>
<span class="cm"> * Define JBD2_EXPENSIVE_CHECKING to enable more expensive internal</span>
<span class="cm"> * consistency checks.  By default we don&#39;t do this unless</span>
<span class="cm"> * CONFIG_JBD2_DEBUG is on.</span>
<span class="cm"> */</span>
<span class="cp">#define JBD2_EXPENSIVE_CHECKING</span>
<span class="k">extern</span> <span class="n">u8</span> <span class="n">jbd2_journal_enable_debug</span><span class="p">;</span>

<span class="cp">#define jbd_debug(n, f, a...)						\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if ((n) &lt;= jbd2_journal_enable_debug) {			\</span>
<span class="cp">			printk (KERN_DEBUG &quot;(%s, %d): %s: &quot;,		\</span>
<span class="cp">				__FILE__, __LINE__, __func__);	\</span>
<span class="cp">			printk (f, ## a);				\</span>
<span class="cp">		}							\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define jbd_debug(f, a...)	</span><span class="cm">/**/</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">jbd2_alloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">jbd2_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cp">#define JBD2_MIN_JOURNAL_BLOCKS 1024</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/**</span>
<span class="cm"> * typedef handle_t - The handle_t type represents a single atomic update being performed by some process.</span>
<span class="cm"> *</span>
<span class="cm"> * All filesystem modifications made by the process go</span>
<span class="cm"> * through this handle.  Recursive operations (such as quota operations)</span>
<span class="cm"> * are gathered into a single update.</span>
<span class="cm"> *</span>
<span class="cm"> * The buffer credits field is used to account for journaled buffers</span>
<span class="cm"> * being modified by the running process.  To ensure that there is</span>
<span class="cm"> * enough log space for all outstanding operations, we need to limit the</span>
<span class="cm"> * number of outstanding buffers possible at any time.  When the</span>
<span class="cm"> * operation completes, any buffer credits not used are credited back to</span>
<span class="cm"> * the transaction, so that at all times we know how many buffers the</span>
<span class="cm"> * outstanding updates on a transaction might possibly touch.</span>
<span class="cm"> *</span>
<span class="cm"> * This is an opaque datatype.</span>
<span class="cm"> **/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">jbd2_journal_handle</span> <span class="n">handle_t</span><span class="p">;</span>	<span class="cm">/* Atomic operation type */</span>


<span class="cm">/**</span>
<span class="cm"> * typedef journal_t - The journal_t maintains all of the journaling state information for a single filesystem.</span>
<span class="cm"> *</span>
<span class="cm"> * journal_t is linked to from the fs superblock structure.</span>
<span class="cm"> *</span>
<span class="cm"> * We use the journal_t to keep track of all outstanding transaction</span>
<span class="cm"> * activity on the filesystem, and to manage the state of the log</span>
<span class="cm"> * writing process.</span>
<span class="cm"> *</span>
<span class="cm"> * This is an opaque datatype.</span>
<span class="cm"> **/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">journal_s</span>	<span class="n">journal_t</span><span class="p">;</span>	<span class="cm">/* Journal control structure */</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Internal structures used by the logging mechanism:</span>
<span class="cm"> */</span>

<span class="cp">#define JBD2_MAGIC_NUMBER 0xc03b3998U </span><span class="cm">/* The first 4 bytes of /dev/random! */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * On-disk structures</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Descriptor block types:</span>
<span class="cm"> */</span>

<span class="cp">#define JBD2_DESCRIPTOR_BLOCK	1</span>
<span class="cp">#define JBD2_COMMIT_BLOCK	2</span>
<span class="cp">#define JBD2_SUPERBLOCK_V1	3</span>
<span class="cp">#define JBD2_SUPERBLOCK_V2	4</span>
<span class="cp">#define JBD2_REVOKE_BLOCK	5</span>

<span class="cm">/*</span>
<span class="cm"> * Standard header for all descriptor blocks:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">journal_header_s</span>
<span class="p">{</span>
	<span class="n">__be32</span>		<span class="n">h_magic</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">h_blocktype</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">h_sequence</span><span class="p">;</span>
<span class="p">}</span> <span class="n">journal_header_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Checksum types.</span>
<span class="cm"> */</span>
<span class="cp">#define JBD2_CRC32_CHKSUM   1</span>
<span class="cp">#define JBD2_MD5_CHKSUM     2</span>
<span class="cp">#define JBD2_SHA1_CHKSUM    3</span>
<span class="cp">#define JBD2_CRC32C_CHKSUM  4</span>

<span class="cp">#define JBD2_CRC32_CHKSUM_SIZE 4</span>

<span class="cp">#define JBD2_CHECKSUM_BYTES (32 / sizeof(u32))</span>
<span class="cm">/*</span>
<span class="cm"> * Commit block header for storing transactional checksums:</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: If FEATURE_COMPAT_CHECKSUM (checksum v1) is set, the h_chksum*</span>
<span class="cm"> * fields are used to store a checksum of the descriptor and data blocks.</span>
<span class="cm"> *</span>
<span class="cm"> * If FEATURE_INCOMPAT_CSUM_V2 (checksum v2) is set, then the h_chksum</span>
<span class="cm"> * field is used to store crc32c(uuid+commit_block).  Each journal metadata</span>
<span class="cm"> * block gets its own checksum, and data block checksums are stored in</span>
<span class="cm"> * journal_block_tag (in the descriptor).  The other h_chksum* fields are</span>
<span class="cm"> * not used.</span>
<span class="cm"> *</span>
<span class="cm"> * Checksum v1 and v2 are mutually exclusive features.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">commit_header</span> <span class="p">{</span>
	<span class="n">__be32</span>		<span class="n">h_magic</span><span class="p">;</span>
	<span class="n">__be32</span>          <span class="n">h_blocktype</span><span class="p">;</span>
	<span class="n">__be32</span>          <span class="n">h_sequence</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>   <span class="n">h_chksum_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>   <span class="n">h_chksum_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> 	<span class="n">h_padding</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__be32</span> 		<span class="n">h_chksum</span><span class="p">[</span><span class="n">JBD2_CHECKSUM_BYTES</span><span class="p">];</span>
	<span class="n">__be64</span>		<span class="n">h_commit_sec</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">h_commit_nsec</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The block tag: used to describe a single buffer in the journal.</span>
<span class="cm"> * t_blocknr_high is only used if INCOMPAT_64BIT is set, so this</span>
<span class="cm"> * raw struct shouldn&#39;t be used for pointer math or sizeof() - use</span>
<span class="cm"> * journal_tag_bytes(journal) instead to compute this.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">journal_block_tag_s</span>
<span class="p">{</span>
	<span class="n">__be32</span>		<span class="n">t_blocknr</span><span class="p">;</span>	<span class="cm">/* The on-disk block number */</span>
	<span class="n">__be16</span>		<span class="n">t_checksum</span><span class="p">;</span>	<span class="cm">/* truncated crc32c(uuid+seq+block) */</span>
	<span class="n">__be16</span>		<span class="n">t_flags</span><span class="p">;</span>	<span class="cm">/* See below */</span>
	<span class="n">__be32</span>		<span class="n">t_blocknr_high</span><span class="p">;</span> <span class="cm">/* most-significant high 32bits. */</span>
<span class="p">}</span> <span class="n">journal_block_tag_t</span><span class="p">;</span>

<span class="cp">#define JBD2_TAG_SIZE32 (offsetof(journal_block_tag_t, t_blocknr_high))</span>
<span class="cp">#define JBD2_TAG_SIZE64 (sizeof(journal_block_tag_t))</span>

<span class="cm">/* Tail of descriptor block, for checksumming */</span>
<span class="k">struct</span> <span class="n">jbd2_journal_block_tail</span> <span class="p">{</span>
	<span class="n">__be32</span>		<span class="n">t_checksum</span><span class="p">;</span>	<span class="cm">/* crc32c(uuid+descr_block) */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The revoke descriptor: used on disk to describe a series of blocks to</span>
<span class="cm"> * be revoked from the log</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">jbd2_journal_revoke_header_s</span>
<span class="p">{</span>
	<span class="n">journal_header_t</span> <span class="n">r_header</span><span class="p">;</span>
	<span class="n">__be32</span>		 <span class="n">r_count</span><span class="p">;</span>	<span class="cm">/* Count of bytes used in the block */</span>
<span class="p">}</span> <span class="n">jbd2_journal_revoke_header_t</span><span class="p">;</span>

<span class="cm">/* Tail of revoke block, for checksumming */</span>
<span class="k">struct</span> <span class="n">jbd2_journal_revoke_tail</span> <span class="p">{</span>
	<span class="n">__be32</span>		<span class="n">r_checksum</span><span class="p">;</span>	<span class="cm">/* crc32c(uuid+revoke_block) */</span>
<span class="p">};</span>

<span class="cm">/* Definitions for the journal tag flags word: */</span>
<span class="cp">#define JBD2_FLAG_ESCAPE		1	</span><span class="cm">/* on-disk block is escaped */</span><span class="cp"></span>
<span class="cp">#define JBD2_FLAG_SAME_UUID	2	</span><span class="cm">/* block has same uuid as previous */</span><span class="cp"></span>
<span class="cp">#define JBD2_FLAG_DELETED	4	</span><span class="cm">/* block deleted by this transaction */</span><span class="cp"></span>
<span class="cp">#define JBD2_FLAG_LAST_TAG	8	</span><span class="cm">/* last tag in this descriptor block */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * The journal superblock.  All fields are in big-endian byte order.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">journal_superblock_s</span>
<span class="p">{</span>
<span class="cm">/* 0x0000 */</span>
	<span class="n">journal_header_t</span> <span class="n">s_header</span><span class="p">;</span>

<span class="cm">/* 0x000C */</span>
	<span class="cm">/* Static information describing the journal */</span>
	<span class="n">__be32</span>	<span class="n">s_blocksize</span><span class="p">;</span>		<span class="cm">/* journal device blocksize */</span>
	<span class="n">__be32</span>	<span class="n">s_maxlen</span><span class="p">;</span>		<span class="cm">/* total blocks in journal file */</span>
	<span class="n">__be32</span>	<span class="n">s_first</span><span class="p">;</span>		<span class="cm">/* first block of log information */</span>

<span class="cm">/* 0x0018 */</span>
	<span class="cm">/* Dynamic information describing the current state of the log */</span>
	<span class="n">__be32</span>	<span class="n">s_sequence</span><span class="p">;</span>		<span class="cm">/* first commit ID expected in log */</span>
	<span class="n">__be32</span>	<span class="n">s_start</span><span class="p">;</span>		<span class="cm">/* blocknr of start of log */</span>

<span class="cm">/* 0x0020 */</span>
	<span class="cm">/* Error value, as set by jbd2_journal_abort(). */</span>
	<span class="n">__be32</span>	<span class="n">s_errno</span><span class="p">;</span>

<span class="cm">/* 0x0024 */</span>
	<span class="cm">/* Remaining fields are only valid in a version-2 superblock */</span>
	<span class="n">__be32</span>	<span class="n">s_feature_compat</span><span class="p">;</span>	<span class="cm">/* compatible feature set */</span>
	<span class="n">__be32</span>	<span class="n">s_feature_incompat</span><span class="p">;</span>	<span class="cm">/* incompatible feature set */</span>
	<span class="n">__be32</span>	<span class="n">s_feature_ro_compat</span><span class="p">;</span>	<span class="cm">/* readonly-compatible feature set */</span>
<span class="cm">/* 0x0030 */</span>
	<span class="n">__u8</span>	<span class="n">s_uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>		<span class="cm">/* 128-bit uuid for journal */</span>

<span class="cm">/* 0x0040 */</span>
	<span class="n">__be32</span>	<span class="n">s_nr_users</span><span class="p">;</span>		<span class="cm">/* Nr of filesystems sharing log */</span>

	<span class="n">__be32</span>	<span class="n">s_dynsuper</span><span class="p">;</span>		<span class="cm">/* Blocknr of dynamic superblock copy*/</span>

<span class="cm">/* 0x0048 */</span>
	<span class="n">__be32</span>	<span class="n">s_max_transaction</span><span class="p">;</span>	<span class="cm">/* Limit of journal blocks per trans.*/</span>
	<span class="n">__be32</span>	<span class="n">s_max_trans_data</span><span class="p">;</span>	<span class="cm">/* Limit of data blocks per trans. */</span>

<span class="cm">/* 0x0050 */</span>
	<span class="n">__u8</span>	<span class="n">s_checksum_type</span><span class="p">;</span>	<span class="cm">/* checksum type */</span>
	<span class="n">__u8</span>	<span class="n">s_padding2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">__u32</span>	<span class="n">s_padding</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span>
	<span class="n">__be32</span>	<span class="n">s_checksum</span><span class="p">;</span>		<span class="cm">/* crc32c(superblock) */</span>

<span class="cm">/* 0x0100 */</span>
	<span class="n">__u8</span>	<span class="n">s_users</span><span class="p">[</span><span class="mi">16</span><span class="o">*</span><span class="mi">48</span><span class="p">];</span>		<span class="cm">/* ids of all fs&#39;es sharing the log */</span>
<span class="cm">/* 0x0400 */</span>
<span class="p">}</span> <span class="n">journal_superblock_t</span><span class="p">;</span>

<span class="cp">#define JBD2_HAS_COMPAT_FEATURE(j,mask)					\</span>
<span class="cp">	((j)-&gt;j_format_version &gt;= 2 &amp;&amp;					\</span>
<span class="cp">	 ((j)-&gt;j_superblock-&gt;s_feature_compat &amp; cpu_to_be32((mask))))</span>
<span class="cp">#define JBD2_HAS_RO_COMPAT_FEATURE(j,mask)				\</span>
<span class="cp">	((j)-&gt;j_format_version &gt;= 2 &amp;&amp;					\</span>
<span class="cp">	 ((j)-&gt;j_superblock-&gt;s_feature_ro_compat &amp; cpu_to_be32((mask))))</span>
<span class="cp">#define JBD2_HAS_INCOMPAT_FEATURE(j,mask)				\</span>
<span class="cp">	((j)-&gt;j_format_version &gt;= 2 &amp;&amp;					\</span>
<span class="cp">	 ((j)-&gt;j_superblock-&gt;s_feature_incompat &amp; cpu_to_be32((mask))))</span>

<span class="cp">#define JBD2_FEATURE_COMPAT_CHECKSUM	0x00000001</span>

<span class="cp">#define JBD2_FEATURE_INCOMPAT_REVOKE		0x00000001</span>
<span class="cp">#define JBD2_FEATURE_INCOMPAT_64BIT		0x00000002</span>
<span class="cp">#define JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT	0x00000004</span>
<span class="cp">#define JBD2_FEATURE_INCOMPAT_CSUM_V2		0x00000008</span>

<span class="cm">/* Features known to this kernel version: */</span>
<span class="cp">#define JBD2_KNOWN_COMPAT_FEATURES	JBD2_FEATURE_COMPAT_CHECKSUM</span>
<span class="cp">#define JBD2_KNOWN_ROCOMPAT_FEATURES	0</span>
<span class="cp">#define JBD2_KNOWN_INCOMPAT_FEATURES	(JBD2_FEATURE_INCOMPAT_REVOKE | \</span>
<span class="cp">					JBD2_FEATURE_INCOMPAT_64BIT | \</span>
<span class="cp">					JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT | \</span>
<span class="cp">					JBD2_FEATURE_INCOMPAT_CSUM_V2)</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/jbd_common.h&gt;</span>

<span class="cp">#define J_ASSERT(assert)	BUG_ON(!(assert))</span>

<span class="cp">#define J_ASSERT_BH(bh, expr)	J_ASSERT(expr)</span>
<span class="cp">#define J_ASSERT_JH(jh, expr)	J_ASSERT(expr)</span>

<span class="cp">#if defined(JBD2_PARANOID_IOFAIL)</span>
<span class="cp">#define J_EXPECT(expr, why...)		J_ASSERT(expr)</span>
<span class="cp">#define J_EXPECT_BH(bh, expr, why...)	J_ASSERT_BH(bh, expr)</span>
<span class="cp">#define J_EXPECT_JH(jh, expr, why...)	J_ASSERT_JH(jh, expr)</span>
<span class="cp">#else</span>
<span class="cp">#define __journal_expect(expr, why...)					     \</span>
<span class="cp">	({								     \</span>
<span class="cp">		int val = (expr);					     \</span>
<span class="cp">		if (!val) {						     \</span>
<span class="cp">			printk(KERN_ERR					     \</span>
<span class="cp">			       &quot;JBD2 unexpected failure: %s: %s;\n&quot;,	     \</span>
<span class="cp">			       __func__, #expr);			     \</span>
<span class="cp">			printk(KERN_ERR why &quot;\n&quot;);			     \</span>
<span class="cp">		}							     \</span>
<span class="cp">		val;							     \</span>
<span class="cp">	})</span>
<span class="cp">#define J_EXPECT(expr, why...)		__journal_expect(expr, ## why)</span>
<span class="cp">#define J_EXPECT_BH(bh, expr, why...)	__journal_expect(expr, ## why)</span>
<span class="cp">#define J_EXPECT_JH(jh, expr, why...)	__journal_expect(expr, ## why)</span>
<span class="cp">#endif</span>

<span class="cm">/* Flags in jbd_inode-&gt;i_flags */</span>
<span class="cp">#define __JI_COMMIT_RUNNING 0</span>
<span class="cm">/* Commit of the inode data in progress. We use this flag to protect us from</span>
<span class="cm"> * concurrent deletion of inode. We cannot use reference to inode for this</span>
<span class="cm"> * since we cannot afford doing last iput() on behalf of kjournald</span>
<span class="cm"> */</span>
<span class="cp">#define JI_COMMIT_RUNNING (1 &lt;&lt; __JI_COMMIT_RUNNING)</span>

<span class="cm">/**</span>
<span class="cm"> * struct jbd_inode is the structure linking inodes in ordered mode</span>
<span class="cm"> *   present in a transaction so that we can sync them during commit.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">jbd2_inode</span> <span class="p">{</span>
	<span class="cm">/* Which transaction does this inode belong to? Either the running</span>
<span class="cm">	 * transaction or the committing one. [j_list_lock] */</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">i_transaction</span><span class="p">;</span>

	<span class="cm">/* Pointer to the running transaction modifying inode&#39;s data in case</span>
<span class="cm">	 * there is already a committing transaction touching it. [j_list_lock] */</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">i_next_transaction</span><span class="p">;</span>

	<span class="cm">/* List of inodes in the i_transaction [j_list_lock] */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">i_list</span><span class="p">;</span>

	<span class="cm">/* VFS inode this inode belongs to [constant during the lifetime</span>
<span class="cm">	 * of the structure] */</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">i_vfs_inode</span><span class="p">;</span>

	<span class="cm">/* Flags of inode [j_list_lock] */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i_flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">jbd2_revoke_table_s</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct handle_s - The handle_s type is the concrete type associated with</span>
<span class="cm"> *     handle_t.</span>
<span class="cm"> * @h_transaction: Which compound transaction is this update a part of?</span>
<span class="cm"> * @h_buffer_credits: Number of remaining buffers we are allowed to dirty.</span>
<span class="cm"> * @h_ref: Reference count on this handle</span>
<span class="cm"> * @h_err: Field for caller&#39;s use to track errors through large fs operations</span>
<span class="cm"> * @h_sync: flag for sync-on-close</span>
<span class="cm"> * @h_jdata: flag to force data journaling</span>
<span class="cm"> * @h_aborted: flag indicating fatal error on handle</span>
<span class="cm"> **/</span>

<span class="cm">/* Docbook can&#39;t yet cope with the bit fields, but will leave the documentation</span>
<span class="cm"> * in so it can be fixed later.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">jbd2_journal_handle</span>
<span class="p">{</span>
	<span class="cm">/* Which compound transaction is this update a part of? */</span>
	<span class="n">transaction_t</span>		<span class="o">*</span><span class="n">h_transaction</span><span class="p">;</span>

	<span class="cm">/* Number of remaining buffers we are allowed to dirty: */</span>
	<span class="kt">int</span>			<span class="n">h_buffer_credits</span><span class="p">;</span>

	<span class="cm">/* Reference count on this handle */</span>
	<span class="kt">int</span>			<span class="n">h_ref</span><span class="p">;</span>

	<span class="cm">/* Field for caller&#39;s use to track errors through large fs */</span>
	<span class="cm">/* operations */</span>
	<span class="kt">int</span>			<span class="n">h_err</span><span class="p">;</span>

	<span class="cm">/* Flags [no locking] */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">h_sync</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* sync-on-close */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">h_jdata</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* force data journaling */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">h_aborted</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* fatal error on handle */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">h_cowing</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* COWing block to snapshot */</span>

	<span class="cm">/* Number of buffers requested by user:</span>
<span class="cm">	 * (before adding the COW credits factor) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">h_base_credits</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>

	<span class="cm">/* Number of buffers the user is allowed to dirty:</span>
<span class="cm">	 * (counts only buffers dirtied when !h_cowing) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">h_user_credits</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>


<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
	<span class="k">struct</span> <span class="n">lockdep_map</span>	<span class="n">h_lockdep_map</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_JBD2_DEBUG</span>
	<span class="cm">/* COW debugging counters: */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h_cow_moved</span><span class="p">;</span> <span class="cm">/* blocks moved to snapshot */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h_cow_copied</span><span class="p">;</span> <span class="cm">/* blocks copied to snapshot */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h_cow_ok_jh</span><span class="p">;</span> <span class="cm">/* blocks already COWed during current</span>
<span class="cm">				     transaction */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h_cow_ok_bitmap</span><span class="p">;</span> <span class="cm">/* blocks not set in COW bitmap */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h_cow_ok_mapped</span><span class="p">;</span><span class="cm">/* blocks already mapped in snapshot */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h_cow_bitmaps</span><span class="p">;</span> <span class="cm">/* COW bitmaps created */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h_cow_excluded</span><span class="p">;</span> <span class="cm">/* blocks set in exclude bitmap */</span>
<span class="cp">#endif</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Some stats for checkpoint phase</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">transaction_chp_stats_s</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">cs_chp_time</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">cs_forced_to_close</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">cs_written</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">cs_dropped</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The transaction_t type is the guts of the journaling mechanism.  It</span>
<span class="cm"> * tracks a compound transaction through its various states:</span>
<span class="cm"> *</span>
<span class="cm"> * RUNNING:	accepting new updates</span>
<span class="cm"> * LOCKED:	Updates still running but we don&#39;t accept new ones</span>
<span class="cm"> * RUNDOWN:	Updates are tidying up but have finished requesting</span>
<span class="cm"> *		new buffers to modify (state not used for now)</span>
<span class="cm"> * FLUSH:       All updates complete, but we are still writing to disk</span>
<span class="cm"> * COMMIT:      All data on disk, writing commit record</span>
<span class="cm"> * FINISHED:	We still have to keep the transaction for checkpointing.</span>
<span class="cm"> *</span>
<span class="cm"> * The transaction keeps track of all of the buffers modified by a</span>
<span class="cm"> * running transaction, and all of the buffers committed but not yet</span>
<span class="cm"> * flushed to home for finished transactions.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Lock ranking:</span>
<span class="cm"> *</span>
<span class="cm"> *    j_list_lock</span>
<span class="cm"> *      -&gt;jbd_lock_bh_journal_head()	(This is &quot;innermost&quot;)</span>
<span class="cm"> *</span>
<span class="cm"> *    j_state_lock</span>
<span class="cm"> *    -&gt;jbd_lock_bh_state()</span>
<span class="cm"> *</span>
<span class="cm"> *    jbd_lock_bh_state()</span>
<span class="cm"> *    -&gt;j_list_lock</span>
<span class="cm"> *</span>
<span class="cm"> *    j_state_lock</span>
<span class="cm"> *    -&gt;t_handle_lock</span>
<span class="cm"> *</span>
<span class="cm"> *    j_state_lock</span>
<span class="cm"> *    -&gt;j_list_lock			(journal_unmap_buffer)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">transaction_s</span>
<span class="p">{</span>
	<span class="cm">/* Pointer to the journal for this transaction. [no locking] */</span>
	<span class="n">journal_t</span>		<span class="o">*</span><span class="n">t_journal</span><span class="p">;</span>

	<span class="cm">/* Sequence number for this transaction [no locking] */</span>
	<span class="n">tid_t</span>			<span class="n">t_tid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Transaction&#39;s current state</span>
<span class="cm">	 * [no locking - only kjournald2 alters this]</span>
<span class="cm">	 * [j_list_lock] guards transition of a transaction into T_FINISHED</span>
<span class="cm">	 * state and subsequent call of __jbd2_journal_drop_transaction()</span>
<span class="cm">	 * FIXME: needs barriers</span>
<span class="cm">	 * KLUDGE: [use j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">T_RUNNING</span><span class="p">,</span>
		<span class="n">T_LOCKED</span><span class="p">,</span>
		<span class="n">T_FLUSH</span><span class="p">,</span>
		<span class="n">T_COMMIT</span><span class="p">,</span>
		<span class="n">T_COMMIT_DFLUSH</span><span class="p">,</span>
		<span class="n">T_COMMIT_JFLUSH</span><span class="p">,</span>
		<span class="n">T_FINISHED</span>
	<span class="p">}</span>			<span class="n">t_state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Where in the log does this transaction&#39;s commit start? [no locking]</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">t_log_start</span><span class="p">;</span>

	<span class="cm">/* Number of buffers on the t_buffers list [j_list_lock] */</span>
	<span class="kt">int</span>			<span class="n">t_nr_buffers</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of all buffers reserved but not yet</span>
<span class="cm">	 * modified by this transaction [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_reserved_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of all metadata buffers owned by this</span>
<span class="cm">	 * transaction [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_buffers</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of all forget buffers (superseded</span>
<span class="cm">	 * buffers which we can un-checkpoint once this transaction commits)</span>
<span class="cm">	 * [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_forget</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of all buffers still to be flushed before</span>
<span class="cm">	 * this transaction can be checkpointed. [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_checkpoint_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of all buffers submitted for IO while</span>
<span class="cm">	 * checkpointing. [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_checkpoint_io_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of temporary buffers currently undergoing</span>
<span class="cm">	 * IO in the log [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_iobuf_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of metadata buffers being shadowed by log</span>
<span class="cm">	 * IO.  The IO buffers on the iobuf list and the shadow buffers on this</span>
<span class="cm">	 * list match each other one for one at all times. [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_shadow_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of control buffers being written to the</span>
<span class="cm">	 * log. [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_log_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * List of inodes whose data we&#39;ve modified in data=ordered mode.</span>
<span class="cm">	 * [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">t_inode_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protects info related to handles</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span>		<span class="n">t_handle_lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Longest time some handle had to wait for running transaction</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">t_max_wait</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When transaction started</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">t_start</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Checkpointing stats [j_checkpoint_sem]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">transaction_chp_stats_s</span> <span class="n">t_chp_stats</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Number of outstanding updates running on this transaction</span>
<span class="cm">	 * [t_handle_lock]</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span>		<span class="n">t_updates</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Number of buffers reserved for use by all handles in this transaction</span>
<span class="cm">	 * handle but not yet modified. [t_handle_lock]</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span>		<span class="n">t_outstanding_credits</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Forward and backward links for the circular list of all transactions</span>
<span class="cm">	 * awaiting checkpoint. [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="n">transaction_t</span>		<span class="o">*</span><span class="n">t_cpnext</span><span class="p">,</span> <span class="o">*</span><span class="n">t_cpprev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When will the transaction expire (become due for commit), in jiffies?</span>
<span class="cm">	 * [no locking]</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">t_expires</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When this transaction started, in nanoseconds [no locking]</span>
<span class="cm">	 */</span>
	<span class="n">ktime_t</span>			<span class="n">t_start_time</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * How many handles used this transaction? [t_handle_lock]</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span>		<span class="n">t_handle_count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This transaction is being forced and some process is</span>
<span class="cm">	 * waiting for it to finish.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">t_synchronous_commit</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Disk flush needs to be sent to fs partition [no locking] */</span>
	<span class="kt">int</span>			<span class="n">t_need_data_flush</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For use by the filesystem to store fs-specific data</span>
<span class="cm">	 * structures associated with the transaction</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">t_private_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">transaction_run_stats_s</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">rs_wait</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">rs_running</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">rs_locked</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">rs_flushing</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">rs_logging</span><span class="p">;</span>

	<span class="n">__u32</span>			<span class="n">rs_handle_count</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">rs_blocks</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">rs_blocks_logged</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">transaction_stats_s</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ts_tid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">transaction_run_stats_s</span> <span class="n">run</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">jbd2_time_diff</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">end</span> <span class="o">+</span> <span class="p">(</span><span class="n">MAX_JIFFY_OFFSET</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define JBD2_NR_BATCH	64</span>

<span class="cm">/**</span>
<span class="cm"> * struct journal_s - The journal_s type is the concrete type associated with</span>
<span class="cm"> *     journal_t.</span>
<span class="cm"> * @j_flags:  General journaling state flags</span>
<span class="cm"> * @j_errno:  Is there an outstanding uncleared error on the journal (from a</span>
<span class="cm"> *     prior abort)?</span>
<span class="cm"> * @j_sb_buffer: First part of superblock buffer</span>
<span class="cm"> * @j_superblock: Second part of superblock buffer</span>
<span class="cm"> * @j_format_version: Version of the superblock format</span>
<span class="cm"> * @j_state_lock: Protect the various scalars in the journal</span>
<span class="cm"> * @j_barrier_count:  Number of processes waiting to create a barrier lock</span>
<span class="cm"> * @j_barrier: The barrier lock itself</span>
<span class="cm"> * @j_running_transaction: The current running transaction..</span>
<span class="cm"> * @j_committing_transaction: the transaction we are pushing to disk</span>
<span class="cm"> * @j_checkpoint_transactions: a linked circular list of all transactions</span>
<span class="cm"> *  waiting for checkpointing</span>
<span class="cm"> * @j_wait_transaction_locked: Wait queue for waiting for a locked transaction</span>
<span class="cm"> *  to start committing, or for a barrier lock to be released</span>
<span class="cm"> * @j_wait_logspace: Wait queue for waiting for checkpointing to complete</span>
<span class="cm"> * @j_wait_done_commit: Wait queue for waiting for commit to complete</span>
<span class="cm"> * @j_wait_checkpoint:  Wait queue to trigger checkpointing</span>
<span class="cm"> * @j_wait_commit: Wait queue to trigger commit</span>
<span class="cm"> * @j_wait_updates: Wait queue to wait for updates to complete</span>
<span class="cm"> * @j_checkpoint_mutex: Mutex for locking against concurrent checkpoints</span>
<span class="cm"> * @j_head: Journal head - identifies the first unused block in the journal</span>
<span class="cm"> * @j_tail: Journal tail - identifies the oldest still-used block in the</span>
<span class="cm"> *  journal.</span>
<span class="cm"> * @j_free: Journal free - how many free blocks are there in the journal?</span>
<span class="cm"> * @j_first: The block number of the first usable block</span>
<span class="cm"> * @j_last: The block number one beyond the last usable block</span>
<span class="cm"> * @j_dev: Device where we store the journal</span>
<span class="cm"> * @j_blocksize: blocksize for the location where we store the journal.</span>
<span class="cm"> * @j_blk_offset: starting block offset for into the device where we store the</span>
<span class="cm"> *     journal</span>
<span class="cm"> * @j_fs_dev: Device which holds the client fs.  For internal journal this will</span>
<span class="cm"> *     be equal to j_dev</span>
<span class="cm"> * @j_maxlen: Total maximum capacity of the journal region on disk.</span>
<span class="cm"> * @j_list_lock: Protects the buffer lists and internal buffer state.</span>
<span class="cm"> * @j_inode: Optional inode where we store the journal.  If present, all journal</span>
<span class="cm"> *     block numbers are mapped into this inode via bmap().</span>
<span class="cm"> * @j_tail_sequence:  Sequence number of the oldest transaction in the log</span>
<span class="cm"> * @j_transaction_sequence: Sequence number of the next transaction to grant</span>
<span class="cm"> * @j_commit_sequence: Sequence number of the most recently committed</span>
<span class="cm"> *  transaction</span>
<span class="cm"> * @j_commit_request: Sequence number of the most recent transaction wanting</span>
<span class="cm"> *     commit</span>
<span class="cm"> * @j_uuid: Uuid of client object.</span>
<span class="cm"> * @j_task: Pointer to the current commit thread for this journal</span>
<span class="cm"> * @j_max_transaction_buffers:  Maximum number of metadata buffers to allow in a</span>
<span class="cm"> *     single compound commit transaction</span>
<span class="cm"> * @j_commit_interval: What is the maximum transaction lifetime before we begin</span>
<span class="cm"> *  a commit?</span>
<span class="cm"> * @j_commit_timer:  The timer used to wakeup the commit thread</span>
<span class="cm"> * @j_revoke_lock: Protect the revoke table</span>
<span class="cm"> * @j_revoke: The revoke table - maintains the list of revoked blocks in the</span>
<span class="cm"> *     current transaction.</span>
<span class="cm"> * @j_revoke_table: alternate revoke tables for j_revoke</span>
<span class="cm"> * @j_wbuf: array of buffer_heads for jbd2_journal_commit_transaction</span>
<span class="cm"> * @j_wbufsize: maximum number of buffer_heads allowed in j_wbuf, the</span>
<span class="cm"> *	number that will fit in j_blocksize</span>
<span class="cm"> * @j_last_sync_writer: most recent pid which did a synchronous write</span>
<span class="cm"> * @j_history: Buffer storing the transactions statistics history</span>
<span class="cm"> * @j_history_max: Maximum number of transactions in the statistics history</span>
<span class="cm"> * @j_history_cur: Current number of transactions in the statistics history</span>
<span class="cm"> * @j_history_lock: Protect the transactions statistics history</span>
<span class="cm"> * @j_proc_entry: procfs entry for the jbd statistics directory</span>
<span class="cm"> * @j_stats: Overall statistics</span>
<span class="cm"> * @j_private: An opaque pointer to fs-private information.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">journal_s</span>
<span class="p">{</span>
	<span class="cm">/* General journaling state flags [j_state_lock] */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">j_flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Is there an outstanding uncleared error on the journal (from a prior</span>
<span class="cm">	 * abort)? [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="n">j_errno</span><span class="p">;</span>

	<span class="cm">/* The superblock buffer */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">j_sb_buffer</span><span class="p">;</span>
	<span class="n">journal_superblock_t</span>	<span class="o">*</span><span class="n">j_superblock</span><span class="p">;</span>

	<span class="cm">/* Version of the superblock format */</span>
	<span class="kt">int</span>			<span class="n">j_format_version</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protect the various scalars in the journal</span>
<span class="cm">	 */</span>
	<span class="n">rwlock_t</span>		<span class="n">j_state_lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Number of processes waiting to create a barrier lock [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="n">j_barrier_count</span><span class="p">;</span>

	<span class="cm">/* The barrier lock itself */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">j_barrier</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Transactions: The current running transaction...</span>
<span class="cm">	 * [j_state_lock] [caller holding open handle]</span>
<span class="cm">	 */</span>
	<span class="n">transaction_t</span>		<span class="o">*</span><span class="n">j_running_transaction</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * the transaction we are pushing to disk</span>
<span class="cm">	 * [j_state_lock] [caller holding open handle]</span>
<span class="cm">	 */</span>
	<span class="n">transaction_t</span>		<span class="o">*</span><span class="n">j_committing_transaction</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * ... and a linked circular list of all transactions waiting for</span>
<span class="cm">	 * checkpointing. [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="n">transaction_t</span>		<span class="o">*</span><span class="n">j_checkpoint_transactions</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait queue for waiting for a locked transaction to start committing,</span>
<span class="cm">	 * or for a barrier lock to be released</span>
<span class="cm">	 */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">j_wait_transaction_locked</span><span class="p">;</span>

	<span class="cm">/* Wait queue for waiting for checkpointing to complete */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">j_wait_logspace</span><span class="p">;</span>

	<span class="cm">/* Wait queue for waiting for commit to complete */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">j_wait_done_commit</span><span class="p">;</span>

	<span class="cm">/* Wait queue to trigger checkpointing */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">j_wait_checkpoint</span><span class="p">;</span>

	<span class="cm">/* Wait queue to trigger commit */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">j_wait_commit</span><span class="p">;</span>

	<span class="cm">/* Wait queue to wait for updates to complete */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">j_wait_updates</span><span class="p">;</span>

	<span class="cm">/* Semaphore for locking against concurrent checkpoints */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">j_checkpoint_mutex</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * List of buffer heads used by the checkpoint routine.  This</span>
<span class="cm">	 * was moved from jbd2_log_do_checkpoint() to reduce stack</span>
<span class="cm">	 * usage.  Access to this array is controlled by the</span>
<span class="cm">	 * j_checkpoint_mutex.  [j_checkpoint_mutex]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">j_chkpt_bhs</span><span class="p">[</span><span class="n">JBD2_NR_BATCH</span><span class="p">];</span>
	
	<span class="cm">/*</span>
<span class="cm">	 * Journal head: identifies the first unused block in the journal.</span>
<span class="cm">	 * [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">j_head</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Journal tail: identifies the oldest still-used block in the journal.</span>
<span class="cm">	 * [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">j_tail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Journal free: how many free blocks are there in the journal?</span>
<span class="cm">	 * [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">j_free</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Journal start and end: the block numbers of the first usable block</span>
<span class="cm">	 * and one beyond the last usable block in the journal. [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">j_first</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">j_last</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Device, blocksize and starting block offset for the location where we</span>
<span class="cm">	 * store the journal.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">block_device</span>	<span class="o">*</span><span class="n">j_dev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">j_blocksize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>	<span class="n">j_blk_offset</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">j_devname</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="o">+</span><span class="mi">24</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Device which holds the client fs.  For internal journal this will be</span>
<span class="cm">	 * equal to j_dev.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">block_device</span>	<span class="o">*</span><span class="n">j_fs_dev</span><span class="p">;</span>

	<span class="cm">/* Total maximum capacity of the journal region on disk. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">j_maxlen</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protects the buffer lists and internal buffer state.</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span>		<span class="n">j_list_lock</span><span class="p">;</span>

	<span class="cm">/* Optional inode where we store the journal.  If present, all */</span>
	<span class="cm">/* journal block numbers are mapped into this inode via */</span>
	<span class="cm">/* bmap(). */</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">j_inode</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sequence number of the oldest transaction in the log [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="n">tid_t</span>			<span class="n">j_tail_sequence</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sequence number of the next transaction to grant [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="n">tid_t</span>			<span class="n">j_transaction_sequence</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sequence number of the most recently committed transaction</span>
<span class="cm">	 * [j_state_lock].</span>
<span class="cm">	 */</span>
	<span class="n">tid_t</span>			<span class="n">j_commit_sequence</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sequence number of the most recent transaction wanting commit</span>
<span class="cm">	 * [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="n">tid_t</span>			<span class="n">j_commit_request</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Journal uuid: identifies the object (filesystem, LVM volume etc)</span>
<span class="cm">	 * backed by this journal.  This will eventually be replaced by an array</span>
<span class="cm">	 * of uuids, allowing us to index multiple devices within a single</span>
<span class="cm">	 * journal and to perform atomic updates across them.</span>
<span class="cm">	 */</span>
	<span class="n">__u8</span>			<span class="n">j_uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="cm">/* Pointer to the current commit thread for this journal */</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">j_task</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Maximum number of metadata buffers to allow in a single compound</span>
<span class="cm">	 * commit transaction</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="n">j_max_transaction_buffers</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * What is the maximum transaction lifetime before we begin a commit?</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">j_commit_interval</span><span class="p">;</span>

	<span class="cm">/* The timer used to wakeup the commit thread: */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">j_commit_timer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The revoke table: maintains the list of revoked blocks in the</span>
<span class="cm">	 * current transaction.  [j_revoke_lock]</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span>		<span class="n">j_revoke_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jbd2_revoke_table_s</span> <span class="o">*</span><span class="n">j_revoke</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jbd2_revoke_table_s</span> <span class="o">*</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * array of bhs for jbd2_journal_commit_transaction</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">**</span><span class="n">j_wbuf</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">j_wbufsize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * this is the pid of hte last person to run a synchronous operation</span>
<span class="cm">	 * through the journal</span>
<span class="cm">	 */</span>
	<span class="n">pid_t</span>			<span class="n">j_last_sync_writer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * the average amount of time in nanoseconds it takes to commit a</span>
<span class="cm">	 * transaction to disk. [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="n">u64</span>			<span class="n">j_average_commit_time</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * minimum and maximum times that we should wait for</span>
<span class="cm">	 * additional filesystem operations to get batched into a</span>
<span class="cm">	 * synchronous handle in microseconds</span>
<span class="cm">	 */</span>
	<span class="n">u32</span>			<span class="n">j_min_batch_time</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">j_max_batch_time</span><span class="p">;</span>

	<span class="cm">/* This function is called when a transaction is closed */</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">j_commit_callback</span><span class="p">)(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span>
						     <span class="n">transaction_t</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Journal statistics</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span>		<span class="n">j_history_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span>	<span class="o">*</span><span class="n">j_proc_entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">transaction_stats_s</span> <span class="n">j_stats</span><span class="p">;</span>

	<span class="cm">/* Failed journal commit ID */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">j_failed_commit</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * An opaque pointer to fs-private information.  ext3 puts its</span>
<span class="cm">	 * superblock pointer here</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">j_private</span><span class="p">;</span>

	<span class="cm">/* Reference to checksum algorithm driver via cryptoapi */</span>
	<span class="k">struct</span> <span class="n">crypto_shash</span> <span class="o">*</span><span class="n">j_chksum_driver</span><span class="p">;</span>

	<span class="cm">/* Precomputed journal UUID checksum for seeding other checksums */</span>
	<span class="n">__u32</span> <span class="n">j_csum_seed</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Journal flag definitions</span>
<span class="cm"> */</span>
<span class="cp">#define JBD2_UNMOUNT	0x001	</span><span class="cm">/* Journal thread is being destroyed */</span><span class="cp"></span>
<span class="cp">#define JBD2_ABORT	0x002	</span><span class="cm">/* Journaling has been aborted for errors. */</span><span class="cp"></span>
<span class="cp">#define JBD2_ACK_ERR	0x004	</span><span class="cm">/* The errno in the sb has been acked */</span><span class="cp"></span>
<span class="cp">#define JBD2_FLUSHED	0x008	</span><span class="cm">/* The journal superblock has been flushed */</span><span class="cp"></span>
<span class="cp">#define JBD2_LOADED	0x010	</span><span class="cm">/* The journal superblock has been loaded */</span><span class="cp"></span>
<span class="cp">#define JBD2_BARRIER	0x020	</span><span class="cm">/* Use IDE barriers */</span><span class="cp"></span>
<span class="cp">#define JBD2_ABORT_ON_SYNCDATA_ERR	0x040	</span><span class="cm">/* Abort the journal on file</span>
<span class="cm">						 * data write error in ordered</span>
<span class="cm">						 * mode */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Function declarations for the journaling transaction and buffer</span>
<span class="cm"> * management</span>
<span class="cm"> */</span>

<span class="cm">/* Filing buffers */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">jbd2_journal_unfile_buffer</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__jbd2_journal_refile_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">jbd2_journal_refile_buffer</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__jbd2_journal_file_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">,</span> <span class="n">transaction_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__journal_free_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">jbd2_journal_file_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">,</span> <span class="n">transaction_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__journal_clean_data_list</span><span class="p">(</span><span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">);</span>

<span class="cm">/* Log buffer allocation */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span> <span class="n">jbd2_journal_get_descriptor_buffer</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">jbd2_journal_next_log_block</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">jbd2_journal_get_log_tail</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="o">*</span><span class="n">tid</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">block</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__jbd2_update_log_tail</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">jbd2_update_log_tail</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block</span><span class="p">);</span>

<span class="cm">/* Commit management */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">jbd2_journal_commit_transaction</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Checkpoint list management */</span>
<span class="kt">int</span> <span class="n">__jbd2_journal_clean_checkpoint_list</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__jbd2_journal_remove_checkpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__jbd2_journal_insert_checkpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">,</span> <span class="n">transaction_t</span> <span class="o">*</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Triggers</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">jbd2_buffer_trigger_type</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fired a the moment data to write to the journal are known to be</span>
<span class="cm">	 * stable - so either at the moment b_frozen_data is created or just</span>
<span class="cm">	 * before a buffer is written to the journal.  mapped_data is a mapped</span>
<span class="cm">	 * buffer that is the frozen data for commit.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">t_frozen</span><span class="p">)(</span><span class="k">struct</span> <span class="n">jbd2_buffer_trigger_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mapped_data</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fired during journal abort for dirty buffers that will not be</span>
<span class="cm">	 * committed.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">t_abort</span><span class="p">)(</span><span class="k">struct</span> <span class="n">jbd2_buffer_trigger_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">jbd2_buffer_frozen_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">*</span><span class="n">mapped_data</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">jbd2_buffer_trigger_type</span> <span class="o">*</span><span class="n">triggers</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">jbd2_buffer_abort_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">jbd2_buffer_trigger_type</span> <span class="o">*</span><span class="n">triggers</span><span class="p">);</span>

<span class="cm">/* Buffer IO */</span>
<span class="k">extern</span> <span class="kt">int</span>
<span class="n">jbd2_journal_write_metadata_buffer</span><span class="p">(</span><span class="n">transaction_t</span>	  <span class="o">*</span><span class="n">transaction</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">journal_head</span>  <span class="o">*</span><span class="n">jh_in</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">**</span><span class="n">jh_out</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>   <span class="n">blocknr</span><span class="p">);</span>

<span class="cm">/* Transaction locking */</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">__wait_on_journal</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Transaction cache support */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">jbd2_journal_destroy_transaction_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">jbd2_journal_init_transaction_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">jbd2_journal_free_transaction</span><span class="p">(</span><span class="n">transaction_t</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Journal locking.</span>
<span class="cm"> *</span>
<span class="cm"> * We need to lock the journal during transaction state changes so that nobody</span>
<span class="cm"> * ever tries to take a handle on the running transaction while we are in the</span>
<span class="cm"> * middle of moving it to the commit phase.  j_state_lock does this.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the locking is completely interrupt unsafe.  We never touch</span>
<span class="cm"> * journal structures from interrupts.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">handle_t</span> <span class="o">*</span><span class="nf">journal_current_handle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The journaling code user interface:</span>
<span class="cm"> *</span>
<span class="cm"> * Create and destroy handles</span>
<span class="cm"> * Register buffer modifications against the current transaction.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="n">handle_t</span> <span class="o">*</span><span class="n">jbd2_journal_start</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">handle_t</span> <span class="o">*</span><span class="n">jbd2__journal_start</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">jbd2_journal_restart</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">jbd2__journal_restart</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">jbd2_journal_extend</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">jbd2_journal_get_write_access</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">jbd2_journal_get_create_access</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">jbd2_journal_get_undo_access</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>		 <span class="n">jbd2_journal_set_triggers</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">jbd2_buffer_trigger_type</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">jbd2_journal_dirty_metadata</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	 <span class="n">jbd2_journal_release_buffer</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">jbd2_journal_forget</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	 <span class="n">journal_sync_buffer</span> <span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	 <span class="n">jbd2_journal_invalidatepage</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">jbd2_journal_try_to_free_buffers</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">jbd2_journal_stop</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">jbd2_journal_flush</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	 <span class="n">jbd2_journal_lock_updates</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	 <span class="n">jbd2_journal_unlock_updates</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">journal_t</span> <span class="o">*</span> <span class="n">jbd2_journal_init_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">fs_dev</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bsize</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">journal_t</span> <span class="o">*</span> <span class="n">jbd2_journal_init_inode</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_update_format</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_check_used_features</span>
		   <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_check_available_features</span>
		   <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_set_features</span>
		   <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">jbd2_journal_clear_features</span>
		   <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_load</span>       <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_destroy</span>    <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_recover</span>    <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_wipe</span>       <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_skip_recovery</span>	<span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">jbd2_journal_update_sb_log_tail</span>	<span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">tid_t</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">__jbd2_journal_abort_hard</span>	<span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">jbd2_journal_abort</span>      <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_errno</span>      <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">jbd2_journal_ack_err</span>    <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_clear_err</span>  <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_bmap</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_force_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_file_inode</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jbd2_inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_begin_ordered_truncate</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">jbd2_inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">new_size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">jbd2_journal_init_jbd_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">jbd2_inode</span> <span class="o">*</span><span class="n">jinode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">jbd2_journal_release_jbd_inode</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jbd2_inode</span> <span class="o">*</span><span class="n">jinode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * journal_head management</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jbd2_journal_add_journal_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jbd2_journal_grab_journal_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">jbd2_journal_put_journal_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * handle management</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">jbd2_handle_cache</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">handle_t</span> <span class="o">*</span><span class="nf">jbd2_alloc_handle</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">jbd2_handle_cache</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">jbd2_free_handle</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">jbd2_handle_cache</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * jbd2_inode management (optional, for those file systems that want to use</span>
<span class="cm"> * dynamically allocated jbd2_inode structures)</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">jbd2_inode_cache</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">jbd2_inode</span> <span class="o">*</span><span class="nf">jbd2_alloc_inode</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">jbd2_inode_cache</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">jbd2_free_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">jbd2_inode</span> <span class="o">*</span><span class="n">jinode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">jbd2_inode_cache</span><span class="p">,</span> <span class="n">jinode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Primary revoke support */</span>
<span class="cp">#define JOURNAL_REVOKE_DEFAULT_HASH 256</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_init_revoke</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">jbd2_journal_destroy_revoke_caches</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_init_revoke_caches</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">jbd2_journal_destroy_revoke</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_revoke</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">jbd2_journal_cancel_revoke</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">jbd2_journal_write_revoke_records</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span>
						     <span class="n">transaction_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/* Recovery revoke support */</span>
<span class="k">extern</span> <span class="kt">int</span>	<span class="n">jbd2_journal_set_revoke</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="n">tid_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	<span class="n">jbd2_journal_test_revoke</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="n">tid_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	<span class="n">jbd2_journal_clear_revoke</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	<span class="n">jbd2_journal_switch_revoke_table</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	<span class="n">jbd2_clear_buffer_revoked_flags</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The log thread user interface:</span>
<span class="cm"> *</span>
<span class="cm"> * Request space in the current transaction, and force transaction commit</span>
<span class="cm"> * transitions on demand.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">__jbd2_log_space_left</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span> <span class="cm">/* Called with journal locked */</span>
<span class="kt">int</span> <span class="n">jbd2_log_start_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">tid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__jbd2_log_start_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">tid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">jbd2_journal_start_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="o">*</span><span class="n">tid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">jbd2_journal_force_commit_nested</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">jbd2_log_wait_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">tid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">jbd2_log_do_checkpoint</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">jbd2_trans_will_send_data_barrier</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">tid</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__jbd2_log_wait_for_space</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__jbd2_journal_drop_transaction</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">transaction_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">jbd2_cleanup_journal_tail</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Debugging code only: */</span>

<span class="cp">#define jbd_ENOSYS() \</span>
<span class="cp">do {								           \</span>
<span class="cp">	printk (KERN_ERR &quot;JBD unimplemented function %s\n&quot;, __func__); \</span>
<span class="cp">	current-&gt;state = TASK_UNINTERRUPTIBLE;			           \</span>
<span class="cp">	schedule();						           \</span>
<span class="cp">} while (1)</span>

<span class="cm">/*</span>
<span class="cm"> * is_journal_abort</span>
<span class="cm"> *</span>
<span class="cm"> * Simple test wrapper function to test the JBD2_ABORT state flag.  This</span>
<span class="cm"> * bit, when set, indicates that we have had a fatal error somewhere,</span>
<span class="cm"> * either inside the journaling layer or indicated to us by the client</span>
<span class="cm"> * (eg. ext3), and that we and should not commit any further</span>
<span class="cm"> * transactions.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_journal_aborted</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JBD2_ABORT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_handle_aborted</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_aborted</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">is_journal_aborted</span><span class="p">(</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">jbd2_journal_abort_handle</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_aborted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__   */</span><span class="cp"></span>

<span class="cm">/* Comparison functions for transaction IDs: perform comparisons using</span>
<span class="cm"> * modulo arithmetic so that they work over sequence number wraps. */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tid_gt</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">difference</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">difference</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tid_geq</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">difference</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">difference</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">jbd2_journal_blocks_per_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">size_t</span> <span class="n">journal_tag_bytes</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Return the minimum number of blocks which must be free in the journal</span>
<span class="cm"> * before a new transaction may be started.  Must be called under j_state_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">jbd_space_needed</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nblocks</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_transaction_buffers</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">)</span>
		<span class="n">nblocks</span> <span class="o">+=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="o">-&gt;</span>
				       <span class="n">t_outstanding_credits</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nblocks</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Definitions which augment the buffer_head layer</span>
<span class="cm"> */</span>

<span class="cm">/* journaling buffer types */</span>
<span class="cp">#define BJ_None		0	</span><span class="cm">/* Not journaled */</span><span class="cp"></span>
<span class="cp">#define BJ_Metadata	1	</span><span class="cm">/* Normal journaled metadata */</span><span class="cp"></span>
<span class="cp">#define BJ_Forget	2	</span><span class="cm">/* Buffer superseded by this transaction */</span><span class="cp"></span>
<span class="cp">#define BJ_IO		3	</span><span class="cm">/* Buffer is for temporary IO use */</span><span class="cp"></span>
<span class="cp">#define BJ_Shadow	4	</span><span class="cm">/* Buffer contents being shadowed to the log */</span><span class="cp"></span>
<span class="cp">#define BJ_LogCtl	5	</span><span class="cm">/* Buffer contains log descriptors */</span><span class="cp"></span>
<span class="cp">#define BJ_Reserved	6	</span><span class="cm">/* Buffer is reserved for access by journal */</span><span class="cp"></span>
<span class="cp">#define BJ_Types	7</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">jbd_blocks_per_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">jbd2_chksum</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">u32</span> <span class="n">crc</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">shash_desc</span> <span class="n">shash</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">ctx</span><span class="p">[</span><span class="n">crypto_shash_descsize</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_chksum_driver</span><span class="p">)];</span>
	<span class="p">}</span> <span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">desc</span><span class="p">.</span><span class="n">shash</span><span class="p">.</span><span class="n">tfm</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_chksum_driver</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">.</span><span class="n">shash</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">desc</span><span class="p">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">crc</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">crypto_shash_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">.</span><span class="n">shash</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">desc</span><span class="p">.</span><span class="n">ctx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#define buffer_trace_init(bh)	do {} while (0)</span>
<span class="cp">#define print_buffer_fields(bh)	do {} while (0)</span>
<span class="cp">#define print_buffer_trace(bh)	do {} while (0)</span>
<span class="cp">#define BUFFER_TRACE(bh, info)	do {} while (0)</span>
<span class="cp">#define BUFFER_TRACE2(bh, bh2, info)	do {} while (0)</span>
<span class="cp">#define JBUFFER_TRACE(jh, info)	do {} while (0)</span>

<span class="cp">#endif	</span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif	</span><span class="cm">/* _LINUX_JBD2_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
