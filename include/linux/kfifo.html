<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › kfifo.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>kfifo.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * A generic kernel FIFO implementation</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009/2010 Stefani Seibold &lt;stefani@seibold.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_KFIFO_H</span>
<span class="cp">#define _LINUX_KFIFO_H</span>

<span class="cm">/*</span>
<span class="cm"> * How to porting drivers to the new generic FIFO API:</span>
<span class="cm"> *</span>
<span class="cm"> * - Modify the declaration of the &quot;struct kfifo *&quot; object into a</span>
<span class="cm"> *   in-place &quot;struct kfifo&quot; object</span>
<span class="cm"> * - Init the in-place object with kfifo_alloc() or kfifo_init()</span>
<span class="cm"> *   Note: The address of the in-place &quot;struct kfifo&quot; object must be</span>
<span class="cm"> *   passed as the first argument to this functions</span>
<span class="cm"> * - Replace the use of __kfifo_put into kfifo_in and __kfifo_get</span>
<span class="cm"> *   into kfifo_out</span>
<span class="cm"> * - Replace the use of kfifo_put into kfifo_in_spinlocked and kfifo_get</span>
<span class="cm"> *   into kfifo_out_spinlocked</span>
<span class="cm"> *   Note: the spinlock pointer formerly passed to kfifo_init/kfifo_alloc</span>
<span class="cm"> *   must be passed now to the kfifo_in_spinlocked and kfifo_out_spinlocked</span>
<span class="cm"> *   as the last parameter</span>
<span class="cm"> * - The formerly __kfifo_* functions are renamed into kfifo_*</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Note about locking : There is no locking required until only * one reader</span>
<span class="cm"> * and one writer is using the fifo and no kfifo_reset() will be * called</span>
<span class="cm"> *  kfifo_reset_out() can be safely used, until it will be only called</span>
<span class="cm"> * in the reader thread.</span>
<span class="cm"> *  For multiple writer and one reader there is only a need to lock the writer.</span>
<span class="cm"> * And vice versa for only one writer and multiple reader there is only a need</span>
<span class="cm"> * to lock the reader.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>

<span class="k">struct</span> <span class="n">__kfifo</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">in</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">out</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">esize</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define __STRUCT_KFIFO_COMMON(datatype, recsize, ptrtype) \</span>
<span class="cp">	union { \</span>
<span class="cp">		struct __kfifo	kfifo; \</span>
<span class="cp">		datatype	*type; \</span>
<span class="cp">		char		(*rectype)[recsize]; \</span>
<span class="cp">		ptrtype		*ptr; \</span>
<span class="cp">		const ptrtype	*ptr_const; \</span>
<span class="cp">	}</span>

<span class="cp">#define __STRUCT_KFIFO(type, size, recsize, ptrtype) \</span>
<span class="cp">{ \</span>
<span class="cp">	__STRUCT_KFIFO_COMMON(type, recsize, ptrtype); \</span>
<span class="cp">	type		buf[((size &lt; 2) || (size &amp; (size - 1))) ? -1 : size]; \</span>
<span class="cp">}</span>

<span class="cp">#define STRUCT_KFIFO(type, size) \</span>
<span class="cp">	struct __STRUCT_KFIFO(type, size, 0, type)</span>

<span class="cp">#define __STRUCT_KFIFO_PTR(type, recsize, ptrtype) \</span>
<span class="cp">{ \</span>
<span class="cp">	__STRUCT_KFIFO_COMMON(type, recsize, ptrtype); \</span>
<span class="cp">	type		buf[0]; \</span>
<span class="cp">}</span>

<span class="cp">#define STRUCT_KFIFO_PTR(type) \</span>
<span class="cp">	struct __STRUCT_KFIFO_PTR(type, 0, type)</span>

<span class="cm">/*</span>
<span class="cm"> * define compatibility &quot;struct kfifo&quot; for dynamic allocated fifos</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kfifo</span> <span class="n">__STRUCT_KFIFO_PTR</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">void</span><span class="p">);</span>

<span class="cp">#define STRUCT_KFIFO_REC_1(size) \</span>
<span class="cp">	struct __STRUCT_KFIFO(unsigned char, size, 1, void)</span>

<span class="cp">#define STRUCT_KFIFO_REC_2(size) \</span>
<span class="cp">	struct __STRUCT_KFIFO(unsigned char, size, 2, void)</span>

<span class="cm">/*</span>
<span class="cm"> * define kfifo_rec types</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kfifo_rec_ptr_1</span> <span class="n">__STRUCT_KFIFO_PTR</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">void</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">kfifo_rec_ptr_2</span> <span class="n">__STRUCT_KFIFO_PTR</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * helper macro to distinguish between real in place fifo where the fifo</span>
<span class="cm"> * array is a part of the structure and the fifo type where the array is</span>
<span class="cm"> * outside of the fifo structure.</span>
<span class="cm"> */</span>
<span class="cp">#define	__is_kfifo_ptr(fifo)	(sizeof(*fifo) == sizeof(struct __kfifo))</span>

<span class="cm">/**</span>
<span class="cm"> * DECLARE_KFIFO_PTR - macro to declare a fifo pointer object</span>
<span class="cm"> * @fifo: name of the declared fifo</span>
<span class="cm"> * @type: type of the fifo elements</span>
<span class="cm"> */</span>
<span class="cp">#define DECLARE_KFIFO_PTR(fifo, type)	STRUCT_KFIFO_PTR(type) fifo</span>

<span class="cm">/**</span>
<span class="cm"> * DECLARE_KFIFO - macro to declare a fifo object</span>
<span class="cm"> * @fifo: name of the declared fifo</span>
<span class="cm"> * @type: type of the fifo elements</span>
<span class="cm"> * @size: the number of elements in the fifo, this must be a power of 2</span>
<span class="cm"> */</span>
<span class="cp">#define DECLARE_KFIFO(fifo, type, size)	STRUCT_KFIFO(type, size) fifo</span>

<span class="cm">/**</span>
<span class="cm"> * INIT_KFIFO - Initialize a fifo declared by DECLARE_KFIFO</span>
<span class="cm"> * @fifo: name of the declared fifo datatype</span>
<span class="cm"> */</span>
<span class="cp">#define INIT_KFIFO(fifo) \</span>
<span class="cp">(void)({ \</span>
<span class="cp">	typeof(&amp;(fifo)) __tmp = &amp;(fifo); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	__kfifo-&gt;in = 0; \</span>
<span class="cp">	__kfifo-&gt;out = 0; \</span>
<span class="cp">	__kfifo-&gt;mask = __is_kfifo_ptr(__tmp) ? 0 : ARRAY_SIZE(__tmp-&gt;buf) - 1;\</span>
<span class="cp">	__kfifo-&gt;esize = sizeof(*__tmp-&gt;buf); \</span>
<span class="cp">	__kfifo-&gt;data = __is_kfifo_ptr(__tmp) ?  NULL : __tmp-&gt;buf; \</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * DEFINE_KFIFO - macro to define and initialize a fifo</span>
<span class="cm"> * @fifo: name of the declared fifo datatype</span>
<span class="cm"> * @type: type of the fifo elements</span>
<span class="cm"> * @size: the number of elements in the fifo, this must be a power of 2</span>
<span class="cm"> *</span>
<span class="cm"> * Note: the macro can be used for global and local fifo data type variables.</span>
<span class="cm"> */</span>
<span class="cp">#define DEFINE_KFIFO(fifo, type, size) \</span>
<span class="cp">	DECLARE_KFIFO(fifo, type, size) = \</span>
<span class="cp">	(typeof(fifo)) { \</span>
<span class="cp">		{ \</span>
<span class="cp">			{ \</span>
<span class="cp">			.in	= 0, \</span>
<span class="cp">			.out	= 0, \</span>
<span class="cp">			.mask	= __is_kfifo_ptr(&amp;(fifo)) ? \</span>
<span class="cp">				  0 : \</span>
<span class="cp">				  ARRAY_SIZE((fifo).buf) - 1, \</span>
<span class="cp">			.esize	= sizeof(*(fifo).buf), \</span>
<span class="cp">			.data	= __is_kfifo_ptr(&amp;(fifo)) ? \</span>
<span class="cp">				NULL : \</span>
<span class="cp">				(fifo).buf, \</span>
<span class="cp">			} \</span>
<span class="cp">		} \</span>
<span class="cp">	}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__must_check</span>
<span class="nf">__kfifo_uint_must_check_helper</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span>
<span class="nf">__kfifo_int_must_check_helper</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_initialized - Check if the fifo is initialized</span>
<span class="cm"> * @fifo: address of the fifo to check</span>
<span class="cm"> *</span>
<span class="cm"> * Return %true if fifo is initialized, otherwise %false.</span>
<span class="cm"> * Assumes the fifo was 0 before.</span>
<span class="cm"> */</span>
<span class="cp">#define kfifo_initialized(fifo) ((fifo)-&gt;kfifo.mask)</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_esize - returns the size of the element managed by the fifo</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> */</span>
<span class="cp">#define kfifo_esize(fifo)	((fifo)-&gt;kfifo.esize)</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_recsize - returns the size of the record length field</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> */</span>
<span class="cp">#define kfifo_recsize(fifo)	(sizeof(*(fifo)-&gt;rectype))</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_size - returns the size of the fifo in elements</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> */</span>
<span class="cp">#define kfifo_size(fifo)	((fifo)-&gt;kfifo.mask + 1)</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_reset - removes the entire fifo content</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> *</span>
<span class="cm"> * Note: usage of kfifo_reset() is dangerous. It should be only called when the</span>
<span class="cm"> * fifo is exclusived locked or when it is secured that no other thread is</span>
<span class="cm"> * accessing the fifo.</span>
<span class="cm"> */</span>
<span class="cp">#define kfifo_reset(fifo) \</span>
<span class="cp">(void)({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	__tmp-&gt;kfifo.in = __tmp-&gt;kfifo.out = 0; \</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_reset_out - skip fifo content</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> *</span>
<span class="cm"> * Note: The usage of kfifo_reset_out() is safe until it will be only called</span>
<span class="cm"> * from the reader thread and there is only one concurrent reader. Otherwise</span>
<span class="cm"> * it is dangerous and must be handled in the same way as kfifo_reset().</span>
<span class="cm"> */</span>
<span class="cp">#define kfifo_reset_out(fifo)	\</span>
<span class="cp">(void)({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	__tmp-&gt;kfifo.out = __tmp-&gt;kfifo.in; \</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_len - returns the number of used elements in the fifo</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> */</span>
<span class="cp">#define kfifo_len(fifo) \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmpl = (fifo); \</span>
<span class="cp">	__tmpl-&gt;kfifo.in - __tmpl-&gt;kfifo.out; \</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_is_empty - returns true if the fifo is empty</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> */</span>
<span class="cp">#define	kfifo_is_empty(fifo) \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmpq = (fifo); \</span>
<span class="cp">	__tmpq-&gt;kfifo.in == __tmpq-&gt;kfifo.out; \</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_is_full - returns true if the fifo is full</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> */</span>
<span class="cp">#define	kfifo_is_full(fifo) \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmpq = (fifo); \</span>
<span class="cp">	kfifo_len(__tmpq) &gt; __tmpq-&gt;kfifo.mask; \</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_avail - returns the number of unused elements in the fifo</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> */</span>
<span class="cp">#define	kfifo_avail(fifo) \</span>
<span class="cp">__kfifo_uint_must_check_helper( \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmpq = (fifo); \</span>
<span class="cp">	const size_t __recsize = sizeof(*__tmpq-&gt;rectype); \</span>
<span class="cp">	unsigned int __avail = kfifo_size(__tmpq) - kfifo_len(__tmpq); \</span>
<span class="cp">	(__recsize) ? ((__avail &lt;= __recsize) ? 0 : \</span>
<span class="cp">	__kfifo_max_r(__avail - __recsize, __recsize)) : \</span>
<span class="cp">	__avail; \</span>
<span class="cp">}) \</span>
<span class="cp">)</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_skip - skip output data</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> */</span>
<span class="cp">#define	kfifo_skip(fifo) \</span>
<span class="cp">(void)({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	const size_t __recsize = sizeof(*__tmp-&gt;rectype); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	if (__recsize) \</span>
<span class="cp">		__kfifo_skip_r(__kfifo, __recsize); \</span>
<span class="cp">	else \</span>
<span class="cp">		__kfifo-&gt;out++; \</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_peek_len - gets the size of the next fifo record</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the size of the next fifo record in number of bytes.</span>
<span class="cm"> */</span>
<span class="cp">#define kfifo_peek_len(fifo) \</span>
<span class="cp">__kfifo_uint_must_check_helper( \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	const size_t __recsize = sizeof(*__tmp-&gt;rectype); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	(!__recsize) ? kfifo_len(__tmp) * sizeof(*__tmp-&gt;type) : \</span>
<span class="cp">	__kfifo_len_r(__kfifo, __recsize); \</span>
<span class="cp">}) \</span>
<span class="cp">)</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_alloc - dynamically allocates a new fifo buffer</span>
<span class="cm"> * @fifo: pointer to the fifo</span>
<span class="cm"> * @size: the number of elements in the fifo, this must be a power of 2</span>
<span class="cm"> * @gfp_mask: get_free_pages mask, passed to kmalloc()</span>
<span class="cm"> *</span>
<span class="cm"> * This macro dynamically allocates a new fifo buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * The numer of elements will be rounded-up to a power of 2.</span>
<span class="cm"> * The fifo will be release with kfifo_free().</span>
<span class="cm"> * Return 0 if no error, otherwise an error code.</span>
<span class="cm"> */</span>
<span class="cp">#define kfifo_alloc(fifo, size, gfp_mask) \</span>
<span class="cp">__kfifo_int_must_check_helper( \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	__is_kfifo_ptr(__tmp) ? \</span>
<span class="cp">	__kfifo_alloc(__kfifo, size, sizeof(*__tmp-&gt;type), gfp_mask) : \</span>
<span class="cp">	-EINVAL; \</span>
<span class="cp">}) \</span>
<span class="cp">)</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_free - frees the fifo</span>
<span class="cm"> * @fifo: the fifo to be freed</span>
<span class="cm"> */</span>
<span class="cp">#define kfifo_free(fifo) \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	if (__is_kfifo_ptr(__tmp)) \</span>
<span class="cp">		__kfifo_free(__kfifo); \</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_init - initialize a fifo using a preallocated buffer</span>
<span class="cm"> * @fifo: the fifo to assign the buffer</span>
<span class="cm"> * @buffer: the preallocated buffer to be used</span>
<span class="cm"> * @size: the size of the internal buffer, this have to be a power of 2</span>
<span class="cm"> *</span>
<span class="cm"> * This macro initialize a fifo using a preallocated buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * The numer of elements will be rounded-up to a power of 2.</span>
<span class="cm"> * Return 0 if no error, otherwise an error code.</span>
<span class="cm"> */</span>
<span class="cp">#define kfifo_init(fifo, buffer, size) \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	__is_kfifo_ptr(__tmp) ? \</span>
<span class="cp">	__kfifo_init(__kfifo, buffer, size, sizeof(*__tmp-&gt;type)) : \</span>
<span class="cp">	-EINVAL; \</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_put - put data into the fifo</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> * @val: the data to be added</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies the given value into the fifo.</span>
<span class="cm"> * It returns 0 if the fifo was full. Otherwise it returns the number</span>
<span class="cm"> * processed elements.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that with only one concurrent reader and one concurrent</span>
<span class="cm"> * writer, you don&#39;t need extra locking to use these macro.</span>
<span class="cm"> */</span>
<span class="cp">#define	kfifo_put(fifo, val) \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	typeof((val) + 1) __val = (val); \</span>
<span class="cp">	unsigned int __ret; \</span>
<span class="cp">	const size_t __recsize = sizeof(*__tmp-&gt;rectype); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	if (0) { \</span>
<span class="cp">		typeof(__tmp-&gt;ptr_const) __dummy __attribute__ ((unused)); \</span>
<span class="cp">		__dummy = (typeof(__val))NULL; \</span>
<span class="cp">	} \</span>
<span class="cp">	if (__recsize) \</span>
<span class="cp">		__ret = __kfifo_in_r(__kfifo, __val, sizeof(*__val), \</span>
<span class="cp">			__recsize); \</span>
<span class="cp">	else { \</span>
<span class="cp">		__ret = !kfifo_is_full(__tmp); \</span>
<span class="cp">		if (__ret) { \</span>
<span class="cp">			(__is_kfifo_ptr(__tmp) ? \</span>
<span class="cp">			((typeof(__tmp-&gt;type))__kfifo-&gt;data) : \</span>
<span class="cp">			(__tmp-&gt;buf) \</span>
<span class="cp">			)[__kfifo-&gt;in &amp; __tmp-&gt;kfifo.mask] = \</span>
<span class="cp">				*(typeof(__tmp-&gt;type))__val; \</span>
<span class="cp">			smp_wmb(); \</span>
<span class="cp">			__kfifo-&gt;in++; \</span>
<span class="cp">		} \</span>
<span class="cp">	} \</span>
<span class="cp">	__ret; \</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_get - get data from the fifo</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> * @val: the var where to store the data to be added</span>
<span class="cm"> *</span>
<span class="cm"> * This macro reads the data from the fifo.</span>
<span class="cm"> * It returns 0 if the fifo was empty. Otherwise it returns the number</span>
<span class="cm"> * processed elements.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that with only one concurrent reader and one concurrent</span>
<span class="cm"> * writer, you don&#39;t need extra locking to use these macro.</span>
<span class="cm"> */</span>
<span class="cp">#define	kfifo_get(fifo, val) \</span>
<span class="cp">__kfifo_uint_must_check_helper( \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	typeof((val) + 1) __val = (val); \</span>
<span class="cp">	unsigned int __ret; \</span>
<span class="cp">	const size_t __recsize = sizeof(*__tmp-&gt;rectype); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	if (0) \</span>
<span class="cp">		__val = (typeof(__tmp-&gt;ptr))0; \</span>
<span class="cp">	if (__recsize) \</span>
<span class="cp">		__ret = __kfifo_out_r(__kfifo, __val, sizeof(*__val), \</span>
<span class="cp">			__recsize); \</span>
<span class="cp">	else { \</span>
<span class="cp">		__ret = !kfifo_is_empty(__tmp); \</span>
<span class="cp">		if (__ret) { \</span>
<span class="cp">			*(typeof(__tmp-&gt;type))__val = \</span>
<span class="cp">				(__is_kfifo_ptr(__tmp) ? \</span>
<span class="cp">				((typeof(__tmp-&gt;type))__kfifo-&gt;data) : \</span>
<span class="cp">				(__tmp-&gt;buf) \</span>
<span class="cp">				)[__kfifo-&gt;out &amp; __tmp-&gt;kfifo.mask]; \</span>
<span class="cp">			smp_wmb(); \</span>
<span class="cp">			__kfifo-&gt;out++; \</span>
<span class="cp">		} \</span>
<span class="cp">	} \</span>
<span class="cp">	__ret; \</span>
<span class="cp">}) \</span>
<span class="cp">)</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_peek - get data from the fifo without removing</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> * @val: the var where to store the data to be added</span>
<span class="cm"> *</span>
<span class="cm"> * This reads the data from the fifo without removing it from the fifo.</span>
<span class="cm"> * It returns 0 if the fifo was empty. Otherwise it returns the number</span>
<span class="cm"> * processed elements.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that with only one concurrent reader and one concurrent</span>
<span class="cm"> * writer, you don&#39;t need extra locking to use these macro.</span>
<span class="cm"> */</span>
<span class="cp">#define	kfifo_peek(fifo, val) \</span>
<span class="cp">__kfifo_uint_must_check_helper( \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	typeof((val) + 1) __val = (val); \</span>
<span class="cp">	unsigned int __ret; \</span>
<span class="cp">	const size_t __recsize = sizeof(*__tmp-&gt;rectype); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	if (0) \</span>
<span class="cp">		__val = (typeof(__tmp-&gt;ptr))NULL; \</span>
<span class="cp">	if (__recsize) \</span>
<span class="cp">		__ret = __kfifo_out_peek_r(__kfifo, __val, sizeof(*__val), \</span>
<span class="cp">			__recsize); \</span>
<span class="cp">	else { \</span>
<span class="cp">		__ret = !kfifo_is_empty(__tmp); \</span>
<span class="cp">		if (__ret) { \</span>
<span class="cp">			*(typeof(__tmp-&gt;type))__val = \</span>
<span class="cp">				(__is_kfifo_ptr(__tmp) ? \</span>
<span class="cp">				((typeof(__tmp-&gt;type))__kfifo-&gt;data) : \</span>
<span class="cp">				(__tmp-&gt;buf) \</span>
<span class="cp">				)[__kfifo-&gt;out &amp; __tmp-&gt;kfifo.mask]; \</span>
<span class="cp">			smp_wmb(); \</span>
<span class="cp">		} \</span>
<span class="cp">	} \</span>
<span class="cp">	__ret; \</span>
<span class="cp">}) \</span>
<span class="cp">)</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_in - put data into the fifo</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> * @buf: the data to be added</span>
<span class="cm"> * @n: number of elements to be added</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies the given buffer into the fifo and returns the</span>
<span class="cm"> * number of copied elements.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that with only one concurrent reader and one concurrent</span>
<span class="cm"> * writer, you don&#39;t need extra locking to use these macro.</span>
<span class="cm"> */</span>
<span class="cp">#define	kfifo_in(fifo, buf, n) \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	typeof((buf) + 1) __buf = (buf); \</span>
<span class="cp">	unsigned long __n = (n); \</span>
<span class="cp">	const size_t __recsize = sizeof(*__tmp-&gt;rectype); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	if (0) { \</span>
<span class="cp">		typeof(__tmp-&gt;ptr_const) __dummy __attribute__ ((unused)); \</span>
<span class="cp">		__dummy = (typeof(__buf))NULL; \</span>
<span class="cp">	} \</span>
<span class="cp">	(__recsize) ?\</span>
<span class="cp">	__kfifo_in_r(__kfifo, __buf, __n, __recsize) : \</span>
<span class="cp">	__kfifo_in(__kfifo, __buf, __n); \</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_in_spinlocked - put data into the fifo using a spinlock for locking</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> * @buf: the data to be added</span>
<span class="cm"> * @n: number of elements to be added</span>
<span class="cm"> * @lock: pointer to the spinlock to use for locking</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies the given values buffer into the fifo and returns the</span>
<span class="cm"> * number of copied elements.</span>
<span class="cm"> */</span>
<span class="cp">#define	kfifo_in_spinlocked(fifo, buf, n, lock) \</span>
<span class="cp">({ \</span>
<span class="cp">	unsigned long __flags; \</span>
<span class="cp">	unsigned int __ret; \</span>
<span class="cp">	spin_lock_irqsave(lock, __flags); \</span>
<span class="cp">	__ret = kfifo_in(fifo, buf, n); \</span>
<span class="cp">	spin_unlock_irqrestore(lock, __flags); \</span>
<span class="cp">	__ret; \</span>
<span class="cp">})</span>

<span class="cm">/* alias for kfifo_in_spinlocked, will be removed in a future release */</span>
<span class="cp">#define kfifo_in_locked(fifo, buf, n, lock) \</span>
<span class="cp">		kfifo_in_spinlocked(fifo, buf, n, lock)</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_out - get data from the fifo</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> * @buf: pointer to the storage buffer</span>
<span class="cm"> * @n: max. number of elements to get</span>
<span class="cm"> *</span>
<span class="cm"> * This macro get some data from the fifo and return the numbers of elements</span>
<span class="cm"> * copied.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that with only one concurrent reader and one concurrent</span>
<span class="cm"> * writer, you don&#39;t need extra locking to use these macro.</span>
<span class="cm"> */</span>
<span class="cp">#define	kfifo_out(fifo, buf, n) \</span>
<span class="cp">__kfifo_uint_must_check_helper( \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	typeof((buf) + 1) __buf = (buf); \</span>
<span class="cp">	unsigned long __n = (n); \</span>
<span class="cp">	const size_t __recsize = sizeof(*__tmp-&gt;rectype); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	if (0) { \</span>
<span class="cp">		typeof(__tmp-&gt;ptr) __dummy = NULL; \</span>
<span class="cp">		__buf = __dummy; \</span>
<span class="cp">	} \</span>
<span class="cp">	(__recsize) ?\</span>
<span class="cp">	__kfifo_out_r(__kfifo, __buf, __n, __recsize) : \</span>
<span class="cp">	__kfifo_out(__kfifo, __buf, __n); \</span>
<span class="cp">}) \</span>
<span class="cp">)</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_out_spinlocked - get data from the fifo using a spinlock for locking</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> * @buf: pointer to the storage buffer</span>
<span class="cm"> * @n: max. number of elements to get</span>
<span class="cm"> * @lock: pointer to the spinlock to use for locking</span>
<span class="cm"> *</span>
<span class="cm"> * This macro get the data from the fifo and return the numbers of elements</span>
<span class="cm"> * copied.</span>
<span class="cm"> */</span>
<span class="cp">#define	kfifo_out_spinlocked(fifo, buf, n, lock) \</span>
<span class="cp">__kfifo_uint_must_check_helper( \</span>
<span class="cp">({ \</span>
<span class="cp">	unsigned long __flags; \</span>
<span class="cp">	unsigned int __ret; \</span>
<span class="cp">	spin_lock_irqsave(lock, __flags); \</span>
<span class="cp">	__ret = kfifo_out(fifo, buf, n); \</span>
<span class="cp">	spin_unlock_irqrestore(lock, __flags); \</span>
<span class="cp">	__ret; \</span>
<span class="cp">}) \</span>
<span class="cp">)</span>

<span class="cm">/* alias for kfifo_out_spinlocked, will be removed in a future release */</span>
<span class="cp">#define kfifo_out_locked(fifo, buf, n, lock) \</span>
<span class="cp">		kfifo_out_spinlocked(fifo, buf, n, lock)</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_from_user - puts some data from user space into the fifo</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> * @from: pointer to the data to be added</span>
<span class="cm"> * @len: the length of the data to be added</span>
<span class="cm"> * @copied: pointer to output variable to store the number of copied bytes</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies at most @len bytes from the @from into the</span>
<span class="cm"> * fifo, depending of the available space and returns -EFAULT/0.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that with only one concurrent reader and one concurrent</span>
<span class="cm"> * writer, you don&#39;t need extra locking to use these macro.</span>
<span class="cm"> */</span>
<span class="cp">#define	kfifo_from_user(fifo, from, len, copied) \</span>
<span class="cp">__kfifo_uint_must_check_helper( \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	const void __user *__from = (from); \</span>
<span class="cp">	unsigned int __len = (len); \</span>
<span class="cp">	unsigned int *__copied = (copied); \</span>
<span class="cp">	const size_t __recsize = sizeof(*__tmp-&gt;rectype); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	(__recsize) ? \</span>
<span class="cp">	__kfifo_from_user_r(__kfifo, __from, __len,  __copied, __recsize) : \</span>
<span class="cp">	__kfifo_from_user(__kfifo, __from, __len, __copied); \</span>
<span class="cp">}) \</span>
<span class="cp">)</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_to_user - copies data from the fifo into user space</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> * @to: where the data must be copied</span>
<span class="cm"> * @len: the size of the destination buffer</span>
<span class="cm"> * @copied: pointer to output variable to store the number of copied bytes</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies at most @len bytes from the fifo into the</span>
<span class="cm"> * @to buffer and returns -EFAULT/0.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that with only one concurrent reader and one concurrent</span>
<span class="cm"> * writer, you don&#39;t need extra locking to use these macro.</span>
<span class="cm"> */</span>
<span class="cp">#define	kfifo_to_user(fifo, to, len, copied) \</span>
<span class="cp">__kfifo_uint_must_check_helper( \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	void __user *__to = (to); \</span>
<span class="cp">	unsigned int __len = (len); \</span>
<span class="cp">	unsigned int *__copied = (copied); \</span>
<span class="cp">	const size_t __recsize = sizeof(*__tmp-&gt;rectype); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	(__recsize) ? \</span>
<span class="cp">	__kfifo_to_user_r(__kfifo, __to, __len, __copied, __recsize) : \</span>
<span class="cp">	__kfifo_to_user(__kfifo, __to, __len, __copied); \</span>
<span class="cp">}) \</span>
<span class="cp">)</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_dma_in_prepare - setup a scatterlist for DMA input</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> * @sgl: pointer to the scatterlist array</span>
<span class="cm"> * @nents: number of entries in the scatterlist array</span>
<span class="cm"> * @len: number of elements to transfer</span>
<span class="cm"> *</span>
<span class="cm"> * This macro fills a scatterlist for DMA input.</span>
<span class="cm"> * It returns the number entries in the scatterlist array.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that with only one concurrent reader and one concurrent</span>
<span class="cm"> * writer, you don&#39;t need extra locking to use these macros.</span>
<span class="cm"> */</span>
<span class="cp">#define	kfifo_dma_in_prepare(fifo, sgl, nents, len) \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	struct scatterlist *__sgl = (sgl); \</span>
<span class="cp">	int __nents = (nents); \</span>
<span class="cp">	unsigned int __len = (len); \</span>
<span class="cp">	const size_t __recsize = sizeof(*__tmp-&gt;rectype); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	(__recsize) ? \</span>
<span class="cp">	__kfifo_dma_in_prepare_r(__kfifo, __sgl, __nents, __len, __recsize) : \</span>
<span class="cp">	__kfifo_dma_in_prepare(__kfifo, __sgl, __nents, __len); \</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_dma_in_finish - finish a DMA IN operation</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> * @len: number of bytes to received</span>
<span class="cm"> *</span>
<span class="cm"> * This macro finish a DMA IN operation. The in counter will be updated by</span>
<span class="cm"> * the len parameter. No error checking will be done.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that with only one concurrent reader and one concurrent</span>
<span class="cm"> * writer, you don&#39;t need extra locking to use these macros.</span>
<span class="cm"> */</span>
<span class="cp">#define kfifo_dma_in_finish(fifo, len) \</span>
<span class="cp">(void)({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	unsigned int __len = (len); \</span>
<span class="cp">	const size_t __recsize = sizeof(*__tmp-&gt;rectype); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	if (__recsize) \</span>
<span class="cp">		__kfifo_dma_in_finish_r(__kfifo, __len, __recsize); \</span>
<span class="cp">	else \</span>
<span class="cp">		__kfifo-&gt;in += __len / sizeof(*__tmp-&gt;type); \</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_dma_out_prepare - setup a scatterlist for DMA output</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> * @sgl: pointer to the scatterlist array</span>
<span class="cm"> * @nents: number of entries in the scatterlist array</span>
<span class="cm"> * @len: number of elements to transfer</span>
<span class="cm"> *</span>
<span class="cm"> * This macro fills a scatterlist for DMA output which at most @len bytes</span>
<span class="cm"> * to transfer.</span>
<span class="cm"> * It returns the number entries in the scatterlist array.</span>
<span class="cm"> * A zero means there is no space available and the scatterlist is not filled.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that with only one concurrent reader and one concurrent</span>
<span class="cm"> * writer, you don&#39;t need extra locking to use these macros.</span>
<span class="cm"> */</span>
<span class="cp">#define	kfifo_dma_out_prepare(fifo, sgl, nents, len) \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo);  \</span>
<span class="cp">	struct scatterlist *__sgl = (sgl); \</span>
<span class="cp">	int __nents = (nents); \</span>
<span class="cp">	unsigned int __len = (len); \</span>
<span class="cp">	const size_t __recsize = sizeof(*__tmp-&gt;rectype); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	(__recsize) ? \</span>
<span class="cp">	__kfifo_dma_out_prepare_r(__kfifo, __sgl, __nents, __len, __recsize) : \</span>
<span class="cp">	__kfifo_dma_out_prepare(__kfifo, __sgl, __nents, __len); \</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_dma_out_finish - finish a DMA OUT operation</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> * @len: number of bytes transferd</span>
<span class="cm"> *</span>
<span class="cm"> * This macro finish a DMA OUT operation. The out counter will be updated by</span>
<span class="cm"> * the len parameter. No error checking will be done.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that with only one concurrent reader and one concurrent</span>
<span class="cm"> * writer, you don&#39;t need extra locking to use these macros.</span>
<span class="cm"> */</span>
<span class="cp">#define kfifo_dma_out_finish(fifo, len) \</span>
<span class="cp">(void)({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	unsigned int __len = (len); \</span>
<span class="cp">	const size_t __recsize = sizeof(*__tmp-&gt;rectype); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	if (__recsize) \</span>
<span class="cp">		__kfifo_dma_out_finish_r(__kfifo, __recsize); \</span>
<span class="cp">	else \</span>
<span class="cp">		__kfifo-&gt;out += __len / sizeof(*__tmp-&gt;type); \</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * kfifo_out_peek - gets some data from the fifo</span>
<span class="cm"> * @fifo: address of the fifo to be used</span>
<span class="cm"> * @buf: pointer to the storage buffer</span>
<span class="cm"> * @n: max. number of elements to get</span>
<span class="cm"> *</span>
<span class="cm"> * This macro get the data from the fifo and return the numbers of elements</span>
<span class="cm"> * copied. The data is not removed from the fifo.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that with only one concurrent reader and one concurrent</span>
<span class="cm"> * writer, you don&#39;t need extra locking to use these macro.</span>
<span class="cm"> */</span>
<span class="cp">#define	kfifo_out_peek(fifo, buf, n) \</span>
<span class="cp">__kfifo_uint_must_check_helper( \</span>
<span class="cp">({ \</span>
<span class="cp">	typeof((fifo) + 1) __tmp = (fifo); \</span>
<span class="cp">	typeof((buf) + 1) __buf = (buf); \</span>
<span class="cp">	unsigned long __n = (n); \</span>
<span class="cp">	const size_t __recsize = sizeof(*__tmp-&gt;rectype); \</span>
<span class="cp">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span>
<span class="cp">	if (0) { \</span>
<span class="cp">		typeof(__tmp-&gt;ptr) __dummy __attribute__ ((unused)) = NULL; \</span>
<span class="cp">		__buf = __dummy; \</span>
<span class="cp">	} \</span>
<span class="cp">	(__recsize) ? \</span>
<span class="cp">	__kfifo_out_peek_r(__kfifo, __buf, __n, __recsize) : \</span>
<span class="cp">	__kfifo_out_peek(__kfifo, __buf, __n); \</span>
<span class="cp">}) \</span>
<span class="cp">)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__kfifo_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">esize</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__kfifo_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__kfifo_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">esize</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__kfifo_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__kfifo_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__kfifo_from_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">copied</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__kfifo_to_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">copied</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__kfifo_dma_in_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__kfifo_dma_out_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__kfifo_out_peek</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__kfifo_in_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">recsize</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__kfifo_out_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">recsize</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__kfifo_from_user_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">copied</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">recsize</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__kfifo_to_user_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">copied</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">recsize</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__kfifo_dma_in_prepare_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">recsize</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__kfifo_dma_in_finish_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">recsize</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__kfifo_dma_out_prepare_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">recsize</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__kfifo_dma_out_finish_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">recsize</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__kfifo_len_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">recsize</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__kfifo_skip_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">recsize</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__kfifo_out_peek_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">__kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">recsize</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__kfifo_max_r</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">recsize</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
