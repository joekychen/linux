<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › netfilter_arp › arp_tables.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>arp_tables.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * 	Format of an ARP firewall descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * 	src, tgt, src_mask, tgt_mask, arpop, arpop_mask are always stored in</span>
<span class="cm"> *	network byte order.</span>
<span class="cm"> * 	flags are stored in host byte order (of course).</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ARPTABLES_H</span>
<span class="cp">#define _ARPTABLES_H</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/if.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter_arp.h&gt;</span>

<span class="cp">#include &lt;linux/netfilter/x_tables.h&gt;</span>

<span class="cp">#ifndef __KERNEL__</span>
<span class="cp">#define ARPT_FUNCTION_MAXNAMELEN XT_FUNCTION_MAXNAMELEN</span>
<span class="cp">#define ARPT_TABLE_MAXNAMELEN XT_TABLE_MAXNAMELEN</span>
<span class="cp">#define arpt_entry_target xt_entry_target</span>
<span class="cp">#define arpt_standard_target xt_standard_target</span>
<span class="cp">#define arpt_error_target xt_error_target</span>
<span class="cp">#define ARPT_CONTINUE XT_CONTINUE</span>
<span class="cp">#define ARPT_RETURN XT_RETURN</span>
<span class="cp">#define arpt_counters_info xt_counters_info</span>
<span class="cp">#define arpt_counters xt_counters</span>
<span class="cp">#define ARPT_STANDARD_TARGET XT_STANDARD_TARGET</span>
<span class="cp">#define ARPT_ERROR_TARGET XT_ERROR_TARGET</span>
<span class="cp">#define ARPT_ENTRY_ITERATE(entries, size, fn, args...) \</span>
<span class="cp">	XT_ENTRY_ITERATE(struct arpt_entry, entries, size, fn, ## args)</span>
<span class="cp">#endif</span>

<span class="cp">#define ARPT_DEV_ADDR_LEN_MAX 16</span>

<span class="k">struct</span> <span class="n">arpt_devaddr_info</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">addr</span><span class="p">[</span><span class="n">ARPT_DEV_ADDR_LEN_MAX</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">mask</span><span class="p">[</span><span class="n">ARPT_DEV_ADDR_LEN_MAX</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Yes, Virginia, you have to zero the padding. */</span>
<span class="k">struct</span> <span class="n">arpt_arp</span> <span class="p">{</span>
	<span class="cm">/* Source and target IP addr */</span>
	<span class="k">struct</span> <span class="n">in_addr</span> <span class="n">src</span><span class="p">,</span> <span class="n">tgt</span><span class="p">;</span>
	<span class="cm">/* Mask for src and target IP addr */</span>
	<span class="k">struct</span> <span class="n">in_addr</span> <span class="n">smsk</span><span class="p">,</span> <span class="n">tmsk</span><span class="p">;</span>

	<span class="cm">/* Device hw address length, src+target device addresses */</span>
	<span class="n">__u8</span> <span class="n">arhln</span><span class="p">,</span> <span class="n">arhln_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">arpt_devaddr_info</span> <span class="n">src_devaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">arpt_devaddr_info</span> <span class="n">tgt_devaddr</span><span class="p">;</span>

	<span class="cm">/* ARP operation code. */</span>
	<span class="n">__be16</span> <span class="n">arpop</span><span class="p">,</span> <span class="n">arpop_mask</span><span class="p">;</span>

	<span class="cm">/* ARP hardware address and protocol address format. */</span>
	<span class="n">__be16</span> <span class="n">arhrd</span><span class="p">,</span> <span class="n">arhrd_mask</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">arpro</span><span class="p">,</span> <span class="n">arpro_mask</span><span class="p">;</span>

	<span class="cm">/* The protocol address length is only accepted if it is 4</span>
<span class="cm">	 * so there is no use in offering a way to do filtering on it.</span>
<span class="cm">	 */</span>

	<span class="kt">char</span> <span class="n">iniface</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">],</span> <span class="n">outiface</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">iniface_mask</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">],</span> <span class="n">outiface_mask</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>

	<span class="cm">/* Flags word */</span>
	<span class="n">__u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="cm">/* Inverse flags */</span>
	<span class="n">__u16</span> <span class="n">invflags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Values for &quot;flag&quot; field in struct arpt_ip (general arp structure).</span>
<span class="cm"> * No flags defined yet.</span>
<span class="cm"> */</span>
<span class="cp">#define ARPT_F_MASK		0x00	</span><span class="cm">/* All possible flag bits mask. */</span><span class="cp"></span>

<span class="cm">/* Values for &quot;inv&quot; field in struct arpt_arp. */</span>
<span class="cp">#define ARPT_INV_VIA_IN		0x0001	</span><span class="cm">/* Invert the sense of IN IFACE. */</span><span class="cp"></span>
<span class="cp">#define ARPT_INV_VIA_OUT	0x0002	</span><span class="cm">/* Invert the sense of OUT IFACE */</span><span class="cp"></span>
<span class="cp">#define ARPT_INV_SRCIP		0x0004	</span><span class="cm">/* Invert the sense of SRC IP. */</span><span class="cp"></span>
<span class="cp">#define ARPT_INV_TGTIP		0x0008	</span><span class="cm">/* Invert the sense of TGT IP. */</span><span class="cp"></span>
<span class="cp">#define ARPT_INV_SRCDEVADDR	0x0010	</span><span class="cm">/* Invert the sense of SRC DEV ADDR. */</span><span class="cp"></span>
<span class="cp">#define ARPT_INV_TGTDEVADDR	0x0020	</span><span class="cm">/* Invert the sense of TGT DEV ADDR. */</span><span class="cp"></span>
<span class="cp">#define ARPT_INV_ARPOP		0x0040	</span><span class="cm">/* Invert the sense of ARP OP. */</span><span class="cp"></span>
<span class="cp">#define ARPT_INV_ARPHRD		0x0080	</span><span class="cm">/* Invert the sense of ARP HRD. */</span><span class="cp"></span>
<span class="cp">#define ARPT_INV_ARPPRO		0x0100	</span><span class="cm">/* Invert the sense of ARP PRO. */</span><span class="cp"></span>
<span class="cp">#define ARPT_INV_ARPHLN		0x0200	</span><span class="cm">/* Invert the sense of ARP HLN. */</span><span class="cp"></span>
<span class="cp">#define ARPT_INV_MASK		0x03FF	</span><span class="cm">/* All possible flag bits mask. */</span><span class="cp"></span>

<span class="cm">/* This structure defines each of the firewall rules.  Consists of 3</span>
<span class="cm">   parts which are 1) general ARP header stuff 2) match specific</span>
<span class="cm">   stuff 3) the target to perform if the rule matches */</span>
<span class="k">struct</span> <span class="n">arpt_entry</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">arpt_arp</span> <span class="n">arp</span><span class="p">;</span>

	<span class="cm">/* Size of arpt_entry + matches */</span>
	<span class="n">__u16</span> <span class="n">target_offset</span><span class="p">;</span>
	<span class="cm">/* Size of arpt_entry + matches + target */</span>
	<span class="n">__u16</span> <span class="n">next_offset</span><span class="p">;</span>

	<span class="cm">/* Back pointer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">comefrom</span><span class="p">;</span>

	<span class="cm">/* Packet and byte counters. */</span>
	<span class="k">struct</span> <span class="n">xt_counters</span> <span class="n">counters</span><span class="p">;</span>

	<span class="cm">/* The matches (if any), then the target. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">elems</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * New IP firewall options for [gs]etsockopt at the RAW IP level.</span>
<span class="cm"> * Unlike BSD Linux inherits IP options so you don&#39;t have to use a raw</span>
<span class="cm"> * socket for this. Instead we check rights in the calls.</span>
<span class="cm"> *</span>
<span class="cm"> * ATTENTION: check linux/in.h before adding new number here.</span>
<span class="cm"> */</span>
<span class="cp">#define ARPT_BASE_CTL		96</span>

<span class="cp">#define ARPT_SO_SET_REPLACE		(ARPT_BASE_CTL)</span>
<span class="cp">#define ARPT_SO_SET_ADD_COUNTERS	(ARPT_BASE_CTL + 1)</span>
<span class="cp">#define ARPT_SO_SET_MAX			ARPT_SO_SET_ADD_COUNTERS</span>

<span class="cp">#define ARPT_SO_GET_INFO		(ARPT_BASE_CTL)</span>
<span class="cp">#define ARPT_SO_GET_ENTRIES		(ARPT_BASE_CTL + 1)</span>
<span class="cm">/* #define ARPT_SO_GET_REVISION_MATCH	(APRT_BASE_CTL + 2) */</span>
<span class="cp">#define ARPT_SO_GET_REVISION_TARGET	(ARPT_BASE_CTL + 3)</span>
<span class="cp">#define ARPT_SO_GET_MAX			(ARPT_SO_GET_REVISION_TARGET)</span>

<span class="cm">/* The argument to ARPT_SO_GET_INFO */</span>
<span class="k">struct</span> <span class="n">arpt_getinfo</span> <span class="p">{</span>
	<span class="cm">/* Which table: caller fills this in. */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">XT_TABLE_MAXNAMELEN</span><span class="p">];</span>

	<span class="cm">/* Kernel fills these in. */</span>
	<span class="cm">/* Which hook entry points are valid: bitmask */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">valid_hooks</span><span class="p">;</span>

	<span class="cm">/* Hook entry points: one per netfilter hook. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook_entry</span><span class="p">[</span><span class="n">NF_ARP_NUMHOOKS</span><span class="p">];</span>

	<span class="cm">/* Underflow points. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">underflow</span><span class="p">[</span><span class="n">NF_ARP_NUMHOOKS</span><span class="p">];</span>

	<span class="cm">/* Number of entries */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_entries</span><span class="p">;</span>

	<span class="cm">/* Size of entries. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The argument to ARPT_SO_SET_REPLACE. */</span>
<span class="k">struct</span> <span class="n">arpt_replace</span> <span class="p">{</span>
	<span class="cm">/* Which table. */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">XT_TABLE_MAXNAMELEN</span><span class="p">];</span>

	<span class="cm">/* Which hook entry points are valid: bitmask.  You can&#39;t</span>
<span class="cm">           change this. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">valid_hooks</span><span class="p">;</span>

	<span class="cm">/* Number of entries */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_entries</span><span class="p">;</span>

	<span class="cm">/* Total size of new entries */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* Hook entry points. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook_entry</span><span class="p">[</span><span class="n">NF_ARP_NUMHOOKS</span><span class="p">];</span>

	<span class="cm">/* Underflow points. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">underflow</span><span class="p">[</span><span class="n">NF_ARP_NUMHOOKS</span><span class="p">];</span>

	<span class="cm">/* Information about old entries: */</span>
	<span class="cm">/* Number of counters (must be equal to current number of entries). */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_counters</span><span class="p">;</span>
	<span class="cm">/* The old entries&#39; counters. */</span>
	<span class="k">struct</span> <span class="n">xt_counters</span> <span class="n">__user</span> <span class="o">*</span><span class="n">counters</span><span class="p">;</span>

	<span class="cm">/* The entries (hang off end: not really an array). */</span>
	<span class="k">struct</span> <span class="n">arpt_entry</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* The argument to ARPT_SO_GET_ENTRIES. */</span>
<span class="k">struct</span> <span class="n">arpt_get_entries</span> <span class="p">{</span>
	<span class="cm">/* Which table: user fills this in. */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">XT_TABLE_MAXNAMELEN</span><span class="p">];</span>

	<span class="cm">/* User fills this in: total entry size. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* The entries. */</span>
	<span class="k">struct</span> <span class="n">arpt_entry</span> <span class="n">entrytable</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Helper functions */</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="k">struct</span> <span class="n">xt_entry_target</span> <span class="o">*</span><span class="nf">arpt_get_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">arpt_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Main firewall chains definitions and global var&#39;s definitions.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/* Standard entry. */</span>
<span class="k">struct</span> <span class="n">arpt_standard</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">arpt_entry</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xt_standard_target</span> <span class="n">target</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">arpt_error</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">arpt_entry</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xt_error_target</span> <span class="n">target</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define ARPT_ENTRY_INIT(__size)						       \</span>
<span class="cp">{									       \</span>
<span class="cp">	.target_offset	= sizeof(struct arpt_entry),			       \</span>
<span class="cp">	.next_offset	= (__size),					       \</span>
<span class="cp">}</span>

<span class="cp">#define ARPT_STANDARD_INIT(__verdict)					       \</span>
<span class="cp">{									       \</span>
<span class="cp">	.entry		= ARPT_ENTRY_INIT(sizeof(struct arpt_standard)),       \</span>
<span class="cp">	.target		= XT_TARGET_INIT(XT_STANDARD_TARGET,		       \</span>
<span class="cp">					 sizeof(struct xt_standard_target)), \</span>
<span class="cp">	.target.verdict	= -(__verdict) - 1,				       \</span>
<span class="cp">}</span>

<span class="cp">#define ARPT_ERROR_INIT							       \</span>
<span class="cp">{									       \</span>
<span class="cp">	.entry		= ARPT_ENTRY_INIT(sizeof(struct arpt_error)),	       \</span>
<span class="cp">	.target		= XT_TARGET_INIT(XT_ERROR_TARGET,		       \</span>
<span class="cp">					 sizeof(struct xt_error_target)),      \</span>
<span class="cp">	.target.errorname = &quot;ERROR&quot;,					       \</span>
<span class="cp">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arpt_alloc_initial_table</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xt_table</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xt_table</span> <span class="o">*</span><span class="n">arpt_register_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
					    <span class="k">const</span> <span class="k">struct</span> <span class="n">xt_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span>
					    <span class="k">const</span> <span class="k">struct</span> <span class="n">arpt_replace</span> <span class="o">*</span><span class="n">repl</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">arpt_unregister_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">xt_table</span> <span class="o">*</span><span class="n">table</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arpt_do_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">xt_table</span> <span class="o">*</span><span class="n">table</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="cp">#include &lt;net/compat.h&gt;</span>

<span class="k">struct</span> <span class="n">compat_arpt_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">arpt_arp</span> <span class="n">arp</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">target_offset</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">next_offset</span><span class="p">;</span>
	<span class="n">compat_uint_t</span> <span class="n">comefrom</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">compat_xt_counters</span> <span class="n">counters</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">elems</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">xt_entry_target</span> <span class="o">*</span>
<span class="nf">compat_arpt_get_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_arpt_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_COMPAT */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/*__KERNEL__*/</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _ARPTABLES_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
