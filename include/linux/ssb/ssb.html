<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › ssb › ssb.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ssb.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef LINUX_SSB_H_</span>
<span class="cp">#define LINUX_SSB_H_</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/mod_devicetable.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>

<span class="cp">#include &lt;linux/ssb/ssb_regs.h&gt;</span>


<span class="k">struct</span> <span class="n">pcmcia_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ssb_bus</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ssb_driver</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ssb_sprom_core_pwr_info</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">itssi_2g</span><span class="p">,</span> <span class="n">itssi_5g</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">maxpwr_2g</span><span class="p">,</span> <span class="n">maxpwr_5gl</span><span class="p">,</span> <span class="n">maxpwr_5g</span><span class="p">,</span> <span class="n">maxpwr_5gh</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pa_2g</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">pa_5gl</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">pa_5g</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">pa_5gh</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ssb_sprom</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">revision</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">il0mac</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>		<span class="cm">/* MAC address for 802.11b/g */</span>
	<span class="n">u8</span> <span class="n">et0mac</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>		<span class="cm">/* MAC address for Ethernet */</span>
	<span class="n">u8</span> <span class="n">et1mac</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>		<span class="cm">/* MAC address for 802.11a */</span>
	<span class="n">u8</span> <span class="n">et0phyaddr</span><span class="p">;</span>		<span class="cm">/* MII address for enet0 */</span>
	<span class="n">u8</span> <span class="n">et1phyaddr</span><span class="p">;</span>		<span class="cm">/* MII address for enet1 */</span>
	<span class="n">u8</span> <span class="n">et0mdcport</span><span class="p">;</span>		<span class="cm">/* MDIO for enet0 */</span>
	<span class="n">u8</span> <span class="n">et1mdcport</span><span class="p">;</span>		<span class="cm">/* MDIO for enet1 */</span>
	<span class="n">u16</span> <span class="n">board_rev</span><span class="p">;</span>		<span class="cm">/* Board revision number from SPROM. */</span>
	<span class="n">u16</span> <span class="n">board_num</span><span class="p">;</span>		<span class="cm">/* Board number from SPROM. */</span>
	<span class="n">u16</span> <span class="n">board_type</span><span class="p">;</span>		<span class="cm">/* Board type from SPROM. */</span>
	<span class="n">u8</span> <span class="n">country_code</span><span class="p">;</span>	<span class="cm">/* Country Code */</span>
	<span class="kt">char</span> <span class="n">alpha2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>		<span class="cm">/* Country Code as two chars like EU or US */</span>
	<span class="n">u8</span> <span class="n">leddc_on_time</span><span class="p">;</span>	<span class="cm">/* LED Powersave Duty Cycle On Count */</span>
	<span class="n">u8</span> <span class="n">leddc_off_time</span><span class="p">;</span>	<span class="cm">/* LED Powersave Duty Cycle Off Count */</span>
	<span class="n">u8</span> <span class="n">ant_available_a</span><span class="p">;</span>	<span class="cm">/* 2GHz antenna available bits (up to 4) */</span>
	<span class="n">u8</span> <span class="n">ant_available_bg</span><span class="p">;</span>	<span class="cm">/* 5GHz antenna available bits (up to 4) */</span>
	<span class="n">u16</span> <span class="n">pa0b0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pa0b1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pa0b2</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pa1b0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pa1b1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pa1b2</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pa1lob0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pa1lob1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pa1lob2</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pa1hib0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pa1hib1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pa1hib2</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">gpio0</span><span class="p">;</span>		<span class="cm">/* GPIO pin 0 */</span>
	<span class="n">u8</span> <span class="n">gpio1</span><span class="p">;</span>		<span class="cm">/* GPIO pin 1 */</span>
	<span class="n">u8</span> <span class="n">gpio2</span><span class="p">;</span>		<span class="cm">/* GPIO pin 2 */</span>
	<span class="n">u8</span> <span class="n">gpio3</span><span class="p">;</span>		<span class="cm">/* GPIO pin 3 */</span>
	<span class="n">u8</span> <span class="n">maxpwr_bg</span><span class="p">;</span>		<span class="cm">/* 2.4GHz Amplifier Max Power (in dBm Q5.2) */</span>
	<span class="n">u8</span> <span class="n">maxpwr_al</span><span class="p">;</span>		<span class="cm">/* 5.2GHz Amplifier Max Power (in dBm Q5.2) */</span>
	<span class="n">u8</span> <span class="n">maxpwr_a</span><span class="p">;</span>		<span class="cm">/* 5.3GHz Amplifier Max Power (in dBm Q5.2) */</span>
	<span class="n">u8</span> <span class="n">maxpwr_ah</span><span class="p">;</span>		<span class="cm">/* 5.8GHz Amplifier Max Power (in dBm Q5.2) */</span>
	<span class="n">u8</span> <span class="n">itssi_a</span><span class="p">;</span>		<span class="cm">/* Idle TSSI Target for A-PHY */</span>
	<span class="n">u8</span> <span class="n">itssi_bg</span><span class="p">;</span>		<span class="cm">/* Idle TSSI Target for B/G-PHY */</span>
	<span class="n">u8</span> <span class="n">tri2g</span><span class="p">;</span>		<span class="cm">/* 2.4GHz TX isolation */</span>
	<span class="n">u8</span> <span class="n">tri5gl</span><span class="p">;</span>		<span class="cm">/* 5.2GHz TX isolation */</span>
	<span class="n">u8</span> <span class="n">tri5g</span><span class="p">;</span>		<span class="cm">/* 5.3GHz TX isolation */</span>
	<span class="n">u8</span> <span class="n">tri5gh</span><span class="p">;</span>		<span class="cm">/* 5.8GHz TX isolation */</span>
	<span class="n">u8</span> <span class="n">txpid2g</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>		<span class="cm">/* 2GHz TX power index */</span>
	<span class="n">u8</span> <span class="n">txpid5gl</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>		<span class="cm">/* 4.9 - 5.1GHz TX power index */</span>
	<span class="n">u8</span> <span class="n">txpid5g</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>		<span class="cm">/* 5.1 - 5.5GHz TX power index */</span>
	<span class="n">u8</span> <span class="n">txpid5gh</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>		<span class="cm">/* 5.5 - ...GHz TX power index */</span>
	<span class="n">s8</span> <span class="n">rxpo2g</span><span class="p">;</span>		<span class="cm">/* 2GHz RX power offset */</span>
	<span class="n">s8</span> <span class="n">rxpo5g</span><span class="p">;</span>		<span class="cm">/* 5GHz RX power offset */</span>
	<span class="n">u8</span> <span class="n">rssisav2g</span><span class="p">;</span>		<span class="cm">/* 2GHz RSSI params */</span>
	<span class="n">u8</span> <span class="n">rssismc2g</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rssismf2g</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bxa2g</span><span class="p">;</span>		<span class="cm">/* 2GHz BX arch */</span>
	<span class="n">u8</span> <span class="n">rssisav5g</span><span class="p">;</span>		<span class="cm">/* 5GHz RSSI params */</span>
	<span class="n">u8</span> <span class="n">rssismc5g</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rssismf5g</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bxa5g</span><span class="p">;</span>		<span class="cm">/* 5GHz BX arch */</span>
	<span class="n">u16</span> <span class="n">cck2gpo</span><span class="p">;</span>		<span class="cm">/* CCK power offset */</span>
	<span class="n">u32</span> <span class="n">ofdm2gpo</span><span class="p">;</span>		<span class="cm">/* 2.4GHz OFDM power offset */</span>
	<span class="n">u32</span> <span class="n">ofdm5glpo</span><span class="p">;</span>		<span class="cm">/* 5.2GHz OFDM power offset */</span>
	<span class="n">u32</span> <span class="n">ofdm5gpo</span><span class="p">;</span>		<span class="cm">/* 5.3GHz OFDM power offset */</span>
	<span class="n">u32</span> <span class="n">ofdm5ghpo</span><span class="p">;</span>		<span class="cm">/* 5.8GHz OFDM power offset */</span>
	<span class="n">u16</span> <span class="n">boardflags_lo</span><span class="p">;</span>	<span class="cm">/* Board flags (bits 0-15) */</span>
	<span class="n">u16</span> <span class="n">boardflags_hi</span><span class="p">;</span>	<span class="cm">/* Board flags (bits 16-31) */</span>
	<span class="n">u16</span> <span class="n">boardflags2_lo</span><span class="p">;</span>	<span class="cm">/* Board flags (bits 32-47) */</span>
	<span class="n">u16</span> <span class="n">boardflags2_hi</span><span class="p">;</span>	<span class="cm">/* Board flags (bits 48-63) */</span>
	<span class="cm">/* TODO store board flags in a single u64 */</span>

	<span class="k">struct</span> <span class="n">ssb_sprom_core_pwr_info</span> <span class="n">core_pwr_info</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="cm">/* Antenna gain values for up to 4 antennas</span>
<span class="cm">	 * on each band. Values in dBm/4 (Q5.2). Negative gain means the</span>
<span class="cm">	 * loss in the connectors is bigger than the gain. */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">s8</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">antenna_gain</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">tssipos</span><span class="p">,</span> <span class="n">extpa_gain</span><span class="p">,</span> <span class="n">pdet_range</span><span class="p">,</span> <span class="n">tr_iso</span><span class="p">,</span> <span class="n">antswlut</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">ghz2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">tssipos</span><span class="p">,</span> <span class="n">extpa_gain</span><span class="p">,</span> <span class="n">pdet_range</span><span class="p">,</span> <span class="n">tr_iso</span><span class="p">,</span> <span class="n">antswlut</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">ghz5</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">fem</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">mcs2gpo</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">mcs5gpo</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">mcs5glpo</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">mcs5ghpo</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">opo</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">rxgainerr2ga</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">rxgainerr5gla</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">rxgainerr5gma</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">rxgainerr5gha</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">rxgainerr5gua</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="n">u8</span> <span class="n">noiselvl2ga</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">noiselvl5gla</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">noiselvl5gma</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">noiselvl5gha</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">noiselvl5gua</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="n">u8</span> <span class="n">regrev</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">txchain</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rxchain</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">antswitch</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cddpo</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">stbcpo</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">bw40po</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">bwduppo</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">tempthresh</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tempoffset</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">rawtempsense</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">measpower</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tempsense_slope</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tempcorrx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tempsense_option</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">freqoffset_corr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">iqcal_swp_dis</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hw_iqcal_en</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">elna2g</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">elna5g</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">phycal_tempdelta</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">temps_period</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">temps_hysteresis</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">measpower1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">measpower2</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pcieingress_war</span><span class="p">;</span>

	<span class="cm">/* power per rate from sromrev 9 */</span>
	<span class="n">u16</span> <span class="n">cckbw202gpo</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cckbw20ul2gpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">legofdmbw202gpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">legofdmbw20ul2gpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">legofdmbw205glpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">legofdmbw20ul5glpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">legofdmbw205gmpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">legofdmbw20ul5gmpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">legofdmbw205ghpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">legofdmbw20ul5ghpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mcsbw202gpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mcsbw20ul2gpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mcsbw402gpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mcsbw205glpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mcsbw20ul5glpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mcsbw405glpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mcsbw205gmpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mcsbw20ul5gmpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mcsbw405gmpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mcsbw205ghpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mcsbw20ul5ghpo</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mcsbw405ghpo</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mcs32po</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">legofdm40duppo</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sar2g</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sar5g</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Information about the PCB the circuitry is soldered on. */</span>
<span class="k">struct</span> <span class="n">ssb_boardinfo</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">vendor</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">ssb_device</span><span class="p">;</span>
<span class="cm">/* Lowlevel read/write operations on the device MMIO.</span>
<span class="cm"> * Internal, don&#39;t use that outside of ssb. */</span>
<span class="k">struct</span> <span class="n">ssb_bus_ops</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="p">(</span><span class="o">*</span><span class="n">read8</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">u16</span> <span class="p">(</span><span class="o">*</span><span class="n">read16</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">read32</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write8</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write16</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write32</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SSB_BLOCKIO</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">block_read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg_width</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">block_write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg_width</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">};</span>


<span class="cm">/* Core-ID values. */</span>
<span class="cp">#define SSB_DEV_CHIPCOMMON	0x800</span>
<span class="cp">#define SSB_DEV_ILINE20		0x801</span>
<span class="cp">#define SSB_DEV_SDRAM		0x803</span>
<span class="cp">#define SSB_DEV_PCI		0x804</span>
<span class="cp">#define SSB_DEV_MIPS		0x805</span>
<span class="cp">#define SSB_DEV_ETHERNET	0x806</span>
<span class="cp">#define SSB_DEV_V90		0x807</span>
<span class="cp">#define SSB_DEV_USB11_HOSTDEV	0x808</span>
<span class="cp">#define SSB_DEV_ADSL		0x809</span>
<span class="cp">#define SSB_DEV_ILINE100	0x80A</span>
<span class="cp">#define SSB_DEV_IPSEC		0x80B</span>
<span class="cp">#define SSB_DEV_PCMCIA		0x80D</span>
<span class="cp">#define SSB_DEV_INTERNAL_MEM	0x80E</span>
<span class="cp">#define SSB_DEV_MEMC_SDRAM	0x80F</span>
<span class="cp">#define SSB_DEV_EXTIF		0x811</span>
<span class="cp">#define SSB_DEV_80211		0x812</span>
<span class="cp">#define SSB_DEV_MIPS_3302	0x816</span>
<span class="cp">#define SSB_DEV_USB11_HOST	0x817</span>
<span class="cp">#define SSB_DEV_USB11_DEV	0x818</span>
<span class="cp">#define SSB_DEV_USB20_HOST	0x819</span>
<span class="cp">#define SSB_DEV_USB20_DEV	0x81A</span>
<span class="cp">#define SSB_DEV_SDIO_HOST	0x81B</span>
<span class="cp">#define SSB_DEV_ROBOSWITCH	0x81C</span>
<span class="cp">#define SSB_DEV_PARA_ATA	0x81D</span>
<span class="cp">#define SSB_DEV_SATA_XORDMA	0x81E</span>
<span class="cp">#define SSB_DEV_ETHERNET_GBIT	0x81F</span>
<span class="cp">#define SSB_DEV_PCIE		0x820</span>
<span class="cp">#define SSB_DEV_MIMO_PHY	0x821</span>
<span class="cp">#define SSB_DEV_SRAM_CTRLR	0x822</span>
<span class="cp">#define SSB_DEV_MINI_MACPHY	0x823</span>
<span class="cp">#define SSB_DEV_ARM_1176	0x824</span>
<span class="cp">#define SSB_DEV_ARM_7TDMI	0x825</span>

<span class="cm">/* Vendor-ID values */</span>
<span class="cp">#define SSB_VENDOR_BROADCOM	0x4243</span>

<span class="cm">/* Some kernel subsystems poke with dev-&gt;drvdata, so we must use the</span>
<span class="cm"> * following ugly workaround to get from struct device to struct ssb_device */</span>
<span class="k">struct</span> <span class="n">__ssb_dev_wrapper</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ssb_device</span> <span class="p">{</span>
	<span class="cm">/* Having a copy of the ops pointer in each dev struct</span>
<span class="cm">	 * is an optimization. */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ssb_bus_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">dma_dev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ssb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ssb_device_id</span> <span class="n">id</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">core_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="cm">/* Internal-only stuff follows. */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">drvdata</span><span class="p">;</span>		<span class="cm">/* Per-device data */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">devtypedata</span><span class="p">;</span>	<span class="cm">/* Per-devicetype (eg 802.11) data */</span>
<span class="p">};</span>

<span class="cm">/* Go from struct device to struct ssb_device. */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span> <span class="nf">dev_to_ssb_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">__ssb_dev_wrapper</span> <span class="o">*</span><span class="n">wrap</span><span class="p">;</span>
	<span class="n">wrap</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__ssb_dev_wrapper</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">wrap</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Device specific user data */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">ssb_set_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">drvdata</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">ssb_get_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">drvdata</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Devicetype specific user data. This is per device-type (not per device) */</span>
<span class="kt">void</span> <span class="n">ssb_set_devtypedata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">ssb_get_devtypedata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devtypedata</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">struct</span> <span class="n">ssb_driver</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ssb_device_id</span> <span class="o">*</span><span class="n">id_table</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ssb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">device_driver</span> <span class="n">drv</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define drv_to_ssb_drv(_drv) container_of(_drv, struct ssb_driver, drv)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__ssb_driver_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">);</span>
<span class="cp">#define ssb_driver_register(drv) \</span>
<span class="cp">	__ssb_driver_register(drv, THIS_MODULE)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ssb_driver_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">);</span>




<span class="k">enum</span> <span class="n">ssb_bustype</span> <span class="p">{</span>
	<span class="n">SSB_BUSTYPE_SSB</span><span class="p">,</span>	<span class="cm">/* This SSB bus is the system bus */</span>
	<span class="n">SSB_BUSTYPE_PCI</span><span class="p">,</span>	<span class="cm">/* SSB is connected to PCI bus */</span>
	<span class="n">SSB_BUSTYPE_PCMCIA</span><span class="p">,</span>	<span class="cm">/* SSB is connected to PCMCIA bus */</span>
	<span class="n">SSB_BUSTYPE_SDIO</span><span class="p">,</span>	<span class="cm">/* SSB is connected to SDIO bus */</span>
<span class="p">};</span>

<span class="cm">/* board_vendor */</span>
<span class="cp">#define SSB_BOARDVENDOR_BCM	0x14E4	</span><span class="cm">/* Broadcom */</span><span class="cp"></span>
<span class="cp">#define SSB_BOARDVENDOR_DELL	0x1028	</span><span class="cm">/* Dell */</span><span class="cp"></span>
<span class="cp">#define SSB_BOARDVENDOR_HP	0x0E11	</span><span class="cm">/* HP */</span><span class="cp"></span>
<span class="cm">/* board_type */</span>
<span class="cp">#define SSB_BOARD_BCM94306MP	0x0418</span>
<span class="cp">#define SSB_BOARD_BCM4309G	0x0421</span>
<span class="cp">#define SSB_BOARD_BCM4306CB	0x0417</span>
<span class="cp">#define SSB_BOARD_BCM4309MP	0x040C</span>
<span class="cp">#define SSB_BOARD_MP4318	0x044A</span>
<span class="cp">#define SSB_BOARD_BU4306	0x0416</span>
<span class="cp">#define SSB_BOARD_BU4309	0x040A</span>
<span class="cm">/* chip_package */</span>
<span class="cp">#define SSB_CHIPPACK_BCM4712S	1	</span><span class="cm">/* Small 200pin 4712 */</span><span class="cp"></span>
<span class="cp">#define SSB_CHIPPACK_BCM4712M	2	</span><span class="cm">/* Medium 225pin 4712 */</span><span class="cp"></span>
<span class="cp">#define SSB_CHIPPACK_BCM4712L	0	</span><span class="cm">/* Large 340pin 4712 */</span><span class="cp"></span>

<span class="cp">#include &lt;linux/ssb/ssb_driver_chipcommon.h&gt;</span>
<span class="cp">#include &lt;linux/ssb/ssb_driver_mips.h&gt;</span>
<span class="cp">#include &lt;linux/ssb/ssb_driver_extif.h&gt;</span>
<span class="cp">#include &lt;linux/ssb/ssb_driver_pci.h&gt;</span>

<span class="k">struct</span> <span class="n">ssb_bus</span> <span class="p">{</span>
	<span class="cm">/* The MMIO area. */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">ssb_bus_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>

	<span class="cm">/* The core currently mapped into the MMIO window.</span>
<span class="cm">	 * Not valid on all host-buses. So don&#39;t use outside of SSB. */</span>
	<span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">mapped_device</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="cm">/* Currently mapped PCMCIA segment. (bustype == SSB_BUSTYPE_PCMCIA only) */</span>
		<span class="n">u8</span> <span class="n">mapped_pcmcia_seg</span><span class="p">;</span>
		<span class="cm">/* Current SSB base address window for SDIO. */</span>
		<span class="n">u32</span> <span class="n">sdio_sbaddr</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="cm">/* Lock for core and segment switching.</span>
<span class="cm">	 * On PCMCIA-host busses this is used to protect the whole MMIO access. */</span>
	<span class="n">spinlock_t</span> <span class="n">bar_lock</span><span class="p">;</span>

	<span class="cm">/* The host-bus this backplane is running on. */</span>
	<span class="k">enum</span> <span class="n">ssb_bustype</span> <span class="n">bustype</span><span class="p">;</span>
	<span class="cm">/* Pointers to the host-bus. Check bustype before using any of these pointers. */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="cm">/* Pointer to the PCI bus (only valid if bustype == SSB_BUSTYPE_PCI). */</span>
		<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">host_pci</span><span class="p">;</span>
		<span class="cm">/* Pointer to the PCMCIA device (only if bustype == SSB_BUSTYPE_PCMCIA). */</span>
		<span class="k">struct</span> <span class="n">pcmcia_device</span> <span class="o">*</span><span class="n">host_pcmcia</span><span class="p">;</span>
		<span class="cm">/* Pointer to the SDIO device (only if bustype == SSB_BUSTYPE_SDIO). */</span>
		<span class="k">struct</span> <span class="n">sdio_func</span> <span class="o">*</span><span class="n">host_sdio</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/* See enum ssb_quirks */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">quirks</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SSB_SPROM</span>
	<span class="cm">/* Mutex to protect the SPROM writing. */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">sprom_mutex</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* ID information about the Chip. */</span>
	<span class="n">u16</span> <span class="n">chip_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">chip_rev</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">sprom_offset</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">sprom_size</span><span class="p">;</span>		<span class="cm">/* number of words in sprom */</span>
	<span class="n">u8</span> <span class="n">chip_package</span><span class="p">;</span>

	<span class="cm">/* List of devices (cores) on the backplane. */</span>
	<span class="k">struct</span> <span class="n">ssb_device</span> <span class="n">devices</span><span class="p">[</span><span class="n">SSB_MAX_NR_CORES</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">nr_devices</span><span class="p">;</span>

	<span class="cm">/* Software ID number for this bus. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">busnumber</span><span class="p">;</span>

	<span class="cm">/* The ChipCommon device (if available). */</span>
	<span class="k">struct</span> <span class="n">ssb_chipcommon</span> <span class="n">chipco</span><span class="p">;</span>
	<span class="cm">/* The PCI-core device (if available). */</span>
	<span class="k">struct</span> <span class="n">ssb_pcicore</span> <span class="n">pcicore</span><span class="p">;</span>
	<span class="cm">/* The MIPS-core device (if available). */</span>
	<span class="k">struct</span> <span class="n">ssb_mipscore</span> <span class="n">mipscore</span><span class="p">;</span>
	<span class="cm">/* The EXTif-core device (if available). */</span>
	<span class="k">struct</span> <span class="n">ssb_extif</span> <span class="n">extif</span><span class="p">;</span>

	<span class="cm">/* The following structure elements are not available in early</span>
<span class="cm">	 * SSB initialization. Though, they are available for regular</span>
<span class="cm">	 * registered drivers at any stage. So be careful when</span>
<span class="cm">	 * using them in the ssb core code. */</span>

	<span class="cm">/* ID information about the PCB. */</span>
	<span class="k">struct</span> <span class="n">ssb_boardinfo</span> <span class="n">boardinfo</span><span class="p">;</span>
	<span class="cm">/* Contents of the SPROM. */</span>
	<span class="k">struct</span> <span class="n">ssb_sprom</span> <span class="n">sprom</span><span class="p">;</span>
	<span class="cm">/* If the board has a cardbus slot, this is set to true. */</span>
	<span class="n">bool</span> <span class="n">has_cardbus_slot</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SSB_EMBEDDED</span>
	<span class="cm">/* Lock for GPIO register access. */</span>
	<span class="n">spinlock_t</span> <span class="n">gpio_lock</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* EMBEDDED */</span><span class="cp"></span>

	<span class="cm">/* Internal-only stuff follows. Do not touch. */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SSB_DEBUG</span>
	<span class="cm">/* Is the bus already powered up? */</span>
	<span class="n">bool</span> <span class="n">powered_up</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">power_warn_count</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ssb_quirks</span> <span class="p">{</span>
	<span class="cm">/* SDIO connected card requires performing a read after writing a 32-bit value */</span>
	<span class="n">SSB_QUIRK_SDIO_READ_AFTER_WRITE32</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/* The initialization-invariants. */</span>
<span class="k">struct</span> <span class="n">ssb_init_invariants</span> <span class="p">{</span>
	<span class="cm">/* Versioning information about the PCB. */</span>
	<span class="k">struct</span> <span class="n">ssb_boardinfo</span> <span class="n">boardinfo</span><span class="p">;</span>
	<span class="cm">/* The SPROM information. That&#39;s either stored in an</span>
<span class="cm">	 * EEPROM or NVRAM on the board. */</span>
	<span class="k">struct</span> <span class="n">ssb_sprom</span> <span class="n">sprom</span><span class="p">;</span>
	<span class="cm">/* If the board has a cardbus slot, this is set to true. */</span>
	<span class="n">bool</span> <span class="n">has_cardbus_slot</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/* Type of function to fetch the invariants. */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ssb_invariants_func_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ssb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ssb_init_invariants</span> <span class="o">*</span><span class="n">iv</span><span class="p">);</span>

<span class="cm">/* Register a SSB system bus. get_invariants() is called after the</span>
<span class="cm"> * basic system devices are initialized.</span>
<span class="cm"> * The invariants are usually fetched from some NVRAM.</span>
<span class="cm"> * Put the invariants into the struct pointed to by iv. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ssb_bus_ssbbus_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">baseaddr</span><span class="p">,</span>
				   <span class="n">ssb_invariants_func_t</span> <span class="n">get_invariants</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SSB_PCIHOST</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ssb_bus_pcibus_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">host_pci</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SSB_PCIHOST */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_SSB_PCMCIAHOST</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ssb_bus_pcmciabus_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">pcmcia_device</span> <span class="o">*</span><span class="n">pcmcia_dev</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">baseaddr</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SSB_PCMCIAHOST */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_SSB_SDIOHOST</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ssb_bus_sdiobus_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sdio_func</span> <span class="o">*</span><span class="n">sdio_func</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">quirks</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SSB_SDIOHOST */</span><span class="cp"></span>


<span class="k">extern</span> <span class="kt">void</span> <span class="n">ssb_bus_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

<span class="cm">/* Does the device have an SPROM? */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">ssb_is_sprom_available</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

<span class="cm">/* Set a fallback SPROM.</span>
<span class="cm"> * See kdoc at the function definition for complete documentation. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ssb_arch_register_fallback_sprom</span><span class="p">(</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sprom_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ssb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ssb_sprom</span> <span class="o">*</span><span class="n">out</span><span class="p">));</span>

<span class="cm">/* Suspend a SSB bus.</span>
<span class="cm"> * Call this from the parent bus suspend routine. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ssb_bus_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="cm">/* Resume a SSB bus.</span>
<span class="cm"> * Call this from the parent bus resume routine. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ssb_bus_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">u32</span> <span class="n">ssb_clockspeed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

<span class="cm">/* Is the device enabled in hardware? */</span>
<span class="kt">int</span> <span class="n">ssb_device_is_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cm">/* Enable a device and pass device-specific SSB_TMSLOW flags.</span>
<span class="cm"> * If no device-specific flags are available, use 0. */</span>
<span class="kt">void</span> <span class="n">ssb_device_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">core_specific_flags</span><span class="p">);</span>
<span class="cm">/* Disable a device in hardware and pass SSB_TMSLOW flags (if any). */</span>
<span class="kt">void</span> <span class="n">ssb_device_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">core_specific_flags</span><span class="p">);</span>


<span class="cm">/* Device MMIO register read/write functions. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">ssb_read8</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read8</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">ssb_read16</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read16</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ssb_read32</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read32</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ssb_write8</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write8</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ssb_write16</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write16</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ssb_write32</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write32</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#ifdef CONFIG_SSB_BLOCKIO</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ssb_block_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg_width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">block_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">reg_width</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ssb_block_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg_width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">block_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">reg_width</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SSB_BLOCKIO */</span><span class="cp"></span>


<span class="cm">/* The SSB DMA API. Use this API for any DMA operation on the device.</span>
<span class="cm"> * This API basically is a wrapper that calls the correct DMA API for</span>
<span class="cm"> * the host device type the SSB device is attached to. */</span>

<span class="cm">/* Translation (routing) bits that need to be ORed to DMA</span>
<span class="cm"> * addresses before they are given to a device. */</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">ssb_dma_translation</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#define SSB_DMA_TRANSLATION_MASK	0xC0000000</span>
<span class="cp">#define SSB_DMA_TRANSLATION_SHIFT	30</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__cold</span> <span class="nf">__ssb_dma_not_implemented</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SSB_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SSB: BUG! Calling DMA API for &quot;</span>
	       <span class="s">&quot;unsupported bustype %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bustype</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SSB_PCIHOST</span>
<span class="cm">/* PCI-host wrapper driver */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ssb_pcihost_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ssb_pcihost_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">ssb_pcihost_set_power_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bustype</span> <span class="o">==</span> <span class="n">SSB_BUSTYPE_PCI</span><span class="p">)</span>
		<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">host_pci</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ssb_pcihost_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">ssb_pcihost_set_power_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SSB_PCIHOST */</span><span class="cp"></span>


<span class="cm">/* If a driver is shutdown or suspended, call this to signal</span>
<span class="cm"> * that the bus may be completely powered down. SSB will decide,</span>
<span class="cm"> * if it&#39;s really time to power down the bus, based on if there</span>
<span class="cm"> * are other devices that want to run. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ssb_bus_may_powerdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="cm">/* Before initializing and enabling a device, call this to power-up the bus.</span>
<span class="cm"> * If you want to allow use of dynamic-power-control, pass the flag.</span>
<span class="cm"> * Otherwise static always-on powercontrol will be used. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ssb_bus_powerup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="n">bool</span> <span class="n">dynamic_pctl</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ssb_commit_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

<span class="cm">/* Various helper functions */</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">ssb_admatch_base</span><span class="p">(</span><span class="n">u32</span> <span class="n">adm</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">ssb_admatch_size</span><span class="p">(</span><span class="n">u32</span> <span class="n">adm</span><span class="p">);</span>

<span class="cm">/* PCI device mapping and fixup routines.</span>
<span class="cm"> * Called from the architecture pcibios init code.</span>
<span class="cm"> * These are only available on SSB_EMBEDDED configurations. */</span>
<span class="cp">#ifdef CONFIG_SSB_EMBEDDED</span>
<span class="kt">int</span> <span class="n">ssb_pcibios_plat_dev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ssb_pcibios_map_irq</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">slot</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pin</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SSB_EMBEDDED */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* LINUX_SSB_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
