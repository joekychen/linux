<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › module.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>module.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_MODULE_H</span>
<span class="cp">#define _LINUX_MODULE_H</span>
<span class="cm">/*</span>
<span class="cm"> * Dynamic loading of modules into the kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * Rewritten by Richard Henderson &lt;rth@tamu.edu&gt; Dec 1996</span>
<span class="cm"> * Rewritten again by Rusty Russell, 2002</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;linux/stringify.h&gt;</span>
<span class="cp">#include &lt;linux/kobject.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/tracepoint.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;asm/module.h&gt;</span>

<span class="cm">/* Not Yet Implemented */</span>
<span class="cp">#define MODULE_SUPPORTED_DEVICE(name)</span>

<span class="cp">#define MODULE_NAME_LEN MAX_PARAM_PREFIX_LEN</span>

<span class="k">struct</span> <span class="n">modversion_info</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">crc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">MODULE_NAME_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">module_kobject</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">drivers_dir</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module_param_attrs</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">module_attribute</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module_kobject</span> <span class="o">*</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)(</span><span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module_kobject</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test</span><span class="p">)(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">module_version_attribute</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">module_attribute</span> <span class="n">mattr</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">module_name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">version</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))));</span>

<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">__modver_version_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">module_kobject</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">module_attribute</span> <span class="n">module_uevent</span><span class="p">;</span>

<span class="cm">/* These are either module local, or the kernel&#39;s dummy ones. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Archs provide a method of finding the correct exception table. */</span>
<span class="k">struct</span> <span class="n">exception_table_entry</span><span class="p">;</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span>
<span class="n">search_extable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span>
	       <span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="n">last</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sort_extable</span><span class="p">(</span><span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="n">finish</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sort_main_extable</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">trim_init_extable</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">m</span><span class="p">);</span>

<span class="cp">#ifdef MODULE</span>
<span class="cp">#define MODULE_GENERIC_TABLE(gtype,name)			\</span>
<span class="cp">extern const struct gtype##_id __mod_##gtype##_table		\</span>
<span class="cp">  __attribute__ ((unused, alias(__stringify(name))))</span>

<span class="cp">#else  </span><span class="cm">/* !MODULE */</span><span class="cp"></span>
<span class="cp">#define MODULE_GENERIC_TABLE(gtype,name)</span>
<span class="cp">#endif</span>

<span class="cm">/* Generic info of form tag = &quot;info&quot; */</span>
<span class="cp">#define MODULE_INFO(tag, info) __MODULE_INFO(tag, tag, info)</span>

<span class="cm">/* For userspace: you can also call me... */</span>
<span class="cp">#define MODULE_ALIAS(_alias) MODULE_INFO(alias, _alias)</span>

<span class="cm">/*</span>
<span class="cm"> * The following license idents are currently accepted as indicating free</span>
<span class="cm"> * software modules</span>
<span class="cm"> *</span>
<span class="cm"> *	&quot;GPL&quot;				[GNU Public License v2 or later]</span>
<span class="cm"> *	&quot;GPL v2&quot;			[GNU Public License v2]</span>
<span class="cm"> *	&quot;GPL and additional rights&quot;	[GNU Public License v2 rights and more]</span>
<span class="cm"> *	&quot;Dual BSD/GPL&quot;			[GNU Public License v2</span>
<span class="cm"> *					 or BSD license choice]</span>
<span class="cm"> *	&quot;Dual MIT/GPL&quot;			[GNU Public License v2</span>
<span class="cm"> *					 or MIT license choice]</span>
<span class="cm"> *	&quot;Dual MPL/GPL&quot;			[GNU Public License v2</span>
<span class="cm"> *					 or Mozilla license choice]</span>
<span class="cm"> *</span>
<span class="cm"> * The following other idents are available</span>
<span class="cm"> *</span>
<span class="cm"> *	&quot;Proprietary&quot;			[Non free products]</span>
<span class="cm"> *</span>
<span class="cm"> * There are dual licensed components, but when running with Linux it is the</span>
<span class="cm"> * GPL that is relevant so this is a non issue. Similarly LGPL linked with GPL</span>
<span class="cm"> * is a GPL combined work.</span>
<span class="cm"> *</span>
<span class="cm"> * This exists for several reasons</span>
<span class="cm"> * 1.	So modinfo can show license info for users wanting to vet their setup </span>
<span class="cm"> *	is free</span>
<span class="cm"> * 2.	So the community can ignore bug reports including proprietary modules</span>
<span class="cm"> * 3.	So vendors can do likewise based on their own policies</span>
<span class="cm"> */</span>
<span class="cp">#define MODULE_LICENSE(_license) MODULE_INFO(license, _license)</span>

<span class="cm">/*</span>
<span class="cm"> * Author(s), use &quot;Name &lt;email&gt;&quot; or just &quot;Name&quot;, for multiple</span>
<span class="cm"> * authors use multiple MODULE_AUTHOR() statements/lines.</span>
<span class="cm"> */</span>
<span class="cp">#define MODULE_AUTHOR(_author) MODULE_INFO(author, _author)</span>
  
<span class="cm">/* What your module does. */</span>
<span class="cp">#define MODULE_DESCRIPTION(_description) MODULE_INFO(description, _description)</span>

<span class="cp">#define MODULE_DEVICE_TABLE(type,name)		\</span>
<span class="cp">  MODULE_GENERIC_TABLE(type##_device,name)</span>

<span class="cm">/* Version of form [&lt;epoch&gt;:]&lt;version&gt;[-&lt;extra-version&gt;].</span>
<span class="cm">   Or for CVS/RCS ID version, everything but the number is stripped.</span>
<span class="cm">  &lt;epoch&gt;: A (small) unsigned integer which allows you to start versions</span>
<span class="cm">           anew. If not mentioned, it&#39;s zero.  eg. &quot;2:1.0&quot; is after</span>
<span class="cm">	   &quot;1:2.0&quot;.</span>
<span class="cm">  &lt;version&gt;: The &lt;version&gt; may contain only alphanumerics and the</span>
<span class="cm">           character `.&#39;.  Ordered by numeric sort for numeric parts,</span>
<span class="cm">	   ascii sort for ascii parts (as per RPM or DEB algorithm).</span>
<span class="cm">  &lt;extraversion&gt;: Like &lt;version&gt;, but inserted for local</span>
<span class="cm">           customizations, eg &quot;rh3&quot; or &quot;rusty1&quot;.</span>

<span class="cm">  Using this automatically adds a checksum of the .c files and the</span>
<span class="cm">  local headers in &quot;srcversion&quot;.</span>
<span class="cm">*/</span>

<span class="cp">#if defined(MODULE) || !defined(CONFIG_SYSFS)</span>
<span class="cp">#define MODULE_VERSION(_version) MODULE_INFO(version, _version)</span>
<span class="cp">#else</span>
<span class="cp">#define MODULE_VERSION(_version)					\</span>
<span class="cp">	static struct module_version_attribute ___modver_attr = {	\</span>
<span class="cp">		.mattr	= {						\</span>
<span class="cp">			.attr	= {					\</span>
<span class="cp">				.name	= &quot;version&quot;,			\</span>
<span class="cp">				.mode	= S_IRUGO,			\</span>
<span class="cp">			},						\</span>
<span class="cp">			.show	= __modver_version_show,		\</span>
<span class="cp">		},							\</span>
<span class="cp">		.module_name	= KBUILD_MODNAME,			\</span>
<span class="cp">		.version	= _version,				\</span>
<span class="cp">	};								\</span>
<span class="cp">	static const struct module_version_attribute			\</span>
<span class="cp">	__used __attribute__ ((__section__ (&quot;__modver&quot;)))		\</span>
<span class="cp">	* __moduleparam_const __modver_attr = &amp;___modver_attr</span>
<span class="cp">#endif</span>

<span class="cm">/* Optional firmware file (or files) needed by the module</span>
<span class="cm"> * format is simply firmware file name.  Multiple firmware</span>
<span class="cm"> * files require multiple MODULE_FIRMWARE() specifiers */</span>
<span class="cp">#define MODULE_FIRMWARE(_firmware) MODULE_INFO(firmware, _firmware)</span>

<span class="cm">/* Given an address, look for it in the exception tables */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="n">search_exception_tables</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">add</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">notifier_block</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_MODULES</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">modules_disabled</span><span class="p">;</span> <span class="cm">/* for sysctl */</span>
<span class="cm">/* Get/put a kernel symbol (calls must be symmetric) */</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">__symbol_get</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symbol</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">__symbol_get_gpl</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symbol</span><span class="p">);</span>
<span class="cp">#define symbol_get(x) ((typeof(&amp;x))(__symbol_get(MODULE_SYMBOL_PREFIX #x)))</span>

<span class="cm">/* modules using other modules: kdb wants to see this. */</span>
<span class="k">struct</span> <span class="n">module_use</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">source_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">target_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">module_state</span>
<span class="p">{</span>
	<span class="n">MODULE_STATE_LIVE</span><span class="p">,</span>
	<span class="n">MODULE_STATE_COMING</span><span class="p">,</span>
	<span class="n">MODULE_STATE_GOING</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct module_ref - per cpu module reference counts</span>
<span class="cm"> * @incs: number of module get on this cpu</span>
<span class="cm"> * @decs: number of module put on this cpu</span>
<span class="cm"> *</span>
<span class="cm"> * We force an alignment on 8 or 16 bytes, so that alloc_percpu()</span>
<span class="cm"> * put @incs/@decs in same cache line, with no extra memory cost,</span>
<span class="cm"> * since alloc_percpu() is fine grained.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">module_ref</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">incs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">decs</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))));</span>

<span class="k">struct</span> <span class="n">module</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">module_state</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/* Member of list of modules */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="cm">/* Unique handle for this module */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">MODULE_NAME_LEN</span><span class="p">];</span>

	<span class="cm">/* Sysfs stuff. */</span>
	<span class="k">struct</span> <span class="n">module_kobject</span> <span class="n">mkobj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module_attribute</span> <span class="o">*</span><span class="n">modinfo_attrs</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">version</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">srcversion</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">holders_dir</span><span class="p">;</span>

	<span class="cm">/* Exported symbols */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">syms</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">crcs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_syms</span><span class="p">;</span>

	<span class="cm">/* Kernel parameters. */</span>
	<span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_kp</span><span class="p">;</span>

	<span class="cm">/* GPL-only exported symbols. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_gpl_syms</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">gpl_syms</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">gpl_crcs</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_UNUSED_SYMBOLS</span>
	<span class="cm">/* unused exported symbols. */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">unused_syms</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">unused_crcs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_unused_syms</span><span class="p">;</span>

	<span class="cm">/* GPL-only, unused exported symbols. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_unused_gpl_syms</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">unused_gpl_syms</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">unused_gpl_crcs</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* symbols that will be GPL-only in the near future. */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">gpl_future_syms</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">gpl_future_crcs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_gpl_future_syms</span><span class="p">;</span>

	<span class="cm">/* Exception table */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_exentries</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="n">extable</span><span class="p">;</span>

	<span class="cm">/* Startup function. */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="cm">/* If this is non-NULL, vfree after init() returns */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">module_init</span><span class="p">;</span>

	<span class="cm">/* Here is the actual code + data, vfree&#39;d on unload. */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">module_core</span><span class="p">;</span>

	<span class="cm">/* Here are the sizes of the init and core sections */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">init_size</span><span class="p">,</span> <span class="n">core_size</span><span class="p">;</span>

	<span class="cm">/* The size of the executable code in each section.  */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">init_text_size</span><span class="p">,</span> <span class="n">core_text_size</span><span class="p">;</span>

	<span class="cm">/* Size of RO sections of the module (text+rodata) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">init_ro_size</span><span class="p">,</span> <span class="n">core_ro_size</span><span class="p">;</span>

	<span class="cm">/* Arch-specific module values */</span>
	<span class="k">struct</span> <span class="n">mod_arch_specific</span> <span class="n">arch</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">taints</span><span class="p">;</span>	<span class="cm">/* same bits as kernel:tainted */</span>

<span class="cp">#ifdef CONFIG_GENERIC_BUG</span>
	<span class="cm">/* Support for BUG */</span>
	<span class="kt">unsigned</span> <span class="n">num_bugs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">bug_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bug_entry</span> <span class="o">*</span><span class="n">bug_table</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_KALLSYMS</span>
	<span class="cm">/*</span>
<span class="cm">	 * We keep the symbol and string tables for kallsyms.</span>
<span class="cm">	 * The core_* fields below are temporary, loader-only (they</span>
<span class="cm">	 * could really be discarded after module init).</span>
<span class="cm">	 */</span>
	<span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">symtab</span><span class="p">,</span> <span class="o">*</span><span class="n">core_symtab</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_symtab</span><span class="p">,</span> <span class="n">core_num_syms</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">strtab</span><span class="p">,</span> <span class="o">*</span><span class="n">core_strtab</span><span class="p">;</span>

	<span class="cm">/* Section attributes */</span>
	<span class="k">struct</span> <span class="n">module_sect_attrs</span> <span class="o">*</span><span class="n">sect_attrs</span><span class="p">;</span>

	<span class="cm">/* Notes attributes */</span>
	<span class="k">struct</span> <span class="n">module_notes_attrs</span> <span class="o">*</span><span class="n">notes_attrs</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* The command line arguments (may be mangled).  People like</span>
<span class="cm">	   keeping pointers to this stuff */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/* Per-cpu data. */</span>
	<span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">percpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">percpu_size</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_TRACEPOINTS</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_tracepoints</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tracepoint</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">tracepoints_ptrs</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef HAVE_JUMP_LABEL</span>
	<span class="k">struct</span> <span class="n">jump_entry</span> <span class="o">*</span><span class="n">jump_entries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_jump_entries</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_TRACING</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_trace_bprintk_fmt</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">trace_bprintk_fmt_start</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_EVENT_TRACING</span>
	<span class="k">struct</span> <span class="n">ftrace_event_call</span> <span class="o">**</span><span class="n">trace_events</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_trace_events</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FTRACE_MCOUNT_RECORD</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_ftrace_callsites</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ftrace_callsites</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MODULE_UNLOAD</span>
	<span class="cm">/* What modules depend on me? */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">source_list</span><span class="p">;</span>
	<span class="cm">/* What modules do I depend on? */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">target_list</span><span class="p">;</span>

	<span class="cm">/* Who is waiting for us to be unloaded */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">waiter</span><span class="p">;</span>

	<span class="cm">/* Destruction function. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exit</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">module_ref</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">refptr</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_CONSTRUCTORS</span>
	<span class="cm">/* Constructor functions. */</span>
	<span class="n">ctor_fn_t</span> <span class="o">*</span><span class="n">ctors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_ctors</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>
<span class="cp">#ifndef MODULE_ARCH_INIT</span>
<span class="cp">#define MODULE_ARCH_INIT {}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="n">module_mutex</span><span class="p">;</span>

<span class="cm">/* FIXME: It&#39;d be nice to isolate modules during init, too, so they</span>
<span class="cm">   aren&#39;t used before they (may) fail.  But presently too much code</span>
<span class="cm">   (IDE &amp; SCSI) require entry into the module during init.*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">module_is_live</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">MODULE_STATE_GOING</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">__module_text_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">__module_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">is_module_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">is_module_percpu_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">is_module_text_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">within_module_core</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">&lt;=</span> <span class="n">addr</span> <span class="o">&amp;&amp;</span>
	       <span class="n">addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">within_module_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span> <span class="o">&lt;=</span> <span class="n">addr</span> <span class="o">&amp;&amp;</span>
	       <span class="n">addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Search for module by name: must hold module_mutex. */</span>
<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">find_module</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">symsearch</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">stop</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">crcs</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">NOT_GPL_ONLY</span><span class="p">,</span>
		<span class="n">GPL_ONLY</span><span class="p">,</span>
		<span class="n">WILL_BE_GPL_ONLY</span><span class="p">,</span>
	<span class="p">}</span> <span class="n">licence</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">unused</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Search for an exported symbol by name. */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_symbol</span> <span class="o">*</span><span class="n">find_symbol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">module</span> <span class="o">**</span><span class="n">owner</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">**</span><span class="n">crc</span><span class="p">,</span>
					<span class="n">bool</span> <span class="n">gplok</span><span class="p">,</span>
					<span class="n">bool</span> <span class="n">warn</span><span class="p">);</span>

<span class="cm">/* Walk the exported symbol table */</span>
<span class="n">bool</span> <span class="n">each_symbol_section</span><span class="p">(</span><span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">symsearch</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/* Returns 0 and fills in value, defined and namebuf, or -ERANGE if</span>
<span class="cm">   symnum out of range. */</span>
<span class="kt">int</span> <span class="n">module_get_kallsym</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">symnum</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">module_name</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">exported</span><span class="p">);</span>

<span class="cm">/* Look for this name: can be of form module:name. */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">module_kallsyms_lookup_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">module_kallsyms_on_each_symbol</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
				   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__module_put_and_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">long</span> <span class="n">code</span><span class="p">)</span>
	<span class="n">__attribute__</span><span class="p">((</span><span class="n">noreturn</span><span class="p">));</span>
<span class="cp">#define module_put_and_exit(code) __module_put_and_exit(THIS_MODULE, code);</span>

<span class="cp">#ifdef CONFIG_MODULE_UNLOAD</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">module_refcount</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__symbol_put</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symbol</span><span class="p">);</span>
<span class="cp">#define symbol_put(x) __symbol_put(MODULE_SYMBOL_PREFIX #x)</span>
<span class="kt">void</span> <span class="n">symbol_put_addr</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

<span class="cm">/* Sometimes we know we already have a refcount, and it&#39;s easier not</span>
<span class="cm">   to handle the error case (which only happens with rmmod --wait). */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__module_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">);</span>

<span class="cm">/* This is the Right Way to get a module: if it fails, it&#39;s being removed,</span>
<span class="cm"> * so pretend it&#39;s not there. */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">try_module_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">module_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/*!CONFIG_MODULE_UNLOAD*/</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">try_module_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">module</span> <span class="o">||</span> <span class="n">module_is_live</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">module_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__module_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#define symbol_put(x) do { } while(0)</span>
<span class="cp">#define symbol_put_addr(p) do { } while(0)</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_MODULE_UNLOAD */</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">ref_module</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>

<span class="cm">/* This is a #define so the string doesn&#39;t get put in every .o file */</span>
<span class="cp">#define module_name(mod)			\</span>
<span class="cp">({						\</span>
<span class="cp">	struct module *__mod = (mod);		\</span>
<span class="cp">	__mod ? __mod-&gt;name : &quot;kernel&quot;;		\</span>
<span class="cp">})</span>

<span class="cm">/* For kallsyms to ask for address resolution.  namebuf should be at</span>
<span class="cm"> * least KSYM_NAME_LEN long: a pointer to namebuf is returned if</span>
<span class="cm"> * found, otherwise NULL. */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">module_address_lookup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">symbolsize</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span>
			    <span class="kt">char</span> <span class="o">**</span><span class="n">modname</span><span class="p">,</span>
			    <span class="kt">char</span> <span class="o">*</span><span class="n">namebuf</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">lookup_module_symbol_name</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">lookup_module_symbol_attrs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/* For extable.c to search modules&#39; exception tables. */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="n">search_module_extables</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">register_module_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span> <span class="n">nb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">unregister_module_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span> <span class="n">nb</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">print_modules</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_MODULES... */</span><span class="cp"></span>

<span class="cm">/* Given an address, look for it in the exception tables. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span>
<span class="nf">search_module_extables</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="nf">__module_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="nf">__module_text_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_module_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_module_percpu_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_module_text_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get/put a kernel symbol (calls should be symmetric) */</span>
<span class="cp">#define symbol_get(x) ({ extern typeof(x) x __attribute__((weak)); &amp;(x); })</span>
<span class="cp">#define symbol_put(x) do { } while(0)</span>
<span class="cp">#define symbol_put_addr(x) do { } while(0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__module_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">try_module_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">module_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#define module_name(mod) &quot;kernel&quot;</span>

<span class="cm">/* For kallsyms to ask for address resolution.  NULL means not found. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">module_address_lookup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">symbolsize</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span>
					  <span class="kt">char</span> <span class="o">**</span><span class="n">modname</span><span class="p">,</span>
					  <span class="kt">char</span> <span class="o">*</span><span class="n">namebuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">lookup_module_symbol_name</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">lookup_module_symbol_attrs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">module_get_kallsym</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">symnum</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">module_name</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">exported</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">module_kallsyms_lookup_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">module_kallsyms_on_each_symbol</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
							   <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="p">,</span>
							   <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
						 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">register_module_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span> <span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* no events will happen anyway, so this can always succeed */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">unregister_module_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span> <span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define module_put_and_exit(code) do_exit(code)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">print_modules</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MODULES */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SYSFS</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">module_kset</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">module_ktype</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">module_sysfs_initialized</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SYSFS */</span><span class="cp"></span>

<span class="cp">#define symbol_request(x) try_then_request_module(symbol_get(x), &quot;symbol:&quot; #x)</span>

<span class="cm">/* BELOW HERE ALL THESE ARE OBSOLETE AND WILL VANISH */</span>

<span class="cp">#define __MODULE_STRING(x) __stringify(x)</span>

<span class="cp">#ifdef CONFIG_DEBUG_SET_MODULE_RONX</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_all_modules_text_rw</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_all_modules_text_ro</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_all_modules_text_rw</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_all_modules_text_ro</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_GENERIC_BUG</span>
<span class="kt">void</span> <span class="n">module_bug_finalize</span><span class="p">(</span><span class="k">const</span> <span class="n">Elf_Ehdr</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">module_bug_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#else	</span><span class="cm">/* !CONFIG_GENERIC_BUG */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">module_bug_finalize</span><span class="p">(</span><span class="k">const</span> <span class="n">Elf_Ehdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">module_bug_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_GENERIC_BUG */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_MODULE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
