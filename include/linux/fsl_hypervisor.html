<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › fsl_hypervisor.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>fsl_hypervisor.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Freescale hypervisor ioctl and kernel interface</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008-2011 Freescale Semiconductor, Inc.</span>
<span class="cm"> * Author: Timur Tabi &lt;timur@freescale.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions are met:</span>
<span class="cm"> *     * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *       notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *     * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *       notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *       documentation and/or other materials provided with the distribution.</span>
<span class="cm"> *     * Neither the name of Freescale Semiconductor nor the</span>
<span class="cm"> *       names of its contributors may be used to endorse or promote products</span>
<span class="cm"> *       derived from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * ALTERNATIVELY, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) as published by the Free Software</span>
<span class="cm"> * Foundation, either version 2 of that License or (at your option) any</span>
<span class="cm"> * later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is provided by Freescale Semiconductor &quot;as is&quot; and any</span>
<span class="cm"> * express or implied warranties, including, but not limited to, the implied</span>
<span class="cm"> * warranties of merchantability and fitness for a particular purpose are</span>
<span class="cm"> * disclaimed. In no event shall Freescale Semiconductor be liable for any</span>
<span class="cm"> * direct, indirect, incidental, special, exemplary, or consequential damages</span>
<span class="cm"> * (including, but not limited to, procurement of substitute goods or services;</span>
<span class="cm"> * loss of use, data, or profits; or business interruption) however caused and</span>
<span class="cm"> * on any theory of liability, whether in contract, strict liability, or tort</span>
<span class="cm"> * (including negligence or otherwise) arising in any way out of the use of this</span>
<span class="cm"> * software, even if advised of the possibility of such damage.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is used by the Freescale hypervisor management driver.  It can</span>
<span class="cm"> * also be included by applications that need to communicate with the driver</span>
<span class="cm"> * via the ioctl interface.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef FSL_HYPERVISOR_H</span>
<span class="cp">#define FSL_HYPERVISOR_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * struct fsl_hv_ioctl_restart - restart a partition</span>
<span class="cm"> * @ret: return error code from the hypervisor</span>
<span class="cm"> * @partition: the ID of the partition to restart, or -1 for the</span>
<span class="cm"> *             calling partition</span>
<span class="cm"> *</span>
<span class="cm"> * Used by FSL_HV_IOCTL_PARTITION_RESTART</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsl_hv_ioctl_restart</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">partition</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fsl_hv_ioctl_status - get a partition&#39;s status</span>
<span class="cm"> * @ret: return error code from the hypervisor</span>
<span class="cm"> * @partition: the ID of the partition to query, or -1 for the</span>
<span class="cm"> *             calling partition</span>
<span class="cm"> * @status: The returned status of the partition</span>
<span class="cm"> *</span>
<span class="cm"> * Used by FSL_HV_IOCTL_PARTITION_GET_STATUS</span>
<span class="cm"> *</span>
<span class="cm"> * Values of &#39;status&#39;:</span>
<span class="cm"> *    0 = Stopped</span>
<span class="cm"> *    1 = Running</span>
<span class="cm"> *    2 = Starting</span>
<span class="cm"> *    3 = Stopping</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsl_hv_ioctl_status</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">partition</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">status</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fsl_hv_ioctl_start - start a partition</span>
<span class="cm"> * @ret: return error code from the hypervisor</span>
<span class="cm"> * @partition: the ID of the partition to control</span>
<span class="cm"> * @entry_point: The offset within the guest IMA to start execution</span>
<span class="cm"> * @load: If non-zero, reload the partition&#39;s images before starting</span>
<span class="cm"> *</span>
<span class="cm"> * Used by FSL_HV_IOCTL_PARTITION_START</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsl_hv_ioctl_start</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">partition</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">entry_point</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">load</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fsl_hv_ioctl_stop - stop a partition</span>
<span class="cm"> * @ret: return error code from the hypervisor</span>
<span class="cm"> * @partition: the ID of the partition to stop, or -1 for the calling</span>
<span class="cm"> *             partition</span>
<span class="cm"> *</span>
<span class="cm"> * Used by FSL_HV_IOCTL_PARTITION_STOP</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsl_hv_ioctl_stop</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">partition</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fsl_hv_ioctl_memcpy - copy memory between partitions</span>
<span class="cm"> * @ret: return error code from the hypervisor</span>
<span class="cm"> * @source: the partition ID of the source partition, or -1 for this</span>
<span class="cm"> *          partition</span>
<span class="cm"> * @target: the partition ID of the target partition, or -1 for this</span>
<span class="cm"> *          partition</span>
<span class="cm"> * @reserved: reserved, must be set to 0</span>
<span class="cm"> * @local_addr: user-space virtual address of a buffer in the local</span>
<span class="cm"> *              partition</span>
<span class="cm"> * @remote_addr: guest physical address of a buffer in the</span>
<span class="cm"> *           remote partition</span>
<span class="cm"> * @count: the number of bytes to copy.  Both the local and remote</span>
<span class="cm"> *         buffers must be at least &#39;count&#39; bytes long</span>
<span class="cm"> *</span>
<span class="cm"> * Used by FSL_HV_IOCTL_MEMCPY</span>
<span class="cm"> *</span>
<span class="cm"> * The &#39;local&#39; partition is the partition that calls this ioctl.  The</span>
<span class="cm"> * &#39;remote&#39; partition is a different partition.  The data is copied from</span>
<span class="cm"> * the &#39;source&#39; paritition&#39; to the &#39;target&#39; partition.</span>
<span class="cm"> *</span>
<span class="cm"> * The buffer in the remote partition must be guest physically</span>
<span class="cm"> * contiguous.</span>
<span class="cm"> *</span>
<span class="cm"> * This ioctl does not support copying memory between two remote</span>
<span class="cm"> * partitions or within the same partition, so either &#39;source&#39; or</span>
<span class="cm"> * &#39;target&#39; (but not both) must be -1.  In other words, either</span>
<span class="cm"> *</span>
<span class="cm"> *      source == local and target == remote</span>
<span class="cm"> * or</span>
<span class="cm"> *      source == remote and target == local</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsl_hv_ioctl_memcpy</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">source</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">target</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">reserved</span><span class="p">;</span>	<span class="cm">/* padding to ensure local_vaddr is aligned */</span>
	<span class="n">__u64</span> <span class="n">local_vaddr</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">remote_paddr</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fsl_hv_ioctl_doorbell - ring a doorbell</span>
<span class="cm"> * @ret: return error code from the hypervisor</span>
<span class="cm"> * @doorbell: the handle of the doorbell to ring doorbell</span>
<span class="cm"> *</span>
<span class="cm"> * Used by FSL_HV_IOCTL_DOORBELL</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsl_hv_ioctl_doorbell</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">doorbell</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fsl_hv_ioctl_prop - get/set a device tree property</span>
<span class="cm"> * @ret: return error code from the hypervisor</span>
<span class="cm"> * @handle: handle of partition whose tree to access</span>
<span class="cm"> * @path: virtual address of path name of node to access</span>
<span class="cm"> * @propname: virtual address of name of property to access</span>
<span class="cm"> * @propval: virtual address of property data buffer</span>
<span class="cm"> * @proplen: Size of property data buffer</span>
<span class="cm"> * @reserved: reserved, must be set to 0</span>
<span class="cm"> *</span>
<span class="cm"> * Used by FSL_HV_IOCTL_DOORBELL</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsl_hv_ioctl_prop</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">path</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">propname</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">propval</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">proplen</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">reserved</span><span class="p">;</span>	<span class="cm">/* padding to ensure structure is aligned */</span>
<span class="p">};</span>

<span class="cm">/* The ioctl type, documented in ioctl-number.txt */</span>
<span class="cp">#define FSL_HV_IOCTL_TYPE	0xAF</span>

<span class="cm">/* Restart another partition */</span>
<span class="cp">#define FSL_HV_IOCTL_PARTITION_RESTART \</span>
<span class="cp">	_IOWR(FSL_HV_IOCTL_TYPE, 1, struct fsl_hv_ioctl_restart)</span>

<span class="cm">/* Get a partition&#39;s status */</span>
<span class="cp">#define FSL_HV_IOCTL_PARTITION_GET_STATUS \</span>
<span class="cp">	_IOWR(FSL_HV_IOCTL_TYPE, 2, struct fsl_hv_ioctl_status)</span>

<span class="cm">/* Boot another partition */</span>
<span class="cp">#define FSL_HV_IOCTL_PARTITION_START \</span>
<span class="cp">	_IOWR(FSL_HV_IOCTL_TYPE, 3, struct fsl_hv_ioctl_start)</span>

<span class="cm">/* Stop this or another partition */</span>
<span class="cp">#define FSL_HV_IOCTL_PARTITION_STOP \</span>
<span class="cp">	_IOWR(FSL_HV_IOCTL_TYPE, 4, struct fsl_hv_ioctl_stop)</span>

<span class="cm">/* Copy data from one partition to another */</span>
<span class="cp">#define FSL_HV_IOCTL_MEMCPY \</span>
<span class="cp">	_IOWR(FSL_HV_IOCTL_TYPE, 5, struct fsl_hv_ioctl_memcpy)</span>

<span class="cm">/* Ring a doorbell */</span>
<span class="cp">#define FSL_HV_IOCTL_DOORBELL \</span>
<span class="cp">	_IOWR(FSL_HV_IOCTL_TYPE, 6, struct fsl_hv_ioctl_doorbell)</span>

<span class="cm">/* Get a property from another guest&#39;s device tree */</span>
<span class="cp">#define FSL_HV_IOCTL_GETPROP \</span>
<span class="cp">	_IOWR(FSL_HV_IOCTL_TYPE, 7, struct fsl_hv_ioctl_prop)</span>

<span class="cm">/* Set a property in another guest&#39;s device tree */</span>
<span class="cp">#define FSL_HV_IOCTL_SETPROP \</span>
<span class="cp">	_IOWR(FSL_HV_IOCTL_TYPE, 8, struct fsl_hv_ioctl_prop)</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/**</span>
<span class="cm"> * fsl_hv_event_register() - register a callback for failover events</span>
<span class="cm"> * @nb: pointer to caller-supplied notifier_block structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by device drivers to register their callback</span>
<span class="cm"> * functions for fail-over events.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller should allocate a notifier_block object and initialize the</span>
<span class="cm"> * &#39;priority&#39; and &#39;notifier_call&#39; fields.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fsl_hv_failover_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fsl_hv_event_unregister() - unregister a callback for failover events</span>
<span class="cm"> * @nb: the same &#39;nb&#39; used in previous fsl_hv_failover_register call</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fsl_hv_failover_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>

<span class="cp">#endif</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
