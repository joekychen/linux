<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › nodemask.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>nodemask.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __LINUX_NODEMASK_H</span>
<span class="cp">#define __LINUX_NODEMASK_H</span>

<span class="cm">/*</span>
<span class="cm"> * Nodemasks provide a bitmap suitable for representing the</span>
<span class="cm"> * set of Node&#39;s in a system, one bit position per Node number.</span>
<span class="cm"> *</span>
<span class="cm"> * See detailed comments in the file linux/bitmap.h describing the</span>
<span class="cm"> * data type on which these nodemasks are based.</span>
<span class="cm"> *</span>
<span class="cm"> * For details of nodemask_scnprintf() and nodemask_parse_user(),</span>
<span class="cm"> * see bitmap_scnprintf() and bitmap_parse_user() in lib/bitmap.c.</span>
<span class="cm"> * For details of nodelist_scnprintf() and nodelist_parse(), see</span>
<span class="cm"> * bitmap_scnlistprintf() and bitmap_parselist(), also in bitmap.c.</span>
<span class="cm"> * For details of node_remap(), see bitmap_bitremap in lib/bitmap.c.</span>
<span class="cm"> * For details of nodes_remap(), see bitmap_remap in lib/bitmap.c.</span>
<span class="cm"> * For details of nodes_onto(), see bitmap_onto in lib/bitmap.c.</span>
<span class="cm"> * For details of nodes_fold(), see bitmap_fold in lib/bitmap.c.</span>
<span class="cm"> *</span>
<span class="cm"> * The available nodemask operations are:</span>
<span class="cm"> *</span>
<span class="cm"> * void node_set(node, mask)		turn on bit &#39;node&#39; in mask</span>
<span class="cm"> * void node_clear(node, mask)		turn off bit &#39;node&#39; in mask</span>
<span class="cm"> * void nodes_setall(mask)		set all bits</span>
<span class="cm"> * void nodes_clear(mask)		clear all bits</span>
<span class="cm"> * int node_isset(node, mask)		true iff bit &#39;node&#39; set in mask</span>
<span class="cm"> * int node_test_and_set(node, mask)	test and set bit &#39;node&#39; in mask</span>
<span class="cm"> *</span>
<span class="cm"> * void nodes_and(dst, src1, src2)	dst = src1 &amp; src2  [intersection]</span>
<span class="cm"> * void nodes_or(dst, src1, src2)	dst = src1 | src2  [union]</span>
<span class="cm"> * void nodes_xor(dst, src1, src2)	dst = src1 ^ src2</span>
<span class="cm"> * void nodes_andnot(dst, src1, src2)	dst = src1 &amp; ~src2</span>
<span class="cm"> * void nodes_complement(dst, src)	dst = ~src</span>
<span class="cm"> *</span>
<span class="cm"> * int nodes_equal(mask1, mask2)	Does mask1 == mask2?</span>
<span class="cm"> * int nodes_intersects(mask1, mask2)	Do mask1 and mask2 intersect?</span>
<span class="cm"> * int nodes_subset(mask1, mask2)	Is mask1 a subset of mask2?</span>
<span class="cm"> * int nodes_empty(mask)		Is mask empty (no bits sets)?</span>
<span class="cm"> * int nodes_full(mask)			Is mask full (all bits sets)?</span>
<span class="cm"> * int nodes_weight(mask)		Hamming weight - number of set bits</span>
<span class="cm"> *</span>
<span class="cm"> * void nodes_shift_right(dst, src, n)	Shift right</span>
<span class="cm"> * void nodes_shift_left(dst, src, n)	Shift left</span>
<span class="cm"> *</span>
<span class="cm"> * int first_node(mask)			Number lowest set bit, or MAX_NUMNODES</span>
<span class="cm"> * int next_node(node, mask)		Next node past &#39;node&#39;, or MAX_NUMNODES</span>
<span class="cm"> * int first_unset_node(mask)		First node not set in mask, or </span>
<span class="cm"> *					MAX_NUMNODES.</span>
<span class="cm"> *</span>
<span class="cm"> * nodemask_t nodemask_of_node(node)	Return nodemask with bit &#39;node&#39; set</span>
<span class="cm"> * NODE_MASK_ALL			Initializer - all bits set</span>
<span class="cm"> * NODE_MASK_NONE			Initializer - no bits set</span>
<span class="cm"> * unsigned long *nodes_addr(mask)	Array of unsigned long&#39;s in mask</span>
<span class="cm"> *</span>
<span class="cm"> * int nodemask_scnprintf(buf, len, mask) Format nodemask for printing</span>
<span class="cm"> * int nodemask_parse_user(ubuf, ulen, mask)	Parse ascii string as nodemask</span>
<span class="cm"> * int nodelist_scnprintf(buf, len, mask) Format nodemask as list for printing</span>
<span class="cm"> * int nodelist_parse(buf, map)		Parse ascii string as nodelist</span>
<span class="cm"> * int node_remap(oldbit, old, new)	newbit = map(old, new)(oldbit)</span>
<span class="cm"> * void nodes_remap(dst, src, old, new)	*dst = map(old, new)(src)</span>
<span class="cm"> * void nodes_onto(dst, orig, relmap)	*dst = orig relative to relmap</span>
<span class="cm"> * void nodes_fold(dst, orig, sz)	dst bits = orig bits mod sz</span>
<span class="cm"> *</span>
<span class="cm"> * for_each_node_mask(node, mask)	for-loop node over mask</span>
<span class="cm"> *</span>
<span class="cm"> * int num_online_nodes()		Number of online Nodes</span>
<span class="cm"> * int num_possible_nodes()		Number of all possible Nodes</span>
<span class="cm"> *</span>
<span class="cm"> * int node_random(mask)		Random node with set bit in mask</span>
<span class="cm"> *</span>
<span class="cm"> * int node_online(node)		Is some node online?</span>
<span class="cm"> * int node_possible(node)		Is some node possible?</span>
<span class="cm"> *</span>
<span class="cm"> * node_set_online(node)		set bit &#39;node&#39; in node_online_map</span>
<span class="cm"> * node_set_offline(node)		clear bit &#39;node&#39; in node_online_map</span>
<span class="cm"> *</span>
<span class="cm"> * for_each_node(node)			for-loop node over node_possible_map</span>
<span class="cm"> * for_each_online_node(node)		for-loop node over node_online_map</span>
<span class="cm"> *</span>
<span class="cm"> * Subtlety:</span>
<span class="cm"> * 1) The &#39;type-checked&#39; form of node_isset() causes gcc (3.3.2, anyway)</span>
<span class="cm"> *    to generate slightly worse code.  So use a simple one-line #define</span>
<span class="cm"> *    for node_isset(), instead of wrapping an inline inside a macro, the</span>
<span class="cm"> *    way we do the other calls.</span>
<span class="cm"> *</span>
<span class="cm"> * NODEMASK_SCRATCH</span>
<span class="cm"> * When doing above logical AND, OR, XOR, Remap operations the callers tend to</span>
<span class="cm"> * need temporary nodemask_t&#39;s on the stack. But if NODES_SHIFT is large,</span>
<span class="cm"> * nodemask_t&#39;s consume too much stack space.  NODEMASK_SCRATCH is a helper</span>
<span class="cm"> * for such situations. See below and CPUMASK_ALLOC also.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;linux/bitmap.h&gt;</span>
<span class="cp">#include &lt;linux/numa.h&gt;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">);</span> <span class="p">}</span> <span class="n">nodemask_t</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">nodemask_t</span> <span class="n">_unused_nodemask_arg_</span><span class="p">;</span>

<span class="cp">#define node_set(node, dst) __node_set((node), &amp;(dst))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__node_set</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="k">volatile</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define node_clear(node, dst) __node_clear((node), &amp;(dst))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__node_clear</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="k">volatile</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_setall(dst) __nodes_setall(&amp;(dst), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__nodes_setall</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_fill</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_clear(dst) __nodes_clear(&amp;(dst), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__nodes_clear</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* No static inline type checking - see Subtlety (1) above. */</span>
<span class="cp">#define node_isset(node, nodemask) test_bit((node), (nodemask).bits)</span>

<span class="cp">#define node_test_and_set(node, nodemask) \</span>
<span class="cp">			__node_test_and_set((node), &amp;(nodemask))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__node_test_and_set</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_and(dst, src1, src2) \</span>
<span class="cp">			__nodes_and(&amp;(dst), &amp;(src1), &amp;(src2), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__nodes_and</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">src2p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_and</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src1p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src2p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_or(dst, src1, src2) \</span>
<span class="cp">			__nodes_or(&amp;(dst), &amp;(src1), &amp;(src2), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__nodes_or</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">src2p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_or</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src1p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src2p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_xor(dst, src1, src2) \</span>
<span class="cp">			__nodes_xor(&amp;(dst), &amp;(src1), &amp;(src2), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__nodes_xor</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">src2p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_xor</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src1p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src2p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_andnot(dst, src1, src2) \</span>
<span class="cp">			__nodes_andnot(&amp;(dst), &amp;(src1), &amp;(src2), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__nodes_andnot</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">src2p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_andnot</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src1p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src2p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_complement(dst, src) \</span>
<span class="cp">			__nodes_complement(&amp;(dst), &amp;(src), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__nodes_complement</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_complement</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_equal(src1, src2) \</span>
<span class="cp">			__nodes_equal(&amp;(src1), &amp;(src2), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__nodes_equal</span><span class="p">(</span><span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">src2p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_equal</span><span class="p">(</span><span class="n">src1p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src2p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_intersects(src1, src2) \</span>
<span class="cp">			__nodes_intersects(&amp;(src1), &amp;(src2), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__nodes_intersects</span><span class="p">(</span><span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">src2p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_intersects</span><span class="p">(</span><span class="n">src1p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src2p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_subset(src1, src2) \</span>
<span class="cp">			__nodes_subset(&amp;(src1), &amp;(src2), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__nodes_subset</span><span class="p">(</span><span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">src2p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_subset</span><span class="p">(</span><span class="n">src1p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src2p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_empty(src) __nodes_empty(&amp;(src), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__nodes_empty</span><span class="p">(</span><span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_empty</span><span class="p">(</span><span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_full(nodemask) __nodes_full(&amp;(nodemask), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__nodes_full</span><span class="p">(</span><span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_full</span><span class="p">(</span><span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_weight(nodemask) __nodes_weight(&amp;(nodemask), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__nodes_weight</span><span class="p">(</span><span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_weight</span><span class="p">(</span><span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_shift_right(dst, src, n) \</span>
<span class="cp">			__nodes_shift_right(&amp;(dst), &amp;(src), (n), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__nodes_shift_right</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_shift_right</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_shift_left(dst, src, n) \</span>
<span class="cp">			__nodes_shift_left(&amp;(dst), &amp;(src), (n), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__nodes_shift_left</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_shift_left</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* FIXME: better would be to fix all architectures to never return</span>
<span class="cm">          &gt; MAX_NUMNODES, then the silly min_ts could be dropped. */</span>

<span class="cp">#define first_node(src) __first_node(&amp;(src))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__first_node</span><span class="p">(</span><span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">,</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define next_node(n, src) __next_node((n), &amp;(src))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__next_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">MAX_NUMNODES</span><span class="p">,</span><span class="n">find_next_bit</span><span class="p">(</span><span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_nodemask_of_node</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nodes_clear</span><span class="p">(</span><span class="o">*</span><span class="n">mask</span><span class="p">);</span>
	<span class="n">node_set</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodemask_of_node(node)						\</span>
<span class="cp">({									\</span>
<span class="cp">	typeof(_unused_nodemask_arg_) m;				\</span>
<span class="cp">	if (sizeof(m) == sizeof(unsigned long)) {			\</span>
<span class="cp">		m.bits[0] = 1UL &lt;&lt; (node);				\</span>
<span class="cp">	} else {							\</span>
<span class="cp">		init_nodemask_of_node(&amp;m, (node));			\</span>
<span class="cp">	}								\</span>
<span class="cp">	m;								\</span>
<span class="cp">})</span>

<span class="cp">#define first_unset_node(mask) __first_unset_node(&amp;(mask))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__first_unset_node</span><span class="p">(</span><span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">maskp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">MAX_NUMNODES</span><span class="p">,</span>
			<span class="n">find_first_zero_bit</span><span class="p">(</span><span class="n">maskp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define NODE_MASK_LAST_WORD BITMAP_LAST_WORD_MASK(MAX_NUMNODES)</span>

<span class="cp">#if MAX_NUMNODES &lt;= BITS_PER_LONG</span>

<span class="cp">#define NODE_MASK_ALL							\</span>
<span class="cp">((nodemask_t) { {							\</span>
<span class="cp">	[BITS_TO_LONGS(MAX_NUMNODES)-1] = NODE_MASK_LAST_WORD		\</span>
<span class="cp">} })</span>

<span class="cp">#else</span>

<span class="cp">#define NODE_MASK_ALL							\</span>
<span class="cp">((nodemask_t) { {							\</span>
<span class="cp">	[0 ... BITS_TO_LONGS(MAX_NUMNODES)-2] = ~0UL,			\</span>
<span class="cp">	[BITS_TO_LONGS(MAX_NUMNODES)-1] = NODE_MASK_LAST_WORD		\</span>
<span class="cp">} })</span>

<span class="cp">#endif</span>

<span class="cp">#define NODE_MASK_NONE							\</span>
<span class="cp">((nodemask_t) { {							\</span>
<span class="cp">	[0 ... BITS_TO_LONGS(MAX_NUMNODES)-1] =  0UL			\</span>
<span class="cp">} })</span>

<span class="cp">#define nodes_addr(src) ((src).bits)</span>

<span class="cp">#define nodemask_scnprintf(buf, len, src) \</span>
<span class="cp">			__nodemask_scnprintf((buf), (len), &amp;(src), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__nodemask_scnprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodemask_parse_user(ubuf, ulen, dst) \</span>
<span class="cp">		__nodemask_parse_user((ubuf), (ulen), &amp;(dst), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__nodemask_parse_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
					<span class="n">nodemask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_parse_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodelist_scnprintf(buf, len, src) \</span>
<span class="cp">			__nodelist_scnprintf((buf), (len), &amp;(src), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__nodelist_scnprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_scnlistprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodelist_parse(buf, dst) __nodelist_parse((buf), &amp;(dst), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__nodelist_parse</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_parselist</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define node_remap(oldbit, old, new) \</span>
<span class="cp">		__node_remap((oldbit), &amp;(old), &amp;(new), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__node_remap</span><span class="p">(</span><span class="kt">int</span> <span class="n">oldbit</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">oldp</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">newp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_bitremap</span><span class="p">(</span><span class="n">oldbit</span><span class="p">,</span> <span class="n">oldp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">newp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_remap(dst, src, old, new) \</span>
<span class="cp">		__nodes_remap(&amp;(dst), &amp;(src), &amp;(old), &amp;(new), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__nodes_remap</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">oldp</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">newp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_remap</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">oldp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">newp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_onto(dst, orig, relmap) \</span>
<span class="cp">		__nodes_onto(&amp;(dst), &amp;(orig), &amp;(relmap), MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__nodes_onto</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">origp</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">relmapp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_onto</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">origp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">relmapp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define nodes_fold(dst, orig, sz) \</span>
<span class="cp">		__nodes_fold(&amp;(dst), &amp;(orig), sz, MAX_NUMNODES)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__nodes_fold</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">origp</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">sz</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_fold</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">origp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if MAX_NUMNODES &gt; 1</span>
<span class="cp">#define for_each_node_mask(node, mask)			\</span>
<span class="cp">	for ((node) = first_node(mask);			\</span>
<span class="cp">		(node) &lt; MAX_NUMNODES;			\</span>
<span class="cp">		(node) = next_node((node), (mask)))</span>
<span class="cp">#else </span><span class="cm">/* MAX_NUMNODES == 1 */</span><span class="cp"></span>
<span class="cp">#define for_each_node_mask(node, mask)			\</span>
<span class="cp">	if (!nodes_empty(mask))				\</span>
<span class="cp">		for ((node) = 0; (node) &lt; 1; (node)++)</span>
<span class="cp">#endif </span><span class="cm">/* MAX_NUMNODES */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Bitmasks that are kept for all the nodes.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">node_states</span> <span class="p">{</span>
	<span class="n">N_POSSIBLE</span><span class="p">,</span>		<span class="cm">/* The node could become online at some point */</span>
	<span class="n">N_ONLINE</span><span class="p">,</span>		<span class="cm">/* The node is online */</span>
	<span class="n">N_NORMAL_MEMORY</span><span class="p">,</span>	<span class="cm">/* The node has regular memory */</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="n">N_HIGH_MEMORY</span><span class="p">,</span>		<span class="cm">/* The node has regular or high memory */</span>
<span class="cp">#else</span>
	<span class="n">N_HIGH_MEMORY</span> <span class="o">=</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="n">N_CPU</span><span class="p">,</span>		<span class="cm">/* The node has one or more cpus */</span>
	<span class="n">NR_NODE_STATES</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The following particular system nodemasks and operations</span>
<span class="cm"> * on them manage all possible and online nodes.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="n">nodemask_t</span> <span class="n">node_states</span><span class="p">[</span><span class="n">NR_NODE_STATES</span><span class="p">];</span>

<span class="cp">#if MAX_NUMNODES &gt; 1</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">node_state</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="k">enum</span> <span class="n">node_states</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">node_isset</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node_states</span><span class="p">[</span><span class="n">state</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">node_set_state</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="k">enum</span> <span class="n">node_states</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__node_set</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_states</span><span class="p">[</span><span class="n">state</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">node_clear_state</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="k">enum</span> <span class="n">node_states</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__node_clear</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_states</span><span class="p">[</span><span class="n">state</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">num_node_state</span><span class="p">(</span><span class="k">enum</span> <span class="n">node_states</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nodes_weight</span><span class="p">(</span><span class="n">node_states</span><span class="p">[</span><span class="n">state</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cp">#define for_each_node_state(__node, __state) \</span>
<span class="cp">	for_each_node_mask((__node), node_states[__state])</span>

<span class="cp">#define first_online_node	first_node(node_states[N_ONLINE])</span>
<span class="cp">#define next_online_node(nid)	next_node((nid), node_states[N_ONLINE])</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">nr_node_ids</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nr_online_nodes</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">node_set_online</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">node_set_state</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">N_ONLINE</span><span class="p">);</span>
	<span class="n">nr_online_nodes</span> <span class="o">=</span> <span class="n">num_node_state</span><span class="p">(</span><span class="n">N_ONLINE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">node_set_offline</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">node_clear_state</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">N_ONLINE</span><span class="p">);</span>
	<span class="n">nr_online_nodes</span> <span class="o">=</span> <span class="n">num_node_state</span><span class="p">(</span><span class="n">N_ONLINE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">node_state</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="k">enum</span> <span class="n">node_states</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">node</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">node_set_state</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="k">enum</span> <span class="n">node_states</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">node_clear_state</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="k">enum</span> <span class="n">node_states</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">num_node_state</span><span class="p">(</span><span class="k">enum</span> <span class="n">node_states</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define for_each_node_state(node, __state) \</span>
<span class="cp">	for ( (node) = 0; (node) == 0; (node) = 1)</span>

<span class="cp">#define first_online_node	0</span>
<span class="cp">#define next_online_node(nid)	(MAX_NUMNODES)</span>
<span class="cp">#define nr_node_ids		1</span>
<span class="cp">#define nr_online_nodes		1</span>

<span class="cp">#define node_set_online(node)	   node_set_state((node), N_ONLINE)</span>
<span class="cp">#define node_set_offline(node)	   node_clear_state((node), N_ONLINE)</span>

<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_NUMA) &amp;&amp; (MAX_NUMNODES &gt; 1)</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_random</span><span class="p">(</span><span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">maskp</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">node_random</span><span class="p">(</span><span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#define node_online_map 	node_states[N_ONLINE]</span>
<span class="cp">#define node_possible_map 	node_states[N_POSSIBLE]</span>

<span class="cp">#define num_online_nodes()	num_node_state(N_ONLINE)</span>
<span class="cp">#define num_possible_nodes()	num_node_state(N_POSSIBLE)</span>
<span class="cp">#define node_online(node)	node_state((node), N_ONLINE)</span>
<span class="cp">#define node_possible(node)	node_state((node), N_POSSIBLE)</span>

<span class="cp">#define for_each_node(node)	   for_each_node_state(node, N_POSSIBLE)</span>
<span class="cp">#define for_each_online_node(node) for_each_node_state(node, N_ONLINE)</span>

<span class="cm">/*</span>
<span class="cm"> * For nodemask scrach area.</span>
<span class="cm"> * NODEMASK_ALLOC(type, name) allocates an object with a specified type and</span>
<span class="cm"> * name.</span>
<span class="cm"> */</span>
<span class="cp">#if NODES_SHIFT &gt; 8 </span><span class="cm">/* nodemask_t &gt; 256 bytes */</span><span class="cp"></span>
<span class="cp">#define NODEMASK_ALLOC(type, name, gfp_flags)	\</span>
<span class="cp">			type *name = kmalloc(sizeof(*name), gfp_flags)</span>
<span class="cp">#define NODEMASK_FREE(m)			kfree(m)</span>
<span class="cp">#else</span>
<span class="cp">#define NODEMASK_ALLOC(type, name, gfp_flags)	type _##name, *name = &amp;_##name</span>
<span class="cp">#define NODEMASK_FREE(m)			do {} while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/* A example struture for using NODEMASK_ALLOC, used in mempolicy. */</span>
<span class="k">struct</span> <span class="n">nodemask_scratch</span> <span class="p">{</span>
	<span class="n">nodemask_t</span>	<span class="n">mask1</span><span class="p">;</span>
	<span class="n">nodemask_t</span>	<span class="n">mask2</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define NODEMASK_SCRATCH(x)						\</span>
<span class="cp">			NODEMASK_ALLOC(struct nodemask_scratch, x,	\</span>
<span class="cp">					GFP_KERNEL | __GFP_NORETRY)</span>
<span class="cp">#define NODEMASK_SCRATCH_FREE(x)	NODEMASK_FREE(x)</span>


<span class="cp">#endif </span><span class="cm">/* __LINUX_NODEMASK_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
