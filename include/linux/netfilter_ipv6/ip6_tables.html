<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › netfilter_ipv6 › ip6_tables.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ip6_tables.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * 25-Jul-1998 Major changes to allow for ip chain table</span>
<span class="cm"> *</span>
<span class="cm"> * 3-Jan-2000 Named tables to allow packet selection for different uses.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * 	Format of an IP6 firewall descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * 	src, dst, src_mask, dst_mask are always stored in network byte order.</span>
<span class="cm"> * 	flags are stored in host byte order (of course).</span>
<span class="cm"> * 	Port numbers are stored in HOST byte order.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _IP6_TABLES_H</span>
<span class="cp">#define _IP6_TABLES_H</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/if.h&gt;</span>
<span class="cp">#include &lt;linux/in6.h&gt;</span>
<span class="cp">#include &lt;linux/ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter_ipv6.h&gt;</span>

<span class="cp">#include &lt;linux/netfilter/x_tables.h&gt;</span>

<span class="cp">#ifndef __KERNEL__</span>
<span class="cp">#define IP6T_FUNCTION_MAXNAMELEN XT_FUNCTION_MAXNAMELEN</span>
<span class="cp">#define IP6T_TABLE_MAXNAMELEN XT_TABLE_MAXNAMELEN</span>
<span class="cp">#define ip6t_match xt_match</span>
<span class="cp">#define ip6t_target xt_target</span>
<span class="cp">#define ip6t_table xt_table</span>
<span class="cp">#define ip6t_get_revision xt_get_revision</span>
<span class="cp">#define ip6t_entry_match xt_entry_match</span>
<span class="cp">#define ip6t_entry_target xt_entry_target</span>
<span class="cp">#define ip6t_standard_target xt_standard_target</span>
<span class="cp">#define ip6t_error_target xt_error_target</span>
<span class="cp">#define ip6t_counters xt_counters</span>
<span class="cp">#define IP6T_CONTINUE XT_CONTINUE</span>
<span class="cp">#define IP6T_RETURN XT_RETURN</span>

<span class="cm">/* Pre-iptables-1.4.0 */</span>
<span class="cp">#include &lt;linux/netfilter/xt_tcpudp.h&gt;</span>
<span class="cp">#define ip6t_tcp xt_tcp</span>
<span class="cp">#define ip6t_udp xt_udp</span>
<span class="cp">#define IP6T_TCP_INV_SRCPT	XT_TCP_INV_SRCPT</span>
<span class="cp">#define IP6T_TCP_INV_DSTPT	XT_TCP_INV_DSTPT</span>
<span class="cp">#define IP6T_TCP_INV_FLAGS	XT_TCP_INV_FLAGS</span>
<span class="cp">#define IP6T_TCP_INV_OPTION	XT_TCP_INV_OPTION</span>
<span class="cp">#define IP6T_TCP_INV_MASK	XT_TCP_INV_MASK</span>
<span class="cp">#define IP6T_UDP_INV_SRCPT	XT_UDP_INV_SRCPT</span>
<span class="cp">#define IP6T_UDP_INV_DSTPT	XT_UDP_INV_DSTPT</span>
<span class="cp">#define IP6T_UDP_INV_MASK	XT_UDP_INV_MASK</span>

<span class="cp">#define ip6t_counters_info xt_counters_info</span>
<span class="cp">#define IP6T_STANDARD_TARGET XT_STANDARD_TARGET</span>
<span class="cp">#define IP6T_ERROR_TARGET XT_ERROR_TARGET</span>
<span class="cp">#define IP6T_MATCH_ITERATE(e, fn, args...) \</span>
<span class="cp">	XT_MATCH_ITERATE(struct ip6t_entry, e, fn, ## args)</span>
<span class="cp">#define IP6T_ENTRY_ITERATE(entries, size, fn, args...) \</span>
<span class="cp">	XT_ENTRY_ITERATE(struct ip6t_entry, entries, size, fn, ## args)</span>
<span class="cp">#endif</span>

<span class="cm">/* Yes, Virginia, you have to zero the padding. */</span>
<span class="k">struct</span> <span class="n">ip6t_ip6</span> <span class="p">{</span>
	<span class="cm">/* Source and destination IP6 addr */</span>
	<span class="k">struct</span> <span class="n">in6_addr</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">;</span>		
	<span class="cm">/* Mask for src and dest IP6 addr */</span>
	<span class="k">struct</span> <span class="n">in6_addr</span> <span class="n">smsk</span><span class="p">,</span> <span class="n">dmsk</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">iniface</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">],</span> <span class="n">outiface</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">iniface_mask</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">],</span> <span class="n">outiface_mask</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>

	<span class="cm">/* Upper protocol number</span>
<span class="cm">	 * - The allowed value is 0 (any) or protocol number of last parsable</span>
<span class="cm">	 *   header, which is 50 (ESP), 59 (No Next Header), 135 (MH), or</span>
<span class="cm">	 *   the non IPv6 extension headers.</span>
<span class="cm">	 * - The protocol numbers of IPv6 extension headers except of ESP and</span>
<span class="cm">	 *   MH do not match any packets.</span>
<span class="cm">	 * - You also need to set IP6T_FLAGS_PROTO to &quot;flags&quot; to check protocol.</span>
<span class="cm">	 */</span>
	<span class="n">__u16</span> <span class="n">proto</span><span class="p">;</span>
	<span class="cm">/* TOS to match iff flags &amp; IP6T_F_TOS */</span>
	<span class="n">__u8</span> <span class="n">tos</span><span class="p">;</span>

	<span class="cm">/* Flags word */</span>
	<span class="n">__u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="cm">/* Inverse flags */</span>
	<span class="n">__u8</span> <span class="n">invflags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Values for &quot;flag&quot; field in struct ip6t_ip6 (general ip6 structure). */</span>
<span class="cp">#define IP6T_F_PROTO		0x01	</span><span class="cm">/* Set if rule cares about upper </span>
<span class="cm">					   protocols */</span><span class="cp"></span>
<span class="cp">#define IP6T_F_TOS		0x02	</span><span class="cm">/* Match the TOS. */</span><span class="cp"></span>
<span class="cp">#define IP6T_F_GOTO		0x04	</span><span class="cm">/* Set if jump is a goto */</span><span class="cp"></span>
<span class="cp">#define IP6T_F_MASK		0x07	</span><span class="cm">/* All possible flag bits mask. */</span><span class="cp"></span>

<span class="cm">/* Values for &quot;inv&quot; field in struct ip6t_ip6. */</span>
<span class="cp">#define IP6T_INV_VIA_IN		0x01	</span><span class="cm">/* Invert the sense of IN IFACE. */</span><span class="cp"></span>
<span class="cp">#define IP6T_INV_VIA_OUT		0x02	</span><span class="cm">/* Invert the sense of OUT IFACE */</span><span class="cp"></span>
<span class="cp">#define IP6T_INV_TOS		0x04	</span><span class="cm">/* Invert the sense of TOS. */</span><span class="cp"></span>
<span class="cp">#define IP6T_INV_SRCIP		0x08	</span><span class="cm">/* Invert the sense of SRC IP. */</span><span class="cp"></span>
<span class="cp">#define IP6T_INV_DSTIP		0x10	</span><span class="cm">/* Invert the sense of DST OP. */</span><span class="cp"></span>
<span class="cp">#define IP6T_INV_FRAG		0x20	</span><span class="cm">/* Invert the sense of FRAG. */</span><span class="cp"></span>
<span class="cp">#define IP6T_INV_PROTO		XT_INV_PROTO</span>
<span class="cp">#define IP6T_INV_MASK		0x7F	</span><span class="cm">/* All possible flag bits mask. */</span><span class="cp"></span>

<span class="cm">/* This structure defines each of the firewall rules.  Consists of 3</span>
<span class="cm">   parts which are 1) general IP header stuff 2) match specific</span>
<span class="cm">   stuff 3) the target to perform if the rule matches */</span>
<span class="k">struct</span> <span class="n">ip6t_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip6t_ip6</span> <span class="n">ipv6</span><span class="p">;</span>

	<span class="cm">/* Mark with fields that we care about. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nfcache</span><span class="p">;</span>

	<span class="cm">/* Size of ipt_entry + matches */</span>
	<span class="n">__u16</span> <span class="n">target_offset</span><span class="p">;</span>
	<span class="cm">/* Size of ipt_entry + matches + target */</span>
	<span class="n">__u16</span> <span class="n">next_offset</span><span class="p">;</span>

	<span class="cm">/* Back pointer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">comefrom</span><span class="p">;</span>

	<span class="cm">/* Packet and byte counters. */</span>
	<span class="k">struct</span> <span class="n">xt_counters</span> <span class="n">counters</span><span class="p">;</span>

	<span class="cm">/* The matches (if any), then the target. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">elems</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Standard entry */</span>
<span class="k">struct</span> <span class="n">ip6t_standard</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip6t_entry</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xt_standard_target</span> <span class="n">target</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ip6t_error</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip6t_entry</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xt_error_target</span> <span class="n">target</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define IP6T_ENTRY_INIT(__size)						       \</span>
<span class="cp">{									       \</span>
<span class="cp">	.target_offset	= sizeof(struct ip6t_entry),			       \</span>
<span class="cp">	.next_offset	= (__size),					       \</span>
<span class="cp">}</span>

<span class="cp">#define IP6T_STANDARD_INIT(__verdict)					       \</span>
<span class="cp">{									       \</span>
<span class="cp">	.entry		= IP6T_ENTRY_INIT(sizeof(struct ip6t_standard)),       \</span>
<span class="cp">	.target		= XT_TARGET_INIT(XT_STANDARD_TARGET,		       \</span>
<span class="cp">					 sizeof(struct xt_standard_target)),   \</span>
<span class="cp">	.target.verdict	= -(__verdict) - 1,				       \</span>
<span class="cp">}</span>

<span class="cp">#define IP6T_ERROR_INIT							       \</span>
<span class="cp">{									       \</span>
<span class="cp">	.entry		= IP6T_ENTRY_INIT(sizeof(struct ip6t_error)),	       \</span>
<span class="cp">	.target		= XT_TARGET_INIT(XT_ERROR_TARGET,		       \</span>
<span class="cp">					 sizeof(struct xt_error_target)),      \</span>
<span class="cp">	.target.errorname = &quot;ERROR&quot;,					       \</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * New IP firewall options for [gs]etsockopt at the RAW IP level.</span>
<span class="cm"> * Unlike BSD Linux inherits IP options so you don&#39;t have to use</span>
<span class="cm"> * a raw socket for this. Instead we check rights in the calls.</span>
<span class="cm"> *</span>
<span class="cm"> * ATTENTION: check linux/in6.h before adding new number here.</span>
<span class="cm"> */</span>
<span class="cp">#define IP6T_BASE_CTL			64</span>

<span class="cp">#define IP6T_SO_SET_REPLACE		(IP6T_BASE_CTL)</span>
<span class="cp">#define IP6T_SO_SET_ADD_COUNTERS	(IP6T_BASE_CTL + 1)</span>
<span class="cp">#define IP6T_SO_SET_MAX			IP6T_SO_SET_ADD_COUNTERS</span>

<span class="cp">#define IP6T_SO_GET_INFO		(IP6T_BASE_CTL)</span>
<span class="cp">#define IP6T_SO_GET_ENTRIES		(IP6T_BASE_CTL + 1)</span>
<span class="cp">#define IP6T_SO_GET_REVISION_MATCH	(IP6T_BASE_CTL + 4)</span>
<span class="cp">#define IP6T_SO_GET_REVISION_TARGET	(IP6T_BASE_CTL + 5)</span>
<span class="cp">#define IP6T_SO_GET_MAX			IP6T_SO_GET_REVISION_TARGET</span>

<span class="cm">/* ICMP matching stuff */</span>
<span class="k">struct</span> <span class="n">ip6t_icmp</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="n">type</span><span class="p">;</span>				<span class="cm">/* type to match */</span>
	<span class="n">__u8</span> <span class="n">code</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>				<span class="cm">/* range of code */</span>
	<span class="n">__u8</span> <span class="n">invflags</span><span class="p">;</span>				<span class="cm">/* Inverse flags */</span>
<span class="p">};</span>

<span class="cm">/* Values for &quot;inv&quot; field for struct ipt_icmp. */</span>
<span class="cp">#define IP6T_ICMP_INV	0x01	</span><span class="cm">/* Invert the sense of type/code test */</span><span class="cp"></span>

<span class="cm">/* The argument to IP6T_SO_GET_INFO */</span>
<span class="k">struct</span> <span class="n">ip6t_getinfo</span> <span class="p">{</span>
	<span class="cm">/* Which table: caller fills this in. */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">XT_TABLE_MAXNAMELEN</span><span class="p">];</span>

	<span class="cm">/* Kernel fills these in. */</span>
	<span class="cm">/* Which hook entry points are valid: bitmask */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">valid_hooks</span><span class="p">;</span>

	<span class="cm">/* Hook entry points: one per netfilter hook. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook_entry</span><span class="p">[</span><span class="n">NF_INET_NUMHOOKS</span><span class="p">];</span>

	<span class="cm">/* Underflow points. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">underflow</span><span class="p">[</span><span class="n">NF_INET_NUMHOOKS</span><span class="p">];</span>

	<span class="cm">/* Number of entries */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_entries</span><span class="p">;</span>

	<span class="cm">/* Size of entries. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The argument to IP6T_SO_SET_REPLACE. */</span>
<span class="k">struct</span> <span class="n">ip6t_replace</span> <span class="p">{</span>
	<span class="cm">/* Which table. */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">XT_TABLE_MAXNAMELEN</span><span class="p">];</span>

	<span class="cm">/* Which hook entry points are valid: bitmask.  You can&#39;t</span>
<span class="cm">           change this. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">valid_hooks</span><span class="p">;</span>

	<span class="cm">/* Number of entries */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_entries</span><span class="p">;</span>

	<span class="cm">/* Total size of new entries */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* Hook entry points. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook_entry</span><span class="p">[</span><span class="n">NF_INET_NUMHOOKS</span><span class="p">];</span>

	<span class="cm">/* Underflow points. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">underflow</span><span class="p">[</span><span class="n">NF_INET_NUMHOOKS</span><span class="p">];</span>

	<span class="cm">/* Information about old entries: */</span>
	<span class="cm">/* Number of counters (must be equal to current number of entries). */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_counters</span><span class="p">;</span>
	<span class="cm">/* The old entries&#39; counters. */</span>
	<span class="k">struct</span> <span class="n">xt_counters</span> <span class="n">__user</span> <span class="o">*</span><span class="n">counters</span><span class="p">;</span>

	<span class="cm">/* The entries (hang off end: not really an array). */</span>
	<span class="k">struct</span> <span class="n">ip6t_entry</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* The argument to IP6T_SO_GET_ENTRIES. */</span>
<span class="k">struct</span> <span class="n">ip6t_get_entries</span> <span class="p">{</span>
	<span class="cm">/* Which table: user fills this in. */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">XT_TABLE_MAXNAMELEN</span><span class="p">];</span>

	<span class="cm">/* User fills this in: total entry size. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* The entries. */</span>
	<span class="k">struct</span> <span class="n">ip6t_entry</span> <span class="n">entrytable</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Helper functions */</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="k">struct</span> <span class="n">xt_entry_target</span> <span class="o">*</span>
<span class="nf">ip6t_get_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip6t_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Main firewall chains definitions and global var&#39;s definitions.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip6t_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__init</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ip6t_alloc_initial_table</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xt_table</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xt_table</span> <span class="o">*</span><span class="n">ip6t_register_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
					    <span class="k">const</span> <span class="k">struct</span> <span class="n">xt_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span>
					    <span class="k">const</span> <span class="k">struct</span> <span class="n">ip6t_replace</span> <span class="o">*</span><span class="n">repl</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip6t_unregister_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xt_table</span> <span class="o">*</span><span class="n">table</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ip6t_do_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">xt_table</span> <span class="o">*</span><span class="n">table</span><span class="p">);</span>

<span class="cm">/* Check for an extension */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ip6t_ext_hdr</span><span class="p">(</span><span class="n">u8</span> <span class="n">nexthdr</span><span class="p">)</span>
<span class="p">{</span>	<span class="k">return</span> <span class="p">(</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">IPPROTO_HOPOPTS</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">IPPROTO_ROUTING</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">IPPROTO_FRAGMENT</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">IPPROTO_ESP</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">IPPROTO_AH</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">IPPROTO_NONE</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">IPPROTO_DSTOPTS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IP6T_FH_F_FRAG</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">IP6T_FH_F_AUTH</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/* find specified header and get offset to it */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ipv6_find_hdr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">fragoff</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">fragflg</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="cp">#include &lt;net/compat.h&gt;</span>

<span class="k">struct</span> <span class="n">compat_ip6t_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip6t_ip6</span> <span class="n">ipv6</span><span class="p">;</span>
	<span class="n">compat_uint_t</span> <span class="n">nfcache</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">target_offset</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">next_offset</span><span class="p">;</span>
	<span class="n">compat_uint_t</span> <span class="n">comefrom</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">compat_xt_counters</span> <span class="n">counters</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">elems</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">xt_entry_target</span> <span class="o">*</span>
<span class="nf">compat_ip6t_get_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ip6t_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_COMPAT */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/*__KERNEL__*/</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _IP6_TABLES_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
