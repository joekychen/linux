<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › ti_wilink_st.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ti_wilink_st.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Shared Transport Header file</span>
<span class="cm"> *	To be included by the protocol stack drivers for</span>
<span class="cm"> *	Texas Instruments BT,FM and GPS combo chip drivers</span>
<span class="cm"> *	and also serves the sub-modules of the shared transport driver.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2009-2010 Texas Instruments</span>
<span class="cm"> *  Author: Pavan Savoy &lt;pavan_savoy@ti.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> *  published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef TI_WILINK_ST_H</span>
<span class="cp">#define TI_WILINK_ST_H</span>

<span class="cp">#include &lt;linux/skbuff.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * enum proto-type - The protocol on WiLink chips which share a</span>
<span class="cm"> *	common physical interface like UART.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">proto_type</span> <span class="p">{</span>
	<span class="n">ST_BT</span><span class="p">,</span>
	<span class="n">ST_FM</span><span class="p">,</span>
	<span class="n">ST_GPS</span><span class="p">,</span>
	<span class="n">ST_MAX_CHANNELS</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct st_proto_s - Per Protocol structure from BT/FM/GPS to ST</span>
<span class="cm"> * @type: type of the protocol being registered among the</span>
<span class="cm"> *	available proto_type(BT, FM, GPS the protocol which share TTY).</span>
<span class="cm"> * @recv: the receiver callback pointing to a function in the</span>
<span class="cm"> *	protocol drivers called by the ST driver upon receiving</span>
<span class="cm"> *	relevant data.</span>
<span class="cm"> * @match_packet: reserved for future use, to make ST more generic</span>
<span class="cm"> * @reg_complete_cb: callback handler pointing to a function in protocol</span>
<span class="cm"> *	handler called by ST when the pending registrations are complete.</span>
<span class="cm"> *	The registrations are marked pending, in situations when fw</span>
<span class="cm"> *	download is in progress.</span>
<span class="cm"> * @write: pointer to function in ST provided to protocol drivers from ST,</span>
<span class="cm"> *	to be made use when protocol drivers have data to send to TTY.</span>
<span class="cm"> * @priv_data: privdate data holder for the protocol drivers, sent</span>
<span class="cm"> *	from the protocol drivers during registration, and sent back on</span>
<span class="cm"> *	reg_complete_cb and recv.</span>
<span class="cm"> * @chnl_id: channel id the protocol driver is interested in, the channel</span>
<span class="cm"> *	id is nothing but the 1st byte of the packet in UART frame.</span>
<span class="cm"> * @max_frame_size: size of the largest frame the protocol can receive.</span>
<span class="cm"> * @hdr_len: length of the header structure of the protocol.</span>
<span class="cm"> * @offset_len_in_hdr: this provides the offset of the length field in the</span>
<span class="cm"> *	header structure of the protocol header, to assist ST to know</span>
<span class="cm"> *	how much to receive, if the data is split across UART frames.</span>
<span class="cm"> * @len_size: whether the length field inside the header is 2 bytes</span>
<span class="cm"> *	or 1 byte.</span>
<span class="cm"> * @reserve: the number of bytes ST needs to reserve in the skb being</span>
<span class="cm"> *	prepared for the protocol driver.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">st_proto_s</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">proto_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">recv</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="p">(</span><span class="o">*</span><span class="n">match_packet</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reg_complete_cb</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">data</span><span class="p">);</span>
	<span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">priv_data</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">chnl_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">max_frame_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">hdr_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">offset_len_in_hdr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">len_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserve</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">long</span> <span class="n">st_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">st_proto_s</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">st_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">st_proto_s</span> <span class="o">*</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * header information used by st_core.c</span>
<span class="cm"> */</span>

<span class="cm">/* states of protocol list */</span>
<span class="cp">#define ST_NOTEMPTY	1</span>
<span class="cp">#define ST_EMPTY	0</span>

<span class="cm">/*</span>
<span class="cm"> * possible st_states</span>
<span class="cm"> */</span>
<span class="cp">#define ST_INITIALIZING		1</span>
<span class="cp">#define ST_REG_IN_PROGRESS	2</span>
<span class="cp">#define ST_REG_PENDING		3</span>
<span class="cp">#define ST_WAITING_FOR_RESP	4</span>

<span class="cm">/**</span>
<span class="cm"> * struct st_data_s - ST core internal structure</span>
<span class="cm"> * @st_state: different states of ST like initializing, registration</span>
<span class="cm"> *	in progress, this is mainly used to return relevant err codes</span>
<span class="cm"> *	when protocol drivers are registering. It is also used to track</span>
<span class="cm"> *	the recv function, as in during fw download only HCI events</span>
<span class="cm"> *	can occur , where as during other times other events CH8, CH9</span>
<span class="cm"> *	can occur.</span>
<span class="cm"> * @tty: tty provided by the TTY core for line disciplines.</span>
<span class="cm"> * @tx_skb: If for some reason the tty&#39;s write returns lesser bytes written</span>
<span class="cm"> *	then to maintain the rest of data to be written on next instance.</span>
<span class="cm"> *	This needs to be protected, hence the lock inside wakeup func.</span>
<span class="cm"> * @tx_state: if the data is being written onto the TTY and protocol driver</span>
<span class="cm"> *	wants to send more, queue up data and mark that there is</span>
<span class="cm"> *	more data to send.</span>
<span class="cm"> * @list: the list of protocols registered, only MAX can exist, one protocol</span>
<span class="cm"> *	can register only once.</span>
<span class="cm"> * @rx_state: states to be maintained inside st&#39;s tty receive</span>
<span class="cm"> * @rx_count: count to be maintained inside st&#39;s tty receieve</span>
<span class="cm"> * @rx_skb: the skb where all data for a protocol gets accumulated,</span>
<span class="cm"> *	since tty might not call receive when a complete event packet</span>
<span class="cm"> *	is received, the states, count and the skb needs to be maintained.</span>
<span class="cm"> * @rx_chnl: the channel ID for which the data is getting accumalated for.</span>
<span class="cm"> * @txq: the list of skbs which needs to be sent onto the TTY.</span>
<span class="cm"> * @tx_waitq: if the chip is not in AWAKE state, the skbs needs to be queued</span>
<span class="cm"> *	up in here, PM(WAKEUP_IND) data needs to be sent and then the skbs</span>
<span class="cm"> *	from waitq can be moved onto the txq.</span>
<span class="cm"> *	Needs locking too.</span>
<span class="cm"> * @lock: the lock to protect skbs, queues, and ST states.</span>
<span class="cm"> * @protos_registered: count of the protocols registered, also when 0 the</span>
<span class="cm"> *	chip enable gpio can be toggled, and when it changes to 1 the fw</span>
<span class="cm"> *	needs to be downloaded to initialize chip side ST.</span>
<span class="cm"> * @ll_state: the various PM states the chip can be, the states are notified</span>
<span class="cm"> *	to us, when the chip sends relevant PM packets(SLEEP_IND, WAKE_IND).</span>
<span class="cm"> * @kim_data: reference to the parent encapsulating structure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">st_data_s</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">st_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tx_skb</span><span class="p">;</span>
<span class="cp">#define ST_TX_SENDING	1</span>
<span class="cp">#define ST_TX_WAKEUP	2</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tx_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">st_proto_s</span> <span class="o">*</span><span class="n">list</span><span class="p">[</span><span class="n">ST_MAX_CHANNELS</span><span class="p">];</span>
	<span class="n">bool</span> <span class="n">is_registered</span><span class="p">[</span><span class="n">ST_MAX_CHANNELS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rx_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rx_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">rx_skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">rx_chnl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">txq</span><span class="p">,</span> <span class="n">tx_waitq</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">protos_registered</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ll_state</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">kim_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * wrapper around tty-&gt;ops-&gt;write_room to check</span>
<span class="cm"> * availability during firmware download</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">st_get_uart_wr_room</span><span class="p">(</span><span class="k">struct</span> <span class="n">st_data_s</span> <span class="o">*</span><span class="n">st_gdata</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * st_int_write -</span>
<span class="cm"> * point this to tty-&gt;driver-&gt;write or tty-&gt;ops-&gt;write</span>
<span class="cm"> * depending upon the kernel version</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">st_int_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">st_data_s</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * st_write -</span>
<span class="cm"> * internal write function, passed onto protocol drivers</span>
<span class="cm"> * via the write function ptr of protocol struct</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">st_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* function to be called from ST-LL */</span>
<span class="kt">void</span> <span class="n">st_ll_send_frame</span><span class="p">(</span><span class="k">enum</span> <span class="n">proto_type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* internal wake up function */</span>
<span class="kt">void</span> <span class="n">st_tx_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">st_data_s</span> <span class="o">*</span><span class="n">st_data</span><span class="p">);</span>

<span class="cm">/* init, exit entry funcs called from KIM */</span>
<span class="kt">int</span> <span class="n">st_core_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">st_data_s</span> <span class="o">**</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">st_core_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">st_data_s</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* ask for reference from KIM */</span>
<span class="kt">void</span> <span class="n">st_kim_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">st_data_s</span> <span class="o">**</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cp">#define GPS_STUB_TEST</span>
<span class="cp">#ifdef GPS_STUB_TEST</span>
<span class="kt">int</span> <span class="n">gps_chrdrv_stub_write</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gps_chrdrv_stub_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * header information used by st_kim.c</span>
<span class="cm"> */</span>

<span class="cm">/* time in msec to wait for</span>
<span class="cm"> * line discipline to be installed</span>
<span class="cm"> */</span>
<span class="cp">#define LDISC_TIME	1000</span>
<span class="cp">#define CMD_RESP_TIME	800</span>
<span class="cp">#define CMD_WR_TIME	5000</span>
<span class="cp">#define MAKEWORD(a, b)  ((unsigned short)(((unsigned char)(a)) \</span>
<span class="cp">	| ((unsigned short)((unsigned char)(b))) &lt;&lt; 8))</span>

<span class="cp">#define GPIO_HIGH 1</span>
<span class="cp">#define GPIO_LOW  0</span>

<span class="cm">/* the Power-On-Reset logic, requires to attempt</span>
<span class="cm"> * to download firmware onto chip more than once</span>
<span class="cm"> * since the self-test for chip takes a while</span>
<span class="cm"> */</span>
<span class="cp">#define POR_RETRY_COUNT 5</span>

<span class="cm">/**</span>
<span class="cm"> * struct chip_version - save the chip version</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">chip_version</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">full</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">chip</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">min_ver</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">maj_ver</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define UART_DEV_NAME_LEN 32</span>
<span class="cm">/**</span>
<span class="cm"> * struct kim_data_s - the KIM internal data, embedded as the</span>
<span class="cm"> *	platform&#39;s drv data. One for each ST device in the system.</span>
<span class="cm"> * @uim_pid: KIM needs to communicate with UIM to request to install</span>
<span class="cm"> *	the ldisc by opening UART when protocol drivers register.</span>
<span class="cm"> * @kim_pdev: the platform device added in one of the board-XX.c file</span>
<span class="cm"> *	in arch/XX/ directory, 1 for each ST device.</span>
<span class="cm"> * @kim_rcvd: completion handler to notify when data was received,</span>
<span class="cm"> *	mainly used during fw download, which involves multiple send/wait</span>
<span class="cm"> *	for each of the HCI-VS commands.</span>
<span class="cm"> * @ldisc_installed: completion handler to notify that the UIM accepted</span>
<span class="cm"> *	the request to install ldisc, notify from tty_open which suggests</span>
<span class="cm"> *	the ldisc was properly installed.</span>
<span class="cm"> * @resp_buffer: data buffer for the .bts fw file name.</span>
<span class="cm"> * @fw_entry: firmware class struct to request/release the fw.</span>
<span class="cm"> * @rx_state: the rx state for kim&#39;s receive func during fw download.</span>
<span class="cm"> * @rx_count: the rx count for the kim&#39;s receive func during fw download.</span>
<span class="cm"> * @rx_skb: all of fw data might not come at once, and hence data storage for</span>
<span class="cm"> *	whole of the fw response, only HCI_EVENTs and hence diff from ST&#39;s</span>
<span class="cm"> *	response.</span>
<span class="cm"> * @core_data: ST core&#39;s data, which mainly is the tty&#39;s disc_data</span>
<span class="cm"> * @version: chip version available via a sysfs entry.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kim_data_s</span> <span class="p">{</span>
	<span class="kt">long</span> <span class="n">uim_pid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">kim_pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">kim_rcvd</span><span class="p">,</span> <span class="n">ldisc_installed</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">resp_buffer</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw_entry</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">nshutdown</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rx_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rx_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">rx_skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">st_data_s</span> <span class="o">*</span><span class="n">core_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chip_version</span> <span class="n">version</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ldisc_install</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dev_name</span><span class="p">[</span><span class="n">UART_DEV_NAME_LEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flow_cntrl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">baud_rate</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * functions called when 1 of the protocol drivers gets</span>
<span class="cm"> * registered, these need to communicate with UIM to request</span>
<span class="cm"> * ldisc installed, read chip_version, download relevant fw</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">st_kim_start</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">st_kim_stop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">st_kim_recv</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span> <span class="n">count</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">st_kim_complete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kim_st_list_protocols</span><span class="p">(</span><span class="k">struct</span> <span class="n">st_data_s</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * BTS headers</span>
<span class="cm"> */</span>
<span class="cp">#define ACTION_SEND_COMMAND     1</span>
<span class="cp">#define ACTION_WAIT_EVENT       2</span>
<span class="cp">#define ACTION_SERIAL           3</span>
<span class="cp">#define ACTION_DELAY            4</span>
<span class="cp">#define ACTION_RUN_SCRIPT       5</span>
<span class="cp">#define ACTION_REMARKS          6</span>

<span class="cm">/**</span>
<span class="cm"> * struct bts_header - the fw file is NOT binary which can</span>
<span class="cm"> *	be sent onto TTY as is. The .bts is more a script</span>
<span class="cm"> *	file which has different types of actions.</span>
<span class="cm"> *	Each such action needs to be parsed by the KIM and</span>
<span class="cm"> *	relevant procedure to be called.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bts_header</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">magic</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">version</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">future</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">actions</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/**</span>
<span class="cm"> * struct bts_action - Each .bts action has its own type of</span>
<span class="cm"> *	data.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bts_action</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">bts_action_send</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">bts_action_wait</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">msec</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">bts_action_delay</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">msec</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">bts_action_serial</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">baud</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flow_control</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/**</span>
<span class="cm"> * struct hci_command - the HCI-VS for intrepreting</span>
<span class="cm"> *	the change baud rate of host-side UART, which</span>
<span class="cm"> *	needs to be ignored, since UIM would do that</span>
<span class="cm"> *	when it receives request from KIM for ldisc installation.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hci_command</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">prefix</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">opcode</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">plen</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">speed</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/*</span>
<span class="cm"> * header information used by st_ll.c</span>
<span class="cm"> */</span>

<span class="cm">/* ST LL receiver states */</span>
<span class="cp">#define ST_W4_PACKET_TYPE       0</span>
<span class="cp">#define ST_W4_HEADER		1</span>
<span class="cp">#define ST_W4_DATA		2</span>

<span class="cm">/* ST LL state machines */</span>
<span class="cp">#define ST_LL_ASLEEP               0</span>
<span class="cp">#define ST_LL_ASLEEP_TO_AWAKE      1</span>
<span class="cp">#define ST_LL_AWAKE                2</span>
<span class="cp">#define ST_LL_AWAKE_TO_ASLEEP      3</span>
<span class="cp">#define ST_LL_INVALID		   4</span>

<span class="cm">/* different PM notifications coming from chip */</span>
<span class="cp">#define LL_SLEEP_IND	0x30</span>
<span class="cp">#define LL_SLEEP_ACK	0x31</span>
<span class="cp">#define LL_WAKE_UP_IND	0x32</span>
<span class="cp">#define LL_WAKE_UP_ACK	0x33</span>

<span class="cm">/* initialize and de-init ST LL */</span>
<span class="kt">long</span> <span class="n">st_ll_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">st_data_s</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">st_ll_deinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">st_data_s</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * enable/disable ST LL along with KIM start/stop</span>
<span class="cm"> * called by ST Core</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">st_ll_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">st_data_s</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">st_ll_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">st_data_s</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * various funcs used by ST core to set/get the various PM states</span>
<span class="cm"> * of the chip.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">st_ll_getstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">st_data_s</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">st_ll_sleep_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">st_data_s</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">st_ll_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">st_data_s</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * header information used by st_core.c for FM and GPS</span>
<span class="cm"> * packet parsing, the bluetooth headers are already available</span>
<span class="cm"> * at net/bluetooth/</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">fm_event_hdr</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">plen</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cp">#define FM_MAX_FRAME_SIZE 0xFF	</span><span class="cm">/* TODO: */</span><span class="cp"></span>
<span class="cp">#define FM_EVENT_HDR_SIZE 1	</span><span class="cm">/* size of fm_event_hdr */</span><span class="cp"></span>
<span class="cp">#define ST_FM_CH8_PKT 0x8</span>

<span class="cm">/* gps stuff */</span>
<span class="k">struct</span> <span class="n">gps_event_hdr</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">opcode</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">plen</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/**</span>
<span class="cm"> * struct ti_st_plat_data - platform data shared between ST driver and</span>
<span class="cm"> *	platform specific board file which adds the ST device.</span>
<span class="cm"> * @nshutdown_gpio: Host&#39;s GPIO line to which chip&#39;s BT_EN is connected.</span>
<span class="cm"> * @dev_name: The UART/TTY name to which chip is interfaced. (eg: /dev/ttyS1)</span>
<span class="cm"> * @flow_cntrl: Should always be 1, since UART&#39;s CTS/RTS is used for PM</span>
<span class="cm"> *	purposes.</span>
<span class="cm"> * @baud_rate: The baud rate supported by the Host UART controller, this will</span>
<span class="cm"> *	be shared across with the chip via a HCI VS command from User-Space Init</span>
<span class="cm"> *	Mgr application.</span>
<span class="cm"> * @suspend:</span>
<span class="cm"> * @resume: legacy PM routines hooked to platform specific board file, so as</span>
<span class="cm"> *	to take chip-host interface specific action.</span>
<span class="cm"> * @chip_enable:</span>
<span class="cm"> * @chip_disable: Platform/Interface specific mux mode setting, GPIO</span>
<span class="cm"> *	configuring, Host side PM disabling etc.. can be done here.</span>
<span class="cm"> * @chip_asleep:</span>
<span class="cm"> * @chip_awake: Chip specific deep sleep states is communicated to Host</span>
<span class="cm"> *	specific board-xx.c to take actions such as cut UART clocks when chip</span>
<span class="cm"> *	asleep or run host faster when chip awake etc..</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ti_st_plat_data</span> <span class="p">{</span>
	<span class="kt">long</span> <span class="n">nshutdown_gpio</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dev_name</span><span class="p">[</span><span class="n">UART_DEV_NAME_LEN</span><span class="p">];</span> <span class="cm">/* uart name */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flow_cntrl</span><span class="p">;</span> <span class="cm">/* flow control flag */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">baud_rate</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">pm_message_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">chip_enable</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kim_data_s</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">chip_disable</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kim_data_s</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">chip_asleep</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kim_data_s</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">chip_awake</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kim_data_s</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* TI_WILINK_ST_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
