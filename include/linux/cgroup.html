<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › cgroup.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>cgroup.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_CGROUP_H</span>
<span class="cp">#define _LINUX_CGROUP_H</span>
<span class="cm">/*</span>
<span class="cm"> *  cgroup interface</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2003 BULL SA</span>
<span class="cm"> *  Copyright (C) 2004-2006 Silicon Graphics, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/nodemask.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/cgroupstats.h&gt;</span>
<span class="cp">#include &lt;linux/prio_heap.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>

<span class="cp">#ifdef CONFIG_CGROUPS</span>

<span class="k">struct</span> <span class="n">cgroupfs_root</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cgroup_subsys</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">inode</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cgroup</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">css_id</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">cgroup_init_early</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cgroup_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cgroup_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cgroup_lock_is_held</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">cgroup_lock_live_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cgroup_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cgroup_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cgroup_fork_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cgroup_post_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cgroup_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">run_callbacks</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cgroupstats_build</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroupstats</span> <span class="o">*</span><span class="n">stats</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cgroup_load_subsys</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cgroup_unload_subsys</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_cgroup_operations</span><span class="p">;</span>

<span class="cm">/* Define the enumeration of all builtin cgroup subsystems */</span>
<span class="cp">#define SUBSYS(_x) _x ## _subsys_id,</span>
<span class="k">enum</span> <span class="n">cgroup_subsys_id</span> <span class="p">{</span>
<span class="cp">#include &lt;linux/cgroup_subsys.h&gt;</span>
	<span class="n">CGROUP_BUILTIN_SUBSYS_COUNT</span>
<span class="p">};</span>
<span class="cp">#undef SUBSYS</span>
<span class="cm">/*</span>
<span class="cm"> * This define indicates the maximum number of subsystems that can be loaded</span>
<span class="cm"> * at once. We limit to this many since cgroupfs_root has subsys_bits to keep</span>
<span class="cm"> * track of all of them.</span>
<span class="cm"> */</span>
<span class="cp">#define CGROUP_SUBSYS_COUNT (BITS_PER_BYTE*sizeof(unsigned long))</span>

<span class="cm">/* Per-subsystem/per-cgroup state maintained by the system. */</span>
<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The cgroup that this subsystem is attached to. Useful</span>
<span class="cm">	 * for subsystems that want to know about the cgroup</span>
<span class="cm">	 * hierarchy structure</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgroup</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * State maintained by the cgroup system to allow subsystems</span>
<span class="cm">	 * to be &quot;busy&quot;. Should be accessed via css_get(),</span>
<span class="cm">	 * css_tryget() and and css_put().</span>
<span class="cm">	 */</span>

	<span class="n">atomic_t</span> <span class="n">refcnt</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="cm">/* ID for this css, if possible */</span>
	<span class="k">struct</span> <span class="n">css_id</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">id</span><span class="p">;</span>

	<span class="cm">/* Used to put @cgroup-&gt;dentry on the last css_put() */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">dput_work</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* bits in struct cgroup_subsys_state flags field */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">CSS_ROOT</span><span class="p">,</span> <span class="cm">/* This CSS is the root of the subsystem */</span>
	<span class="n">CSS_REMOVED</span><span class="p">,</span> <span class="cm">/* This CSS is dead */</span>
	<span class="n">CSS_CLEAR_CSS_REFS</span><span class="p">,</span>		<span class="cm">/* @ss-&gt;__DEPRECATED_clear_css_refs */</span>
<span class="p">};</span>

<span class="cm">/* Caller must verify that the css is not for root cgroup */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__css_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_add</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Call css_get() to hold a reference on the css; it can be used</span>
<span class="cm"> * for a reference obtained via:</span>
<span class="cm"> * - an existing ref-counted reference to the css</span>
<span class="cm"> * - task-&gt;cgroups for a locked task</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">css_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We don&#39;t need to reference count the root state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CSS_ROOT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">__css_get</span><span class="p">(</span><span class="n">css</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">css_is_removed</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">CSS_REMOVED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Call css_tryget() to take a reference on a css if your existing</span>
<span class="cm"> * (known-valid) reference isn&#39;t already ref-counted. Returns false if</span>
<span class="cm"> * the css has been destroyed.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">__css_tryget</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">css_tryget</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CSS_ROOT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__css_tryget</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * css_put() should be called to release a reference taken by</span>
<span class="cm"> * css_get() or css_tryget()</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__css_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">css_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CSS_ROOT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">__css_put</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* bits in struct cgroup flags field */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* Control Group is dead */</span>
	<span class="n">CGRP_REMOVED</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * Control Group has previously had a child cgroup or a task,</span>
<span class="cm">	 * but no longer (only if CGRP_NOTIFY_ON_RELEASE is set)</span>
<span class="cm">	 */</span>
	<span class="n">CGRP_RELEASABLE</span><span class="p">,</span>
	<span class="cm">/* Control Group requires release notifications to userspace */</span>
	<span class="n">CGRP_NOTIFY_ON_RELEASE</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * A thread in rmdir() is wating for this cgroup.</span>
<span class="cm">	 */</span>
	<span class="n">CGRP_WAIT_ON_RMDIR</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clone cgroup values when creating a new child cgroup</span>
<span class="cm">	 */</span>
	<span class="n">CGRP_CLONE_CHILDREN</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cgroup</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* &quot;unsigned long&quot; so bitops work */</span>

	<span class="cm">/*</span>
<span class="cm">	 * count users of this cgroup. &gt;0 means busy, but doesn&#39;t</span>
<span class="cm">	 * necessarily indicate the number of tasks in the cgroup</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We link our &#39;sibling&#39; struct into our parent&#39;s &#39;children&#39;.</span>
<span class="cm">	 * Our children link their &#39;sibling&#39; into our &#39;children&#39;.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">sibling</span><span class="p">;</span>	<span class="cm">/* my parent&#39;s children */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">children</span><span class="p">;</span>	<span class="cm">/* my children */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">files</span><span class="p">;</span>		<span class="cm">/* my files */</span>

	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>		<span class="cm">/* my parent */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>	<span class="cm">/* cgroup fs entry, RCU protected */</span>

	<span class="cm">/* Private pointers for each registered subsystem */</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">subsys</span><span class="p">[</span><span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">top_cgroup</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * List of cg_cgroup_links pointing at css_sets with</span>
<span class="cm">	 * tasks in this cgroup. Protected by css_set_lock</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">css_sets</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">allcg_node</span><span class="p">;</span>	<span class="cm">/* cgroupfs_root-&gt;allcg_list */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cft_q_node</span><span class="p">;</span>	<span class="cm">/* used during cftype add/rm */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Linked list running through all cgroups that can</span>
<span class="cm">	 * potentially be reaped by the release agent. Protected by</span>
<span class="cm">	 * release_list_lock</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">release_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * list of pidlists, up to two for each namespace (one for procs, one</span>
<span class="cm">	 * for tasks); created on demand.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pidlists</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">pidlist_mutex</span><span class="p">;</span>

	<span class="cm">/* For RCU-protected deletion */</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu_head</span><span class="p">;</span>

	<span class="cm">/* List of events which userspace want to receive */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">event_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">event_list_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * A css_set is a structure holding pointers to a set of</span>
<span class="cm"> * cgroup_subsys_state objects. This saves space in the task struct</span>
<span class="cm"> * object and speeds up fork()/exit(), since a single inc/dec and a</span>
<span class="cm"> * list_add()/del() can bump the reference count on the entire cgroup</span>
<span class="cm"> * set for a task.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">css_set</span> <span class="p">{</span>

	<span class="cm">/* Reference count */</span>
	<span class="n">atomic_t</span> <span class="n">refcount</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * List running through all cgroup groups in the same hash</span>
<span class="cm">	 * slot. Protected by css_set_lock</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">hlist</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * List running through all tasks using this cgroup</span>
<span class="cm">	 * group. Protected by css_set_lock</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tasks</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * List of cg_cgroup_link objects on link chains from</span>
<span class="cm">	 * cgroups referenced from this css_set. Protected by</span>
<span class="cm">	 * css_set_lock</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cg_links</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set of subsystem states, one for each subsystem. This array</span>
<span class="cm">	 * is immutable after creation apart from the init_css_set</span>
<span class="cm">	 * during subsystem registration (at boot time) and modular subsystem</span>
<span class="cm">	 * loading/unloading.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">subsys</span><span class="p">[</span><span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">];</span>

	<span class="cm">/* For RCU-protected deletion */</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu_head</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * cgroup_map_cb is an abstract callback API for reporting map-valued</span>
<span class="cm"> * control files</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">cgroup_map_cb</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fill</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup_map_cb</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">u64</span> <span class="n">value</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct cftype: handler definitions for cgroup control files</span>
<span class="cm"> *</span>
<span class="cm"> * When reading/writing to a file:</span>
<span class="cm"> *	- the cgroup to use is file-&gt;f_dentry-&gt;d_parent-&gt;d_fsdata</span>
<span class="cm"> *	- the &#39;cftype&#39; of the file is file-&gt;f_dentry-&gt;d_fsdata</span>
<span class="cm"> */</span>

<span class="cm">/* cftype-&gt;flags */</span>
<span class="cp">#define CFTYPE_ONLY_ON_ROOT	(1U &lt;&lt; 0)	</span><span class="cm">/* only create on root cg */</span><span class="cp"></span>
<span class="cp">#define CFTYPE_NOT_ON_ROOT	(1U &lt;&lt; 1)	</span><span class="cm">/* don&#39;t create onp root cg */</span><span class="cp"></span>

<span class="cp">#define MAX_CFTYPE_NAME		64</span>

<span class="k">struct</span> <span class="n">cftype</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * By convention, the name should begin with the name of the</span>
<span class="cm">	 * subsystem, followed by a period.  Zero length string indicates</span>
<span class="cm">	 * end of cftype array.</span>
<span class="cm">	 */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">MAX_CFTYPE_NAME</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">private</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If not 0, file mode is set to this value, otherwise it will</span>
<span class="cm">	 * be figured out automatically</span>
<span class="cm">	 */</span>
	<span class="n">umode_t</span> <span class="n">mode</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If non-zero, defines the maximum length of string that can</span>
<span class="cm">	 * be passed to write_string; defaults to 64</span>
<span class="cm">	 */</span>
	<span class="kt">size_t</span> <span class="n">max_write_len</span><span class="p">;</span>

	<span class="cm">/* CFTYPE_* flags */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * read_u64() is a shortcut for the common case of returning a</span>
<span class="cm">	 * single integer. Use it in place of read()</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">read_u64</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * read_s64() is a signed version of read_u64()</span>
<span class="cm">	 */</span>
	<span class="n">s64</span> <span class="p">(</span><span class="o">*</span><span class="n">read_s64</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * read_map() is used for defining a map of key/value</span>
<span class="cm">	 * pairs. It should call cb-&gt;fill(cb, key, value) for each</span>
<span class="cm">	 * entry. The key/value pairs (and their ordering) should not</span>
<span class="cm">	 * change between reboots.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_map</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cgroup_map_cb</span> <span class="o">*</span><span class="n">cb</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * read_seq_string() is used for outputting a simple sequence</span>
<span class="cm">	 * using seqfile.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_seq_string</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">);</span>

	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * write_u64() is a shortcut for the common case of accepting</span>
<span class="cm">	 * a single integer (as parsed by simple_strtoull) from</span>
<span class="cm">	 * userspace. Use in place of write(); return 0 or error.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_u64</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * write_s64() is a signed version of write_u64()</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_s64</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="n">s64</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * write_string() is passed a nul-terminated kernelspace</span>
<span class="cm">	 * buffer of maximum length determined by max_write_len.</span>
<span class="cm">	 * Returns 0 or -ve error code.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_string</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * trigger() callback can be used to get some kick from the</span>
<span class="cm">	 * userspace, when the actual string written is not important</span>
<span class="cm">	 * at all. The private field can be used to determine the</span>
<span class="cm">	 * kick type for multiplexing.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">trigger</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">event</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * register_event() callback will be used to add new userspace</span>
<span class="cm">	 * waiter for changes related to the cftype. Implement it if</span>
<span class="cm">	 * you want to provide this functionality. Use eventfd_signal()</span>
<span class="cm">	 * on eventfd to send notification to userspace.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">register_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">eventfd_ctx</span> <span class="o">*</span><span class="n">eventfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * unregister_event() callback will be called when userspace</span>
<span class="cm">	 * closes the eventfd or on cgroup removing.</span>
<span class="cm">	 * This callback must be implemented, if you want provide</span>
<span class="cm">	 * notification functionality.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">unregister_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">eventfd_ctx</span> <span class="o">*</span><span class="n">eventfd</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * cftype_sets describe cftypes belonging to a subsystem and are chained at</span>
<span class="cm"> * cgroup_subsys-&gt;cftsets.  Each cftset points to an array of cftypes</span>
<span class="cm"> * terminated by zero length name.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cftype_set</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">node</span><span class="p">;</span>	<span class="cm">/* chained at subsys-&gt;cftsets */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cftype</span>		<span class="o">*</span><span class="n">cfts</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cgroup_scanner</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test_task</span><span class="p">)(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_scanner</span> <span class="o">*</span><span class="n">scan</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">process_task</span><span class="p">)(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cgroup_scanner</span> <span class="o">*</span><span class="n">scan</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ptr_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">cgroup_add_cftypes</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cfts</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">cgroup_rm_cftypes</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cfts</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">cgroup_is_removed</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">cgroup_path</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">cgroup_task_count</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">);</span>

<span class="cm">/* Return true if cgrp is a descendant of the task&#39;s cgroup */</span>
<span class="kt">int</span> <span class="n">cgroup_is_descendant</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * When the subsys has to access css and may add permanent refcnt to css,</span>
<span class="cm"> * it should take care of racy conditions with rmdir(). Following set of</span>
<span class="cm"> * functions, is for stop/restart rmdir if necessary.</span>
<span class="cm"> * Because these will call css_get/put, &quot;css&quot; should be alive css.</span>
<span class="cm"> *</span>
<span class="cm"> *  cgroup_exclude_rmdir();</span>
<span class="cm"> *  ...do some jobs which may access arbitrary empty cgroup</span>
<span class="cm"> *  cgroup_release_and_wakeup_rmdir();</span>
<span class="cm"> *</span>
<span class="cm"> *  When someone removes a cgroup while cgroup_exclude_rmdir() holds it,</span>
<span class="cm"> *  it sleeps and cgroup_release_and_wakeup_rmdir() will wake him up.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="n">cgroup_exclude_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">cgroup_release_and_wakeup_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Control Group taskset, used to pass around set of tasks to cgroup_subsys</span>
<span class="cm"> * methods.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cgroup_taskset</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">cgroup_taskset_first</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">cgroup_taskset_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgroup_taskset_cur_cgroup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">cgroup_taskset_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_taskset_for_each - iterate cgroup_taskset</span>
<span class="cm"> * @task: the loop cursor</span>
<span class="cm"> * @skip_cgrp: skip if task&#39;s cgroup matches this, %NULL to iterate through all</span>
<span class="cm"> * @tset: taskset to iterate</span>
<span class="cm"> */</span>
<span class="cp">#define cgroup_taskset_for_each(task, skip_cgrp, tset)			\</span>
<span class="cp">	for ((task) = cgroup_taskset_first((tset)); (task);		\</span>
<span class="cp">	     (task) = cgroup_taskset_next((tset)))			\</span>
<span class="cp">		if (!(skip_cgrp) ||					\</span>
<span class="cp">		    cgroup_taskset_cur_cgroup((tset)) != (skip_cgrp))</span>

<span class="cm">/*</span>
<span class="cm"> * Control Group subsystem type.</span>
<span class="cm"> * See Documentation/cgroups/cgroups.txt for details</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pre_destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">can_attach</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cancel_attach</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">attach</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fork</span><span class="p">)(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exit</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">old_cgrp</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">post_clone</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">subsys_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">active</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">disabled</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">early_init</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * True if this subsys uses ID. ID is not available before cgroup_init()</span>
<span class="cm">	 * (not available in early_init time.)</span>
<span class="cm">	 */</span>
	<span class="n">bool</span> <span class="n">use_id</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If %true, cgroup removal will try to clear css refs by retrying</span>
<span class="cm">	 * ss-&gt;pre_destroy() until there&#39;s no css ref left.  This behavior</span>
<span class="cm">	 * is strictly for backward compatibility and will be removed as</span>
<span class="cm">	 * soon as the current user (memcg) is updated.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If %false, ss-&gt;pre_destroy() can&#39;t fail and cgroup removal won&#39;t</span>
<span class="cm">	 * wait for css refs to drop to zero before proceeding.</span>
<span class="cm">	 */</span>
	<span class="n">bool</span> <span class="n">__DEPRECATED_clear_css_refs</span><span class="p">;</span>

<span class="cp">#define MAX_CGROUP_TYPE_NAMELEN 32</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protects sibling/children links of cgroups in this</span>
<span class="cm">	 * hierarchy, plus protects which hierarchy (or none) the</span>
<span class="cm">	 * subsystem is a part of (i.e. root/sibling).  To avoid</span>
<span class="cm">	 * potential deadlocks, the following operations should not be</span>
<span class="cm">	 * undertaken while holding any hierarchy_mutex:</span>
<span class="cm">	 *</span>
<span class="cm">	 * - allocating memory</span>
<span class="cm">	 * - initiating hotplug events</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">hierarchy_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">subsys_key</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Link to parent, and list entry in parent&#39;s children.</span>
<span class="cm">	 * Protected by this-&gt;hierarchy_mutex and cgroup_lock()</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">sibling</span><span class="p">;</span>
	<span class="cm">/* used when use_id == true */</span>
	<span class="k">struct</span> <span class="n">idr</span> <span class="n">idr</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">id_lock</span><span class="p">;</span>

	<span class="cm">/* list of cftype_sets */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cftsets</span><span class="p">;</span>

	<span class="cm">/* base cftypes, automatically [de]registered with subsys itself */</span>
	<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">base_cftypes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cftype_set</span> <span class="n">base_cftset</span><span class="p">;</span>

	<span class="cm">/* should be defined only by modular subsystems */</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define SUBSYS(_x) extern struct cgroup_subsys _x ## _subsys;</span>
<span class="cp">#include &lt;linux/cgroup_subsys.h&gt;</span>
<span class="cp">#undef SUBSYS</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="nf">cgroup_subsys_state</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">subsys_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">subsys_id</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * function to get the cgroup_subsys_state which allows for extra</span>
<span class="cm"> * rcu_dereference_check() conditions, such as locks used during the</span>
<span class="cm"> * cgroup_subsys::attach() methods.</span>
<span class="cm"> */</span>
<span class="cp">#define task_subsys_state_check(task, subsys_id, __c)			\</span>
<span class="cp">	rcu_dereference_check(task-&gt;cgroups-&gt;subsys[subsys_id],		\</span>
<span class="cp">			      lockdep_is_held(&amp;task-&gt;alloc_lock) ||	\</span>
<span class="cp">			      cgroup_lock_is_held() || (__c))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span>
<span class="nf">task_subsys_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">subsys_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task_subsys_state_check</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">subsys_id</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cgroup</span><span class="o">*</span> <span class="nf">task_cgroup</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
					       <span class="kt">int</span> <span class="n">subsys_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task_subsys_state</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">subsys_id</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cgroup</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* A cgroup_iter should be treated as an opaque object */</span>
<span class="k">struct</span> <span class="n">cgroup_iter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">cg_link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * To iterate across the tasks in a cgroup:</span>
<span class="cm"> *</span>
<span class="cm"> * 1) call cgroup_iter_start to initialize an iterator</span>
<span class="cm"> *</span>
<span class="cm"> * 2) call cgroup_iter_next() to retrieve member tasks until it</span>
<span class="cm"> *    returns NULL or until you want to end the iteration</span>
<span class="cm"> *</span>
<span class="cm"> * 3) call cgroup_iter_end() to destroy the iterator.</span>
<span class="cm"> *</span>
<span class="cm"> * Or, call cgroup_scan_tasks() to iterate through every task in a</span>
<span class="cm"> * cgroup - cgroup_scan_tasks() holds the css_set_lock when calling</span>
<span class="cm"> * the test_task() callback, but not while calling the process_task()</span>
<span class="cm"> * callback.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cgroup_iter_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_iter</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">cgroup_iter_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cgroup_iter</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">cgroup_iter_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_iter</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">cgroup_scan_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_scanner</span> <span class="o">*</span><span class="n">scan</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">cgroup_attach_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">cgroup_attach_task_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * CSS ID is ID for cgroup_subsys_state structs under subsys. This only works</span>
<span class="cm"> * if cgroup_subsys.use_id == true. It can be used for looking up and scanning.</span>
<span class="cm"> * CSS ID is assigned at cgroup allocation (create) automatically</span>
<span class="cm"> * and removed when subsys calls free_css_id() function. This is because</span>
<span class="cm"> * the lifetime of cgroup_subsys_state is subsys&#39;s matter.</span>
<span class="cm"> *</span>
<span class="cm"> * Looking up and scanning function should be called under rcu_read_lock().</span>
<span class="cm"> * Taking cgroup_mutex()/hierarchy_mutex() is not necessary for following calls.</span>
<span class="cm"> * But the css returned by this routine can be &quot;not populated yet&quot; or &quot;being</span>
<span class="cm"> * destroyed&quot;. The caller should check css and cgroup&#39;s status.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Typically Called at -&gt;destroy(), or somewhere the subsys frees</span>
<span class="cm"> * cgroup_subsys_state.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">free_css_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">);</span>

<span class="cm">/* Find a cgroup_subsys_state which has given ID */</span>

<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Get a cgroup whose id is greater than or equal to id under tree of root.</span>
<span class="cm"> * Returning a cgroup_subsys_state or NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css_get_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">foundid</span><span class="p">);</span>

<span class="cm">/* Returns true if root is ancestor of cg */</span>
<span class="n">bool</span> <span class="n">css_is_ancestor</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">cg</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>

<span class="cm">/* Get id and depth of css */</span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">css_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">css_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">cgroup_css_from_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_CGROUPS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cgroup_init_early</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cgroup_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cgroup_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cgroup_fork_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cgroup_post_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cgroup_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">callbacks</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cgroup_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cgroup_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cgroupstats_build</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroupstats</span> <span class="o">*</span><span class="n">stats</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* No cgroups - nothing to do */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cgroup_attach_task_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_CGROUPS */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_CGROUP_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
