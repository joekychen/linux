<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › kernel.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>kernel.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_KERNEL_H</span>
<span class="cp">#define _LINUX_KERNEL_H</span>

<span class="cp">#include &lt;linux/sysinfo.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * &#39;kernel.h&#39; contains some often-used function prototypes etc</span>
<span class="cm"> */</span>
<span class="cp">#define __ALIGN_KERNEL(x, a)		__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)</span>
<span class="cp">#define __ALIGN_KERNEL_MASK(x, mask)	(((x) + (mask)) &amp; ~(mask))</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;stdarg.h&gt;</span>
<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>
<span class="cp">#include &lt;linux/typecheck.h&gt;</span>
<span class="cp">#include &lt;linux/printk.h&gt;</span>
<span class="cp">#include &lt;linux/dynamic_debug.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#define USHRT_MAX	((u16)(~0U))</span>
<span class="cp">#define SHRT_MAX	((s16)(USHRT_MAX&gt;&gt;1))</span>
<span class="cp">#define SHRT_MIN	((s16)(-SHRT_MAX - 1))</span>
<span class="cp">#define INT_MAX		((int)(~0U&gt;&gt;1))</span>
<span class="cp">#define INT_MIN		(-INT_MAX - 1)</span>
<span class="cp">#define UINT_MAX	(~0U)</span>
<span class="cp">#define LONG_MAX	((long)(~0UL&gt;&gt;1))</span>
<span class="cp">#define LONG_MIN	(-LONG_MAX - 1)</span>
<span class="cp">#define ULONG_MAX	(~0UL)</span>
<span class="cp">#define LLONG_MAX	((long long)(~0ULL&gt;&gt;1))</span>
<span class="cp">#define LLONG_MIN	(-LLONG_MAX - 1)</span>
<span class="cp">#define ULLONG_MAX	(~0ULL)</span>
<span class="cp">#define SIZE_MAX	(~(size_t)0)</span>

<span class="cp">#define STACK_MAGIC	0xdeadbeef</span>

<span class="cp">#define REPEAT_BYTE(x)	((~0ul / 0xff) * (x))</span>

<span class="cp">#define ALIGN(x, a)		__ALIGN_KERNEL((x), (a))</span>
<span class="cp">#define __ALIGN_MASK(x, mask)	__ALIGN_KERNEL_MASK((x), (mask))</span>
<span class="cp">#define PTR_ALIGN(p, a)		((typeof(p))ALIGN((unsigned long)(p), (a)))</span>
<span class="cp">#define IS_ALIGNED(x, a)		(((x) &amp; ((typeof(x))(a) - 1)) == 0)</span>

<span class="cp">#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))</span>

<span class="cm">/*</span>
<span class="cm"> * This looks more complex than it should be. But we need to</span>
<span class="cm"> * get the type for the ~ right in round_down (it needs to be</span>
<span class="cm"> * as wide as the result!), and we want to evaluate the macro</span>
<span class="cm"> * arguments just once each.</span>
<span class="cm"> */</span>
<span class="cp">#define __round_mask(x, y) ((__typeof__(x))((y)-1))</span>
<span class="cp">#define round_up(x, y) ((((x)-1) | __round_mask(x, y))+1)</span>
<span class="cp">#define round_down(x, y) ((x) &amp; ~__round_mask(x, y))</span>

<span class="cp">#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)-&gt;f))</span>
<span class="cp">#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))</span>
<span class="cp">#define DIV_ROUND_UP_ULL(ll,d) \</span>
<span class="cp">	({ unsigned long long _tmp = (ll)+(d)-1; do_div(_tmp, d); _tmp; })</span>

<span class="cp">#if BITS_PER_LONG == 32</span>
<span class="cp"># define DIV_ROUND_UP_SECTOR_T(ll,d) DIV_ROUND_UP_ULL(ll, d)</span>
<span class="cp">#else</span>
<span class="cp"># define DIV_ROUND_UP_SECTOR_T(ll,d) DIV_ROUND_UP(ll,d)</span>
<span class="cp">#endif</span>

<span class="cm">/* The `const&#39; in roundup() prevents gcc-3.3 from calling __divdi3 */</span>
<span class="cp">#define roundup(x, y) (					\</span>
<span class="cp">{							\</span>
<span class="cp">	const typeof(y) __y = y;			\</span>
<span class="cp">	(((x) + (__y - 1)) / __y) * __y;		\</span>
<span class="cp">}							\</span>
<span class="cp">)</span>
<span class="cp">#define rounddown(x, y) (				\</span>
<span class="cp">{							\</span>
<span class="cp">	typeof(x) __x = (x);				\</span>
<span class="cp">	__x - (__x % (y));				\</span>
<span class="cp">}							\</span>
<span class="cp">)</span>
<span class="cp">#define DIV_ROUND_CLOSEST(x, divisor)(			\</span>
<span class="cp">{							\</span>
<span class="cp">	typeof(divisor) __divisor = divisor;		\</span>
<span class="cp">	(((x) + ((__divisor) / 2)) / (__divisor));	\</span>
<span class="cp">}							\</span>
<span class="cp">)</span>

<span class="cm">/*</span>
<span class="cm"> * Multiplies an integer by a fraction, while avoiding unnecessary</span>
<span class="cm"> * overflow or loss of precision.</span>
<span class="cm"> */</span>
<span class="cp">#define mult_frac(x, numer, denom)(			\</span>
<span class="cp">{							\</span>
<span class="cp">	typeof(x) quot = (x) / (denom);			\</span>
<span class="cp">	typeof(x) rem  = (x) % (denom);			\</span>
<span class="cp">	(quot * (numer)) + ((rem * (numer)) / (denom));	\</span>
<span class="cp">}							\</span>
<span class="cp">)</span>


<span class="cp">#define _RET_IP_		(unsigned long)__builtin_return_address(0)</span>
<span class="cp">#define _THIS_IP_  ({ __label__ __here; __here: (unsigned long)&amp;&amp;__here; })</span>

<span class="cp">#ifdef CONFIG_LBDAF</span>
<span class="cp"># include &lt;asm/div64.h&gt;</span>
<span class="cp"># define sector_div(a, b) do_div(a, b)</span>
<span class="cp">#else</span>
<span class="cp"># define sector_div(n, b)( \</span>
<span class="cp">{ \</span>
<span class="cp">	int _res; \</span>
<span class="cp">	_res = (n) % (b); \</span>
<span class="cp">	(n) /= (b); \</span>
<span class="cp">	_res; \</span>
<span class="cp">} \</span>
<span class="cp">)</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * upper_32_bits - return bits 32-63 of a number</span>
<span class="cm"> * @n: the number we&#39;re accessing</span>
<span class="cm"> *</span>
<span class="cm"> * A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress</span>
<span class="cm"> * the &quot;right shift count &gt;= width of type&quot; warning when that quantity is</span>
<span class="cm"> * 32-bits.</span>
<span class="cm"> */</span>
<span class="cp">#define upper_32_bits(n) ((u32)(((n) &gt;&gt; 16) &gt;&gt; 16))</span>

<span class="cm">/**</span>
<span class="cm"> * lower_32_bits - return bits 0-31 of a number</span>
<span class="cm"> * @n: the number we&#39;re accessing</span>
<span class="cm"> */</span>
<span class="cp">#define lower_32_bits(n) ((u32)(n))</span>

<span class="k">struct</span> <span class="n">completion</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pt_regs</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">user</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PREEMPT_VOLUNTARY</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">_cond_resched</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp"># define might_resched() _cond_resched()</span>
<span class="cp">#else</span>
<span class="cp"># define might_resched() do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_DEBUG_ATOMIC_SLEEP</span>
  <span class="kt">void</span> <span class="n">__might_sleep</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preempt_offset</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * might_sleep - annotation for functions that can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * this macro will print a stack trace if it is executed in an atomic</span>
<span class="cm"> * context (spinlock, irq-handler, ...).</span>
<span class="cm"> *</span>
<span class="cm"> * This is a useful debugging help to be able to catch problems early and not</span>
<span class="cm"> * be bitten later when the calling function happens to sleep when it is not</span>
<span class="cm"> * supposed to.</span>
<span class="cm"> */</span>
<span class="cp"># define might_sleep() \</span>
<span class="cp">	do { __might_sleep(__FILE__, __LINE__, 0); might_resched(); } while (0)</span>
<span class="cp">#else</span>
  <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__might_sleep</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">preempt_offset</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp"># define might_sleep() do { might_resched(); } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#define might_sleep_if(cond) do { if (cond) might_sleep(); } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * abs() handles unsigned and signed longs, ints, shorts and chars.  For all</span>
<span class="cm"> * input types abs() returns a signed long.</span>
<span class="cm"> * abs() should not be used for 64-bit types (s64, u64, long long) - use abs64()</span>
<span class="cm"> * for those.</span>
<span class="cm"> */</span>
<span class="cp">#define abs(x) ({						\</span>
<span class="cp">		long ret;					\</span>
<span class="cp">		if (sizeof(x) == sizeof(long)) {		\</span>
<span class="cp">			long __x = (x);				\</span>
<span class="cp">			ret = (__x &lt; 0) ? -__x : __x;		\</span>
<span class="cp">		} else {					\</span>
<span class="cp">			int __x = (x);				\</span>
<span class="cp">			ret = (__x &lt; 0) ? -__x : __x;		\</span>
<span class="cp">		}						\</span>
<span class="cp">		ret;						\</span>
<span class="cp">	})</span>

<span class="cp">#define abs64(x) ({				\</span>
<span class="cp">		s64 __x = (x);			\</span>
<span class="cp">		(__x &lt; 0) ? -__x : __x;		\</span>
<span class="cp">	})</span>

<span class="cp">#ifdef CONFIG_PROVE_LOCKING</span>
<span class="kt">void</span> <span class="n">might_fault</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">might_fault</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">atomic_notifier_head</span> <span class="n">panic_notifier_list</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">panic_blink</span><span class="p">)(</span><span class="kt">int</span> <span class="n">state</span><span class="p">);</span>
<span class="n">__printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">panic</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
	<span class="n">__noreturn</span> <span class="n">__cold</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">oops_enter</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">oops_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">print_oops_end_marker</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">oops_may_print</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">do_exit</span><span class="p">(</span><span class="kt">long</span> <span class="n">error_code</span><span class="p">)</span>
	<span class="n">__noreturn</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">complete_and_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">)</span>
	<span class="n">__noreturn</span><span class="p">;</span>

<span class="cm">/* Internal, do not use. */</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">_kstrtoul</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">_kstrtol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtoull</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtoll</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">kstrtoul</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We want to shortcut function call, but</span>
<span class="cm">	 * __builtin_types_compatible_p(unsigned long, unsigned long long) = 0.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">__alignof__</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">==</span> <span class="n">__alignof__</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">kstrtoull</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">res</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">_kstrtoul</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">kstrtol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We want to shortcut function call, but</span>
<span class="cm">	 * __builtin_types_compatible_p(long, long long) = 0.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">__alignof__</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="o">==</span> <span class="n">__alignof__</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">kstrtoll</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">res</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">_kstrtol</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtouint</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtoint</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">kstrtou64</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kstrtoull</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">kstrtos64</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kstrtoll</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">kstrtou32</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kstrtouint</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">kstrtos32</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">s32</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kstrtoint</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtou16</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtos16</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">s16</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtou8</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtos8</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">s8</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtoull_from_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtoll_from_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtoul_from_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtol_from_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtouint_from_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtoint_from_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtou16_from_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtos16_from_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">s16</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtou8_from_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">kstrtos8_from_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">s8</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">kstrtou64_from_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kstrtoull_from_user</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">kstrtos64_from_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kstrtoll_from_user</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">kstrtou32_from_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kstrtouint_from_user</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">kstrtos32_from_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">s32</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kstrtoint_from_user</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Obsolete, do not use.  Use kstrto&lt;foo&gt; instead */</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">simple_strtol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">simple_strtoull</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">simple_strtoll</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="cp">#define strict_strtoul	kstrtoul</span>
<span class="cp">#define strict_strtol	kstrtol</span>
<span class="cp">#define strict_strtoull	kstrtoull</span>
<span class="cp">#define strict_strtoll	kstrtoll</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">num_to_str</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">num</span><span class="p">);</span>

<span class="cm">/* lib/printf utilities */</span>

<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="kt">int</span> <span class="n">sprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="kt">int</span> <span class="n">vsprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">va_list</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">snprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">vsnprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">scnprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">vscnprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">kasprintf</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kvasprintf</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">__scanf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">sscanf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__scanf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">vsscanf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">va_list</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">get_option</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pint</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">get_options</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nints</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ints</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">memparse</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">retptr</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">core_kernel_text</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">core_kernel_data</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__kernel_text_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">kernel_text_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">func_ptr_is_kernel_text</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">pid</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">session_of_pgrp</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pgrp</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">int_sqrt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">bust_spinlocks</span><span class="p">(</span><span class="kt">int</span> <span class="n">yes</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wake_up_klogd</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">oops_in_progress</span><span class="p">;</span>		<span class="cm">/* If set, an oops, panic(), BUG() or die() is in progress */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">panic_timeout</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">panic_on_oops</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">panic_on_unrecovered_nmi</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">panic_on_io_nmi</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_panic_on_stackoverflow</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">print_tainted</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">add_taint</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">flag</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">test_taint</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">flag</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_taint</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">root_mountflags</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">early_boot_irqs_disabled</span><span class="p">;</span>

<span class="cm">/* Values used for system_state */</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">system_states</span> <span class="p">{</span>
	<span class="n">SYSTEM_BOOTING</span><span class="p">,</span>
	<span class="n">SYSTEM_RUNNING</span><span class="p">,</span>
	<span class="n">SYSTEM_HALT</span><span class="p">,</span>
	<span class="n">SYSTEM_POWER_OFF</span><span class="p">,</span>
	<span class="n">SYSTEM_RESTART</span><span class="p">,</span>
	<span class="n">SYSTEM_SUSPEND_DISK</span><span class="p">,</span>
<span class="p">}</span> <span class="n">system_state</span><span class="p">;</span>

<span class="cp">#define TAINT_PROPRIETARY_MODULE	0</span>
<span class="cp">#define TAINT_FORCED_MODULE		1</span>
<span class="cp">#define TAINT_UNSAFE_SMP		2</span>
<span class="cp">#define TAINT_FORCED_RMMOD		3</span>
<span class="cp">#define TAINT_MACHINE_CHECK		4</span>
<span class="cp">#define TAINT_BAD_PAGE			5</span>
<span class="cp">#define TAINT_USER			6</span>
<span class="cp">#define TAINT_DIE			7</span>
<span class="cp">#define TAINT_OVERRIDDEN_ACPI_TABLE	8</span>
<span class="cp">#define TAINT_WARN			9</span>
<span class="cp">#define TAINT_CRAP			10</span>
<span class="cp">#define TAINT_FIRMWARE_WORKAROUND	11</span>
<span class="cp">#define TAINT_OOT_MODULE		12</span>

<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">hex_asc</span><span class="p">[];</span>
<span class="cp">#define hex_asc_lo(x)	hex_asc[((x) &amp; 0x0f)]</span>
<span class="cp">#define hex_asc_hi(x)	hex_asc[((x) &amp; 0xf0) &gt;&gt; 4]</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">hex_byte_pack</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u8</span> <span class="n">byte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="n">hex_asc_hi</span><span class="p">(</span><span class="n">byte</span><span class="p">);</span>
	<span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="n">hex_asc_lo</span><span class="p">(</span><span class="n">byte</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">__deprecated</span> <span class="nf">pack_hex_byte</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u8</span> <span class="n">byte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hex_byte_pack</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">byte</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">hex2bin</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * General tracing related utility functions - trace_printk(),</span>
<span class="cm"> * tracing_on/tracing_off and tracing_start()/tracing_stop</span>
<span class="cm"> *</span>
<span class="cm"> * Use tracing_on/tracing_off when you want to quickly turn on or off</span>
<span class="cm"> * tracing. It simply enables or disables the recording of the trace events.</span>
<span class="cm"> * This also corresponds to the user space /sys/kernel/debug/tracing/tracing_on</span>
<span class="cm"> * file, which gives a means for the kernel and userspace to interact.</span>
<span class="cm"> * Place a tracing_off() in the kernel where you want tracing to end.</span>
<span class="cm"> * From user space, examine the trace, and then echo 1 &gt; tracing_on</span>
<span class="cm"> * to continue tracing.</span>
<span class="cm"> *</span>
<span class="cm"> * tracing_stop/tracing_start has slightly more overhead. It is used</span>
<span class="cm"> * by things like suspend to ram where disabling the recording of the</span>
<span class="cm"> * trace is not enough, but tracing must actually stop because things</span>
<span class="cm"> * like calling smp_processor_id() may crash the system.</span>
<span class="cm"> *</span>
<span class="cm"> * Most likely, you want to use tracing_on/tracing_off.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_RING_BUFFER</span>
<span class="cm">/* trace_off_permanent stops recording with no way to bring it back */</span>
<span class="kt">void</span> <span class="n">tracing_off_permanent</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tracing_off_permanent</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">enum</span> <span class="n">ftrace_dump_mode</span> <span class="p">{</span>
	<span class="n">DUMP_NONE</span><span class="p">,</span>
	<span class="n">DUMP_ALL</span><span class="p">,</span>
	<span class="n">DUMP_ORIG</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_TRACING</span>
<span class="kt">void</span> <span class="n">tracing_on</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">tracing_off</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">tracing_is_on</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tracing_start</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tracing_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ftrace_off_permanent</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="nf">__printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">____trace_printk_check_format</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#define __trace_printk_check_format(fmt, args...)			\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (0)								\</span>
<span class="cp">		____trace_printk_check_format(fmt, ##args);		\</span>
<span class="cp">} while (0)</span>

<span class="cm">/**</span>
<span class="cm"> * trace_printk - printf formatting in the ftrace buffer</span>
<span class="cm"> * @fmt: the printf format for printing</span>
<span class="cm"> *</span>
<span class="cm"> * Note: __trace_printk is an internal function for trace_printk and</span>
<span class="cm"> *       the @ip is passed in via the trace_printk macro.</span>
<span class="cm"> *</span>
<span class="cm"> * This function allows a kernel developer to debug fast path sections</span>
<span class="cm"> * that printk is not appropriate for. By scattering in various</span>
<span class="cm"> * printk like tracing in the code, a developer can quickly see</span>
<span class="cm"> * where problems are occurring.</span>
<span class="cm"> *</span>
<span class="cm"> * This is intended as a debugging tool for the developer only.</span>
<span class="cm"> * Please refrain from leaving trace_printks scattered around in</span>
<span class="cm"> * your code.</span>
<span class="cm"> */</span>

<span class="cp">#define trace_printk(fmt, args...)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	static const char *trace_printk_fmt				\</span>
<span class="cp">		__attribute__((section(&quot;__trace_printk_fmt&quot;))) =	\</span>
<span class="cp">		__builtin_constant_p(fmt) ? fmt : NULL;			\</span>
<span class="cp">									\</span>
<span class="cp">	__trace_printk_check_format(fmt, ##args);			\</span>
<span class="cp">									\</span>
<span class="cp">	if (__builtin_constant_p(fmt))					\</span>
<span class="cp">		__trace_bprintk(_THIS_IP_, trace_printk_fmt, ##args);	\</span>
<span class="cp">	else								\</span>
<span class="cp">		__trace_printk(_THIS_IP_, fmt, ##args);			\</span>
<span class="cp">} while (0)</span>

<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">__trace_bprintk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">__trace_printk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">trace_dump_stack</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The double __builtin_constant_p is because gcc will give us an error</span>
<span class="cm"> * if we try to allocate the static variable to fmt if it is not a</span>
<span class="cm"> * constant. Even with the outer if statement.</span>
<span class="cm"> */</span>
<span class="cp">#define ftrace_vprintk(fmt, vargs)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (__builtin_constant_p(fmt)) {				\</span>
<span class="cp">		static const char *trace_printk_fmt			\</span>
<span class="cp">		  __attribute__((section(&quot;__trace_printk_fmt&quot;))) =	\</span>
<span class="cp">			__builtin_constant_p(fmt) ? fmt : NULL;		\</span>
<span class="cp">									\</span>
<span class="cp">		__ftrace_vbprintk(_THIS_IP_, trace_printk_fmt, vargs);	\</span>
<span class="cp">	} else								\</span>
<span class="cp">		__ftrace_vprintk(_THIS_IP_, fmt, vargs);		\</span>
<span class="cp">} while (0)</span>

<span class="k">extern</span> <span class="kt">int</span>
<span class="n">__ftrace_vbprintk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">ap</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span>
<span class="n">__ftrace_vprintk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">ap</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ftrace_dump</span><span class="p">(</span><span class="k">enum</span> <span class="n">ftrace_dump_mode</span> <span class="n">oops_dump_mode</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">trace_printk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tracing_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tracing_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_off_permanent</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">trace_dump_stack</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tracing_on</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tracing_off</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tracing_is_on</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">trace_printk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ftrace_vprintk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_dump</span><span class="p">(</span><span class="k">enum</span> <span class="n">ftrace_dump_mode</span> <span class="n">oops_dump_mode</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TRACING */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * min()/max()/clamp() macros that also do</span>
<span class="cm"> * strict type-checking.. See the</span>
<span class="cm"> * &quot;unnecessary&quot; pointer comparison.</span>
<span class="cm"> */</span>
<span class="cp">#define min(x, y) ({				\</span>
<span class="cp">	typeof(x) _min1 = (x);			\</span>
<span class="cp">	typeof(y) _min2 = (y);			\</span>
<span class="cp">	(void) (&amp;_min1 == &amp;_min2);		\</span>
<span class="cp">	_min1 &lt; _min2 ? _min1 : _min2; })</span>

<span class="cp">#define max(x, y) ({				\</span>
<span class="cp">	typeof(x) _max1 = (x);			\</span>
<span class="cp">	typeof(y) _max2 = (y);			\</span>
<span class="cp">	(void) (&amp;_max1 == &amp;_max2);		\</span>
<span class="cp">	_max1 &gt; _max2 ? _max1 : _max2; })</span>

<span class="cp">#define min3(x, y, z) ({			\</span>
<span class="cp">	typeof(x) _min1 = (x);			\</span>
<span class="cp">	typeof(y) _min2 = (y);			\</span>
<span class="cp">	typeof(z) _min3 = (z);			\</span>
<span class="cp">	(void) (&amp;_min1 == &amp;_min2);		\</span>
<span class="cp">	(void) (&amp;_min1 == &amp;_min3);		\</span>
<span class="cp">	_min1 &lt; _min2 ? (_min1 &lt; _min3 ? _min1 : _min3) : \</span>
<span class="cp">		(_min2 &lt; _min3 ? _min2 : _min3); })</span>

<span class="cp">#define max3(x, y, z) ({			\</span>
<span class="cp">	typeof(x) _max1 = (x);			\</span>
<span class="cp">	typeof(y) _max2 = (y);			\</span>
<span class="cp">	typeof(z) _max3 = (z);			\</span>
<span class="cp">	(void) (&amp;_max1 == &amp;_max2);		\</span>
<span class="cp">	(void) (&amp;_max1 == &amp;_max3);		\</span>
<span class="cp">	_max1 &gt; _max2 ? (_max1 &gt; _max3 ? _max1 : _max3) : \</span>
<span class="cp">		(_max2 &gt; _max3 ? _max2 : _max3); })</span>

<span class="cm">/**</span>
<span class="cm"> * min_not_zero - return the minimum that is _not_ zero, unless both are zero</span>
<span class="cm"> * @x: value1</span>
<span class="cm"> * @y: value2</span>
<span class="cm"> */</span>
<span class="cp">#define min_not_zero(x, y) ({			\</span>
<span class="cp">	typeof(x) __x = (x);			\</span>
<span class="cp">	typeof(y) __y = (y);			\</span>
<span class="cp">	__x == 0 ? __y : ((__y == 0) ? __x : min(__x, __y)); })</span>

<span class="cm">/**</span>
<span class="cm"> * clamp - return a value clamped to a given range with strict typechecking</span>
<span class="cm"> * @val: current value</span>
<span class="cm"> * @min: minimum allowable value</span>
<span class="cm"> * @max: maximum allowable value</span>
<span class="cm"> *</span>
<span class="cm"> * This macro does strict typechecking of min/max to make sure they are of the</span>
<span class="cm"> * same type as val.  See the unnecessary pointer comparisons.</span>
<span class="cm"> */</span>
<span class="cp">#define clamp(val, min, max) ({			\</span>
<span class="cp">	typeof(val) __val = (val);		\</span>
<span class="cp">	typeof(min) __min = (min);		\</span>
<span class="cp">	typeof(max) __max = (max);		\</span>
<span class="cp">	(void) (&amp;__val == &amp;__min);		\</span>
<span class="cp">	(void) (&amp;__val == &amp;__max);		\</span>
<span class="cp">	__val = __val &lt; __min ? __min: __val;	\</span>
<span class="cp">	__val &gt; __max ? __max: __val; })</span>

<span class="cm">/*</span>
<span class="cm"> * ..and if you can&#39;t take the strict</span>
<span class="cm"> * types, you can specify one yourself.</span>
<span class="cm"> *</span>
<span class="cm"> * Or not use min/max/clamp at all, of course.</span>
<span class="cm"> */</span>
<span class="cp">#define min_t(type, x, y) ({			\</span>
<span class="cp">	type __min1 = (x);			\</span>
<span class="cp">	type __min2 = (y);			\</span>
<span class="cp">	__min1 &lt; __min2 ? __min1: __min2; })</span>

<span class="cp">#define max_t(type, x, y) ({			\</span>
<span class="cp">	type __max1 = (x);			\</span>
<span class="cp">	type __max2 = (y);			\</span>
<span class="cp">	__max1 &gt; __max2 ? __max1: __max2; })</span>

<span class="cm">/**</span>
<span class="cm"> * clamp_t - return a value clamped to a given range using a given type</span>
<span class="cm"> * @type: the type of variable to use</span>
<span class="cm"> * @val: current value</span>
<span class="cm"> * @min: minimum allowable value</span>
<span class="cm"> * @max: maximum allowable value</span>
<span class="cm"> *</span>
<span class="cm"> * This macro does no typechecking and uses temporary variables of type</span>
<span class="cm"> * &#39;type&#39; to make all the comparisons.</span>
<span class="cm"> */</span>
<span class="cp">#define clamp_t(type, val, min, max) ({		\</span>
<span class="cp">	type __val = (val);			\</span>
<span class="cp">	type __min = (min);			\</span>
<span class="cp">	type __max = (max);			\</span>
<span class="cp">	__val = __val &lt; __min ? __min: __val;	\</span>
<span class="cp">	__val &gt; __max ? __max: __val; })</span>

<span class="cm">/**</span>
<span class="cm"> * clamp_val - return a value clamped to a given range using val&#39;s type</span>
<span class="cm"> * @val: current value</span>
<span class="cm"> * @min: minimum allowable value</span>
<span class="cm"> * @max: maximum allowable value</span>
<span class="cm"> *</span>
<span class="cm"> * This macro does no typechecking and uses temporary variables of whatever</span>
<span class="cm"> * type the input argument &#39;val&#39; is.  This is useful when val is an unsigned</span>
<span class="cm"> * type and min and max are literals that will otherwise be assigned a signed</span>
<span class="cm"> * integer type.</span>
<span class="cm"> */</span>
<span class="cp">#define clamp_val(val, min, max) ({		\</span>
<span class="cp">	typeof(val) __val = (val);		\</span>
<span class="cp">	typeof(val) __min = (min);		\</span>
<span class="cp">	typeof(val) __max = (max);		\</span>
<span class="cp">	__val = __val &lt; __min ? __min: __val;	\</span>
<span class="cp">	__val &gt; __max ? __max: __val; })</span>


<span class="cm">/*</span>
<span class="cm"> * swap - swap value of @a and @b</span>
<span class="cm"> */</span>
<span class="cp">#define swap(a, b) \</span>
<span class="cp">	do { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)</span>

<span class="cm">/**</span>
<span class="cm"> * container_of - cast a member of a structure out to the containing structure</span>
<span class="cm"> * @ptr:	the pointer to the member.</span>
<span class="cm"> * @type:	the type of the container struct this is embedded in.</span>
<span class="cm"> * @member:	the name of the member within the struct.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define container_of(ptr, type, member) ({			\</span>
<span class="cp">	const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);	\</span>
<span class="cp">	(type *)( (char *)__mptr - offsetof(type,member) );})</span>

<span class="cm">/* Trap pasters of __FUNCTION__ at compile-time */</span>
<span class="cp">#define __FUNCTION__ (__func__)</span>

<span class="cm">/* This helps us to avoid #ifdef CONFIG_NUMA */</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="cp">#define NUMA_BUILD 1</span>
<span class="cp">#else</span>
<span class="cp">#define NUMA_BUILD 0</span>
<span class="cp">#endif</span>

<span class="cm">/* This helps us avoid #ifdef CONFIG_COMPACTION */</span>
<span class="cp">#ifdef CONFIG_COMPACTION</span>
<span class="cp">#define COMPACTION_BUILD 1</span>
<span class="cp">#else</span>
<span class="cp">#define COMPACTION_BUILD 0</span>
<span class="cp">#endif</span>

<span class="cm">/* Rebuild everything on CONFIG_FTRACE_MCOUNT_RECORD */</span>
<span class="cp">#ifdef CONFIG_FTRACE_MCOUNT_RECORD</span>
<span class="cp"># define REBUILD_DUE_TO_FTRACE_MCOUNT_RECORD</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_sysinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">sysinfo</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
