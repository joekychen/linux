<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › elf.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>elf.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_ELF_H</span>
<span class="cp">#define _LINUX_ELF_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/elf-em.h&gt;</span>
<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;asm/elf.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/* 32-bit ELF base types. */</span>
<span class="k">typedef</span> <span class="n">__u32</span>	<span class="n">Elf32_Addr</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__u16</span>	<span class="n">Elf32_Half</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__u32</span>	<span class="n">Elf32_Off</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__s32</span>	<span class="n">Elf32_Sword</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__u32</span>	<span class="n">Elf32_Word</span><span class="p">;</span>

<span class="cm">/* 64-bit ELF base types. */</span>
<span class="k">typedef</span> <span class="n">__u64</span>	<span class="n">Elf64_Addr</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__u16</span>	<span class="n">Elf64_Half</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__s16</span>	<span class="n">Elf64_SHalf</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__u64</span>	<span class="n">Elf64_Off</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__s32</span>	<span class="n">Elf64_Sword</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__u32</span>	<span class="n">Elf64_Word</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__u64</span>	<span class="n">Elf64_Xword</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__s64</span>	<span class="n">Elf64_Sxword</span><span class="p">;</span>

<span class="cm">/* These constants are for the segment types stored in the image headers */</span>
<span class="cp">#define PT_NULL    0</span>
<span class="cp">#define PT_LOAD    1</span>
<span class="cp">#define PT_DYNAMIC 2</span>
<span class="cp">#define PT_INTERP  3</span>
<span class="cp">#define PT_NOTE    4</span>
<span class="cp">#define PT_SHLIB   5</span>
<span class="cp">#define PT_PHDR    6</span>
<span class="cp">#define PT_TLS     7               </span><span class="cm">/* Thread local storage segment */</span><span class="cp"></span>
<span class="cp">#define PT_LOOS    0x60000000      </span><span class="cm">/* OS-specific */</span><span class="cp"></span>
<span class="cp">#define PT_HIOS    0x6fffffff      </span><span class="cm">/* OS-specific */</span><span class="cp"></span>
<span class="cp">#define PT_LOPROC  0x70000000</span>
<span class="cp">#define PT_HIPROC  0x7fffffff</span>
<span class="cp">#define PT_GNU_EH_FRAME		0x6474e550</span>

<span class="cp">#define PT_GNU_STACK	(PT_LOOS + 0x474e551)</span>

<span class="cm">/*</span>
<span class="cm"> * Extended Numbering</span>
<span class="cm"> *</span>
<span class="cm"> * If the real number of program header table entries is larger than</span>
<span class="cm"> * or equal to PN_XNUM(0xffff), it is set to sh_info field of the</span>
<span class="cm"> * section header at index 0, and PN_XNUM is set to e_phnum</span>
<span class="cm"> * field. Otherwise, the section header at index 0 is zero</span>
<span class="cm"> * initialized, if it exists.</span>
<span class="cm"> *</span>
<span class="cm"> * Specifications are available in:</span>
<span class="cm"> *</span>
<span class="cm"> * - Sun microsystems: Linker and Libraries.</span>
<span class="cm"> *   Part No: 817-1984-17, September 2008.</span>
<span class="cm"> *   URL: http://docs.sun.com/app/docs/doc/817-1984</span>
<span class="cm"> *</span>
<span class="cm"> * - System V ABI AMD64 Architecture Processor Supplement</span>
<span class="cm"> *   Draft Version 0.99.,</span>
<span class="cm"> *   May 11, 2009.</span>
<span class="cm"> *   URL: http://www.x86-64.org/</span>
<span class="cm"> */</span>
<span class="cp">#define PN_XNUM 0xffff</span>

<span class="cm">/* These constants define the different elf file types */</span>
<span class="cp">#define ET_NONE   0</span>
<span class="cp">#define ET_REL    1</span>
<span class="cp">#define ET_EXEC   2</span>
<span class="cp">#define ET_DYN    3</span>
<span class="cp">#define ET_CORE   4</span>
<span class="cp">#define ET_LOPROC 0xff00</span>
<span class="cp">#define ET_HIPROC 0xffff</span>

<span class="cm">/* This is the info that is needed to parse the dynamic section of the file */</span>
<span class="cp">#define DT_NULL		0</span>
<span class="cp">#define DT_NEEDED	1</span>
<span class="cp">#define DT_PLTRELSZ	2</span>
<span class="cp">#define DT_PLTGOT	3</span>
<span class="cp">#define DT_HASH		4</span>
<span class="cp">#define DT_STRTAB	5</span>
<span class="cp">#define DT_SYMTAB	6</span>
<span class="cp">#define DT_RELA		7</span>
<span class="cp">#define DT_RELASZ	8</span>
<span class="cp">#define DT_RELAENT	9</span>
<span class="cp">#define DT_STRSZ	10</span>
<span class="cp">#define DT_SYMENT	11</span>
<span class="cp">#define DT_INIT		12</span>
<span class="cp">#define DT_FINI		13</span>
<span class="cp">#define DT_SONAME	14</span>
<span class="cp">#define DT_RPATH 	15</span>
<span class="cp">#define DT_SYMBOLIC	16</span>
<span class="cp">#define DT_REL	        17</span>
<span class="cp">#define DT_RELSZ	18</span>
<span class="cp">#define DT_RELENT	19</span>
<span class="cp">#define DT_PLTREL	20</span>
<span class="cp">#define DT_DEBUG	21</span>
<span class="cp">#define DT_TEXTREL	22</span>
<span class="cp">#define DT_JMPREL	23</span>
<span class="cp">#define DT_ENCODING	32</span>
<span class="cp">#define OLD_DT_LOOS	0x60000000</span>
<span class="cp">#define DT_LOOS		0x6000000d</span>
<span class="cp">#define DT_HIOS		0x6ffff000</span>
<span class="cp">#define DT_VALRNGLO	0x6ffffd00</span>
<span class="cp">#define DT_VALRNGHI	0x6ffffdff</span>
<span class="cp">#define DT_ADDRRNGLO	0x6ffffe00</span>
<span class="cp">#define DT_ADDRRNGHI	0x6ffffeff</span>
<span class="cp">#define DT_VERSYM	0x6ffffff0</span>
<span class="cp">#define DT_RELACOUNT	0x6ffffff9</span>
<span class="cp">#define DT_RELCOUNT	0x6ffffffa</span>
<span class="cp">#define DT_FLAGS_1	0x6ffffffb</span>
<span class="cp">#define DT_VERDEF	0x6ffffffc</span>
<span class="cp">#define	DT_VERDEFNUM	0x6ffffffd</span>
<span class="cp">#define DT_VERNEED	0x6ffffffe</span>
<span class="cp">#define	DT_VERNEEDNUM	0x6fffffff</span>
<span class="cp">#define OLD_DT_HIOS     0x6fffffff</span>
<span class="cp">#define DT_LOPROC	0x70000000</span>
<span class="cp">#define DT_HIPROC	0x7fffffff</span>

<span class="cm">/* This info is needed when parsing the symbol table */</span>
<span class="cp">#define STB_LOCAL  0</span>
<span class="cp">#define STB_GLOBAL 1</span>
<span class="cp">#define STB_WEAK   2</span>

<span class="cp">#define STT_NOTYPE  0</span>
<span class="cp">#define STT_OBJECT  1</span>
<span class="cp">#define STT_FUNC    2</span>
<span class="cp">#define STT_SECTION 3</span>
<span class="cp">#define STT_FILE    4</span>
<span class="cp">#define STT_COMMON  5</span>
<span class="cp">#define STT_TLS     6</span>

<span class="cp">#define ELF_ST_BIND(x)		((x) &gt;&gt; 4)</span>
<span class="cp">#define ELF_ST_TYPE(x)		(((unsigned int) x) &amp; 0xf)</span>
<span class="cp">#define ELF32_ST_BIND(x)	ELF_ST_BIND(x)</span>
<span class="cp">#define ELF32_ST_TYPE(x)	ELF_ST_TYPE(x)</span>
<span class="cp">#define ELF64_ST_BIND(x)	ELF_ST_BIND(x)</span>
<span class="cp">#define ELF64_ST_TYPE(x)	ELF_ST_TYPE(x)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dynamic</span><span class="p">{</span>
  <span class="n">Elf32_Sword</span> <span class="n">d_tag</span><span class="p">;</span>
  <span class="k">union</span><span class="p">{</span>
    <span class="n">Elf32_Sword</span>	<span class="n">d_val</span><span class="p">;</span>
    <span class="n">Elf32_Addr</span>	<span class="n">d_ptr</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">d_un</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Elf32_Dyn</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Elf64_Sxword</span> <span class="n">d_tag</span><span class="p">;</span>		<span class="cm">/* entry tag value */</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="n">Elf64_Xword</span> <span class="n">d_val</span><span class="p">;</span>
    <span class="n">Elf64_Addr</span> <span class="n">d_ptr</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">d_un</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Elf64_Dyn</span><span class="p">;</span>

<span class="cm">/* The following are used with relocations */</span>
<span class="cp">#define ELF32_R_SYM(x) ((x) &gt;&gt; 8)</span>
<span class="cp">#define ELF32_R_TYPE(x) ((x) &amp; 0xff)</span>

<span class="cp">#define ELF64_R_SYM(i)			((i) &gt;&gt; 32)</span>
<span class="cp">#define ELF64_R_TYPE(i)			((i) &amp; 0xffffffff)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">elf32_rel</span> <span class="p">{</span>
  <span class="n">Elf32_Addr</span>	<span class="n">r_offset</span><span class="p">;</span>
  <span class="n">Elf32_Word</span>	<span class="n">r_info</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Elf32_Rel</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">elf64_rel</span> <span class="p">{</span>
  <span class="n">Elf64_Addr</span> <span class="n">r_offset</span><span class="p">;</span>	<span class="cm">/* Location at which to apply the action */</span>
  <span class="n">Elf64_Xword</span> <span class="n">r_info</span><span class="p">;</span>	<span class="cm">/* index and type of relocation */</span>
<span class="p">}</span> <span class="n">Elf64_Rel</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">elf32_rela</span><span class="p">{</span>
  <span class="n">Elf32_Addr</span>	<span class="n">r_offset</span><span class="p">;</span>
  <span class="n">Elf32_Word</span>	<span class="n">r_info</span><span class="p">;</span>
  <span class="n">Elf32_Sword</span>	<span class="n">r_addend</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Elf32_Rela</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">elf64_rela</span> <span class="p">{</span>
  <span class="n">Elf64_Addr</span> <span class="n">r_offset</span><span class="p">;</span>	<span class="cm">/* Location at which to apply the action */</span>
  <span class="n">Elf64_Xword</span> <span class="n">r_info</span><span class="p">;</span>	<span class="cm">/* index and type of relocation */</span>
  <span class="n">Elf64_Sxword</span> <span class="n">r_addend</span><span class="p">;</span>	<span class="cm">/* Constant addend used to compute value */</span>
<span class="p">}</span> <span class="n">Elf64_Rela</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">elf32_sym</span><span class="p">{</span>
  <span class="n">Elf32_Word</span>	<span class="n">st_name</span><span class="p">;</span>
  <span class="n">Elf32_Addr</span>	<span class="n">st_value</span><span class="p">;</span>
  <span class="n">Elf32_Word</span>	<span class="n">st_size</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">st_info</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">st_other</span><span class="p">;</span>
  <span class="n">Elf32_Half</span>	<span class="n">st_shndx</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Elf32_Sym</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">elf64_sym</span> <span class="p">{</span>
  <span class="n">Elf64_Word</span> <span class="n">st_name</span><span class="p">;</span>		<span class="cm">/* Symbol name, index in string tbl */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">st_info</span><span class="p">;</span>	<span class="cm">/* Type and binding attributes */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">st_other</span><span class="p">;</span>	<span class="cm">/* No defined meaning, 0 */</span>
  <span class="n">Elf64_Half</span> <span class="n">st_shndx</span><span class="p">;</span>		<span class="cm">/* Associated section index */</span>
  <span class="n">Elf64_Addr</span> <span class="n">st_value</span><span class="p">;</span>		<span class="cm">/* Value of the symbol */</span>
  <span class="n">Elf64_Xword</span> <span class="n">st_size</span><span class="p">;</span>		<span class="cm">/* Associated symbol size */</span>
<span class="p">}</span> <span class="n">Elf64_Sym</span><span class="p">;</span>


<span class="cp">#define EI_NIDENT	16</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">elf32_hdr</span><span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">e_ident</span><span class="p">[</span><span class="n">EI_NIDENT</span><span class="p">];</span>
  <span class="n">Elf32_Half</span>	<span class="n">e_type</span><span class="p">;</span>
  <span class="n">Elf32_Half</span>	<span class="n">e_machine</span><span class="p">;</span>
  <span class="n">Elf32_Word</span>	<span class="n">e_version</span><span class="p">;</span>
  <span class="n">Elf32_Addr</span>	<span class="n">e_entry</span><span class="p">;</span>  <span class="cm">/* Entry point */</span>
  <span class="n">Elf32_Off</span>	<span class="n">e_phoff</span><span class="p">;</span>
  <span class="n">Elf32_Off</span>	<span class="n">e_shoff</span><span class="p">;</span>
  <span class="n">Elf32_Word</span>	<span class="n">e_flags</span><span class="p">;</span>
  <span class="n">Elf32_Half</span>	<span class="n">e_ehsize</span><span class="p">;</span>
  <span class="n">Elf32_Half</span>	<span class="n">e_phentsize</span><span class="p">;</span>
  <span class="n">Elf32_Half</span>	<span class="n">e_phnum</span><span class="p">;</span>
  <span class="n">Elf32_Half</span>	<span class="n">e_shentsize</span><span class="p">;</span>
  <span class="n">Elf32_Half</span>	<span class="n">e_shnum</span><span class="p">;</span>
  <span class="n">Elf32_Half</span>	<span class="n">e_shstrndx</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Elf32_Ehdr</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">elf64_hdr</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">e_ident</span><span class="p">[</span><span class="n">EI_NIDENT</span><span class="p">];</span>	<span class="cm">/* ELF &quot;magic number&quot; */</span>
  <span class="n">Elf64_Half</span> <span class="n">e_type</span><span class="p">;</span>
  <span class="n">Elf64_Half</span> <span class="n">e_machine</span><span class="p">;</span>
  <span class="n">Elf64_Word</span> <span class="n">e_version</span><span class="p">;</span>
  <span class="n">Elf64_Addr</span> <span class="n">e_entry</span><span class="p">;</span>		<span class="cm">/* Entry point virtual address */</span>
  <span class="n">Elf64_Off</span> <span class="n">e_phoff</span><span class="p">;</span>		<span class="cm">/* Program header table file offset */</span>
  <span class="n">Elf64_Off</span> <span class="n">e_shoff</span><span class="p">;</span>		<span class="cm">/* Section header table file offset */</span>
  <span class="n">Elf64_Word</span> <span class="n">e_flags</span><span class="p">;</span>
  <span class="n">Elf64_Half</span> <span class="n">e_ehsize</span><span class="p">;</span>
  <span class="n">Elf64_Half</span> <span class="n">e_phentsize</span><span class="p">;</span>
  <span class="n">Elf64_Half</span> <span class="n">e_phnum</span><span class="p">;</span>
  <span class="n">Elf64_Half</span> <span class="n">e_shentsize</span><span class="p">;</span>
  <span class="n">Elf64_Half</span> <span class="n">e_shnum</span><span class="p">;</span>
  <span class="n">Elf64_Half</span> <span class="n">e_shstrndx</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Elf64_Ehdr</span><span class="p">;</span>

<span class="cm">/* These constants define the permissions on sections in the program</span>
<span class="cm">   header, p_flags. */</span>
<span class="cp">#define PF_R		0x4</span>
<span class="cp">#define PF_W		0x2</span>
<span class="cp">#define PF_X		0x1</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">elf32_phdr</span><span class="p">{</span>
  <span class="n">Elf32_Word</span>	<span class="n">p_type</span><span class="p">;</span>
  <span class="n">Elf32_Off</span>	<span class="n">p_offset</span><span class="p">;</span>
  <span class="n">Elf32_Addr</span>	<span class="n">p_vaddr</span><span class="p">;</span>
  <span class="n">Elf32_Addr</span>	<span class="n">p_paddr</span><span class="p">;</span>
  <span class="n">Elf32_Word</span>	<span class="n">p_filesz</span><span class="p">;</span>
  <span class="n">Elf32_Word</span>	<span class="n">p_memsz</span><span class="p">;</span>
  <span class="n">Elf32_Word</span>	<span class="n">p_flags</span><span class="p">;</span>
  <span class="n">Elf32_Word</span>	<span class="n">p_align</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Elf32_Phdr</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">elf64_phdr</span> <span class="p">{</span>
  <span class="n">Elf64_Word</span> <span class="n">p_type</span><span class="p">;</span>
  <span class="n">Elf64_Word</span> <span class="n">p_flags</span><span class="p">;</span>
  <span class="n">Elf64_Off</span> <span class="n">p_offset</span><span class="p">;</span>		<span class="cm">/* Segment file offset */</span>
  <span class="n">Elf64_Addr</span> <span class="n">p_vaddr</span><span class="p">;</span>		<span class="cm">/* Segment virtual address */</span>
  <span class="n">Elf64_Addr</span> <span class="n">p_paddr</span><span class="p">;</span>		<span class="cm">/* Segment physical address */</span>
  <span class="n">Elf64_Xword</span> <span class="n">p_filesz</span><span class="p">;</span>		<span class="cm">/* Segment size in file */</span>
  <span class="n">Elf64_Xword</span> <span class="n">p_memsz</span><span class="p">;</span>		<span class="cm">/* Segment size in memory */</span>
  <span class="n">Elf64_Xword</span> <span class="n">p_align</span><span class="p">;</span>		<span class="cm">/* Segment alignment, file &amp; memory */</span>
<span class="p">}</span> <span class="n">Elf64_Phdr</span><span class="p">;</span>

<span class="cm">/* sh_type */</span>
<span class="cp">#define SHT_NULL	0</span>
<span class="cp">#define SHT_PROGBITS	1</span>
<span class="cp">#define SHT_SYMTAB	2</span>
<span class="cp">#define SHT_STRTAB	3</span>
<span class="cp">#define SHT_RELA	4</span>
<span class="cp">#define SHT_HASH	5</span>
<span class="cp">#define SHT_DYNAMIC	6</span>
<span class="cp">#define SHT_NOTE	7</span>
<span class="cp">#define SHT_NOBITS	8</span>
<span class="cp">#define SHT_REL		9</span>
<span class="cp">#define SHT_SHLIB	10</span>
<span class="cp">#define SHT_DYNSYM	11</span>
<span class="cp">#define SHT_NUM		12</span>
<span class="cp">#define SHT_LOPROC	0x70000000</span>
<span class="cp">#define SHT_HIPROC	0x7fffffff</span>
<span class="cp">#define SHT_LOUSER	0x80000000</span>
<span class="cp">#define SHT_HIUSER	0xffffffff</span>

<span class="cm">/* sh_flags */</span>
<span class="cp">#define SHF_WRITE	0x1</span>
<span class="cp">#define SHF_ALLOC	0x2</span>
<span class="cp">#define SHF_EXECINSTR	0x4</span>
<span class="cp">#define SHF_MASKPROC	0xf0000000</span>

<span class="cm">/* special section indexes */</span>
<span class="cp">#define SHN_UNDEF	0</span>
<span class="cp">#define SHN_LORESERVE	0xff00</span>
<span class="cp">#define SHN_LOPROC	0xff00</span>
<span class="cp">#define SHN_HIPROC	0xff1f</span>
<span class="cp">#define SHN_ABS		0xfff1</span>
<span class="cp">#define SHN_COMMON	0xfff2</span>
<span class="cp">#define SHN_HIRESERVE	0xffff</span>
 
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">elf32_shdr</span> <span class="p">{</span>
  <span class="n">Elf32_Word</span>	<span class="n">sh_name</span><span class="p">;</span>
  <span class="n">Elf32_Word</span>	<span class="n">sh_type</span><span class="p">;</span>
  <span class="n">Elf32_Word</span>	<span class="n">sh_flags</span><span class="p">;</span>
  <span class="n">Elf32_Addr</span>	<span class="n">sh_addr</span><span class="p">;</span>
  <span class="n">Elf32_Off</span>	<span class="n">sh_offset</span><span class="p">;</span>
  <span class="n">Elf32_Word</span>	<span class="n">sh_size</span><span class="p">;</span>
  <span class="n">Elf32_Word</span>	<span class="n">sh_link</span><span class="p">;</span>
  <span class="n">Elf32_Word</span>	<span class="n">sh_info</span><span class="p">;</span>
  <span class="n">Elf32_Word</span>	<span class="n">sh_addralign</span><span class="p">;</span>
  <span class="n">Elf32_Word</span>	<span class="n">sh_entsize</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Elf32_Shdr</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">elf64_shdr</span> <span class="p">{</span>
  <span class="n">Elf64_Word</span> <span class="n">sh_name</span><span class="p">;</span>		<span class="cm">/* Section name, index in string tbl */</span>
  <span class="n">Elf64_Word</span> <span class="n">sh_type</span><span class="p">;</span>		<span class="cm">/* Type of section */</span>
  <span class="n">Elf64_Xword</span> <span class="n">sh_flags</span><span class="p">;</span>		<span class="cm">/* Miscellaneous section attributes */</span>
  <span class="n">Elf64_Addr</span> <span class="n">sh_addr</span><span class="p">;</span>		<span class="cm">/* Section virtual addr at execution */</span>
  <span class="n">Elf64_Off</span> <span class="n">sh_offset</span><span class="p">;</span>		<span class="cm">/* Section file offset */</span>
  <span class="n">Elf64_Xword</span> <span class="n">sh_size</span><span class="p">;</span>		<span class="cm">/* Size of section in bytes */</span>
  <span class="n">Elf64_Word</span> <span class="n">sh_link</span><span class="p">;</span>		<span class="cm">/* Index of another section */</span>
  <span class="n">Elf64_Word</span> <span class="n">sh_info</span><span class="p">;</span>		<span class="cm">/* Additional section information */</span>
  <span class="n">Elf64_Xword</span> <span class="n">sh_addralign</span><span class="p">;</span>	<span class="cm">/* Section alignment */</span>
  <span class="n">Elf64_Xword</span> <span class="n">sh_entsize</span><span class="p">;</span>	<span class="cm">/* Entry size if section holds table */</span>
<span class="p">}</span> <span class="n">Elf64_Shdr</span><span class="p">;</span>

<span class="cp">#define	EI_MAG0		0		</span><span class="cm">/* e_ident[] indexes */</span><span class="cp"></span>
<span class="cp">#define	EI_MAG1		1</span>
<span class="cp">#define	EI_MAG2		2</span>
<span class="cp">#define	EI_MAG3		3</span>
<span class="cp">#define	EI_CLASS	4</span>
<span class="cp">#define	EI_DATA		5</span>
<span class="cp">#define	EI_VERSION	6</span>
<span class="cp">#define	EI_OSABI	7</span>
<span class="cp">#define	EI_PAD		8</span>

<span class="cp">#define	ELFMAG0		0x7f		</span><span class="cm">/* EI_MAG */</span><span class="cp"></span>
<span class="cp">#define	ELFMAG1		&#39;E&#39;</span>
<span class="cp">#define	ELFMAG2		&#39;L&#39;</span>
<span class="cp">#define	ELFMAG3		&#39;F&#39;</span>
<span class="cp">#define	ELFMAG		&quot;\177ELF&quot;</span>
<span class="cp">#define	SELFMAG		4</span>

<span class="cp">#define	ELFCLASSNONE	0		</span><span class="cm">/* EI_CLASS */</span><span class="cp"></span>
<span class="cp">#define	ELFCLASS32	1</span>
<span class="cp">#define	ELFCLASS64	2</span>
<span class="cp">#define	ELFCLASSNUM	3</span>

<span class="cp">#define ELFDATANONE	0		</span><span class="cm">/* e_ident[EI_DATA] */</span><span class="cp"></span>
<span class="cp">#define ELFDATA2LSB	1</span>
<span class="cp">#define ELFDATA2MSB	2</span>

<span class="cp">#define EV_NONE		0		</span><span class="cm">/* e_version, EI_VERSION */</span><span class="cp"></span>
<span class="cp">#define EV_CURRENT	1</span>
<span class="cp">#define EV_NUM		2</span>

<span class="cp">#define ELFOSABI_NONE	0</span>
<span class="cp">#define ELFOSABI_LINUX	3</span>

<span class="cp">#ifndef ELF_OSABI</span>
<span class="cp">#define ELF_OSABI ELFOSABI_NONE</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Notes used in ET_CORE. Architectures export some of the arch register sets</span>
<span class="cm"> * using the corresponding note types via the PTRACE_GETREGSET and</span>
<span class="cm"> * PTRACE_SETREGSET requests.</span>
<span class="cm"> */</span>
<span class="cp">#define NT_PRSTATUS	1</span>
<span class="cp">#define NT_PRFPREG	2</span>
<span class="cp">#define NT_PRPSINFO	3</span>
<span class="cp">#define NT_TASKSTRUCT	4</span>
<span class="cp">#define NT_AUXV		6</span>
<span class="cp">#define NT_PRXFPREG     0x46e62b7f      </span><span class="cm">/* copied from gdb5.1/include/elf/common.h */</span><span class="cp"></span>
<span class="cp">#define NT_PPC_VMX	0x100		</span><span class="cm">/* PowerPC Altivec/VMX registers */</span><span class="cp"></span>
<span class="cp">#define NT_PPC_SPE	0x101		</span><span class="cm">/* PowerPC SPE/EVR registers */</span><span class="cp"></span>
<span class="cp">#define NT_PPC_VSX	0x102		</span><span class="cm">/* PowerPC VSX registers */</span><span class="cp"></span>
<span class="cp">#define NT_386_TLS	0x200		</span><span class="cm">/* i386 TLS slots (struct user_desc) */</span><span class="cp"></span>
<span class="cp">#define NT_386_IOPERM	0x201		</span><span class="cm">/* x86 io permission bitmap (1=deny) */</span><span class="cp"></span>
<span class="cp">#define NT_X86_XSTATE	0x202		</span><span class="cm">/* x86 extended state using xsave */</span><span class="cp"></span>
<span class="cp">#define NT_S390_HIGH_GPRS	0x300	</span><span class="cm">/* s390 upper register halves */</span><span class="cp"></span>
<span class="cp">#define NT_S390_TIMER	0x301		</span><span class="cm">/* s390 timer register */</span><span class="cp"></span>
<span class="cp">#define NT_S390_TODCMP	0x302		</span><span class="cm">/* s390 TOD clock comparator register */</span><span class="cp"></span>
<span class="cp">#define NT_S390_TODPREG	0x303		</span><span class="cm">/* s390 TOD programmable register */</span><span class="cp"></span>
<span class="cp">#define NT_S390_CTRS	0x304		</span><span class="cm">/* s390 control registers */</span><span class="cp"></span>
<span class="cp">#define NT_S390_PREFIX	0x305		</span><span class="cm">/* s390 prefix register */</span><span class="cp"></span>
<span class="cp">#define NT_S390_LAST_BREAK	0x306	</span><span class="cm">/* s390 breaking event address */</span><span class="cp"></span>
<span class="cp">#define NT_S390_SYSTEM_CALL	0x307	</span><span class="cm">/* s390 system call restart data */</span><span class="cp"></span>
<span class="cp">#define NT_ARM_VFP	0x400		</span><span class="cm">/* ARM VFP/NEON registers */</span><span class="cp"></span>


<span class="cm">/* Note header in a PT_NOTE section */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">elf32_note</span> <span class="p">{</span>
  <span class="n">Elf32_Word</span>	<span class="n">n_namesz</span><span class="p">;</span>	<span class="cm">/* Name size */</span>
  <span class="n">Elf32_Word</span>	<span class="n">n_descsz</span><span class="p">;</span>	<span class="cm">/* Content size */</span>
  <span class="n">Elf32_Word</span>	<span class="n">n_type</span><span class="p">;</span>		<span class="cm">/* Content type */</span>
<span class="p">}</span> <span class="n">Elf32_Nhdr</span><span class="p">;</span>

<span class="cm">/* Note header in a PT_NOTE section */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">elf64_note</span> <span class="p">{</span>
  <span class="n">Elf64_Word</span> <span class="n">n_namesz</span><span class="p">;</span>	<span class="cm">/* Name size */</span>
  <span class="n">Elf64_Word</span> <span class="n">n_descsz</span><span class="p">;</span>	<span class="cm">/* Content size */</span>
  <span class="n">Elf64_Word</span> <span class="n">n_type</span><span class="p">;</span>	<span class="cm">/* Content type */</span>
<span class="p">}</span> <span class="n">Elf64_Nhdr</span><span class="p">;</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#ifndef elf_read_implies_exec</span>
  <span class="cm">/* Executables for which elf_read_implies_exec() returns TRUE will</span>
<span class="cm">     have the READ_IMPLIES_EXEC personality flag set automatically.</span>
<span class="cm">     Override in asm/elf.h as needed.  */</span>
<span class="cp"># define elf_read_implies_exec(ex, have_pt_gnu_stack)	0</span>
<span class="cp">#endif</span>

<span class="cp">#if ELF_CLASS == ELFCLASS32</span>

<span class="k">extern</span> <span class="n">Elf32_Dyn</span> <span class="n">_DYNAMIC</span> <span class="p">[];</span>
<span class="cp">#define elfhdr		elf32_hdr</span>
<span class="cp">#define elf_phdr	elf32_phdr</span>
<span class="cp">#define elf_shdr	elf32_shdr</span>
<span class="cp">#define elf_note	elf32_note</span>
<span class="cp">#define elf_addr_t	Elf32_Off</span>
<span class="cp">#define Elf_Half	Elf32_Half</span>

<span class="cp">#else</span>

<span class="k">extern</span> <span class="n">Elf64_Dyn</span> <span class="n">_DYNAMIC</span> <span class="p">[];</span>
<span class="cp">#define elfhdr		elf64_hdr</span>
<span class="cp">#define elf_phdr	elf64_phdr</span>
<span class="cp">#define elf_shdr	elf64_shdr</span>
<span class="cp">#define elf_note	elf64_note</span>
<span class="cp">#define elf_addr_t	Elf64_Off</span>
<span class="cp">#define Elf_Half	Elf64_Half</span>

<span class="cp">#endif</span>

<span class="cm">/* Optional callbacks to write extra ELF notes. */</span>
<span class="k">struct</span> <span class="n">file</span><span class="p">;</span>

<span class="cp">#ifndef ARCH_HAVE_EXTRA_ELF_NOTES</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">elf_coredump_extra_notes_size</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">elf_coredump_extra_notes_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="o">*</span><span class="n">foffset</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">elf_coredump_extra_notes_size</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">elf_coredump_extra_notes_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">foffset</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _LINUX_ELF_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
