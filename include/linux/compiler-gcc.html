<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › compiler-gcc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>compiler-gcc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __LINUX_COMPILER_H</span>
<span class="cp">#error &quot;Please don&#39;t include &lt;linux/compiler-gcc.h&gt; directly, include &lt;linux/compiler.h&gt; instead.&quot;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Common definitions for all gcc versions go here.</span>
<span class="cm"> */</span>


<span class="cm">/* Optimization barrier */</span>
<span class="cm">/* The &quot;volatile&quot; is due to gcc bugs */</span>
<span class="cp">#define barrier() __asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;)</span>

<span class="cm">/*</span>
<span class="cm"> * This macro obfuscates arithmetic on a variable address so that gcc</span>
<span class="cm"> * shouldn&#39;t recognize the original var, and make assumptions about it.</span>
<span class="cm"> *</span>
<span class="cm"> * This is needed because the C standard makes it undefined to do</span>
<span class="cm"> * pointer arithmetic on &quot;objects&quot; outside their boundaries and the</span>
<span class="cm"> * gcc optimizers assume this is the case. In particular they</span>
<span class="cm"> * assume such arithmetic does not wrap.</span>
<span class="cm"> *</span>
<span class="cm"> * A miscompilation has been observed because of this on PPC.</span>
<span class="cm"> * To work around it we hide the relationship of the pointer and the object</span>
<span class="cm"> * using this macro.</span>
<span class="cm"> *</span>
<span class="cm"> * Versions of the ppc64 compiler before 4.1 had a bug where use of</span>
<span class="cm"> * RELOC_HIDE could trash r30. The bug can be worked around by changing</span>
<span class="cm"> * the inline assembly constraint from =g to =r, in this particular</span>
<span class="cm"> * case either is valid.</span>
<span class="cm"> */</span>
<span class="cp">#define RELOC_HIDE(ptr, off)					\</span>
<span class="cp">  ({ unsigned long __ptr;					\</span>
<span class="cp">    __asm__ (&quot;&quot; : &quot;=r&quot;(__ptr) : &quot;0&quot;(ptr));		\</span>
<span class="cp">    (typeof(ptr)) (__ptr + (off)); })</span>

<span class="cp">#ifdef __CHECKER__</span>
<span class="cp">#define __must_be_array(arr) 0</span>
<span class="cp">#else</span>
<span class="cm">/* &amp;a[0] degrades to a pointer: a different type from an array */</span>
<span class="cp">#define __must_be_array(a) BUILD_BUG_ON_ZERO(__same_type((a), &amp;(a)[0]))</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Force always-inline if the user requests it so via the .config,</span>
<span class="cm"> * or if gcc is too old:</span>
<span class="cm"> */</span>
<span class="cp">#if !defined(CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING) || \</span>
<span class="cp">    !defined(CONFIG_OPTIMIZE_INLINING) || (__GNUC__ &lt; 4)</span>
<span class="cp"># define inline		inline		__attribute__((always_inline)) notrace</span>
<span class="cp"># define __inline__	__inline__	__attribute__((always_inline)) notrace</span>
<span class="cp"># define __inline	__inline	__attribute__((always_inline)) notrace</span>
<span class="cp">#else</span>
<span class="cm">/* A lot of inline functions can cause havoc with function tracing */</span>
<span class="cp"># define inline		inline		notrace</span>
<span class="cp"># define __inline__	__inline__	notrace</span>
<span class="cp"># define __inline	__inline	notrace</span>
<span class="cp">#endif</span>

<span class="cp">#define __deprecated			__attribute__((deprecated))</span>
<span class="cp">#define __packed			__attribute__((packed))</span>
<span class="cp">#define __weak				__attribute__((weak))</span>

<span class="cm">/*</span>
<span class="cm"> * it doesn&#39;t make sense on ARM (currently the only user of __naked) to trace</span>
<span class="cm"> * naked functions because then mcount is called without stack and frame pointer</span>
<span class="cm"> * being set up and there is no chance to restore the lr register to the value</span>
<span class="cm"> * before mcount was called.</span>
<span class="cm"> *</span>
<span class="cm"> * The asm() bodies of naked functions often depend on standard calling conventions,</span>
<span class="cm"> * therefore they must be noinline and noclone.  GCC 4.[56] currently fail to enforce</span>
<span class="cm"> * this, so we must do so ourselves.  See GCC PR44290.</span>
<span class="cm"> */</span>
<span class="cp">#define __naked				__attribute__((naked)) noinline __noclone notrace</span>

<span class="cp">#define __noreturn			__attribute__((noreturn))</span>

<span class="cm">/*</span>
<span class="cm"> * From the GCC manual:</span>
<span class="cm"> *</span>
<span class="cm"> * Many functions have no effects except the return value and their</span>
<span class="cm"> * return value depends only on the parameters and/or global</span>
<span class="cm"> * variables.  Such a function can be subject to common subexpression</span>
<span class="cm"> * elimination and loop optimization just as an arithmetic operator</span>
<span class="cm"> * would be.</span>
<span class="cm"> * [...]</span>
<span class="cm"> */</span>
<span class="cp">#define __pure				__attribute__((pure))</span>
<span class="cp">#define __aligned(x)			__attribute__((aligned(x)))</span>
<span class="cp">#define __printf(a, b)			__attribute__((format(printf, a, b)))</span>
<span class="cp">#define __scanf(a, b)			__attribute__((format(scanf, a, b)))</span>
<span class="cp">#define  noinline			__attribute__((noinline))</span>
<span class="cp">#define __attribute_const__		__attribute__((__const__))</span>
<span class="cp">#define __maybe_unused			__attribute__((unused))</span>
<span class="cp">#define __always_unused			__attribute__((unused))</span>

<span class="cp">#define __gcc_header(x) #x</span>
<span class="cp">#define _gcc_header(x) __gcc_header(linux/compiler-gcc##x.h)</span>
<span class="cp">#define gcc_header(x) _gcc_header(x)</span>
<span class="cp">#include gcc_header(__GNUC__)</span>

<span class="cp">#if !defined(__noclone)</span>
<span class="cp">#define __noclone	</span><span class="cm">/* not needed */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * A trick to suppress uninitialized variable warning without generating any</span>
<span class="cm"> * code</span>
<span class="cm"> */</span>
<span class="cp">#define uninitialized_var(x) x = x</span>

<span class="cp">#define __always_inline		inline __attribute__((always_inline))</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
