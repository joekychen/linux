<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › radix-tree.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>radix-tree.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2001 Momchil Velikov</span>
<span class="cm"> * Portions Copyright (C) 2001 Christoph Hellwig</span>
<span class="cm"> * Copyright (C) 2006 Nick Piggin</span>
<span class="cm"> * Copyright (C) 2012 Konstantin Khlebnikov</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation; either version 2, or (at</span>
<span class="cm"> * your option) any later version.</span>
<span class="cm"> * </span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> * </span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _LINUX_RADIX_TREE_H</span>
<span class="cp">#define _LINUX_RADIX_TREE_H</span>

<span class="cp">#include &lt;linux/preempt.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * An indirect pointer (root-&gt;rnode pointing to a radix_tree_node, rather</span>
<span class="cm"> * than a data item) is signalled by the low bit set in the root-&gt;rnode</span>
<span class="cm"> * pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * In this case root-&gt;height is &gt; 0, but the indirect pointer tests are</span>
<span class="cm"> * needed for RCU lookups (because root-&gt;height is unreliable). The only</span>
<span class="cm"> * time callers need worry about this is when doing a lookup_slot under</span>
<span class="cm"> * RCU.</span>
<span class="cm"> *</span>
<span class="cm"> * Indirect pointer in fact is also used to tag the last pointer of a node</span>
<span class="cm"> * when it is shrunk, before we rcu free the node. See shrink code for</span>
<span class="cm"> * details.</span>
<span class="cm"> */</span>
<span class="cp">#define RADIX_TREE_INDIRECT_PTR		1</span>
<span class="cm">/*</span>
<span class="cm"> * A common use of the radix tree is to store pointers to struct pages;</span>
<span class="cm"> * but shmem/tmpfs needs also to store swap entries in the same tree:</span>
<span class="cm"> * those are marked as exceptional entries to distinguish them.</span>
<span class="cm"> * EXCEPTIONAL_ENTRY tests the bit, EXCEPTIONAL_SHIFT shifts content past it.</span>
<span class="cm"> */</span>
<span class="cp">#define RADIX_TREE_EXCEPTIONAL_ENTRY	2</span>
<span class="cp">#define RADIX_TREE_EXCEPTIONAL_SHIFT	2</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">radix_tree_is_indirect_ptr</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span> <span class="o">&amp;</span> <span class="n">RADIX_TREE_INDIRECT_PTR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*** radix-tree API starts here ***/</span>

<span class="cp">#define RADIX_TREE_MAX_TAGS 3</span>

<span class="cm">/* root tags are stored in gfp_mask, shifted by __GFP_BITS_SHIFT */</span>
<span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">height</span><span class="p">;</span>
	<span class="n">gfp_t</span>			<span class="n">gfp_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">radix_tree_node</span>	<span class="n">__rcu</span> <span class="o">*</span><span class="n">rnode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define RADIX_TREE_INIT(mask)	{					\</span>
<span class="cp">	.height = 0,							\</span>
<span class="cp">	.gfp_mask = (mask),						\</span>
<span class="cp">	.rnode = NULL,							\</span>
<span class="cp">}</span>

<span class="cp">#define RADIX_TREE(name, mask) \</span>
<span class="cp">	struct radix_tree_root name = RADIX_TREE_INIT(mask)</span>

<span class="cp">#define INIT_RADIX_TREE(root, mask)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	(root)-&gt;height = 0;						\</span>
<span class="cp">	(root)-&gt;gfp_mask = (mask);					\</span>
<span class="cp">	(root)-&gt;rnode = NULL;						\</span>
<span class="cp">} while (0)</span>

<span class="cm">/**</span>
<span class="cm"> * Radix-tree synchronization</span>
<span class="cm"> *</span>
<span class="cm"> * The radix-tree API requires that users provide all synchronisation (with</span>
<span class="cm"> * specific exceptions, noted below).</span>
<span class="cm"> *</span>
<span class="cm"> * Synchronization of access to the data items being stored in the tree, and</span>
<span class="cm"> * management of their lifetimes must be completely managed by API users.</span>
<span class="cm"> *</span>
<span class="cm"> * For API usage, in general,</span>
<span class="cm"> * - any function _modifying_ the tree or tags (inserting or deleting</span>
<span class="cm"> *   items, setting or clearing tags) must exclude other modifications, and</span>
<span class="cm"> *   exclude any functions reading the tree.</span>
<span class="cm"> * - any function _reading_ the tree or tags (looking up items or tags,</span>
<span class="cm"> *   gang lookups) must exclude modifications to the tree, but may occur</span>
<span class="cm"> *   concurrently with other readers.</span>
<span class="cm"> *</span>
<span class="cm"> * The notable exceptions to this rule are the following functions:</span>
<span class="cm"> * radix_tree_lookup</span>
<span class="cm"> * radix_tree_lookup_slot</span>
<span class="cm"> * radix_tree_tag_get</span>
<span class="cm"> * radix_tree_gang_lookup</span>
<span class="cm"> * radix_tree_gang_lookup_slot</span>
<span class="cm"> * radix_tree_gang_lookup_tag</span>
<span class="cm"> * radix_tree_gang_lookup_tag_slot</span>
<span class="cm"> * radix_tree_tagged</span>
<span class="cm"> *</span>
<span class="cm"> * The first 7 functions are able to be called locklessly, using RCU. The</span>
<span class="cm"> * caller must ensure calls to these functions are made within rcu_read_lock()</span>
<span class="cm"> * regions. Other readers (lock-free or otherwise) and modifications may be</span>
<span class="cm"> * running concurrently.</span>
<span class="cm"> *</span>
<span class="cm"> * It is still required that the caller manage the synchronization and lifetimes</span>
<span class="cm"> * of the items. So if RCU lock-free lookups are used, typically this would mean</span>
<span class="cm"> * that the items have their own locks, or are amenable to lock-free access; and</span>
<span class="cm"> * that the items are freed by RCU (or only freed after having been deleted from</span>
<span class="cm"> * the radix tree *and* a synchronize_rcu() grace period).</span>
<span class="cm"> *</span>
<span class="cm"> * (Note, rcu_assign_pointer and rcu_dereference are not needed to control</span>
<span class="cm"> * access to data items when inserting into or looking up from the radix tree)</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the value returned by radix_tree_tag_get() may not be relied upon</span>
<span class="cm"> * if only the RCU read lock is held.  Functions to set/clear tags and to</span>
<span class="cm"> * delete nodes running concurrently with it may affect its result such that</span>
<span class="cm"> * two consecutive reads in the same locked section may return different</span>
<span class="cm"> * values.  If reliability is required, modification functions must also be</span>
<span class="cm"> * excluded from concurrency.</span>
<span class="cm"> *</span>
<span class="cm"> * radix_tree_tagged is able to be called without locking or RCU.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * radix_tree_deref_slot	- dereference a slot</span>
<span class="cm"> * @pslot:	pointer to slot, returned by radix_tree_lookup_slot</span>
<span class="cm"> * Returns:	item that was stored in that slot with any direct pointer flag</span>
<span class="cm"> *		removed.</span>
<span class="cm"> *</span>
<span class="cm"> * For use with radix_tree_lookup_slot().  Caller must hold tree at least read</span>
<span class="cm"> * locked across slot lookup and dereference. Not required if write lock is</span>
<span class="cm"> * held (ie. items cannot be concurrently inserted).</span>
<span class="cm"> *</span>
<span class="cm"> * radix_tree_deref_retry must be used to confirm validity of the pointer if</span>
<span class="cm"> * only the read lock is held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">radix_tree_deref_slot</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">pslot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="o">*</span><span class="n">pslot</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * radix_tree_deref_slot_protected	- dereference a slot without RCU lock but with tree lock held</span>
<span class="cm"> * @pslot:	pointer to slot, returned by radix_tree_lookup_slot</span>
<span class="cm"> * Returns:	item that was stored in that slot with any direct pointer flag</span>
<span class="cm"> *		removed.</span>
<span class="cm"> *</span>
<span class="cm"> * Similar to radix_tree_deref_slot but only used during migration when a pages</span>
<span class="cm"> * mapping is being moved. The caller does not hold the RCU read lock but it</span>
<span class="cm"> * must hold the tree lock to prevent parallel updates.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">radix_tree_deref_slot_protected</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">pslot</span><span class="p">,</span>
							<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">treelock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="o">*</span><span class="n">pslot</span><span class="p">,</span> <span class="n">lockdep_is_held</span><span class="p">(</span><span class="n">treelock</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * radix_tree_deref_retry	- check radix_tree_deref_slot</span>
<span class="cm"> * @arg:	pointer returned by radix_tree_deref_slot</span>
<span class="cm"> * Returns:	0 if retry is not required, otherwise retry is required</span>
<span class="cm"> *</span>
<span class="cm"> * radix_tree_deref_retry must be used with radix_tree_deref_slot.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">radix_tree_deref_retry</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">unlikely</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">RADIX_TREE_INDIRECT_PTR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * radix_tree_exceptional_entry	- radix_tree_deref_slot gave exceptional entry?</span>
<span class="cm"> * @arg:	value returned by radix_tree_deref_slot</span>
<span class="cm"> * Returns:	0 if well-aligned pointer, non-0 if exceptional entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">radix_tree_exceptional_entry</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Not unlikely because radix_tree_exception often tested first */</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">RADIX_TREE_EXCEPTIONAL_ENTRY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * radix_tree_exception	- radix_tree_deref_slot returned either exception?</span>
<span class="cm"> * @arg:	value returned by radix_tree_deref_slot</span>
<span class="cm"> * Returns:	0 if well-aligned pointer, non-0 if either kind of exception.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">radix_tree_exception</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">unlikely</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">arg</span> <span class="o">&amp;</span>
		<span class="p">(</span><span class="n">RADIX_TREE_INDIRECT_PTR</span> <span class="o">|</span> <span class="n">RADIX_TREE_EXCEPTIONAL_ENTRY</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * radix_tree_replace_slot	- replace item in a slot</span>
<span class="cm"> * @pslot:	pointer to slot, returned by radix_tree_lookup_slot</span>
<span class="cm"> * @item:	new item to store in the slot.</span>
<span class="cm"> *</span>
<span class="cm"> * For use with radix_tree_lookup_slot().  Caller must hold tree write locked</span>
<span class="cm"> * across slot lookup and replacement.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">radix_tree_replace_slot</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">pslot</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">radix_tree_is_indirect_ptr</span><span class="p">(</span><span class="n">item</span><span class="p">));</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="o">*</span><span class="n">pslot</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">radix_tree_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">radix_tree_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">**</span><span class="n">radix_tree_lookup_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">radix_tree_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span>
<span class="n">radix_tree_gang_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">results</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_items</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">radix_tree_gang_lookup_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">***</span><span class="n">results</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">indices</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_items</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">radix_tree_next_hole</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_scan</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">radix_tree_prev_hole</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_scan</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">radix_tree_preload</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">radix_tree_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">radix_tree_tag_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">radix_tree_tag_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">radix_tree_tag_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span>
<span class="n">radix_tree_gang_lookup_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">results</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_items</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span>
<span class="n">radix_tree_gang_lookup_tag_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">void</span> <span class="o">***</span><span class="n">results</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_items</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">radix_tree_range_tag_if_tagged</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">first_indexp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_index</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_to_tag</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fromtag</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">totag</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">radix_tree_tagged</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">radix_tree_locate_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">radix_tree_preload_end</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct radix_tree_iter - radix tree iterator state</span>
<span class="cm"> *</span>
<span class="cm"> * @index:	index of current slot</span>
<span class="cm"> * @next_index:	next-to-last index for this chunk</span>
<span class="cm"> * @tags:	bit-mask for tag-iterating</span>
<span class="cm"> *</span>
<span class="cm"> * This radix tree iterator works in terms of &quot;chunks&quot; of slots.  A chunk is a</span>
<span class="cm"> * subinterval of slots contained within one radix tree leaf node.  It is</span>
<span class="cm"> * described by a pointer to its first slot and a struct radix_tree_iter</span>
<span class="cm"> * which holds the chunk&#39;s position in the tree and its size.  For tagged</span>
<span class="cm"> * iteration radix_tree_iter also holds the slots&#39; bit-mask for one chosen</span>
<span class="cm"> * radix tree tag.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">radix_tree_iter</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">next_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define RADIX_TREE_ITER_TAG_MASK	0x00FF	</span><span class="cm">/* tag index in lower byte */</span><span class="cp"></span>
<span class="cp">#define RADIX_TREE_ITER_TAGGED		0x0100	</span><span class="cm">/* lookup tagged slots */</span><span class="cp"></span>
<span class="cp">#define RADIX_TREE_ITER_CONTIG		0x0200	</span><span class="cm">/* stop at first hole */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * radix_tree_iter_init - initialize radix tree iterator</span>
<span class="cm"> *</span>
<span class="cm"> * @iter:	pointer to iterator state</span>
<span class="cm"> * @start:	iteration starting index</span>
<span class="cm"> * Returns:	NULL</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">**</span>
<span class="nf">radix_tree_iter_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Leave iter-&gt;tags uninitialized. radix_tree_next_chunk() will fill it</span>
<span class="cm">	 * in the case of a successful tagged chunk lookup.  If the lookup was</span>
<span class="cm">	 * unsuccessful or non-tagged then nobody cares about -&gt;tags.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set index to zero to bypass next_index overflow protection.</span>
<span class="cm">	 * See the comment in radix_tree_next_chunk() for details.</span>
<span class="cm">	 */</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">next_index</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * radix_tree_next_chunk - find next chunk of slots for iteration</span>
<span class="cm"> *</span>
<span class="cm"> * @root:	radix tree root</span>
<span class="cm"> * @iter:	iterator state</span>
<span class="cm"> * @flags:	RADIX_TREE_ITER_* flags and tag index</span>
<span class="cm"> * Returns:	pointer to chunk first slot, or NULL if there no more left</span>
<span class="cm"> *</span>
<span class="cm"> * This function looks up the next chunk in the radix tree starting from</span>
<span class="cm"> * @iter-&gt;next_index.  It returns a pointer to the chunk&#39;s first slot.</span>
<span class="cm"> * Also it fills @iter with data about chunk: position in the tree (index),</span>
<span class="cm"> * its end (next_index), and constructs a bit mask for tagged iterating (tags).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">**</span><span class="n">radix_tree_next_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">radix_tree_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * radix_tree_chunk_size - get current chunk size</span>
<span class="cm"> *</span>
<span class="cm"> * @iter:	pointer to radix tree iterator</span>
<span class="cm"> * Returns:	current chunk size</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">unsigned</span>
<span class="nf">radix_tree_chunk_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next_index</span> <span class="o">-</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * radix_tree_next_slot - find next slot in chunk</span>
<span class="cm"> *</span>
<span class="cm"> * @slot:	pointer to current slot</span>
<span class="cm"> * @iter:	pointer to interator state</span>
<span class="cm"> * @flags:	RADIX_TREE_ITER_*, should be constant</span>
<span class="cm"> * Returns:	pointer to next slot, or NULL if there no more left</span>
<span class="cm"> *</span>
<span class="cm"> * This function updates @iter-&gt;index in the case of a successful lookup.</span>
<span class="cm"> * For tagged lookup it also eats @iter-&gt;tags.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">**</span>
<span class="nf">radix_tree_next_slot</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">slot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">radix_tree_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RADIX_TREE_ITER_TAGGED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">tags</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">tags</span> <span class="o">&amp;</span> <span class="mi">1ul</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RADIX_TREE_ITER_CONTIG</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">likely</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">tags</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">tags</span><span class="p">);</span>

			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">tags</span> <span class="o">&gt;&gt;=</span> <span class="n">offset</span><span class="p">;</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+=</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">slot</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">size</span> <span class="o">=</span> <span class="n">radix_tree_chunk_size</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">size</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">slot</span><span class="o">++</span><span class="p">;</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">*</span><span class="n">slot</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">slot</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RADIX_TREE_ITER_CONTIG</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* forbid switching to the next chunk */</span>
				<span class="n">iter</span><span class="o">-&gt;</span><span class="n">next_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * radix_tree_for_each_chunk - iterate over chunks</span>
<span class="cm"> *</span>
<span class="cm"> * @slot:	the void** variable for pointer to chunk first slot</span>
<span class="cm"> * @root:	the struct radix_tree_root pointer</span>
<span class="cm"> * @iter:	the struct radix_tree_iter pointer</span>
<span class="cm"> * @start:	iteration starting index</span>
<span class="cm"> * @flags:	RADIX_TREE_ITER_* and tag index</span>
<span class="cm"> *</span>
<span class="cm"> * Locks can be released and reacquired between iterations.</span>
<span class="cm"> */</span>
<span class="cp">#define radix_tree_for_each_chunk(slot, root, iter, start, flags)	\</span>
<span class="cp">	for (slot = radix_tree_iter_init(iter, start) ;			\</span>
<span class="cp">	      (slot = radix_tree_next_chunk(root, iter, flags)) ;)</span>

<span class="cm">/**</span>
<span class="cm"> * radix_tree_for_each_chunk_slot - iterate over slots in one chunk</span>
<span class="cm"> *</span>
<span class="cm"> * @slot:	the void** variable, at the beginning points to chunk first slot</span>
<span class="cm"> * @iter:	the struct radix_tree_iter pointer</span>
<span class="cm"> * @flags:	RADIX_TREE_ITER_*, should be constant</span>
<span class="cm"> *</span>
<span class="cm"> * This macro is designed to be nested inside radix_tree_for_each_chunk().</span>
<span class="cm"> * @slot points to the radix tree slot, @iter-&gt;index contains its index.</span>
<span class="cm"> */</span>
<span class="cp">#define radix_tree_for_each_chunk_slot(slot, iter, flags)		\</span>
<span class="cp">	for (; slot ; slot = radix_tree_next_slot(slot, iter, flags))</span>

<span class="cm">/**</span>
<span class="cm"> * radix_tree_for_each_slot - iterate over non-empty slots</span>
<span class="cm"> *</span>
<span class="cm"> * @slot:	the void** variable for pointer to slot</span>
<span class="cm"> * @root:	the struct radix_tree_root pointer</span>
<span class="cm"> * @iter:	the struct radix_tree_iter pointer</span>
<span class="cm"> * @start:	iteration starting index</span>
<span class="cm"> *</span>
<span class="cm"> * @slot points to radix tree slot, @iter-&gt;index contains its index.</span>
<span class="cm"> */</span>
<span class="cp">#define radix_tree_for_each_slot(slot, root, iter, start)		\</span>
<span class="cp">	for (slot = radix_tree_iter_init(iter, start) ;			\</span>
<span class="cp">	     slot || (slot = radix_tree_next_chunk(root, iter, 0)) ;	\</span>
<span class="cp">	     slot = radix_tree_next_slot(slot, iter, 0))</span>

<span class="cm">/**</span>
<span class="cm"> * radix_tree_for_each_contig - iterate over contiguous slots</span>
<span class="cm"> *</span>
<span class="cm"> * @slot:	the void** variable for pointer to slot</span>
<span class="cm"> * @root:	the struct radix_tree_root pointer</span>
<span class="cm"> * @iter:	the struct radix_tree_iter pointer</span>
<span class="cm"> * @start:	iteration starting index</span>
<span class="cm"> *</span>
<span class="cm"> * @slot points to radix tree slot, @iter-&gt;index contains its index.</span>
<span class="cm"> */</span>
<span class="cp">#define radix_tree_for_each_contig(slot, root, iter, start)		\</span>
<span class="cp">	for (slot = radix_tree_iter_init(iter, start) ;			\</span>
<span class="cp">	     slot || (slot = radix_tree_next_chunk(root, iter,		\</span>
<span class="cp">				RADIX_TREE_ITER_CONTIG)) ;		\</span>
<span class="cp">	     slot = radix_tree_next_slot(slot, iter,			\</span>
<span class="cp">				RADIX_TREE_ITER_CONTIG))</span>

<span class="cm">/**</span>
<span class="cm"> * radix_tree_for_each_tagged - iterate over tagged slots</span>
<span class="cm"> *</span>
<span class="cm"> * @slot:	the void** variable for pointer to slot</span>
<span class="cm"> * @root:	the struct radix_tree_root pointer</span>
<span class="cm"> * @iter:	the struct radix_tree_iter pointer</span>
<span class="cm"> * @start:	iteration starting index</span>
<span class="cm"> * @tag:	tag index</span>
<span class="cm"> *</span>
<span class="cm"> * @slot points to radix tree slot, @iter-&gt;index contains its index.</span>
<span class="cm"> */</span>
<span class="cp">#define radix_tree_for_each_tagged(slot, root, iter, start, tag)	\</span>
<span class="cp">	for (slot = radix_tree_iter_init(iter, start) ;			\</span>
<span class="cp">	     slot || (slot = radix_tree_next_chunk(root, iter,		\</span>
<span class="cp">			      RADIX_TREE_ITER_TAGGED | tag)) ;		\</span>
<span class="cp">	     slot = radix_tree_next_slot(slot, iter,			\</span>
<span class="cp">				RADIX_TREE_ITER_TAGGED))</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_RADIX_TREE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
