<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › idr.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>idr.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * include/linux/idr.h</span>
<span class="cm"> * </span>
<span class="cm"> * 2002-10-18  written by Jim Houston jim.houston@ccur.com</span>
<span class="cm"> *	Copyright (C) 2002 by Concurrent Computer Corporation</span>
<span class="cm"> *	Distributed under the GNU GPL license version 2.</span>
<span class="cm"> *</span>
<span class="cm"> * Small id to pointer translation service avoiding fixed sized</span>
<span class="cm"> * tables.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __IDR_H__</span>
<span class="cp">#define __IDR_H__</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>

<span class="cp">#if BITS_PER_LONG == 32</span>
<span class="cp"># define IDR_BITS 5</span>
<span class="cp"># define IDR_FULL 0xfffffffful</span>
<span class="cm">/* We can only use two of the bits in the top level because there is</span>
<span class="cm">   only one possible bit in the top level (5 bits * 7 levels = 35</span>
<span class="cm">   bits, but you only use 31 bits in the id). */</span>
<span class="cp"># define TOP_LEVEL_FULL (IDR_FULL &gt;&gt; 30)</span>
<span class="cp">#elif BITS_PER_LONG == 64</span>
<span class="cp"># define IDR_BITS 6</span>
<span class="cp"># define IDR_FULL 0xfffffffffffffffful</span>
<span class="cm">/* We can only use two of the bits in the top level because there is</span>
<span class="cm">   only one possible bit in the top level (6 bits * 6 levels = 36</span>
<span class="cm">   bits, but you only use 31 bits in the id). */</span>
<span class="cp"># define TOP_LEVEL_FULL (IDR_FULL &gt;&gt; 62)</span>
<span class="cp">#else</span>
<span class="cp"># error &quot;BITS_PER_LONG is not 32 or 64&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#define IDR_SIZE (1 &lt;&lt; IDR_BITS)</span>
<span class="cp">#define IDR_MASK ((1 &lt;&lt; IDR_BITS)-1)</span>

<span class="cp">#define MAX_ID_SHIFT (sizeof(int)*8 - 1)</span>
<span class="cp">#define MAX_ID_BIT (1U &lt;&lt; MAX_ID_SHIFT)</span>
<span class="cp">#define MAX_ID_MASK (MAX_ID_BIT - 1)</span>

<span class="cm">/* Leave the possibility of an incomplete final layer */</span>
<span class="cp">#define MAX_LEVEL (MAX_ID_SHIFT + IDR_BITS - 1) / IDR_BITS</span>

<span class="cm">/* Number of id_layer structs to leave in free list */</span>
<span class="cp">#define IDR_FREE_MAX MAX_LEVEL + MAX_LEVEL</span>

<span class="k">struct</span> <span class="n">idr_layer</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		 <span class="n">bitmap</span><span class="p">;</span> <span class="cm">/* A zero bit means &quot;space here&quot; */</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="n">__rcu</span>	<span class="o">*</span><span class="n">ary</span><span class="p">[</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">IDR_BITS</span><span class="p">];</span>
	<span class="kt">int</span>			 <span class="n">count</span><span class="p">;</span>	 <span class="cm">/* When zero, we can release it */</span>
	<span class="kt">int</span>			 <span class="n">layer</span><span class="p">;</span>	 <span class="cm">/* distance from leaf */</span>
	<span class="k">struct</span> <span class="n">rcu_head</span>		 <span class="n">rcu_head</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">idr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">top</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">id_free</span><span class="p">;</span>
	<span class="kt">int</span>		  <span class="n">layers</span><span class="p">;</span> <span class="cm">/* only valid without concurrent changes */</span>
	<span class="kt">int</span>		  <span class="n">id_free_cnt</span><span class="p">;</span>
	<span class="n">spinlock_t</span>	  <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define IDR_INIT(name)						\</span>
<span class="cp">{								\</span>
<span class="cp">	.top		= NULL,					\</span>
<span class="cp">	.id_free	= NULL,					\</span>
<span class="cp">	.layers 	= 0,					\</span>
<span class="cp">	.id_free_cnt	= 0,					\</span>
<span class="cp">	.lock		= __SPIN_LOCK_UNLOCKED(name.lock),	\</span>
<span class="cp">}</span>
<span class="cp">#define DEFINE_IDR(name)	struct idr name = IDR_INIT(name)</span>

<span class="cm">/* Actions to be taken after a call to _idr_sub_alloc */</span>
<span class="cp">#define IDR_NEED_TO_GROW -2</span>
<span class="cp">#define IDR_NOMORE_SPACE -3</span>

<span class="cp">#define _idr_rc_to_errno(rc) ((rc) == -1 ? -EAGAIN : -ENOSPC)</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: idr sync</span>
<span class="cm"> * idr synchronization (stolen from radix-tree.h)</span>
<span class="cm"> *</span>
<span class="cm"> * idr_find() is able to be called locklessly, using RCU. The caller must</span>
<span class="cm"> * ensure calls to this function are made within rcu_read_lock() regions.</span>
<span class="cm"> * Other readers (lock-free or otherwise) and modifications may be running</span>
<span class="cm"> * concurrently.</span>
<span class="cm"> *</span>
<span class="cm"> * It is still required that the caller manage the synchronization and</span>
<span class="cm"> * lifetimes of the items. So if RCU lock-free lookups are used, typically</span>
<span class="cm"> * this would mean that the items have their own locks, or are amenable to</span>
<span class="cm"> * lock-free access; and that the items are freed by RCU (or only freed after</span>
<span class="cm"> * having been deleted from the idr tree *and* a synchronize_rcu() grace</span>
<span class="cm"> * period).</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This is what we export.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">idr_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">idr_pre_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">idr_get_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">idr_get_new_above</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">starting_id</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">idr_for_each</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">idr_get_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nextid</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">idr_replace</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">idr_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">idr_remove_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">idr_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">idr_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * IDA - IDR based id allocator, use when translation from id to</span>
<span class="cm"> * pointer isn&#39;t necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * IDA_BITMAP_LONGS is calculated to be one less to accommodate</span>
<span class="cm"> * ida_bitmap-&gt;nr_busy so that the whole struct fits in 128 bytes.</span>
<span class="cm"> */</span>
<span class="cp">#define IDA_CHUNK_SIZE		128	</span><span class="cm">/* 128 bytes per chunk */</span><span class="cp"></span>
<span class="cp">#define IDA_BITMAP_LONGS	(IDA_CHUNK_SIZE / sizeof(long) - 1)</span>
<span class="cp">#define IDA_BITMAP_BITS 	(IDA_BITMAP_LONGS * sizeof(long) * 8)</span>

<span class="k">struct</span> <span class="n">ida_bitmap</span> <span class="p">{</span>
	<span class="kt">long</span>			<span class="n">nr_busy</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">bitmap</span><span class="p">[</span><span class="n">IDA_BITMAP_LONGS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ida</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">idr</span>		<span class="n">idr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ida_bitmap</span>	<span class="o">*</span><span class="n">free_bitmap</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define IDA_INIT(name)		{ .idr = IDR_INIT(name), .free_bitmap = NULL, }</span>
<span class="cp">#define DEFINE_IDA(name)	struct ida name = IDA_INIT(name)</span>

<span class="kt">int</span> <span class="n">ida_pre_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ida_get_new_above</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">,</span> <span class="kt">int</span> <span class="n">starting_id</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p_id</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ida_get_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p_id</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ida_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ida_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ida_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ida_simple_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span>
		   <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ida_simple_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="n">idr_init_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __IDR_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
