<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › pid.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pid.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_PID_H</span>
<span class="cp">#define _LINUX_PID_H</span>

<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>

<span class="k">enum</span> <span class="n">pid_type</span>
<span class="p">{</span>
	<span class="n">PIDTYPE_PID</span><span class="p">,</span>
	<span class="n">PIDTYPE_PGID</span><span class="p">,</span>
	<span class="n">PIDTYPE_SID</span><span class="p">,</span>
	<span class="n">PIDTYPE_MAX</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * What is struct pid?</span>
<span class="cm"> *</span>
<span class="cm"> * A struct pid is the kernel&#39;s internal notion of a process identifier.</span>
<span class="cm"> * It refers to individual tasks, process groups, and sessions.  While</span>
<span class="cm"> * there are processes attached to it the struct pid lives in a hash</span>
<span class="cm"> * table, so it and then the processes that it refers to can be found</span>
<span class="cm"> * quickly from the numeric pid value.  The attached processes may be</span>
<span class="cm"> * quickly accessed by following pointers from struct pid.</span>
<span class="cm"> *</span>
<span class="cm"> * Storing pid_t values in the kernel and referring to them later has a</span>
<span class="cm"> * problem.  The process originally with that pid may have exited and the</span>
<span class="cm"> * pid allocator wrapped, and another process could have come along</span>
<span class="cm"> * and been assigned that pid.</span>
<span class="cm"> *</span>
<span class="cm"> * Referring to user space processes by holding a reference to struct</span>
<span class="cm"> * task_struct has a problem.  When the user space process exits</span>
<span class="cm"> * the now useless task_struct is still kept.  A task_struct plus a</span>
<span class="cm"> * stack consumes around 10K of low kernel memory.  More precisely</span>
<span class="cm"> * this is THREAD_SIZE + sizeof(struct task_struct).  By comparison</span>
<span class="cm"> * a struct pid is about 64 bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * Holding a reference to struct pid solves both of these problems.</span>
<span class="cm"> * It is small so holding a reference does not consume a lot of</span>
<span class="cm"> * resources, and since a new struct pid is allocated when the numeric pid</span>
<span class="cm"> * value is reused (when pids wrap around) we don&#39;t mistakenly refer to new</span>
<span class="cm"> * processes.</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * struct upid is used to get the id of the struct pid, as it is</span>
<span class="cm"> * seen in particular namespace. Later the struct pid is found with</span>
<span class="cm"> * find_pid_ns() using the int nr and struct pid_namespace *ns.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">upid</span> <span class="p">{</span>
	<span class="cm">/* Try to keep pid_chain in the same cacheline as nr for find_vpid */</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">pid_chain</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pid</span>
<span class="p">{</span>
	<span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="cm">/* lists of tasks that use this pid */</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">tasks</span><span class="p">[</span><span class="n">PIDTYPE_MAX</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">upid</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">pid</span> <span class="n">init_struct_pid</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">pid_link</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="nf">get_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pid</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">put_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">pid_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pid_type</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">get_pid_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pid_type</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">get_task_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pid_type</span> <span class="n">type</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * attach_pid() and detach_pid() must be called with the tasklist_lock</span>
<span class="cm"> * write-held.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">attach_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pid_type</span> <span class="n">type</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">detach_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pid_type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">change_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pid_type</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">transfer_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
			 <span class="k">enum</span> <span class="n">pid_type</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">pid_namespace</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pid_namespace</span> <span class="n">init_pid_ns</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * look up a PID in the hash table. Must be called with the tasklist_lock</span>
<span class="cm"> * or rcu_read_lock() held.</span>
<span class="cm"> *</span>
<span class="cm"> * find_pid_ns() finds the pid in the namespace specified</span>
<span class="cm"> * find_vpid() finds the pid by its virtual id, i.e. in the current namespace</span>
<span class="cm"> *</span>
<span class="cm"> * see also find_task_by_vpid() set in include/linux/sched.h</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">find_pid_ns</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">find_vpid</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Lookup a PID in the hash table, and return with it&#39;s count elevated.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">find_get_pid</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">find_ge_pid</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">next_pidmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">pid_ns</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">alloc_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ns_of_pid() returns the pid namespace in which the specified pid was</span>
<span class="cm"> * allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:</span>
<span class="cm"> * 	ns_of_pid() is expected to be called for a process (task) that has</span>
<span class="cm"> * 	an attached &#39;struct pid&#39; (see attach_pid(), detach_pid()) i.e @pid</span>
<span class="cm"> * 	is expected to be non-NULL. If @pid is NULL, caller should handle</span>
<span class="cm"> * 	the resulting NULL pid-ns.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="nf">ns_of_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="p">)</span>
		<span class="n">ns</span> <span class="o">=</span> <span class="n">pid</span><span class="o">-&gt;</span><span class="n">numbers</span><span class="p">[</span><span class="n">pid</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">].</span><span class="n">ns</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * is_child_reaper returns true if the pid is the init process</span>
<span class="cm"> * of the current namespace. As this one could be checked before</span>
<span class="cm"> * pid_ns-&gt;child_reaper is assigned in copy_process, we check</span>
<span class="cm"> * with the pid number.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_child_reaper</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pid</span><span class="o">-&gt;</span><span class="n">numbers</span><span class="p">[</span><span class="n">pid</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">].</span><span class="n">nr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * the helpers to get the pid&#39;s id seen from different namespaces</span>
<span class="cm"> *</span>
<span class="cm"> * pid_nr()    : global id, i.e. the id seen from the init namespace;</span>
<span class="cm"> * pid_vnr()   : virtual id, i.e. the id seen from the pid namespace of</span>
<span class="cm"> *               current.</span>
<span class="cm"> * pid_nr_ns() : id seen from the ns specified.</span>
<span class="cm"> *</span>
<span class="cm"> * see also task_xid_nr() etc in include/linux/sched.h</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pid_t</span> <span class="nf">pid_nr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pid_t</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="p">)</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">pid</span><span class="o">-&gt;</span><span class="n">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">nr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">pid_t</span> <span class="n">pid_nr_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">);</span>
<span class="n">pid_t</span> <span class="n">pid_vnr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">);</span>

<span class="cp">#define do_each_pid_task(pid, type, task)				\</span>
<span class="cp">	do {								\</span>
<span class="cp">		struct hlist_node *pos___;				\</span>
<span class="cp">		if ((pid) != NULL)					\</span>
<span class="cp">			hlist_for_each_entry_rcu((task), pos___,	\</span>
<span class="cp">				&amp;(pid)-&gt;tasks[type], pids[type].node) {</span>

			<span class="cm">/*</span>
<span class="cm">			 * Both old and new leaders may be attached to</span>
<span class="cm">			 * the same pid in the middle of de_thread().</span>
<span class="cm">			 */</span>
<span class="cp">#define while_each_pid_task(pid, type, task)				\</span>
<span class="cp">				if (type == PIDTYPE_PID)		\</span>
<span class="cp">					break;				\</span>
<span class="cp">			}						\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define do_each_pid_thread(pid, type, task)				\</span>
<span class="cp">	do_each_pid_task(pid, type, task) {				\</span>
<span class="cp">		struct task_struct *tg___ = task;			\</span>
<span class="cp">		do {</span>

<span class="cp">#define while_each_pid_thread(pid, type, task)				\</span>
<span class="cp">		} while_each_thread(tg___, task);			\</span>
<span class="cp">		task = tg___;						\</span>
<span class="cp">	} while_each_pid_task(pid, type, task)</span>
<span class="cp">#endif </span><span class="cm">/* _LINUX_PID_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
