<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › cred.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>cred.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Credentials management - see Documentation/security/credentials.txt</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008 Red Hat, Inc. All Rights Reserved.</span>
<span class="cm"> * Written by David Howells (dhowells@redhat.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public Licence</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the Licence, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_CRED_H</span>
<span class="cp">#define _LINUX_CRED_H</span>

<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/key.h&gt;</span>
<span class="cp">#include &lt;linux/selinux.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/uidgid.h&gt;</span>

<span class="k">struct</span> <span class="n">user_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cred</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">inode</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * COW Supplementary groups list</span>
<span class="cm"> */</span>
<span class="cp">#define NGROUPS_SMALL		32</span>
<span class="cp">#define NGROUPS_PER_BLOCK	((unsigned int)(PAGE_SIZE / sizeof(kgid_t)))</span>

<span class="k">struct</span> <span class="n">group_info</span> <span class="p">{</span>
	<span class="n">atomic_t</span>	<span class="n">usage</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">ngroups</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">nblocks</span><span class="p">;</span>
	<span class="n">kgid_t</span>		<span class="n">small_block</span><span class="p">[</span><span class="n">NGROUPS_SMALL</span><span class="p">];</span>
	<span class="n">kgid_t</span>		<span class="o">*</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * get_group_info - Get a reference to a group info structure</span>
<span class="cm"> * @group_info: The group info to reference</span>
<span class="cm"> *</span>
<span class="cm"> * This gets a reference to a set of supplementary groups.</span>
<span class="cm"> *</span>
<span class="cm"> * If the caller is accessing a task&#39;s credentials, they must hold the RCU read</span>
<span class="cm"> * lock when reading.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">group_info</span> <span class="o">*</span><span class="nf">get_group_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">group_info</span> <span class="o">*</span><span class="n">gi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gi</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">gi</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * put_group_info - Release a reference to a group info structure</span>
<span class="cm"> * @group_info: The group info to release</span>
<span class="cm"> */</span>
<span class="cp">#define put_group_info(group_info)			\</span>
<span class="cp">do {							\</span>
<span class="cp">	if (atomic_dec_and_test(&amp;(group_info)-&gt;usage))	\</span>
<span class="cp">		groups_free(group_info);		\</span>
<span class="cp">} while (0)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">group_info</span> <span class="o">*</span><span class="n">groups_alloc</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">group_info</span> <span class="n">init_groups</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">groups_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">group_info</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">set_current_groups</span><span class="p">(</span><span class="k">struct</span> <span class="n">group_info</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">set_groups</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">group_info</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">groups_search</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">group_info</span> <span class="o">*</span><span class="p">,</span> <span class="n">kgid_t</span><span class="p">);</span>

<span class="cm">/* access the groups &quot;array&quot; with this macro */</span>
<span class="cp">#define GROUP_AT(gi, i) \</span>
<span class="cp">	((gi)-&gt;blocks[(i) / NGROUPS_PER_BLOCK][(i) % NGROUPS_PER_BLOCK])</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">in_group_p</span><span class="p">(</span><span class="n">kgid_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">in_egroup_p</span><span class="p">(</span><span class="n">kgid_t</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The common credentials for a thread group</span>
<span class="cm"> * - shared by CLONE_THREAD</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_KEYS</span>
<span class="k">struct</span> <span class="n">thread_group_cred</span> <span class="p">{</span>
	<span class="n">atomic_t</span>	<span class="n">usage</span><span class="p">;</span>
	<span class="n">pid_t</span>		<span class="n">tgid</span><span class="p">;</span>			<span class="cm">/* thread group process ID */</span>
	<span class="n">spinlock_t</span>	<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">session_keyring</span><span class="p">;</span>	<span class="cm">/* keyring inherited over fork */</span>
	<span class="k">struct</span> <span class="n">key</span>	<span class="o">*</span><span class="n">process_keyring</span><span class="p">;</span>	<span class="cm">/* keyring private to this process */</span>
	<span class="k">struct</span> <span class="n">rcu_head</span>	<span class="n">rcu</span><span class="p">;</span>			<span class="cm">/* RCU deletion hook */</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The security context of a task</span>
<span class="cm"> *</span>
<span class="cm"> * The parts of the context break down into two categories:</span>
<span class="cm"> *</span>
<span class="cm"> *  (1) The objective context of a task.  These parts are used when some other</span>
<span class="cm"> *	task is attempting to affect this one.</span>
<span class="cm"> *</span>
<span class="cm"> *  (2) The subjective context.  These details are used when the task is acting</span>
<span class="cm"> *	upon another object, be that a file, a task, a key or whatever.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that some members of this structure belong to both categories - the</span>
<span class="cm"> * LSM security pointer for instance.</span>
<span class="cm"> *</span>
<span class="cm"> * A task has two security pointers.  task-&gt;real_cred points to the objective</span>
<span class="cm"> * context that defines that task&#39;s actual details.  The objective part of this</span>
<span class="cm"> * context is used whenever that task is acted upon.</span>
<span class="cm"> *</span>
<span class="cm"> * task-&gt;cred points to the subjective context that defines the details of how</span>
<span class="cm"> * that task is going to act upon another object.  This may be overridden</span>
<span class="cm"> * temporarily to point to another security context, but normally points to the</span>
<span class="cm"> * same context as task-&gt;real_cred.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cred</span> <span class="p">{</span>
	<span class="n">atomic_t</span>	<span class="n">usage</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_DEBUG_CREDENTIALS</span>
	<span class="n">atomic_t</span>	<span class="n">subscribers</span><span class="p">;</span>	<span class="cm">/* number of processes subscribed */</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">put_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">magic</span><span class="p">;</span>
<span class="cp">#define CRED_MAGIC	0x43736564</span>
<span class="cp">#define CRED_MAGIC_DEAD	0x44656144</span>
<span class="cp">#endif</span>
	<span class="n">kuid_t</span>		<span class="n">uid</span><span class="p">;</span>		<span class="cm">/* real UID of the task */</span>
	<span class="n">kgid_t</span>		<span class="n">gid</span><span class="p">;</span>		<span class="cm">/* real GID of the task */</span>
	<span class="n">kuid_t</span>		<span class="n">suid</span><span class="p">;</span>		<span class="cm">/* saved UID of the task */</span>
	<span class="n">kgid_t</span>		<span class="n">sgid</span><span class="p">;</span>		<span class="cm">/* saved GID of the task */</span>
	<span class="n">kuid_t</span>		<span class="n">euid</span><span class="p">;</span>		<span class="cm">/* effective UID of the task */</span>
	<span class="n">kgid_t</span>		<span class="n">egid</span><span class="p">;</span>		<span class="cm">/* effective GID of the task */</span>
	<span class="n">kuid_t</span>		<span class="n">fsuid</span><span class="p">;</span>		<span class="cm">/* UID for VFS ops */</span>
	<span class="n">kgid_t</span>		<span class="n">fsgid</span><span class="p">;</span>		<span class="cm">/* GID for VFS ops */</span>
	<span class="kt">unsigned</span>	<span class="n">securebits</span><span class="p">;</span>	<span class="cm">/* SUID-less security management */</span>
	<span class="n">kernel_cap_t</span>	<span class="n">cap_inheritable</span><span class="p">;</span> <span class="cm">/* caps our children can inherit */</span>
	<span class="n">kernel_cap_t</span>	<span class="n">cap_permitted</span><span class="p">;</span>	<span class="cm">/* caps we&#39;re permitted */</span>
	<span class="n">kernel_cap_t</span>	<span class="n">cap_effective</span><span class="p">;</span>	<span class="cm">/* caps we can actually use */</span>
	<span class="n">kernel_cap_t</span>	<span class="n">cap_bset</span><span class="p">;</span>	<span class="cm">/* capability bounding set */</span>
<span class="cp">#ifdef CONFIG_KEYS</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">jit_keyring</span><span class="p">;</span>	<span class="cm">/* default keyring to attach requested</span>
<span class="cm">					 * keys to */</span>
	<span class="k">struct</span> <span class="n">key</span>	<span class="o">*</span><span class="n">thread_keyring</span><span class="p">;</span> <span class="cm">/* keyring private to this thread */</span>
	<span class="k">struct</span> <span class="n">key</span>	<span class="o">*</span><span class="n">request_key_auth</span><span class="p">;</span> <span class="cm">/* assumed request_key authority */</span>
	<span class="k">struct</span> <span class="n">thread_group_cred</span> <span class="o">*</span><span class="n">tgcred</span><span class="p">;</span> <span class="cm">/* thread-group shared credentials */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SECURITY</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">security</span><span class="p">;</span>	<span class="cm">/* subjective LSM security */</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>	<span class="cm">/* real user ID subscription */</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">user_ns</span><span class="p">;</span> <span class="cm">/* user_ns the caps and keyrings are relative to. */</span>
	<span class="k">struct</span> <span class="n">group_info</span> <span class="o">*</span><span class="n">group_info</span><span class="p">;</span>	<span class="cm">/* supplementary groups for euid/fsgid */</span>
	<span class="k">struct</span> <span class="n">rcu_head</span>	<span class="n">rcu</span><span class="p">;</span>		<span class="cm">/* RCU deletion hook */</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__put_cred</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">exit_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">copy_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">get_task_cred</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred_alloc_blank</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">prepare_creds</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">prepare_exec_creds</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">commit_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">abort_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">override_creds</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">revert_creds</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">prepare_kernel_cred</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">change_create_files_as</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">set_security_override</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">set_security_override_from_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">set_create_files_as</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">cred_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * check for validity of credentials</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_DEBUG_CREDENTIALS</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__invalid_creds</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__validate_process_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">creds_are_invalid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__validate_creds</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">creds_are_invalid</span><span class="p">(</span><span class="n">cred</span><span class="p">)))</span>
		<span class="n">__invalid_creds</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define validate_creds(cred)				\</span>
<span class="cp">do {							\</span>
<span class="cp">	__validate_creds((cred), __FILE__, __LINE__);	\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define validate_process_creds()				\</span>
<span class="cp">do {								\</span>
<span class="cp">	__validate_process_creds(current, __FILE__, __LINE__);	\</span>
<span class="cp">} while(0)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">validate_creds_for_do_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">validate_creds</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">validate_creds_for_do_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">validate_process_creds</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * get_new_cred - Get a reference on a new set of credentials</span>
<span class="cm"> * @cred: The new credentials to reference</span>
<span class="cm"> *</span>
<span class="cm"> * Get a reference on the specified set of new credentials.  The caller must</span>
<span class="cm"> * release the reference.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="nf">get_new_cred</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cred</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_cred - Get a reference on a set of credentials</span>
<span class="cm"> * @cred: The credentials to reference</span>
<span class="cm"> *</span>
<span class="cm"> * Get a reference on the specified set of credentials.  The caller must</span>
<span class="cm"> * release the reference.</span>
<span class="cm"> *</span>
<span class="cm"> * This is used to deal with a committed set of credentials.  Although the</span>
<span class="cm"> * pointer is const, this will temporarily discard the const and increment the</span>
<span class="cm"> * usage count.  The purpose of this is to attempt to catch at compile time the</span>
<span class="cm"> * accidental alteration of a set of credentials that should be considered</span>
<span class="cm"> * immutable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="nf">get_cred</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">nonconst_cred</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">)</span> <span class="n">cred</span><span class="p">;</span>
	<span class="n">validate_creds</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">get_new_cred</span><span class="p">(</span><span class="n">nonconst_cred</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * put_cred - Release a reference to a set of credentials</span>
<span class="cm"> * @cred: The credentials to release</span>
<span class="cm"> *</span>
<span class="cm"> * Release a reference to a set of credentials, deleting them when the last ref</span>
<span class="cm"> * is released.</span>
<span class="cm"> *</span>
<span class="cm"> * This takes a const pointer to a set of credentials because the credentials</span>
<span class="cm"> * on task_struct are attached by const pointers to prevent accidental</span>
<span class="cm"> * alteration of otherwise immutable credential sets.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_cred</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">_cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">)</span> <span class="n">_cred</span><span class="p">;</span>

	<span class="n">validate_creds</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">cred</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">))</span>
		<span class="n">__put_cred</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * current_cred - Access the current task&#39;s subjective credentials</span>
<span class="cm"> *</span>
<span class="cm"> * Access the subjective credentials of the current task.  RCU-safe,</span>
<span class="cm"> * since nobody else can modify it.</span>
<span class="cm"> */</span>
<span class="cp">#define current_cred() \</span>
<span class="cp">	rcu_dereference_protected(current-&gt;cred, 1)</span>

<span class="cm">/**</span>
<span class="cm"> * __task_cred - Access a task&#39;s objective credentials</span>
<span class="cm"> * @task: The task to query</span>
<span class="cm"> *</span>
<span class="cm"> * Access the objective credentials of a task.  The caller must hold the RCU</span>
<span class="cm"> * readlock.</span>
<span class="cm"> *</span>
<span class="cm"> * The result of this function should not be passed directly to get_cred();</span>
<span class="cm"> * rather get_task_cred() should be used instead.</span>
<span class="cm"> */</span>
<span class="cp">#define __task_cred(task)	\</span>
<span class="cp">	rcu_dereference((task)-&gt;real_cred)</span>

<span class="cm">/**</span>
<span class="cm"> * get_current_cred - Get the current task&#39;s subjective credentials</span>
<span class="cm"> *</span>
<span class="cm"> * Get the subjective credentials of the current task, pinning them so that</span>
<span class="cm"> * they can&#39;t go away.  Accessing the current task&#39;s credentials directly is</span>
<span class="cm"> * not permitted.</span>
<span class="cm"> */</span>
<span class="cp">#define get_current_cred()				\</span>
<span class="cp">	(get_cred(current_cred()))</span>

<span class="cm">/**</span>
<span class="cm"> * get_current_user - Get the current task&#39;s user_struct</span>
<span class="cm"> *</span>
<span class="cm"> * Get the user record of the current task, pinning it so that it can&#39;t go</span>
<span class="cm"> * away.</span>
<span class="cm"> */</span>
<span class="cp">#define get_current_user()				\</span>
<span class="cp">({							\</span>
<span class="cp">	struct user_struct *__u;			\</span>
<span class="cp">	const struct cred *__cred;			\</span>
<span class="cp">	__cred = current_cred();			\</span>
<span class="cp">	__u = get_uid(__cred-&gt;user);			\</span>
<span class="cp">	__u;						\</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * get_current_groups - Get the current task&#39;s supplementary group list</span>
<span class="cm"> *</span>
<span class="cm"> * Get the supplementary group list of the current task, pinning it so that it</span>
<span class="cm"> * can&#39;t go away.</span>
<span class="cm"> */</span>
<span class="cp">#define get_current_groups()				\</span>
<span class="cp">({							\</span>
<span class="cp">	struct group_info *__groups;			\</span>
<span class="cp">	const struct cred *__cred;			\</span>
<span class="cp">	__cred = current_cred();			\</span>
<span class="cp">	__groups = get_group_info(__cred-&gt;group_info);	\</span>
<span class="cp">	__groups;					\</span>
<span class="cp">})</span>

<span class="cp">#define task_cred_xxx(task, xxx)			\</span>
<span class="cp">({							\</span>
<span class="cp">	__typeof__(((struct cred *)NULL)-&gt;xxx) ___val;	\</span>
<span class="cp">	rcu_read_lock();				\</span>
<span class="cp">	___val = __task_cred((task))-&gt;xxx;		\</span>
<span class="cp">	rcu_read_unlock();				\</span>
<span class="cp">	___val;						\</span>
<span class="cp">})</span>

<span class="cp">#define task_uid(task)		(task_cred_xxx((task), uid))</span>
<span class="cp">#define task_euid(task)		(task_cred_xxx((task), euid))</span>

<span class="cp">#define current_cred_xxx(xxx)			\</span>
<span class="cp">({						\</span>
<span class="cp">	current_cred()-&gt;xxx;			\</span>
<span class="cp">})</span>

<span class="cp">#define current_uid()		(current_cred_xxx(uid))</span>
<span class="cp">#define current_gid()		(current_cred_xxx(gid))</span>
<span class="cp">#define current_euid()		(current_cred_xxx(euid))</span>
<span class="cp">#define current_egid()		(current_cred_xxx(egid))</span>
<span class="cp">#define current_suid()		(current_cred_xxx(suid))</span>
<span class="cp">#define current_sgid()		(current_cred_xxx(sgid))</span>
<span class="cp">#define current_fsuid() 	(current_cred_xxx(fsuid))</span>
<span class="cp">#define current_fsgid() 	(current_cred_xxx(fsgid))</span>
<span class="cp">#define current_cap()		(current_cred_xxx(cap_effective))</span>
<span class="cp">#define current_user()		(current_cred_xxx(user))</span>
<span class="cp">#define current_security()	(current_cred_xxx(security))</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">user_namespace</span> <span class="n">init_user_ns</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_USER_NS</span>
<span class="cp">#define current_user_ns()	(current_cred_xxx(user_ns))</span>
<span class="cp">#define task_user_ns(task)	(task_cred_xxx((task), user_ns))</span>
<span class="cp">#else</span>
<span class="cp">#define current_user_ns()	(&amp;init_user_ns)</span>
<span class="cp">#define task_user_ns(task)	(&amp;init_user_ns)</span>
<span class="cp">#endif</span>


<span class="cp">#define current_uid_gid(_uid, _gid)		\</span>
<span class="cp">do {						\</span>
<span class="cp">	const struct cred *__cred;		\</span>
<span class="cp">	__cred = current_cred();		\</span>
<span class="cp">	*(_uid) = __cred-&gt;uid;			\</span>
<span class="cp">	*(_gid) = __cred-&gt;gid;			\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define current_euid_egid(_euid, _egid)		\</span>
<span class="cp">do {						\</span>
<span class="cp">	const struct cred *__cred;		\</span>
<span class="cp">	__cred = current_cred();		\</span>
<span class="cp">	*(_euid) = __cred-&gt;euid;		\</span>
<span class="cp">	*(_egid) = __cred-&gt;egid;		\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define current_fsuid_fsgid(_fsuid, _fsgid)	\</span>
<span class="cp">do {						\</span>
<span class="cp">	const struct cred *__cred;		\</span>
<span class="cp">	__cred = current_cred();		\</span>
<span class="cp">	*(_fsuid) = __cred-&gt;fsuid;		\</span>
<span class="cp">	*(_fsgid) = __cred-&gt;fsgid;		\</span>
<span class="cp">} while(0)</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_CRED_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
