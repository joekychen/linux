<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › gfp.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>gfp.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __LINUX_GFP_H</span>
<span class="cp">#define __LINUX_GFP_H</span>

<span class="cp">#include &lt;linux/mmzone.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/topology.h&gt;</span>
<span class="cp">#include &lt;linux/mmdebug.h&gt;</span>

<span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">;</span>

<span class="cm">/* Plain integer GFP bitmasks. Do not use this directly. */</span>
<span class="cp">#define ___GFP_DMA		0x01u</span>
<span class="cp">#define ___GFP_HIGHMEM		0x02u</span>
<span class="cp">#define ___GFP_DMA32		0x04u</span>
<span class="cp">#define ___GFP_MOVABLE		0x08u</span>
<span class="cp">#define ___GFP_WAIT		0x10u</span>
<span class="cp">#define ___GFP_HIGH		0x20u</span>
<span class="cp">#define ___GFP_IO		0x40u</span>
<span class="cp">#define ___GFP_FS		0x80u</span>
<span class="cp">#define ___GFP_COLD		0x100u</span>
<span class="cp">#define ___GFP_NOWARN		0x200u</span>
<span class="cp">#define ___GFP_REPEAT		0x400u</span>
<span class="cp">#define ___GFP_NOFAIL		0x800u</span>
<span class="cp">#define ___GFP_NORETRY		0x1000u</span>
<span class="cp">#define ___GFP_COMP		0x4000u</span>
<span class="cp">#define ___GFP_ZERO		0x8000u</span>
<span class="cp">#define ___GFP_NOMEMALLOC	0x10000u</span>
<span class="cp">#define ___GFP_HARDWALL		0x20000u</span>
<span class="cp">#define ___GFP_THISNODE		0x40000u</span>
<span class="cp">#define ___GFP_RECLAIMABLE	0x80000u</span>
<span class="cp">#ifdef CONFIG_KMEMCHECK</span>
<span class="cp">#define ___GFP_NOTRACK		0x200000u</span>
<span class="cp">#else</span>
<span class="cp">#define ___GFP_NOTRACK		0</span>
<span class="cp">#endif</span>
<span class="cp">#define ___GFP_NO_KSWAPD	0x400000u</span>
<span class="cp">#define ___GFP_OTHER_NODE	0x800000u</span>
<span class="cp">#define ___GFP_WRITE		0x1000000u</span>

<span class="cm">/*</span>
<span class="cm"> * GFP bitmasks..</span>
<span class="cm"> *</span>
<span class="cm"> * Zone modifiers (see linux/mmzone.h - low three bits)</span>
<span class="cm"> *</span>
<span class="cm"> * Do not put any conditional on these. If necessary modify the definitions</span>
<span class="cm"> * without the underscores and use them consistently. The definitions here may</span>
<span class="cm"> * be used in bit comparisons.</span>
<span class="cm"> */</span>
<span class="cp">#define __GFP_DMA	((__force gfp_t)___GFP_DMA)</span>
<span class="cp">#define __GFP_HIGHMEM	((__force gfp_t)___GFP_HIGHMEM)</span>
<span class="cp">#define __GFP_DMA32	((__force gfp_t)___GFP_DMA32)</span>
<span class="cp">#define __GFP_MOVABLE	((__force gfp_t)___GFP_MOVABLE)  </span><span class="cm">/* Page is movable */</span><span class="cp"></span>
<span class="cp">#define GFP_ZONEMASK	(__GFP_DMA|__GFP_HIGHMEM|__GFP_DMA32|__GFP_MOVABLE)</span>
<span class="cm">/*</span>
<span class="cm"> * Action modifiers - doesn&#39;t change the zoning</span>
<span class="cm"> *</span>
<span class="cm"> * __GFP_REPEAT: Try hard to allocate the memory, but the allocation attempt</span>
<span class="cm"> * _might_ fail.  This depends upon the particular VM implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * __GFP_NOFAIL: The VM implementation _must_ retry infinitely: the caller</span>
<span class="cm"> * cannot handle allocation failures.  This modifier is deprecated and no new</span>
<span class="cm"> * users should be added.</span>
<span class="cm"> *</span>
<span class="cm"> * __GFP_NORETRY: The VM implementation must not retry indefinitely.</span>
<span class="cm"> *</span>
<span class="cm"> * __GFP_MOVABLE: Flag that this page will be movable by the page migration</span>
<span class="cm"> * mechanism or reclaimed</span>
<span class="cm"> */</span>
<span class="cp">#define __GFP_WAIT	((__force gfp_t)___GFP_WAIT)	</span><span class="cm">/* Can wait and reschedule? */</span><span class="cp"></span>
<span class="cp">#define __GFP_HIGH	((__force gfp_t)___GFP_HIGH)	</span><span class="cm">/* Should access emergency pools? */</span><span class="cp"></span>
<span class="cp">#define __GFP_IO	((__force gfp_t)___GFP_IO)	</span><span class="cm">/* Can start physical IO? */</span><span class="cp"></span>
<span class="cp">#define __GFP_FS	((__force gfp_t)___GFP_FS)	</span><span class="cm">/* Can call down to low-level FS? */</span><span class="cp"></span>
<span class="cp">#define __GFP_COLD	((__force gfp_t)___GFP_COLD)	</span><span class="cm">/* Cache-cold page required */</span><span class="cp"></span>
<span class="cp">#define __GFP_NOWARN	((__force gfp_t)___GFP_NOWARN)	</span><span class="cm">/* Suppress page allocation failure warning */</span><span class="cp"></span>
<span class="cp">#define __GFP_REPEAT	((__force gfp_t)___GFP_REPEAT)	</span><span class="cm">/* See above */</span><span class="cp"></span>
<span class="cp">#define __GFP_NOFAIL	((__force gfp_t)___GFP_NOFAIL)	</span><span class="cm">/* See above */</span><span class="cp"></span>
<span class="cp">#define __GFP_NORETRY	((__force gfp_t)___GFP_NORETRY) </span><span class="cm">/* See above */</span><span class="cp"></span>
<span class="cp">#define __GFP_COMP	((__force gfp_t)___GFP_COMP)	</span><span class="cm">/* Add compound page metadata */</span><span class="cp"></span>
<span class="cp">#define __GFP_ZERO	((__force gfp_t)___GFP_ZERO)	</span><span class="cm">/* Return zeroed page on success */</span><span class="cp"></span>
<span class="cp">#define __GFP_NOMEMALLOC ((__force gfp_t)___GFP_NOMEMALLOC) </span><span class="cm">/* Don&#39;t use emergency reserves */</span><span class="cp"></span>
<span class="cp">#define __GFP_HARDWALL   ((__force gfp_t)___GFP_HARDWALL) </span><span class="cm">/* Enforce hardwall cpuset memory allocs */</span><span class="cp"></span>
<span class="cp">#define __GFP_THISNODE	((__force gfp_t)___GFP_THISNODE)</span><span class="cm">/* No fallback, no policies */</span><span class="cp"></span>
<span class="cp">#define __GFP_RECLAIMABLE ((__force gfp_t)___GFP_RECLAIMABLE) </span><span class="cm">/* Page is reclaimable */</span><span class="cp"></span>
<span class="cp">#define __GFP_NOTRACK	((__force gfp_t)___GFP_NOTRACK)  </span><span class="cm">/* Don&#39;t track with kmemcheck */</span><span class="cp"></span>

<span class="cp">#define __GFP_NO_KSWAPD	((__force gfp_t)___GFP_NO_KSWAPD)</span>
<span class="cp">#define __GFP_OTHER_NODE ((__force gfp_t)___GFP_OTHER_NODE) </span><span class="cm">/* On behalf of other node */</span><span class="cp"></span>
<span class="cp">#define __GFP_WRITE	((__force gfp_t)___GFP_WRITE)	</span><span class="cm">/* Allocator intends to dirty page */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * This may seem redundant, but it&#39;s a way of annotating false positives vs.</span>
<span class="cm"> * allocations that simply cannot be supported (e.g. page tables).</span>
<span class="cm"> */</span>
<span class="cp">#define __GFP_NOTRACK_FALSE_POSITIVE (__GFP_NOTRACK)</span>

<span class="cp">#define __GFP_BITS_SHIFT 25	</span><span class="cm">/* Room for N __GFP_FOO bits */</span><span class="cp"></span>
<span class="cp">#define __GFP_BITS_MASK ((__force gfp_t)((1 &lt;&lt; __GFP_BITS_SHIFT) - 1))</span>

<span class="cm">/* This equals 0, but use constants in case they ever change */</span>
<span class="cp">#define GFP_NOWAIT	(GFP_ATOMIC &amp; ~__GFP_HIGH)</span>
<span class="cm">/* GFP_ATOMIC means both !wait (__GFP_WAIT not set) and use emergency pool */</span>
<span class="cp">#define GFP_ATOMIC	(__GFP_HIGH)</span>
<span class="cp">#define GFP_NOIO	(__GFP_WAIT)</span>
<span class="cp">#define GFP_NOFS	(__GFP_WAIT | __GFP_IO)</span>
<span class="cp">#define GFP_KERNEL	(__GFP_WAIT | __GFP_IO | __GFP_FS)</span>
<span class="cp">#define GFP_TEMPORARY	(__GFP_WAIT | __GFP_IO | __GFP_FS | \</span>
<span class="cp">			 __GFP_RECLAIMABLE)</span>
<span class="cp">#define GFP_USER	(__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HARDWALL)</span>
<span class="cp">#define GFP_HIGHUSER	(__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HARDWALL | \</span>
<span class="cp">			 __GFP_HIGHMEM)</span>
<span class="cp">#define GFP_HIGHUSER_MOVABLE	(__GFP_WAIT | __GFP_IO | __GFP_FS | \</span>
<span class="cp">				 __GFP_HARDWALL | __GFP_HIGHMEM | \</span>
<span class="cp">				 __GFP_MOVABLE)</span>
<span class="cp">#define GFP_IOFS	(__GFP_IO | __GFP_FS)</span>
<span class="cp">#define GFP_TRANSHUGE	(GFP_HIGHUSER_MOVABLE | __GFP_COMP | \</span>
<span class="cp">			 __GFP_NOMEMALLOC | __GFP_NORETRY | __GFP_NOWARN | \</span>
<span class="cp">			 __GFP_NO_KSWAPD)</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="cp">#define GFP_THISNODE	(__GFP_THISNODE | __GFP_NOWARN | __GFP_NORETRY)</span>
<span class="cp">#else</span>
<span class="cp">#define GFP_THISNODE	((__force gfp_t)0)</span>
<span class="cp">#endif</span>

<span class="cm">/* This mask makes up all the page movable related flags */</span>
<span class="cp">#define GFP_MOVABLE_MASK (__GFP_RECLAIMABLE|__GFP_MOVABLE)</span>

<span class="cm">/* Control page allocator reclaim behavior */</span>
<span class="cp">#define GFP_RECLAIM_MASK (__GFP_WAIT|__GFP_HIGH|__GFP_IO|__GFP_FS|\</span>
<span class="cp">			__GFP_NOWARN|__GFP_REPEAT|__GFP_NOFAIL|\</span>
<span class="cp">			__GFP_NORETRY|__GFP_NOMEMALLOC)</span>

<span class="cm">/* Control slab gfp mask during early boot */</span>
<span class="cp">#define GFP_BOOT_MASK (__GFP_BITS_MASK &amp; ~(__GFP_WAIT|__GFP_IO|__GFP_FS))</span>

<span class="cm">/* Control allocation constraints */</span>
<span class="cp">#define GFP_CONSTRAINT_MASK (__GFP_HARDWALL|__GFP_THISNODE)</span>

<span class="cm">/* Do not use these with a slab allocator */</span>
<span class="cp">#define GFP_SLAB_BUG_MASK (__GFP_DMA32|__GFP_HIGHMEM|~__GFP_BITS_MASK)</span>

<span class="cm">/* Flag - indicates that the buffer will be suitable for DMA.  Ignored on some</span>
<span class="cm">   platforms, used as appropriate on others */</span>

<span class="cp">#define GFP_DMA		__GFP_DMA</span>

<span class="cm">/* 4GB DMA on some platforms */</span>
<span class="cp">#define GFP_DMA32	__GFP_DMA32</span>

<span class="cm">/* Convert GFP flags to their corresponding migrate type */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">allocflags_to_migratetype</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="n">gfp_flags</span> <span class="o">&amp;</span> <span class="n">GFP_MOVABLE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">GFP_MOVABLE_MASK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page_group_by_mobility_disabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">MIGRATE_UNMOVABLE</span><span class="p">;</span>

	<span class="cm">/* Group based on mobility */</span>
	<span class="k">return</span> <span class="p">(((</span><span class="n">gfp_flags</span> <span class="o">&amp;</span> <span class="n">__GFP_MOVABLE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">gfp_flags</span> <span class="o">&amp;</span> <span class="n">__GFP_RECLAIMABLE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
<span class="cp">#define OPT_ZONE_HIGHMEM ZONE_HIGHMEM</span>
<span class="cp">#else</span>
<span class="cp">#define OPT_ZONE_HIGHMEM ZONE_NORMAL</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ZONE_DMA</span>
<span class="cp">#define OPT_ZONE_DMA ZONE_DMA</span>
<span class="cp">#else</span>
<span class="cp">#define OPT_ZONE_DMA ZONE_NORMAL</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ZONE_DMA32</span>
<span class="cp">#define OPT_ZONE_DMA32 ZONE_DMA32</span>
<span class="cp">#else</span>
<span class="cp">#define OPT_ZONE_DMA32 ZONE_NORMAL</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * GFP_ZONE_TABLE is a word size bitstring that is used for looking up the</span>
<span class="cm"> * zone to use given the lowest 4 bits of gfp_t. Entries are ZONE_SHIFT long</span>
<span class="cm"> * and there are 16 of them to cover all possible combinations of</span>
<span class="cm"> * __GFP_DMA, __GFP_DMA32, __GFP_MOVABLE and __GFP_HIGHMEM.</span>
<span class="cm"> *</span>
<span class="cm"> * The zone fallback order is MOVABLE=&gt;HIGHMEM=&gt;NORMAL=&gt;DMA32=&gt;DMA.</span>
<span class="cm"> * But GFP_MOVABLE is not only a zone specifier but also an allocation</span>
<span class="cm"> * policy. Therefore __GFP_MOVABLE plus another zone selector is valid.</span>
<span class="cm"> * Only 1 bit of the lowest 3 bits (DMA,DMA32,HIGHMEM) can be set to &quot;1&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> *       bit       result</span>
<span class="cm"> *       =================</span>
<span class="cm"> *       0x0    =&gt; NORMAL</span>
<span class="cm"> *       0x1    =&gt; DMA or NORMAL</span>
<span class="cm"> *       0x2    =&gt; HIGHMEM or NORMAL</span>
<span class="cm"> *       0x3    =&gt; BAD (DMA+HIGHMEM)</span>
<span class="cm"> *       0x4    =&gt; DMA32 or DMA or NORMAL</span>
<span class="cm"> *       0x5    =&gt; BAD (DMA+DMA32)</span>
<span class="cm"> *       0x6    =&gt; BAD (HIGHMEM+DMA32)</span>
<span class="cm"> *       0x7    =&gt; BAD (HIGHMEM+DMA32+DMA)</span>
<span class="cm"> *       0x8    =&gt; NORMAL (MOVABLE+0)</span>
<span class="cm"> *       0x9    =&gt; DMA or NORMAL (MOVABLE+DMA)</span>
<span class="cm"> *       0xa    =&gt; MOVABLE (Movable is valid only if HIGHMEM is set too)</span>
<span class="cm"> *       0xb    =&gt; BAD (MOVABLE+HIGHMEM+DMA)</span>
<span class="cm"> *       0xc    =&gt; DMA32 (MOVABLE+HIGHMEM+DMA32)</span>
<span class="cm"> *       0xd    =&gt; BAD (MOVABLE+DMA32+DMA)</span>
<span class="cm"> *       0xe    =&gt; BAD (MOVABLE+DMA32+HIGHMEM)</span>
<span class="cm"> *       0xf    =&gt; BAD (MOVABLE+DMA32+HIGHMEM+DMA)</span>
<span class="cm"> *</span>
<span class="cm"> * ZONES_SHIFT must be &lt;= 2 on 32 bit platforms.</span>
<span class="cm"> */</span>

<span class="cp">#if 16 * ZONES_SHIFT &gt; BITS_PER_LONG</span>
<span class="cp">#error ZONES_SHIFT too large to create GFP_ZONE_TABLE integer</span>
<span class="cp">#endif</span>

<span class="cp">#define GFP_ZONE_TABLE ( \</span>
<span class="cp">	(ZONE_NORMAL &lt;&lt; 0 * ZONES_SHIFT)				      \</span>
<span class="cp">	| (OPT_ZONE_DMA &lt;&lt; ___GFP_DMA * ZONES_SHIFT)			      \</span>
<span class="cp">	| (OPT_ZONE_HIGHMEM &lt;&lt; ___GFP_HIGHMEM * ZONES_SHIFT)		      \</span>
<span class="cp">	| (OPT_ZONE_DMA32 &lt;&lt; ___GFP_DMA32 * ZONES_SHIFT)		      \</span>
<span class="cp">	| (ZONE_NORMAL &lt;&lt; ___GFP_MOVABLE * ZONES_SHIFT)			      \</span>
<span class="cp">	| (OPT_ZONE_DMA &lt;&lt; (___GFP_MOVABLE | ___GFP_DMA) * ZONES_SHIFT)	      \</span>
<span class="cp">	| (ZONE_MOVABLE &lt;&lt; (___GFP_MOVABLE | ___GFP_HIGHMEM) * ZONES_SHIFT)   \</span>
<span class="cp">	| (OPT_ZONE_DMA32 &lt;&lt; (___GFP_MOVABLE | ___GFP_DMA32) * ZONES_SHIFT)   \</span>
<span class="cp">)</span>

<span class="cm">/*</span>
<span class="cm"> * GFP_ZONE_BAD is a bitmap for all combinations of __GFP_DMA, __GFP_DMA32</span>
<span class="cm"> * __GFP_HIGHMEM and __GFP_MOVABLE that are not permitted. One flag per</span>
<span class="cm"> * entry starting with bit 0. Bit is set if the combination is not</span>
<span class="cm"> * allowed.</span>
<span class="cm"> */</span>
<span class="cp">#define GFP_ZONE_BAD ( \</span>
<span class="cp">	1 &lt;&lt; (___GFP_DMA | ___GFP_HIGHMEM)				      \</span>
<span class="cp">	| 1 &lt;&lt; (___GFP_DMA | ___GFP_DMA32)				      \</span>
<span class="cp">	| 1 &lt;&lt; (___GFP_DMA32 | ___GFP_HIGHMEM)				      \</span>
<span class="cp">	| 1 &lt;&lt; (___GFP_DMA | ___GFP_DMA32 | ___GFP_HIGHMEM)		      \</span>
<span class="cp">	| 1 &lt;&lt; (___GFP_MOVABLE | ___GFP_HIGHMEM | ___GFP_DMA)		      \</span>
<span class="cp">	| 1 &lt;&lt; (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_DMA)		      \</span>
<span class="cp">	| 1 &lt;&lt; (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_HIGHMEM)		      \</span>
<span class="cp">	| 1 &lt;&lt; (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_DMA | ___GFP_HIGHMEM)  \</span>
<span class="cp">)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">zone_type</span> <span class="nf">gfp_zone</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">zone_type</span> <span class="n">z</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GFP_ZONEMASK</span><span class="p">);</span>

	<span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">GFP_ZONE_TABLE</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">bit</span> <span class="o">*</span> <span class="n">ZONES_SHIFT</span><span class="p">))</span> <span class="o">&amp;</span>
					 <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ZONES_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">((</span><span class="n">GFP_ZONE_BAD</span> <span class="o">&gt;&gt;</span> <span class="n">bit</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * There is only one page-allocator function, and two main namespaces to</span>
<span class="cm"> * it. The alloc_page*() variants return &#39;struct page *&#39; and as such</span>
<span class="cm"> * can allocate highmem pages, the *get*page*() variants return</span>
<span class="cm"> * virtual kernel addresses to the allocated page(s).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">gfp_zonelist</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NUMA_BUILD</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__GFP_THISNODE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We get the zone list from the current node and the gfp_mask.</span>
<span class="cm"> * This zone list contains a maximum of MAXNODES*MAX_NR_ZONES zones.</span>
<span class="cm"> * There are two zonelists per node, one for all zones with memory and</span>
<span class="cm"> * one containing just zones from the node the zonelist belongs to.</span>
<span class="cm"> *</span>
<span class="cm"> * For the normal case of non-DISCONTIGMEM systems the NODE_DATA() gets</span>
<span class="cm"> * optimized to &amp;contig_page_data at compile-time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="nf">node_zonelist</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_zonelists</span> <span class="o">+</span> <span class="n">gfp_zonelist</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef HAVE_ARCH_FREE_PAGE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">arch_free_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef HAVE_ARCH_ALLOC_PAGE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">arch_alloc_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="n">__alloc_pages_nodemask</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="nf">__alloc_pages</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__alloc_pages_nodemask</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">zonelist</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">alloc_pages_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Unknown node is current node */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">numa_node_id</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">__alloc_pages</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">node_zonelist</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">alloc_pages_exact_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">nid</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nid</span> <span class="o">&gt;=</span> <span class="n">MAX_NUMNODES</span> <span class="o">||</span> <span class="o">!</span><span class="n">node_online</span><span class="p">(</span><span class="n">nid</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">__alloc_pages</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">node_zonelist</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">alloc_pages_current</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">order</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="nf">alloc_pages</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">alloc_pages_current</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">alloc_pages_vma</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define alloc_pages(gfp_mask, order) \</span>
<span class="cp">		alloc_pages_node(numa_node_id(), gfp_mask, order)</span>
<span class="cp">#define alloc_pages_vma(gfp_mask, order, vma, addr, node)	\</span>
<span class="cp">	alloc_pages(gfp_mask, order)</span>
<span class="cp">#endif</span>
<span class="cp">#define alloc_page(gfp_mask) alloc_pages(gfp_mask, 0)</span>
<span class="cp">#define alloc_page_vma(gfp_mask, vma, addr)			\</span>
<span class="cp">	alloc_pages_vma(gfp_mask, 0, vma, addr, numa_node_id())</span>
<span class="cp">#define alloc_page_vma_node(gfp_mask, vma, addr, node)		\</span>
<span class="cp">	alloc_pages_vma(gfp_mask, 0, vma, addr, node)</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">alloc_pages_exact</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">free_pages_exact</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">virt</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="cm">/* This is different from alloc_pages_exact_node !!! */</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">alloc_pages_exact_nid</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>

<span class="cp">#define __get_free_page(gfp_mask) \</span>
<span class="cp">		__get_free_pages((gfp_mask), 0)</span>

<span class="cp">#define __get_dma_pages(gfp_mask, order) \</span>
<span class="cp">		__get_free_pages((gfp_mask) | GFP_DMA, (order))</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__free_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_hot_cold_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cold</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_hot_cold_page_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cold</span><span class="p">);</span>

<span class="cp">#define __free_page(page) __free_pages((page), 0)</span>
<span class="cp">#define free_page(addr) free_pages((addr), 0)</span>

<span class="kt">void</span> <span class="n">page_alloc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drain_zone_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="k">struct</span> <span class="n">per_cpu_pages</span> <span class="o">*</span><span class="n">pcp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drain_all_pages</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drain_local_pages</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * gfp_allowed_mask is set to GFP_BOOT_MASK during early boot to restrict what</span>
<span class="cm"> * GFP flags are used before interrupts are enabled. Once interrupts are</span>
<span class="cm"> * enabled, it is set to __GFP_BITS_MASK while the system is running. During</span>
<span class="cm"> * hibernation, it is used by PM to avoid I/O during memory allocation while</span>
<span class="cm"> * devices are suspended.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">gfp_t</span> <span class="n">gfp_allowed_mask</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">pm_restrict_gfp_mask</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pm_restore_gfp_mask</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">pm_suspended_storage</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">pm_suspended_storage</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM_SLEEP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_CMA</span>

<span class="cm">/* The below functions must be run on a range from a single zone. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">alloc_contig_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="n">migratetype</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_contig_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">);</span>

<span class="cm">/* CMA stuff */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">init_cma_reserved_pageblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __LINUX_GFP_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
