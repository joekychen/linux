<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › ipc_namespace.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ipc_namespace.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __IPC_NAMESPACE_H__</span>
<span class="cp">#define __IPC_NAMESPACE_H__</span>

<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * ipc namespace events</span>
<span class="cm"> */</span>
<span class="cp">#define IPCNS_MEMCHANGED   0x00000001   </span><span class="cm">/* Notify lowmem size changed */</span><span class="cp"></span>
<span class="cp">#define IPCNS_CREATED  0x00000002   </span><span class="cm">/* Notify new ipc namespace created */</span><span class="cp"></span>
<span class="cp">#define IPCNS_REMOVED  0x00000003   </span><span class="cm">/* Notify ipc namespace removed */</span><span class="cp"></span>

<span class="cp">#define IPCNS_CALLBACK_PRI 0</span>

<span class="k">struct</span> <span class="n">user_namespace</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ipc_ids</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">in_use</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">seq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">seq_max</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">rw_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idr</span> <span class="n">ipcs_idr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="p">{</span>
	<span class="n">atomic_t</span>	<span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipc_ids</span>	<span class="n">ids</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="kt">int</span>		<span class="n">sem_ctls</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">int</span>		<span class="n">used_sems</span><span class="p">;</span>

	<span class="kt">int</span>		<span class="n">msg_ctlmax</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">msg_ctlmnb</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">msg_ctlmni</span><span class="p">;</span>
	<span class="n">atomic_t</span>	<span class="n">msg_bytes</span><span class="p">;</span>
	<span class="n">atomic_t</span>	<span class="n">msg_hdrs</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">auto_msgmni</span><span class="p">;</span>

	<span class="kt">size_t</span>		<span class="n">shm_ctlmax</span><span class="p">;</span>
	<span class="kt">size_t</span>		<span class="n">shm_ctlall</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">shm_ctlmni</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">shm_tot</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Defines whether IPC_RMID is forced for _all_ shm segments regardless</span>
<span class="cm">	 * of shmctl()</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>		<span class="n">shm_rmid_forced</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">ipcns_nb</span><span class="p">;</span>

	<span class="cm">/* The kern_mount of the mqueuefs sb.  We take a ref on it */</span>
	<span class="k">struct</span> <span class="n">vfsmount</span>	<span class="o">*</span><span class="n">mq_mnt</span><span class="p">;</span>

	<span class="cm">/* # queues in this ns, protected by mq_lock */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">mq_queues_count</span><span class="p">;</span>

	<span class="cm">/* next fields are set through sysctl */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">mq_queues_max</span><span class="p">;</span>   <span class="cm">/* initialized to DFLT_QUEUESMAX */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">mq_msg_max</span><span class="p">;</span>      <span class="cm">/* initialized to DFLT_MSGMAX */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">mq_msgsize_max</span><span class="p">;</span>  <span class="cm">/* initialized to DFLT_MSGSIZEMAX */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">mq_msg_default</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">mq_msgsize_default</span><span class="p">;</span>

	<span class="cm">/* user_ns which owns the ipc ns */</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">user_ns</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="n">init_ipc_ns</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">atomic_t</span> <span class="n">nr_ipc_ns</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">spinlock_t</span> <span class="n">mq_lock</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SYSVIPC</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">register_ipcns_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cond_register_ipcns_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">unregister_ipcns_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ipcns_notify</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">shm_destroy_orphaned</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_SYSVIPC */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">register_ipcns_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cond_register_ipcns_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unregister_ipcns_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ipcns_notify</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">shm_destroy_orphaned</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SYSVIPC */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_POSIX_MQUEUE</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">mq_init_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * POSIX Message Queue default values:</span>
<span class="cm"> *</span>
<span class="cm"> * MIN_*: Lowest value an admin can set the maximum unprivileged limit to</span>
<span class="cm"> * DFLT_*MAX: Default values for the maximum unprivileged limits</span>
<span class="cm"> * DFLT_{MSG,MSGSIZE}: Default values used when the user doesn&#39;t supply</span>
<span class="cm"> *   an attribute to the open call and the queue must be created</span>
<span class="cm"> * HARD_*: Highest value the maximums can be set to.  These are enforced</span>
<span class="cm"> *   on CAP_SYS_RESOURCE apps as well making them inviolate (so make them</span>
<span class="cm"> *   suitably high)</span>
<span class="cm"> *</span>
<span class="cm"> * POSIX Requirements:</span>
<span class="cm"> *   Per app minimum openable message queues - 8.  This does not map well</span>
<span class="cm"> *     to the fact that we limit the number of queues on a per namespace</span>
<span class="cm"> *     basis instead of a per app basis.  So, make the default high enough</span>
<span class="cm"> *     that no given app should have a hard time opening 8 queues.</span>
<span class="cm"> *   Minimum maximum for HARD_MSGMAX - 32767.  I bumped this to 65536.</span>
<span class="cm"> *   Minimum maximum for HARD_MSGSIZEMAX - POSIX is silent on this.  However,</span>
<span class="cm"> *     we have run into a situation where running applications in the wild</span>
<span class="cm"> *     require this to be at least 5MB, and preferably 10MB, so I set the</span>
<span class="cm"> *     value to 16MB in hopes that this user is the worst of the bunch and</span>
<span class="cm"> *     the new maximum will handle anyone else.  I may have to revisit this</span>
<span class="cm"> *     in the future.</span>
<span class="cm"> */</span>
<span class="cp">#define MIN_QUEUESMAX			1</span>
<span class="cp">#define DFLT_QUEUESMAX		      256</span>
<span class="cp">#define HARD_QUEUESMAX		     1024</span>
<span class="cp">#define MIN_MSGMAX			1</span>
<span class="cp">#define DFLT_MSG		       10U</span>
<span class="cp">#define DFLT_MSGMAX		       10</span>
<span class="cp">#define HARD_MSGMAX		    65536</span>
<span class="cp">#define MIN_MSGSIZEMAX		      128</span>
<span class="cp">#define DFLT_MSGSIZE		     8192U</span>
<span class="cp">#define DFLT_MSGSIZEMAX		     8192</span>
<span class="cp">#define HARD_MSGSIZEMAX	    (16*1024*1024)</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mq_init_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_IPC_NS)</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">copy_ipcs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="nf">get_ipc_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ns</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">put_ipc_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="nf">copy_ipcs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLONE_NEWIPC</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">ipc_ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="nf">get_ipc_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_ipc_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_POSIX_MQUEUE_SYSCTL</span>

<span class="k">struct</span> <span class="n">ctl_table_header</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ctl_table_header</span> <span class="o">*</span><span class="n">mq_register_sysctl_table</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_POSIX_MQUEUE_SYSCTL */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ctl_table_header</span> <span class="o">*</span><span class="nf">mq_register_sysctl_table</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_POSIX_MQUEUE_SYSCTL */</span><span class="cp"></span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
