<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › aio.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>aio.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __LINUX__AIO_H</span>
<span class="cp">#define __LINUX__AIO_H</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/aio_abi.h&gt;</span>
<span class="cp">#include &lt;linux/uio.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cp">#define AIO_MAXSEGS		4</span>
<span class="cp">#define AIO_KIOGRP_NR_ATOMIC	8</span>

<span class="k">struct</span> <span class="n">kioctx</span><span class="p">;</span>

<span class="cm">/* Notes on cancelling a kiocb:</span>
<span class="cm"> *	If a kiocb is cancelled, aio_complete may return 0 to indicate </span>
<span class="cm"> *	that cancel has not yet disposed of the kiocb.  All cancel </span>
<span class="cm"> *	operations *must* call aio_put_req to dispose of the kiocb </span>
<span class="cm"> *	to guard against races with the completion code.</span>
<span class="cm"> */</span>
<span class="cp">#define KIOCB_C_CANCELLED	0x01</span>
<span class="cp">#define KIOCB_C_COMPLETE	0x02</span>

<span class="cp">#define KIOCB_SYNC_KEY		(~0U)</span>

<span class="cm">/* ki_flags bits */</span>
<span class="cm">/*</span>
<span class="cm"> * This may be used for cancel/retry serialization in the future, but</span>
<span class="cm"> * for now it&#39;s unused and we probably don&#39;t want modules to even</span>
<span class="cm"> * think they can use it.</span>
<span class="cm"> */</span>
<span class="cm">/* #define KIF_LOCKED		0 */</span>
<span class="cp">#define KIF_KICKED		1</span>
<span class="cp">#define KIF_CANCELLED		2</span>

<span class="cp">#define kiocbTryLock(iocb)	test_and_set_bit(KIF_LOCKED, &amp;(iocb)-&gt;ki_flags)</span>
<span class="cp">#define kiocbTryKick(iocb)	test_and_set_bit(KIF_KICKED, &amp;(iocb)-&gt;ki_flags)</span>

<span class="cp">#define kiocbSetLocked(iocb)	set_bit(KIF_LOCKED, &amp;(iocb)-&gt;ki_flags)</span>
<span class="cp">#define kiocbSetKicked(iocb)	set_bit(KIF_KICKED, &amp;(iocb)-&gt;ki_flags)</span>
<span class="cp">#define kiocbSetCancelled(iocb)	set_bit(KIF_CANCELLED, &amp;(iocb)-&gt;ki_flags)</span>

<span class="cp">#define kiocbClearLocked(iocb)	clear_bit(KIF_LOCKED, &amp;(iocb)-&gt;ki_flags)</span>
<span class="cp">#define kiocbClearKicked(iocb)	clear_bit(KIF_KICKED, &amp;(iocb)-&gt;ki_flags)</span>
<span class="cp">#define kiocbClearCancelled(iocb)	clear_bit(KIF_CANCELLED, &amp;(iocb)-&gt;ki_flags)</span>

<span class="cp">#define kiocbIsLocked(iocb)	test_bit(KIF_LOCKED, &amp;(iocb)-&gt;ki_flags)</span>
<span class="cp">#define kiocbIsKicked(iocb)	test_bit(KIF_KICKED, &amp;(iocb)-&gt;ki_flags)</span>
<span class="cp">#define kiocbIsCancelled(iocb)	test_bit(KIF_CANCELLED, &amp;(iocb)-&gt;ki_flags)</span>

<span class="cm">/* is there a better place to document function pointer methods? */</span>
<span class="cm">/**</span>
<span class="cm"> * ki_retry	-	iocb forward progress callback</span>
<span class="cm"> * @kiocb:	The kiocb struct to advance by performing an operation.</span>
<span class="cm"> *</span>
<span class="cm"> * This callback is called when the AIO core wants a given AIO operation</span>
<span class="cm"> * to make forward progress.  The kiocb argument describes the operation</span>
<span class="cm"> * that is to be performed.  As the operation proceeds, perhaps partially,</span>
<span class="cm"> * ki_retry is expected to update the kiocb with progress made.  Typically</span>
<span class="cm"> * ki_retry is set in the AIO core and it itself calls file_operations</span>
<span class="cm"> * helpers.</span>
<span class="cm"> *</span>
<span class="cm"> * ki_retry&#39;s return value determines when the AIO operation is completed</span>
<span class="cm"> * and an event is generated in the AIO event ring.  Except the special</span>
<span class="cm"> * return values described below, the value that is returned from ki_retry</span>
<span class="cm"> * is transferred directly into the completion ring as the operation&#39;s</span>
<span class="cm"> * resulting status.  Once this has happened ki_retry *MUST NOT* reference</span>
<span class="cm"> * the kiocb pointer again.</span>
<span class="cm"> *</span>
<span class="cm"> * If ki_retry returns -EIOCBQUEUED it has made a promise that aio_complete()</span>
<span class="cm"> * will be called on the kiocb pointer in the future.  The AIO core will</span>
<span class="cm"> * not ask the method again -- ki_retry must ensure forward progress.</span>
<span class="cm"> * aio_complete() must be called once and only once in the future, multiple</span>
<span class="cm"> * calls may result in undefined behaviour.</span>
<span class="cm"> *</span>
<span class="cm"> * If ki_retry returns -EIOCBRETRY it has made a promise that kick_iocb()</span>
<span class="cm"> * will be called on the kiocb pointer in the future.  This may happen</span>
<span class="cm"> * through generic helpers that associate kiocb-&gt;ki_wait with a wait</span>
<span class="cm"> * queue head that ki_retry uses via current-&gt;io_wait.  It can also happen</span>
<span class="cm"> * with custom tracking and manual calls to kick_iocb(), though that is</span>
<span class="cm"> * discouraged.  In either case, kick_iocb() must be called once and only</span>
<span class="cm"> * once.  ki_retry must ensure forward progress, the AIO core will wait</span>
<span class="cm"> * indefinitely for kick_iocb() to be called.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kiocb</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ki_run_list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ki_flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ki_users</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">ki_key</span><span class="p">;</span>		<span class="cm">/* id of this request */</span>

	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kioctx</span>		<span class="o">*</span><span class="n">ki_ctx</span><span class="p">;</span>	<span class="cm">/* may be NULL for sync ops */</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ki_cancel</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_event</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">ssize_t</span>			<span class="p">(</span><span class="o">*</span><span class="n">ki_retry</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">ki_dtor</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="n">__user</span>		<span class="o">*</span><span class="n">user</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ki_obj</span><span class="p">;</span>

	<span class="n">__u64</span>			<span class="n">ki_user_data</span><span class="p">;</span>	<span class="cm">/* user&#39;s data for completion */</span>
	<span class="n">loff_t</span>			<span class="n">ki_pos</span><span class="p">;</span>

	<span class="kt">void</span>			<span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="cm">/* State that we remember to be able to restart/retry  */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">ki_opcode</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">ki_nbytes</span><span class="p">;</span> 	<span class="cm">/* copy of iocb-&gt;aio_nbytes */</span>
	<span class="kt">char</span> 			<span class="n">__user</span> <span class="o">*</span><span class="n">ki_buf</span><span class="p">;</span>	<span class="cm">/* remaining iocb-&gt;aio_buf */</span>
	<span class="kt">size_t</span>			<span class="n">ki_left</span><span class="p">;</span> 	<span class="cm">/* remaining bytes */</span>
	<span class="k">struct</span> <span class="n">iovec</span>		<span class="n">ki_inline_vec</span><span class="p">;</span>	<span class="cm">/* inline vector */</span>
 	<span class="k">struct</span> <span class="n">iovec</span>		<span class="o">*</span><span class="n">ki_iovec</span><span class="p">;</span>
 	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ki_nr_segs</span><span class="p">;</span>
 	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ki_cur_seg</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ki_list</span><span class="p">;</span>	<span class="cm">/* the aio core uses this</span>
<span class="cm">						 * for cancellation */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ki_batch</span><span class="p">;</span>	<span class="cm">/* batch allocation */</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the aio_resfd field of the userspace iocb is not zero,</span>
<span class="cm">	 * this is the underlying eventfd context to deliver events to.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">eventfd_ctx</span>	<span class="o">*</span><span class="n">ki_eventfd</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define is_sync_kiocb(iocb)	((iocb)-&gt;ki_key == KIOCB_SYNC_KEY)</span>
<span class="cp">#define init_sync_kiocb(x, filp)			\</span>
<span class="cp">	do {						\</span>
<span class="cp">		struct task_struct *tsk = current;	\</span>
<span class="cp">		(x)-&gt;ki_flags = 0;			\</span>
<span class="cp">		(x)-&gt;ki_users = 1;			\</span>
<span class="cp">		(x)-&gt;ki_key = KIOCB_SYNC_KEY;		\</span>
<span class="cp">		(x)-&gt;ki_filp = (filp);			\</span>
<span class="cp">		(x)-&gt;ki_ctx = NULL;			\</span>
<span class="cp">		(x)-&gt;ki_cancel = NULL;			\</span>
<span class="cp">		(x)-&gt;ki_retry = NULL;			\</span>
<span class="cp">		(x)-&gt;ki_dtor = NULL;			\</span>
<span class="cp">		(x)-&gt;ki_obj.tsk = tsk;			\</span>
<span class="cp">		(x)-&gt;ki_user_data = 0;                  \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define AIO_RING_MAGIC			0xa10a10a1</span>
<span class="cp">#define AIO_RING_COMPAT_FEATURES	1</span>
<span class="cp">#define AIO_RING_INCOMPAT_FEATURES	0</span>
<span class="k">struct</span> <span class="n">aio_ring</span> <span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">id</span><span class="p">;</span>	<span class="cm">/* kernel internal index number */</span>
	<span class="kt">unsigned</span>	<span class="n">nr</span><span class="p">;</span>	<span class="cm">/* number of io_events */</span>
	<span class="kt">unsigned</span>	<span class="n">head</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">tail</span><span class="p">;</span>

	<span class="kt">unsigned</span>	<span class="n">magic</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">compat_features</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">incompat_features</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">header_length</span><span class="p">;</span>	<span class="cm">/* size of aio_ring */</span>


	<span class="k">struct</span> <span class="n">io_event</span>		<span class="n">io_events</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span> <span class="cm">/* 128 bytes + ring size */</span>

<span class="cp">#define aio_ring_avail(info, ring)	(((ring)-&gt;head + (info)-&gt;nr - 1 - (ring)-&gt;tail) % (info)-&gt;nr)</span>

<span class="cp">#define AIO_RING_PAGES	8</span>
<span class="k">struct</span> <span class="n">aio_ring_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">mmap_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">mmap_size</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">page</span>		<span class="o">**</span><span class="n">ring_pages</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">ring_lock</span><span class="p">;</span>
	<span class="kt">long</span>			<span class="n">nr_pages</span><span class="p">;</span>

	<span class="kt">unsigned</span>		<span class="n">nr</span><span class="p">,</span> <span class="n">tail</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">internal_pages</span><span class="p">[</span><span class="n">AIO_RING_PAGES</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kioctx</span> <span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">users</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">dead</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span>	<span class="o">*</span><span class="n">mm</span><span class="p">;</span>

	<span class="cm">/* This needs improving */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">user_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">list</span><span class="p">;</span>

	<span class="n">wait_queue_head_t</span>	<span class="n">wait</span><span class="p">;</span>

	<span class="n">spinlock_t</span>		<span class="n">ctx_lock</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">reqs_active</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">active_reqs</span><span class="p">;</span>	<span class="cm">/* used for cancellation */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">run_list</span><span class="p">;</span>	<span class="cm">/* used for kicked reqs */</span>

	<span class="cm">/* sys_io_setup currently limits this to an unsigned int */</span>
	<span class="kt">unsigned</span>		<span class="n">max_reqs</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">aio_ring_info</span>	<span class="n">ring_info</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">wq</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">rcu_head</span>		<span class="n">rcu_head</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* prototypes */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="n">aio_max_size</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_AIO</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">wait_on_sync_kiocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">aio_put_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">kick_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">aio_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="kt">long</span> <span class="n">res</span><span class="p">,</span> <span class="kt">long</span> <span class="n">res2</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">mm_struct</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">exit_aio</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">do_io_submit</span><span class="p">(</span><span class="n">aio_context_t</span> <span class="n">ctx_id</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">iocb</span> <span class="n">__user</span> <span class="o">*</span><span class="n">__user</span> <span class="o">*</span><span class="n">iocbpp</span><span class="p">,</span> <span class="n">bool</span> <span class="n">compat</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">ssize_t</span> <span class="nf">wait_on_sync_kiocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">aio_put_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kick_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">aio_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="kt">long</span> <span class="n">res</span><span class="p">,</span> <span class="kt">long</span> <span class="n">res2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">struct</span> <span class="n">mm_struct</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">exit_aio</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">do_io_submit</span><span class="p">(</span><span class="n">aio_context_t</span> <span class="n">ctx_id</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">iocb</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">__user</span> <span class="o">*</span><span class="n">iocbpp</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">compat</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_AIO */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="nf">list_kiocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span><span class="p">,</span> <span class="n">ki_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* for sysctl: */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">aio_nr</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">aio_max_nr</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* __LINUX__AIO_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
