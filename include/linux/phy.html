<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › phy.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>phy.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * include/linux/phy.h</span>
<span class="cm"> *</span>
<span class="cm"> * Framework and drivers for configuring and reading different PHYs</span>
<span class="cm"> * Based on code in sungem_phy.c and gianfar_phy.c</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Andy Fleming</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2004 Freescale Semiconductor, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute  it and/or modify it</span>
<span class="cm"> * under  the terms of  the GNU General  Public License as published by the</span>
<span class="cm"> * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __PHY_H</span>
<span class="cp">#define __PHY_H</span>

<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/mod_devicetable.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cp">#define PHY_BASIC_FEATURES	(SUPPORTED_10baseT_Half | \</span>
<span class="cp">				 SUPPORTED_10baseT_Full | \</span>
<span class="cp">				 SUPPORTED_100baseT_Half | \</span>
<span class="cp">				 SUPPORTED_100baseT_Full | \</span>
<span class="cp">				 SUPPORTED_Autoneg | \</span>
<span class="cp">				 SUPPORTED_TP | \</span>
<span class="cp">				 SUPPORTED_MII)</span>

<span class="cp">#define PHY_GBIT_FEATURES	(PHY_BASIC_FEATURES | \</span>
<span class="cp">				 SUPPORTED_1000baseT_Half | \</span>
<span class="cp">				 SUPPORTED_1000baseT_Full)</span>

<span class="cm">/*</span>
<span class="cm"> * Set phydev-&gt;irq to PHY_POLL if interrupts are not supported,</span>
<span class="cm"> * or not desired for this PHY.  Set to PHY_IGNORE_INTERRUPT if</span>
<span class="cm"> * the attached driver handles the interrupt</span>
<span class="cm"> */</span>
<span class="cp">#define PHY_POLL		-1</span>
<span class="cp">#define PHY_IGNORE_INTERRUPT	-2</span>

<span class="cp">#define PHY_HAS_INTERRUPT	0x00000001</span>
<span class="cp">#define PHY_HAS_MAGICANEG	0x00000002</span>

<span class="cm">/* Interface Mode definitions */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">PHY_INTERFACE_MODE_NA</span><span class="p">,</span>
	<span class="n">PHY_INTERFACE_MODE_MII</span><span class="p">,</span>
	<span class="n">PHY_INTERFACE_MODE_GMII</span><span class="p">,</span>
	<span class="n">PHY_INTERFACE_MODE_SGMII</span><span class="p">,</span>
	<span class="n">PHY_INTERFACE_MODE_TBI</span><span class="p">,</span>
	<span class="n">PHY_INTERFACE_MODE_RMII</span><span class="p">,</span>
	<span class="n">PHY_INTERFACE_MODE_RGMII</span><span class="p">,</span>
	<span class="n">PHY_INTERFACE_MODE_RGMII_ID</span><span class="p">,</span>
	<span class="n">PHY_INTERFACE_MODE_RGMII_RXID</span><span class="p">,</span>
	<span class="n">PHY_INTERFACE_MODE_RGMII_TXID</span><span class="p">,</span>
	<span class="n">PHY_INTERFACE_MODE_RTBI</span><span class="p">,</span>
	<span class="n">PHY_INTERFACE_MODE_SMII</span><span class="p">,</span>
<span class="p">}</span> <span class="n">phy_interface_t</span><span class="p">;</span>


<span class="cp">#define PHY_INIT_TIMEOUT	100000</span>
<span class="cp">#define PHY_STATE_TIME		1</span>
<span class="cp">#define PHY_FORCE_TIMEOUT	10</span>
<span class="cp">#define PHY_AN_TIMEOUT		10</span>

<span class="cp">#define PHY_MAX_ADDR	32</span>

<span class="cm">/* Used when trying to connect to a specific phy (mii bus id:phy device id) */</span>
<span class="cp">#define PHY_ID_FMT &quot;%s:%02x&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Need to be a little smaller than phydev-&gt;dev.bus_id to leave room</span>
<span class="cm"> * for the &quot;:%02x&quot;</span>
<span class="cm"> */</span>
<span class="cp">#define MII_BUS_ID_SIZE	(20 - 3)</span>

<span class="cm">/* Or MII_ADDR_C45 into regnum for read/write on mii_bus to enable the 21 bit</span>
<span class="cm">   IEEE 802.3ae clause 45 addressing mode used by 10GIGE phy chips. */</span>
<span class="cp">#define MII_ADDR_C45 (1&lt;&lt;30)</span>

<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sk_buff</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The Bus class for PHYs.  Devices which provide access to</span>
<span class="cm"> * PHYs should register using this structure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mii_bus</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">id</span><span class="p">[</span><span class="n">MII_BUS_ID_SIZE</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">regnum</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">regnum</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * A lock to ensure that only one thing can read/write</span>
<span class="cm">	 * the MDIO bus at a time</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mdio_lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">MDIOBUS_ALLOCATED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="n">MDIOBUS_REGISTERED</span><span class="p">,</span>
		<span class="n">MDIOBUS_UNREGISTERED</span><span class="p">,</span>
		<span class="n">MDIOBUS_RELEASED</span><span class="p">,</span>
	<span class="p">}</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* list of all PHYs on bus */</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phy_map</span><span class="p">[</span><span class="n">PHY_MAX_ADDR</span><span class="p">];</span>

	<span class="cm">/* PHY addresses to be ignored when probing */</span>
	<span class="n">u32</span> <span class="n">phy_mask</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Pointer to an array of interrupts, each PHY&#39;s</span>
<span class="cm">	 * interrupt at the index matching its address</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">irq</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define to_mii_bus(d) container_of(d, struct mii_bus, dev)</span>

<span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">mdiobus_alloc_size</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="nf">mdiobus_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mdiobus_alloc_size</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">mdiobus_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mdiobus_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mdiobus_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">mdiobus_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">mdiobus_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">regnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">mdiobus_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">regnum</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">);</span>


<span class="cp">#define PHY_INTERRUPT_DISABLED	0x0</span>
<span class="cp">#define PHY_INTERRUPT_ENABLED	0x80000000</span>

<span class="cm">/* PHY state machine states:</span>
<span class="cm"> *</span>
<span class="cm"> * DOWN: PHY device and driver are not ready for anything.  probe</span>
<span class="cm"> * should be called if and only if the PHY is in this state,</span>
<span class="cm"> * given that the PHY device exists.</span>
<span class="cm"> * - PHY driver probe function will, depending on the PHY, set</span>
<span class="cm"> * the state to STARTING or READY</span>
<span class="cm"> *</span>
<span class="cm"> * STARTING:  PHY device is coming up, and the ethernet driver is</span>
<span class="cm"> * not ready.  PHY drivers may set this in the probe function.</span>
<span class="cm"> * If they do, they are responsible for making sure the state is</span>
<span class="cm"> * eventually set to indicate whether the PHY is UP or READY,</span>
<span class="cm"> * depending on the state when the PHY is done starting up.</span>
<span class="cm"> * - PHY driver will set the state to READY</span>
<span class="cm"> * - start will set the state to PENDING</span>
<span class="cm"> *</span>
<span class="cm"> * READY: PHY is ready to send and receive packets, but the</span>
<span class="cm"> * controller is not.  By default, PHYs which do not implement</span>
<span class="cm"> * probe will be set to this state by phy_probe().  If the PHY</span>
<span class="cm"> * driver knows the PHY is ready, and the PHY state is STARTING,</span>
<span class="cm"> * then it sets this STATE.</span>
<span class="cm"> * - start will set the state to UP</span>
<span class="cm"> *</span>
<span class="cm"> * PENDING: PHY device is coming up, but the ethernet driver is</span>
<span class="cm"> * ready.  phy_start will set this state if the PHY state is</span>
<span class="cm"> * STARTING.</span>
<span class="cm"> * - PHY driver will set the state to UP when the PHY is ready</span>
<span class="cm"> *</span>
<span class="cm"> * UP: The PHY and attached device are ready to do work.</span>
<span class="cm"> * Interrupts should be started here.</span>
<span class="cm"> * - timer moves to AN</span>
<span class="cm"> *</span>
<span class="cm"> * AN: The PHY is currently negotiating the link state.  Link is</span>
<span class="cm"> * therefore down for now.  phy_timer will set this state when it</span>
<span class="cm"> * detects the state is UP.  config_aneg will set this state</span>
<span class="cm"> * whenever called with phydev-&gt;autoneg set to AUTONEG_ENABLE.</span>
<span class="cm"> * - If autonegotiation finishes, but there&#39;s no link, it sets</span>
<span class="cm"> *   the state to NOLINK.</span>
<span class="cm"> * - If aneg finishes with link, it sets the state to RUNNING,</span>
<span class="cm"> *   and calls adjust_link</span>
<span class="cm"> * - If autonegotiation did not finish after an arbitrary amount</span>
<span class="cm"> *   of time, autonegotiation should be tried again if the PHY</span>
<span class="cm"> *   supports &quot;magic&quot; autonegotiation (back to AN)</span>
<span class="cm"> * - If it didn&#39;t finish, and no magic_aneg, move to FORCING.</span>
<span class="cm"> *</span>
<span class="cm"> * NOLINK: PHY is up, but not currently plugged in.</span>
<span class="cm"> * - If the timer notes that the link comes back, we move to RUNNING</span>
<span class="cm"> * - config_aneg moves to AN</span>
<span class="cm"> * - phy_stop moves to HALTED</span>
<span class="cm"> *</span>
<span class="cm"> * FORCING: PHY is being configured with forced settings</span>
<span class="cm"> * - if link is up, move to RUNNING</span>
<span class="cm"> * - If link is down, we drop to the next highest setting, and</span>
<span class="cm"> *   retry (FORCING) after a timeout</span>
<span class="cm"> * - phy_stop moves to HALTED</span>
<span class="cm"> *</span>
<span class="cm"> * RUNNING: PHY is currently up, running, and possibly sending</span>
<span class="cm"> * and/or receiving packets</span>
<span class="cm"> * - timer will set CHANGELINK if we&#39;re polling (this ensures the</span>
<span class="cm"> *   link state is polled every other cycle of this state machine,</span>
<span class="cm"> *   which makes it every other second)</span>
<span class="cm"> * - irq will set CHANGELINK</span>
<span class="cm"> * - config_aneg will set AN</span>
<span class="cm"> * - phy_stop moves to HALTED</span>
<span class="cm"> *</span>
<span class="cm"> * CHANGELINK: PHY experienced a change in link state</span>
<span class="cm"> * - timer moves to RUNNING if link</span>
<span class="cm"> * - timer moves to NOLINK if the link is down</span>
<span class="cm"> * - phy_stop moves to HALTED</span>
<span class="cm"> *</span>
<span class="cm"> * HALTED: PHY is up, but no polling or interrupts are done. Or</span>
<span class="cm"> * PHY is in an error state.</span>
<span class="cm"> *</span>
<span class="cm"> * - phy_start moves to RESUMING</span>
<span class="cm"> *</span>
<span class="cm"> * RESUMING: PHY was halted, but now wants to run again.</span>
<span class="cm"> * - If we are forcing, or aneg is done, timer moves to RUNNING</span>
<span class="cm"> * - If aneg is not done, timer moves to AN</span>
<span class="cm"> * - phy_stop moves to HALTED</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">phy_state</span> <span class="p">{</span>
	<span class="n">PHY_DOWN</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
	<span class="n">PHY_STARTING</span><span class="p">,</span>
	<span class="n">PHY_READY</span><span class="p">,</span>
	<span class="n">PHY_PENDING</span><span class="p">,</span>
	<span class="n">PHY_UP</span><span class="p">,</span>
	<span class="n">PHY_AN</span><span class="p">,</span>
	<span class="n">PHY_RUNNING</span><span class="p">,</span>
	<span class="n">PHY_NOLINK</span><span class="p">,</span>
	<span class="n">PHY_FORCING</span><span class="p">,</span>
	<span class="n">PHY_CHANGELINK</span><span class="p">,</span>
	<span class="n">PHY_HALTED</span><span class="p">,</span>
	<span class="n">PHY_RESUMING</span>
<span class="p">};</span>


<span class="cm">/* phy_device: An instance of a PHY</span>
<span class="cm"> *</span>
<span class="cm"> * drv: Pointer to the driver for this PHY instance</span>
<span class="cm"> * bus: Pointer to the bus this PHY is on</span>
<span class="cm"> * dev: driver model device structure for this PHY</span>
<span class="cm"> * phy_id: UID for this device found during discovery</span>
<span class="cm"> * state: state of the PHY for management purposes</span>
<span class="cm"> * dev_flags: Device-specific flags used by the PHY driver.</span>
<span class="cm"> * addr: Bus address of PHY</span>
<span class="cm"> * link_timeout: The number of timer firings to wait before the</span>
<span class="cm"> * giving up on the current attempt at acquiring a link</span>
<span class="cm"> * irq: IRQ number of the PHY&#39;s interrupt (-1 if none)</span>
<span class="cm"> * phy_timer: The timer for handling the state machine</span>
<span class="cm"> * phy_queue: A work_queue for the interrupt</span>
<span class="cm"> * attached_dev: The attached enet driver&#39;s device instance ptr</span>
<span class="cm"> * adjust_link: Callback for the enet controller to respond to</span>
<span class="cm"> * changes in the link state.</span>
<span class="cm"> * adjust_state: Callback for the enet driver to respond to</span>
<span class="cm"> * changes in the state machine.</span>
<span class="cm"> *</span>
<span class="cm"> * speed, duplex, pause, supported, advertising, and</span>
<span class="cm"> * autoneg are used like in mii_if_info</span>
<span class="cm"> *</span>
<span class="cm"> * interrupts currently only supports enabled or disabled,</span>
<span class="cm"> * but could be changed in the future to support enabling</span>
<span class="cm"> * and disabling specific interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * Contains some infrastructure for polling and interrupt</span>
<span class="cm"> * handling, as well as handling shifts in PHY hardware state</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">phy_device</span> <span class="p">{</span>
	<span class="cm">/* Information about the PHY type */</span>
	<span class="cm">/* And management functions */</span>
	<span class="k">struct</span> <span class="n">phy_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">phy_id</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">phy_state</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">dev_flags</span><span class="p">;</span>

	<span class="n">phy_interface_t</span> <span class="n">interface</span><span class="p">;</span>

	<span class="cm">/* Bus address of the PHY (0-31) */</span>
	<span class="kt">int</span> <span class="n">addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * forced speed &amp; duplex (no autoneg)</span>
<span class="cm">	 * partner speed &amp; duplex &amp; pause (autoneg)</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">speed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">duplex</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pause</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">asym_pause</span><span class="p">;</span>

	<span class="cm">/* The most recently read link state */</span>
	<span class="kt">int</span> <span class="n">link</span><span class="p">;</span>

	<span class="cm">/* Enabled Interrupts */</span>
	<span class="n">u32</span> <span class="n">interrupts</span><span class="p">;</span>

	<span class="cm">/* Union of PHY and Attached devices&#39; supported modes */</span>
	<span class="cm">/* See mii.h for more info */</span>
	<span class="n">u32</span> <span class="n">supported</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">advertising</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">autoneg</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">link_timeout</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Interrupt number for this PHY</span>
<span class="cm">	 * -1 means no interrupt</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="cm">/* private data pointer */</span>
	<span class="cm">/* For use by PHYs to maintain extra state */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>

	<span class="cm">/* Interrupt and Polling infrastructure */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">phy_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">state_queue</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">irq_disable</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">attached_dev</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">adjust_link</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">adjust_state</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="p">};</span>
<span class="cp">#define to_phy_device(d) container_of(d, struct phy_device, dev)</span>

<span class="cm">/* struct phy_driver: Driver structure for a particular PHY type</span>
<span class="cm"> *</span>
<span class="cm"> * phy_id: The result of reading the UID registers of this PHY</span>
<span class="cm"> *   type, and ANDing them with the phy_id_mask.  This driver</span>
<span class="cm"> *   only works for PHYs with IDs which match this field</span>
<span class="cm"> * name: The friendly name of this PHY type</span>
<span class="cm"> * phy_id_mask: Defines the important bits of the phy_id</span>
<span class="cm"> * features: A list of features (speed, duplex, etc) supported</span>
<span class="cm"> *   by this PHY</span>
<span class="cm"> * flags: A bitfield defining certain other features this PHY</span>
<span class="cm"> *   supports (like interrupts)</span>
<span class="cm"> *</span>
<span class="cm"> * The drivers must implement config_aneg and read_status.  All</span>
<span class="cm"> * other functions are optional. Note that none of these</span>
<span class="cm"> * functions should be called from interrupt time.  The goal is</span>
<span class="cm"> * for the bus read/write functions to be able to block when the</span>
<span class="cm"> * bus transaction is happening, and be freed up by an interrupt</span>
<span class="cm"> * (The MPC85xx has this ability, though it is not currently</span>
<span class="cm"> * supported in the driver).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">phy_driver</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">phy_id</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">phy_id_mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">features</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Called to initialize the PHY,</span>
<span class="cm">	 * including after a reset</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">config_init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Called during discovery.  Used to set</span>
<span class="cm">	 * up device-specific structures, if any</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>

	<span class="cm">/* PHY Power Management */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Configures the advertisement and resets</span>
<span class="cm">	 * autonegotiation if phydev-&gt;autoneg is on,</span>
<span class="cm">	 * forces the speed to the current settings in phydev</span>
<span class="cm">	 * if phydev-&gt;autoneg is off</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">config_aneg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>

	<span class="cm">/* Determines the negotiated speed and duplex */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_status</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>

	<span class="cm">/* Clears any pending interrupts */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ack_interrupt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>

	<span class="cm">/* Enables or disables interrupts */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">config_intr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Checks if the PHY generated an interrupt.</span>
<span class="cm">	 * For multi-PHY devices with shared PHY interrupt pin</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">did_interrupt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>

	<span class="cm">/* Clears up any memory if needed */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>

	<span class="cm">/* Handles ethtool queries for hardware time stamping. */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ts_info</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_ts_info</span> <span class="o">*</span><span class="n">ti</span><span class="p">);</span>

	<span class="cm">/* Handles SIOCSHWTSTAMP ioctl for hardware time stamping. */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">hwtstamp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Requests a Rx timestamp for &#39;skb&#39;. If the skb is accepted,</span>
<span class="cm">	 * the phy driver promises to deliver it using netif_rx() as</span>
<span class="cm">	 * soon as a timestamp becomes available. One of the</span>
<span class="cm">	 * PTP_CLASS_ values is passed in &#39;type&#39;. The function must</span>
<span class="cm">	 * return true if the skb is accepted for delivery.</span>
<span class="cm">	 */</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">rxtstamp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Requests a Tx timestamp for &#39;skb&#39;. The phy driver promises</span>
<span class="cm">	 * to deliver it using skb_complete_tx_timestamp() as soon as a</span>
<span class="cm">	 * timestamp becomes available. One of the PTP_CLASS_ values</span>
<span class="cm">	 * is passed in &#39;type&#39;.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">txtstamp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">device_driver</span> <span class="n">driver</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define to_phy_driver(d) container_of(d, struct phy_driver, driver)</span>

<span class="cp">#define PHY_ANY_ID &quot;MATCH ANY PHY&quot;</span>
<span class="cp">#define PHY_ANY_UID 0xffffffff</span>

<span class="cm">/* A Structure for boards to register fixups with the PHY Lib */</span>
<span class="k">struct</span> <span class="n">phy_fixup</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">bus_id</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">phy_uid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">phy_uid_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">run</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * phy_read - Convenience function for reading a given PHY register</span>
<span class="cm"> * @phydev: the phy_device struct</span>
<span class="cm"> * @regnum: register number to read</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: MUST NOT be called from interrupt context,</span>
<span class="cm"> * because the bus read/write functions may wait for an interrupt</span>
<span class="cm"> * to conclude the operation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">phy_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">regnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mdiobus_read</span><span class="p">(</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">regnum</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * phy_write - Convenience function for writing a given PHY register</span>
<span class="cm"> * @phydev: the phy_device struct</span>
<span class="cm"> * @regnum: register number to write</span>
<span class="cm"> * @val: value to write to @regnum</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: MUST NOT be called from interrupt context,</span>
<span class="cm"> * because the bus read/write functions may wait for an interrupt</span>
<span class="cm"> * to conclude the operation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">phy_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">regnum</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mdiobus_write</span><span class="p">(</span><span class="n">phydev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">regnum</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">phy_device</span><span class="o">*</span> <span class="n">get_phy_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">phy_device_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phy</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">phy_init_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span> <span class="n">phy_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bus_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">,</span> <span class="n">phy_interface_t</span> <span class="n">interface</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phy_find_first</span><span class="p">(</span><span class="k">struct</span> <span class="n">mii_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">phy_connect_direct</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">),</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">,</span>
		<span class="n">phy_interface_t</span> <span class="n">interface</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span> <span class="n">phy_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bus_id</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">),</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">,</span>
		<span class="n">phy_interface_t</span> <span class="n">interface</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">phy_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">phy_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">phy_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">phy_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">phy_start_aneg</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">phy_stop_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">phy_read_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">phydev</span><span class="o">-&gt;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">read_status</span><span class="p">(</span><span class="n">phydev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">genphy_restart_aneg</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">genphy_config_aneg</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">genphy_update_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">genphy_read_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">genphy_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">genphy_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">phy_driver_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">phy_driver_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_driver</span> <span class="o">*</span><span class="n">new_driver</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">phy_state_machine</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">phy_start_machine</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">void</span> <span class="n">phy_stop_machine</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">phy_ethtool_sset</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">phy_ethtool_gset</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">phy_mii_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">phy_start_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">phy_print_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">phy_device_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">phy_register_fixup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bus_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">phy_uid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">phy_uid_mask</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">run</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">int</span> <span class="n">phy_register_fixup_for_id</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bus_id</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">run</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">int</span> <span class="n">phy_register_fixup_for_uid</span><span class="p">(</span><span class="n">u32</span> <span class="n">phy_uid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">phy_uid_mask</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">run</span><span class="p">)(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">int</span> <span class="n">phy_scan_fixups</span><span class="p">(</span><span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="n">mdio_bus_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mdio_bus_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">mdio_bus_type</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* __PHY_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
