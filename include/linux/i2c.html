<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › i2c.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>i2c.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* ------------------------------------------------------------------------- */</span>
<span class="cm">/*									     */</span>
<span class="cm">/* i2c.h - definitions for the i2c-bus interface			     */</span>
<span class="cm">/*									     */</span>
<span class="cm">/* ------------------------------------------------------------------------- */</span>
<span class="cm">/*   Copyright (C) 1995-2000 Simon G. Vogl</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,</span>
<span class="cm">    MA 02110-1301 USA.							     */</span>
<span class="cm">/* ------------------------------------------------------------------------- */</span>

<span class="cm">/* With some changes from Kyösti Mälkki &lt;kmalkki@cc.hut.fi&gt; and</span>
<span class="cm">   Frodo Looijaard &lt;frodol@dds.nl&gt; */</span>

<span class="cp">#ifndef _LINUX_I2C_H</span>
<span class="cp">#define _LINUX_I2C_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/mod_devicetable.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;	</span><span class="cm">/* for struct device */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/sched.h&gt;	</span><span class="cm">/* for completion */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;		</span><span class="cm">/* for struct device_node */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/swab.h&gt;		</span><span class="cm">/* for swab16 */</span><span class="cp"></span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">i2c_bus_type</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="n">i2c_adapter_type</span><span class="p">;</span>

<span class="cm">/* --- General options ------------------------------------------------	*/</span>

<span class="k">struct</span> <span class="n">i2c_msg</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">i2c_algorithm</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">i2c_adapter</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">i2c_client</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">i2c_driver</span><span class="p">;</span>
<span class="k">union</span> <span class="n">i2c_smbus_data</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">i2c_board_info</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)</span>
<span class="cm">/*</span>
<span class="cm"> * The master routines are the ones normally used to transmit data to devices</span>
<span class="cm"> * on a bus (or read from them). Apart from two basic transfer functions to</span>
<span class="cm"> * transmit one message at a time, a more complex version can be used to</span>
<span class="cm"> * transmit an arbitrary number of messages without interruption.</span>
<span class="cm"> * @count must be be less than 64k since msg.len is u16.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2c_master_send</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2c_master_recv</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="cm">/* Transfer num messages.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2c_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2c_msg</span> <span class="o">*</span><span class="n">msgs</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">num</span><span class="p">);</span>

<span class="cm">/* This is the very generalized SMBus access routine. You probably do not</span>
<span class="cm">   want to use this, though; one of the functions below may be much easier,</span>
<span class="cm">   and probably just as fast.</span>
<span class="cm">   Note that we use i2c_adapter here, because you do not need a specific</span>
<span class="cm">   smbus adapter to call this function. */</span>
<span class="k">extern</span> <span class="n">s32</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">char</span> <span class="n">read_write</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/* Now follow the &#39;nice&#39; access routines. These also document the calling</span>
<span class="cm">   conventions of i2c_smbus_xfer. */</span>

<span class="k">extern</span> <span class="n">s32</span> <span class="n">i2c_smbus_read_byte</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">s32</span> <span class="n">i2c_smbus_write_byte</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">s32</span> <span class="n">i2c_smbus_read_byte_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
				    <span class="n">u8</span> <span class="n">command</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">s32</span> <span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
				     <span class="n">u8</span> <span class="n">command</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">s32</span> <span class="n">i2c_smbus_read_word_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
				    <span class="n">u8</span> <span class="n">command</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">s32</span> <span class="n">i2c_smbus_write_word_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
				     <span class="n">u8</span> <span class="n">command</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">s32</span>
<span class="nf">i2c_smbus_read_word_swapped</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">value</span> <span class="o">=</span> <span class="n">i2c_smbus_read_word_data</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">value</span> <span class="o">:</span> <span class="n">swab16</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">s32</span>
<span class="nf">i2c_smbus_write_word_swapped</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
			     <span class="n">u8</span> <span class="n">command</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">i2c_smbus_write_word_data</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">swab16</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Returns the number of read bytes */</span>
<span class="k">extern</span> <span class="n">s32</span> <span class="n">i2c_smbus_read_block_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
				     <span class="n">u8</span> <span class="n">command</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">values</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">s32</span> <span class="n">i2c_smbus_write_block_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
				      <span class="n">u8</span> <span class="n">command</span><span class="p">,</span> <span class="n">u8</span> <span class="n">length</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">values</span><span class="p">);</span>
<span class="cm">/* Returns the number of read bytes */</span>
<span class="k">extern</span> <span class="n">s32</span> <span class="n">i2c_smbus_read_i2c_block_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
					 <span class="n">u8</span> <span class="n">command</span><span class="p">,</span> <span class="n">u8</span> <span class="n">length</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">values</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">s32</span> <span class="n">i2c_smbus_write_i2c_block_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
					  <span class="n">u8</span> <span class="n">command</span><span class="p">,</span> <span class="n">u8</span> <span class="n">length</span><span class="p">,</span>
					  <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">values</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* I2C */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * struct i2c_driver - represent an I2C device driver</span>
<span class="cm"> * @class: What kind of i2c device we instantiate (for detect)</span>
<span class="cm"> * @attach_adapter: Callback for bus addition (deprecated)</span>
<span class="cm"> * @detach_adapter: Callback for bus removal (deprecated)</span>
<span class="cm"> * @probe: Callback for device binding</span>
<span class="cm"> * @remove: Callback for device unbinding</span>
<span class="cm"> * @shutdown: Callback for device shutdown</span>
<span class="cm"> * @suspend: Callback for device suspend</span>
<span class="cm"> * @resume: Callback for device resume</span>
<span class="cm"> * @alert: Alert callback, for example for the SMBus alert protocol</span>
<span class="cm"> * @command: Callback for bus-wide signaling (optional)</span>
<span class="cm"> * @driver: Device driver model driver</span>
<span class="cm"> * @id_table: List of I2C devices supported by this driver</span>
<span class="cm"> * @detect: Callback for device detection</span>
<span class="cm"> * @address_list: The I2C addresses to probe (for detect)</span>
<span class="cm"> * @clients: List of detected clients we created (for i2c-core use only)</span>
<span class="cm"> *</span>
<span class="cm"> * The driver.owner field should be set to the module owner of this driver.</span>
<span class="cm"> * The driver.name field should be set to the name of this driver.</span>
<span class="cm"> *</span>
<span class="cm"> * For automatic device detection, both @detect and @address_data must</span>
<span class="cm"> * be defined. @class should also be set, otherwise only devices forced</span>
<span class="cm"> * with module parameters will be created. The detect function must</span>
<span class="cm"> * fill at least the name field of the i2c_board_info structure it is</span>
<span class="cm"> * handed upon successful detection, and possibly also the flags field.</span>
<span class="cm"> *</span>
<span class="cm"> * If @detect is missing, the driver will still work fine for enumerated</span>
<span class="cm"> * devices. Detected devices simply won&#39;t be supported. This is expected</span>
<span class="cm"> * for the many I2C/SMBus devices which can&#39;t be detected reliably, and</span>
<span class="cm"> * the ones which can always be enumerated in practice.</span>
<span class="cm"> *</span>
<span class="cm"> * The i2c_client structure which is handed to the @detect callback is</span>
<span class="cm"> * not a real i2c_client. It is initialized just enough so that you can</span>
<span class="cm"> * call i2c_smbus_read_byte_data and friends on it. Don&#39;t do anything</span>
<span class="cm"> * else with it. In particular, calling dev_dbg and friends on it is</span>
<span class="cm"> * not allowed.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2c_driver</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">class</span><span class="p">;</span>

	<span class="cm">/* Notifies the driver that a new bus has appeared or is about to be</span>
<span class="cm">	 * removed. You should avoid using this, it will be removed in a</span>
<span class="cm">	 * near future.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">attach_adapter</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="p">)</span> <span class="n">__deprecated</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">detach_adapter</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="p">)</span> <span class="n">__deprecated</span><span class="p">;</span>

	<span class="cm">/* Standard driver model interfaces */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_device_id</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* driver model interfaces that don&#39;t relate to enumeration  */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Alert callback, for example for the SMBus alert protocol.</span>
<span class="cm">	 * The format and meaning of the data value depends on the protocol.</span>
<span class="cm">	 * For the SMBus alert protocol, there is a single bit of data passed</span>
<span class="cm">	 * as the alert response&#39;s low bit (&quot;event flag&quot;).</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">alert</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">);</span>

	<span class="cm">/* a ioctl like command that can be used to perform specific functions</span>
<span class="cm">	 * with the device.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">command</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">device_driver</span> <span class="n">driver</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_device_id</span> <span class="o">*</span><span class="n">id_table</span><span class="p">;</span>

	<span class="cm">/* Device detection callback for automatic device creation */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">detect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2c_board_info</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">address_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">clients</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define to_i2c_driver(d) container_of(d, struct i2c_driver, driver)</span>

<span class="cm">/**</span>
<span class="cm"> * struct i2c_client - represent an I2C slave device</span>
<span class="cm"> * @flags: I2C_CLIENT_TEN indicates the device uses a ten bit chip address;</span>
<span class="cm"> *	I2C_CLIENT_PEC indicates it uses SMBus Packet Error Checking</span>
<span class="cm"> * @addr: Address used on the I2C bus connected to the parent adapter.</span>
<span class="cm"> * @name: Indicates the type of the device, usually a chip name that&#39;s</span>
<span class="cm"> *	generic enough to hide second-sourcing and compatible revisions.</span>
<span class="cm"> * @adapter: manages the bus segment hosting this I2C device</span>
<span class="cm"> * @driver: device&#39;s driver, hence pointer to access routines</span>
<span class="cm"> * @dev: Driver model device node for the slave.</span>
<span class="cm"> * @irq: indicates the IRQ generated by this device (if any)</span>
<span class="cm"> * @detected: member of an i2c_driver.clients list or i2c-core&#39;s</span>
<span class="cm"> *	userspace_devices list</span>
<span class="cm"> *</span>
<span class="cm"> * An i2c_client identifies a single device (i.e. chip) connected to an</span>
<span class="cm"> * i2c bus. The behaviour exposed to Linux is defined by the driver</span>
<span class="cm"> * managing the device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2c_client</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* div., see below		*/</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">addr</span><span class="p">;</span>		<span class="cm">/* chip address - NOTE: 7bit	*/</span>
					<span class="cm">/* addresses are stored in the	*/</span>
					<span class="cm">/* _LOWER_ 7 bits		*/</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">I2C_NAME_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>	<span class="cm">/* the adapter we sit on	*/</span>
	<span class="k">struct</span> <span class="n">i2c_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>	<span class="cm">/* and our access routines	*/</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>		<span class="cm">/* the device structure		*/</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>			<span class="cm">/* irq issued by device		*/</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">detected</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define to_i2c_client(d) container_of(d, struct i2c_client, dev)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">i2c_verify_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">i2c_verify_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="nf">kobj_to_i2c_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span> <span class="k">const</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">to_i2c_client</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">i2c_get_clientdata</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i2c_set_clientdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct i2c_board_info - template for device creation</span>
<span class="cm"> * @type: chip type, to initialize i2c_client.name</span>
<span class="cm"> * @flags: to initialize i2c_client.flags</span>
<span class="cm"> * @addr: stored in i2c_client.addr</span>
<span class="cm"> * @platform_data: stored in i2c_client.dev.platform_data</span>
<span class="cm"> * @archdata: copied into i2c_client.dev.archdata</span>
<span class="cm"> * @of_node: pointer to OpenFirmware device node</span>
<span class="cm"> * @irq: stored in i2c_client.irq</span>
<span class="cm"> *</span>
<span class="cm"> * I2C doesn&#39;t actually support hardware probing, although controllers and</span>
<span class="cm"> * devices may be able to use I2C_SMBUS_QUICK to tell whether or not there&#39;s</span>
<span class="cm"> * a device at a given address.  Drivers commonly need more information than</span>
<span class="cm"> * that, such as chip type, configuration, associated IRQ, and so on.</span>
<span class="cm"> *</span>
<span class="cm"> * i2c_board_info is used to build tables of information listing I2C devices</span>
<span class="cm"> * that are present.  This information is used to grow the driver model tree.</span>
<span class="cm"> * For mainboards this is done statically using i2c_register_board_info();</span>
<span class="cm"> * bus numbers identify adapters that aren&#39;t yet available.  For add-on boards,</span>
<span class="cm"> * i2c_new_device() does this dynamically with the adapter already known.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2c_board_info</span> <span class="p">{</span>
	<span class="kt">char</span>		<span class="n">type</span><span class="p">[</span><span class="n">I2C_NAME_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">addr</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_archdata</span>	<span class="o">*</span><span class="n">archdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">of_node</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">irq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * I2C_BOARD_INFO - macro used to list an i2c device and its address</span>
<span class="cm"> * @dev_type: identifies the device type</span>
<span class="cm"> * @dev_addr: the device&#39;s address on the bus.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro initializes essential fields of a struct i2c_board_info,</span>
<span class="cm"> * declaring what has been provided on a particular board.  Optional</span>
<span class="cm"> * fields (such as associated irq, or device-specific platform_data)</span>
<span class="cm"> * are provided using conventional syntax.</span>
<span class="cm"> */</span>
<span class="cp">#define I2C_BOARD_INFO(dev_type, dev_addr) \</span>
<span class="cp">	.type = dev_type, .addr = (dev_addr)</span>


<span class="cp">#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)</span>
<span class="cm">/* Add-on boards should register/unregister their devices; e.g. a board</span>
<span class="cm"> * with integrated I2C, a config eeprom, sensors, and a codec that&#39;s</span>
<span class="cm"> * used in conjunction with the primary hardware.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span>
<span class="n">i2c_new_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2c_board_info</span> <span class="k">const</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>

<span class="cm">/* If you don&#39;t know the exact address of an I2C device, use this variant</span>
<span class="cm"> * instead, which can probe for device presence in a list of possible</span>
<span class="cm"> * addresses. The &quot;probe&quot; callback function is optional. If it is provided,</span>
<span class="cm"> * it must return 1 on successful probe, 0 otherwise. If it is not provided,</span>
<span class="cm"> * a default probing method is used.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span>
<span class="n">i2c_new_probed_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">i2c_board_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">short</span> <span class="k">const</span> <span class="o">*</span><span class="n">addr_list</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">addr</span><span class="p">));</span>

<span class="cm">/* Common custom probe functions */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2c_probe_func_quick_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">addr</span><span class="p">);</span>

<span class="cm">/* For devices that use several addresses, use i2c_new_dummy() to make</span>
<span class="cm"> * client handles for the extra addresses.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span>
<span class="n">i2c_new_dummy</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="n">u16</span> <span class="n">address</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2c_unregister_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* I2C */</span><span class="cp"></span>

<span class="cm">/* Mainboard arch_initcall() code should register all its I2C devices.</span>
<span class="cm"> * This is done at arch_initcall time, before declaring any i2c adapters.</span>
<span class="cm"> * Modules for add-on boards must use other calls.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_I2C_BOARDINFO</span>
<span class="k">extern</span> <span class="kt">int</span>
<span class="n">i2c_register_board_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">busnum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2c_board_info</span> <span class="k">const</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">n</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">i2c_register_board_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">busnum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2c_board_info</span> <span class="k">const</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* I2C_BOARDINFO */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The following structs are for those who like to implement new bus drivers:</span>
<span class="cm"> * i2c_algorithm is the interface to a class of hardware solutions which can</span>
<span class="cm"> * be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584</span>
<span class="cm"> * to name two of the most common.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2c_algorithm</span> <span class="p">{</span>
	<span class="cm">/* If an adapter algorithm can&#39;t do I2C-level access, set master_xfer</span>
<span class="cm">	   to NULL. If an adapter algorithm can do SMBus access, set</span>
<span class="cm">	   smbus_xfer. If set to NULL, the SMBus protocol is simulated</span>
<span class="cm">	   using common I2C messages */</span>
	<span class="cm">/* master_xfer should return the number of messages successfully</span>
<span class="cm">	   processed, or a negative value on error */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">master_xfer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2c_msg</span> <span class="o">*</span><span class="n">msgs</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">smbus_xfer</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">char</span> <span class="n">read_write</span><span class="p">,</span>
			   <span class="n">u8</span> <span class="n">command</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

	<span class="cm">/* To determine what the adapter supports */</span>
	<span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">functionality</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * i2c_adapter is the structure used to identify a physical i2c bus along</span>
<span class="cm"> * with the access algorithms necessary to access it.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">class</span><span class="p">;</span>		  <span class="cm">/* classes to allow probing for */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_algorithm</span> <span class="o">*</span><span class="n">algo</span><span class="p">;</span> <span class="cm">/* the algorithm to access the bus */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">algo_data</span><span class="p">;</span>

	<span class="cm">/* data fields that are valid for all devices	*/</span>
	<span class="k">struct</span> <span class="n">rt_mutex</span> <span class="n">bus_lock</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>			<span class="cm">/* in jiffies */</span>
	<span class="kt">int</span> <span class="n">retries</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>		<span class="cm">/* the adapter device */</span>

	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">48</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">dev_released</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">userspace_clients_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">userspace_clients</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define to_i2c_adapter(d) container_of(d, struct i2c_adapter, dev)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">i2c_get_adapdata</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i2c_set_adapdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span>
<span class="nf">i2c_parent_is_i2c_adapter</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">i2c_adapter_type</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">to_i2c_adapter</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">i2c_for_each_dev</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">));</span>

<span class="cm">/* Adapter locking functions, exported for shared pin cases */</span>
<span class="kt">void</span> <span class="n">i2c_lock_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">i2c_unlock_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*flags for the client struct: */</span>
<span class="cp">#define I2C_CLIENT_PEC	0x04		</span><span class="cm">/* Use Packet Error Checking */</span><span class="cp"></span>
<span class="cp">#define I2C_CLIENT_TEN	0x10		</span><span class="cm">/* we have a ten bit chip address */</span><span class="cp"></span>
					<span class="cm">/* Must equal I2C_M_TEN below */</span>
<span class="cp">#define I2C_CLIENT_WAKE	0x80		</span><span class="cm">/* for board_info; true iff can wake */</span><span class="cp"></span>

<span class="cm">/* i2c adapter classes (bitmask) */</span>
<span class="cp">#define I2C_CLASS_HWMON		(1&lt;&lt;0)	</span><span class="cm">/* lm_sensors, ... */</span><span class="cp"></span>
<span class="cp">#define I2C_CLASS_DDC		(1&lt;&lt;3)	</span><span class="cm">/* DDC bus on graphics adapters */</span><span class="cp"></span>
<span class="cp">#define I2C_CLASS_SPD		(1&lt;&lt;7)	</span><span class="cm">/* Memory modules */</span><span class="cp"></span>

<span class="cm">/* Internal numbers to terminate lists */</span>
<span class="cp">#define I2C_CLIENT_END		0xfffeU</span>

<span class="cm">/* Construct an I2C_CLIENT_END-terminated array of i2c addresses */</span>
<span class="cp">#define I2C_ADDRS(addr, addrs...) \</span>
<span class="cp">	((const unsigned short []){ addr, ## addrs, I2C_CLIENT_END })</span>


<span class="cm">/* ----- functions exported by i2c.o */</span>

<span class="cm">/* administration...</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2c_add_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2c_del_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2c_add_numbered_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2c_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2c_driver</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2c_del_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_driver</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* use a define to avoid include chaining to get THIS_MODULE */</span>
<span class="cp">#define i2c_add_driver(driver) \</span>
<span class="cp">	i2c_register_driver(THIS_MODULE, driver)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">i2c_use_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2c_release_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">);</span>

<span class="cm">/* call the i2c_client-&gt;command() of all attached clients with</span>
<span class="cm"> * the given arguments */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2c_clients_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">i2c_get_adapter</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2c_put_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">);</span>


<span class="cm">/* Return the functionality mask */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">i2c_get_functionality</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">algo</span><span class="o">-&gt;</span><span class="n">functionality</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Return 1 if adapter supports everything we need, 0 if not. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">i2c_check_functionality</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="n">u32</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">func</span> <span class="o">&amp;</span> <span class="n">i2c_get_functionality</span><span class="p">(</span><span class="n">adap</span><span class="p">))</span> <span class="o">==</span> <span class="n">func</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return the adapter number for a specific adapter */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">i2c_adapter_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * module_i2c_driver() - Helper macro for registering a I2C driver</span>
<span class="cm"> * @__i2c_driver: i2c_driver struct</span>
<span class="cm"> *</span>
<span class="cm"> * Helper macro for I2C drivers which do not do anything special in module</span>
<span class="cm"> * init/exit. This eliminates a lot of boilerplate. Each module may only</span>
<span class="cm"> * use this macro once, and calling it replaces module_init() and module_exit()</span>
<span class="cm"> */</span>
<span class="cp">#define module_i2c_driver(__i2c_driver) \</span>
<span class="cp">	module_driver(__i2c_driver, i2c_add_driver, \</span>
<span class="cp">			i2c_del_driver)</span>

<span class="cp">#endif </span><span class="cm">/* I2C */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * struct i2c_msg - an I2C transaction segment beginning with START</span>
<span class="cm"> * @addr: Slave address, either seven or ten bits.  When this is a ten</span>
<span class="cm"> *	bit address, I2C_M_TEN must be set in @flags and the adapter</span>
<span class="cm"> *	must support I2C_FUNC_10BIT_ADDR.</span>
<span class="cm"> * @flags: I2C_M_RD is handled by all adapters.  No other flags may be</span>
<span class="cm"> *	provided unless the adapter exported the relevant I2C_FUNC_*</span>
<span class="cm"> *	flags through i2c_check_functionality().</span>
<span class="cm"> * @len: Number of data bytes in @buf being read from or written to the</span>
<span class="cm"> *	I2C slave address.  For read transactions where I2C_M_RECV_LEN</span>
<span class="cm"> *	is set, the caller guarantees that this buffer can hold up to</span>
<span class="cm"> *	32 bytes in addition to the initial length byte sent by the</span>
<span class="cm"> *	slave (plus, if used, the SMBus PEC); and this value will be</span>
<span class="cm"> *	incremented by the number of block data bytes received.</span>
<span class="cm"> * @buf: The buffer into which data is read, or from which it&#39;s written.</span>
<span class="cm"> *</span>
<span class="cm"> * An i2c_msg is the low level representation of one segment of an I2C</span>
<span class="cm"> * transaction.  It is visible to drivers in the @i2c_transfer() procedure,</span>
<span class="cm"> * to userspace from i2c-dev, and to I2C adapter drivers through the</span>
<span class="cm"> * @i2c_adapter.@master_xfer() method.</span>
<span class="cm"> *</span>
<span class="cm"> * Except when I2C &quot;protocol mangling&quot; is used, all I2C adapters implement</span>
<span class="cm"> * the standard rules for I2C transactions.  Each transaction begins with a</span>
<span class="cm"> * START.  That is followed by the slave address, and a bit encoding read</span>
<span class="cm"> * versus write.  Then follow all the data bytes, possibly including a byte</span>
<span class="cm"> * with SMBus PEC.  The transfer terminates with a NAK, or when all those</span>
<span class="cm"> * bytes have been transferred and ACKed.  If this is the last message in a</span>
<span class="cm"> * group, it is followed by a STOP.  Otherwise it is followed by the next</span>
<span class="cm"> * @i2c_msg transaction segment, beginning with a (repeated) START.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, when the adapter supports I2C_FUNC_PROTOCOL_MANGLING then</span>
<span class="cm"> * passing certain @flags may have changed those standard protocol behaviors.</span>
<span class="cm"> * Those flags are only for use with broken/nonconforming slaves, and with</span>
<span class="cm"> * adapters which are known to support the specific mangling options they</span>
<span class="cm"> * need (one or more of IGNORE_NAK, NO_RD_ACK, NOSTART, and REV_DIR_ADDR).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2c_msg</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">addr</span><span class="p">;</span>	<span class="cm">/* slave address			*/</span>
	<span class="n">__u16</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#define I2C_M_TEN		0x0010	</span><span class="cm">/* this is a ten bit chip address */</span><span class="cp"></span>
<span class="cp">#define I2C_M_RD		0x0001	</span><span class="cm">/* read data, from slave to master */</span><span class="cp"></span>
<span class="cp">#define I2C_M_NOSTART		0x4000	</span><span class="cm">/* if I2C_FUNC_NOSTART */</span><span class="cp"></span>
<span class="cp">#define I2C_M_REV_DIR_ADDR	0x2000	</span><span class="cm">/* if I2C_FUNC_PROTOCOL_MANGLING */</span><span class="cp"></span>
<span class="cp">#define I2C_M_IGNORE_NAK	0x1000	</span><span class="cm">/* if I2C_FUNC_PROTOCOL_MANGLING */</span><span class="cp"></span>
<span class="cp">#define I2C_M_NO_RD_ACK		0x0800	</span><span class="cm">/* if I2C_FUNC_PROTOCOL_MANGLING */</span><span class="cp"></span>
<span class="cp">#define I2C_M_RECV_LEN		0x0400	</span><span class="cm">/* length will be first received byte */</span><span class="cp"></span>
	<span class="n">__u16</span> <span class="n">len</span><span class="p">;</span>		<span class="cm">/* msg length				*/</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>		<span class="cm">/* pointer to msg data			*/</span>
<span class="p">};</span>

<span class="cm">/* To determine what functionality is present */</span>

<span class="cp">#define I2C_FUNC_I2C			0x00000001</span>
<span class="cp">#define I2C_FUNC_10BIT_ADDR		0x00000002</span>
<span class="cp">#define I2C_FUNC_PROTOCOL_MANGLING	0x00000004 </span><span class="cm">/* I2C_M_IGNORE_NAK etc. */</span><span class="cp"></span>
<span class="cp">#define I2C_FUNC_SMBUS_PEC		0x00000008</span>
<span class="cp">#define I2C_FUNC_NOSTART		0x00000010 </span><span class="cm">/* I2C_M_NOSTART */</span><span class="cp"></span>
<span class="cp">#define I2C_FUNC_SMBUS_BLOCK_PROC_CALL	0x00008000 </span><span class="cm">/* SMBus 2.0 */</span><span class="cp"></span>
<span class="cp">#define I2C_FUNC_SMBUS_QUICK		0x00010000</span>
<span class="cp">#define I2C_FUNC_SMBUS_READ_BYTE	0x00020000</span>
<span class="cp">#define I2C_FUNC_SMBUS_WRITE_BYTE	0x00040000</span>
<span class="cp">#define I2C_FUNC_SMBUS_READ_BYTE_DATA	0x00080000</span>
<span class="cp">#define I2C_FUNC_SMBUS_WRITE_BYTE_DATA	0x00100000</span>
<span class="cp">#define I2C_FUNC_SMBUS_READ_WORD_DATA	0x00200000</span>
<span class="cp">#define I2C_FUNC_SMBUS_WRITE_WORD_DATA	0x00400000</span>
<span class="cp">#define I2C_FUNC_SMBUS_PROC_CALL	0x00800000</span>
<span class="cp">#define I2C_FUNC_SMBUS_READ_BLOCK_DATA	0x01000000</span>
<span class="cp">#define I2C_FUNC_SMBUS_WRITE_BLOCK_DATA 0x02000000</span>
<span class="cp">#define I2C_FUNC_SMBUS_READ_I2C_BLOCK	0x04000000 </span><span class="cm">/* I2C-like block xfer  */</span><span class="cp"></span>
<span class="cp">#define I2C_FUNC_SMBUS_WRITE_I2C_BLOCK	0x08000000 </span><span class="cm">/* w/ 1-byte reg. addr. */</span><span class="cp"></span>

<span class="cp">#define I2C_FUNC_SMBUS_BYTE		(I2C_FUNC_SMBUS_READ_BYTE | \</span>
<span class="cp">					 I2C_FUNC_SMBUS_WRITE_BYTE)</span>
<span class="cp">#define I2C_FUNC_SMBUS_BYTE_DATA	(I2C_FUNC_SMBUS_READ_BYTE_DATA | \</span>
<span class="cp">					 I2C_FUNC_SMBUS_WRITE_BYTE_DATA)</span>
<span class="cp">#define I2C_FUNC_SMBUS_WORD_DATA	(I2C_FUNC_SMBUS_READ_WORD_DATA | \</span>
<span class="cp">					 I2C_FUNC_SMBUS_WRITE_WORD_DATA)</span>
<span class="cp">#define I2C_FUNC_SMBUS_BLOCK_DATA	(I2C_FUNC_SMBUS_READ_BLOCK_DATA | \</span>
<span class="cp">					 I2C_FUNC_SMBUS_WRITE_BLOCK_DATA)</span>
<span class="cp">#define I2C_FUNC_SMBUS_I2C_BLOCK	(I2C_FUNC_SMBUS_READ_I2C_BLOCK | \</span>
<span class="cp">					 I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)</span>

<span class="cp">#define I2C_FUNC_SMBUS_EMUL		(I2C_FUNC_SMBUS_QUICK | \</span>
<span class="cp">					 I2C_FUNC_SMBUS_BYTE | \</span>
<span class="cp">					 I2C_FUNC_SMBUS_BYTE_DATA | \</span>
<span class="cp">					 I2C_FUNC_SMBUS_WORD_DATA | \</span>
<span class="cp">					 I2C_FUNC_SMBUS_PROC_CALL | \</span>
<span class="cp">					 I2C_FUNC_SMBUS_WRITE_BLOCK_DATA | \</span>
<span class="cp">					 I2C_FUNC_SMBUS_I2C_BLOCK | \</span>
<span class="cp">					 I2C_FUNC_SMBUS_PEC)</span>

<span class="cm">/*</span>
<span class="cm"> * Data for SMBus Messages</span>
<span class="cm"> */</span>
<span class="cp">#define I2C_SMBUS_BLOCK_MAX	32	</span><span class="cm">/* As specified in SMBus standard */</span><span class="cp"></span>
<span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="n">byte</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">word</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">block</span><span class="p">[</span><span class="n">I2C_SMBUS_BLOCK_MAX</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span> <span class="cm">/* block[0] is used for length */</span>
			       <span class="cm">/* and one more for user-space compatibility */</span>
<span class="p">};</span>

<span class="cm">/* i2c_smbus_xfer read or write markers */</span>
<span class="cp">#define I2C_SMBUS_READ	1</span>
<span class="cp">#define I2C_SMBUS_WRITE	0</span>

<span class="cm">/* SMBus transaction types (size parameter in the above functions)</span>
<span class="cm">   Note: these no longer correspond to the (arbitrary) PIIX4 internal codes! */</span>
<span class="cp">#define I2C_SMBUS_QUICK		    0</span>
<span class="cp">#define I2C_SMBUS_BYTE		    1</span>
<span class="cp">#define I2C_SMBUS_BYTE_DATA	    2</span>
<span class="cp">#define I2C_SMBUS_WORD_DATA	    3</span>
<span class="cp">#define I2C_SMBUS_PROC_CALL	    4</span>
<span class="cp">#define I2C_SMBUS_BLOCK_DATA	    5</span>
<span class="cp">#define I2C_SMBUS_I2C_BLOCK_BROKEN  6</span>
<span class="cp">#define I2C_SMBUS_BLOCK_PROC_CALL   7		</span><span class="cm">/* SMBus 2.0 */</span><span class="cp"></span>
<span class="cp">#define I2C_SMBUS_I2C_BLOCK_DATA    8</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_I2C_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
