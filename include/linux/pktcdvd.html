<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › pktcdvd.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pktcdvd.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2000 Jens Axboe &lt;axboe@suse.de&gt;</span>
<span class="cm"> * Copyright (C) 2001-2004 Peter Osterlund &lt;petero2@telia.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * May be copied or modified under the terms of the GNU General Public</span>
<span class="cm"> * License.  See linux/COPYING for more information.</span>
<span class="cm"> *</span>
<span class="cm"> * Packet writing layer for ATAPI and SCSI CD-R, CD-RW, DVD-R, and</span>
<span class="cm"> * DVD-RW devices.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __PKTCDVD_H</span>
<span class="cp">#define __PKTCDVD_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * 1 for normal debug messages, 2 is very verbose. 0 to turn it off.</span>
<span class="cm"> */</span>
<span class="cp">#define PACKET_DEBUG		1</span>

<span class="cp">#define	MAX_WRITERS		8</span>

<span class="cp">#define PKT_RB_POOL_SIZE	512</span>

<span class="cm">/*</span>
<span class="cm"> * How long we should hold a non-full packet before starting data gathering.</span>
<span class="cm"> */</span>
<span class="cp">#define PACKET_WAIT_TIME	(HZ * 5 / 1000)</span>

<span class="cm">/*</span>
<span class="cm"> * use drive write caching -- we need deferred error handling to be</span>
<span class="cm"> * able to successfully recover with this option (drive will return good</span>
<span class="cm"> * status as soon as the cdb is validated).</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_CDROM_PKTCDVD_WCACHE)</span>
<span class="cp">#define USE_WCACHING		1</span>
<span class="cp">#else</span>
<span class="cp">#define USE_WCACHING		0</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * No user-servicable parts beyond this point -&gt;</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * device types</span>
<span class="cm"> */</span>
<span class="cp">#define PACKET_CDR		1</span>
<span class="cp">#define	PACKET_CDRW		2</span>
<span class="cp">#define PACKET_DVDR		3</span>
<span class="cp">#define PACKET_DVDRW		4</span>

<span class="cm">/*</span>
<span class="cm"> * flags</span>
<span class="cm"> */</span>
<span class="cp">#define PACKET_WRITABLE		1	</span><span class="cm">/* pd is writable */</span><span class="cp"></span>
<span class="cp">#define PACKET_NWA_VALID	2	</span><span class="cm">/* next writable address valid */</span><span class="cp"></span>
<span class="cp">#define PACKET_LRA_VALID	3	</span><span class="cm">/* last recorded address valid */</span><span class="cp"></span>
<span class="cp">#define PACKET_MERGE_SEGS	4	</span><span class="cm">/* perform segment merging to keep */</span><span class="cp"></span>
					<span class="cm">/* underlying cdrom device happy */</span>

<span class="cm">/*</span>
<span class="cm"> * Disc status -- from READ_DISC_INFO</span>
<span class="cm"> */</span>
<span class="cp">#define PACKET_DISC_EMPTY	0</span>
<span class="cp">#define PACKET_DISC_INCOMPLETE	1</span>
<span class="cp">#define PACKET_DISC_COMPLETE	2</span>
<span class="cp">#define PACKET_DISC_OTHER	3</span>

<span class="cm">/*</span>
<span class="cm"> * write type, and corresponding data block type</span>
<span class="cm"> */</span>
<span class="cp">#define PACKET_MODE1		1</span>
<span class="cp">#define PACKET_MODE2		2</span>
<span class="cp">#define PACKET_BLOCK_MODE1	8</span>
<span class="cp">#define PACKET_BLOCK_MODE2	10</span>

<span class="cm">/*</span>
<span class="cm"> * Last session/border status</span>
<span class="cm"> */</span>
<span class="cp">#define PACKET_SESSION_EMPTY		0</span>
<span class="cp">#define PACKET_SESSION_INCOMPLETE	1</span>
<span class="cp">#define PACKET_SESSION_RESERVED		2</span>
<span class="cp">#define PACKET_SESSION_COMPLETE		3</span>

<span class="cp">#define PACKET_MCN			&quot;4a656e734178626f65323030300000&quot;</span>

<span class="cp">#undef PACKET_USE_LS</span>

<span class="cp">#define PKT_CTRL_CMD_SETUP	0</span>
<span class="cp">#define PKT_CTRL_CMD_TEARDOWN	1</span>
<span class="cp">#define PKT_CTRL_CMD_STATUS	2</span>

<span class="k">struct</span> <span class="n">pkt_ctrl_command</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">command</span><span class="p">;</span>				<span class="cm">/* in: Setup, teardown, status */</span>
	<span class="n">__u32</span> <span class="n">dev_index</span><span class="p">;</span>			<span class="cm">/* in/out: Device index */</span>
	<span class="n">__u32</span> <span class="n">dev</span><span class="p">;</span>				<span class="cm">/* in/out: Device nr for cdrw device */</span>
	<span class="n">__u32</span> <span class="n">pkt_dev</span><span class="p">;</span>				<span class="cm">/* in/out: Device nr for packet device */</span>
	<span class="n">__u32</span> <span class="n">num_devices</span><span class="p">;</span>			<span class="cm">/* out: Largest device index + 1 */</span>
	<span class="n">__u32</span> <span class="n">padding</span><span class="p">;</span>				<span class="cm">/* Not used */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * packet ioctls</span>
<span class="cm"> */</span>
<span class="cp">#define PACKET_IOCTL_MAGIC	(&#39;X&#39;)</span>
<span class="cp">#define PACKET_CTRL_CMD		_IOWR(PACKET_IOCTL_MAGIC, 1, struct pkt_ctrl_command)</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/cdrom.h&gt;</span>
<span class="cp">#include &lt;linux/kobject.h&gt;</span>
<span class="cp">#include &lt;linux/sysfs.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>

<span class="cm">/* default bio write queue congestion marks */</span>
<span class="cp">#define PKT_WRITE_CONGESTION_ON    10000</span>
<span class="cp">#define PKT_WRITE_CONGESTION_OFF   9000</span>


<span class="k">struct</span> <span class="n">packet_settings</span>
<span class="p">{</span>
	<span class="n">__u32</span>			<span class="n">size</span><span class="p">;</span>		<span class="cm">/* packet size in (512 byte) sectors */</span>
	<span class="n">__u8</span>			<span class="n">fp</span><span class="p">;</span>		<span class="cm">/* fixed packets */</span>
	<span class="n">__u8</span>			<span class="n">link_loss</span><span class="p">;</span>	<span class="cm">/* the rest is specified</span>
<span class="cm">						 * as per Mt Fuji */</span>
	<span class="n">__u8</span>			<span class="n">write_type</span><span class="p">;</span>
	<span class="n">__u8</span>			<span class="n">track_mode</span><span class="p">;</span>
	<span class="n">__u8</span>			<span class="n">block_mode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Very crude stats for now</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">packet_stats</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">pkt_started</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">pkt_ended</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">secs_w</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">secs_rg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">secs_r</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">packet_cdrw</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">pkt_free_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">pkt_active_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">active_list_lock</span><span class="p">;</span> <span class="cm">/* Serialize access to pkt_active_list */</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">pending_bios</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Switch to high speed reading after reading this many kilobytes</span>
<span class="cm"> * with no interspersed writes.</span>
<span class="cm"> */</span>
<span class="cp">#define HI_SPEED_SWITCH 512</span>

<span class="k">struct</span> <span class="n">packet_iosched</span>
<span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">attention</span><span class="p">;</span>	<span class="cm">/* Set to non-zero when queue processing is needed */</span>
	<span class="kt">int</span>			<span class="n">writing</span><span class="p">;</span>	<span class="cm">/* Non-zero when writing, zero when reading */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* Protecting read/write queue manipulations */</span>
	<span class="k">struct</span> <span class="n">bio_list</span>		<span class="n">read_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_list</span>		<span class="n">write_queue</span><span class="p">;</span>
	<span class="n">sector_t</span>		<span class="n">last_write</span><span class="p">;</span>	<span class="cm">/* The sector where the last write ended */</span>
	<span class="kt">int</span>			<span class="n">successive_reads</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 32 buffers of 2048 bytes</span>
<span class="cm"> */</span>
<span class="cp">#if (PAGE_SIZE % CD_FRAMESIZE) != 0</span>
<span class="cp">#error &quot;PAGE_SIZE must be a multiple of CD_FRAMESIZE&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#define PACKET_MAX_SIZE		128</span>
<span class="cp">#define FRAMES_PER_PAGE		(PAGE_SIZE / CD_FRAMESIZE)</span>
<span class="cp">#define PACKET_MAX_SECTORS	(PACKET_MAX_SIZE * CD_FRAMESIZE &gt;&gt; 9)</span>

<span class="k">enum</span> <span class="n">packet_data_state</span> <span class="p">{</span>
	<span class="n">PACKET_IDLE_STATE</span><span class="p">,</span>			<span class="cm">/* Not used at the moment */</span>
	<span class="n">PACKET_WAITING_STATE</span><span class="p">,</span>			<span class="cm">/* Waiting for more bios to arrive, so */</span>
						<span class="cm">/* we don&#39;t have to do as much */</span>
						<span class="cm">/* data gathering */</span>
	<span class="n">PACKET_READ_WAIT_STATE</span><span class="p">,</span>			<span class="cm">/* Waiting for reads to fill in holes */</span>
	<span class="n">PACKET_WRITE_WAIT_STATE</span><span class="p">,</span>		<span class="cm">/* Waiting for the write to complete */</span>
	<span class="n">PACKET_RECOVERY_STATE</span><span class="p">,</span>			<span class="cm">/* Recover after read/write errors */</span>
	<span class="n">PACKET_FINISHED_STATE</span><span class="p">,</span>			<span class="cm">/* After write has finished */</span>

	<span class="n">PACKET_NUM_STATES</span>			<span class="cm">/* Number of possible states */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Information needed for writing a single packet</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pktcdvd_device</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">packet_data</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>

	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* Lock protecting state transitions and */</span>
						<span class="cm">/* orig_bios list */</span>

	<span class="k">struct</span> <span class="n">bio_list</span>		<span class="n">orig_bios</span><span class="p">;</span>	<span class="cm">/* Original bios passed to pkt_make_request */</span>
						<span class="cm">/* that will be handled by this packet */</span>
	<span class="kt">int</span>			<span class="n">write_size</span><span class="p">;</span>	<span class="cm">/* Total size of all bios in the orig_bios */</span>
						<span class="cm">/* list, measured in number of frames */</span>

	<span class="k">struct</span> <span class="n">bio</span>		<span class="o">*</span><span class="n">w_bio</span><span class="p">;</span>		<span class="cm">/* The bio we will send to the real CD */</span>
						<span class="cm">/* device once we have all data for the */</span>
						<span class="cm">/* packet we are going to write */</span>
	<span class="n">sector_t</span>		<span class="n">sector</span><span class="p">;</span>		<span class="cm">/* First sector in this packet */</span>
	<span class="kt">int</span>			<span class="n">frames</span><span class="p">;</span>		<span class="cm">/* Number of frames in this packet */</span>

	<span class="k">enum</span> <span class="n">packet_data_state</span>	<span class="n">state</span><span class="p">;</span>		<span class="cm">/* Current state */</span>
	<span class="n">atomic_t</span>		<span class="n">run_sm</span><span class="p">;</span>		<span class="cm">/* Incremented whenever the state */</span>
						<span class="cm">/* machine needs to be run */</span>
	<span class="kt">long</span>			<span class="n">sleep_time</span><span class="p">;</span>	<span class="cm">/* Set this to non-zero to make the state */</span>
						<span class="cm">/* machine run after this many jiffies. */</span>

	<span class="n">atomic_t</span>		<span class="n">io_wait</span><span class="p">;</span>	<span class="cm">/* Number of pending IO operations */</span>
	<span class="n">atomic_t</span>		<span class="n">io_errors</span><span class="p">;</span>	<span class="cm">/* Number of read/write errors during IO */</span>

	<span class="k">struct</span> <span class="n">bio</span>		<span class="o">*</span><span class="n">r_bios</span><span class="p">[</span><span class="n">PACKET_MAX_SIZE</span><span class="p">];</span> <span class="cm">/* bios to use during data gathering */</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">pages</span><span class="p">[</span><span class="n">PACKET_MAX_SIZE</span> <span class="o">/</span> <span class="n">FRAMES_PER_PAGE</span><span class="p">];</span>

	<span class="kt">int</span>			<span class="n">cache_valid</span><span class="p">;</span>	<span class="cm">/* If non-zero, the data for the zone defined */</span>
						<span class="cm">/* by the sector variable is completely cached */</span>
						<span class="cm">/* in the pages[] vector. */</span>

	<span class="kt">int</span>			<span class="n">id</span><span class="p">;</span>		<span class="cm">/* ID number for debugging */</span>
	<span class="k">struct</span> <span class="n">pktcdvd_device</span>	<span class="o">*</span><span class="n">pd</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pkt_rb_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span>		<span class="o">*</span><span class="n">bio</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">packet_stacked_data</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span>		<span class="o">*</span><span class="n">bio</span><span class="p">;</span>		<span class="cm">/* Original read request bio */</span>
	<span class="k">struct</span> <span class="n">pktcdvd_device</span>	<span class="o">*</span><span class="n">pd</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define PSD_POOL_SIZE		64</span>

<span class="k">struct</span> <span class="n">pktcdvd_kobj</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span>		<span class="n">kobj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pktcdvd_device</span>	<span class="o">*</span><span class="n">pd</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define to_pktcdvdkobj(_k) \</span>
<span class="cp">  ((struct pktcdvd_kobj*)container_of(_k,struct pktcdvd_kobj,kobj))</span>

<span class="k">struct</span> <span class="n">pktcdvd_device</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">block_device</span>	<span class="o">*</span><span class="n">bdev</span><span class="p">;</span>		<span class="cm">/* dev attached */</span>
	<span class="n">dev_t</span>			<span class="n">pkt_dev</span><span class="p">;</span>	<span class="cm">/* our dev */</span>
	<span class="kt">char</span>			<span class="n">name</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">packet_settings</span>	<span class="n">settings</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">packet_stats</span>	<span class="n">stats</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">refcnt</span><span class="p">;</span>		<span class="cm">/* Open count */</span>
	<span class="kt">int</span>			<span class="n">write_speed</span><span class="p">;</span>	<span class="cm">/* current write speed, kB/s */</span>
	<span class="kt">int</span>			<span class="n">read_speed</span><span class="p">;</span>	<span class="cm">/* current read speed, kB/s */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">offset</span><span class="p">;</span>		<span class="cm">/* start offset */</span>
	<span class="n">__u8</span>			<span class="n">mode_offset</span><span class="p">;</span>	<span class="cm">/* 0 / 8 */</span>
	<span class="n">__u8</span>			<span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="n">__u16</span>			<span class="n">mmc3_profile</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">nwa</span><span class="p">;</span>		<span class="cm">/* next writable address */</span>
	<span class="n">__u32</span>			<span class="n">lra</span><span class="p">;</span>		<span class="cm">/* last recorded address */</span>
	<span class="k">struct</span> <span class="n">packet_cdrw</span>	<span class="n">cdrw</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">wqueue</span><span class="p">;</span>

	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* Serialize access to bio_queue */</span>
	<span class="k">struct</span> <span class="n">rb_root</span>		<span class="n">bio_queue</span><span class="p">;</span>	<span class="cm">/* Work queue of bios we need to handle */</span>
	<span class="kt">int</span>			<span class="n">bio_queue_size</span><span class="p">;</span>	<span class="cm">/* Number of nodes in bio_queue */</span>
	<span class="n">sector_t</span>		<span class="n">current_sector</span><span class="p">;</span>	<span class="cm">/* Keep track of where the elevator is */</span>
	<span class="n">atomic_t</span>		<span class="n">scan_queue</span><span class="p">;</span>	<span class="cm">/* Set to non-zero when pkt_handle_queue */</span>
						<span class="cm">/* needs to be run. */</span>
	<span class="n">mempool_t</span>		<span class="o">*</span><span class="n">rb_pool</span><span class="p">;</span>	<span class="cm">/* mempool for pkt_rb_node allocations */</span>

	<span class="k">struct</span> <span class="n">packet_iosched</span>   <span class="n">iosched</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gendisk</span>		<span class="o">*</span><span class="n">disk</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">write_congestion_off</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">write_congestion_on</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>		<span class="cm">/* sysfs pktcdvd[0-7] dev */</span>
	<span class="k">struct</span> <span class="n">pktcdvd_kobj</span>	<span class="o">*</span><span class="n">kobj_stat</span><span class="p">;</span>	<span class="cm">/* sysfs pktcdvd[0-7]/stat/     */</span>
	<span class="k">struct</span> <span class="n">pktcdvd_kobj</span>	<span class="o">*</span><span class="n">kobj_wqueue</span><span class="p">;</span>	<span class="cm">/* sysfs pktcdvd[0-7]/write_queue/ */</span>

	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">dfs_d_root</span><span class="p">;</span>	<span class="cm">/* debugfs: devname directory */</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">dfs_f_info</span><span class="p">;</span>	<span class="cm">/* debugfs: info file */</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __PKTCDVD_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
