<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › clk.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>clk.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/include/linux/clk.h</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2004 ARM Limited.</span>
<span class="cm"> *  Written by Deep Blue Solutions Limited.</span>
<span class="cm"> *  Copyright (C) 2011-2012 Linaro Ltd &lt;mturquette@linaro.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __LINUX_CLK_H</span>
<span class="cp">#define __LINUX_CLK_H</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>

<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">clk</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_COMMON_CLK</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: clk notifier callback types</span>
<span class="cm"> *</span>
<span class="cm"> * PRE_RATE_CHANGE - called immediately before the clk rate is changed,</span>
<span class="cm"> *     to indicate that the rate change will proceed.  Drivers must</span>
<span class="cm"> *     immediately terminate any operations that will be affected by the</span>
<span class="cm"> *     rate change.  Callbacks may either return NOTIFY_DONE or</span>
<span class="cm"> *     NOTIFY_STOP.</span>
<span class="cm"> *</span>
<span class="cm"> * ABORT_RATE_CHANGE: called if the rate change failed for some reason</span>
<span class="cm"> *     after PRE_RATE_CHANGE.  In this case, all registered notifiers on</span>
<span class="cm"> *     the clk will be called with ABORT_RATE_CHANGE. Callbacks must</span>
<span class="cm"> *     always return NOTIFY_DONE.</span>
<span class="cm"> *</span>
<span class="cm"> * POST_RATE_CHANGE - called after the clk rate change has successfully</span>
<span class="cm"> *     completed.  Callbacks must always return NOTIFY_DONE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define PRE_RATE_CHANGE			BIT(0)</span>
<span class="cp">#define POST_RATE_CHANGE		BIT(1)</span>
<span class="cp">#define ABORT_RATE_CHANGE		BIT(2)</span>

<span class="cm">/**</span>
<span class="cm"> * struct clk_notifier - associate a clk with a notifier</span>
<span class="cm"> * @clk: struct clk * to associate the notifier with</span>
<span class="cm"> * @notifier_head: a blocking_notifier_head for this clk</span>
<span class="cm"> * @node: linked list pointers</span>
<span class="cm"> *</span>
<span class="cm"> * A list of struct clk_notifier is maintained by the notifier code.</span>
<span class="cm"> * An entry is created whenever code registers the first notifier on a</span>
<span class="cm"> * particular @clk.  Future notifiers on that @clk are added to the</span>
<span class="cm"> * @notifier_head.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">clk_notifier</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span>			<span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">srcu_notifier_head</span>	<span class="n">notifier_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">node</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct clk_notifier_data - rate data to pass to the notifier callback</span>
<span class="cm"> * @clk: struct clk * being changed</span>
<span class="cm"> * @old_rate: previous rate of this clk</span>
<span class="cm"> * @new_rate: new rate of this clk</span>
<span class="cm"> *</span>
<span class="cm"> * For a pre-notifier, old_rate is the clk&#39;s rate before this rate</span>
<span class="cm"> * change, and new_rate is what the rate will be in the future.  For a</span>
<span class="cm"> * post-notifier, old_rate and new_rate are both set to the clk&#39;s</span>
<span class="cm"> * current rate (this was done to optimize the implementation).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">clk_notifier_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span>		<span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">old_rate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">new_rate</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">clk_notifier_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">clk_notifier_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>

<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * clk_get - lookup and obtain a reference to a clock producer.</span>
<span class="cm"> * @dev: device for clock &quot;consumer&quot;</span>
<span class="cm"> * @id: clock comsumer ID</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a struct clk corresponding to the clock producer, or</span>
<span class="cm"> * valid IS_ERR() condition containing errno.  The implementation</span>
<span class="cm"> * uses @dev and @id to determine the clock consumer, and thereby</span>
<span class="cm"> * the clock producer.  (IOW, @id may be identical strings, but</span>
<span class="cm"> * clk_get may return different clock producers depending on @dev.)</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers must assume that the clock source is not enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * clk_get should not be called from within interrupt context.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * devm_clk_get - lookup and obtain a managed reference to a clock producer.</span>
<span class="cm"> * @dev: device for clock &quot;consumer&quot;</span>
<span class="cm"> * @id: clock comsumer ID</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a struct clk corresponding to the clock producer, or</span>
<span class="cm"> * valid IS_ERR() condition containing errno.  The implementation</span>
<span class="cm"> * uses @dev and @id to determine the clock consumer, and thereby</span>
<span class="cm"> * the clock producer.  (IOW, @id may be identical strings, but</span>
<span class="cm"> * clk_get may return different clock producers depending on @dev.)</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers must assume that the clock source is not enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * devm_clk_get should not be called from within interrupt context.</span>
<span class="cm"> *</span>
<span class="cm"> * The clock will automatically be freed when the device is unbound</span>
<span class="cm"> * from the bus.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">devm_clk_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clk_prepare - prepare a clock source</span>
<span class="cm"> * @clk: clock source</span>
<span class="cm"> *</span>
<span class="cm"> * This prepares the clock source for use.</span>
<span class="cm"> *</span>
<span class="cm"> * Must not be called from within atomic context.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_HAVE_CLK_PREPARE</span>
<span class="kt">int</span> <span class="n">clk_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">clk_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * clk_enable - inform the system when the clock source should be running.</span>
<span class="cm"> * @clk: clock source</span>
<span class="cm"> *</span>
<span class="cm"> * If the clock can not be enabled/disabled, this should return success.</span>
<span class="cm"> *</span>
<span class="cm"> * May be called from atomic contexts.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns success (0) or negative errno.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">clk_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clk_disable - inform the system when the clock source is no longer required.</span>
<span class="cm"> * @clk: clock source</span>
<span class="cm"> *</span>
<span class="cm"> * Inform the system that a clock source is no longer required by</span>
<span class="cm"> * a driver and may be shut down.</span>
<span class="cm"> *</span>
<span class="cm"> * May be called from atomic contexts.</span>
<span class="cm"> *</span>
<span class="cm"> * Implementation detail: if the clock source is shared between</span>
<span class="cm"> * multiple drivers, clk_enable() calls must be balanced by the</span>
<span class="cm"> * same number of clk_disable() calls for the clock source to be</span>
<span class="cm"> * disabled.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">clk_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * clk_unprepare - undo preparation of a clock source</span>
<span class="cm"> * @clk: clock source</span>
<span class="cm"> *</span>
<span class="cm"> * This undoes a previously prepared clock.  The caller must balance</span>
<span class="cm"> * the number of prepare and unprepare calls.</span>
<span class="cm"> *</span>
<span class="cm"> * Must not be called from within atomic context.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_HAVE_CLK_PREPARE</span>
<span class="kt">void</span> <span class="n">clk_unprepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clk_unprepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* clk_prepare_enable helps cases using clk_enable in non-atomic context. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">clk_prepare_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">clk_prepare</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">clk_enable</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">clk_unprepare</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* clk_disable_unprepare helps cases using clk_disable in non-atomic context. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clk_disable_unprepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">clk_unprepare</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clk_get_rate - obtain the current clock rate (in Hz) for a clock source.</span>
<span class="cm"> *		  This is only valid once the clock source has been enabled.</span>
<span class="cm"> * @clk: clock source</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clk_get_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clk_put	- &quot;free&quot; the clock source</span>
<span class="cm"> * @clk: clock source</span>
<span class="cm"> *</span>
<span class="cm"> * Note: drivers must ensure that all clk_enable calls made on this</span>
<span class="cm"> * clock source are balanced by clk_disable calls prior to calling</span>
<span class="cm"> * this function.</span>
<span class="cm"> *</span>
<span class="cm"> * clk_put should not be called from within interrupt context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">clk_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * devm_clk_put	- &quot;free&quot; a managed clock source</span>
<span class="cm"> * @dev: device used to acuqire the clock</span>
<span class="cm"> * @clk: clock source acquired with devm_clk_get()</span>
<span class="cm"> *</span>
<span class="cm"> * Note: drivers must ensure that all clk_enable calls made on this</span>
<span class="cm"> * clock source are balanced by clk_disable calls prior to calling</span>
<span class="cm"> * this function.</span>
<span class="cm"> *</span>
<span class="cm"> * clk_put should not be called from within interrupt context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">devm_clk_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The remaining APIs are optional for machine class support.</span>
<span class="cm"> */</span>


<span class="cm">/**</span>
<span class="cm"> * clk_round_rate - adjust a rate to the exact rate a clock can provide</span>
<span class="cm"> * @clk: clock source</span>
<span class="cm"> * @rate: desired clock rate in Hz</span>
<span class="cm"> *</span>
<span class="cm"> * Returns rounded clock rate in Hz, or negative errno.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">clk_round_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clk_set_rate - set the clock rate for a clock source</span>
<span class="cm"> * @clk: clock source</span>
<span class="cm"> * @rate: desired clock rate in Hz</span>
<span class="cm"> *</span>
<span class="cm"> * Returns success (0) or negative errno.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">clk_set_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clk_set_parent - set the parent clock source for this clock</span>
<span class="cm"> * @clk: clock source</span>
<span class="cm"> * @parent: parent clock source</span>
<span class="cm"> *</span>
<span class="cm"> * Returns success (0) or negative errno.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">clk_set_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clk_get_parent - get the parent clock source for this clock</span>
<span class="cm"> * @clk: clock source</span>
<span class="cm"> *</span>
<span class="cm"> * Returns struct clk corresponding to parent clock source, or</span>
<span class="cm"> * valid IS_ERR() condition containing errno.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk_get_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clk_get_sys - get a clock based upon the device name</span>
<span class="cm"> * @dev_id: device name</span>
<span class="cm"> * @con_id: connection ID</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a struct clk corresponding to the clock producer, or</span>
<span class="cm"> * valid IS_ERR() condition containing errno.  The implementation</span>
<span class="cm"> * uses @dev_id and @con_id to determine the clock consumer, and</span>
<span class="cm"> * thereby the clock producer. In contrast to clk_get() this function</span>
<span class="cm"> * takes the device name instead of the device itself for identification.</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers must assume that the clock source is not enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * clk_get_sys should not be called from within interrupt context.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk_get_sys</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">con_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clk_add_alias - add a new clock alias</span>
<span class="cm"> * @alias: name for clock alias</span>
<span class="cm"> * @alias_dev_name: device name</span>
<span class="cm"> * @id: platform specific clock name</span>
<span class="cm"> * @dev: device</span>
<span class="cm"> *</span>
<span class="cm"> * Allows using generic clock names for drivers by adding a new alias.</span>
<span class="cm"> * Assumes clkdev, see clkdev.h for more info.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">clk_add_alias</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alias</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alias_dev_name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
