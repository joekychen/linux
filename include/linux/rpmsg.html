<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › rpmsg.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>rpmsg.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Remote processor messaging</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2011 Texas Instruments, Inc.</span>
<span class="cm"> * Copyright (C) 2011 Google, Inc.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> * * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *   notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> * * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *   notice, this list of conditions and the following disclaimer in</span>
<span class="cm"> *   the documentation and/or other materials provided with the</span>
<span class="cm"> *   distribution.</span>
<span class="cm"> * * Neither the name Texas Instruments nor the names of its</span>
<span class="cm"> *   contributors may be used to endorse or promote products derived</span>
<span class="cm"> *   from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_RPMSG_H</span>
<span class="cp">#define _LINUX_RPMSG_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/mod_devicetable.h&gt;</span>

<span class="cm">/* The feature bitmap for virtio rpmsg */</span>
<span class="cp">#define VIRTIO_RPMSG_F_NS	0 </span><span class="cm">/* RP supports name service notifications */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * struct rpmsg_hdr - common header for all rpmsg messages</span>
<span class="cm"> * @src: source address</span>
<span class="cm"> * @dst: destination address</span>
<span class="cm"> * @reserved: reserved for future use</span>
<span class="cm"> * @len: length of payload (in bytes)</span>
<span class="cm"> * @flags: message flags</span>
<span class="cm"> * @data: @len bytes of message payload data</span>
<span class="cm"> *</span>
<span class="cm"> * Every message sent(/received) on the rpmsg bus begins with this header.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpmsg_hdr</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">src</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dst</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct rpmsg_ns_msg - dynamic name service announcement message</span>
<span class="cm"> * @name: name of remote service that is published</span>
<span class="cm"> * @addr: address of remote service that is published</span>
<span class="cm"> * @flags: indicates whether service is created or destroyed</span>
<span class="cm"> *</span>
<span class="cm"> * This message is sent across to publish a new service, or announce</span>
<span class="cm"> * about its removal. When we receive these messages, an appropriate</span>
<span class="cm"> * rpmsg channel (i.e device) is created/destroyed. In turn, the -&gt;probe()</span>
<span class="cm"> * or -&gt;remove() handler of the appropriate rpmsg driver will be invoked</span>
<span class="cm"> * (if/as-soon-as one is registered).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpmsg_ns_msg</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">RPMSG_NAME_SIZE</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * enum rpmsg_ns_flags - dynamic name service announcement flags</span>
<span class="cm"> *</span>
<span class="cm"> * @RPMSG_NS_CREATE: a new remote service was just created</span>
<span class="cm"> * @RPMSG_NS_DESTROY: a known remote service was just destroyed</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">rpmsg_ns_flags</span> <span class="p">{</span>
	<span class="n">RPMSG_NS_CREATE</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RPMSG_NS_DESTROY</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define RPMSG_ADDR_ANY		0xFFFFFFFF</span>

<span class="k">struct</span> <span class="n">virtproc_info</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * rpmsg_channel - devices that belong to the rpmsg bus are called channels</span>
<span class="cm"> * @vrp: the remote processor this channel belongs to</span>
<span class="cm"> * @dev: the device struct</span>
<span class="cm"> * @id: device id (used to match between rpmsg drivers and devices)</span>
<span class="cm"> * @src: local address</span>
<span class="cm"> * @dst: destination address</span>
<span class="cm"> * @ept: the rpmsg endpoint of this channel</span>
<span class="cm"> * @announce: if set, rpmsg will announce the creation/removal of this channel</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtproc_info</span> <span class="o">*</span><span class="n">vrp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpmsg_device_id</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">src</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpmsg_endpoint</span> <span class="o">*</span><span class="n">ept</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">announce</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rpmsg_rx_cb_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct rpmsg_endpoint - binds a local rpmsg address to its user</span>
<span class="cm"> * @rpdev: rpmsg channel device</span>
<span class="cm"> * @cb: rx callback handler</span>
<span class="cm"> * @addr: local rpmsg address</span>
<span class="cm"> * @priv: private data for the driver&#39;s use</span>
<span class="cm"> *</span>
<span class="cm"> * In essence, an rpmsg endpoint represents a listener on the rpmsg bus, as</span>
<span class="cm"> * it binds an rpmsg address with an rx callback handler.</span>
<span class="cm"> *</span>
<span class="cm"> * Simple rpmsg drivers shouldn&#39;t use this struct directly, because</span>
<span class="cm"> * things just work: every rpmsg driver provides an rx callback upon</span>
<span class="cm"> * registering to the bus, and that callback is then bound to its rpmsg</span>
<span class="cm"> * address when the driver is probed. When relevant inbound messages arrive</span>
<span class="cm"> * (i.e. messages which their dst address equals to the src address of</span>
<span class="cm"> * the rpmsg channel), the driver&#39;s handler is invoked to process it.</span>
<span class="cm"> *</span>
<span class="cm"> * More complicated drivers though, that do need to allocate additional rpmsg</span>
<span class="cm"> * addresses, and bind them to different rx callbacks, must explicitly</span>
<span class="cm"> * create additional endpoints by themselves (see rpmsg_create_ept()).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpmsg_endpoint</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span><span class="p">;</span>
	<span class="n">rpmsg_rx_cb_t</span> <span class="n">cb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct rpmsg_driver - rpmsg driver struct</span>
<span class="cm"> * @drv: underlying device driver</span>
<span class="cm"> * @id_table: rpmsg ids serviced by this driver</span>
<span class="cm"> * @probe: invoked when a matching rpmsg channel (i.e. device) is found</span>
<span class="cm"> * @remove: invoked when the rpmsg channel is removed</span>
<span class="cm"> * @callback: invoked when an inbound message is received on the channel</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rpmsg_driver</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_driver</span> <span class="n">drv</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rpmsg_device_id</span> <span class="o">*</span><span class="n">id_table</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">register_rpmsg_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">unregister_rpmsg_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">register_rpmsg_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">unregister_rpmsg_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rpmsg_destroy_ept</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_endpoint</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">rpmsg_endpoint</span> <span class="o">*</span><span class="n">rpmsg_create_ept</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="p">,</span>
				<span class="n">rpmsg_rx_cb_t</span> <span class="n">cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span>
<span class="n">rpmsg_send_offchannel_raw</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">bool</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rpmsg_send() - send a message across to the remote processor</span>
<span class="cm"> * @rpdev: the rpmsg channel</span>
<span class="cm"> * @data: payload of message</span>
<span class="cm"> * @len: length of payload</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends @data of length @len on the @rpdev channel.</span>
<span class="cm"> * The message will be sent to the remote processor which the @rpdev</span>
<span class="cm"> * channel belongs to, using @rpdev&#39;s source and destination addresses.</span>
<span class="cm"> * In case there are no TX buffers available, the function will block until</span>
<span class="cm"> * one becomes available, or a timeout of 15 seconds elapses. When the latter</span>
<span class="cm"> * happens, -ERESTARTSYS is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Can only be called from process context (for now).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success and an appropriate error value on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rpmsg_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">src</span> <span class="o">=</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rpmsg_send_offchannel_raw</span><span class="p">(</span><span class="n">rpdev</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rpmsg_sendto() - send a message across to the remote processor, specify dst</span>
<span class="cm"> * @rpdev: the rpmsg channel</span>
<span class="cm"> * @data: payload of message</span>
<span class="cm"> * @len: length of payload</span>
<span class="cm"> * @dst: destination address</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends @data of length @len to the remote @dst address.</span>
<span class="cm"> * The message will be sent to the remote processor which the @rpdev</span>
<span class="cm"> * channel belongs to, using @rpdev&#39;s source address.</span>
<span class="cm"> * In case there are no TX buffers available, the function will block until</span>
<span class="cm"> * one becomes available, or a timeout of 15 seconds elapses. When the latter</span>
<span class="cm"> * happens, -ERESTARTSYS is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Can only be called from process context (for now).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success and an appropriate error value on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">rpmsg_sendto</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">src</span> <span class="o">=</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rpmsg_send_offchannel_raw</span><span class="p">(</span><span class="n">rpdev</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rpmsg_send_offchannel() - send a message using explicit src/dst addresses</span>
<span class="cm"> * @rpdev: the rpmsg channel</span>
<span class="cm"> * @src: source address</span>
<span class="cm"> * @dst: destination address</span>
<span class="cm"> * @data: payload of message</span>
<span class="cm"> * @len: length of payload</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends @data of length @len to the remote @dst address,</span>
<span class="cm"> * and uses @src as the source address.</span>
<span class="cm"> * The message will be sent to the remote processor which the @rpdev</span>
<span class="cm"> * channel belongs to.</span>
<span class="cm"> * In case there are no TX buffers available, the function will block until</span>
<span class="cm"> * one becomes available, or a timeout of 15 seconds elapses. When the latter</span>
<span class="cm"> * happens, -ERESTARTSYS is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Can only be called from process context (for now).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success and an appropriate error value on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">rpmsg_send_offchannel</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">src</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dst</span><span class="p">,</span>
							<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rpmsg_send_offchannel_raw</span><span class="p">(</span><span class="n">rpdev</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rpmsg_send() - send a message across to the remote processor</span>
<span class="cm"> * @rpdev: the rpmsg channel</span>
<span class="cm"> * @data: payload of message</span>
<span class="cm"> * @len: length of payload</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends @data of length @len on the @rpdev channel.</span>
<span class="cm"> * The message will be sent to the remote processor which the @rpdev</span>
<span class="cm"> * channel belongs to, using @rpdev&#39;s source and destination addresses.</span>
<span class="cm"> * In case there are no TX buffers available, the function will immediately</span>
<span class="cm"> * return -ENOMEM without waiting until one becomes available.</span>
<span class="cm"> *</span>
<span class="cm"> * Can only be called from process context (for now).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success and an appropriate error value on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">rpmsg_trysend</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">src</span> <span class="o">=</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rpmsg_send_offchannel_raw</span><span class="p">(</span><span class="n">rpdev</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rpmsg_sendto() - send a message across to the remote processor, specify dst</span>
<span class="cm"> * @rpdev: the rpmsg channel</span>
<span class="cm"> * @data: payload of message</span>
<span class="cm"> * @len: length of payload</span>
<span class="cm"> * @dst: destination address</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends @data of length @len to the remote @dst address.</span>
<span class="cm"> * The message will be sent to the remote processor which the @rpdev</span>
<span class="cm"> * channel belongs to, using @rpdev&#39;s source address.</span>
<span class="cm"> * In case there are no TX buffers available, the function will immediately</span>
<span class="cm"> * return -ENOMEM without waiting until one becomes available.</span>
<span class="cm"> *</span>
<span class="cm"> * Can only be called from process context (for now).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success and an appropriate error value on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">rpmsg_trysendto</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">src</span> <span class="o">=</span> <span class="n">rpdev</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rpmsg_send_offchannel_raw</span><span class="p">(</span><span class="n">rpdev</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rpmsg_send_offchannel() - send a message using explicit src/dst addresses</span>
<span class="cm"> * @rpdev: the rpmsg channel</span>
<span class="cm"> * @src: source address</span>
<span class="cm"> * @dst: destination address</span>
<span class="cm"> * @data: payload of message</span>
<span class="cm"> * @len: length of payload</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends @data of length @len to the remote @dst address,</span>
<span class="cm"> * and uses @src as the source address.</span>
<span class="cm"> * The message will be sent to the remote processor which the @rpdev</span>
<span class="cm"> * channel belongs to.</span>
<span class="cm"> * In case there are no TX buffers available, the function will immediately</span>
<span class="cm"> * return -ENOMEM without waiting until one becomes available.</span>
<span class="cm"> *</span>
<span class="cm"> * Can only be called from process context (for now).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success and an appropriate error value on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">rpmsg_trysend_offchannel</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpmsg_channel</span> <span class="o">*</span><span class="n">rpdev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">src</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dst</span><span class="p">,</span>
							<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rpmsg_send_offchannel_raw</span><span class="p">(</span><span class="n">rpdev</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_RPMSG_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
