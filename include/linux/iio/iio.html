<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › iio › iio.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>iio.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* The industrial I/O core</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2008 Jonathan Cameron</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _INDUSTRIAL_IO_H_</span>
<span class="cp">#define _INDUSTRIAL_IO_H_</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/cdev.h&gt;</span>
<span class="cp">#include &lt;linux/iio/types.h&gt;</span>
<span class="cm">/* IIO TODO LIST */</span>
<span class="cm">/*</span>
<span class="cm"> * Provide means of adjusting timer accuracy.</span>
<span class="cm"> * Currently assumes nano seconds.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">iio_chan_info_enum</span> <span class="p">{</span>
	<span class="n">IIO_CHAN_INFO_RAW</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IIO_CHAN_INFO_PROCESSED</span><span class="p">,</span>
	<span class="n">IIO_CHAN_INFO_SCALE</span><span class="p">,</span>
	<span class="n">IIO_CHAN_INFO_OFFSET</span><span class="p">,</span>
	<span class="n">IIO_CHAN_INFO_CALIBSCALE</span><span class="p">,</span>
	<span class="n">IIO_CHAN_INFO_CALIBBIAS</span><span class="p">,</span>
	<span class="n">IIO_CHAN_INFO_PEAK</span><span class="p">,</span>
	<span class="n">IIO_CHAN_INFO_PEAK_SCALE</span><span class="p">,</span>
	<span class="n">IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW</span><span class="p">,</span>
	<span class="n">IIO_CHAN_INFO_AVERAGE_RAW</span><span class="p">,</span>
	<span class="n">IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY</span><span class="p">,</span>
	<span class="n">IIO_CHAN_INFO_SAMP_FREQ</span><span class="p">,</span>
	<span class="n">IIO_CHAN_INFO_FREQUENCY</span><span class="p">,</span>
	<span class="n">IIO_CHAN_INFO_PHASE</span><span class="p">,</span>
	<span class="n">IIO_CHAN_INFO_HARDWAREGAIN</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define IIO_CHAN_INFO_SHARED_BIT(type) BIT(type*2)</span>
<span class="cp">#define IIO_CHAN_INFO_SEPARATE_BIT(type) BIT(type*2 + 1)</span>

<span class="cp">#define IIO_CHAN_INFO_RAW_SEPARATE_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_RAW)</span>
<span class="cp">#define IIO_CHAN_INFO_PROCESSED_SEPARATE_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_PROCESSED)</span>
<span class="cp">#define IIO_CHAN_INFO_SCALE_SEPARATE_BIT		\</span>
<span class="cp">	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_SCALE)</span>
<span class="cp">#define IIO_CHAN_INFO_SCALE_SHARED_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_SCALE)</span>
<span class="cp">#define IIO_CHAN_INFO_OFFSET_SEPARATE_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_OFFSET)</span>
<span class="cp">#define IIO_CHAN_INFO_OFFSET_SHARED_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_OFFSET)</span>
<span class="cp">#define IIO_CHAN_INFO_CALIBSCALE_SEPARATE_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_CALIBSCALE)</span>
<span class="cp">#define IIO_CHAN_INFO_CALIBSCALE_SHARED_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_CALIBSCALE)</span>
<span class="cp">#define IIO_CHAN_INFO_CALIBBIAS_SEPARATE_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_CALIBBIAS)</span>
<span class="cp">#define IIO_CHAN_INFO_CALIBBIAS_SHARED_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_CALIBBIAS)</span>
<span class="cp">#define IIO_CHAN_INFO_PEAK_SEPARATE_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_PEAK)</span>
<span class="cp">#define IIO_CHAN_INFO_PEAK_SHARED_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_PEAK)</span>
<span class="cp">#define IIO_CHAN_INFO_PEAKSCALE_SEPARATE_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_PEAKSCALE)</span>
<span class="cp">#define IIO_CHAN_INFO_PEAKSCALE_SHARED_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_PEAKSCALE)</span>
<span class="cp">#define IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW_SEPARATE_BIT	\</span>
<span class="cp">	IIO_CHAN_INFO_SEPARATE_BIT(				\</span>
<span class="cp">		IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW)</span>
<span class="cp">#define IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW_SHARED_BIT	\</span>
<span class="cp">	IIO_CHAN_INFO_SHARED_BIT(				\</span>
<span class="cp">		IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW)</span>
<span class="cp">#define IIO_CHAN_INFO_AVERAGE_RAW_SEPARATE_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_AVERAGE_RAW)</span>
<span class="cp">#define IIO_CHAN_INFO_AVERAGE_RAW_SHARED_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_AVERAGE_RAW)</span>
<span class="cp">#define IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY_SHARED_BIT \</span>
<span class="cp">	IIO_CHAN_INFO_SHARED_BIT(			       \</span>
<span class="cp">		IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY)</span>
<span class="cp">#define IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY_SEPARATE_BIT \</span>
<span class="cp">	IIO_CHAN_INFO_SEPARATE_BIT(			       \</span>
<span class="cp">		IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY)</span>
<span class="cp">#define IIO_CHAN_INFO_SAMP_FREQ_SEPARATE_BIT		\</span>
<span class="cp">	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_SAMP_FREQ)</span>
<span class="cp">#define IIO_CHAN_INFO_SAMP_FREQ_SHARED_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_SAMP_FREQ)</span>
<span class="cp">#define IIO_CHAN_INFO_FREQUENCY_SEPARATE_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_FREQUENCY)</span>
<span class="cp">#define IIO_CHAN_INFO_FREQUENCY_SHARED_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_FREQUENCY)</span>
<span class="cp">#define IIO_CHAN_INFO_PHASE_SEPARATE_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_PHASE)</span>
<span class="cp">#define IIO_CHAN_INFO_PHASE_SHARED_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_PHASE)</span>
<span class="cp">#define IIO_CHAN_INFO_HARDWAREGAIN_SEPARATE_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SEPARATE_BIT(IIO_CHAN_INFO_HARDWAREGAIN)</span>
<span class="cp">#define IIO_CHAN_INFO_HARDWAREGAIN_SHARED_BIT			\</span>
<span class="cp">	IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_HARDWAREGAIN)</span>

<span class="k">enum</span> <span class="n">iio_endian</span> <span class="p">{</span>
	<span class="n">IIO_CPU</span><span class="p">,</span>
	<span class="n">IIO_BE</span><span class="p">,</span>
	<span class="n">IIO_LE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iio_chan_spec</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">iio_dev</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct iio_chan_spec_ext_info - Extended channel info attribute</span>
<span class="cm"> * @name:	Info attribute name</span>
<span class="cm"> * @shared:	Whether this attribute is shared between all channels.</span>
<span class="cm"> * @read:	Read callback for this info attribute, may be NULL.</span>
<span class="cm"> * @write:	Write callback for this info attribute, may be NULL.</span>
<span class="cm"> * @private:	Data private to the driver.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iio_chan_spec_ext_info</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">shared</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">private</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">iio_chan_spec</span> <span class="k">const</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">private</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">iio_chan_spec</span> <span class="k">const</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">uintptr_t</span> <span class="n">private</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct iio_chan_spec - specification of a single channel</span>
<span class="cm"> * @type:		What type of measurement is the channel making.</span>
<span class="cm"> * @channel:		What number or name do we wish to assign the channel.</span>
<span class="cm"> * @channel2:		If there is a second number for a differential</span>
<span class="cm"> *			channel then this is it. If modified is set then the</span>
<span class="cm"> *			value here specifies the modifier.</span>
<span class="cm"> * @address:		Driver specific identifier.</span>
<span class="cm"> * @scan_index:	Monotonic index to give ordering in scans when read</span>
<span class="cm"> *			from a buffer.</span>
<span class="cm"> * @scan_type:		Sign:		&#39;s&#39; or &#39;u&#39; to specify signed or unsigned</span>
<span class="cm"> *			realbits:	Number of valid bits of data</span>
<span class="cm"> *			storage_bits:	Realbits + padding</span>
<span class="cm"> *			shift:		Shift right by this before masking out</span>
<span class="cm"> *					realbits.</span>
<span class="cm"> *			endianness:	little or big endian</span>
<span class="cm"> * @info_mask:		What information is to be exported about this channel.</span>
<span class="cm"> *			This includes calibbias, scale etc.</span>
<span class="cm"> * @event_mask:	What events can this channel produce.</span>
<span class="cm"> * @ext_info:		Array of extended info attributes for this channel.</span>
<span class="cm"> *			The array is NULL terminated, the last element should</span>
<span class="cm"> *			have it&#39;s name field set to NULL.</span>
<span class="cm"> * @extend_name:	Allows labeling of channel attributes with an</span>
<span class="cm"> *			informative name. Note this has no effect codes etc,</span>
<span class="cm"> *			unlike modifiers.</span>
<span class="cm"> * @datasheet_name:	A name used in in kernel mapping of channels. It should</span>
<span class="cm"> *			correspond to the first name that the channel is referred</span>
<span class="cm"> *			to by in the datasheet (e.g. IND), or the nearest</span>
<span class="cm"> *			possible compound name (e.g. IND-INC).</span>
<span class="cm"> * @modified:		Does a modifier apply to this channel. What these are</span>
<span class="cm"> *			depends on the channel type.  Modifier is set in</span>
<span class="cm"> *			channel2. Examples are IIO_MOD_X for axial sensors about</span>
<span class="cm"> *			the &#39;x&#39; axis.</span>
<span class="cm"> * @indexed:		Specify the channel has a numerical index. If not,</span>
<span class="cm"> *			the value in channel will be suppressed for attribute</span>
<span class="cm"> *			but not for event codes. Typically set it to 0 when</span>
<span class="cm"> *			the index is false.</span>
<span class="cm"> * @differential:	Channel is differential.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iio_chan_spec</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">iio_chan_type</span>	<span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">channel</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">channel2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">address</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">scan_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">char</span>	<span class="n">sign</span><span class="p">;</span>
		<span class="n">u8</span>	<span class="n">realbits</span><span class="p">;</span>
		<span class="n">u8</span>	<span class="n">storagebits</span><span class="p">;</span>
		<span class="n">u8</span>	<span class="n">shift</span><span class="p">;</span>
		<span class="k">enum</span> <span class="n">iio_endian</span> <span class="n">endianness</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">scan_type</span><span class="p">;</span>
	<span class="kt">long</span>			<span class="n">info_mask</span><span class="p">;</span>
	<span class="kt">long</span>			<span class="n">event_mask</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iio_chan_spec_ext_info</span> <span class="o">*</span><span class="n">ext_info</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">extend_name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">datasheet_name</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">modified</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">indexed</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">output</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">differential</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define IIO_ST(si, rb, sb, sh)						\</span>
<span class="cp">	{ .sign = si, .realbits = rb, .storagebits = sb, .shift = sh }</span>

<span class="cp">#define IIO_CHAN_SOFT_TIMESTAMP(_si)					\</span>
<span class="cp">	{ .type = IIO_TIMESTAMP, .channel = -1,				\</span>
<span class="cp">			.scan_index = _si, .scan_type = IIO_ST(&#39;s&#39;, 64, 64, 0) }</span>

<span class="cm">/**</span>
<span class="cm"> * iio_get_time_ns() - utility function to get a time stamp for events etc</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">iio_get_time_ns</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * calls getnstimeofday.</span>
<span class="cm">	 * If hrtimers then up to ns accurate, if not microsecond.</span>
<span class="cm">	 */</span>
	<span class="n">ktime_get_real_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">timespec_to_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Device operating modes */</span>
<span class="cp">#define INDIO_DIRECT_MODE		0x01</span>
<span class="cp">#define INDIO_BUFFER_TRIGGERED		0x02</span>
<span class="cp">#define INDIO_BUFFER_HARDWARE		0x08</span>

<span class="cp">#define INDIO_ALL_BUFFER_MODES					\</span>
<span class="cp">	(INDIO_BUFFER_TRIGGERED | INDIO_BUFFER_HARDWARE)</span>

<span class="k">struct</span> <span class="n">iio_trigger</span><span class="p">;</span> <span class="cm">/* forward declaration */</span>
<span class="k">struct</span> <span class="n">iio_dev</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct iio_info - constant information about device</span>
<span class="cm"> * @driver_module:	module structure used to ensure correct</span>
<span class="cm"> *			ownership of chrdevs etc</span>
<span class="cm"> * @event_attrs:	event control attributes</span>
<span class="cm"> * @attrs:		general purpose device attributes</span>
<span class="cm"> * @read_raw:		function to request a value from the device.</span>
<span class="cm"> *			mask specifies which value. Note 0 means a reading of</span>
<span class="cm"> *			the channel in question.  Return value will specify the</span>
<span class="cm"> *			type of value returned by the device. val and val2 will</span>
<span class="cm"> *			contain the elements making up the returned value.</span>
<span class="cm"> * @write_raw:		function to write a value to the device.</span>
<span class="cm"> *			Parameters are the same as for read_raw.</span>
<span class="cm"> * @write_raw_get_fmt:	callback function to query the expected</span>
<span class="cm"> *			format/precision. If not set by the driver, write_raw</span>
<span class="cm"> *			returns IIO_VAL_INT_PLUS_MICRO.</span>
<span class="cm"> * @read_event_config:	find out if the event is enabled.</span>
<span class="cm"> * @write_event_config:	set if the event is enabled.</span>
<span class="cm"> * @read_event_value:	read a value associated with the event. Meaning</span>
<span class="cm"> *			is event dependant. event_code specifies which event.</span>
<span class="cm"> * @write_event_value:	write the value associated with the event.</span>
<span class="cm"> *			Meaning is event dependent.</span>
<span class="cm"> * @validate_trigger:	function to validate the trigger when the</span>
<span class="cm"> *			current trigger gets changed.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">iio_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span>			<span class="o">*</span><span class="n">driver_module</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">attribute_group</span>		<span class="o">*</span><span class="n">event_attrs</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span>	<span class="o">*</span><span class="n">attrs</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_raw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">iio_chan_spec</span> <span class="k">const</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">val2</span><span class="p">,</span>
			<span class="kt">long</span> <span class="n">mask</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_raw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">iio_chan_spec</span> <span class="k">const</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">val</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">val2</span><span class="p">,</span>
			 <span class="kt">long</span> <span class="n">mask</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_raw_get_fmt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">iio_chan_spec</span> <span class="k">const</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
			 <span class="kt">long</span> <span class="n">mask</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_event_config</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">event_code</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_event_config</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="n">event_code</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">state</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_event_value</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">event_code</span><span class="p">,</span>
				<span class="kt">int</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_event_value</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">event_code</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">validate_trigger</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">iio_trigger</span> <span class="o">*</span><span class="n">trig</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">update_scan_mode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">scan_mask</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">debugfs_reg_access</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">writeval</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="o">*</span><span class="n">readval</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct iio_buffer_setup_ops - buffer setup related callbacks</span>
<span class="cm"> * @preenable:		[DRIVER] function to run prior to marking buffer enabled</span>
<span class="cm"> * @postenable:		[DRIVER] function to run after marking buffer enabled</span>
<span class="cm"> * @predisable:		[DRIVER] function to run prior to marking buffer</span>
<span class="cm"> *			disabled</span>
<span class="cm"> * @postdisable:	[DRIVER] function to run after marking buffer disabled</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iio_buffer_setup_ops</span> <span class="p">{</span>
	<span class="kt">int</span>				<span class="p">(</span><span class="o">*</span><span class="n">preenable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>				<span class="p">(</span><span class="o">*</span><span class="n">postenable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>				<span class="p">(</span><span class="o">*</span><span class="n">predisable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>				<span class="p">(</span><span class="o">*</span><span class="n">postdisable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct iio_dev - industrial I/O device</span>
<span class="cm"> * @id:			[INTERN] used to identify device internally</span>
<span class="cm"> * @modes:		[DRIVER] operating modes supported by device</span>
<span class="cm"> * @currentmode:	[DRIVER] current operating mode</span>
<span class="cm"> * @dev:		[DRIVER] device structure, should be assigned a parent</span>
<span class="cm"> *			and owner</span>
<span class="cm"> * @event_interface:	[INTERN] event chrdevs associated with interrupt lines</span>
<span class="cm"> * @buffer:		[DRIVER] any buffer present</span>
<span class="cm"> * @scan_bytes:		[INTERN] num bytes captured to be fed to buffer demux</span>
<span class="cm"> * @mlock:		[INTERN] lock used to prevent simultaneous device state</span>
<span class="cm"> *			changes</span>
<span class="cm"> * @available_scan_masks: [DRIVER] optional array of allowed bitmasks</span>
<span class="cm"> * @masklength:		[INTERN] the length of the mask established from</span>
<span class="cm"> *			channels</span>
<span class="cm"> * @active_scan_mask:	[INTERN] union of all scan masks requested by buffers</span>
<span class="cm"> * @scan_timestamp:	[INTERN] set if any buffers have requested timestamp</span>
<span class="cm"> * @scan_index_timestamp:[INTERN] cache of the index to the timestamp</span>
<span class="cm"> * @trig:		[INTERN] current device trigger (buffer modes)</span>
<span class="cm"> * @pollfunc:		[DRIVER] function run on trigger being received</span>
<span class="cm"> * @channels:		[DRIVER] channel specification structure table</span>
<span class="cm"> * @num_channels:	[DRIVER] number of chanels specified in @channels.</span>
<span class="cm"> * @channel_attr_list:	[INTERN] keep track of automatically created channel</span>
<span class="cm"> *			attributes</span>
<span class="cm"> * @chan_attr_group:	[INTERN] group for all attrs in base directory</span>
<span class="cm"> * @name:		[DRIVER] name of the device.</span>
<span class="cm"> * @info:		[DRIVER] callbacks and constant info from driver</span>
<span class="cm"> * @info_exist_lock:	[INTERN] lock to prevent use during removal</span>
<span class="cm"> * @setup_ops:		[DRIVER] callbacks to call before and after buffer</span>
<span class="cm"> *			enable/disable</span>
<span class="cm"> * @chrdev:		[INTERN] associated character device</span>
<span class="cm"> * @groups:		[INTERN] attribute groups</span>
<span class="cm"> * @groupcounter:	[INTERN] index of next attribute group</span>
<span class="cm"> * @flags:		[INTERN] file ops related flags including busy flag.</span>
<span class="cm"> * @debugfs_dentry:	[INTERN] device specific debugfs dentry.</span>
<span class="cm"> * @cached_reg_addr:	[INTERN] cached register address for debugfs reads.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iio_dev</span> <span class="p">{</span>
	<span class="kt">int</span>				<span class="n">id</span><span class="p">;</span>

	<span class="kt">int</span>				<span class="n">modes</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">currentmode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>			<span class="n">dev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">iio_event_interface</span>	<span class="o">*</span><span class="n">event_interface</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">iio_buffer</span>		<span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">scan_bytes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>			<span class="n">mlock</span><span class="p">;</span>

	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span>		<span class="o">*</span><span class="n">available_scan_masks</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">masklength</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span>		<span class="o">*</span><span class="n">active_scan_mask</span><span class="p">;</span>
	<span class="n">bool</span>				<span class="n">scan_timestamp</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">scan_index_timestamp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iio_trigger</span>		<span class="o">*</span><span class="n">trig</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iio_poll_func</span>		<span class="o">*</span><span class="n">pollfunc</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">iio_chan_spec</span> <span class="k">const</span>	<span class="o">*</span><span class="n">channels</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">num_channels</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">channel_attr_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">attribute_group</span>		<span class="n">chan_attr_group</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iio_info</span>		<span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>			<span class="n">info_exist_lock</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iio_buffer_setup_ops</span>	<span class="o">*</span><span class="n">setup_ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cdev</span>			<span class="n">chrdev</span><span class="p">;</span>
<span class="cp">#define IIO_MAX_GROUPS 6</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span>	<span class="o">*</span><span class="n">groups</span><span class="p">[</span><span class="n">IIO_MAX_GROUPS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span>				<span class="n">groupcounter</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">flags</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_DEBUG_FS)</span>
	<span class="k">struct</span> <span class="n">dentry</span>			<span class="o">*</span><span class="n">debugfs_dentry</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">cached_reg_addr</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * iio_find_channel_from_si() - get channel from its scan index</span>
<span class="cm"> * @indio_dev:		device</span>
<span class="cm"> * @si:			scan index to match</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">iio_chan_spec</span>
<span class="o">*</span><span class="n">iio_find_channel_from_si</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">si</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iio_device_register() - register a device with the IIO subsystem</span>
<span class="cm"> * @indio_dev:		Device structure filled by the device driver</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="n">iio_device_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iio_device_unregister() - unregister a device from the IIO subsystem</span>
<span class="cm"> * @indio_dev:		Device structure representing the device.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="n">iio_device_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iio_push_event() - try to add event to the list for userspace reading</span>
<span class="cm"> * @indio_dev:		IIO device structure</span>
<span class="cm"> * @ev_code:		What event</span>
<span class="cm"> * @timestamp:		When the event occurred</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="n">iio_push_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ev_code</span><span class="p">,</span> <span class="n">s64</span> <span class="n">timestamp</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">iio_bus_type</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * iio_device_put() - reference counted deallocation of struct device</span>
<span class="cm"> * @dev: the iio_device containing the device</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iio_device_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">indio_dev</span><span class="p">)</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * dev_to_iio_dev() - Get IIO device struct from a device struct</span>
<span class="cm"> * @dev: The device embedded in the IIO device</span>
<span class="cm"> *</span>
<span class="cm"> * Note: The device must be a IIO device, otherwise the result is undefined.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="nf">dev_to_iio_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iio_dev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Can we make this smaller? */</span>
<span class="cp">#define IIO_ALIGN L1_CACHE_BYTES</span>
<span class="cm">/**</span>
<span class="cm"> * iio_device_alloc() - allocate an iio_dev from a driver</span>
<span class="cm"> * @sizeof_priv: Space to allocate for private structure.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">iio_device_alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">sizeof_priv</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">iio_priv</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">indio_dev</span> <span class="o">+</span> <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span><span class="p">),</span> <span class="n">IIO_ALIGN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="nf">iio_priv_to_dev</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">priv</span> <span class="o">-</span>
				  <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span><span class="p">),</span> <span class="n">IIO_ALIGN</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iio_device_free() - free an iio_dev from a driver</span>
<span class="cm"> * @dev: the iio_dev associated with the device</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="n">iio_device_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iio_buffer_enabled() - helper function to test if the buffer is enabled</span>
<span class="cm"> * @indio_dev:		IIO device info structure for device</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">iio_buffer_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">currentmode</span>
		<span class="o">&amp;</span> <span class="p">(</span><span class="n">INDIO_BUFFER_TRIGGERED</span> <span class="o">|</span> <span class="n">INDIO_BUFFER_HARDWARE</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * iio_get_debugfs_dentry() - helper function to get the debugfs_dentry</span>
<span class="cm"> * @indio_dev:		IIO device info structure for device</span>
<span class="cm"> **/</span>
<span class="cp">#if defined(CONFIG_DEBUG_FS)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">iio_get_debugfs_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">indio_dev</span><span class="o">-&gt;</span><span class="n">debugfs_dentry</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">iio_get_debugfs_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">iio_dev</span> <span class="o">*</span><span class="n">indio_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* _INDUSTRIAL_IO_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
