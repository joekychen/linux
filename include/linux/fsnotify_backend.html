<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › fsnotify_backend.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>fsnotify_backend.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Filesystem access notification for Linux</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2008 Red Hat, Inc., Eric Paris &lt;eparis@redhat.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __LINUX_FSNOTIFY_BACKEND_H</span>
<span class="cp">#define __LINUX_FSNOTIFY_BACKEND_H</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/idr.h&gt; </span><span class="cm">/* inotify uses this */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/fs.h&gt; </span><span class="cm">/* struct inode */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/path.h&gt; </span><span class="cm">/* struct path */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * IN_* from inotfy.h lines up EXACTLY with FS_*, this is so we can easily</span>
<span class="cm"> * convert between them.  dnotify only needs conversion at watch creation</span>
<span class="cm"> * so no perf loss there.  fanotify isn&#39;t defined yet, so it can use the</span>
<span class="cm"> * wholes if it needs more events.</span>
<span class="cm"> */</span>
<span class="cp">#define FS_ACCESS		0x00000001	</span><span class="cm">/* File was accessed */</span><span class="cp"></span>
<span class="cp">#define FS_MODIFY		0x00000002	</span><span class="cm">/* File was modified */</span><span class="cp"></span>
<span class="cp">#define FS_ATTRIB		0x00000004	</span><span class="cm">/* Metadata changed */</span><span class="cp"></span>
<span class="cp">#define FS_CLOSE_WRITE		0x00000008	</span><span class="cm">/* Writtable file was closed */</span><span class="cp"></span>
<span class="cp">#define FS_CLOSE_NOWRITE	0x00000010	</span><span class="cm">/* Unwrittable file closed */</span><span class="cp"></span>
<span class="cp">#define FS_OPEN			0x00000020	</span><span class="cm">/* File was opened */</span><span class="cp"></span>
<span class="cp">#define FS_MOVED_FROM		0x00000040	</span><span class="cm">/* File was moved from X */</span><span class="cp"></span>
<span class="cp">#define FS_MOVED_TO		0x00000080	</span><span class="cm">/* File was moved to Y */</span><span class="cp"></span>
<span class="cp">#define FS_CREATE		0x00000100	</span><span class="cm">/* Subfile was created */</span><span class="cp"></span>
<span class="cp">#define FS_DELETE		0x00000200	</span><span class="cm">/* Subfile was deleted */</span><span class="cp"></span>
<span class="cp">#define FS_DELETE_SELF		0x00000400	</span><span class="cm">/* Self was deleted */</span><span class="cp"></span>
<span class="cp">#define FS_MOVE_SELF		0x00000800	</span><span class="cm">/* Self was moved */</span><span class="cp"></span>

<span class="cp">#define FS_UNMOUNT		0x00002000	</span><span class="cm">/* inode on umount fs */</span><span class="cp"></span>
<span class="cp">#define FS_Q_OVERFLOW		0x00004000	</span><span class="cm">/* Event queued overflowed */</span><span class="cp"></span>
<span class="cp">#define FS_IN_IGNORED		0x00008000	</span><span class="cm">/* last inotify event here */</span><span class="cp"></span>

<span class="cp">#define FS_OPEN_PERM		0x00010000	</span><span class="cm">/* open event in an permission hook */</span><span class="cp"></span>
<span class="cp">#define FS_ACCESS_PERM		0x00020000	</span><span class="cm">/* access event in a permissions hook */</span><span class="cp"></span>

<span class="cp">#define FS_EXCL_UNLINK		0x04000000	</span><span class="cm">/* do not send events if object is unlinked */</span><span class="cp"></span>
<span class="cp">#define FS_ISDIR		0x40000000	</span><span class="cm">/* event occurred against dir */</span><span class="cp"></span>
<span class="cp">#define FS_IN_ONESHOT		0x80000000	</span><span class="cm">/* only send event once */</span><span class="cp"></span>

<span class="cp">#define FS_DN_RENAME		0x10000000	</span><span class="cm">/* file renamed */</span><span class="cp"></span>
<span class="cp">#define FS_DN_MULTISHOT		0x20000000	</span><span class="cm">/* dnotify multishot */</span><span class="cp"></span>

<span class="cm">/* This inode cares about things that happen to its children.  Always set for</span>
<span class="cm"> * dnotify and inotify. */</span>
<span class="cp">#define FS_EVENT_ON_CHILD	0x08000000</span>

<span class="cm">/* This is a list of all events that may get sent to a parernt based on fs event</span>
<span class="cm"> * happening to inodes inside that directory */</span>
<span class="cp">#define FS_EVENTS_POSS_ON_CHILD   (FS_ACCESS | FS_MODIFY | FS_ATTRIB |\</span>
<span class="cp">				   FS_CLOSE_WRITE | FS_CLOSE_NOWRITE | FS_OPEN |\</span>
<span class="cp">				   FS_MOVED_FROM | FS_MOVED_TO | FS_CREATE |\</span>
<span class="cp">				   FS_DELETE | FS_OPEN_PERM | FS_ACCESS_PERM)</span>

<span class="cp">#define FS_MOVE			(FS_MOVED_FROM | FS_MOVED_TO)</span>

<span class="cp">#define ALL_FSNOTIFY_PERM_EVENTS (FS_OPEN_PERM | FS_ACCESS_PERM)</span>

<span class="cp">#define ALL_FSNOTIFY_EVENTS (FS_ACCESS | FS_MODIFY | FS_ATTRIB | \</span>
<span class="cp">			     FS_CLOSE_WRITE | FS_CLOSE_NOWRITE | FS_OPEN | \</span>
<span class="cp">			     FS_MOVED_FROM | FS_MOVED_TO | FS_CREATE | \</span>
<span class="cp">			     FS_DELETE | FS_DELETE_SELF | FS_MOVE_SELF | \</span>
<span class="cp">			     FS_UNMOUNT | FS_Q_OVERFLOW | FS_IN_IGNORED | \</span>
<span class="cp">			     FS_OPEN_PERM | FS_ACCESS_PERM | FS_EXCL_UNLINK | \</span>
<span class="cp">			     FS_ISDIR | FS_IN_ONESHOT | FS_DN_RENAME | \</span>
<span class="cp">			     FS_DN_MULTISHOT | FS_EVENT_ON_CHILD)</span>

<span class="k">struct</span> <span class="n">fsnotify_group</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">fsnotify_event</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">fsnotify_mark</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">fsnotify_event_private_data</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Each group much define these ops.  The fsnotify infrastructure will call</span>
<span class="cm"> * these operations for each relevant group.</span>
<span class="cm"> *</span>
<span class="cm"> * should_send_event - given a group, inode, and mask this function determines</span>
<span class="cm"> *		if the group is interested in this event.</span>
<span class="cm"> * handle_event - main call for a group to handle an fs event</span>
<span class="cm"> * free_group_priv - called when a group refcnt hits 0 to clean up the private union</span>
<span class="cm"> * freeing-mark - this means that a mark has been flagged to die when everything</span>
<span class="cm"> *		finishes using it.  The function is supplied with what must be a</span>
<span class="cm"> *		valid group and inode to use to clean up.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsnotify_ops</span> <span class="p">{</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">should_send_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">inode_mark</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">vfsmount_mark</span><span class="p">,</span>
				  <span class="n">__u32</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data_type</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">handle_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">inode_mark</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">vfsmount_mark</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free_group_priv</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">freeing_mark</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">mark</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free_event_priv</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fsnotify_event_private_data</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * A group is a &quot;thing&quot; that wants to receive notification about filesystem</span>
<span class="cm"> * events.  The mask holds the subset of event types this group cares about.</span>
<span class="cm"> * refcnt on a group is up to the implementor and at any moment if it goes 0</span>
<span class="cm"> * everything will be cleaned up.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * How the refcnt is used is up to each group.  When the refcnt hits 0</span>
<span class="cm">	 * fsnotify will clean up all of the resources associated with this group.</span>
<span class="cm">	 * As an example, the dnotify group will always have a refcnt=1 and that</span>
<span class="cm">	 * will never change.  Inotify, on the other hand, has a group per</span>
<span class="cm">	 * inotify_init() and the refcnt will hit 0 only when that fd has been</span>
<span class="cm">	 * closed.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span> <span class="n">refcnt</span><span class="p">;</span>		<span class="cm">/* things with interest in this group */</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">fsnotify_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>	<span class="cm">/* how this group handles things */</span>

	<span class="cm">/* needed to send notification to userspace */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">notification_mutex</span><span class="p">;</span>	<span class="cm">/* protect the notification_list */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">notification_list</span><span class="p">;</span>	<span class="cm">/* list of event_holder this group needs to send to userspace */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">notification_waitq</span><span class="p">;</span>	<span class="cm">/* read() on the notification file blocks on this waitq */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">q_len</span><span class="p">;</span>			<span class="cm">/* events on the queue */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_events</span><span class="p">;</span>		<span class="cm">/* maximum events allowed on the list */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Valid fsnotify group priorities.  Events are send in order from highest</span>
<span class="cm">	 * priority to lowest priority.  We default to the lowest priority.</span>
<span class="cm">	 */</span>
	<span class="cp">#define FS_PRIO_0	0 </span><span class="cm">/* normal notifiers, no permissions */</span><span class="cp"></span>
	<span class="cp">#define FS_PRIO_1	1 </span><span class="cm">/* fanotify content based access control */</span><span class="cp"></span>
	<span class="cp">#define FS_PRIO_2	2 </span><span class="cm">/* fanotify pre-content access */</span><span class="cp"></span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">;</span>

	<span class="cm">/* stores all fastpath marks assoc with this group so they can be cleaned on unregister */</span>
	<span class="n">spinlock_t</span> <span class="n">mark_lock</span><span class="p">;</span>		<span class="cm">/* protect marks_list */</span>
	<span class="n">atomic_t</span> <span class="n">num_marks</span><span class="p">;</span>		<span class="cm">/* 1 for each mark and 1 for not being</span>
<span class="cm">					 * past the point of no return when freeing</span>
<span class="cm">					 * a group */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">marks_list</span><span class="p">;</span>	<span class="cm">/* all inode marks for this group */</span>

	<span class="cm">/* groups can define private fields here or use the void *private */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_INOTIFY_USER</span>
		<span class="k">struct</span> <span class="n">inotify_group_private_data</span> <span class="p">{</span>
			<span class="n">spinlock_t</span>	<span class="n">idr_lock</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">idr</span>      <span class="n">idr</span><span class="p">;</span>
			<span class="n">u32</span>             <span class="n">last_wd</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">fasync_struct</span>    <span class="o">*</span><span class="n">fa</span><span class="p">;</span>    <span class="cm">/* async notification */</span>
			<span class="k">struct</span> <span class="n">user_struct</span>      <span class="o">*</span><span class="n">user</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">inotify_data</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FANOTIFY</span>
		<span class="k">struct</span> <span class="n">fanotify_group_private_data</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS</span>
			<span class="cm">/* allows a group to block waiting for a userspace response */</span>
			<span class="k">struct</span> <span class="n">mutex</span> <span class="n">access_mutex</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="n">access_list</span><span class="p">;</span>
			<span class="n">wait_queue_head_t</span> <span class="n">access_waitq</span><span class="p">;</span>
			<span class="n">atomic_t</span> <span class="n">bypass_perm</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FANOTIFY_ACCESS_PERMISSIONS */</span><span class="cp"></span>
			<span class="kt">int</span> <span class="n">f_flags</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_marks</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">fanotify_data</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FANOTIFY */</span><span class="cp"></span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * A single event can be queued in multiple group-&gt;notification_lists.</span>
<span class="cm"> *</span>
<span class="cm"> * each group-&gt;notification_list will point to an event_holder which in turns points</span>
<span class="cm"> * to the actual event that needs to be sent to userspace.</span>
<span class="cm"> *</span>
<span class="cm"> * Seemed cheaper to create a refcnt&#39;d event and a small holder for every group</span>
<span class="cm"> * than create a different event for every group</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsnotify_event_holder</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">event_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Inotify needs to tack data onto an event.  This struct lets us later find the</span>
<span class="cm"> * correct private data of the correct group.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsnotify_event_private_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">event_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * all of the information about the original object we want to now send to</span>
<span class="cm"> * a group.  If you want to carry more info from the accessing task to the</span>
<span class="cm"> * listener this structure is where you need to be adding fields.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we create an event we are also likely going to need a holder</span>
<span class="cm">	 * to link to a group.  So embed one holder in the event.  Means only</span>
<span class="cm">	 * one allocation for the common case where we only have one group</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">fsnotify_event_holder</span> <span class="n">holder</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>	<span class="cm">/* protection for the associated event_holder and private_list */</span>
	<span class="cm">/* to_tell may ONLY be dereferenced during handle_event(). */</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">to_tell</span><span class="p">;</span>	<span class="cm">/* either the inode the event happened to or its parent */</span>
	<span class="cm">/*</span>
<span class="cm">	 * depending on the event type we should have either a path or inode</span>
<span class="cm">	 * We hold a reference on path, but NOT on inode.  Since we have the ref on</span>
<span class="cm">	 * the path, it may be dereferenced at any point during this object&#39;s</span>
<span class="cm">	 * lifetime.  That reference is dropped when this object&#39;s refcnt hits</span>
<span class="cm">	 * 0.  If this event contains an inode instead of a path, the inode may</span>
<span class="cm">	 * ONLY be used during handle_event().</span>
<span class="cm">	 */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="p">};</span>
<span class="cm">/* when calling fsnotify tell it if the data is a path or inode */</span>
<span class="cp">#define FSNOTIFY_EVENT_NONE	0</span>
<span class="cp">#define FSNOTIFY_EVENT_PATH	1</span>
<span class="cp">#define FSNOTIFY_EVENT_INODE	2</span>
	<span class="kt">int</span> <span class="n">data_type</span><span class="p">;</span>		<span class="cm">/* which of the above union we have */</span>
	<span class="n">atomic_t</span> <span class="n">refcnt</span><span class="p">;</span>	<span class="cm">/* how many groups still are using/need to send this event */</span>
	<span class="n">__u32</span> <span class="n">mask</span><span class="p">;</span>		<span class="cm">/* the type of access, bitwise OR for FS_* event types */</span>

	<span class="n">u32</span> <span class="n">sync_cookie</span><span class="p">;</span>	<span class="cm">/* used to corrolate events, namely inotify mv events */</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file_name</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">tgid</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS</span>
	<span class="n">__u32</span> <span class="n">response</span><span class="p">;</span>	<span class="cm">/* userspace answer to question */</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FANOTIFY_ACCESS_PERMISSIONS */</span><span class="cp"></span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">private_data_list</span><span class="p">;</span>	<span class="cm">/* groups can store private data here */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Inode specific fields in an fsnotify_mark</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsnotify_inode_mark</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>		<span class="cm">/* inode this mark is associated with */</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">i_list</span><span class="p">;</span>	<span class="cm">/* list of marks by inode-&gt;i_fsnotify_marks */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">free_i_list</span><span class="p">;</span>	<span class="cm">/* tmp list used when freeing this mark */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Mount point specific fields in an fsnotify_mark</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsnotify_vfsmount_mark</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">;</span>		<span class="cm">/* vfsmount this mark is associated with */</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">m_list</span><span class="p">;</span>	<span class="cm">/* list of marks by inode-&gt;i_fsnotify_marks */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">free_m_list</span><span class="p">;</span>	<span class="cm">/* tmp list used when freeing this mark */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * a mark is simply an object attached to an in core inode which allows an</span>
<span class="cm"> * fsnotify listener to indicate they are either no longer interested in events</span>
<span class="cm"> * of a type matching mask or only interested in those events.</span>
<span class="cm"> *</span>
<span class="cm"> * these are flushed when an inode is evicted from core and may be flushed</span>
<span class="cm"> * when the inode is modified (as seen by fsnotify_access).  Some fsnotify users</span>
<span class="cm"> * (such as dnotify) will flush these when the open fd is closed and not at</span>
<span class="cm"> * inode eviction or modification.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">mask</span><span class="p">;</span>			<span class="cm">/* mask this mark is for */</span>
	<span class="cm">/* we hold ref for each i_list and g_list.  also one ref for each &#39;thing&#39;</span>
<span class="cm">	 * in kernel that found and may be using this mark. */</span>
	<span class="n">atomic_t</span> <span class="n">refcnt</span><span class="p">;</span>		<span class="cm">/* active things looking at this mark */</span>
	<span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">;</span>	<span class="cm">/* group this mark is for */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">g_list</span><span class="p">;</span>	<span class="cm">/* list of marks by group-&gt;i_fsnotify_marks */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>		<span class="cm">/* protect group and inode */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fsnotify_inode_mark</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">fsnotify_vfsmount_mark</span> <span class="n">m</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">free_g_list</span><span class="p">;</span>	<span class="cm">/* tmp list used when freeing this mark */</span>
	<span class="n">__u32</span> <span class="n">ignored_mask</span><span class="p">;</span>		<span class="cm">/* events types to ignore */</span>
<span class="cp">#define FSNOTIFY_MARK_FLAG_INODE		0x01</span>
<span class="cp">#define FSNOTIFY_MARK_FLAG_VFSMOUNT		0x02</span>
<span class="cp">#define FSNOTIFY_MARK_FLAG_OBJECT_PINNED	0x04</span>
<span class="cp">#define FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY	0x08</span>
<span class="cp">#define FSNOTIFY_MARK_FLAG_ALIVE		0x10</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* vfsmount or inode mark? */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">destroy_list</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free_mark</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">mark</span><span class="p">);</span> <span class="cm">/* called on final put+free */</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_FSNOTIFY</span>

<span class="cm">/* called from the vfs helpers */</span>

<span class="cm">/* main fsnotify call to send events */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fsnotify</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">to_tell</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data_is</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cookie</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__fsnotify_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__fsnotify_inode_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__fsnotify_vfsmount_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">fsnotify_get_cookie</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fsnotify_inode_watches_children</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* FS_EVENT_ON_CHILD is set if the inode may care */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fsnotify_mask</span> <span class="o">&amp;</span> <span class="n">FS_EVENT_ON_CHILD</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* this inode might care about child events, does it care about the</span>
<span class="cm">	 * specific set of events that can happen on a child? */</span>
	<span class="k">return</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fsnotify_mask</span> <span class="o">&amp;</span> <span class="n">FS_EVENTS_POSS_ON_CHILD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update the dentry with a flag indicating the interest of its parent to receive</span>
<span class="cm"> * filesystem events when those events happens to this dentry-&gt;d_inode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__fsnotify_update_dcache_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Serialisation of setting PARENT_WATCHED on the dentries is provided</span>
<span class="cm">	 * by d_lock. If inotify_inode_watched changes after we have taken</span>
<span class="cm">	 * d_lock, the following __fsnotify_update_child_dentry_flags call will</span>
<span class="cm">	 * find our entry, so it will spin until we complete here, and update</span>
<span class="cm">	 * us with the new state.</span>
<span class="cm">	 */</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">&amp;&amp;</span> <span class="n">fsnotify_inode_watches_children</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">))</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_FSNOTIFY_PARENT_WATCHED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DCACHE_FSNOTIFY_PARENT_WATCHED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fsnotify_d_instantiate - instantiate a dentry for inode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__fsnotify_d_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">__fsnotify_update_dcache_flags</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* called from fsnotify listeners, such as fanotify or dnotify */</span>

<span class="cm">/* get a reference to an existing or create a new group */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">fsnotify_alloc_group</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">fsnotify_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="cm">/* drop reference on a group from fsnotify_alloc_group */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_put_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">);</span>

<span class="cm">/* take a reference to an event */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_get_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_put_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
<span class="cm">/* find private data previously attached to an event and unlink it */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">fsnotify_event_private_data</span> <span class="o">*</span><span class="n">fsnotify_remove_priv_from_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span>
									   <span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>

<span class="cm">/* attach the event to the group notification queue */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="o">*</span><span class="n">fsnotify_add_notify_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span>
							<span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
							<span class="k">struct</span> <span class="n">fsnotify_event_private_data</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
							<span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">merge</span><span class="p">)(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">,</span>
											<span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="o">*</span><span class="p">));</span>
<span class="cm">/* true if the group notification queue is empty */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">fsnotify_notify_queue_is_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">);</span>
<span class="cm">/* return, but do not dequeue the first event on the notification queue */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="o">*</span><span class="n">fsnotify_peek_notify_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">);</span>
<span class="cm">/* return AND dequeue the first event on the notification queue */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="o">*</span><span class="n">fsnotify_remove_notify_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">);</span>

<span class="cm">/* functions used to manipulate the marks attached to inodes */</span>

<span class="cm">/* run all marks associated with a vfsmount and update mnt-&gt;mnt_fsnotify_mask */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_recalc_vfsmount_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">);</span>
<span class="cm">/* run all marks associated with an inode and update inode-&gt;i_fsnotify_mask */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_recalc_inode_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_init_mark</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">mark</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free_mark</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">mark</span><span class="p">));</span>
<span class="cm">/* find (and take a reference) to a mark associated with group and inode */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">fsnotify_find_inode_mark</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="cm">/* find (and take a reference) to a mark associated with group and vfsmount */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">fsnotify_find_vfsmount_mark</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">);</span>
<span class="cm">/* copy the values from old into new */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_duplicate_mark</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">old</span><span class="p">);</span>
<span class="cm">/* set the ignored_mask of a mark */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_set_mark_ignored_mask_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">mark</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">mask</span><span class="p">);</span>
<span class="cm">/* set the mask of a mark (might pin the object into memory */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_set_mark_mask_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">mark</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">mask</span><span class="p">);</span>
<span class="cm">/* attach the mark to both the group and the inode */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fsnotify_add_mark</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">mark</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">allow_dups</span><span class="p">);</span>
<span class="cm">/* given a mark, flag it to be freed when all references are dropped */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_destroy_mark</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">mark</span><span class="p">);</span>
<span class="cm">/* run all the marks in a group, and clear all of the vfsmount marks */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_clear_vfsmount_marks_by_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">);</span>
<span class="cm">/* run all the marks in a group, and clear all of the inode marks */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_clear_inode_marks_by_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">);</span>
<span class="cm">/* run all the marks in a group, and clear all of the marks where mark-&gt;flags &amp; flags is true*/</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_clear_marks_by_group_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="cm">/* run all the marks in a group, and flag them to be freed */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_clear_marks_by_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_get_mark</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">mark</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_put_mark</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">mark</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsnotify_unmount_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>

<span class="cm">/* put here because inotify does some weird stuff when destroying watches */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="o">*</span><span class="n">fsnotify_create_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">to_tell</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">mask</span><span class="p">,</span>
						    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data_is</span><span class="p">,</span>
						    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
						    <span class="n">u32</span> <span class="n">cookie</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/* fanotify likes to change events after they are on lists... */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="o">*</span><span class="n">fsnotify_clone_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="o">*</span><span class="n">old_event</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fsnotify_replace_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_event_holder</span> <span class="o">*</span><span class="n">old_holder</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="o">*</span><span class="n">new_event</span><span class="p">);</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fsnotify</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">to_tell</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data_is</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__fsnotify_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__fsnotify_inode_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__fsnotify_vfsmount_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__fsnotify_update_dcache_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__fsnotify_d_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">fsnotify_get_cookie</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fsnotify_unmount_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{}</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_FSNOTIFY */</span><span class="cp"></span>

<span class="cp">#endif	</span><span class="cm">/* __KERNEL __ */</span><span class="cp"></span>

<span class="cp">#endif	</span><span class="cm">/* __LINUX_FSNOTIFY_BACKEND_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
