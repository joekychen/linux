<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › clocksource.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>clocksource.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*  linux/include/linux/clocksource.h</span>
<span class="cm"> *</span>
<span class="cm"> *  This file contains the structure definitions for clocksources.</span>
<span class="cm"> *</span>
<span class="cm"> *  If you are not a clocksource, or timekeeping code, you should</span>
<span class="cm"> *  not be including this file!</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _LINUX_CLOCKSOURCE_H</span>
<span class="cp">#define _LINUX_CLOCKSOURCE_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/timex.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;asm/div64.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cm">/* clocksource cycle base type */</span>
<span class="k">typedef</span> <span class="n">u64</span> <span class="n">cycle_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">clocksource</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_ARCH_CLOCKSOURCE_DATA</span>
<span class="cp">#include &lt;asm/clocksource.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * struct cyclecounter - hardware abstraction for a free running counter</span>
<span class="cm"> *	Provides completely state-free accessors to the underlying hardware.</span>
<span class="cm"> *	Depending on which hardware it reads, the cycle counter may wrap</span>
<span class="cm"> *	around quickly. Locking rules (if necessary) have to be defined</span>
<span class="cm"> *	by the implementor and user of specific instances of this API.</span>
<span class="cm"> *</span>
<span class="cm"> * @read:		returns the current cycle value</span>
<span class="cm"> * @mask:		bitmask for two&#39;s complement</span>
<span class="cm"> *			subtraction of non 64 bit counters,</span>
<span class="cm"> *			see CLOCKSOURCE_MASK() helper macro</span>
<span class="cm"> * @mult:		cycle to nanosecond multiplier</span>
<span class="cm"> * @shift:		cycle to nanosecond divisor (power of two)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cyclecounter</span> <span class="p">{</span>
	<span class="n">cycle_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cyclecounter</span> <span class="o">*</span><span class="n">cc</span><span class="p">);</span>
	<span class="n">cycle_t</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mult</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">shift</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct timecounter - layer above a %struct cyclecounter which counts nanoseconds</span>
<span class="cm"> *	Contains the state needed by timecounter_read() to detect</span>
<span class="cm"> *	cycle counter wrap around. Initialize with</span>
<span class="cm"> *	timecounter_init(). Also used to convert cycle counts into the</span>
<span class="cm"> *	corresponding nanosecond counts with timecounter_cyc2time(). Users</span>
<span class="cm"> *	of this code are responsible for initializing the underlying</span>
<span class="cm"> *	cycle counter hardware, locking issues and reading the time</span>
<span class="cm"> *	more often than the cycle counter wraps around. The nanosecond</span>
<span class="cm"> *	counter will only wrap around after ~585 years.</span>
<span class="cm"> *</span>
<span class="cm"> * @cc:			the cycle counter used by this instance</span>
<span class="cm"> * @cycle_last:		most recent cycle counter value seen by</span>
<span class="cm"> *			timecounter_read()</span>
<span class="cm"> * @nsec:		continuously increasing count</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">timecounter</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cyclecounter</span> <span class="o">*</span><span class="n">cc</span><span class="p">;</span>
	<span class="n">cycle_t</span> <span class="n">cycle_last</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">nsec</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * cyclecounter_cyc2ns - converts cycle counter cycles to nanoseconds</span>
<span class="cm"> * @cc:		Pointer to cycle counter.</span>
<span class="cm"> * @cycles:	Cycles</span>
<span class="cm"> *</span>
<span class="cm"> * XXX - This could use some mult_lxl_ll() asm optimization. Same code</span>
<span class="cm"> * as in cyc2ns, but with unsigned result.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">cyclecounter_cyc2ns</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cyclecounter</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span>
				      <span class="n">cycle_t</span> <span class="n">cycles</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">cycles</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret</span> <span class="o">*</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * timecounter_init - initialize a time counter</span>
<span class="cm"> * @tc:			Pointer to time counter which is to be initialized/reset</span>
<span class="cm"> * @cc:			A cycle counter, ready to be used.</span>
<span class="cm"> * @start_tstamp:	Arbitrary initial time stamp.</span>
<span class="cm"> *</span>
<span class="cm"> * After this call the current cycle register (roughly) corresponds to</span>
<span class="cm"> * the initial time stamp. Every call to timecounter_read() increments</span>
<span class="cm"> * the time stamp counter by the number of elapsed nanoseconds.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">timecounter_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">timecounter</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">cyclecounter</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span>
			     <span class="n">u64</span> <span class="n">start_tstamp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * timecounter_read - return nanoseconds elapsed since timecounter_init()</span>
<span class="cm"> *                    plus the initial time stamp</span>
<span class="cm"> * @tc:          Pointer to time counter.</span>
<span class="cm"> *</span>
<span class="cm"> * In other words, keeps track of time since the same epoch as</span>
<span class="cm"> * the function which generated the initial time stamp.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">u64</span> <span class="n">timecounter_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">timecounter</span> <span class="o">*</span><span class="n">tc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * timecounter_cyc2time - convert a cycle counter to same</span>
<span class="cm"> *                        time base as values returned by</span>
<span class="cm"> *                        timecounter_read()</span>
<span class="cm"> * @tc:		Pointer to time counter.</span>
<span class="cm"> * @cycle_tstamp:	a value returned by tc-&gt;cc-&gt;read()</span>
<span class="cm"> *</span>
<span class="cm"> * Cycle counts that are converted correctly as long as they</span>
<span class="cm"> * fall into the interval [-1/2 max cycle count, +1/2 max cycle count],</span>
<span class="cm"> * with &quot;max cycle count&quot; == cs-&gt;mask+1.</span>
<span class="cm"> *</span>
<span class="cm"> * This allows conversion of cycle counter values which were generated</span>
<span class="cm"> * in the past.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">u64</span> <span class="n">timecounter_cyc2time</span><span class="p">(</span><span class="k">struct</span> <span class="n">timecounter</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span>
				<span class="n">cycle_t</span> <span class="n">cycle_tstamp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct clocksource - hardware abstraction for a free running counter</span>
<span class="cm"> *	Provides mostly state-free accessors to the underlying hardware.</span>
<span class="cm"> *	This is the structure used for system time.</span>
<span class="cm"> *</span>
<span class="cm"> * @name:		ptr to clocksource name</span>
<span class="cm"> * @list:		list head for registration</span>
<span class="cm"> * @rating:		rating value for selection (higher is better)</span>
<span class="cm"> *			To avoid rating inflation the following</span>
<span class="cm"> *			list should give you a guide as to how</span>
<span class="cm"> *			to assign your clocksource a rating</span>
<span class="cm"> *			1-99: Unfit for real use</span>
<span class="cm"> *				Only available for bootup and testing purposes.</span>
<span class="cm"> *			100-199: Base level usability.</span>
<span class="cm"> *				Functional for real use, but not desired.</span>
<span class="cm"> *			200-299: Good.</span>
<span class="cm"> *				A correct and usable clocksource.</span>
<span class="cm"> *			300-399: Desired.</span>
<span class="cm"> *				A reasonably fast and accurate clocksource.</span>
<span class="cm"> *			400-499: Perfect</span>
<span class="cm"> *				The ideal clocksource. A must-use where</span>
<span class="cm"> *				available.</span>
<span class="cm"> * @read:		returns a cycle value, passes clocksource as argument</span>
<span class="cm"> * @enable:		optional function to enable the clocksource</span>
<span class="cm"> * @disable:		optional function to disable the clocksource</span>
<span class="cm"> * @mask:		bitmask for two&#39;s complement</span>
<span class="cm"> *			subtraction of non 64 bit counters</span>
<span class="cm"> * @mult:		cycle to nanosecond multiplier</span>
<span class="cm"> * @shift:		cycle to nanosecond divisor (power of two)</span>
<span class="cm"> * @max_idle_ns:	max idle time permitted by the clocksource (nsecs)</span>
<span class="cm"> * @maxadj:		maximum adjustment value to mult (~11%)</span>
<span class="cm"> * @flags:		flags describing special properties</span>
<span class="cm"> * @archdata:		arch-specific data</span>
<span class="cm"> * @suspend:		suspend function for the clocksource, if necessary</span>
<span class="cm"> * @resume:		resume function for the clocksource, if necessary</span>
<span class="cm"> * @cycle_last:		most recent cycle counter value seen by ::read()</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">clocksource</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Hotpath data, fits in a single cache line when the</span>
<span class="cm">	 * clocksource itself is cacheline aligned.</span>
<span class="cm">	 */</span>
	<span class="n">cycle_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
	<span class="n">cycle_t</span> <span class="n">cycle_last</span><span class="p">;</span>
	<span class="n">cycle_t</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mult</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">shift</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">max_idle_ns</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">maxadj</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ARCH_CLOCKSOURCE_DATA</span>
	<span class="k">struct</span> <span class="n">arch_clocksource_data</span> <span class="n">archdata</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rating</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>

	<span class="cm">/* private: */</span>
<span class="cp">#ifdef CONFIG_CLOCKSOURCE_WATCHDOG</span>
	<span class="cm">/* Watchdog related data, used by the framework */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">wd_list</span><span class="p">;</span>
	<span class="n">cycle_t</span> <span class="n">cs_last</span><span class="p">;</span>
	<span class="n">cycle_t</span> <span class="n">wd_last</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Clock source flags bits::</span>
<span class="cm"> */</span>
<span class="cp">#define CLOCK_SOURCE_IS_CONTINUOUS		0x01</span>
<span class="cp">#define CLOCK_SOURCE_MUST_VERIFY		0x02</span>

<span class="cp">#define CLOCK_SOURCE_WATCHDOG			0x10</span>
<span class="cp">#define CLOCK_SOURCE_VALID_FOR_HRES		0x20</span>
<span class="cp">#define CLOCK_SOURCE_UNSTABLE			0x40</span>

<span class="cm">/* simplify initialization of mask field */</span>
<span class="cp">#define CLOCKSOURCE_MASK(bits) (cycle_t)((bits) &lt; 64 ? ((1ULL&lt;&lt;(bits))-1) : -1)</span>

<span class="cm">/**</span>
<span class="cm"> * clocksource_khz2mult - calculates mult from khz and shift</span>
<span class="cm"> * @khz:		Clocksource frequency in KHz</span>
<span class="cm"> * @shift_constant:	Clocksource shift factor</span>
<span class="cm"> *</span>
<span class="cm"> * Helper functions that converts a khz counter frequency to a timsource</span>
<span class="cm"> * multiplier, given the clocksource shift value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">clocksource_khz2mult</span><span class="p">(</span><span class="n">u32</span> <span class="n">khz</span><span class="p">,</span> <span class="n">u32</span> <span class="n">shift_constant</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*  khz = cyc/(Million ns)</span>
<span class="cm">	 *  mult/2^shift  = ns/cyc</span>
<span class="cm">	 *  mult = ns/cyc * 2^shift</span>
<span class="cm">	 *  mult = 1Million/khz * 2^shift</span>
<span class="cm">	 *  mult = 1000000 * 2^shift / khz</span>
<span class="cm">	 *  mult = (1000000&lt;&lt;shift) / khz</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="mi">1000000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">shift_constant</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">+=</span> <span class="n">khz</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="cm">/* round for do_div */</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">khz</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clocksource_hz2mult - calculates mult from hz and shift</span>
<span class="cm"> * @hz:			Clocksource frequency in Hz</span>
<span class="cm"> * @shift_constant:	Clocksource shift factor</span>
<span class="cm"> *</span>
<span class="cm"> * Helper functions that converts a hz counter</span>
<span class="cm"> * frequency to a timsource multiplier, given the</span>
<span class="cm"> * clocksource shift value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">clocksource_hz2mult</span><span class="p">(</span><span class="n">u32</span> <span class="n">hz</span><span class="p">,</span> <span class="n">u32</span> <span class="n">shift_constant</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*  hz = cyc/(Billion ns)</span>
<span class="cm">	 *  mult/2^shift  = ns/cyc</span>
<span class="cm">	 *  mult = ns/cyc * 2^shift</span>
<span class="cm">	 *  mult = 1Billion/hz * 2^shift</span>
<span class="cm">	 *  mult = 1000000000 * 2^shift / hz</span>
<span class="cm">	 *  mult = (1000000000&lt;&lt;shift) / hz</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="mi">1000000000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">shift_constant</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">+=</span> <span class="n">hz</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="cm">/* round for do_div */</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">hz</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clocksource_cyc2ns - converts clocksource cycles to nanoseconds</span>
<span class="cm"> * @cycles:	cycles</span>
<span class="cm"> * @mult:	cycle to nanosecond multiplier</span>
<span class="cm"> * @shift:	cycle to nanosecond divisor (power of two)</span>
<span class="cm"> *</span>
<span class="cm"> * Converts cycles to nanoseconds, using the given mult and shift.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX - This could use some mult_lxl_ll() asm optimization</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">clocksource_cyc2ns</span><span class="p">(</span><span class="n">cycle_t</span> <span class="n">cycles</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mult</span><span class="p">,</span> <span class="n">u32</span> <span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">cycles</span> <span class="o">*</span> <span class="n">mult</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">extern</span> <span class="kt">int</span> <span class="n">clocksource_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span><span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">clocksource_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span><span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">clocksource_touch_watchdog</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">clocksource</span><span class="o">*</span> <span class="n">clocksource_get_next</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">clocksource_change_rating</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rating</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">clocksource_suspend</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">clocksource_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span> <span class="n">__init</span> <span class="n">__weak</span> <span class="n">clocksource_default_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">clocksource_mark_unstable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span>
<span class="n">clocks_calc_mult_shift</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">mult</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">shift</span><span class="p">,</span> <span class="n">u32</span> <span class="n">from</span><span class="p">,</span> <span class="n">u32</span> <span class="n">to</span><span class="p">,</span> <span class="n">u32</span> <span class="n">minsec</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Don&#39;t call __clocksource_register_scale directly, use</span>
<span class="cm"> * clocksource_register_hz/khz</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span>
<span class="n">__clocksource_register_scale</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">scale</span><span class="p">,</span> <span class="n">u32</span> <span class="n">freq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>
<span class="n">__clocksource_updatefreq_scale</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">scale</span><span class="p">,</span> <span class="n">u32</span> <span class="n">freq</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">clocksource_register_hz</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__clocksource_register_scale</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hz</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">clocksource_register_khz</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">khz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__clocksource_register_scale</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">khz</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__clocksource_updatefreq_hz</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__clocksource_updatefreq_scale</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hz</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__clocksource_updatefreq_khz</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">khz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__clocksource_updatefreq_scale</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">khz</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_GENERIC_TIME_VSYSCALL</span>
<span class="k">extern</span> <span class="kt">void</span>
<span class="n">update_vsyscall</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">wtm</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mult</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">update_vsyscall_tz</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">update_vsyscall</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">wtm</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mult</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vsyscall_tz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">timekeeping_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">clock</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">cycle_t</span> <span class="n">clocksource_mmio_readl_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">cycle_t</span> <span class="n">clocksource_mmio_readl_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">cycle_t</span> <span class="n">clocksource_mmio_readw_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">cycle_t</span> <span class="n">clocksource_mmio_readw_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">clocksource_mmio_init</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="n">cycle_t</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="p">));</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">clocksource_i8253_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_CLOCKSOURCE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
