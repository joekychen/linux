<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › dm-log-userspace.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dm-log-userspace.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2006-2009 Red Hat, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the LGPL.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __DM_LOG_USERSPACE_H__</span>
<span class="cp">#define __DM_LOG_USERSPACE_H__</span>

<span class="cp">#include &lt;linux/dm-ioctl.h&gt; </span><span class="cm">/* For DM_UUID_LEN */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The device-mapper userspace log module consists of a kernel component and</span>
<span class="cm"> * a user-space component.  The kernel component implements the API defined</span>
<span class="cm"> * in dm-dirty-log.h.  Its purpose is simply to pass the parameters and</span>
<span class="cm"> * return values of those API functions between kernel and user-space.</span>
<span class="cm"> *</span>
<span class="cm"> * Below are defined the &#39;request_types&#39; - DM_ULOG_CTR, DM_ULOG_DTR, etc.</span>
<span class="cm"> * These request types represent the different functions in the device-mapper</span>
<span class="cm"> * dirty log API.  Each of these is described in more detail below.</span>
<span class="cm"> *</span>
<span class="cm"> * The user-space program must listen for requests from the kernel (representing</span>
<span class="cm"> * the various API functions) and process them.</span>
<span class="cm"> *</span>
<span class="cm"> * User-space begins by setting up the communication link (error checking</span>
<span class="cm"> * removed for clarity):</span>
<span class="cm"> *	fd = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);</span>
<span class="cm"> *	addr.nl_family = AF_NETLINK;</span>
<span class="cm"> *	addr.nl_groups = CN_IDX_DM;</span>
<span class="cm"> *	addr.nl_pid = 0;</span>
<span class="cm"> *	r = bind(fd, (struct sockaddr *) &amp;addr, sizeof(addr));</span>
<span class="cm"> *	opt = addr.nl_groups;</span>
<span class="cm"> *	setsockopt(fd, SOL_NETLINK, NETLINK_ADD_MEMBERSHIP, &amp;opt, sizeof(opt));</span>
<span class="cm"> *</span>
<span class="cm"> * User-space will then wait to receive requests form the kernel, which it</span>
<span class="cm"> * will process as described below.  The requests are received in the form,</span>
<span class="cm"> * ((struct dm_ulog_request) + (additional data)).  Depending on the request</span>
<span class="cm"> * type, there may or may not be &#39;additional data&#39;.  In the descriptions below,</span>
<span class="cm"> * you will see &#39;Payload-to-userspace&#39; and &#39;Payload-to-kernel&#39;.  The</span>
<span class="cm"> * &#39;Payload-to-userspace&#39; is what the kernel sends in &#39;additional data&#39; as</span>
<span class="cm"> * necessary parameters to complete the request.  The &#39;Payload-to-kernel&#39; is</span>
<span class="cm"> * the &#39;additional data&#39; returned to the kernel that contains the necessary</span>
<span class="cm"> * results of the request.  The &#39;data_size&#39; field in the dm_ulog_request</span>
<span class="cm"> * structure denotes the availability and amount of payload data.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_CTR corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * int (*ctr)(struct dm_dirty_log *log, struct dm_target *ti,</span>
<span class="cm"> *	      unsigned argc, char **argv);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	A single string containing all the argv arguments separated by &#39; &#39;s</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	A NUL-terminated string that is the name of the device that is used</span>
<span class="cm"> *	as the backing store for the log data.  &#39;dm_get_device&#39; will be called</span>
<span class="cm"> *	on this device.  (&#39;dm_put_device&#39; will be called on this device</span>
<span class="cm"> *	automatically after calling DM_ULOG_DTR.)  If there is no device needed</span>
<span class="cm"> *	for log data, &#39;data_size&#39; in the dm_ulog_request struct should be 0.</span>
<span class="cm"> *</span>
<span class="cm"> * The UUID contained in the dm_ulog_request structure is the reference that</span>
<span class="cm"> * will be used by all request types to a specific log.  The constructor must</span>
<span class="cm"> * record this association with the instance created.</span>
<span class="cm"> *</span>
<span class="cm"> * When the request has been processed, user-space must return the</span>
<span class="cm"> * dm_ulog_request to the kernel - setting the &#39;error&#39; field, filling the</span>
<span class="cm"> * data field with the log device if necessary, and setting &#39;data_size&#39;</span>
<span class="cm"> * appropriately.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_CTR                    1</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_DTR corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * void (*dtr)(struct dm_dirty_log *log);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	A single string containing all the argv arguments separated by &#39; &#39;s</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	None.  (&#39;data_size&#39; in the dm_ulog_request struct should be 0.)</span>
<span class="cm"> *</span>
<span class="cm"> * The UUID contained in the dm_ulog_request structure is all that is</span>
<span class="cm"> * necessary to identify the log instance being destroyed.  There is no</span>
<span class="cm"> * payload data.</span>
<span class="cm"> *</span>
<span class="cm"> * When the request has been processed, user-space must return the</span>
<span class="cm"> * dm_ulog_request to the kernel - setting the &#39;error&#39; field and clearing</span>
<span class="cm"> * &#39;data_size&#39; appropriately.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_DTR                    2</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_PRESUSPEND corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * int (*presuspend)(struct dm_dirty_log *log);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	None.</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> * The UUID contained in the dm_ulog_request structure is all that is</span>
<span class="cm"> * necessary to identify the log instance being presuspended.  There is no</span>
<span class="cm"> * payload data.</span>
<span class="cm"> *</span>
<span class="cm"> * When the request has been processed, user-space must return the</span>
<span class="cm"> * dm_ulog_request to the kernel - setting the &#39;error&#39; field and</span>
<span class="cm"> * &#39;data_size&#39; appropriately.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_PRESUSPEND             3</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_POSTSUSPEND corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * int (*postsuspend)(struct dm_dirty_log *log);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	None.</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> * The UUID contained in the dm_ulog_request structure is all that is</span>
<span class="cm"> * necessary to identify the log instance being postsuspended.  There is no</span>
<span class="cm"> * payload data.</span>
<span class="cm"> *</span>
<span class="cm"> * When the request has been processed, user-space must return the</span>
<span class="cm"> * dm_ulog_request to the kernel - setting the &#39;error&#39; field and</span>
<span class="cm"> * &#39;data_size&#39; appropriately.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_POSTSUSPEND            4</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_RESUME corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * int (*resume)(struct dm_dirty_log *log);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	None.</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> * The UUID contained in the dm_ulog_request structure is all that is</span>
<span class="cm"> * necessary to identify the log instance being resumed.  There is no</span>
<span class="cm"> * payload data.</span>
<span class="cm"> *</span>
<span class="cm"> * When the request has been processed, user-space must return the</span>
<span class="cm"> * dm_ulog_request to the kernel - setting the &#39;error&#39; field and</span>
<span class="cm"> * &#39;data_size&#39; appropriately.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_RESUME                 5</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_GET_REGION_SIZE corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * uint32_t (*get_region_size)(struct dm_dirty_log *log);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	None.</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	uint64_t - contains the region size</span>
<span class="cm"> *</span>
<span class="cm"> * The region size is something that was determined at constructor time.</span>
<span class="cm"> * It is returned in the payload area and &#39;data_size&#39; is set to</span>
<span class="cm"> * reflect this.</span>
<span class="cm"> *</span>
<span class="cm"> * When the request has been processed, user-space must return the</span>
<span class="cm"> * dm_ulog_request to the kernel - setting the &#39;error&#39; field appropriately.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_GET_REGION_SIZE        6</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_IS_CLEAN corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * int (*is_clean)(struct dm_dirty_log *log, region_t region);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	uint64_t - the region to get clean status on</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	int64_t  - 1 if clean, 0 otherwise</span>
<span class="cm"> *</span>
<span class="cm"> * Payload is sizeof(uint64_t) and contains the region for which the clean</span>
<span class="cm"> * status is being made.</span>
<span class="cm"> *</span>
<span class="cm"> * When the request has been processed, user-space must return the</span>
<span class="cm"> * dm_ulog_request to the kernel - filling the payload with 0 (not clean) or</span>
<span class="cm"> * 1 (clean), setting &#39;data_size&#39; and &#39;error&#39; appropriately.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_IS_CLEAN               7</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_IN_SYNC corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * int (*in_sync)(struct dm_dirty_log *log, region_t region,</span>
<span class="cm"> *		  int can_block);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	uint64_t - the region to get sync status on</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	int64_t - 1 if in-sync, 0 otherwise</span>
<span class="cm"> *</span>
<span class="cm"> * Exactly the same as &#39;is_clean&#39; above, except this time asking &quot;has the</span>
<span class="cm"> * region been recovered?&quot; vs. &quot;is the region not being modified?&quot;</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_IN_SYNC                8</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_FLUSH corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * int (*flush)(struct dm_dirty_log *log);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	None.</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> * No incoming or outgoing payload.  Simply flush log state to disk.</span>
<span class="cm"> *</span>
<span class="cm"> * When the request has been processed, user-space must return the</span>
<span class="cm"> * dm_ulog_request to the kernel - setting the &#39;error&#39; field and clearing</span>
<span class="cm"> * &#39;data_size&#39; appropriately.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_FLUSH                  9</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_MARK_REGION corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * void (*mark_region)(struct dm_dirty_log *log, region_t region);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	uint64_t [] - region(s) to mark</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> * Incoming payload contains the one or more regions to mark dirty.</span>
<span class="cm"> * The number of regions contained in the payload can be determined from</span>
<span class="cm"> * &#39;data_size/sizeof(uint64_t)&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * When the request has been processed, user-space must return the</span>
<span class="cm"> * dm_ulog_request to the kernel - setting the &#39;error&#39; field and clearing</span>
<span class="cm"> * &#39;data_size&#39; appropriately.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_MARK_REGION           10</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_CLEAR_REGION corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * void (*clear_region)(struct dm_dirty_log *log, region_t region);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	uint64_t [] - region(s) to clear</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> * Incoming payload contains the one or more regions to mark clean.</span>
<span class="cm"> * The number of regions contained in the payload can be determined from</span>
<span class="cm"> * &#39;data_size/sizeof(uint64_t)&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * When the request has been processed, user-space must return the</span>
<span class="cm"> * dm_ulog_request to the kernel - setting the &#39;error&#39; field and clearing</span>
<span class="cm"> * &#39;data_size&#39; appropriately.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_CLEAR_REGION          11</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_GET_RESYNC_WORK corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * int (*get_resync_work)(struct dm_dirty_log *log, region_t *region);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	None.</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	{</span>
<span class="cm"> *		int64_t i; -- 1 if recovery necessary, 0 otherwise</span>
<span class="cm"> *		uint64_t r; -- The region to recover if i=1</span>
<span class="cm"> *	}</span>
<span class="cm"> * &#39;data_size&#39; should be set appropriately.</span>
<span class="cm"> *</span>
<span class="cm"> * When the request has been processed, user-space must return the</span>
<span class="cm"> * dm_ulog_request to the kernel - setting the &#39;error&#39; field appropriately.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_GET_RESYNC_WORK       12</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_SET_REGION_SYNC corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * void (*set_region_sync)(struct dm_dirty_log *log,</span>
<span class="cm"> *			   region_t region, int in_sync);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	{</span>
<span class="cm"> *		uint64_t - region to set sync state on</span>
<span class="cm"> *		int64_t  - 0 if not-in-sync, 1 if in-sync</span>
<span class="cm"> *	}</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> * When the request has been processed, user-space must return the</span>
<span class="cm"> * dm_ulog_request to the kernel - setting the &#39;error&#39; field and clearing</span>
<span class="cm"> * &#39;data_size&#39; appropriately.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_SET_REGION_SYNC       13</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_GET_SYNC_COUNT corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * region_t (*get_sync_count)(struct dm_dirty_log *log);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	None.</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	uint64_t - the number of in-sync regions</span>
<span class="cm"> *</span>
<span class="cm"> * No incoming payload.  Kernel-bound payload contains the number of</span>
<span class="cm"> * regions that are in-sync (in a size_t).</span>
<span class="cm"> *</span>
<span class="cm"> * When the request has been processed, user-space must return the</span>
<span class="cm"> * dm_ulog_request to the kernel - setting the &#39;error&#39; field and</span>
<span class="cm"> * &#39;data_size&#39; appropriately.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_GET_SYNC_COUNT        14</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_STATUS_INFO corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * int (*status)(struct dm_dirty_log *log, STATUSTYPE_INFO,</span>
<span class="cm"> *		 char *result, unsigned maxlen);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	None.</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	Character string containing STATUSTYPE_INFO</span>
<span class="cm"> *</span>
<span class="cm"> * When the request has been processed, user-space must return the</span>
<span class="cm"> * dm_ulog_request to the kernel - setting the &#39;error&#39; field and</span>
<span class="cm"> * &#39;data_size&#39; appropriately.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_STATUS_INFO           15</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_STATUS_TABLE corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * int (*status)(struct dm_dirty_log *log, STATUSTYPE_TABLE,</span>
<span class="cm"> *		 char *result, unsigned maxlen);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	None.</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	Character string containing STATUSTYPE_TABLE</span>
<span class="cm"> *</span>
<span class="cm"> * When the request has been processed, user-space must return the</span>
<span class="cm"> * dm_ulog_request to the kernel - setting the &#39;error&#39; field and</span>
<span class="cm"> * &#39;data_size&#39; appropriately.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_STATUS_TABLE          16</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_IS_REMOTE_RECOVERING corresponds to (found in dm-dirty-log.h):</span>
<span class="cm"> * int (*is_remote_recovering)(struct dm_dirty_log *log, region_t region);</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	uint64_t - region to determine recovery status on</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	{</span>
<span class="cm"> *		int64_t is_recovering;  -- 0 if no, 1 if yes</span>
<span class="cm"> *		uint64_t in_sync_hint;  -- lowest region still needing resync</span>
<span class="cm"> *	}</span>
<span class="cm"> *</span>
<span class="cm"> * When the request has been processed, user-space must return the</span>
<span class="cm"> * dm_ulog_request to the kernel - setting the &#39;error&#39; field and</span>
<span class="cm"> * &#39;data_size&#39; appropriately.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_IS_REMOTE_RECOVERING  17</span>

<span class="cm">/*</span>
<span class="cm"> * (DM_ULOG_REQUEST_MASK &amp; request_type) to get the request type</span>
<span class="cm"> *</span>
<span class="cm"> * Payload-to-userspace:</span>
<span class="cm"> *	A single string containing all the argv arguments separated by &#39; &#39;s</span>
<span class="cm"> * Payload-to-kernel:</span>
<span class="cm"> *	None.  (&#39;data_size&#39; in the dm_ulog_request struct should be 0.)</span>
<span class="cm"> *</span>
<span class="cm"> * We are reserving 8 bits of the 32-bit &#39;request_type&#39; field for the</span>
<span class="cm"> * various request types above.  The remaining 24-bits are currently</span>
<span class="cm"> * set to zero and are reserved for future use and compatibility concerns.</span>
<span class="cm"> *</span>
<span class="cm"> * User-space should always use DM_ULOG_REQUEST_TYPE to acquire the</span>
<span class="cm"> * request type from the &#39;request_type&#39; field to maintain forward compatibility.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_REQUEST_MASK 0xFF</span>
<span class="cp">#define DM_ULOG_REQUEST_TYPE(request_type) \</span>
<span class="cp">	(DM_ULOG_REQUEST_MASK &amp; (request_type))</span>

<span class="cm">/*</span>
<span class="cm"> * DM_ULOG_REQUEST_VERSION is incremented when there is a</span>
<span class="cm"> * change to the way information is passed between kernel</span>
<span class="cm"> * and userspace.  This could be a structure change of</span>
<span class="cm"> * dm_ulog_request or a change in the way requests are</span>
<span class="cm"> * issued/handled.  Changes are outlined here:</span>
<span class="cm"> *	version 1:  Initial implementation</span>
<span class="cm"> *	version 2:  DM_ULOG_CTR allowed to return a string containing a</span>
<span class="cm"> *	            device name that is to be registered with DM via</span>
<span class="cm"> *	            &#39;dm_get_device&#39;.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ULOG_REQUEST_VERSION 2</span>

<span class="k">struct</span> <span class="n">dm_ulog_request</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The local unique identifier (luid) and the universally unique</span>
<span class="cm">	 * identifier (uuid) are used to tie a request to a specific</span>
<span class="cm">	 * mirror log.  A single machine log could probably make due with</span>
<span class="cm">	 * just the &#39;luid&#39;, but a cluster-aware log must use the &#39;uuid&#39; and</span>
<span class="cm">	 * the &#39;luid&#39;.  The uuid is what is required for node to node</span>
<span class="cm">	 * communication concerning a particular log, but the &#39;luid&#39; helps</span>
<span class="cm">	 * differentiate between logs that are being swapped and have the</span>
<span class="cm">	 * same &#39;uuid&#39;.  (Think &quot;live&quot; and &quot;inactive&quot; device-mapper tables.)</span>
<span class="cm">	 */</span>
	<span class="kt">uint64_t</span> <span class="n">luid</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">uuid</span><span class="p">[</span><span class="n">DM_UUID_LEN</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">padding</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>        <span class="cm">/* Padding because DM_UUID_LEN = 129 */</span>

	<span class="kt">uint32_t</span> <span class="n">version</span><span class="p">;</span>       <span class="cm">/* See DM_ULOG_REQUEST_VERSION */</span>
	<span class="kt">int32_t</span> <span class="n">error</span><span class="p">;</span>          <span class="cm">/* Used to report back processing errors */</span>

	<span class="kt">uint32_t</span> <span class="n">seq</span><span class="p">;</span>           <span class="cm">/* Sequence number for request */</span>
	<span class="kt">uint32_t</span> <span class="n">request_type</span><span class="p">;</span>  <span class="cm">/* DM_ULOG_* defined above */</span>
	<span class="kt">uint32_t</span> <span class="n">data_size</span><span class="p">;</span>     <span class="cm">/* How much data (not including this struct) */</span>

	<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* __DM_LOG_USERSPACE_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
