<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › ptrace.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ptrace.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_PTRACE_H</span>
<span class="cp">#define _LINUX_PTRACE_H</span>
<span class="cm">/* ptrace.h */</span>
<span class="cm">/* structs and defines to help the user use the ptrace system call. */</span>

<span class="cm">/* has the defines to get at the registers. */</span>

<span class="cp">#define PTRACE_TRACEME		   0</span>
<span class="cp">#define PTRACE_PEEKTEXT		   1</span>
<span class="cp">#define PTRACE_PEEKDATA		   2</span>
<span class="cp">#define PTRACE_PEEKUSR		   3</span>
<span class="cp">#define PTRACE_POKETEXT		   4</span>
<span class="cp">#define PTRACE_POKEDATA		   5</span>
<span class="cp">#define PTRACE_POKEUSR		   6</span>
<span class="cp">#define PTRACE_CONT		   7</span>
<span class="cp">#define PTRACE_KILL		   8</span>
<span class="cp">#define PTRACE_SINGLESTEP	   9</span>

<span class="cp">#define PTRACE_ATTACH		  16</span>
<span class="cp">#define PTRACE_DETACH		  17</span>

<span class="cp">#define PTRACE_SYSCALL		  24</span>

<span class="cm">/* 0x4200-0x4300 are reserved for architecture-independent additions.  */</span>
<span class="cp">#define PTRACE_SETOPTIONS	0x4200</span>
<span class="cp">#define PTRACE_GETEVENTMSG	0x4201</span>
<span class="cp">#define PTRACE_GETSIGINFO	0x4202</span>
<span class="cp">#define PTRACE_SETSIGINFO	0x4203</span>

<span class="cm">/*</span>
<span class="cm"> * Generic ptrace interface that exports the architecture specific regsets</span>
<span class="cm"> * using the corresponding NT_* types (which are also used in the core dump).</span>
<span class="cm"> * Please note that the NT_PRSTATUS note type in a core dump contains a full</span>
<span class="cm"> * &#39;struct elf_prstatus&#39;. But the user_regset for NT_PRSTATUS contains just the</span>
<span class="cm"> * elf_gregset_t that is the pr_reg field of &#39;struct elf_prstatus&#39;. For all the</span>
<span class="cm"> * other user_regset flavors, the user_regset layout and the ELF core dump note</span>
<span class="cm"> * payload are exactly the same layout.</span>
<span class="cm"> *</span>
<span class="cm"> * This interface usage is as follows:</span>
<span class="cm"> *	struct iovec iov = { buf, len};</span>
<span class="cm"> *</span>
<span class="cm"> *	ret = ptrace(PTRACE_GETREGSET/PTRACE_SETREGSET, pid, NT_XXX_TYPE, &amp;iov);</span>
<span class="cm"> *</span>
<span class="cm"> * On the successful completion, iov.len will be updated by the kernel,</span>
<span class="cm"> * specifying how much the kernel has written/read to/from the user&#39;s iov.buf.</span>
<span class="cm"> */</span>
<span class="cp">#define PTRACE_GETREGSET	0x4204</span>
<span class="cp">#define PTRACE_SETREGSET	0x4205</span>

<span class="cp">#define PTRACE_SEIZE		0x4206</span>
<span class="cp">#define PTRACE_INTERRUPT	0x4207</span>
<span class="cp">#define PTRACE_LISTEN		0x4208</span>

<span class="cm">/* Wait extended result codes for the above trace options.  */</span>
<span class="cp">#define PTRACE_EVENT_FORK	1</span>
<span class="cp">#define PTRACE_EVENT_VFORK	2</span>
<span class="cp">#define PTRACE_EVENT_CLONE	3</span>
<span class="cp">#define PTRACE_EVENT_EXEC	4</span>
<span class="cp">#define PTRACE_EVENT_VFORK_DONE	5</span>
<span class="cp">#define PTRACE_EVENT_EXIT	6</span>
<span class="cp">#define PTRACE_EVENT_SECCOMP	7</span>
<span class="cm">/* Extended result codes which enabled by means other than options.  */</span>
<span class="cp">#define PTRACE_EVENT_STOP	128</span>

<span class="cm">/* Options set using PTRACE_SETOPTIONS or using PTRACE_SEIZE @data param */</span>
<span class="cp">#define PTRACE_O_TRACESYSGOOD	1</span>
<span class="cp">#define PTRACE_O_TRACEFORK	(1 &lt;&lt; PTRACE_EVENT_FORK)</span>
<span class="cp">#define PTRACE_O_TRACEVFORK	(1 &lt;&lt; PTRACE_EVENT_VFORK)</span>
<span class="cp">#define PTRACE_O_TRACECLONE	(1 &lt;&lt; PTRACE_EVENT_CLONE)</span>
<span class="cp">#define PTRACE_O_TRACEEXEC	(1 &lt;&lt; PTRACE_EVENT_EXEC)</span>
<span class="cp">#define PTRACE_O_TRACEVFORKDONE	(1 &lt;&lt; PTRACE_EVENT_VFORK_DONE)</span>
<span class="cp">#define PTRACE_O_TRACEEXIT	(1 &lt;&lt; PTRACE_EVENT_EXIT)</span>
<span class="cp">#define PTRACE_O_TRACESECCOMP	(1 &lt;&lt; PTRACE_EVENT_SECCOMP)</span>

<span class="cp">#define PTRACE_O_MASK		0x000000ff</span>

<span class="cp">#include &lt;asm/ptrace.h&gt;</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cm">/*</span>
<span class="cm"> * Ptrace flags</span>
<span class="cm"> *</span>
<span class="cm"> * The owner ship rules for task-&gt;ptrace which holds the ptrace</span>
<span class="cm"> * flags is simple.  When a task is running it owns it&#39;s task-&gt;ptrace</span>
<span class="cm"> * flags.  When the a task is stopped the ptracer owns task-&gt;ptrace.</span>
<span class="cm"> */</span>

<span class="cp">#define PT_SEIZED	0x00010000	</span><span class="cm">/* SEIZE used, enable new behavior */</span><span class="cp"></span>
<span class="cp">#define PT_PTRACED	0x00000001</span>
<span class="cp">#define PT_DTRACE	0x00000002	</span><span class="cm">/* delayed trace (used on m68k, i386) */</span><span class="cp"></span>
<span class="cp">#define PT_PTRACE_CAP	0x00000004	</span><span class="cm">/* ptracer can follow suid-exec */</span><span class="cp"></span>

<span class="cp">#define PT_OPT_FLAG_SHIFT	3</span>
<span class="cm">/* PT_TRACE_* event enable flags */</span>
<span class="cp">#define PT_EVENT_FLAG(event)	(1 &lt;&lt; (PT_OPT_FLAG_SHIFT + (event)))</span>
<span class="cp">#define PT_TRACESYSGOOD		PT_EVENT_FLAG(0)</span>
<span class="cp">#define PT_TRACE_FORK		PT_EVENT_FLAG(PTRACE_EVENT_FORK)</span>
<span class="cp">#define PT_TRACE_VFORK		PT_EVENT_FLAG(PTRACE_EVENT_VFORK)</span>
<span class="cp">#define PT_TRACE_CLONE		PT_EVENT_FLAG(PTRACE_EVENT_CLONE)</span>
<span class="cp">#define PT_TRACE_EXEC		PT_EVENT_FLAG(PTRACE_EVENT_EXEC)</span>
<span class="cp">#define PT_TRACE_VFORK_DONE	PT_EVENT_FLAG(PTRACE_EVENT_VFORK_DONE)</span>
<span class="cp">#define PT_TRACE_EXIT		PT_EVENT_FLAG(PTRACE_EVENT_EXIT)</span>
<span class="cp">#define PT_TRACE_SECCOMP	PT_EVENT_FLAG(PTRACE_EVENT_SECCOMP)</span>

<span class="cm">/* single stepping state bits (used on ARM and PA-RISC) */</span>
<span class="cp">#define PT_SINGLESTEP_BIT	31</span>
<span class="cp">#define PT_SINGLESTEP		(1&lt;&lt;PT_SINGLESTEP_BIT)</span>
<span class="cp">#define PT_BLOCKSTEP_BIT	30</span>
<span class="cp">#define PT_BLOCKSTEP		(1&lt;&lt;PT_BLOCKSTEP_BIT)</span>

<span class="cp">#include &lt;linux/compiler.h&gt;		</span><span class="cm">/* For unlikely.  */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/sched.h&gt;		</span><span class="cm">/* For struct task_struct.  */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/err.h&gt;			</span><span class="cm">/* for IS_ERR_VALUE */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/bug.h&gt;			</span><span class="cm">/* For BUG_ON.  */</span><span class="cp"></span>


<span class="k">extern</span> <span class="kt">long</span> <span class="n">arch_ptrace</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="kt">long</span> <span class="n">request</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ptrace_readdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">src</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ptrace_writedata</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ptrace_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ptrace_check_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ignore_state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ptrace_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="kt">long</span> <span class="n">request</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ptrace_notify</span><span class="p">(</span><span class="kt">int</span> <span class="n">exit_code</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__ptrace_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">new_parent</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__ptrace_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">exit_ptrace</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tracer</span><span class="p">);</span>
<span class="cp">#define PTRACE_MODE_READ	0x01</span>
<span class="cp">#define PTRACE_MODE_ATTACH	0x02</span>
<span class="cp">#define PTRACE_MODE_NOAUDIT	0x04</span>
<span class="cm">/* Returns 0 on success, -errno on denial. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__ptrace_may_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="cm">/* Returns true on success, false on denial. */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">ptrace_may_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ptrace_reparented</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">same_thread_group</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">,</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ptrace_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">))</span>
		<span class="n">__ptrace_unlink</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">generic_ptrace_peekdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">generic_ptrace_pokedata</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ptrace_parent - return the task that is tracing the given task</span>
<span class="cm"> * @task: task to consider</span>
<span class="cm"> *</span>
<span class="cm"> * Returns %NULL if no one is tracing @task, or the &amp;struct task_struct</span>
<span class="cm"> * pointer to its tracer.</span>
<span class="cm"> *</span>
<span class="cm"> * Must called under rcu_read_lock().  The pointer returned might be kept</span>
<span class="cm"> * live only by RCU.  During exec, this may be called with task_lock() held</span>
<span class="cm"> * on @task, still held from when check_unsafe_exec() was called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">ptrace_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ptrace_event_enabled - test whether a ptrace event is enabled</span>
<span class="cm"> * @task: ptracee of interest</span>
<span class="cm"> * @event: %PTRACE_EVENT_* to test</span>
<span class="cm"> *</span>
<span class="cm"> * Test whether @event is enabled for ptracee @task.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns %true if @event is enabled, %false otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ptrace_event_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;</span> <span class="n">PT_EVENT_FLAG</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ptrace_event - possibly stop for a ptrace event notification</span>
<span class="cm"> * @event:	%PTRACE_EVENT_* value to report</span>
<span class="cm"> * @message:	value for %PTRACE_GETEVENTMSG to return</span>
<span class="cm"> *</span>
<span class="cm"> * Check whether @event is enabled and, if so, report @event and @message</span>
<span class="cm"> * to the ptrace parent.</span>
<span class="cm"> *</span>
<span class="cm"> * Called without locks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ptrace_event</span><span class="p">(</span><span class="kt">int</span> <span class="n">event</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ptrace_event_enabled</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">event</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">ptrace_message</span> <span class="o">=</span> <span class="n">message</span><span class="p">;</span>
		<span class="n">ptrace_notify</span><span class="p">((</span><span class="n">event</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">SIGTRAP</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">PTRACE_EVENT_EXEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* legacy EXEC report via SIGTRAP */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PT_PTRACED</span><span class="o">|</span><span class="n">PT_SEIZED</span><span class="p">))</span> <span class="o">==</span> <span class="n">PT_PTRACED</span><span class="p">)</span>
			<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGTRAP</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ptrace_init_task - initialize ptrace state for a new child</span>
<span class="cm"> * @child:		new child task</span>
<span class="cm"> * @ptrace:		true if child should be ptrace&#39;d by parent&#39;s tracer</span>
<span class="cm"> *</span>
<span class="cm"> * This is called immediately after adding @child to its parent&#39;s children</span>
<span class="cm"> * list.  @ptrace is false in the normal case, and true to ptrace @child.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with current&#39;s siglock and write_lock_irq(&amp;tasklist_lock) held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ptrace_init_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ptrace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace_entry</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">ptraced</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_HAVE_HW_BREAKPOINT</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace_bp_refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">child</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">child</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ptrace</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">;</span>
		<span class="n">__ptrace_link</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;</span> <span class="n">PT_SEIZED</span><span class="p">)</span>
			<span class="n">task_set_jobctl_pending</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">JOBCTL_TRAP_STOP</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">SIGSTOP</span><span class="p">);</span>

		<span class="n">set_tsk_thread_flag</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">TIF_SIGPENDING</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ptrace_release_task - final ptrace-related cleanup of a zombie being reaped</span>
<span class="cm"> * @task:	task in %EXIT_DEAD state</span>
<span class="cm"> *</span>
<span class="cm"> * Called with write_lock(&amp;tasklist_lock) held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ptrace_release_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">ptraced</span><span class="p">));</span>
	<span class="n">ptrace_unlink</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">ptrace_entry</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifndef force_successful_syscall_return</span>
<span class="cm">/*</span>
<span class="cm"> * System call handlers that, upon successful completion, need to return a</span>
<span class="cm"> * negative value should call force_successful_syscall_return() right before</span>
<span class="cm"> * returning.  On architectures where the syscall convention provides for a</span>
<span class="cm"> * separate error flag (e.g., alpha, ia64, ppc{,64}, sparc{,64}, possibly</span>
<span class="cm"> * others), this macro can be used to ensure that the error flag will not get</span>
<span class="cm"> * set.  On architectures which do not support a separate error flag, the macro</span>
<span class="cm"> * is a no-op and the spurious error condition needs to be filtered out by some</span>
<span class="cm"> * other means (e.g., in user-level, by passing an extra argument to the</span>
<span class="cm"> * syscall handler, or something along those lines).</span>
<span class="cm"> */</span>
<span class="cp">#define force_successful_syscall_return() do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef is_syscall_success</span>
<span class="cm">/*</span>
<span class="cm"> * On most systems we can tell if a syscall is a success based on if the retval</span>
<span class="cm"> * is an error value.  On some systems like ia64 and powerpc they have different</span>
<span class="cm"> * indicators of success/failure and must define their own.</span>
<span class="cm"> */</span>
<span class="cp">#define is_syscall_success(regs) (!IS_ERR_VALUE((unsigned long)(regs_return_value(regs))))</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * &lt;asm/ptrace.h&gt; should define the following things inside #ifdef __KERNEL__.</span>
<span class="cm"> *</span>
<span class="cm"> * These do-nothing inlines are used when the arch does not</span>
<span class="cm"> * implement single-step.  The kerneldoc comments are here</span>
<span class="cm"> * to document the interface for all arch definitions.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef arch_has_single_step</span>
<span class="cm">/**</span>
<span class="cm"> * arch_has_single_step - does this CPU support user-mode single-step?</span>
<span class="cm"> *</span>
<span class="cm"> * If this is defined, then there must be function declarations or</span>
<span class="cm"> * inlines for user_enable_single_step() and user_disable_single_step().</span>
<span class="cm"> * arch_has_single_step() should evaluate to nonzero iff the machine</span>
<span class="cm"> * supports instruction single-step for user mode.</span>
<span class="cm"> * It can be a constant or it can test a CPU feature bit.</span>
<span class="cm"> */</span>
<span class="cp">#define arch_has_single_step()		(0)</span>

<span class="cm">/**</span>
<span class="cm"> * user_enable_single_step - single-step in user-mode task</span>
<span class="cm"> * @task: either current or a task stopped in %TASK_TRACED</span>
<span class="cm"> *</span>
<span class="cm"> * This can only be called when arch_has_single_step() has returned nonzero.</span>
<span class="cm"> * Set @task so that when it returns to user mode, it will trap after the</span>
<span class="cm"> * next single instruction executes.  If arch_has_block_step() is defined,</span>
<span class="cm"> * this must clear the effects of user_enable_block_step() too.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">user_enable_single_step</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>			<span class="cm">/* This can never be called.  */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * user_disable_single_step - cancel user-mode single-step</span>
<span class="cm"> * @task: either current or a task stopped in %TASK_TRACED</span>
<span class="cm"> *</span>
<span class="cm"> * Clear @task of the effects of user_enable_single_step() and</span>
<span class="cm"> * user_enable_block_step().  This can be called whether or not either</span>
<span class="cm"> * of those was ever called on @task, and even if arch_has_single_step()</span>
<span class="cm"> * returned zero.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">user_disable_single_step</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">user_enable_single_step</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">user_disable_single_step</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* arch_has_single_step */</span><span class="cp"></span>

<span class="cp">#ifndef arch_has_block_step</span>
<span class="cm">/**</span>
<span class="cm"> * arch_has_block_step - does this CPU support user-mode block-step?</span>
<span class="cm"> *</span>
<span class="cm"> * If this is defined, then there must be a function declaration or inline</span>
<span class="cm"> * for user_enable_block_step(), and arch_has_single_step() must be defined</span>
<span class="cm"> * too.  arch_has_block_step() should evaluate to nonzero iff the machine</span>
<span class="cm"> * supports step-until-branch for user mode.  It can be a constant or it</span>
<span class="cm"> * can test a CPU feature bit.</span>
<span class="cm"> */</span>
<span class="cp">#define arch_has_block_step()		(0)</span>

<span class="cm">/**</span>
<span class="cm"> * user_enable_block_step - step until branch in user-mode task</span>
<span class="cm"> * @task: either current or a task stopped in %TASK_TRACED</span>
<span class="cm"> *</span>
<span class="cm"> * This can only be called when arch_has_block_step() has returned nonzero,</span>
<span class="cm"> * and will never be called when single-instruction stepping is being used.</span>
<span class="cm"> * Set @task so that when it returns to user mode, it will trap after the</span>
<span class="cm"> * next branch or trap taken.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">user_enable_block_step</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>			<span class="cm">/* This can never be called.  */</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">user_enable_block_step</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* arch_has_block_step */</span><span class="cp"></span>

<span class="cp">#ifdef ARCH_HAS_USER_SINGLE_STEP_INFO</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">user_single_step_siginfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">user_single_step_siginfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">));</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGTRAP</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef arch_ptrace_stop_needed</span>
<span class="cm">/**</span>
<span class="cm"> * arch_ptrace_stop_needed - Decide whether arch_ptrace_stop() should be called</span>
<span class="cm"> * @code:	current-&gt;exit_code value ptrace will stop with</span>
<span class="cm"> * @info:	siginfo_t pointer (or %NULL) for signal ptrace will stop with</span>
<span class="cm"> *</span>
<span class="cm"> * This is called with the siglock held, to decide whether or not it&#39;s</span>
<span class="cm"> * necessary to release the siglock and call arch_ptrace_stop() with the</span>
<span class="cm"> * same @code and @info arguments.  It can be defined to a constant if</span>
<span class="cm"> * arch_ptrace_stop() is never required, or always is.  On machines where</span>
<span class="cm"> * this makes sense, it should be defined to a quick test to optimize out</span>
<span class="cm"> * calling arch_ptrace_stop() when it would be superfluous.  For example,</span>
<span class="cm"> * if the thread has not been back to user mode since the last stop, the</span>
<span class="cm"> * thread state might indicate that nothing needs to be done.</span>
<span class="cm"> */</span>
<span class="cp">#define arch_ptrace_stop_needed(code, info)	(0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef arch_ptrace_stop</span>
<span class="cm">/**</span>
<span class="cm"> * arch_ptrace_stop - Do machine-specific work before stopping for ptrace</span>
<span class="cm"> * @code:	current-&gt;exit_code value ptrace will stop with</span>
<span class="cm"> * @info:	siginfo_t pointer (or %NULL) for signal ptrace will stop with</span>
<span class="cm"> *</span>
<span class="cm"> * This is called with no locks held when arch_ptrace_stop_needed() has</span>
<span class="cm"> * just returned nonzero.  It is allowed to block, e.g. for user memory</span>
<span class="cm"> * access.  The arch can have machine-specific work to be done before</span>
<span class="cm"> * ptrace stops.  On ia64, register backing store gets written back to user</span>
<span class="cm"> * memory here.  Since this can be costly (requires dropping the siglock),</span>
<span class="cm"> * we only do it when the arch requires it for this particular stop, as</span>
<span class="cm"> * indicated by arch_ptrace_stop_needed().</span>
<span class="cm"> */</span>
<span class="cp">#define arch_ptrace_stop(code, info)		do { } while (0)</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">task_current_syscall</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">callno</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">args</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxargs</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pc</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HAVE_HW_BREAKPOINT</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ptrace_get_breakpoints</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ptrace_put_breakpoints</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ptrace_put_breakpoints</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HAVE_HW_BREAKPOINT */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL */</span><span class="cp"></span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
