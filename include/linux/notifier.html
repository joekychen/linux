<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › notifier.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>notifier.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	Routines to manage notifier chains for passing status changes to any</span>
<span class="cm"> *	interested routines. We need this instead of hard coded call lists so</span>
<span class="cm"> *	that modules can poke their nose into the innards. The network devices</span>
<span class="cm"> *	needed them so here they are for the rest of you.</span>
<span class="cm"> *</span>
<span class="cm"> *				Alan Cox &lt;Alan.Cox@linux.org&gt;</span>
<span class="cm"> */</span>
 
<span class="cp">#ifndef _LINUX_NOTIFIER_H</span>
<span class="cp">#define _LINUX_NOTIFIER_H</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/srcu.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Notifier chains are of four types:</span>
<span class="cm"> *</span>
<span class="cm"> *	Atomic notifier chains: Chain callbacks run in interrupt/atomic</span>
<span class="cm"> *		context. Callouts are not allowed to block.</span>
<span class="cm"> *	Blocking notifier chains: Chain callbacks run in process context.</span>
<span class="cm"> *		Callouts are allowed to block.</span>
<span class="cm"> *	Raw notifier chains: There are no restrictions on callbacks,</span>
<span class="cm"> *		registration, or unregistration.  All locking and protection</span>
<span class="cm"> *		must be provided by the caller.</span>
<span class="cm"> *	SRCU notifier chains: A variant of blocking notifier chains, with</span>
<span class="cm"> *		the same restrictions.</span>
<span class="cm"> *</span>
<span class="cm"> * atomic_notifier_chain_register() may be called from an atomic context,</span>
<span class="cm"> * but blocking_notifier_chain_register() and srcu_notifier_chain_register()</span>
<span class="cm"> * must be called from a process context.  Ditto for the corresponding</span>
<span class="cm"> * _unregister() routines.</span>
<span class="cm"> *</span>
<span class="cm"> * atomic_notifier_chain_unregister(), blocking_notifier_chain_unregister(),</span>
<span class="cm"> * and srcu_notifier_chain_unregister() _must not_ be called from within</span>
<span class="cm"> * the call chain.</span>
<span class="cm"> *</span>
<span class="cm"> * SRCU notifier chains are an alternative form of blocking notifier chains.</span>
<span class="cm"> * They use SRCU (Sleepable Read-Copy Update) instead of rw-semaphores for</span>
<span class="cm"> * protection of the chain links.  This means there is _very_ low overhead</span>
<span class="cm"> * in srcu_notifier_call_chain(): no cache bounces and no memory barriers.</span>
<span class="cm"> * As compensation, srcu_notifier_chain_unregister() is rather expensive.</span>
<span class="cm"> * SRCU notifier chains should be used when the chain will be called very</span>
<span class="cm"> * often but notifier_blocks will seldom be removed.  Also, SRCU notifier</span>
<span class="cm"> * chains are slightly more difficult to use because they require special</span>
<span class="cm"> * runtime initialization.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">notifier_block</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">notifier_call</span><span class="p">)(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">priority</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">atomic_notifier_head</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">blocking_notifier_head</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">rwsem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">raw_notifier_head</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">srcu_notifier_head</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">srcu_struct</span> <span class="n">srcu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define ATOMIC_INIT_NOTIFIER_HEAD(name) do {	\</span>
<span class="cp">		spin_lock_init(&amp;(name)-&gt;lock);	\</span>
<span class="cp">		(name)-&gt;head = NULL;		\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define BLOCKING_INIT_NOTIFIER_HEAD(name) do {	\</span>
<span class="cp">		init_rwsem(&amp;(name)-&gt;rwsem);	\</span>
<span class="cp">		(name)-&gt;head = NULL;		\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define RAW_INIT_NOTIFIER_HEAD(name) do {	\</span>
<span class="cp">		(name)-&gt;head = NULL;		\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/* srcu_notifier_heads must be initialized and cleaned up dynamically */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">srcu_init_notifier_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">);</span>
<span class="cp">#define srcu_cleanup_notifier_head(name)	\</span>
<span class="cp">		cleanup_srcu_struct(&amp;(name)-&gt;srcu);</span>

<span class="cp">#define ATOMIC_NOTIFIER_INIT(name) {				\</span>
<span class="cp">		.lock = __SPIN_LOCK_UNLOCKED(name.lock),	\</span>
<span class="cp">		.head = NULL }</span>
<span class="cp">#define BLOCKING_NOTIFIER_INIT(name) {				\</span>
<span class="cp">		.rwsem = __RWSEM_INITIALIZER((name).rwsem),	\</span>
<span class="cp">		.head = NULL }</span>
<span class="cp">#define RAW_NOTIFIER_INIT(name)	{				\</span>
<span class="cp">		.head = NULL }</span>
<span class="cm">/* srcu_notifier_heads cannot be initialized statically */</span>

<span class="cp">#define ATOMIC_NOTIFIER_HEAD(name)				\</span>
<span class="cp">	struct atomic_notifier_head name =			\</span>
<span class="cp">		ATOMIC_NOTIFIER_INIT(name)</span>
<span class="cp">#define BLOCKING_NOTIFIER_HEAD(name)				\</span>
<span class="cp">	struct blocking_notifier_head name =			\</span>
<span class="cp">		BLOCKING_NOTIFIER_INIT(name)</span>
<span class="cp">#define RAW_NOTIFIER_HEAD(name)					\</span>
<span class="cp">	struct raw_notifier_head name =				\</span>
<span class="cp">		RAW_NOTIFIER_INIT(name)</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">atomic_notifier_chain_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">atomic_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blocking_notifier_chain_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">blocking_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">raw_notifier_chain_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">raw_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">srcu_notifier_chain_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">blocking_notifier_chain_cond_register</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">blocking_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">atomic_notifier_chain_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">atomic_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blocking_notifier_chain_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">blocking_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">raw_notifier_chain_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">raw_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">srcu_notifier_chain_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">atomic_notifier_call_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">atomic_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__atomic_notifier_call_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">atomic_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_to_call</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nr_calls</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blocking_notifier_call_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">blocking_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__blocking_notifier_call_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">blocking_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_to_call</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nr_calls</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">raw_notifier_call_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">raw_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__raw_notifier_call_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">raw_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_to_call</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nr_calls</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">srcu_notifier_call_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__srcu_notifier_call_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">srcu_notifier_head</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_to_call</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nr_calls</span><span class="p">);</span>

<span class="cp">#define NOTIFY_DONE		0x0000		</span><span class="cm">/* Don&#39;t care */</span><span class="cp"></span>
<span class="cp">#define NOTIFY_OK		0x0001		</span><span class="cm">/* Suits me */</span><span class="cp"></span>
<span class="cp">#define NOTIFY_STOP_MASK	0x8000		</span><span class="cm">/* Don&#39;t call further */</span><span class="cp"></span>
<span class="cp">#define NOTIFY_BAD		(NOTIFY_STOP_MASK|0x0002)</span>
						<span class="cm">/* Bad/Veto action */</span>
<span class="cm">/*</span>
<span class="cm"> * Clean way to return from the notifier and stop further calls.</span>
<span class="cm"> */</span>
<span class="cp">#define NOTIFY_STOP		(NOTIFY_OK|NOTIFY_STOP_MASK)</span>

<span class="cm">/* Encapsulate (negative) errno value (in particular, NOTIFY_BAD &lt;=&gt; EPERM). */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">notifier_from_errno</span><span class="p">(</span><span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_STOP_MASK</span> <span class="o">|</span> <span class="p">(</span><span class="n">NOTIFY_OK</span> <span class="o">-</span> <span class="n">err</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Restore (negative) errno value from notify return value. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">notifier_to_errno</span><span class="p">(</span><span class="kt">int</span> <span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ret</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NOTIFY_STOP_MASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">&gt;</span> <span class="n">NOTIFY_OK</span> <span class="o">?</span> <span class="n">NOTIFY_OK</span> <span class="o">-</span> <span class="n">ret</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Declared notifiers so far. I can imagine quite a few more chains</span>
<span class="cm"> *	over time (eg laptop power reset chains, reboot chain (to clean </span>
<span class="cm"> *	device units up), device [un]mount chain, module load/unload chain,</span>
<span class="cm"> *	low memory chain, screenblank chain (for plug in modular screenblankers) </span>
<span class="cm"> *	VC switch chains (for loadable kernel svgalib VC switch helpers) etc...</span>
<span class="cm"> */</span>
 
<span class="cm">/* CPU notfiers are defined in include/linux/cpu.h. */</span>

<span class="cm">/* netdevice notifiers are defined in include/linux/netdevice.h */</span>

<span class="cm">/* reboot notifiers are defined in include/linux/reboot.h. */</span>

<span class="cm">/* Hibernation and suspend events are defined in include/linux/suspend.h. */</span>

<span class="cm">/* Virtual Terminal events are defined in include/linux/vt.h. */</span>

<span class="cp">#define NETLINK_URELEASE	0x0001	</span><span class="cm">/* Unicast netlink socket released */</span><span class="cp"></span>

<span class="cm">/* Console keyboard events.</span>
<span class="cm"> * Note: KBD_KEYCODE is always sent before KBD_UNBOUND_KEYCODE, KBD_UNICODE and</span>
<span class="cm"> * KBD_KEYSYM. */</span>
<span class="cp">#define KBD_KEYCODE		0x0001 </span><span class="cm">/* Keyboard keycode, called before any other */</span><span class="cp"></span>
<span class="cp">#define KBD_UNBOUND_KEYCODE	0x0002 </span><span class="cm">/* Keyboard keycode which is not bound to any other */</span><span class="cp"></span>
<span class="cp">#define KBD_UNICODE		0x0003 </span><span class="cm">/* Keyboard unicode */</span><span class="cp"></span>
<span class="cp">#define KBD_KEYSYM		0x0004 </span><span class="cm">/* Keyboard keysym */</span><span class="cp"></span>
<span class="cp">#define KBD_POST_KEYSYM		0x0005 </span><span class="cm">/* Called after keyboard keysym interpretation */</span><span class="cp"></span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">blocking_notifier_head</span> <span class="n">reboot_notifier_list</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _LINUX_NOTIFIER_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
