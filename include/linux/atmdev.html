<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › atmdev.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>atmdev.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* atmdev.h - ATM device driver declarations and various related items */</span>
 
<span class="cm">/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */</span>
 

<span class="cp">#ifndef LINUX_ATMDEV_H</span>
<span class="cp">#define LINUX_ATMDEV_H</span>


<span class="cp">#include &lt;linux/atmapi.h&gt;</span>
<span class="cp">#include &lt;linux/atm.h&gt;</span>
<span class="cp">#include &lt;linux/atmioc.h&gt;</span>


<span class="cp">#define ESI_LEN		6</span>

<span class="cp">#define ATM_OC3_PCR	(155520000/270*260/8/53)</span>
			<span class="cm">/* OC3 link rate:  155520000 bps</span>
<span class="cm">			   SONET overhead: /270*260 (9 section, 1 path)</span>
<span class="cm">			   bits per cell:  /8/53</span>
<span class="cm">			   max cell rate:  353207.547 cells/sec */</span>
<span class="cp">#define ATM_25_PCR	((25600000/8-8000)/54)</span>
			<span class="cm">/* 25 Mbps ATM cell rate (59111) */</span>
<span class="cp">#define ATM_OC12_PCR	(622080000/1080*1040/8/53)</span>
			<span class="cm">/* OC12 link rate: 622080000 bps</span>
<span class="cm">			   SONET overhead: /1080*1040</span>
<span class="cm">			   bits per cell:  /8/53</span>
<span class="cm">			   max cell rate:  1412830.188 cells/sec */</span>
<span class="cp">#define ATM_DS3_PCR	(8000*12)</span>
			<span class="cm">/* DS3: 12 cells in a 125 usec time slot */</span>


<span class="cp">#define __AAL_STAT_ITEMS \</span>
<span class="cp">    __HANDLE_ITEM(tx);			</span><span class="cm">/* TX okay */</span><span class="cp"> \</span>
<span class="cp">    __HANDLE_ITEM(tx_err);		</span><span class="cm">/* TX errors */</span><span class="cp"> \</span>
<span class="cp">    __HANDLE_ITEM(rx);			</span><span class="cm">/* RX okay */</span><span class="cp"> \</span>
<span class="cp">    __HANDLE_ITEM(rx_err);		</span><span class="cm">/* RX errors */</span><span class="cp"> \</span>
<span class="cp">    __HANDLE_ITEM(rx_drop);		</span><span class="cm">/* RX out of memory */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">atm_aal_stats</span> <span class="p">{</span>
<span class="cp">#define __HANDLE_ITEM(i) int i</span>
	<span class="n">__AAL_STAT_ITEMS</span>
<span class="cp">#undef __HANDLE_ITEM</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">atm_dev_stats</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">atm_aal_stats</span> <span class="n">aal0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atm_aal_stats</span> <span class="n">aal34</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atm_aal_stats</span> <span class="n">aal5</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__ATM_API_ALIGN</span><span class="p">;</span>


<span class="cp">#define ATM_GETLINKRATE	_IOW(&#39;a&#39;,ATMIOC_ITF+1,struct atmif_sioc)</span>
					<span class="cm">/* get link rate */</span>
<span class="cp">#define ATM_GETNAMES	_IOW(&#39;a&#39;,ATMIOC_ITF+3,struct atm_iobuf)</span>
					<span class="cm">/* get interface names (numbers) */</span>
<span class="cp">#define ATM_GETTYPE	_IOW(&#39;a&#39;,ATMIOC_ITF+4,struct atmif_sioc)</span>
					<span class="cm">/* get interface type name */</span>
<span class="cp">#define ATM_GETESI	_IOW(&#39;a&#39;,ATMIOC_ITF+5,struct atmif_sioc)</span>
					<span class="cm">/* get interface ESI */</span>
<span class="cp">#define ATM_GETADDR	_IOW(&#39;a&#39;,ATMIOC_ITF+6,struct atmif_sioc)</span>
					<span class="cm">/* get itf&#39;s local ATM addr. list */</span>
<span class="cp">#define ATM_RSTADDR	_IOW(&#39;a&#39;,ATMIOC_ITF+7,struct atmif_sioc)</span>
					<span class="cm">/* reset itf&#39;s ATM address list */</span>
<span class="cp">#define ATM_ADDADDR	_IOW(&#39;a&#39;,ATMIOC_ITF+8,struct atmif_sioc)</span>
					<span class="cm">/* add a local ATM address */</span>
<span class="cp">#define ATM_DELADDR	_IOW(&#39;a&#39;,ATMIOC_ITF+9,struct atmif_sioc)</span>
					<span class="cm">/* remove a local ATM address */</span>
<span class="cp">#define ATM_GETCIRANGE	_IOW(&#39;a&#39;,ATMIOC_ITF+10,struct atmif_sioc)</span>
					<span class="cm">/* get connection identifier range */</span>
<span class="cp">#define ATM_SETCIRANGE	_IOW(&#39;a&#39;,ATMIOC_ITF+11,struct atmif_sioc)</span>
					<span class="cm">/* set connection identifier range */</span>
<span class="cp">#define ATM_SETESI	_IOW(&#39;a&#39;,ATMIOC_ITF+12,struct atmif_sioc)</span>
					<span class="cm">/* set interface ESI */</span>
<span class="cp">#define ATM_SETESIF	_IOW(&#39;a&#39;,ATMIOC_ITF+13,struct atmif_sioc)</span>
					<span class="cm">/* force interface ESI */</span>
<span class="cp">#define ATM_ADDLECSADDR	_IOW(&#39;a&#39;, ATMIOC_ITF+14, struct atmif_sioc)</span>
					<span class="cm">/* register a LECS address */</span>
<span class="cp">#define ATM_DELLECSADDR	_IOW(&#39;a&#39;, ATMIOC_ITF+15, struct atmif_sioc)</span>
					<span class="cm">/* unregister a LECS address */</span>
<span class="cp">#define ATM_GETLECSADDR	_IOW(&#39;a&#39;, ATMIOC_ITF+16, struct atmif_sioc)</span>
					<span class="cm">/* retrieve LECS address(es) */</span>

<span class="cp">#define ATM_GETSTAT	_IOW(&#39;a&#39;,ATMIOC_SARCOM+0,struct atmif_sioc)</span>
					<span class="cm">/* get AAL layer statistics */</span>
<span class="cp">#define ATM_GETSTATZ	_IOW(&#39;a&#39;,ATMIOC_SARCOM+1,struct atmif_sioc)</span>
					<span class="cm">/* get AAL layer statistics and zero */</span>
<span class="cp">#define ATM_GETLOOP	_IOW(&#39;a&#39;,ATMIOC_SARCOM+2,struct atmif_sioc)</span>
					<span class="cm">/* get loopback mode */</span>
<span class="cp">#define ATM_SETLOOP	_IOW(&#39;a&#39;,ATMIOC_SARCOM+3,struct atmif_sioc)</span>
					<span class="cm">/* set loopback mode */</span>
<span class="cp">#define ATM_QUERYLOOP	_IOW(&#39;a&#39;,ATMIOC_SARCOM+4,struct atmif_sioc)</span>
					<span class="cm">/* query supported loopback modes */</span>
<span class="cp">#define ATM_SETSC	_IOW(&#39;a&#39;,ATMIOC_SPECIAL+1,int)</span>
					<span class="cm">/* enable or disable single-copy */</span>
<span class="cp">#define ATM_SETBACKEND	_IOW(&#39;a&#39;,ATMIOC_SPECIAL+2,atm_backend_t)</span>
					<span class="cm">/* set backend handler */</span>
<span class="cp">#define ATM_NEWBACKENDIF _IOW(&#39;a&#39;,ATMIOC_SPECIAL+3,atm_backend_t)</span>
					<span class="cm">/* use backend to make new if */</span>
<span class="cp">#define ATM_ADDPARTY  	_IOW(&#39;a&#39;, ATMIOC_SPECIAL+4,struct atm_iobuf)</span>
 					<span class="cm">/* add party to p2mp call */</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="cm">/* It actually takes struct sockaddr_atmsvc, not struct atm_iobuf */</span>
<span class="cp">#define COMPAT_ATM_ADDPARTY  	_IOW(&#39;a&#39;, ATMIOC_SPECIAL+4,struct compat_atm_iobuf)</span>
<span class="cp">#endif</span>
<span class="cp">#define ATM_DROPPARTY 	_IOW(&#39;a&#39;, ATMIOC_SPECIAL+5,int)</span>
					<span class="cm">/* drop party from p2mp call */</span>

<span class="cm">/*</span>
<span class="cm"> * These are backend handkers that can be set via the ATM_SETBACKEND call</span>
<span class="cm"> * above.  In the future we may support dynamic loading of these - for now,</span>
<span class="cm"> * they&#39;re just being used to share the ATMIOC_BACKEND ioctls</span>
<span class="cm"> */</span>
<span class="cp">#define ATM_BACKEND_RAW		0	</span>
<span class="cp">#define ATM_BACKEND_PPP		1	</span><span class="cm">/* PPPoATM - RFC2364 */</span><span class="cp"></span>
<span class="cp">#define ATM_BACKEND_BR2684	2	</span><span class="cm">/* Bridged RFC1483/2684 */</span><span class="cp"></span>

<span class="cm">/* for ATM_GETTYPE */</span>
<span class="cp">#define ATM_ITFTYP_LEN	8	</span><span class="cm">/* maximum length of interface type name */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Loopback modes for ATM_{PHY,SAR}_{GET,SET}LOOP</span>
<span class="cm"> */</span>

<span class="cm">/* Point of loopback				CPU--&gt;SAR--&gt;PHY--&gt;line--&gt; ... */</span>
<span class="cp">#define __ATM_LM_NONE	0	</span><span class="cm">/* no loop back     ^     ^     ^      ^      */</span><span class="cp"></span>
<span class="cp">#define __ATM_LM_AAL	1	</span><span class="cm">/* loop back PDUs --&#39;     |     |      |      */</span><span class="cp"></span>
<span class="cp">#define __ATM_LM_ATM	2	</span><span class="cm">/* loop back ATM cells ---&#39;     |      |      */</span><span class="cp"></span>
<span class="cm">/* RESERVED		4	loop back on PHY side  ---&#39;		      */</span>
<span class="cp">#define __ATM_LM_PHY	8	</span><span class="cm">/* loop back bits (digital) ----&#39;      |      */</span><span class="cp"></span>
<span class="cp">#define __ATM_LM_ANALOG 16	</span><span class="cm">/* loop back the analog signal --------&#39;      */</span><span class="cp"></span>

<span class="cm">/* Direction of loopback */</span>
<span class="cp">#define __ATM_LM_MKLOC(n)	((n))	    </span><span class="cm">/* Local (i.e. loop TX to RX) */</span><span class="cp"></span>
<span class="cp">#define __ATM_LM_MKRMT(n)	((n) &lt;&lt; 8)  </span><span class="cm">/* Remote (i.e. loop RX to TX) */</span><span class="cp"></span>

<span class="cp">#define __ATM_LM_XTLOC(n)	((n) &amp; 0xff)</span>
<span class="cp">#define __ATM_LM_XTRMT(n)	(((n) &gt;&gt; 8) &amp; 0xff)</span>

<span class="cp">#define ATM_LM_NONE	0	</span><span class="cm">/* no loopback */</span><span class="cp"></span>

<span class="cp">#define ATM_LM_LOC_AAL	__ATM_LM_MKLOC(__ATM_LM_AAL)</span>
<span class="cp">#define ATM_LM_LOC_ATM	__ATM_LM_MKLOC(__ATM_LM_ATM)</span>
<span class="cp">#define ATM_LM_LOC_PHY	__ATM_LM_MKLOC(__ATM_LM_PHY)</span>
<span class="cp">#define ATM_LM_LOC_ANALOG __ATM_LM_MKLOC(__ATM_LM_ANALOG)</span>

<span class="cp">#define ATM_LM_RMT_AAL	__ATM_LM_MKRMT(__ATM_LM_AAL)</span>
<span class="cp">#define ATM_LM_RMT_ATM	__ATM_LM_MKRMT(__ATM_LM_ATM)</span>
<span class="cp">#define ATM_LM_RMT_PHY	__ATM_LM_MKRMT(__ATM_LM_PHY)</span>
<span class="cp">#define ATM_LM_RMT_ANALOG __ATM_LM_MKRMT(__ATM_LM_ANALOG)</span>

<span class="cm">/*</span>
<span class="cm"> * Note: ATM_LM_LOC_* and ATM_LM_RMT_* can be combined, provided that</span>
<span class="cm"> * __ATM_LM_XTLOC(x) &lt;= __ATM_LM_XTRMT(x)</span>
<span class="cm"> */</span>


<span class="k">struct</span> <span class="n">atm_iobuf</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* for ATM_GETCIRANGE / ATM_SETCIRANGE */</span>

<span class="cp">#define ATM_CI_MAX      -1              </span><span class="cm">/* use maximum range of VPI/VCI */</span><span class="cp"></span>
 
<span class="k">struct</span> <span class="n">atm_cirange</span> <span class="p">{</span>
	<span class="kt">signed</span> <span class="kt">char</span>	<span class="n">vpi_bits</span><span class="p">;</span>	<span class="cm">/* 1..8, ATM_CI_MAX (-1) for maximum */</span>
	<span class="kt">signed</span> <span class="kt">char</span>	<span class="n">vci_bits</span><span class="p">;</span>	<span class="cm">/* 1..16, ATM_CI_MAX (-1) for maximum */</span>
<span class="p">};</span>

<span class="cm">/* for ATM_SETSC; actually taken from the ATM_VF number space */</span>

<span class="cp">#define ATM_SC_RX	1024		</span><span class="cm">/* enable RX single-copy */</span><span class="cp"></span>
<span class="cp">#define ATM_SC_TX	2048		</span><span class="cm">/* enable TX single-copy */</span><span class="cp"></span>

<span class="cp">#define ATM_BACKLOG_DEFAULT 32 </span><span class="cm">/* if we get more, we&#39;re likely to time out</span>
<span class="cm">				  anyway */</span><span class="cp"></span>

<span class="cm">/* MF: change_qos (Modify) flags */</span>

<span class="cp">#define ATM_MF_IMMED	 1	</span><span class="cm">/* Block until change is effective */</span><span class="cp"></span>
<span class="cp">#define ATM_MF_INC_RSV	 2	</span><span class="cm">/* Change reservation on increase */</span><span class="cp"></span>
<span class="cp">#define ATM_MF_INC_SHP	 4	</span><span class="cm">/* Change shaping on increase */</span><span class="cp"></span>
<span class="cp">#define ATM_MF_DEC_RSV	 8	</span><span class="cm">/* Change reservation on decrease */</span><span class="cp"></span>
<span class="cp">#define ATM_MF_DEC_SHP	16	</span><span class="cm">/* Change shaping on decrease */</span><span class="cp"></span>
<span class="cp">#define ATM_MF_BWD	32	</span><span class="cm">/* Set the backward direction parameters */</span><span class="cp"></span>

<span class="cp">#define ATM_MF_SET	(ATM_MF_INC_RSV | ATM_MF_INC_SHP | ATM_MF_DEC_RSV | \</span>
<span class="cp">			  ATM_MF_DEC_SHP | ATM_MF_BWD)</span>

<span class="cm">/*</span>
<span class="cm"> * ATM_VS_* are used to express VC state in a human-friendly way.</span>
<span class="cm"> */</span>

<span class="cp">#define ATM_VS_IDLE	0	</span><span class="cm">/* VC is not used */</span><span class="cp"></span>
<span class="cp">#define ATM_VS_CONNECTED 1	</span><span class="cm">/* VC is connected */</span><span class="cp"></span>
<span class="cp">#define ATM_VS_CLOSING	2	</span><span class="cm">/* VC is closing */</span><span class="cp"></span>
<span class="cp">#define ATM_VS_LISTEN	3	</span><span class="cm">/* VC is listening for incoming setups */</span><span class="cp"></span>
<span class="cp">#define ATM_VS_INUSE	4	</span><span class="cm">/* VC is in use (registered with atmsigd) */</span><span class="cp"></span>
<span class="cp">#define ATM_VS_BOUND	5	</span><span class="cm">/* VC is bound */</span><span class="cp"></span>

<span class="cp">#define ATM_VS2TXT_MAP \</span>
<span class="cp">    &quot;IDLE&quot;, &quot;CONNECTED&quot;, &quot;CLOSING&quot;, &quot;LISTEN&quot;, &quot;INUSE&quot;, &quot;BOUND&quot;</span>

<span class="cp">#define ATM_VF2TXT_MAP \</span>
<span class="cp">    &quot;ADDR&quot;,	&quot;READY&quot;,	&quot;PARTIAL&quot;,	&quot;REGIS&quot;, \</span>
<span class="cp">    &quot;RELEASED&quot;, &quot;HASQOS&quot;,	&quot;LISTEN&quot;,	&quot;META&quot;, \</span>
<span class="cp">    &quot;256&quot;,	&quot;512&quot;,		&quot;1024&quot;,		&quot;2048&quot;, \</span>
<span class="cp">    &quot;SESSION&quot;,	&quot;HASSAP&quot;,	&quot;BOUND&quot;,	&quot;CLOSE&quot;</span>


<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/wait.h&gt; </span><span class="cm">/* wait_queue_head_t */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/time.h&gt; </span><span class="cm">/* struct timeval */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt; </span><span class="cm">/* struct sk_buff */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/uio.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">atm_proc_root</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="k">struct</span> <span class="n">compat_atm_iobuf</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">compat_uptr_t</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">k_atm_aal_stats</span> <span class="p">{</span>
<span class="cp">#define __HANDLE_ITEM(i) atomic_t i</span>
	<span class="n">__AAL_STAT_ITEMS</span>
<span class="cp">#undef __HANDLE_ITEM</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">k_atm_dev_stats</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">k_atm_aal_stats</span> <span class="n">aal0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">k_atm_aal_stats</span> <span class="n">aal34</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">k_atm_aal_stats</span> <span class="n">aal5</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">ATM_VF_ADDR</span><span class="p">,</span>		<span class="cm">/* Address is in use. Set by anybody, cleared</span>
<span class="cm">				   by device driver. */</span>
	<span class="n">ATM_VF_READY</span><span class="p">,</span>		<span class="cm">/* VC is ready to transfer data. Set by device</span>
<span class="cm">				   driver, cleared by anybody. */</span>
	<span class="n">ATM_VF_PARTIAL</span><span class="p">,</span>		<span class="cm">/* resources are bound to PVC (partial PVC</span>
<span class="cm">				   setup), controlled by socket layer */</span>
	<span class="n">ATM_VF_REGIS</span><span class="p">,</span>		<span class="cm">/* registered with demon, controlled by SVC</span>
<span class="cm">				   socket layer */</span>
	<span class="n">ATM_VF_BOUND</span><span class="p">,</span>		<span class="cm">/* local SAP is set, controlled by SVC socket</span>
<span class="cm">				   layer */</span>
	<span class="n">ATM_VF_RELEASED</span><span class="p">,</span>	<span class="cm">/* demon has indicated/requested release,</span>
<span class="cm">				   controlled by SVC socket layer */</span>
	<span class="n">ATM_VF_HASQOS</span><span class="p">,</span>		<span class="cm">/* QOS parameters have been set */</span>
	<span class="n">ATM_VF_LISTEN</span><span class="p">,</span>		<span class="cm">/* socket is used for listening */</span>
	<span class="n">ATM_VF_META</span><span class="p">,</span>		<span class="cm">/* SVC socket isn&#39;t used for normal data</span>
<span class="cm">				   traffic and doesn&#39;t depend on signaling</span>
<span class="cm">				   to be available */</span>
	<span class="n">ATM_VF_SESSION</span><span class="p">,</span>		<span class="cm">/* VCC is p2mp session control descriptor */</span>
	<span class="n">ATM_VF_HASSAP</span><span class="p">,</span>		<span class="cm">/* SAP has been set */</span>
	<span class="n">ATM_VF_CLOSE</span><span class="p">,</span>		<span class="cm">/* asynchronous close - treat like VF_RELEASED*/</span>
	<span class="n">ATM_VF_WAITING</span><span class="p">,</span>		<span class="cm">/* waiting for reply from sigd */</span>
	<span class="n">ATM_VF_IS_CLIP</span><span class="p">,</span>		<span class="cm">/* in use by CLIP protocol */</span>
<span class="p">};</span>


<span class="cp">#define ATM_VF2VS(flags) \</span>
<span class="cp">    (test_bit(ATM_VF_READY,&amp;(flags)) ? ATM_VS_CONNECTED : \</span>
<span class="cp">     test_bit(ATM_VF_RELEASED,&amp;(flags)) ? ATM_VS_CLOSING : \</span>
<span class="cp">     test_bit(ATM_VF_LISTEN,&amp;(flags)) ? ATM_VS_LISTEN : \</span>
<span class="cp">     test_bit(ATM_VF_REGIS,&amp;(flags)) ? ATM_VS_INUSE : \</span>
<span class="cp">     test_bit(ATM_VF_BOUND,&amp;(flags)) ? ATM_VS_BOUND : ATM_VS_IDLE)</span>


<span class="k">enum</span> <span class="p">{</span>
	<span class="n">ATM_DF_REMOVED</span><span class="p">,</span>		<span class="cm">/* device was removed from atm_devs list */</span>
<span class="p">};</span>


<span class="cp">#define ATM_PHY_SIG_LOST    0	</span><span class="cm">/* no carrier/light */</span><span class="cp"></span>
<span class="cp">#define ATM_PHY_SIG_UNKNOWN 1	</span><span class="cm">/* carrier/light status is unknown */</span><span class="cp"></span>
<span class="cp">#define ATM_PHY_SIG_FOUND   2	</span><span class="cm">/* carrier/light okay */</span><span class="cp"></span>

<span class="cp">#define ATM_ATMOPT_CLP	1	</span><span class="cm">/* set CLP bit */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">atm_vcc</span> <span class="p">{</span>
	<span class="cm">/* struct sock has to be the first member of atm_vcc */</span>
	<span class="k">struct</span> <span class="n">sock</span>	<span class="n">sk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* VCC flags (ATM_VF_*) */</span>
	<span class="kt">short</span>		<span class="n">vpi</span><span class="p">;</span>		<span class="cm">/* VPI and VCI (types must be equal */</span>
					<span class="cm">/* with sockaddr) */</span>
	<span class="kt">int</span> 		<span class="n">vci</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">aal_options</span><span class="p">;</span>	<span class="cm">/* AAL layer options */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">atm_options</span><span class="p">;</span>	<span class="cm">/* ATM layer options */</span>
	<span class="k">struct</span> <span class="n">atm_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>		<span class="cm">/* device back pointer */</span>
	<span class="k">struct</span> <span class="n">atm_qos</span>	<span class="n">qos</span><span class="p">;</span>		<span class="cm">/* QOS */</span>
	<span class="k">struct</span> <span class="n">atm_sap</span>	<span class="n">sap</span><span class="p">;</span>		<span class="cm">/* SAP */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">push</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span> <span class="cm">/* optional */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">push_oam</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">cell</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">send</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">dev_data</span><span class="p">;</span>	<span class="cm">/* per-device data */</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">proto_data</span><span class="p">;</span>	<span class="cm">/* per-protocol data */</span>
	<span class="k">struct</span> <span class="n">k_atm_aal_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>	<span class="cm">/* pointer to AAL stats group */</span>
	<span class="cm">/* SVC part --- may move later ------------------------------------- */</span>
	<span class="kt">short</span>		<span class="n">itf</span><span class="p">;</span>		<span class="cm">/* interface number */</span>
	<span class="k">struct</span> <span class="n">sockaddr_atmsvc</span> <span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_atmsvc</span> <span class="n">remote</span><span class="p">;</span>
	<span class="cm">/* Multipoint part ------------------------------------------------- */</span>
	<span class="k">struct</span> <span class="n">atm_vcc</span>	<span class="o">*</span><span class="n">session</span><span class="p">;</span>	<span class="cm">/* session VCC descriptor */</span>
	<span class="cm">/* Other stuff ----------------------------------------------------- */</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">user_back</span><span class="p">;</span>	<span class="cm">/* user backlink - not touched by */</span>
					<span class="cm">/* native ATM stack. Currently used */</span>
					<span class="cm">/* by CLIP and sch_atm. */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="nf">atm_sk</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="p">)</span><span class="n">sk</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="nf">ATM_SD</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atm_sk</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">sk_atm</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">)</span><span class="n">vcc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">atm_dev_addr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_atmsvc</span> <span class="n">addr</span><span class="p">;</span>	<span class="cm">/* ATM address */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">entry</span><span class="p">;</span>		<span class="cm">/* next address */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">atm_addr_type_t</span> <span class="p">{</span> <span class="n">ATM_ADDR_LOCAL</span><span class="p">,</span> <span class="n">ATM_ADDR_LECS</span> <span class="p">};</span>

<span class="k">struct</span> <span class="n">atm_dev</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">atmdev_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>	<span class="cm">/* device operations; NULL if unused */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">atmphy_ops</span> <span class="o">*</span><span class="n">phy</span><span class="p">;</span>	<span class="cm">/* PHY operations, may be undefined */</span>
					<span class="cm">/* (NULL) */</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">type</span><span class="p">;</span>		<span class="cm">/* device type name */</span>
	<span class="kt">int</span>		<span class="n">number</span><span class="p">;</span>		<span class="cm">/* device index */</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">dev_data</span><span class="p">;</span>	<span class="cm">/* per-device data */</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">phy_data</span><span class="p">;</span>	<span class="cm">/* private PHY date */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* device flags (ATM_DF_*) */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">local</span><span class="p">;</span>		<span class="cm">/* local ATM addresses */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">lecs</span><span class="p">;</span>		<span class="cm">/* LECS ATM addresses learned via ILMI */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">esi</span><span class="p">[</span><span class="n">ESI_LEN</span><span class="p">];</span>	<span class="cm">/* ESI (&quot;MAC&quot; addr) */</span>
	<span class="k">struct</span> <span class="n">atm_cirange</span> <span class="n">ci_range</span><span class="p">;</span>	<span class="cm">/* VPI/VCI range */</span>
	<span class="k">struct</span> <span class="n">k_atm_dev_stats</span> <span class="n">stats</span><span class="p">;</span>	<span class="cm">/* statistics */</span>
	<span class="kt">char</span>		<span class="n">signal</span><span class="p">;</span>		<span class="cm">/* signal status (ATM_PHY_SIG_*) */</span>
	<span class="kt">int</span>		<span class="n">link_rate</span><span class="p">;</span>	<span class="cm">/* link rate (default: OC3) */</span>
	<span class="n">atomic_t</span>	<span class="n">refcnt</span><span class="p">;</span>		<span class="cm">/* reference count */</span>
	<span class="n">spinlock_t</span>	<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* protect internal members */</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc_entry</span><span class="p">;</span> <span class="cm">/* proc entry */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">proc_name</span><span class="p">;</span>		<span class="cm">/* proc entry name */</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">class_dev</span><span class="p">;</span>	<span class="cm">/* sysfs device */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dev_list</span><span class="p">;</span>	<span class="cm">/* linkage */</span>
<span class="p">};</span>

 
<span class="cm">/* OF: send_Oam Flags */</span>

<span class="cp">#define ATM_OF_IMMED  1		</span><span class="cm">/* Attempt immediate delivery */</span><span class="cp"></span>
<span class="cp">#define ATM_OF_INRATE 2		</span><span class="cm">/* Attempt in-rate delivery */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * ioctl, getsockopt, and setsockopt are optional and can be set to NULL.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">atmdev_ops</span> <span class="p">{</span> <span class="cm">/* only send is required */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dev_close</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compat_ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">getsockopt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span><span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
	    <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span><span class="kt">int</span> <span class="n">optlen</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">setsockopt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span><span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
	    <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">send</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">send_oam</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span><span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">phy_put</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value</span><span class="p">,</span>
	    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="p">(</span><span class="o">*</span><span class="n">phy_get</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">change_qos</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span><span class="k">struct</span> <span class="n">atm_qos</span> <span class="o">*</span><span class="n">qos</span><span class="p">,</span><span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">proc_read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">atmphy_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">interrupt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">stop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">atm_skb_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">atm_vcc</span>	<span class="o">*</span><span class="n">vcc</span><span class="p">;</span>		<span class="cm">/* ATM VCC */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">atm_options</span><span class="p">;</span>	<span class="cm">/* ATM layer options */</span>
<span class="p">};</span>

<span class="cp">#define VCC_HTABLE_SIZE 32</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">vcc_hash</span><span class="p">[</span><span class="n">VCC_HTABLE_SIZE</span><span class="p">];</span>
<span class="k">extern</span> <span class="n">rwlock_t</span> <span class="n">vcc_sklist_lock</span><span class="p">;</span>

<span class="cp">#define ATM_SKB(skb) (((struct atm_skb_data *) (skb)-&gt;cb))</span>

<span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">atm_dev_register</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">atmdev_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">number</span><span class="p">,</span> <span class="cm">/* -1 == pick first available */</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">atm_dev_lookup</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">atm_dev_deregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/* atm_dev_signal_change</span>
<span class="cm"> *</span>
<span class="cm"> * Propagate lower layer signal change in atm_dev-&gt;signal to netdevice.</span>
<span class="cm"> * The event will be sent via a notifier call chain.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">atm_dev_signal_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">char</span> <span class="n">signal</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vcc_insert_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">atm_dev_release_vccs</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atm_force_charge</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span><span class="kt">int</span> <span class="n">truesize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_add</span><span class="p">(</span><span class="n">truesize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk_atm</span><span class="p">(</span><span class="n">vcc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atm_return</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span><span class="kt">int</span> <span class="n">truesize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_sub</span><span class="p">(</span><span class="n">truesize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk_atm</span><span class="p">(</span><span class="n">vcc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">atm_may_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk_atm</span><span class="p">(</span><span class="n">vcc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">))</span> <span class="o">&lt;</span>
	       <span class="n">sk_atm</span><span class="p">(</span><span class="n">vcc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atm_dev_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atm_dev_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ATM_DF_REMOVED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">dev_close</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">dev_close</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class_dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">atm_charge</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span><span class="kt">int</span> <span class="n">truesize</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">atm_alloc_charge</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span><span class="kt">int</span> <span class="n">pdu_size</span><span class="p">,</span>
    <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">atm_pcr_goal</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">atm_trafprm</span> <span class="o">*</span><span class="n">tp</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vcc_release_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reply</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">atm_ioctl</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="cm">/* A module reference is kept if appropriate over this call.</span>
<span class="cm">	 * Return -ENOIOCTLCMD if you don&#39;t handle it. */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * register_atm_ioctl - register handler for ioctl operations</span>
<span class="cm"> *</span>
<span class="cm"> * Special (non-device) handlers of ioctl&#39;s should</span>
<span class="cm"> * register here. If you&#39;re a normal device, you should</span>
<span class="cm"> * set .ioctl in your atmdev_ops instead.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">register_atm_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_ioctl</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * deregister_atm_ioctl - remove the ioctl handler</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">deregister_atm_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_ioctl</span> <span class="o">*</span><span class="p">);</span>


<span class="cm">/* register_atmdevice_notifier - register atm_dev notify events</span>
<span class="cm"> *</span>
<span class="cm"> * Clients like br2684 will register notify events</span>
<span class="cm"> * Currently we notify of signal found/lost</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">register_atmdevice_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">unregister_atmdevice_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
