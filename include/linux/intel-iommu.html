<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › intel-iommu.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>intel-iommu.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2006, Intel Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
<span class="cm"> * Place - Suite 330, Boston, MA 02111-1307 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Intel Corporation</span>
<span class="cm"> * Author: Ashok Raj &lt;ashok.raj@intel.com&gt;</span>
<span class="cm"> * Author: Anil S Keshavamurthy &lt;anil.s.keshavamurthy@intel.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _INTEL_IOMMU_H_</span>
<span class="cp">#define _INTEL_IOMMU_H_</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/iova.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/dma_remapping.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/iommu.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Intel IOMMU register specification per version 1.0 public spec.</span>
<span class="cm"> */</span>

<span class="cp">#define	DMAR_VER_REG	0x0	</span><span class="cm">/* Arch version supported by this IOMMU */</span><span class="cp"></span>
<span class="cp">#define	DMAR_CAP_REG	0x8	</span><span class="cm">/* Hardware supported capabilities */</span><span class="cp"></span>
<span class="cp">#define	DMAR_ECAP_REG	0x10	</span><span class="cm">/* Extended capabilities supported */</span><span class="cp"></span>
<span class="cp">#define	DMAR_GCMD_REG	0x18	</span><span class="cm">/* Global command register */</span><span class="cp"></span>
<span class="cp">#define	DMAR_GSTS_REG	0x1c	</span><span class="cm">/* Global status register */</span><span class="cp"></span>
<span class="cp">#define	DMAR_RTADDR_REG	0x20	</span><span class="cm">/* Root entry table */</span><span class="cp"></span>
<span class="cp">#define	DMAR_CCMD_REG	0x28	</span><span class="cm">/* Context command reg */</span><span class="cp"></span>
<span class="cp">#define	DMAR_FSTS_REG	0x34	</span><span class="cm">/* Fault Status register */</span><span class="cp"></span>
<span class="cp">#define	DMAR_FECTL_REG	0x38	</span><span class="cm">/* Fault control register */</span><span class="cp"></span>
<span class="cp">#define	DMAR_FEDATA_REG	0x3c	</span><span class="cm">/* Fault event interrupt data register */</span><span class="cp"></span>
<span class="cp">#define	DMAR_FEADDR_REG	0x40	</span><span class="cm">/* Fault event interrupt addr register */</span><span class="cp"></span>
<span class="cp">#define	DMAR_FEUADDR_REG 0x44	</span><span class="cm">/* Upper address register */</span><span class="cp"></span>
<span class="cp">#define	DMAR_AFLOG_REG	0x58	</span><span class="cm">/* Advanced Fault control */</span><span class="cp"></span>
<span class="cp">#define	DMAR_PMEN_REG	0x64	</span><span class="cm">/* Enable Protected Memory Region */</span><span class="cp"></span>
<span class="cp">#define	DMAR_PLMBASE_REG 0x68	</span><span class="cm">/* PMRR Low addr */</span><span class="cp"></span>
<span class="cp">#define	DMAR_PLMLIMIT_REG 0x6c	</span><span class="cm">/* PMRR low limit */</span><span class="cp"></span>
<span class="cp">#define	DMAR_PHMBASE_REG 0x70	</span><span class="cm">/* pmrr high base addr */</span><span class="cp"></span>
<span class="cp">#define	DMAR_PHMLIMIT_REG 0x78	</span><span class="cm">/* pmrr high limit */</span><span class="cp"></span>
<span class="cp">#define DMAR_IQH_REG	0x80	</span><span class="cm">/* Invalidation queue head register */</span><span class="cp"></span>
<span class="cp">#define DMAR_IQT_REG	0x88	</span><span class="cm">/* Invalidation queue tail register */</span><span class="cp"></span>
<span class="cp">#define DMAR_IQ_SHIFT	4	</span><span class="cm">/* Invalidation queue head/tail shift */</span><span class="cp"></span>
<span class="cp">#define DMAR_IQA_REG	0x90	</span><span class="cm">/* Invalidation queue addr register */</span><span class="cp"></span>
<span class="cp">#define DMAR_ICS_REG	0x98	</span><span class="cm">/* Invalidation complete status register */</span><span class="cp"></span>
<span class="cp">#define DMAR_IRTA_REG	0xb8    </span><span class="cm">/* Interrupt remapping table addr register */</span><span class="cp"></span>

<span class="cp">#define OFFSET_STRIDE		(9)</span>
<span class="cm">/*</span>
<span class="cm">#define dmar_readl(dmar, reg) readl(dmar + reg)</span>
<span class="cm">#define dmar_readq(dmar, reg) ({ \</span>
<span class="cm">		u32 lo, hi; \</span>
<span class="cm">		lo = readl(dmar + reg); \</span>
<span class="cm">		hi = readl(dmar + reg + 4); \</span>
<span class="cm">		(((u64) hi) &lt;&lt; 32) + lo; })</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">dmar_readq</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">;</span>
	<span class="n">lo</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">hi</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(((</span><span class="n">u64</span><span class="p">)</span> <span class="n">hi</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span> <span class="n">lo</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dmar_writeq</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">),</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define DMAR_VER_MAJOR(v)		(((v) &amp; 0xf0) &gt;&gt; 4)</span>
<span class="cp">#define DMAR_VER_MINOR(v)		((v) &amp; 0x0f)</span>

<span class="cm">/*</span>
<span class="cm"> * Decoding Capability Register</span>
<span class="cm"> */</span>
<span class="cp">#define cap_read_drain(c)	(((c) &gt;&gt; 55) &amp; 1)</span>
<span class="cp">#define cap_write_drain(c)	(((c) &gt;&gt; 54) &amp; 1)</span>
<span class="cp">#define cap_max_amask_val(c)	(((c) &gt;&gt; 48) &amp; 0x3f)</span>
<span class="cp">#define cap_num_fault_regs(c)	((((c) &gt;&gt; 40) &amp; 0xff) + 1)</span>
<span class="cp">#define cap_pgsel_inv(c)	(((c) &gt;&gt; 39) &amp; 1)</span>

<span class="cp">#define cap_super_page_val(c)	(((c) &gt;&gt; 34) &amp; 0xf)</span>
<span class="cp">#define cap_super_offset(c)	(((find_first_bit(&amp;cap_super_page_val(c), 4)) \</span>
<span class="cp">					* OFFSET_STRIDE) + 21)</span>

<span class="cp">#define cap_fault_reg_offset(c)	((((c) &gt;&gt; 24) &amp; 0x3ff) * 16)</span>
<span class="cp">#define cap_max_fault_reg_offset(c) \</span>
<span class="cp">	(cap_fault_reg_offset(c) + cap_num_fault_regs(c) * 16)</span>

<span class="cp">#define cap_zlr(c)		(((c) &gt;&gt; 22) &amp; 1)</span>
<span class="cp">#define cap_isoch(c)		(((c) &gt;&gt; 23) &amp; 1)</span>
<span class="cp">#define cap_mgaw(c)		((((c) &gt;&gt; 16) &amp; 0x3f) + 1)</span>
<span class="cp">#define cap_sagaw(c)		(((c) &gt;&gt; 8) &amp; 0x1f)</span>
<span class="cp">#define cap_caching_mode(c)	(((c) &gt;&gt; 7) &amp; 1)</span>
<span class="cp">#define cap_phmr(c)		(((c) &gt;&gt; 6) &amp; 1)</span>
<span class="cp">#define cap_plmr(c)		(((c) &gt;&gt; 5) &amp; 1)</span>
<span class="cp">#define cap_rwbf(c)		(((c) &gt;&gt; 4) &amp; 1)</span>
<span class="cp">#define cap_afl(c)		(((c) &gt;&gt; 3) &amp; 1)</span>
<span class="cp">#define cap_ndoms(c)		(((unsigned long)1) &lt;&lt; (4 + 2 * ((c) &amp; 0x7)))</span>
<span class="cm">/*</span>
<span class="cm"> * Extended Capability Register</span>
<span class="cm"> */</span>

<span class="cp">#define ecap_niotlb_iunits(e)	((((e) &gt;&gt; 24) &amp; 0xff) + 1)</span>
<span class="cp">#define ecap_iotlb_offset(e) 	((((e) &gt;&gt; 8) &amp; 0x3ff) * 16)</span>
<span class="cp">#define ecap_max_iotlb_offset(e) \</span>
<span class="cp">	(ecap_iotlb_offset(e) + ecap_niotlb_iunits(e) * 16)</span>
<span class="cp">#define ecap_coherent(e)	((e) &amp; 0x1)</span>
<span class="cp">#define ecap_qis(e)		((e) &amp; 0x2)</span>
<span class="cp">#define ecap_pass_through(e)	((e &gt;&gt; 6) &amp; 0x1)</span>
<span class="cp">#define ecap_eim_support(e)	((e &gt;&gt; 4) &amp; 0x1)</span>
<span class="cp">#define ecap_ir_support(e)	((e &gt;&gt; 3) &amp; 0x1)</span>
<span class="cp">#define ecap_dev_iotlb_support(e)	(((e) &gt;&gt; 2) &amp; 0x1)</span>
<span class="cp">#define ecap_max_handle_mask(e) ((e &gt;&gt; 20) &amp; 0xf)</span>
<span class="cp">#define ecap_sc_support(e)	((e &gt;&gt; 7) &amp; 0x1) </span><span class="cm">/* Snooping Control */</span><span class="cp"></span>

<span class="cm">/* IOTLB_REG */</span>
<span class="cp">#define DMA_TLB_FLUSH_GRANU_OFFSET  60</span>
<span class="cp">#define DMA_TLB_GLOBAL_FLUSH (((u64)1) &lt;&lt; 60)</span>
<span class="cp">#define DMA_TLB_DSI_FLUSH (((u64)2) &lt;&lt; 60)</span>
<span class="cp">#define DMA_TLB_PSI_FLUSH (((u64)3) &lt;&lt; 60)</span>
<span class="cp">#define DMA_TLB_IIRG(type) ((type &gt;&gt; 60) &amp; 7)</span>
<span class="cp">#define DMA_TLB_IAIG(val) (((val) &gt;&gt; 57) &amp; 7)</span>
<span class="cp">#define DMA_TLB_READ_DRAIN (((u64)1) &lt;&lt; 49)</span>
<span class="cp">#define DMA_TLB_WRITE_DRAIN (((u64)1) &lt;&lt; 48)</span>
<span class="cp">#define DMA_TLB_DID(id)	(((u64)((id) &amp; 0xffff)) &lt;&lt; 32)</span>
<span class="cp">#define DMA_TLB_IVT (((u64)1) &lt;&lt; 63)</span>
<span class="cp">#define DMA_TLB_IH_NONLEAF (((u64)1) &lt;&lt; 6)</span>
<span class="cp">#define DMA_TLB_MAX_SIZE (0x3f)</span>

<span class="cm">/* INVALID_DESC */</span>
<span class="cp">#define DMA_CCMD_INVL_GRANU_OFFSET  61</span>
<span class="cp">#define DMA_ID_TLB_GLOBAL_FLUSH	(((u64)1) &lt;&lt; 3)</span>
<span class="cp">#define DMA_ID_TLB_DSI_FLUSH	(((u64)2) &lt;&lt; 3)</span>
<span class="cp">#define DMA_ID_TLB_PSI_FLUSH	(((u64)3) &lt;&lt; 3)</span>
<span class="cp">#define DMA_ID_TLB_READ_DRAIN	(((u64)1) &lt;&lt; 7)</span>
<span class="cp">#define DMA_ID_TLB_WRITE_DRAIN	(((u64)1) &lt;&lt; 6)</span>
<span class="cp">#define DMA_ID_TLB_DID(id)	(((u64)((id &amp; 0xffff) &lt;&lt; 16)))</span>
<span class="cp">#define DMA_ID_TLB_IH_NONLEAF	(((u64)1) &lt;&lt; 6)</span>
<span class="cp">#define DMA_ID_TLB_ADDR(addr)	(addr)</span>
<span class="cp">#define DMA_ID_TLB_ADDR_MASK(mask)	(mask)</span>

<span class="cm">/* PMEN_REG */</span>
<span class="cp">#define DMA_PMEN_EPM (((u32)1)&lt;&lt;31)</span>
<span class="cp">#define DMA_PMEN_PRS (((u32)1)&lt;&lt;0)</span>

<span class="cm">/* GCMD_REG */</span>
<span class="cp">#define DMA_GCMD_TE (((u32)1) &lt;&lt; 31)</span>
<span class="cp">#define DMA_GCMD_SRTP (((u32)1) &lt;&lt; 30)</span>
<span class="cp">#define DMA_GCMD_SFL (((u32)1) &lt;&lt; 29)</span>
<span class="cp">#define DMA_GCMD_EAFL (((u32)1) &lt;&lt; 28)</span>
<span class="cp">#define DMA_GCMD_WBF (((u32)1) &lt;&lt; 27)</span>
<span class="cp">#define DMA_GCMD_QIE (((u32)1) &lt;&lt; 26)</span>
<span class="cp">#define DMA_GCMD_SIRTP (((u32)1) &lt;&lt; 24)</span>
<span class="cp">#define DMA_GCMD_IRE (((u32) 1) &lt;&lt; 25)</span>
<span class="cp">#define DMA_GCMD_CFI (((u32) 1) &lt;&lt; 23)</span>

<span class="cm">/* GSTS_REG */</span>
<span class="cp">#define DMA_GSTS_TES (((u32)1) &lt;&lt; 31)</span>
<span class="cp">#define DMA_GSTS_RTPS (((u32)1) &lt;&lt; 30)</span>
<span class="cp">#define DMA_GSTS_FLS (((u32)1) &lt;&lt; 29)</span>
<span class="cp">#define DMA_GSTS_AFLS (((u32)1) &lt;&lt; 28)</span>
<span class="cp">#define DMA_GSTS_WBFS (((u32)1) &lt;&lt; 27)</span>
<span class="cp">#define DMA_GSTS_QIES (((u32)1) &lt;&lt; 26)</span>
<span class="cp">#define DMA_GSTS_IRTPS (((u32)1) &lt;&lt; 24)</span>
<span class="cp">#define DMA_GSTS_IRES (((u32)1) &lt;&lt; 25)</span>
<span class="cp">#define DMA_GSTS_CFIS (((u32)1) &lt;&lt; 23)</span>

<span class="cm">/* CCMD_REG */</span>
<span class="cp">#define DMA_CCMD_ICC (((u64)1) &lt;&lt; 63)</span>
<span class="cp">#define DMA_CCMD_GLOBAL_INVL (((u64)1) &lt;&lt; 61)</span>
<span class="cp">#define DMA_CCMD_DOMAIN_INVL (((u64)2) &lt;&lt; 61)</span>
<span class="cp">#define DMA_CCMD_DEVICE_INVL (((u64)3) &lt;&lt; 61)</span>
<span class="cp">#define DMA_CCMD_FM(m) (((u64)((m) &amp; 0x3)) &lt;&lt; 32)</span>
<span class="cp">#define DMA_CCMD_MASK_NOBIT 0</span>
<span class="cp">#define DMA_CCMD_MASK_1BIT 1</span>
<span class="cp">#define DMA_CCMD_MASK_2BIT 2</span>
<span class="cp">#define DMA_CCMD_MASK_3BIT 3</span>
<span class="cp">#define DMA_CCMD_SID(s) (((u64)((s) &amp; 0xffff)) &lt;&lt; 16)</span>
<span class="cp">#define DMA_CCMD_DID(d) ((u64)((d) &amp; 0xffff))</span>

<span class="cm">/* FECTL_REG */</span>
<span class="cp">#define DMA_FECTL_IM (((u32)1) &lt;&lt; 31)</span>

<span class="cm">/* FSTS_REG */</span>
<span class="cp">#define DMA_FSTS_PPF ((u32)2)</span>
<span class="cp">#define DMA_FSTS_PFO ((u32)1)</span>
<span class="cp">#define DMA_FSTS_IQE (1 &lt;&lt; 4)</span>
<span class="cp">#define DMA_FSTS_ICE (1 &lt;&lt; 5)</span>
<span class="cp">#define DMA_FSTS_ITE (1 &lt;&lt; 6)</span>
<span class="cp">#define dma_fsts_fault_record_index(s) (((s) &gt;&gt; 8) &amp; 0xff)</span>

<span class="cm">/* FRCD_REG, 32 bits access */</span>
<span class="cp">#define DMA_FRCD_F (((u32)1) &lt;&lt; 31)</span>
<span class="cp">#define dma_frcd_type(d) ((d &gt;&gt; 30) &amp; 1)</span>
<span class="cp">#define dma_frcd_fault_reason(c) (c &amp; 0xff)</span>
<span class="cp">#define dma_frcd_source_id(c) (c &amp; 0xffff)</span>
<span class="cm">/* low 64 bit */</span>
<span class="cp">#define dma_frcd_page_addr(d) (d &amp; (((u64)-1) &lt;&lt; PAGE_SHIFT))</span>

<span class="cp">#define IOMMU_WAIT_OP(iommu, offset, op, cond, sts)			\</span>
<span class="cp">do {									\</span>
<span class="cp">	cycles_t start_time = get_cycles();				\</span>
<span class="cp">	while (1) {							\</span>
<span class="cp">		sts = op(iommu-&gt;reg + offset);				\</span>
<span class="cp">		if (cond)						\</span>
<span class="cp">			break;						\</span>
<span class="cp">		if (DMAR_OPERATION_TIMEOUT &lt; (get_cycles() - start_time))\</span>
<span class="cp">			panic(&quot;DMAR hardware is malfunctioning\n&quot;);	\</span>
<span class="cp">		cpu_relax();						\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define QI_LENGTH	256	</span><span class="cm">/* queue length */</span><span class="cp"></span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">QI_FREE</span><span class="p">,</span>
	<span class="n">QI_IN_USE</span><span class="p">,</span>
	<span class="n">QI_DONE</span><span class="p">,</span>
	<span class="n">QI_ABORT</span>
<span class="p">};</span>

<span class="cp">#define QI_CC_TYPE		0x1</span>
<span class="cp">#define QI_IOTLB_TYPE		0x2</span>
<span class="cp">#define QI_DIOTLB_TYPE		0x3</span>
<span class="cp">#define QI_IEC_TYPE		0x4</span>
<span class="cp">#define QI_IWD_TYPE		0x5</span>

<span class="cp">#define QI_IEC_SELECTIVE	(((u64)1) &lt;&lt; 4)</span>
<span class="cp">#define QI_IEC_IIDEX(idx)	(((u64)(idx &amp; 0xffff) &lt;&lt; 32))</span>
<span class="cp">#define QI_IEC_IM(m)		(((u64)(m &amp; 0x1f) &lt;&lt; 27))</span>

<span class="cp">#define QI_IWD_STATUS_DATA(d)	(((u64)d) &lt;&lt; 32)</span>
<span class="cp">#define QI_IWD_STATUS_WRITE	(((u64)1) &lt;&lt; 5)</span>

<span class="cp">#define QI_IOTLB_DID(did) 	(((u64)did) &lt;&lt; 16)</span>
<span class="cp">#define QI_IOTLB_DR(dr) 	(((u64)dr) &lt;&lt; 7)</span>
<span class="cp">#define QI_IOTLB_DW(dw) 	(((u64)dw) &lt;&lt; 6)</span>
<span class="cp">#define QI_IOTLB_GRAN(gran) 	(((u64)gran) &gt;&gt; (DMA_TLB_FLUSH_GRANU_OFFSET-4))</span>
<span class="cp">#define QI_IOTLB_ADDR(addr)	(((u64)addr) &amp; VTD_PAGE_MASK)</span>
<span class="cp">#define QI_IOTLB_IH(ih)		(((u64)ih) &lt;&lt; 6)</span>
<span class="cp">#define QI_IOTLB_AM(am)		(((u8)am))</span>

<span class="cp">#define QI_CC_FM(fm)		(((u64)fm) &lt;&lt; 48)</span>
<span class="cp">#define QI_CC_SID(sid)		(((u64)sid) &lt;&lt; 32)</span>
<span class="cp">#define QI_CC_DID(did)		(((u64)did) &lt;&lt; 16)</span>
<span class="cp">#define QI_CC_GRAN(gran)	(((u64)gran) &gt;&gt; (DMA_CCMD_INVL_GRANU_OFFSET-4))</span>

<span class="cp">#define QI_DEV_IOTLB_SID(sid)	((u64)((sid) &amp; 0xffff) &lt;&lt; 32)</span>
<span class="cp">#define QI_DEV_IOTLB_QDEP(qdep)	(((qdep) &amp; 0x1f) &lt;&lt; 16)</span>
<span class="cp">#define QI_DEV_IOTLB_ADDR(addr)	((u64)(addr) &amp; VTD_PAGE_MASK)</span>
<span class="cp">#define QI_DEV_IOTLB_SIZE	1</span>
<span class="cp">#define QI_DEV_IOTLB_MAX_INVS	32</span>

<span class="k">struct</span> <span class="n">qi_desc</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">q_inval</span> <span class="p">{</span>
	<span class="n">raw_spinlock_t</span>  <span class="n">q_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qi_desc</span>  <span class="o">*</span><span class="n">desc</span><span class="p">;</span>          <span class="cm">/* invalidation queue */</span>
	<span class="kt">int</span>             <span class="o">*</span><span class="n">desc_status</span><span class="p">;</span>   <span class="cm">/* desc status */</span>
	<span class="kt">int</span>             <span class="n">free_head</span><span class="p">;</span>      <span class="cm">/* first free entry */</span>
	<span class="kt">int</span>             <span class="n">free_tail</span><span class="p">;</span>      <span class="cm">/* last free entry */</span>
	<span class="kt">int</span>             <span class="n">free_cnt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_IRQ_REMAP</span>
<span class="cm">/* 1MB - maximum possible interrupt remapping table size */</span>
<span class="cp">#define INTR_REMAP_PAGE_ORDER	8</span>
<span class="cp">#define INTR_REMAP_TABLE_REG_SIZE	0xf</span>

<span class="cp">#define INTR_REMAP_TABLE_ENTRIES	65536</span>

<span class="k">struct</span> <span class="n">ir_table</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">irte</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">iommu_flush</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">flush_context</span><span class="p">)(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span> <span class="n">u16</span> <span class="n">did</span><span class="p">,</span> <span class="n">u16</span> <span class="n">sid</span><span class="p">,</span>
			      <span class="n">u8</span> <span class="n">fm</span><span class="p">,</span> <span class="n">u64</span> <span class="n">type</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">flush_iotlb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span> <span class="n">u16</span> <span class="n">did</span><span class="p">,</span> <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size_order</span><span class="p">,</span> <span class="n">u64</span> <span class="n">type</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SR_DMAR_FECTL_REG</span><span class="p">,</span>
	<span class="n">SR_DMAR_FEDATA_REG</span><span class="p">,</span>
	<span class="n">SR_DMAR_FEADDR_REG</span><span class="p">,</span>
	<span class="n">SR_DMAR_FEUADDR_REG</span><span class="p">,</span>
	<span class="n">MAX_SR_DMAR_REGS</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">reg</span><span class="p">;</span> <span class="cm">/* Pointer to hardware regs, virtual addr */</span>
	<span class="n">u64</span>		<span class="n">cap</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">ecap</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">gcmd</span><span class="p">;</span> <span class="cm">/* Holds TE, EAFL. Don&#39;t need SRTP, SFL, WBF */</span>
	<span class="n">raw_spinlock_t</span>	<span class="n">register_lock</span><span class="p">;</span> <span class="cm">/* protect register handling */</span>
	<span class="kt">int</span>		<span class="n">seq_id</span><span class="p">;</span>	<span class="cm">/* sequence id of the iommu */</span>
	<span class="kt">int</span>		<span class="n">agaw</span><span class="p">;</span> <span class="cm">/* agaw of this iommu */</span>
	<span class="kt">int</span>		<span class="n">msagaw</span><span class="p">;</span> <span class="cm">/* max sagaw of this iommu */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> 	<span class="n">irq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> 	<span class="n">name</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>    <span class="cm">/* Device Name */</span>

<span class="cp">#ifdef CONFIG_INTEL_IOMMU</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> 	<span class="o">*</span><span class="n">domain_ids</span><span class="p">;</span> <span class="cm">/* bitmap of domains */</span>
	<span class="k">struct</span> <span class="n">dmar_domain</span> <span class="o">**</span><span class="n">domains</span><span class="p">;</span> <span class="cm">/* ptr to domains */</span>
	<span class="n">spinlock_t</span>	<span class="n">lock</span><span class="p">;</span> <span class="cm">/* protect context, domain ids */</span>
	<span class="k">struct</span> <span class="n">root_entry</span> <span class="o">*</span><span class="n">root_entry</span><span class="p">;</span> <span class="cm">/* virtual address */</span>

	<span class="k">struct</span> <span class="n">iommu_flush</span> <span class="n">flush</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">q_inval</span>  <span class="o">*</span><span class="n">qi</span><span class="p">;</span>            <span class="cm">/* Queued invalidation info */</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">iommu_state</span><span class="p">;</span> <span class="cm">/* Store iommu states between suspend and resume.*/</span>

<span class="cp">#ifdef CONFIG_IRQ_REMAP</span>
	<span class="k">struct</span> <span class="n">ir_table</span> <span class="o">*</span><span class="n">ir_table</span><span class="p">;</span>	<span class="cm">/* Interrupt remapping info */</span>
<span class="cp">#endif</span>
	<span class="kt">int</span>		<span class="n">node</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__iommu_flush_cache</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ecap_coherent</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">ecap</span><span class="p">))</span>
		<span class="n">clflush_cache_range</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">dmar_drhd_unit</span> <span class="o">*</span> <span class="n">dmar_find_matched_drhd_unit</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dmar_find_matched_atsr_unit</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">alloc_iommu</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmar_drhd_unit</span> <span class="o">*</span><span class="n">drhd</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_iommu</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dmar_enable_qi</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dmar_disable_qi</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dmar_reenable_qi</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">qi_global_iec</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">qi_flush_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span> <span class="n">u16</span> <span class="n">did</span><span class="p">,</span> <span class="n">u16</span> <span class="n">sid</span><span class="p">,</span>
			     <span class="n">u8</span> <span class="n">fm</span><span class="p">,</span> <span class="n">u64</span> <span class="n">type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">qi_flush_iotlb</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span> <span class="n">u16</span> <span class="n">did</span><span class="p">,</span> <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size_order</span><span class="p">,</span> <span class="n">u64</span> <span class="n">type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">qi_flush_dev_iotlb</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span> <span class="n">u16</span> <span class="n">sid</span><span class="p">,</span> <span class="n">u16</span> <span class="n">qdep</span><span class="p">,</span>
			       <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mask</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">qi_submit_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">qi_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">intel_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">dmar_ir_support</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
