<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › exportfs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>exportfs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef LINUX_EXPORTFS_H</span>
<span class="cp">#define LINUX_EXPORTFS_H 1</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="k">struct</span> <span class="n">dentry</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">inode</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">super_block</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">vfsmount</span><span class="p">;</span>

<span class="cm">/* limit the handle size to NFSv4 handle size now */</span>
<span class="cp">#define MAX_HANDLE_SZ 128</span>

<span class="cm">/*</span>
<span class="cm"> * The fileid_type identifies how the file within the filesystem is encoded.</span>
<span class="cm"> * In theory this is freely set and parsed by the filesystem, but we try to</span>
<span class="cm"> * stick to conventions so we can share some generic code and don&#39;t confuse</span>
<span class="cm"> * sniffers like ethereal/wireshark.</span>
<span class="cm"> *</span>
<span class="cm"> * The filesystem must not use the value &#39;0&#39; or &#39;0xff&#39;.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">fid_type</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The root, or export point, of the filesystem.</span>
<span class="cm">	 * (Never actually passed down to the filesystem.</span>
<span class="cm">	 */</span>
	<span class="n">FILEID_ROOT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * 32bit inode number, 32 bit generation number.</span>
<span class="cm">	 */</span>
	<span class="n">FILEID_INO32_GEN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * 32bit inode number, 32 bit generation number,</span>
<span class="cm">	 * 32 bit parent directory inode number.</span>
<span class="cm">	 */</span>
	<span class="n">FILEID_INO32_GEN_PARENT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * 64 bit object ID, 64 bit root object ID,</span>
<span class="cm">	 * 32 bit generation number.</span>
<span class="cm">	 */</span>
	<span class="n">FILEID_BTRFS_WITHOUT_PARENT</span> <span class="o">=</span> <span class="mh">0x4d</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * 64 bit object ID, 64 bit root object ID,</span>
<span class="cm">	 * 32 bit generation number,</span>
<span class="cm">	 * 64 bit parent object ID, 32 bit parent generation.</span>
<span class="cm">	 */</span>
	<span class="n">FILEID_BTRFS_WITH_PARENT</span> <span class="o">=</span> <span class="mh">0x4e</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * 64 bit object ID, 64 bit root object ID,</span>
<span class="cm">	 * 32 bit generation number,</span>
<span class="cm">	 * 64 bit parent object ID, 32 bit parent generation,</span>
<span class="cm">	 * 64 bit parent root object ID.</span>
<span class="cm">	 */</span>
	<span class="n">FILEID_BTRFS_WITH_PARENT_ROOT</span> <span class="o">=</span> <span class="mh">0x4f</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * 32 bit block number, 16 bit partition reference,</span>
<span class="cm">	 * 16 bit unused, 32 bit generation number.</span>
<span class="cm">	 */</span>
	<span class="n">FILEID_UDF_WITHOUT_PARENT</span> <span class="o">=</span> <span class="mh">0x51</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * 32 bit block number, 16 bit partition reference,</span>
<span class="cm">	 * 16 bit unused, 32 bit generation number,</span>
<span class="cm">	 * 32 bit parent block number, 32 bit parent generation number</span>
<span class="cm">	 */</span>
	<span class="n">FILEID_UDF_WITH_PARENT</span> <span class="o">=</span> <span class="mh">0x52</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * 64 bit checkpoint number, 64 bit inode number,</span>
<span class="cm">	 * 32 bit generation number.</span>
<span class="cm">	 */</span>
	<span class="n">FILEID_NILFS_WITHOUT_PARENT</span> <span class="o">=</span> <span class="mh">0x61</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * 64 bit checkpoint number, 64 bit inode number,</span>
<span class="cm">	 * 32 bit generation number, 32 bit parent generation.</span>
<span class="cm">	 * 64 bit parent inode number.</span>
<span class="cm">	 */</span>
	<span class="n">FILEID_NILFS_WITH_PARENT</span> <span class="o">=</span> <span class="mh">0x62</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fid</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">ino</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">gen</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">parent_ino</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">parent_gen</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">i32</span><span class="p">;</span>
 		<span class="k">struct</span> <span class="p">{</span>
 			<span class="n">u32</span> <span class="n">block</span><span class="p">;</span>
 			<span class="n">u16</span> <span class="n">partref</span><span class="p">;</span>
 			<span class="n">u16</span> <span class="n">parent_partref</span><span class="p">;</span>
 			<span class="n">u32</span> <span class="n">generation</span><span class="p">;</span>
 			<span class="n">u32</span> <span class="n">parent_block</span><span class="p">;</span>
 			<span class="n">u32</span> <span class="n">parent_generation</span><span class="p">;</span>
 		<span class="p">}</span> <span class="n">udf</span><span class="p">;</span>
		<span class="n">__u32</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct export_operations - for nfsd to communicate with file systems</span>
<span class="cm"> * @encode_fh:      encode a file handle fragment from a dentry</span>
<span class="cm"> * @fh_to_dentry:   find the implied object and get a dentry for it</span>
<span class="cm"> * @fh_to_parent:   find the implied object&#39;s parent and get a dentry for it</span>
<span class="cm"> * @get_name:       find the name for a given inode in a given directory</span>
<span class="cm"> * @get_parent:     find the parent of a given directory</span>
<span class="cm"> * @commit_metadata: commit metadata changes to stable storage</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/filesystems/nfs/Exporting for details on how to use</span>
<span class="cm"> * this interface correctly.</span>
<span class="cm"> *</span>
<span class="cm"> * encode_fh:</span>
<span class="cm"> *    @encode_fh should store in the file handle fragment @fh (using at most</span>
<span class="cm"> *    @max_len bytes) information that can be used by @decode_fh to recover the</span>
<span class="cm"> *    file referred to by the &amp;struct dentry @de.  If the @connectable flag is</span>
<span class="cm"> *    set, the encode_fh() should store sufficient information so that a good</span>
<span class="cm"> *    attempt can be made to find not only the file but also it&#39;s place in the</span>
<span class="cm"> *    filesystem.   This typically means storing a reference to de-&gt;d_parent in</span>
<span class="cm"> *    the filehandle fragment.  encode_fh() should return the fileid_type on</span>
<span class="cm"> *    success and on error returns 255 (if the space needed to encode fh is</span>
<span class="cm"> *    greater than @max_len*4 bytes). On error @max_len contains the minimum</span>
<span class="cm"> *    size(in 4 byte unit) needed to encode the file handle.</span>
<span class="cm"> *</span>
<span class="cm"> * fh_to_dentry:</span>
<span class="cm"> *    @fh_to_dentry is given a &amp;struct super_block (@sb) and a file handle</span>
<span class="cm"> *    fragment (@fh, @fh_len). It should return a &amp;struct dentry which refers</span>
<span class="cm"> *    to the same file that the file handle fragment refers to.  If it cannot,</span>
<span class="cm"> *    it should return a %NULL pointer if the file was found but no acceptable</span>
<span class="cm"> *    &amp;dentries were available, or an %ERR_PTR error code indicating why it</span>
<span class="cm"> *    couldn&#39;t be found (e.g. %ENOENT or %ENOMEM).  Any suitable dentry can be</span>
<span class="cm"> *    returned including, if necessary, a new dentry created with d_alloc_root.</span>
<span class="cm"> *    The caller can then find any other extant dentries by following the</span>
<span class="cm"> *    d_alias links.</span>
<span class="cm"> *</span>
<span class="cm"> * fh_to_parent:</span>
<span class="cm"> *    Same as @fh_to_dentry, except that it returns a pointer to the parent</span>
<span class="cm"> *    dentry if it was encoded into the filehandle fragment by @encode_fh.</span>
<span class="cm"> *</span>
<span class="cm"> * get_name:</span>
<span class="cm"> *    @get_name should find a name for the given @child in the given @parent</span>
<span class="cm"> *    directory.  The name should be stored in the @name (with the</span>
<span class="cm"> *    understanding that it is already pointing to a a %NAME_MAX+1 sized</span>
<span class="cm"> *    buffer.   get_name() should return %0 on success, a negative error code</span>
<span class="cm"> *    or error.  @get_name will be called without @parent-&gt;i_mutex held.</span>
<span class="cm"> *</span>
<span class="cm"> * get_parent:</span>
<span class="cm"> *    @get_parent should find the parent directory for the given @child which</span>
<span class="cm"> *    is also a directory.  In the event that it cannot be found, or storage</span>
<span class="cm"> *    space cannot be allocated, a %ERR_PTR should be returned.</span>
<span class="cm"> *</span>
<span class="cm"> * commit_metadata:</span>
<span class="cm"> *    @commit_metadata should commit metadata changes to stable storage.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking rules:</span>
<span class="cm"> *    get_parent is called with child-&gt;d_inode-&gt;i_mutex down</span>
<span class="cm"> *    get_name is not (which is possibly inconsistent)</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">export_operations</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">encode_fh</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">max_len</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">fh_to_dentry</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fid</span> <span class="o">*</span><span class="n">fid</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">fh_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fh_type</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">fh_to_parent</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fid</span> <span class="o">*</span><span class="n">fid</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">fh_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fh_type</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_name</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">get_parent</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">commit_metadata</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">exportfs_encode_fh</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fid</span> <span class="o">*</span><span class="n">fid</span><span class="p">,</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">max_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">connectable</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">exportfs_decode_fh</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fid</span> <span class="o">*</span><span class="n">fid</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">fh_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fileid_type</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">acceptable</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">),</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Generic helpers for filesystems.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">generic_fh_to_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">fid</span> <span class="o">*</span><span class="n">fid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fh_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fh_type</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ino</span><span class="p">,</span> <span class="n">u32</span> <span class="n">gen</span><span class="p">));</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">generic_fh_to_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">fid</span> <span class="o">*</span><span class="n">fid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fh_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fh_type</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ino</span><span class="p">,</span> <span class="n">u32</span> <span class="n">gen</span><span class="p">));</span>

<span class="cp">#endif </span><span class="cm">/* LINUX_EXPORTFS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
