<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › kvm_host.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>kvm_host.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __KVM_HOST_H</span>
<span class="cp">#define __KVM_HOST_H</span>

<span class="cm">/*</span>
<span class="cm"> * This work is licensed under the terms of the GNU GPL, version 2.  See</span>
<span class="cm"> * the COPYING file in the top-level directory.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/mmu_notifier.h&gt;</span>
<span class="cp">#include &lt;linux/preempt.h&gt;</span>
<span class="cp">#include &lt;linux/msi.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &lt;asm/signal.h&gt;</span>

<span class="cp">#include &lt;linux/kvm.h&gt;</span>
<span class="cp">#include &lt;linux/kvm_para.h&gt;</span>

<span class="cp">#include &lt;linux/kvm_types.h&gt;</span>

<span class="cp">#include &lt;asm/kvm_host.h&gt;</span>

<span class="cp">#ifndef KVM_MMIO_SIZE</span>
<span class="cp">#define KVM_MMIO_SIZE 8</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * If we support unaligned MMIO, at most one fragment will be split into two:</span>
<span class="cm"> */</span>
<span class="cp">#ifdef KVM_UNALIGNED_MMIO</span>
<span class="cp">#  define KVM_EXTRA_MMIO_FRAGMENTS 1</span>
<span class="cp">#else</span>
<span class="cp">#  define KVM_EXTRA_MMIO_FRAGMENTS 0</span>
<span class="cp">#endif</span>

<span class="cp">#define KVM_USER_MMIO_SIZE 8</span>

<span class="cp">#define KVM_MAX_MMIO_FRAGMENTS \</span>
<span class="cp">	(KVM_MMIO_SIZE / KVM_USER_MMIO_SIZE + KVM_EXTRA_MMIO_FRAGMENTS)</span>

<span class="cm">/*</span>
<span class="cm"> * vcpu-&gt;requests bit members</span>
<span class="cm"> */</span>
<span class="cp">#define KVM_REQ_TLB_FLUSH          0</span>
<span class="cp">#define KVM_REQ_MIGRATE_TIMER      1</span>
<span class="cp">#define KVM_REQ_REPORT_TPR_ACCESS  2</span>
<span class="cp">#define KVM_REQ_MMU_RELOAD         3</span>
<span class="cp">#define KVM_REQ_TRIPLE_FAULT       4</span>
<span class="cp">#define KVM_REQ_PENDING_TIMER      5</span>
<span class="cp">#define KVM_REQ_UNHALT             6</span>
<span class="cp">#define KVM_REQ_MMU_SYNC           7</span>
<span class="cp">#define KVM_REQ_CLOCK_UPDATE       8</span>
<span class="cp">#define KVM_REQ_KICK               9</span>
<span class="cp">#define KVM_REQ_DEACTIVATE_FPU    10</span>
<span class="cp">#define KVM_REQ_EVENT             11</span>
<span class="cp">#define KVM_REQ_APF_HALT          12</span>
<span class="cp">#define KVM_REQ_STEAL_UPDATE      13</span>
<span class="cp">#define KVM_REQ_NMI               14</span>
<span class="cp">#define KVM_REQ_IMMEDIATE_EXIT    15</span>
<span class="cp">#define KVM_REQ_PMU               16</span>
<span class="cp">#define KVM_REQ_PMI               17</span>

<span class="cp">#define KVM_USERSPACE_IRQ_SOURCE_ID	0</span>

<span class="k">struct</span> <span class="n">kvm</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kvm_vcpu</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">kvm_vcpu_cache</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">kvm_io_range</span> <span class="p">{</span>
	<span class="n">gpa_t</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_io_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define NR_IOBUS_DEVS 1000</span>

<span class="k">struct</span> <span class="n">kvm_io_bus</span> <span class="p">{</span>
	<span class="kt">int</span>                   <span class="n">dev_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_io_range</span> <span class="n">range</span><span class="p">[];</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">kvm_bus</span> <span class="p">{</span>
	<span class="n">KVM_MMIO_BUS</span><span class="p">,</span>
	<span class="n">KVM_PIO_BUS</span><span class="p">,</span>
	<span class="n">KVM_NR_BUSES</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">kvm_io_bus_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">enum</span> <span class="n">kvm_bus</span> <span class="n">bus_idx</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">addr</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_io_bus_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">enum</span> <span class="n">kvm_bus</span> <span class="n">bus_idx</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
		    <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_io_bus_register_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">enum</span> <span class="n">kvm_bus</span> <span class="n">bus_idx</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">addr</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_io_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_io_bus_unregister_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">enum</span> <span class="n">kvm_bus</span> <span class="n">bus_idx</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">kvm_io_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_KVM_ASYNC_PF</span>
<span class="k">struct</span> <span class="n">kvm_async_pf</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">gva_t</span> <span class="n">gva</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_arch_async_pf</span> <span class="n">arch</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">done</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">kvm_clear_async_pf_completion_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_check_async_pf_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_setup_async_pf</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">kvm_arch_async_pf</span> <span class="o">*</span><span class="n">arch</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_async_pf_wakeup_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">OUTSIDE_GUEST_MODE</span><span class="p">,</span>
	<span class="n">IN_GUEST_MODE</span><span class="p">,</span>
	<span class="n">EXITING_GUEST_MODE</span><span class="p">,</span>
	<span class="n">READING_SHADOW_PAGE_TABLES</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Sometimes a large or cross-page mmio needs to be broken up into separate</span>
<span class="cm"> * exits for userspace servicing.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kvm_mmio_fragment</span> <span class="p">{</span>
	<span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PREEMPT_NOTIFIERS</span>
	<span class="k">struct</span> <span class="n">preempt_notifier</span> <span class="n">preempt_notifier</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vcpu_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">srcu_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">requests</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">guest_debug</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">run</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">fpu_active</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">guest_fpu_loaded</span><span class="p">,</span> <span class="n">guest_xcr0_loaded</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sigset_active</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">sigset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu_stat</span> <span class="n">stat</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HAS_IOMEM</span>
	<span class="kt">int</span> <span class="n">mmio_needed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mmio_read_completed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mmio_is_write</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mmio_cur_fragment</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mmio_nr_fragments</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_mmio_fragment</span> <span class="n">mmio_fragments</span><span class="p">[</span><span class="n">KVM_MAX_MMIO_FRAGMENTS</span><span class="p">];</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_KVM_ASYNC_PF</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">queued</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="n">queue</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="n">done</span><span class="p">;</span>
		<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">async_pf</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">kvm_vcpu_arch</span> <span class="n">arch</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kvm_vcpu_exiting_guest_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">,</span> <span class="n">IN_GUEST_MODE</span><span class="p">,</span> <span class="n">EXITING_GUEST_MODE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Some of the bitops functions do not support too long bitmaps.</span>
<span class="cm"> * This number must be determined not to exceed such limits.</span>
<span class="cm"> */</span>
<span class="cp">#define KVM_MEM_MAX_NR_PAGES ((1UL &lt;&lt; 31) - 1)</span>

<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="p">{</span>
	<span class="n">gfn_t</span> <span class="n">base_gfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dirty_bitmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_arch_memory_slot</span> <span class="n">arch</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">userspace_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">user_alloc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">kvm_dirty_bitmap_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">npages</span><span class="p">,</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">kvm_kernel_irq_routing_entry</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">gsi</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_kernel_irq_routing_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq_source_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">);</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="n">irqchip</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="n">pin</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">irqchip</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">msi_msg</span> <span class="n">msi</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">link</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef __KVM_HAVE_IOAPIC</span>

<span class="k">struct</span> <span class="n">kvm_irq_routing_table</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">chip</span><span class="p">[</span><span class="n">KVM_NR_IRQCHIPS</span><span class="p">][</span><span class="n">KVM_IOAPIC_NUM_PINS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">kvm_kernel_irq_routing_entry</span> <span class="o">*</span><span class="n">rt_entries</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nr_rt_entries</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Array indexed by gsi. Each entry contains list of irq chips</span>
<span class="cm">	 * the gsi is connected to.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#else</span>

<span class="k">struct</span> <span class="n">kvm_irq_routing_table</span> <span class="p">{};</span>

<span class="cp">#endif</span>

<span class="cp">#ifndef KVM_MEM_SLOTS_NUM</span>
<span class="cp">#define KVM_MEM_SLOTS_NUM (KVM_MEMORY_SLOTS + KVM_PRIVATE_MEM_SLOTS)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Note:</span>
<span class="cm"> * memslots are not sorted by id anymore, please use id_to_memslot()</span>
<span class="cm"> * to get the memslot by its id.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">generation</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="n">memslots</span><span class="p">[</span><span class="n">KVM_MEM_SLOTS_NUM</span><span class="p">];</span>
	<span class="cm">/* The mapping table from slot id to the index in memslots[]. */</span>
	<span class="kt">int</span> <span class="n">id_to_index</span><span class="p">[</span><span class="n">KVM_MEM_SLOTS_NUM</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">mmu_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">slots_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span> <span class="cm">/* userspace tied to this vm */</span>
	<span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">memslots</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">srcu_struct</span> <span class="n">srcu</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_KVM_APIC_ARCHITECTURE</span>
	<span class="n">u32</span> <span class="n">bsp_vcpu_id</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpus</span><span class="p">[</span><span class="n">KVM_MAX_VCPUS</span><span class="p">];</span>
	<span class="n">atomic_t</span> <span class="n">online_vcpus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_boosted_vcpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">vm_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_io_bus</span> <span class="o">*</span><span class="n">buses</span><span class="p">[</span><span class="n">KVM_NR_BUSES</span><span class="p">];</span>
<span class="cp">#ifdef CONFIG_HAVE_KVM_EVENTFD</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">spinlock_t</span>        <span class="n">lock</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span>  <span class="n">items</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">irqfds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ioeventfds</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">kvm_vm_stat</span> <span class="n">stat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_arch</span> <span class="n">arch</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">users_count</span><span class="p">;</span>
<span class="cp">#ifdef KVM_COALESCED_MMIO_PAGE_OFFSET</span>
	<span class="k">struct</span> <span class="n">kvm_coalesced_mmio_ring</span> <span class="o">*</span><span class="n">coalesced_mmio_ring</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">ring_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">coalesced_zones</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">irq_lock</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HAVE_KVM_IRQCHIP</span>
	<span class="cm">/*</span>
<span class="cm">	 * Update side is protected by irq_lock and,</span>
<span class="cm">	 * if configured, irqfds.lock.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">kvm_irq_routing_table</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">irq_routing</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">mask_notifier_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">irq_ack_notifier_list</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef KVM_ARCH_WANT_MMU_NOTIFIER</span>
	<span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="n">mmu_notifier</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmu_notifier_seq</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">mmu_notifier_count</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">long</span> <span class="n">tlbs_dirty</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The guest did something we don&#39;t support. */</span>
<span class="cp">#define pr_unimpl(vcpu, fmt, ...)					\</span>
<span class="cp">	pr_err_ratelimited(&quot;kvm: %i: cpu%i &quot; fmt,			\</span>
<span class="cp">			   current-&gt;tgid, (vcpu)-&gt;vcpu_id , ## __VA_ARGS__)</span>

<span class="cp">#define kvm_printf(kvm, fmt ...) printk(KERN_DEBUG fmt)</span>
<span class="cp">#define vcpu_printf(vcpu, fmt...) kvm_printf(vcpu-&gt;kvm, fmt)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="nf">kvm_get_vcpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">vcpus</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="cp">#define kvm_for_each_vcpu(idx, vcpup, kvm) \</span>
<span class="cp">	for (idx = 0; \</span>
<span class="cp">	     idx &lt; atomic_read(&amp;kvm-&gt;online_vcpus) &amp;&amp; \</span>
<span class="cp">	     (vcpup = kvm_get_vcpu(kvm, idx)) != NULL; \</span>
<span class="cp">	     idx++)</span>

<span class="cp">#define kvm_for_each_memslot(memslot, slots)	\</span>
<span class="cp">	for (memslot = &amp;slots-&gt;memslots[0];	\</span>
<span class="cp">	      memslot &lt; slots-&gt;memslots + KVM_MEM_SLOTS_NUM &amp;&amp; memslot-&gt;npages;\</span>
<span class="cp">		memslot++)</span>

<span class="kt">int</span> <span class="n">kvm_vcpu_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">id</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_vcpu_uninit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vcpu_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">vcpu_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">vcpu_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">vcpu_align</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">kvm_get_kvm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_put_kvm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">update_memslots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">new</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="nf">kvm_memslots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">,</span>
			<span class="n">srcu_read_lock_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">)</span>
			<span class="o">||</span> <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span>
<span class="nf">id_to_memslot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">slots</span><span class="o">-&gt;</span><span class="n">id_to_index</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">slots</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">slot</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define HPA_MSB ((sizeof(hpa_t) * 8) - 1)</span>
<span class="cp">#define HPA_ERR_MASK ((hpa_t)1 &lt;&lt; HPA_MSB)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_error_hpa</span><span class="p">(</span><span class="n">hpa_t</span> <span class="n">hpa</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hpa</span> <span class="o">&gt;&gt;</span> <span class="n">HPA_MSB</span><span class="p">;</span> <span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">bad_page</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">fault_page</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">pfn_t</span> <span class="n">bad_pfn</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">pfn_t</span> <span class="n">fault_pfn</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">is_error_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">is_error_pfn</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">is_hwpoison_pfn</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">is_fault_pfn</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">is_noslot_pfn</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">is_invalid_pfn</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_is_error_hva</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_set_memory_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">user_alloc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__kvm_set_memory_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">user_alloc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_arch_free_memslot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">free</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">dont</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_create_memslot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_prepare_memory_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="n">old</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">user_alloc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_arch_commit_memory_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="n">old</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">user_alloc</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">kvm_largepages_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_disable_largepages</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_arch_flush_shadow</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">gfn_to_page_many_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">gfn_to_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gfn_to_hva</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_release_page_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_release_page_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_set_page_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_set_page_accessed</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

<span class="n">pfn_t</span> <span class="n">hva_to_pfn_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="n">pfn_t</span> <span class="n">gfn_to_pfn_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">);</span>
<span class="n">pfn_t</span> <span class="n">gfn_to_pfn_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">async</span><span class="p">,</span>
		       <span class="n">bool</span> <span class="n">write_fault</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">writable</span><span class="p">);</span>
<span class="n">pfn_t</span> <span class="n">gfn_to_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">);</span>
<span class="n">pfn_t</span> <span class="n">gfn_to_pfn_prot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">bool</span> <span class="n">write_fault</span><span class="p">,</span>
		      <span class="n">bool</span> <span class="o">*</span><span class="n">writable</span><span class="p">);</span>
<span class="n">pfn_t</span> <span class="n">gfn_to_pfn_memslot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_release_pfn_dirty</span><span class="p">(</span><span class="n">pfn_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_release_pfn_clean</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_set_pfn_dirty</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_set_pfn_accessed</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_get_pfn</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_read_guest_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_read_guest_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_read_guest</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_read_guest_cached</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gfn_to_hva_cache</span> <span class="o">*</span><span class="n">ghc</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_write_guest_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_write_guest</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_write_guest_cached</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gfn_to_hva_cache</span> <span class="o">*</span><span class="n">ghc</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_gfn_to_hva_cache_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gfn_to_hva_cache</span> <span class="o">*</span><span class="n">ghc</span><span class="p">,</span>
			      <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_clear_guest_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_clear_guest</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">gfn_to_memslot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_is_visible_gfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kvm_host_page_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mark_page_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mark_page_dirty_in_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">,</span>
			     <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">kvm_vcpu_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_vcpu_kick</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">kvm_vcpu_yield_to</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">target</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_vcpu_on_spin</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_resched</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_load_guest_fpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_put_guest_fpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_reload_remote_mmus</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>

<span class="kt">long</span> <span class="n">kvm_arch_dev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">kvm_arch_vcpu_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_vcpu_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_dev_ioctl_check_extension</span><span class="p">(</span><span class="kt">long</span> <span class="n">ext</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_get_dirty_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">kvm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">is_dirty</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_vm_ioctl_get_dirty_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kvm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_vm_ioctl_set_memory_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				   <span class="k">struct</span>
				   <span class="n">kvm_userspace_memory_region</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">user_alloc</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">kvm_arch_vm_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_arch_vcpu_ioctl_get_fpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_fpu</span> <span class="o">*</span><span class="n">fpu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_vcpu_ioctl_set_fpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_fpu</span> <span class="o">*</span><span class="n">fpu</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_arch_vcpu_ioctl_translate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvm_translation</span> <span class="o">*</span><span class="n">tr</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_arch_vcpu_ioctl_get_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_vcpu_ioctl_set_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_vcpu_ioctl_get_sregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kvm_sregs</span> <span class="o">*</span><span class="n">sregs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_vcpu_ioctl_set_sregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kvm_sregs</span> <span class="o">*</span><span class="n">sregs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_vcpu_ioctl_get_mpstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvm_mp_state</span> <span class="o">*</span><span class="n">mp_state</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_vcpu_ioctl_set_mpstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvm_mp_state</span> <span class="o">*</span><span class="n">mp_state</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_vcpu_ioctl_set_guest_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kvm_guest_debug</span> <span class="o">*</span><span class="n">dbg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_vcpu_ioctl_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_arch_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_arch_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_arch_vcpu_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_arch_vcpu_uninit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">kvm_arch_vcpu_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_arch_vcpu_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_arch_vcpu_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">kvm_arch_vcpu_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_vcpu_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_arch_vcpu_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_arch_vcpu_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_hardware_enable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">garbage</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_arch_hardware_disable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">garbage</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_hardware_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_arch_hardware_unsetup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_arch_check_processor_compat</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">rtn</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_vcpu_runnable</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_vcpu_should_kick</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">kvm_free_physmem</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>

<span class="cp">#ifndef __KVM_HAVE_ARCH_VM_ALLOC</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="nf">kvm_arch_alloc_vm</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_arch_free_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="nf">kvm_arch_vcpu_wq</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef __KVM_HAVE_ARCH_WQP</span>
	<span class="k">return</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">wqp</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">kvm_arch_init_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_arch_destroy_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_free_all_assigned_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_arch_sync_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_cpu_has_pending_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_vcpu_kick</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_is_mmio_pfn</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">kvm_irq_ack_notifier</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">link</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">gsi</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_acked</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_irq_ack_notifier</span> <span class="o">*</span><span class="n">kian</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_assigned_dev_kernel</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_irq_ack_notifier</span> <span class="n">ack_notifier</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">assigned_dev_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">host_segnr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">host_busnr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">host_devfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">entries_nr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">host_irq</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">host_irq_disabled</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">pci_2_3</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msix_entry</span> <span class="o">*</span><span class="n">host_msix_entries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">guest_irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msix_entry</span> <span class="o">*</span><span class="n">guest_msix_entries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_requested_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq_source_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">intx_lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">intx_mask_lock</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">irq_name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">pci_saved_state</span> <span class="o">*</span><span class="n">pci_saved_state</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_irq_mask_notifier</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_irq_mask_notifier</span> <span class="o">*</span><span class="n">kimn</span><span class="p">,</span> <span class="n">bool</span> <span class="n">masked</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">link</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">kvm_register_irq_mask_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvm_irq_mask_notifier</span> <span class="o">*</span><span class="n">kimn</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_unregister_irq_mask_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">kvm_irq_mask_notifier</span> <span class="o">*</span><span class="n">kimn</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_fire_mask_notifiers</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">irqchip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">pin</span><span class="p">,</span>
			     <span class="n">bool</span> <span class="n">mask</span><span class="p">);</span>

<span class="cp">#ifdef __KVM_HAVE_IOAPIC</span>
<span class="kt">void</span> <span class="n">kvm_get_intr_delivery_bitmask</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_ioapic</span> <span class="o">*</span><span class="n">ioapic</span><span class="p">,</span>
				   <span class="k">union</span> <span class="n">kvm_ioapic_redirect_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">deliver_bitmask</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="kt">int</span> <span class="n">kvm_set_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq_source_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_set_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_kernel_irq_routing_entry</span> <span class="o">*</span><span class="n">irq_entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">irq_source_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_notify_acked_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">irqchip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">pin</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_register_irq_ack_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">kvm_irq_ack_notifier</span> <span class="o">*</span><span class="n">kian</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_unregister_irq_ack_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">kvm_irq_ack_notifier</span> <span class="o">*</span><span class="n">kian</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_request_irq_source_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_free_irq_source_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq_source_id</span><span class="p">);</span>

<span class="cm">/* For vcpu-&gt;arch.iommu_flags */</span>
<span class="cp">#define KVM_IOMMU_CACHE_COHERENCY	0x1</span>

<span class="cp">#ifdef CONFIG_IOMMU_API</span>
<span class="kt">int</span> <span class="n">kvm_iommu_map_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_iommu_unmap_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_iommu_map_guest</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_iommu_unmap_guest</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_assign_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">kvm_assigned_dev_kernel</span> <span class="o">*</span><span class="n">assigned_dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_deassign_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">kvm_assigned_dev_kernel</span> <span class="o">*</span><span class="n">assigned_dev</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_IOMMU_API */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kvm_iommu_map_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_iommu_unmap_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kvm_iommu_map_guest</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kvm_iommu_unmap_guest</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kvm_assign_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kvm_assigned_dev_kernel</span> <span class="o">*</span><span class="n">assigned_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kvm_deassign_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kvm_assigned_dev_kernel</span> <span class="o">*</span><span class="n">assigned_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IOMMU_API */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_guest_enter</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">preemptible</span><span class="p">());</span>
	<span class="n">account_system_vtime</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_VCPU</span><span class="p">;</span>
	<span class="cm">/* KVM does not hold any references to rcu protected data when it</span>
<span class="cm">	 * switches CPU into a guest mode. In fact switching to a guest mode</span>
<span class="cm">	 * is very similar to exiting to userspase from rcu point of view. In</span>
<span class="cm">	 * addition CPU may stay in a guest mode for quite a long time (up to</span>
<span class="cm">	 * one time slice). Lets treat guest mode as quiescent state, just like</span>
<span class="cm">	 * we do with user-mode execution.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_virt_note_context_switch</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_guest_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">account_system_vtime</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PF_VCPU</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * search_memslots() and __gfn_to_memslot() are here because they are</span>
<span class="cm"> * used in non-modular code in arch/powerpc/kvm/book3s_hv_rm_mmu.c.</span>
<span class="cm"> * gfn_to_memslot() itself isn&#39;t here as an inline because that would</span>
<span class="cm"> * bloat other code too much.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span>
<span class="nf">search_memslots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">;</span>

	<span class="n">kvm_for_each_memslot</span><span class="p">(</span><span class="n">memslot</span><span class="p">,</span> <span class="n">slots</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gfn</span> <span class="o">&gt;=</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">base_gfn</span> <span class="o">&amp;&amp;</span>
		      <span class="n">gfn</span> <span class="o">&lt;</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">base_gfn</span> <span class="o">+</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">npages</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">memslot</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span>
<span class="nf">__gfn_to_memslot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">search_memslots</span><span class="p">(</span><span class="n">slots</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">memslot_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">gfn_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">gfn_t</span> <span class="nf">gfn_to_index</span><span class="p">(</span><span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">base_gfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* KVM_HPAGE_GFN_SHIFT(PT_PAGE_TABLE_LEVEL) must be 0. */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">gfn</span> <span class="o">&gt;&gt;</span> <span class="n">KVM_HPAGE_GFN_SHIFT</span><span class="p">(</span><span class="n">level</span><span class="p">))</span> <span class="o">-</span>
		<span class="p">(</span><span class="n">base_gfn</span> <span class="o">&gt;&gt;</span> <span class="n">KVM_HPAGE_GFN_SHIFT</span><span class="p">(</span><span class="n">level</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">gfn_to_hva_memslot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">,</span>
					       <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">slot</span><span class="o">-&gt;</span><span class="n">userspace_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">gfn</span> <span class="o">-</span> <span class="n">slot</span><span class="o">-&gt;</span><span class="n">base_gfn</span><span class="p">)</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">gpa_t</span> <span class="nf">gfn_to_gpa</span><span class="p">(</span><span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">gpa_t</span><span class="p">)</span><span class="n">gfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">gfn_t</span> <span class="nf">gpa_to_gfn</span><span class="p">(</span><span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">gfn_t</span><span class="p">)(</span><span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">hpa_t</span> <span class="nf">pfn_to_hpa</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">hpa_t</span><span class="p">)</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_migrate_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">KVM_REQ_MIGRATE_TIMER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">kvm_stat_kind</span> <span class="p">{</span>
	<span class="n">KVM_STAT_VM</span><span class="p">,</span>
	<span class="n">KVM_STAT_VCPU</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_stats_debugfs_item</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">kvm_stat_kind</span> <span class="n">kind</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kvm_stats_debugfs_item</span> <span class="n">debugfs_entries</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">kvm_debugfs_dir</span><span class="p">;</span>

<span class="cp">#ifdef KVM_ARCH_WANT_MMU_NOTIFIER</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mmu_notifier_retry</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmu_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_notifier_count</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ensure the read of mmu_notifier_count happens before the read</span>
<span class="cm">	 * of mmu_notifier_seq.  This interacts with the smp_wmb() in</span>
<span class="cm">	 * mmu_notifier_invalidate_range_end to make sure that the caller</span>
<span class="cm">	 * either sees the old (non-zero) value of mmu_notifier_count or</span>
<span class="cm">	 * the new (incremented) value of mmu_notifier_seq.</span>
<span class="cm">	 * PowerPC Book3s HV KVM calls this under a per-page lock</span>
<span class="cm">	 * rather than under kvm-&gt;mmu_lock, for scalability, so</span>
<span class="cm">	 * can&#39;t rely on kvm-&gt;mmu_lock to keep things ordered.</span>
<span class="cm">	 */</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_notifier_seq</span> <span class="o">!=</span> <span class="n">mmu_seq</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HAVE_KVM_IRQCHIP</span>

<span class="cp">#define KVM_MAX_IRQ_ROUTES 1024</span>

<span class="kt">int</span> <span class="n">kvm_setup_default_irq_routing</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_set_irq_routing</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">kvm_irq_routing_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">nr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_free_irq_routing</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_send_userspace_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_msi</span> <span class="o">*</span><span class="n">msi</span><span class="p">);</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_free_irq_routing</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span> <span class="p">{}</span>

<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HAVE_KVM_EVENTFD</span>

<span class="kt">void</span> <span class="n">kvm_eventfd_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_irqfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gsi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_irqfd_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_irq_routing_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_irq_routing_table</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_ioeventfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_ioeventfd</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_eventfd_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kvm_irqfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gsi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_irqfd_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span> <span class="p">{}</span>

<span class="cp">#ifdef CONFIG_HAVE_KVM_IRQCHIP</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_irq_routing_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">kvm_irq_routing_table</span> <span class="o">*</span><span class="n">irq_rt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">irq_routing</span><span class="p">,</span> <span class="n">irq_rt</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kvm_ioeventfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_ioeventfd</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_HAVE_KVM_EVENTFD */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_KVM_APIC_ARCHITECTURE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">kvm_vcpu_is_bsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">bsp_vcpu_id</span> <span class="o">==</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">vcpu_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="n">kvm_vcpu_compatible</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">kvm_vcpu_compatible</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#endif</span>

<span class="cp">#ifdef __KVM_HAVE_DEVICE_ASSIGNMENT</span>

<span class="kt">long</span> <span class="n">kvm_vm_ioctl_assigned_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">ioctl</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">kvm_vm_ioctl_assigned_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">ioctl</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_make_request</span><span class="p">(</span><span class="kt">int</span> <span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">kvm_check_request</span><span class="p">(</span><span class="kt">int</span> <span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
