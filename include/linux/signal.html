<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › signal.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>signal.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_SIGNAL_H</span>
<span class="cp">#define _LINUX_SIGNAL_H</span>

<span class="cp">#include &lt;asm/signal.h&gt;</span>
<span class="cp">#include &lt;asm/siginfo.h&gt;</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>

<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>

<span class="cm">/* for sysctl */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">print_fatal_signals</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * Real Time signals may be queued.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sigqueue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">siginfo_t</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* flags values. */</span>
<span class="cp">#define SIGQUEUE_PREALLOC	1</span>

<span class="k">struct</span> <span class="n">sigpending</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">signal</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Define some primitives to manipulate sigset_t.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __HAVE_ARCH_SIG_BITOPS</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>

<span class="cm">/* We don&#39;t use &lt;linux/bitops.h&gt; for these because there is no need to</span>
<span class="cm">   be atomic.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sigaddset</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">_sig</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_NSIG_WORDS</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">sig</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">/</span> <span class="n">_NSIG_BPW</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">sig</span> <span class="o">%</span> <span class="n">_NSIG_BPW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sigdelset</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">_sig</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_NSIG_WORDS</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">sig</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">/</span> <span class="n">_NSIG_BPW</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">sig</span> <span class="o">%</span> <span class="n">_NSIG_BPW</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sigismember</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">_sig</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_NSIG_WORDS</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">sig</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">/</span> <span class="n">_NSIG_BPW</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">sig</span> <span class="o">%</span> <span class="n">_NSIG_BPW</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sigfindinword</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ffz</span><span class="p">(</span><span class="o">~</span><span class="n">word</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __HAVE_ARCH_SIG_BITOPS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sigisemptyset</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">_NSIG_WORDS_is_unsupported_size</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">_NSIG_WORDS</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|</span>
			<span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">return</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">_NSIG_WORDS_is_unsupported_size</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define sigmask(sig)	(1UL &lt;&lt; ((sig) - 1))</span>

<span class="cp">#ifndef __HAVE_ARCH_SIG_SETOPS</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>

<span class="cp">#define _SIG_SET_BINOP(name, op)					\</span>
<span class="cp">static inline void name(sigset_t *r, const sigset_t *a, const sigset_t *b) \</span>
<span class="cp">{									\</span>
<span class="cp">	extern void _NSIG_WORDS_is_unsupported_size(void);		\</span>
<span class="cp">	unsigned long a0, a1, a2, a3, b0, b1, b2, b3;			\</span>
<span class="cp">									\</span>
<span class="cp">	switch (_NSIG_WORDS) {						\</span>
<span class="cp">	    case 4:							\</span>
<span class="cp">		a3 = a-&gt;sig[3]; a2 = a-&gt;sig[2];				\</span>
<span class="cp">		b3 = b-&gt;sig[3]; b2 = b-&gt;sig[2];				\</span>
<span class="cp">		r-&gt;sig[3] = op(a3, b3);					\</span>
<span class="cp">		r-&gt;sig[2] = op(a2, b2);					\</span>
<span class="cp">	    case 2:							\</span>
<span class="cp">		a1 = a-&gt;sig[1]; b1 = b-&gt;sig[1];				\</span>
<span class="cp">		r-&gt;sig[1] = op(a1, b1);					\</span>
<span class="cp">	    case 1:							\</span>
<span class="cp">		a0 = a-&gt;sig[0]; b0 = b-&gt;sig[0];				\</span>
<span class="cp">		r-&gt;sig[0] = op(a0, b0);					\</span>
<span class="cp">		break;							\</span>
<span class="cp">	    default:							\</span>
<span class="cp">		_NSIG_WORDS_is_unsupported_size();			\</span>
<span class="cp">	}								\</span>
<span class="cp">}</span>

<span class="cp">#define _sig_or(x,y)	((x) | (y))</span>
<span class="n">_SIG_SET_BINOP</span><span class="p">(</span><span class="n">sigorsets</span><span class="p">,</span> <span class="n">_sig_or</span><span class="p">)</span>

<span class="cp">#define _sig_and(x,y)	((x) &amp; (y))</span>
<span class="n">_SIG_SET_BINOP</span><span class="p">(</span><span class="n">sigandsets</span><span class="p">,</span> <span class="n">_sig_and</span><span class="p">)</span>

<span class="cp">#define _sig_andn(x,y)	((x) &amp; ~(y))</span>
<span class="n">_SIG_SET_BINOP</span><span class="p">(</span><span class="n">sigandnsets</span><span class="p">,</span> <span class="n">_sig_andn</span><span class="p">)</span>

<span class="cp">#undef _SIG_SET_BINOP</span>
<span class="cp">#undef _sig_or</span>
<span class="cp">#undef _sig_and</span>
<span class="cp">#undef _sig_andn</span>

<span class="cp">#define _SIG_SET_OP(name, op)						\</span>
<span class="cp">static inline void name(sigset_t *set)					\</span>
<span class="cp">{									\</span>
<span class="cp">	extern void _NSIG_WORDS_is_unsupported_size(void);		\</span>
<span class="cp">									\</span>
<span class="cp">	switch (_NSIG_WORDS) {						\</span>
<span class="cp">	    case 4: set-&gt;sig[3] = op(set-&gt;sig[3]);			\</span>
<span class="cp">		    set-&gt;sig[2] = op(set-&gt;sig[2]);			\</span>
<span class="cp">	    case 2: set-&gt;sig[1] = op(set-&gt;sig[1]);			\</span>
<span class="cp">	    case 1: set-&gt;sig[0] = op(set-&gt;sig[0]);			\</span>
<span class="cp">		    break;						\</span>
<span class="cp">	    default:							\</span>
<span class="cp">		_NSIG_WORDS_is_unsupported_size();			\</span>
<span class="cp">	}								\</span>
<span class="cp">}</span>

<span class="cp">#define _sig_not(x)	(~(x))</span>
<span class="n">_SIG_SET_OP</span><span class="p">(</span><span class="n">signotset</span><span class="p">,</span> <span class="n">_sig_not</span><span class="p">)</span>

<span class="cp">#undef _SIG_SET_OP</span>
<span class="cp">#undef _sig_not</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">sigemptyset</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">_NSIG_WORDS</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sigset_t</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:	<span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">sigfillset</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">_NSIG_WORDS</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sigset_t</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:	<span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Some extensions for manipulating the low 32 signals in particular.  */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">sigaddsetmask</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">sigdelsetmask</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">sigtestsetmask</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">siginitset</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">_NSIG_WORDS</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">_NSIG_WORDS</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">siginitsetinv</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">_NSIG_WORDS</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">_NSIG_WORDS</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __HAVE_ARCH_SIG_SETOPS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">init_sigpending</span><span class="p">(</span><span class="k">struct</span> <span class="n">sigpending</span> <span class="o">*</span><span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">flush_sigqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sigpending</span> <span class="o">*</span><span class="n">queue</span><span class="p">);</span>

<span class="cm">/* Test if &#39;sig&#39; is valid signal. Use this instead of testing _NSIG directly */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">valid_signal</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sig</span> <span class="o">&lt;=</span> <span class="n">_NSIG</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">timespec</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pt_regs</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">next_signal</span><span class="p">(</span><span class="k">struct</span> <span class="n">sigpending</span> <span class="o">*</span><span class="n">pending</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_send_sig_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">bool</span> <span class="n">group</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">group_send_sig_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__group_send_sig_info</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">do_rt_tgsigqueueinfo</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">tgid</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">,</span>
				 <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">do_sigpending</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_sigtimedwait</span><span class="p">(</span><span class="k">const</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sigprocmask</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_current_blocked</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__set_current_blocked</span><span class="p">(</span><span class="k">const</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">show_unhandled_signals</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sigsuspend</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">get_signal_to_deliver</span><span class="p">(</span><span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="n">return_ka</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">signal_delivered</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="n">ka</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stepping</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">exit_signals</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">sighand_cachep</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">unhandled_signal</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * In POSIX a signal is sent either to a specific thread (Linux task)</span>
<span class="cm"> * or to the process as a whole (Linux thread group).  How the signal</span>
<span class="cm"> * is sent determines whether it&#39;s to one thread or the whole group,</span>
<span class="cm"> * which determines which signal mask(s) are involved in blocking it</span>
<span class="cm"> * from being delivered until later.  When the signal is delivered,</span>
<span class="cm"> * either it&#39;s caught or ignored by a user handler or it has a default</span>
<span class="cm"> * effect that applies to the whole thread group (POSIX process).</span>
<span class="cm"> *</span>
<span class="cm"> * The possible effects an unblocked signal set to SIG_DFL can have are:</span>
<span class="cm"> *   ignore	- Nothing Happens</span>
<span class="cm"> *   terminate	- kill the process, i.e. all threads in the group,</span>
<span class="cm"> * 		  similar to exit_group.  The group leader (only) reports</span>
<span class="cm"> *		  WIFSIGNALED status to its parent.</span>
<span class="cm"> *   coredump	- write a core dump file describing all threads using</span>
<span class="cm"> *		  the same mm and then kill all those threads</span>
<span class="cm"> *   stop 	- stop all the threads in the group, i.e. TASK_STOPPED state</span>
<span class="cm"> *</span>
<span class="cm"> * SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.</span>
<span class="cm"> * Other signals when not blocked and set to SIG_DFL behaves as follows.</span>
<span class="cm"> * The job control signals also have other special effects.</span>
<span class="cm"> *</span>
<span class="cm"> *	+--------------------+------------------+</span>
<span class="cm"> *	|  POSIX signal      |  default action  |</span>
<span class="cm"> *	+--------------------+------------------+</span>
<span class="cm"> *	|  SIGHUP            |  terminate	|</span>
<span class="cm"> *	|  SIGINT            |	terminate	|</span>
<span class="cm"> *	|  SIGQUIT           |	coredump 	|</span>
<span class="cm"> *	|  SIGILL            |	coredump 	|</span>
<span class="cm"> *	|  SIGTRAP           |	coredump 	|</span>
<span class="cm"> *	|  SIGABRT/SIGIOT    |	coredump 	|</span>
<span class="cm"> *	|  SIGBUS            |	coredump 	|</span>
<span class="cm"> *	|  SIGFPE            |	coredump 	|</span>
<span class="cm"> *	|  SIGKILL           |	terminate(+)	|</span>
<span class="cm"> *	|  SIGUSR1           |	terminate	|</span>
<span class="cm"> *	|  SIGSEGV           |	coredump 	|</span>
<span class="cm"> *	|  SIGUSR2           |	terminate	|</span>
<span class="cm"> *	|  SIGPIPE           |	terminate	|</span>
<span class="cm"> *	|  SIGALRM           |	terminate	|</span>
<span class="cm"> *	|  SIGTERM           |	terminate	|</span>
<span class="cm"> *	|  SIGCHLD           |	ignore   	|</span>
<span class="cm"> *	|  SIGCONT           |	ignore(*)	|</span>
<span class="cm"> *	|  SIGSTOP           |	stop(*)(+)  	|</span>
<span class="cm"> *	|  SIGTSTP           |	stop(*)  	|</span>
<span class="cm"> *	|  SIGTTIN           |	stop(*)  	|</span>
<span class="cm"> *	|  SIGTTOU           |	stop(*)  	|</span>
<span class="cm"> *	|  SIGURG            |	ignore   	|</span>
<span class="cm"> *	|  SIGXCPU           |	coredump 	|</span>
<span class="cm"> *	|  SIGXFSZ           |	coredump 	|</span>
<span class="cm"> *	|  SIGVTALRM         |	terminate	|</span>
<span class="cm"> *	|  SIGPROF           |	terminate	|</span>
<span class="cm"> *	|  SIGPOLL/SIGIO     |	terminate	|</span>
<span class="cm"> *	|  SIGSYS/SIGUNUSED  |	coredump 	|</span>
<span class="cm"> *	|  SIGSTKFLT         |	terminate	|</span>
<span class="cm"> *	|  SIGWINCH          |	ignore   	|</span>
<span class="cm"> *	|  SIGPWR            |	terminate	|</span>
<span class="cm"> *	|  SIGRTMIN-SIGRTMAX |	terminate       |</span>
<span class="cm"> *	+--------------------+------------------+</span>
<span class="cm"> *	|  non-POSIX signal  |  default action  |</span>
<span class="cm"> *	+--------------------+------------------+</span>
<span class="cm"> *	|  SIGEMT            |  coredump	|</span>
<span class="cm"> *	+--------------------+------------------+</span>
<span class="cm"> *</span>
<span class="cm"> * (+) For SIGKILL and SIGSTOP the action is &quot;always&quot;, not just &quot;default&quot;.</span>
<span class="cm"> * (*) Special job control effects:</span>
<span class="cm"> * When SIGCONT is sent, it resumes the process (all threads in the group)</span>
<span class="cm"> * from TASK_STOPPED state and also clears any pending/queued stop signals</span>
<span class="cm"> * (any of those marked with &quot;stop(*)&quot;).  This happens regardless of blocking,</span>
<span class="cm"> * catching, or ignoring SIGCONT.  When any stop signal is sent, it clears</span>
<span class="cm"> * any pending/queued SIGCONT signals; this happens regardless of blocking,</span>
<span class="cm"> * catching, or ignored the stop signal, though (except for SIGSTOP) the</span>
<span class="cm"> * default action of stopping the process may happen later or never.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef SIGEMT</span>
<span class="cp">#define SIGEMT_MASK	rt_sigmask(SIGEMT)</span>
<span class="cp">#else</span>
<span class="cp">#define SIGEMT_MASK	0</span>
<span class="cp">#endif</span>

<span class="cp">#if SIGRTMIN &gt; BITS_PER_LONG</span>
<span class="cp">#define rt_sigmask(sig)	(1ULL &lt;&lt; ((sig)-1))</span>
<span class="cp">#else</span>
<span class="cp">#define rt_sigmask(sig)	sigmask(sig)</span>
<span class="cp">#endif</span>
<span class="cp">#define siginmask(sig, mask) (rt_sigmask(sig) &amp; (mask))</span>

<span class="cp">#define SIG_KERNEL_ONLY_MASK (\</span>
<span class="cp">	rt_sigmask(SIGKILL)   |  rt_sigmask(SIGSTOP))</span>

<span class="cp">#define SIG_KERNEL_STOP_MASK (\</span>
<span class="cp">	rt_sigmask(SIGSTOP)   |  rt_sigmask(SIGTSTP)   | \</span>
<span class="cp">	rt_sigmask(SIGTTIN)   |  rt_sigmask(SIGTTOU)   )</span>

<span class="cp">#define SIG_KERNEL_COREDUMP_MASK (\</span>
<span class="cp">        rt_sigmask(SIGQUIT)   |  rt_sigmask(SIGILL)    | \</span>
<span class="cp">	rt_sigmask(SIGTRAP)   |  rt_sigmask(SIGABRT)   | \</span>
<span class="cp">        rt_sigmask(SIGFPE)    |  rt_sigmask(SIGSEGV)   | \</span>
<span class="cp">	rt_sigmask(SIGBUS)    |  rt_sigmask(SIGSYS)    | \</span>
<span class="cp">        rt_sigmask(SIGXCPU)   |  rt_sigmask(SIGXFSZ)   | \</span>
<span class="cp">	SIGEMT_MASK				       )</span>

<span class="cp">#define SIG_KERNEL_IGNORE_MASK (\</span>
<span class="cp">        rt_sigmask(SIGCONT)   |  rt_sigmask(SIGCHLD)   | \</span>
<span class="cp">	rt_sigmask(SIGWINCH)  |  rt_sigmask(SIGURG)    )</span>

<span class="cp">#define sig_kernel_only(sig) \</span>
<span class="cp">	(((sig) &lt; SIGRTMIN) &amp;&amp; siginmask(sig, SIG_KERNEL_ONLY_MASK))</span>
<span class="cp">#define sig_kernel_coredump(sig) \</span>
<span class="cp">	(((sig) &lt; SIGRTMIN) &amp;&amp; siginmask(sig, SIG_KERNEL_COREDUMP_MASK))</span>
<span class="cp">#define sig_kernel_ignore(sig) \</span>
<span class="cp">	(((sig) &lt; SIGRTMIN) &amp;&amp; siginmask(sig, SIG_KERNEL_IGNORE_MASK))</span>
<span class="cp">#define sig_kernel_stop(sig) \</span>
<span class="cp">	(((sig) &lt; SIGRTMIN) &amp;&amp; siginmask(sig, SIG_KERNEL_STOP_MASK))</span>

<span class="cp">#define sig_user_defined(t, signr) \</span>
<span class="cp">	(((t)-&gt;sighand-&gt;action[(signr)-1].sa.sa_handler != SIG_DFL) &amp;&amp;	\</span>
<span class="cp">	 ((t)-&gt;sighand-&gt;action[(signr)-1].sa.sa_handler != SIG_IGN))</span>

<span class="cp">#define sig_fatal(t, signr) \</span>
<span class="cp">	(!siginmask(signr, SIG_KERNEL_IGNORE_MASK|SIG_KERNEL_STOP_MASK) &amp;&amp; \</span>
<span class="cp">	 (t)-&gt;sighand-&gt;action[(signr)-1].sa.sa_handler == SIG_DFL)</span>

<span class="kt">void</span> <span class="n">signals_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_SIGNAL_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
