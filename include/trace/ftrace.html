<!DOCTYPE html>
<html><head><title>joekychen/linux » include › trace › ftrace.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ftrace.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Stage 1 of the trace events.</span>
<span class="cm"> *</span>
<span class="cm"> * Override the macros in &lt;trace/trace_events.h&gt; to include the following:</span>
<span class="cm"> *</span>
<span class="cm"> * struct ftrace_raw_&lt;call&gt; {</span>
<span class="cm"> *	struct trace_entry		ent;</span>
<span class="cm"> *	&lt;type&gt;				&lt;item&gt;;</span>
<span class="cm"> *	&lt;type2&gt;				&lt;item2&gt;[&lt;len&gt;];</span>
<span class="cm"> *	[...]</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> * The &lt;type&gt; &lt;item&gt; is created by the __field(type, item) macro or</span>
<span class="cm"> * the __array(type2, item2, len) macro.</span>
<span class="cm"> * We simply do &quot;type item;&quot;, and that will create the fields</span>
<span class="cm"> * in the structure.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/ftrace_event.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * DECLARE_EVENT_CLASS can be used to add a generic function</span>
<span class="cm"> * handlers for events. That is, if all events have the same</span>
<span class="cm"> * parameters and just have distinct trace points.</span>
<span class="cm"> * Each tracepoint can be defined with DEFINE_EVENT and that</span>
<span class="cm"> * will map the DECLARE_EVENT_CLASS to the tracepoint.</span>
<span class="cm"> *</span>
<span class="cm"> * TRACE_EVENT is a one to one mapping between tracepoint and template.</span>
<span class="cm"> */</span>
<span class="cp">#undef TRACE_EVENT</span>
<span class="cp">#define TRACE_EVENT(name, proto, args, tstruct, assign, print) \</span>
<span class="cp">	DECLARE_EVENT_CLASS(name,			       \</span>
<span class="cp">			     PARAMS(proto),		       \</span>
<span class="cp">			     PARAMS(args),		       \</span>
<span class="cp">			     PARAMS(tstruct),		       \</span>
<span class="cp">			     PARAMS(assign),		       \</span>
<span class="cp">			     PARAMS(print));		       \</span>
<span class="cp">	DEFINE_EVENT(name, name, PARAMS(proto), PARAMS(args));</span>


<span class="cp">#undef __field</span>
<span class="cp">#define __field(type, item)		type	item;</span>

<span class="cp">#undef __field_ext</span>
<span class="cp">#define __field_ext(type, item, filter_type)	type	item;</span>

<span class="cp">#undef __array</span>
<span class="cp">#define __array(type, item, len)	type	item[len];</span>

<span class="cp">#undef __dynamic_array</span>
<span class="cp">#define __dynamic_array(type, item, len) u32 __data_loc_##item;</span>

<span class="cp">#undef __string</span>
<span class="cp">#define __string(item, src) __dynamic_array(char, item, -1)</span>

<span class="cp">#undef TP_STRUCT__entry</span>
<span class="cp">#define TP_STRUCT__entry(args...) args</span>

<span class="cp">#undef DECLARE_EVENT_CLASS</span>
<span class="cp">#define DECLARE_EVENT_CLASS(name, proto, args, tstruct, assign, print)	\</span>
<span class="cp">	struct ftrace_raw_##name {					\</span>
<span class="cp">		struct trace_entry	ent;				\</span>
<span class="cp">		tstruct							\</span>
<span class="cp">		char			__data[0];			\</span>
<span class="cp">	};								\</span>
<span class="cp">									\</span>
<span class="cp">	static struct ftrace_event_class event_class_##name;</span>

<span class="cp">#undef DEFINE_EVENT</span>
<span class="cp">#define DEFINE_EVENT(template, name, proto, args)	\</span>
<span class="cp">	static struct ftrace_event_call	__used		\</span>
<span class="cp">	__attribute__((__aligned__(4))) event_##name</span>

<span class="cp">#undef DEFINE_EVENT_PRINT</span>
<span class="cp">#define DEFINE_EVENT_PRINT(template, name, proto, args, print)	\</span>
<span class="cp">	DEFINE_EVENT(template, name, PARAMS(proto), PARAMS(args))</span>

<span class="cm">/* Callbacks are meaningless to ftrace. */</span>
<span class="cp">#undef TRACE_EVENT_FN</span>
<span class="cp">#define TRACE_EVENT_FN(name, proto, args, tstruct,			\</span>
<span class="cp">		assign, print, reg, unreg)				\</span>
<span class="cp">	TRACE_EVENT(name, PARAMS(proto), PARAMS(args),			\</span>
<span class="cp">		PARAMS(tstruct), PARAMS(assign), PARAMS(print))		\</span>

<span class="cp">#undef TRACE_EVENT_FLAGS</span>
<span class="cp">#define TRACE_EVENT_FLAGS(name, value)					\</span>
<span class="cp">	__TRACE_EVENT_FLAGS(name, value)</span>

<span class="cp">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span>


<span class="cm">/*</span>
<span class="cm"> * Stage 2 of the trace events.</span>
<span class="cm"> *</span>
<span class="cm"> * Include the following:</span>
<span class="cm"> *</span>
<span class="cm"> * struct ftrace_data_offsets_&lt;call&gt; {</span>
<span class="cm"> *	u32				&lt;item1&gt;;</span>
<span class="cm"> *	u32				&lt;item2&gt;;</span>
<span class="cm"> *	[...]</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> * The __dynamic_array() macro will create each u32 &lt;item&gt;, this is</span>
<span class="cm"> * to keep the offset of each array from the beginning of the event.</span>
<span class="cm"> * The size of an array is also encoded, in the higher 16 bits of &lt;item&gt;.</span>
<span class="cm"> */</span>

<span class="cp">#undef __field</span>
<span class="cp">#define __field(type, item)</span>

<span class="cp">#undef __field_ext</span>
<span class="cp">#define __field_ext(type, item, filter_type)</span>

<span class="cp">#undef __array</span>
<span class="cp">#define __array(type, item, len)</span>

<span class="cp">#undef __dynamic_array</span>
<span class="cp">#define __dynamic_array(type, item, len)	u32 item;</span>

<span class="cp">#undef __string</span>
<span class="cp">#define __string(item, src) __dynamic_array(char, item, -1)</span>

<span class="cp">#undef DECLARE_EVENT_CLASS</span>
<span class="cp">#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)	\</span>
<span class="cp">	struct ftrace_data_offsets_##call {				\</span>
<span class="cp">		tstruct;						\</span>
<span class="cp">	};</span>

<span class="cp">#undef DEFINE_EVENT</span>
<span class="cp">#define DEFINE_EVENT(template, name, proto, args)</span>

<span class="cp">#undef DEFINE_EVENT_PRINT</span>
<span class="cp">#define DEFINE_EVENT_PRINT(template, name, proto, args, print)	\</span>
<span class="cp">	DEFINE_EVENT(template, name, PARAMS(proto), PARAMS(args))</span>

<span class="cp">#undef TRACE_EVENT_FLAGS</span>
<span class="cp">#define TRACE_EVENT_FLAGS(event, flag)</span>

<span class="cp">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span>

<span class="cm">/*</span>
<span class="cm"> * Stage 3 of the trace events.</span>
<span class="cm"> *</span>
<span class="cm"> * Override the macros in &lt;trace/trace_events.h&gt; to include the following:</span>
<span class="cm"> *</span>
<span class="cm"> * enum print_line_t</span>
<span class="cm"> * ftrace_raw_output_&lt;call&gt;(struct trace_iterator *iter, int flags)</span>
<span class="cm"> * {</span>
<span class="cm"> *	struct trace_seq *s = &amp;iter-&gt;seq;</span>
<span class="cm"> *	struct ftrace_raw_&lt;call&gt; *field; &lt;-- defined in stage 1</span>
<span class="cm"> *	struct trace_entry *entry;</span>
<span class="cm"> *	struct trace_seq *p = &amp;iter-&gt;tmp_seq;</span>
<span class="cm"> *	int ret;</span>
<span class="cm"> *</span>
<span class="cm"> *	entry = iter-&gt;ent;</span>
<span class="cm"> *</span>
<span class="cm"> *	if (entry-&gt;type != event_&lt;call&gt;-&gt;event.type) {</span>
<span class="cm"> *		WARN_ON_ONCE(1);</span>
<span class="cm"> *		return TRACE_TYPE_UNHANDLED;</span>
<span class="cm"> *	}</span>
<span class="cm"> *</span>
<span class="cm"> *	field = (typeof(field))entry;</span>
<span class="cm"> *</span>
<span class="cm"> *	trace_seq_init(p);</span>
<span class="cm"> *	ret = trace_seq_printf(s, &quot;%s: &quot;, &lt;call&gt;);</span>
<span class="cm"> *	if (ret)</span>
<span class="cm"> *		ret = trace_seq_printf(s, &lt;TP_printk&gt; &quot;\n&quot;);</span>
<span class="cm"> *	if (!ret)</span>
<span class="cm"> *		return TRACE_TYPE_PARTIAL_LINE;</span>
<span class="cm"> *</span>
<span class="cm"> *	return TRACE_TYPE_HANDLED;</span>
<span class="cm"> * }</span>
<span class="cm"> *</span>
<span class="cm"> * This is the method used to print the raw event to the trace</span>
<span class="cm"> * output format. Note, this is not needed if the data is read</span>
<span class="cm"> * in binary.</span>
<span class="cm"> */</span>

<span class="cp">#undef __entry</span>
<span class="cp">#define __entry field</span>

<span class="cp">#undef TP_printk</span>
<span class="cp">#define TP_printk(fmt, args...) fmt &quot;\n&quot;, args</span>

<span class="cp">#undef __get_dynamic_array</span>
<span class="cp">#define __get_dynamic_array(field)	\</span>
<span class="cp">		((void *)__entry + (__entry-&gt;__data_loc_##field &amp; 0xffff))</span>

<span class="cp">#undef __get_str</span>
<span class="cp">#define __get_str(field) (char *)__get_dynamic_array(field)</span>

<span class="cp">#undef __print_flags</span>
<span class="cp">#define __print_flags(flag, delim, flag_array...)			\</span>
<span class="cp">	({								\</span>
<span class="cp">		static const struct trace_print_flags __flags[] =	\</span>
<span class="cp">			{ flag_array, { -1, NULL }};			\</span>
<span class="cp">		ftrace_print_flags_seq(p, delim, flag, __flags);	\</span>
<span class="cp">	})</span>

<span class="cp">#undef __print_symbolic</span>
<span class="cp">#define __print_symbolic(value, symbol_array...)			\</span>
<span class="cp">	({								\</span>
<span class="cp">		static const struct trace_print_flags symbols[] =	\</span>
<span class="cp">			{ symbol_array, { -1, NULL }};			\</span>
<span class="cp">		ftrace_print_symbols_seq(p, value, symbols);		\</span>
<span class="cp">	})</span>

<span class="cp">#undef __print_symbolic_u64</span>
<span class="cp">#if BITS_PER_LONG == 32</span>
<span class="cp">#define __print_symbolic_u64(value, symbol_array...)			\</span>
<span class="cp">	({								\</span>
<span class="cp">		static const struct trace_print_flags_u64 symbols[] =	\</span>
<span class="cp">			{ symbol_array, { -1, NULL } };			\</span>
<span class="cp">		ftrace_print_symbols_seq_u64(p, value, symbols);	\</span>
<span class="cp">	})</span>
<span class="cp">#else</span>
<span class="cp">#define __print_symbolic_u64(value, symbol_array...)			\</span>
<span class="cp">			__print_symbolic(value, symbol_array)</span>
<span class="cp">#endif</span>

<span class="cp">#undef __print_hex</span>
<span class="cp">#define __print_hex(buf, buf_len) ftrace_print_hex_seq(p, buf, buf_len)</span>

<span class="cp">#undef DECLARE_EVENT_CLASS</span>
<span class="cp">#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)	\</span>
<span class="cp">static notrace enum print_line_t					\</span>
<span class="cp">ftrace_raw_output_##call(struct trace_iterator *iter, int flags,	\</span>
<span class="cp">			 struct trace_event *trace_event)		\</span>
<span class="cp">{									\</span>
<span class="cp">	struct ftrace_event_call *event;				\</span>
<span class="cp">	struct trace_seq *s = &amp;iter-&gt;seq;				\</span>
<span class="cp">	struct ftrace_raw_##call *field;				\</span>
<span class="cp">	struct trace_entry *entry;					\</span>
<span class="cp">	struct trace_seq *p = &amp;iter-&gt;tmp_seq;				\</span>
<span class="cp">	int ret;							\</span>
<span class="cp">									\</span>
<span class="cp">	event = container_of(trace_event, struct ftrace_event_call,	\</span>
<span class="cp">			     event);					\</span>
<span class="cp">									\</span>
<span class="cp">	entry = iter-&gt;ent;						\</span>
<span class="cp">									\</span>
<span class="cp">	if (entry-&gt;type != event-&gt;event.type) {				\</span>
<span class="cp">		WARN_ON_ONCE(1);					\</span>
<span class="cp">		return TRACE_TYPE_UNHANDLED;				\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	field = (typeof(field))entry;					\</span>
<span class="cp">									\</span>
<span class="cp">	trace_seq_init(p);						\</span>
<span class="cp">	ret = trace_seq_printf(s, &quot;%s: &quot;, event-&gt;name);			\</span>
<span class="cp">	if (ret)							\</span>
<span class="cp">		ret = trace_seq_printf(s, print);			\</span>
<span class="cp">	if (!ret)							\</span>
<span class="cp">		return TRACE_TYPE_PARTIAL_LINE;				\</span>
<span class="cp">									\</span>
<span class="cp">	return TRACE_TYPE_HANDLED;					\</span>
<span class="cp">}									\</span>
<span class="cp">static struct trace_event_functions ftrace_event_type_funcs_##call = {	\</span>
<span class="cp">	.trace			= ftrace_raw_output_##call,		\</span>
<span class="cp">};</span>

<span class="cp">#undef DEFINE_EVENT_PRINT</span>
<span class="cp">#define DEFINE_EVENT_PRINT(template, call, proto, args, print)		\</span>
<span class="cp">static notrace enum print_line_t					\</span>
<span class="cp">ftrace_raw_output_##call(struct trace_iterator *iter, int flags,	\</span>
<span class="cp">			 struct trace_event *event)			\</span>
<span class="cp">{									\</span>
<span class="cp">	struct trace_seq *s = &amp;iter-&gt;seq;				\</span>
<span class="cp">	struct ftrace_raw_##template *field;				\</span>
<span class="cp">	struct trace_entry *entry;					\</span>
<span class="cp">	struct trace_seq *p = &amp;iter-&gt;tmp_seq;				\</span>
<span class="cp">	int ret;							\</span>
<span class="cp">									\</span>
<span class="cp">	entry = iter-&gt;ent;						\</span>
<span class="cp">									\</span>
<span class="cp">	if (entry-&gt;type != event_##call.event.type) {			\</span>
<span class="cp">		WARN_ON_ONCE(1);					\</span>
<span class="cp">		return TRACE_TYPE_UNHANDLED;				\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	field = (typeof(field))entry;					\</span>
<span class="cp">									\</span>
<span class="cp">	trace_seq_init(p);						\</span>
<span class="cp">	ret = trace_seq_printf(s, &quot;%s: &quot;, #call);			\</span>
<span class="cp">	if (ret)							\</span>
<span class="cp">		ret = trace_seq_printf(s, print);			\</span>
<span class="cp">	if (!ret)							\</span>
<span class="cp">		return TRACE_TYPE_PARTIAL_LINE;				\</span>
<span class="cp">									\</span>
<span class="cp">	return TRACE_TYPE_HANDLED;					\</span>
<span class="cp">}									\</span>
<span class="cp">static struct trace_event_functions ftrace_event_type_funcs_##call = {	\</span>
<span class="cp">	.trace			= ftrace_raw_output_##call,		\</span>
<span class="cp">};</span>

<span class="cp">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span>

<span class="cp">#undef __field_ext</span>
<span class="cp">#define __field_ext(type, item, filter_type)				\</span>
<span class="cp">	ret = trace_define_field(event_call, #type, #item,		\</span>
<span class="cp">				 offsetof(typeof(field), item),		\</span>
<span class="cp">				 sizeof(field.item),			\</span>
<span class="cp">				 is_signed_type(type), filter_type);	\</span>
<span class="cp">	if (ret)							\</span>
<span class="cp">		return ret;</span>

<span class="cp">#undef __field</span>
<span class="cp">#define __field(type, item)	__field_ext(type, item, FILTER_OTHER)</span>

<span class="cp">#undef __array</span>
<span class="cp">#define __array(type, item, len)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		mutex_lock(&amp;event_storage_mutex);			\</span>
<span class="cp">		BUILD_BUG_ON(len &gt; MAX_FILTER_STR_VAL);			\</span>
<span class="cp">		snprintf(event_storage, sizeof(event_storage),		\</span>
<span class="cp">			 &quot;%s[%d]&quot;, #type, len);				\</span>
<span class="cp">		ret = trace_define_field(event_call, event_storage, #item, \</span>
<span class="cp">				 offsetof(typeof(field), item),		\</span>
<span class="cp">				 sizeof(field.item),			\</span>
<span class="cp">				 is_signed_type(type), FILTER_OTHER);	\</span>
<span class="cp">		mutex_unlock(&amp;event_storage_mutex);			\</span>
<span class="cp">		if (ret)						\</span>
<span class="cp">			return ret;					\</span>
<span class="cp">	} while (0);</span>

<span class="cp">#undef __dynamic_array</span>
<span class="cp">#define __dynamic_array(type, item, len)				       \</span>
<span class="cp">	ret = trace_define_field(event_call, &quot;__data_loc &quot; #type &quot;[]&quot;, #item,  \</span>
<span class="cp">				 offsetof(typeof(field), __data_loc_##item),   \</span>
<span class="cp">				 sizeof(field.__data_loc_##item),	       \</span>
<span class="cp">				 is_signed_type(type), FILTER_OTHER);</span>

<span class="cp">#undef __string</span>
<span class="cp">#define __string(item, src) __dynamic_array(char, item, -1)</span>

<span class="cp">#undef DECLARE_EVENT_CLASS</span>
<span class="cp">#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, func, print)	\</span>
<span class="cp">static int notrace							\</span>
<span class="cp">ftrace_define_fields_##call(struct ftrace_event_call *event_call)	\</span>
<span class="cp">{									\</span>
<span class="cp">	struct ftrace_raw_##call field;					\</span>
<span class="cp">	int ret;							\</span>
<span class="cp">									\</span>
<span class="cp">	tstruct;							\</span>
<span class="cp">									\</span>
<span class="cp">	return ret;							\</span>
<span class="cp">}</span>

<span class="cp">#undef DEFINE_EVENT</span>
<span class="cp">#define DEFINE_EVENT(template, name, proto, args)</span>

<span class="cp">#undef DEFINE_EVENT_PRINT</span>
<span class="cp">#define DEFINE_EVENT_PRINT(template, name, proto, args, print)	\</span>
<span class="cp">	DEFINE_EVENT(template, name, PARAMS(proto), PARAMS(args))</span>

<span class="cp">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span>

<span class="cm">/*</span>
<span class="cm"> * remember the offset of each array from the beginning of the event.</span>
<span class="cm"> */</span>

<span class="cp">#undef __entry</span>
<span class="cp">#define __entry entry</span>

<span class="cp">#undef __field</span>
<span class="cp">#define __field(type, item)</span>

<span class="cp">#undef __field_ext</span>
<span class="cp">#define __field_ext(type, item, filter_type)</span>

<span class="cp">#undef __array</span>
<span class="cp">#define __array(type, item, len)</span>

<span class="cp">#undef __dynamic_array</span>
<span class="cp">#define __dynamic_array(type, item, len)				\</span>
<span class="cp">	__data_offsets-&gt;item = __data_size +				\</span>
<span class="cp">			       offsetof(typeof(*entry), __data);	\</span>
<span class="cp">	__data_offsets-&gt;item |= (len * sizeof(type)) &lt;&lt; 16;		\</span>
<span class="cp">	__data_size += (len) * sizeof(type);</span>

<span class="cp">#undef __string</span>
<span class="cp">#define __string(item, src) __dynamic_array(char, item, strlen(src) + 1)</span>

<span class="cp">#undef DECLARE_EVENT_CLASS</span>
<span class="cp">#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)	\</span>
<span class="cp">static inline notrace int ftrace_get_offsets_##call(			\</span>
<span class="cp">	struct ftrace_data_offsets_##call *__data_offsets, proto)       \</span>
<span class="cp">{									\</span>
<span class="cp">	int __data_size = 0;						\</span>
<span class="cp">	struct ftrace_raw_##call __maybe_unused *entry;			\</span>
<span class="cp">									\</span>
<span class="cp">	tstruct;							\</span>
<span class="cp">									\</span>
<span class="cp">	return __data_size;						\</span>
<span class="cp">}</span>

<span class="cp">#undef DEFINE_EVENT</span>
<span class="cp">#define DEFINE_EVENT(template, name, proto, args)</span>

<span class="cp">#undef DEFINE_EVENT_PRINT</span>
<span class="cp">#define DEFINE_EVENT_PRINT(template, name, proto, args, print)	\</span>
<span class="cp">	DEFINE_EVENT(template, name, PARAMS(proto), PARAMS(args))</span>

<span class="cp">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span>

<span class="cm">/*</span>
<span class="cm"> * Stage 4 of the trace events.</span>
<span class="cm"> *</span>
<span class="cm"> * Override the macros in &lt;trace/trace_events.h&gt; to include the following:</span>
<span class="cm"> *</span>
<span class="cm"> * For those macros defined with TRACE_EVENT:</span>
<span class="cm"> *</span>
<span class="cm"> * static struct ftrace_event_call event_&lt;call&gt;;</span>
<span class="cm"> *</span>
<span class="cm"> * static void ftrace_raw_event_&lt;call&gt;(void *__data, proto)</span>
<span class="cm"> * {</span>
<span class="cm"> *	struct ftrace_event_call *event_call = __data;</span>
<span class="cm"> *	struct ftrace_data_offsets_&lt;call&gt; __maybe_unused __data_offsets;</span>
<span class="cm"> *	struct ring_buffer_event *event;</span>
<span class="cm"> *	struct ftrace_raw_&lt;call&gt; *entry; &lt;-- defined in stage 1</span>
<span class="cm"> *	struct ring_buffer *buffer;</span>
<span class="cm"> *	unsigned long irq_flags;</span>
<span class="cm"> *	int __data_size;</span>
<span class="cm"> *	int pc;</span>
<span class="cm"> *</span>
<span class="cm"> *	local_save_flags(irq_flags);</span>
<span class="cm"> *	pc = preempt_count();</span>
<span class="cm"> *</span>
<span class="cm"> *	__data_size = ftrace_get_offsets_&lt;call&gt;(&amp;__data_offsets, args);</span>
<span class="cm"> *</span>
<span class="cm"> *	event = trace_current_buffer_lock_reserve(&amp;buffer,</span>
<span class="cm"> *				  event_&lt;call&gt;-&gt;event.type,</span>
<span class="cm"> *				  sizeof(*entry) + __data_size,</span>
<span class="cm"> *				  irq_flags, pc);</span>
<span class="cm"> *	if (!event)</span>
<span class="cm"> *		return;</span>
<span class="cm"> *	entry	= ring_buffer_event_data(event);</span>
<span class="cm"> *</span>
<span class="cm"> *	{ &lt;assign&gt;; }  &lt;-- Here we assign the entries by the __field and</span>
<span class="cm"> *			   __array macros.</span>
<span class="cm"> *</span>
<span class="cm"> *	if (!filter_current_check_discard(buffer, event_call, entry, event))</span>
<span class="cm"> *		trace_current_buffer_unlock_commit(buffer,</span>
<span class="cm"> *						   event, irq_flags, pc);</span>
<span class="cm"> * }</span>
<span class="cm"> *</span>
<span class="cm"> * static struct trace_event ftrace_event_type_&lt;call&gt; = {</span>
<span class="cm"> *	.trace			= ftrace_raw_output_&lt;call&gt;, &lt;-- stage 2</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> * static const char print_fmt_&lt;call&gt;[] = &lt;TP_printk&gt;;</span>
<span class="cm"> *</span>
<span class="cm"> * static struct ftrace_event_class __used event_class_&lt;template&gt; = {</span>
<span class="cm"> *	.system			= &quot;&lt;system&gt;&quot;,</span>
<span class="cm"> *	.define_fields		= ftrace_define_fields_&lt;call&gt;,</span>
<span class="cm"> *	.fields			= LIST_HEAD_INIT(event_class_##call.fields),</span>
<span class="cm"> *	.raw_init		= trace_event_raw_init,</span>
<span class="cm"> *	.probe			= ftrace_raw_event_##call,</span>
<span class="cm"> *	.reg			= ftrace_event_reg,</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> * static struct ftrace_event_call event_&lt;call&gt; = {</span>
<span class="cm"> *	.name			= &quot;&lt;call&gt;&quot;,</span>
<span class="cm"> *	.class			= event_class_&lt;template&gt;,</span>
<span class="cm"> *	.event			= &amp;ftrace_event_type_&lt;call&gt;,</span>
<span class="cm"> *	.print_fmt		= print_fmt_&lt;call&gt;,</span>
<span class="cm"> * };</span>
<span class="cm"> * // its only safe to use pointers when doing linker tricks to</span>
<span class="cm"> * // create an array.</span>
<span class="cm"> * static struct ftrace_event_call __used</span>
<span class="cm"> * __attribute__((section(&quot;_ftrace_events&quot;))) *__event_&lt;call&gt; = &amp;event_&lt;call&gt;;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_PERF_EVENTS</span>

<span class="cp">#define _TRACE_PERF_PROTO(call, proto)					\</span>
<span class="cp">	static notrace void						\</span>
<span class="cp">	perf_trace_##call(void *__data, proto);</span>

<span class="cp">#define _TRACE_PERF_INIT(call)						\</span>
<span class="cp">	.perf_probe		= perf_trace_##call,</span>

<span class="cp">#else</span>
<span class="cp">#define _TRACE_PERF_PROTO(call, proto)</span>
<span class="cp">#define _TRACE_PERF_INIT(call)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PERF_EVENTS */</span><span class="cp"></span>

<span class="cp">#undef __entry</span>
<span class="cp">#define __entry entry</span>

<span class="cp">#undef __field</span>
<span class="cp">#define __field(type, item)</span>

<span class="cp">#undef __array</span>
<span class="cp">#define __array(type, item, len)</span>

<span class="cp">#undef __dynamic_array</span>
<span class="cp">#define __dynamic_array(type, item, len)				\</span>
<span class="cp">	__entry-&gt;__data_loc_##item = __data_offsets.item;</span>

<span class="cp">#undef __string</span>
<span class="cp">#define __string(item, src) __dynamic_array(char, item, -1)       	\</span>

<span class="cp">#undef __assign_str</span>
<span class="cp">#define __assign_str(dst, src)						\</span>
<span class="cp">	strcpy(__get_str(dst), src);</span>

<span class="cp">#undef TP_fast_assign</span>
<span class="cp">#define TP_fast_assign(args...) args</span>

<span class="cp">#undef TP_perf_assign</span>
<span class="cp">#define TP_perf_assign(args...)</span>

<span class="cp">#undef DECLARE_EVENT_CLASS</span>
<span class="cp">#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)	\</span>
<span class="cp">									\</span>
<span class="cp">static notrace void							\</span>
<span class="cp">ftrace_raw_event_##call(void *__data, proto)				\</span>
<span class="cp">{									\</span>
<span class="cp">	struct ftrace_event_call *event_call = __data;			\</span>
<span class="cp">	struct ftrace_data_offsets_##call __maybe_unused __data_offsets;\</span>
<span class="cp">	struct ring_buffer_event *event;				\</span>
<span class="cp">	struct ftrace_raw_##call *entry;				\</span>
<span class="cp">	struct ring_buffer *buffer;					\</span>
<span class="cp">	unsigned long irq_flags;					\</span>
<span class="cp">	int __data_size;						\</span>
<span class="cp">	int pc;								\</span>
<span class="cp">									\</span>
<span class="cp">	local_save_flags(irq_flags);					\</span>
<span class="cp">	pc = preempt_count();						\</span>
<span class="cp">									\</span>
<span class="cp">	__data_size = ftrace_get_offsets_##call(&amp;__data_offsets, args); \</span>
<span class="cp">									\</span>
<span class="cp">	event = trace_current_buffer_lock_reserve(&amp;buffer,		\</span>
<span class="cp">				 event_call-&gt;event.type,		\</span>
<span class="cp">				 sizeof(*entry) + __data_size,		\</span>
<span class="cp">				 irq_flags, pc);			\</span>
<span class="cp">	if (!event)							\</span>
<span class="cp">		return;							\</span>
<span class="cp">	entry	= ring_buffer_event_data(event);			\</span>
<span class="cp">									\</span>
<span class="cp">	tstruct								\</span>
<span class="cp">									\</span>
<span class="cp">	{ assign; }							\</span>
<span class="cp">									\</span>
<span class="cp">	if (!filter_current_check_discard(buffer, event_call, entry, event)) \</span>
<span class="cp">		trace_nowake_buffer_unlock_commit(buffer,		\</span>
<span class="cp">						  event, irq_flags, pc); \</span>
<span class="cp">}</span>
<span class="cm">/*</span>
<span class="cm"> * The ftrace_test_probe is compiled out, it is only here as a build time check</span>
<span class="cm"> * to make sure that if the tracepoint handling changes, the ftrace probe will</span>
<span class="cm"> * fail to compile unless it too is updated.</span>
<span class="cm"> */</span>

<span class="cp">#undef DEFINE_EVENT</span>
<span class="cp">#define DEFINE_EVENT(template, call, proto, args)			\</span>
<span class="cp">static inline void ftrace_test_probe_##call(void)			\</span>
<span class="cp">{									\</span>
<span class="cp">	check_trace_callback_type_##call(ftrace_raw_event_##template);	\</span>
<span class="cp">}</span>

<span class="cp">#undef DEFINE_EVENT_PRINT</span>
<span class="cp">#define DEFINE_EVENT_PRINT(template, name, proto, args, print)</span>

<span class="cp">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span>

<span class="cp">#undef __entry</span>
<span class="cp">#define __entry REC</span>

<span class="cp">#undef __print_flags</span>
<span class="cp">#undef __print_symbolic</span>
<span class="cp">#undef __get_dynamic_array</span>
<span class="cp">#undef __get_str</span>

<span class="cp">#undef TP_printk</span>
<span class="cp">#define TP_printk(fmt, args...) &quot;\&quot;&quot; fmt &quot;\&quot;, &quot;  __stringify(args)</span>

<span class="cp">#undef DECLARE_EVENT_CLASS</span>
<span class="cp">#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)	\</span>
<span class="cp">_TRACE_PERF_PROTO(call, PARAMS(proto));					\</span>
<span class="cp">static const char print_fmt_##call[] = print;				\</span>
<span class="cp">static struct ftrace_event_class __used event_class_##call = {		\</span>
<span class="cp">	.system			= __stringify(TRACE_SYSTEM),		\</span>
<span class="cp">	.define_fields		= ftrace_define_fields_##call,		\</span>
<span class="cp">	.fields			= LIST_HEAD_INIT(event_class_##call.fields),\</span>
<span class="cp">	.raw_init		= trace_event_raw_init,			\</span>
<span class="cp">	.probe			= ftrace_raw_event_##call,		\</span>
<span class="cp">	.reg			= ftrace_event_reg,			\</span>
<span class="cp">	_TRACE_PERF_INIT(call)						\</span>
<span class="cp">};</span>

<span class="cp">#undef DEFINE_EVENT</span>
<span class="cp">#define DEFINE_EVENT(template, call, proto, args)			\</span>
<span class="cp">									\</span>
<span class="cp">static struct ftrace_event_call __used event_##call = {			\</span>
<span class="cp">	.name			= #call,				\</span>
<span class="cp">	.class			= &amp;event_class_##template,		\</span>
<span class="cp">	.event.funcs		= &amp;ftrace_event_type_funcs_##template,	\</span>
<span class="cp">	.print_fmt		= print_fmt_##template,			\</span>
<span class="cp">};									\</span>
<span class="cp">static struct ftrace_event_call __used					\</span>
<span class="cp">__attribute__((section(&quot;_ftrace_events&quot;))) *__event_##call = &amp;event_##call</span>

<span class="cp">#undef DEFINE_EVENT_PRINT</span>
<span class="cp">#define DEFINE_EVENT_PRINT(template, call, proto, args, print)		\</span>
<span class="cp">									\</span>
<span class="cp">static const char print_fmt_##call[] = print;				\</span>
<span class="cp">									\</span>
<span class="cp">static struct ftrace_event_call __used event_##call = {			\</span>
<span class="cp">	.name			= #call,				\</span>
<span class="cp">	.class			= &amp;event_class_##template,		\</span>
<span class="cp">	.event.funcs		= &amp;ftrace_event_type_funcs_##call,	\</span>
<span class="cp">	.print_fmt		= print_fmt_##call,			\</span>
<span class="cp">};									\</span>
<span class="cp">static struct ftrace_event_call __used					\</span>
<span class="cp">__attribute__((section(&quot;_ftrace_events&quot;))) *__event_##call = &amp;event_##call</span>

<span class="cp">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span>

<span class="cm">/*</span>
<span class="cm"> * Define the insertion callback to perf events</span>
<span class="cm"> *</span>
<span class="cm"> * The job is very similar to ftrace_raw_event_&lt;call&gt; except that we don&#39;t</span>
<span class="cm"> * insert in the ring buffer but in a perf counter.</span>
<span class="cm"> *</span>
<span class="cm"> * static void ftrace_perf_&lt;call&gt;(proto)</span>
<span class="cm"> * {</span>
<span class="cm"> *	struct ftrace_data_offsets_&lt;call&gt; __maybe_unused __data_offsets;</span>
<span class="cm"> *	struct ftrace_event_call *event_call = &amp;event_&lt;call&gt;;</span>
<span class="cm"> *	extern void perf_tp_event(int, u64, u64, void *, int);</span>
<span class="cm"> *	struct ftrace_raw_##call *entry;</span>
<span class="cm"> *	struct perf_trace_buf *trace_buf;</span>
<span class="cm"> *	u64 __addr = 0, __count = 1;</span>
<span class="cm"> *	unsigned long irq_flags;</span>
<span class="cm"> *	struct trace_entry *ent;</span>
<span class="cm"> *	int __entry_size;</span>
<span class="cm"> *	int __data_size;</span>
<span class="cm"> *	int __cpu</span>
<span class="cm"> *	int pc;</span>
<span class="cm"> *</span>
<span class="cm"> *	pc = preempt_count();</span>
<span class="cm"> *</span>
<span class="cm"> *	__data_size = ftrace_get_offsets_&lt;call&gt;(&amp;__data_offsets, args);</span>
<span class="cm"> *</span>
<span class="cm"> *	// Below we want to get the aligned size by taking into account</span>
<span class="cm"> *	// the u32 field that will later store the buffer size</span>
<span class="cm"> *	__entry_size = ALIGN(__data_size + sizeof(*entry) + sizeof(u32),</span>
<span class="cm"> *			     sizeof(u64));</span>
<span class="cm"> *	__entry_size -= sizeof(u32);</span>
<span class="cm"> *</span>
<span class="cm"> *	// Protect the non nmi buffer</span>
<span class="cm"> *	// This also protects the rcu read side</span>
<span class="cm"> *	local_irq_save(irq_flags);</span>
<span class="cm"> *	__cpu = smp_processor_id();</span>
<span class="cm"> *</span>
<span class="cm"> *	if (in_nmi())</span>
<span class="cm"> *		trace_buf = rcu_dereference_sched(perf_trace_buf_nmi);</span>
<span class="cm"> *	else</span>
<span class="cm"> *		trace_buf = rcu_dereference_sched(perf_trace_buf);</span>
<span class="cm"> *</span>
<span class="cm"> *	if (!trace_buf)</span>
<span class="cm"> *		goto end;</span>
<span class="cm"> *</span>
<span class="cm"> *	trace_buf = per_cpu_ptr(trace_buf, __cpu);</span>
<span class="cm"> *</span>
<span class="cm"> * 	// Avoid recursion from perf that could mess up the buffer</span>
<span class="cm"> * 	if (trace_buf-&gt;recursion++)</span>
<span class="cm"> *		goto end_recursion;</span>
<span class="cm"> *</span>
<span class="cm"> * 	raw_data = trace_buf-&gt;buf;</span>
<span class="cm"> *</span>
<span class="cm"> *	// Make recursion update visible before entering perf_tp_event</span>
<span class="cm"> *	// so that we protect from perf recursions.</span>
<span class="cm"> *</span>
<span class="cm"> *	barrier();</span>
<span class="cm"> *</span>
<span class="cm"> *	//zero dead bytes from alignment to avoid stack leak to userspace:</span>
<span class="cm"> *	*(u64 *)(&amp;raw_data[__entry_size - sizeof(u64)]) = 0ULL;</span>
<span class="cm"> *	entry = (struct ftrace_raw_&lt;call&gt; *)raw_data;</span>
<span class="cm"> *	ent = &amp;entry-&gt;ent;</span>
<span class="cm"> *	tracing_generic_entry_update(ent, irq_flags, pc);</span>
<span class="cm"> *	ent-&gt;type = event_call-&gt;id;</span>
<span class="cm"> *</span>
<span class="cm"> *	&lt;tstruct&gt; &lt;- do some jobs with dynamic arrays</span>
<span class="cm"> *</span>
<span class="cm"> *	&lt;assign&gt;  &lt;- affect our values</span>
<span class="cm"> *</span>
<span class="cm"> *	perf_tp_event(event_call-&gt;id, __addr, __count, entry,</span>
<span class="cm"> *		     __entry_size);  &lt;- submit them to perf counter</span>
<span class="cm"> *</span>
<span class="cm"> * }</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_PERF_EVENTS</span>

<span class="cp">#undef __entry</span>
<span class="cp">#define __entry entry</span>

<span class="cp">#undef __get_dynamic_array</span>
<span class="cp">#define __get_dynamic_array(field)	\</span>
<span class="cp">		((void *)__entry + (__entry-&gt;__data_loc_##field &amp; 0xffff))</span>

<span class="cp">#undef __get_str</span>
<span class="cp">#define __get_str(field) (char *)__get_dynamic_array(field)</span>

<span class="cp">#undef __perf_addr</span>
<span class="cp">#define __perf_addr(a) __addr = (a)</span>

<span class="cp">#undef __perf_count</span>
<span class="cp">#define __perf_count(c) __count = (c)</span>

<span class="cp">#undef TP_perf_assign</span>
<span class="cp">#define TP_perf_assign(args...) args</span>

<span class="cp">#undef DECLARE_EVENT_CLASS</span>
<span class="cp">#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)	\</span>
<span class="cp">static notrace void							\</span>
<span class="cp">perf_trace_##call(void *__data, proto)					\</span>
<span class="cp">{									\</span>
<span class="cp">	struct ftrace_event_call *event_call = __data;			\</span>
<span class="cp">	struct ftrace_data_offsets_##call __maybe_unused __data_offsets;\</span>
<span class="cp">	struct ftrace_raw_##call *entry;				\</span>
<span class="cp">	struct pt_regs __regs;						\</span>
<span class="cp">	u64 __addr = 0, __count = 1;					\</span>
<span class="cp">	struct hlist_head *head;					\</span>
<span class="cp">	int __entry_size;						\</span>
<span class="cp">	int __data_size;						\</span>
<span class="cp">	int rctx;							\</span>
<span class="cp">									\</span>
<span class="cp">	perf_fetch_caller_regs(&amp;__regs);				\</span>
<span class="cp">									\</span>
<span class="cp">	__data_size = ftrace_get_offsets_##call(&amp;__data_offsets, args); \</span>
<span class="cp">	__entry_size = ALIGN(__data_size + sizeof(*entry) + sizeof(u32),\</span>
<span class="cp">			     sizeof(u64));				\</span>
<span class="cp">	__entry_size -= sizeof(u32);					\</span>
<span class="cp">									\</span>
<span class="cp">	if (WARN_ONCE(__entry_size &gt; PERF_MAX_TRACE_SIZE,		\</span>
<span class="cp">		      &quot;profile buffer not large enough&quot;))		\</span>
<span class="cp">		return;							\</span>
<span class="cp">									\</span>
<span class="cp">	entry = (struct ftrace_raw_##call *)perf_trace_buf_prepare(	\</span>
<span class="cp">		__entry_size, event_call-&gt;event.type, &amp;__regs, &amp;rctx);	\</span>
<span class="cp">	if (!entry)							\</span>
<span class="cp">		return;							\</span>
<span class="cp">									\</span>
<span class="cp">	tstruct								\</span>
<span class="cp">									\</span>
<span class="cp">	{ assign; }							\</span>
<span class="cp">									\</span>
<span class="cp">	head = this_cpu_ptr(event_call-&gt;perf_events);			\</span>
<span class="cp">	perf_trace_buf_submit(entry, __entry_size, rctx, __addr,	\</span>
<span class="cp">		__count, &amp;__regs, head);				\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * This part is compiled out, it is only here as a build time check</span>
<span class="cm"> * to make sure that if the tracepoint handling changes, the</span>
<span class="cm"> * perf probe will fail to compile unless it too is updated.</span>
<span class="cm"> */</span>
<span class="cp">#undef DEFINE_EVENT</span>
<span class="cp">#define DEFINE_EVENT(template, call, proto, args)			\</span>
<span class="cp">static inline void perf_test_probe_##call(void)				\</span>
<span class="cp">{									\</span>
<span class="cp">	check_trace_callback_type_##call(perf_trace_##template);	\</span>
<span class="cp">}</span>


<span class="cp">#undef DEFINE_EVENT_PRINT</span>
<span class="cp">#define DEFINE_EVENT_PRINT(template, name, proto, args, print)	\</span>
<span class="cp">	DEFINE_EVENT(template, name, PARAMS(proto), PARAMS(args))</span>

<span class="cp">#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PERF_EVENTS */</span><span class="cp"></span>

<span class="cp">#undef _TRACE_PROFILE_INIT</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
