<!DOCTYPE html>
<html><head><title>joekychen/linux » include › sound › soc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>soc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/sound/soc.h -- ALSA SoC Layer</span>
<span class="cm"> *</span>
<span class="cm"> * Author:		Liam Girdwood</span>
<span class="cm"> * Created:		Aug 11th 2005</span>
<span class="cm"> * Copyright:	Wolfson Microelectronics. PLC.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __LINUX_SND_SOC_H</span>
<span class="cp">#define __LINUX_SND_SOC_H</span>

<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/regmap.h&gt;</span>
<span class="cp">#include &lt;sound/core.h&gt;</span>
<span class="cp">#include &lt;sound/pcm.h&gt;</span>
<span class="cp">#include &lt;sound/control.h&gt;</span>
<span class="cp">#include &lt;sound/ac97_codec.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Convenience kcontrol builders</span>
<span class="cm"> */</span>
<span class="cp">#define SOC_DOUBLE_VALUE(xreg, shift_left, shift_right, xmax, xinvert) \</span>
<span class="cp">	((unsigned long)&amp;(struct soc_mixer_control) \</span>
<span class="cp">	{.reg = xreg, .rreg = xreg, .shift = shift_left, \</span>
<span class="cp">	.rshift = shift_right, .max = xmax, .platform_max = xmax, \</span>
<span class="cp">	.invert = xinvert})</span>
<span class="cp">#define SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert) \</span>
<span class="cp">	SOC_DOUBLE_VALUE(xreg, xshift, xshift, xmax, xinvert)</span>
<span class="cp">#define SOC_SINGLE_VALUE_EXT(xreg, xmax, xinvert) \</span>
<span class="cp">	((unsigned long)&amp;(struct soc_mixer_control) \</span>
<span class="cp">	{.reg = xreg, .max = xmax, .platform_max = xmax, .invert = xinvert})</span>
<span class="cp">#define SOC_DOUBLE_R_VALUE(xlreg, xrreg, xshift, xmax, xinvert) \</span>
<span class="cp">	((unsigned long)&amp;(struct soc_mixer_control) \</span>
<span class="cp">	{.reg = xlreg, .rreg = xrreg, .shift = xshift, .rshift = xshift, \</span>
<span class="cp">	.max = xmax, .platform_max = xmax, .invert = xinvert})</span>
<span class="cp">#define SOC_SINGLE(xname, reg, shift, max, invert) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span>
<span class="cp">	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\</span>
<span class="cp">	.put = snd_soc_put_volsw, \</span>
<span class="cp">	.private_value =  SOC_SINGLE_VALUE(reg, shift, max, invert) }</span>
<span class="cp">#define SOC_SINGLE_TLV(xname, reg, shift, max, invert, tlv_array) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span>
<span class="cp">	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\</span>
<span class="cp">		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\</span>
<span class="cp">	.tlv.p = (tlv_array), \</span>
<span class="cp">	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\</span>
<span class="cp">	.put = snd_soc_put_volsw, \</span>
<span class="cp">	.private_value =  SOC_SINGLE_VALUE(reg, shift, max, invert) }</span>
<span class="cp">#define SOC_SINGLE_SX_TLV(xname, xreg, xshift, xmin, xmax, tlv_array) \</span>
<span class="cp">{       .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span>
<span class="cp">	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \</span>
<span class="cp">	SNDRV_CTL_ELEM_ACCESS_READWRITE, \</span>
<span class="cp">	.tlv.p  = (tlv_array),\</span>
<span class="cp">	.info = snd_soc_info_volsw, \</span>
<span class="cp">	.get = snd_soc_get_volsw_sx,\</span>
<span class="cp">	.put = snd_soc_put_volsw_sx, \</span>
<span class="cp">	.private_value = (unsigned long)&amp;(struct soc_mixer_control) \</span>
<span class="cp">		{.reg = xreg, .rreg = xreg, \</span>
<span class="cp">		.shift = xshift, .rshift = xshift, \</span>
<span class="cp">		.max = xmax, .min = xmin} }</span>
<span class="cp">#define SOC_DOUBLE(xname, reg, shift_left, shift_right, max, invert) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\</span>
<span class="cp">	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw, \</span>
<span class="cp">	.put = snd_soc_put_volsw, \</span>
<span class="cp">	.private_value = SOC_DOUBLE_VALUE(reg, shift_left, shift_right, \</span>
<span class="cp">					  max, invert) }</span>
<span class="cp">#define SOC_DOUBLE_R(xname, reg_left, reg_right, xshift, xmax, xinvert) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \</span>
<span class="cp">	.info = snd_soc_info_volsw, \</span>
<span class="cp">	.get = snd_soc_get_volsw, .put = snd_soc_put_volsw, \</span>
<span class="cp">	.private_value = SOC_DOUBLE_R_VALUE(reg_left, reg_right, xshift, \</span>
<span class="cp">					    xmax, xinvert) }</span>
<span class="cp">#define SOC_DOUBLE_TLV(xname, reg, shift_left, shift_right, max, invert, tlv_array) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\</span>
<span class="cp">	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\</span>
<span class="cp">		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\</span>
<span class="cp">	.tlv.p = (tlv_array), \</span>
<span class="cp">	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw, \</span>
<span class="cp">	.put = snd_soc_put_volsw, \</span>
<span class="cp">	.private_value = SOC_DOUBLE_VALUE(reg, shift_left, shift_right, \</span>
<span class="cp">					  max, invert) }</span>
<span class="cp">#define SOC_DOUBLE_R_TLV(xname, reg_left, reg_right, xshift, xmax, xinvert, tlv_array) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\</span>
<span class="cp">	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\</span>
<span class="cp">		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\</span>
<span class="cp">	.tlv.p = (tlv_array), \</span>
<span class="cp">	.info = snd_soc_info_volsw, \</span>
<span class="cp">	.get = snd_soc_get_volsw, .put = snd_soc_put_volsw, \</span>
<span class="cp">	.private_value = SOC_DOUBLE_R_VALUE(reg_left, reg_right, xshift, \</span>
<span class="cp">					    xmax, xinvert) }</span>
<span class="cp">#define SOC_DOUBLE_R_SX_TLV(xname, xreg, xrreg, xshift, xmin, xmax, tlv_array) \</span>
<span class="cp">{       .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \</span>
<span class="cp">	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \</span>
<span class="cp">	SNDRV_CTL_ELEM_ACCESS_READWRITE, \</span>
<span class="cp">	.tlv.p  = (tlv_array), \</span>
<span class="cp">	.info = snd_soc_info_volsw, \</span>
<span class="cp">	.get = snd_soc_get_volsw_sx, \</span>
<span class="cp">	.put = snd_soc_put_volsw_sx, \</span>
<span class="cp">	.private_value = (unsigned long)&amp;(struct soc_mixer_control) \</span>
<span class="cp">		{.reg = xreg, .rreg = xrreg, \</span>
<span class="cp">		.shift = xshift, .rshift = xshift, \</span>
<span class="cp">		.max = xmax, .min = xmin} }</span>
<span class="cp">#define SOC_DOUBLE_S8_TLV(xname, xreg, xmin, xmax, tlv_array) \</span>
<span class="cp">{	.iface  = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \</span>
<span class="cp">	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \</span>
<span class="cp">		  SNDRV_CTL_ELEM_ACCESS_READWRITE, \</span>
<span class="cp">	.tlv.p  = (tlv_array), \</span>
<span class="cp">	.info   = snd_soc_info_volsw_s8, .get = snd_soc_get_volsw_s8, \</span>
<span class="cp">	.put    = snd_soc_put_volsw_s8, \</span>
<span class="cp">	.private_value = (unsigned long)&amp;(struct soc_mixer_control) \</span>
<span class="cp">		{.reg = xreg, .min = xmin, .max = xmax, \</span>
<span class="cp">		 .platform_max = xmax} }</span>
<span class="cp">#define SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmax, xtexts) \</span>
<span class="cp">{	.reg = xreg, .shift_l = xshift_l, .shift_r = xshift_r, \</span>
<span class="cp">	.max = xmax, .texts = xtexts }</span>
<span class="cp">#define SOC_ENUM_SINGLE(xreg, xshift, xmax, xtexts) \</span>
<span class="cp">	SOC_ENUM_DOUBLE(xreg, xshift, xshift, xmax, xtexts)</span>
<span class="cp">#define SOC_ENUM_SINGLE_EXT(xmax, xtexts) \</span>
<span class="cp">{	.max = xmax, .texts = xtexts }</span>
<span class="cp">#define SOC_VALUE_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmask, xmax, xtexts, xvalues) \</span>
<span class="cp">{	.reg = xreg, .shift_l = xshift_l, .shift_r = xshift_r, \</span>
<span class="cp">	.mask = xmask, .max = xmax, .texts = xtexts, .values = xvalues}</span>
<span class="cp">#define SOC_VALUE_ENUM_SINGLE(xreg, xshift, xmask, xmax, xtexts, xvalues) \</span>
<span class="cp">	SOC_VALUE_ENUM_DOUBLE(xreg, xshift, xshift, xmask, xmax, xtexts, xvalues)</span>
<span class="cp">#define SOC_ENUM(xname, xenum) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,\</span>
<span class="cp">	.info = snd_soc_info_enum_double, \</span>
<span class="cp">	.get = snd_soc_get_enum_double, .put = snd_soc_put_enum_double, \</span>
<span class="cp">	.private_value = (unsigned long)&amp;xenum }</span>
<span class="cp">#define SOC_VALUE_ENUM(xname, xenum) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,\</span>
<span class="cp">	.info = snd_soc_info_enum_double, \</span>
<span class="cp">	.get = snd_soc_get_value_enum_double, \</span>
<span class="cp">	.put = snd_soc_put_value_enum_double, \</span>
<span class="cp">	.private_value = (unsigned long)&amp;xenum }</span>
<span class="cp">#define SOC_SINGLE_EXT(xname, xreg, xshift, xmax, xinvert,\</span>
<span class="cp">	 xhandler_get, xhandler_put) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span>
<span class="cp">	.info = snd_soc_info_volsw, \</span>
<span class="cp">	.get = xhandler_get, .put = xhandler_put, \</span>
<span class="cp">	.private_value = SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert) }</span>
<span class="cp">#define SOC_DOUBLE_EXT(xname, reg, shift_left, shift_right, max, invert,\</span>
<span class="cp">	 xhandler_get, xhandler_put) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\</span>
<span class="cp">	.info = snd_soc_info_volsw, \</span>
<span class="cp">	.get = xhandler_get, .put = xhandler_put, \</span>
<span class="cp">	.private_value = \</span>
<span class="cp">		SOC_DOUBLE_VALUE(reg, shift_left, shift_right, max, invert) }</span>
<span class="cp">#define SOC_SINGLE_EXT_TLV(xname, xreg, xshift, xmax, xinvert,\</span>
<span class="cp">	 xhandler_get, xhandler_put, tlv_array) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span>
<span class="cp">	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\</span>
<span class="cp">		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\</span>
<span class="cp">	.tlv.p = (tlv_array), \</span>
<span class="cp">	.info = snd_soc_info_volsw, \</span>
<span class="cp">	.get = xhandler_get, .put = xhandler_put, \</span>
<span class="cp">	.private_value = SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert) }</span>
<span class="cp">#define SOC_DOUBLE_EXT_TLV(xname, xreg, shift_left, shift_right, xmax, xinvert,\</span>
<span class="cp">	 xhandler_get, xhandler_put, tlv_array) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \</span>
<span class="cp">	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \</span>
<span class="cp">		 SNDRV_CTL_ELEM_ACCESS_READWRITE, \</span>
<span class="cp">	.tlv.p = (tlv_array), \</span>
<span class="cp">	.info = snd_soc_info_volsw, \</span>
<span class="cp">	.get = xhandler_get, .put = xhandler_put, \</span>
<span class="cp">	.private_value = SOC_DOUBLE_VALUE(xreg, shift_left, shift_right, \</span>
<span class="cp">					  xmax, xinvert) }</span>
<span class="cp">#define SOC_DOUBLE_R_EXT_TLV(xname, reg_left, reg_right, xshift, xmax, xinvert,\</span>
<span class="cp">	 xhandler_get, xhandler_put, tlv_array) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \</span>
<span class="cp">	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \</span>
<span class="cp">		 SNDRV_CTL_ELEM_ACCESS_READWRITE, \</span>
<span class="cp">	.tlv.p = (tlv_array), \</span>
<span class="cp">	.info = snd_soc_info_volsw, \</span>
<span class="cp">	.get = xhandler_get, .put = xhandler_put, \</span>
<span class="cp">	.private_value = SOC_DOUBLE_R_VALUE(reg_left, reg_right, xshift, \</span>
<span class="cp">					    xmax, xinvert) }</span>
<span class="cp">#define SOC_SINGLE_BOOL_EXT(xname, xdata, xhandler_get, xhandler_put) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span>
<span class="cp">	.info = snd_soc_info_bool_ext, \</span>
<span class="cp">	.get = xhandler_get, .put = xhandler_put, \</span>
<span class="cp">	.private_value = xdata }</span>
<span class="cp">#define SOC_ENUM_EXT(xname, xenum, xhandler_get, xhandler_put) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span>
<span class="cp">	.info = snd_soc_info_enum_ext, \</span>
<span class="cp">	.get = xhandler_get, .put = xhandler_put, \</span>
<span class="cp">	.private_value = (unsigned long)&amp;xenum }</span>

<span class="cp">#define SND_SOC_BYTES(xname, xbase, xregs)		      \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,   \</span>
<span class="cp">	.info = snd_soc_bytes_info, .get = snd_soc_bytes_get, \</span>
<span class="cp">	.put = snd_soc_bytes_put, .private_value =	      \</span>
<span class="cp">		((unsigned long)&amp;(struct soc_bytes)           \</span>
<span class="cp">		{.base = xbase, .num_regs = xregs }) }</span>

<span class="cp">#define SND_SOC_BYTES_MASK(xname, xbase, xregs, xmask)	      \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,   \</span>
<span class="cp">	.info = snd_soc_bytes_info, .get = snd_soc_bytes_get, \</span>
<span class="cp">	.put = snd_soc_bytes_put, .private_value =	      \</span>
<span class="cp">		((unsigned long)&amp;(struct soc_bytes)           \</span>
<span class="cp">		{.base = xbase, .num_regs = xregs,	      \</span>
<span class="cp">		 .mask = xmask }) }</span>

<span class="cp">#define SOC_SINGLE_XR_SX(xname, xregbase, xregcount, xnbits, \</span>
<span class="cp">		xmin, xmax, xinvert) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \</span>
<span class="cp">	.info = snd_soc_info_xr_sx, .get = snd_soc_get_xr_sx, \</span>
<span class="cp">	.put = snd_soc_put_xr_sx, \</span>
<span class="cp">	.private_value = (unsigned long)&amp;(struct soc_mreg_control) \</span>
<span class="cp">		{.regbase = xregbase, .regcount = xregcount, .nbits = xnbits, \</span>
<span class="cp">		.invert = xinvert, .min = xmin, .max = xmax} }</span>

<span class="cp">#define SOC_SINGLE_STROBE(xname, xreg, xshift, xinvert) \</span>
<span class="cp">	SOC_SINGLE_EXT(xname, xreg, xshift, 1, xinvert, \</span>
<span class="cp">		snd_soc_get_strobe, snd_soc_put_strobe)</span>

<span class="cm">/*</span>
<span class="cm"> * Simplified versions of above macros, declaring a struct and calculating</span>
<span class="cm"> * ARRAY_SIZE internally</span>
<span class="cm"> */</span>
<span class="cp">#define SOC_ENUM_DOUBLE_DECL(name, xreg, xshift_l, xshift_r, xtexts) \</span>
<span class="cp">	struct soc_enum name = SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, \</span>
<span class="cp">						ARRAY_SIZE(xtexts), xtexts)</span>
<span class="cp">#define SOC_ENUM_SINGLE_DECL(name, xreg, xshift, xtexts) \</span>
<span class="cp">	SOC_ENUM_DOUBLE_DECL(name, xreg, xshift, xshift, xtexts)</span>
<span class="cp">#define SOC_ENUM_SINGLE_EXT_DECL(name, xtexts) \</span>
<span class="cp">	struct soc_enum name = SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(xtexts), xtexts)</span>
<span class="cp">#define SOC_VALUE_ENUM_DOUBLE_DECL(name, xreg, xshift_l, xshift_r, xmask, xtexts, xvalues) \</span>
<span class="cp">	struct soc_enum name = SOC_VALUE_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmask, \</span>
<span class="cp">							ARRAY_SIZE(xtexts), xtexts, xvalues)</span>
<span class="cp">#define SOC_VALUE_ENUM_SINGLE_DECL(name, xreg, xshift, xmask, xtexts, xvalues) \</span>
<span class="cp">	SOC_VALUE_ENUM_DOUBLE_DECL(name, xreg, xshift, xshift, xmask, xtexts, xvalues)</span>

<span class="cm">/*</span>
<span class="cm"> * Component probe and remove ordering levels for components with runtime</span>
<span class="cm"> * dependencies.</span>
<span class="cm"> */</span>
<span class="cp">#define SND_SOC_COMP_ORDER_FIRST		-2</span>
<span class="cp">#define SND_SOC_COMP_ORDER_EARLY		-1</span>
<span class="cp">#define SND_SOC_COMP_ORDER_NORMAL		0</span>
<span class="cp">#define SND_SOC_COMP_ORDER_LATE		1</span>
<span class="cp">#define SND_SOC_COMP_ORDER_LAST		2</span>

<span class="cm">/*</span>
<span class="cm"> * Bias levels</span>
<span class="cm"> *</span>
<span class="cm"> * @ON:      Bias is fully on for audio playback and capture operations.</span>
<span class="cm"> * @PREPARE: Prepare for audio operations. Called before DAPM switching for</span>
<span class="cm"> *           stream start and stop operations.</span>
<span class="cm"> * @STANDBY: Low power standby state when no playback/capture operations are</span>
<span class="cm"> *           in progress. NOTE: The transition time between STANDBY and ON</span>
<span class="cm"> *           should be as fast as possible and no longer than 10ms.</span>
<span class="cm"> * @OFF:     Power Off. No restrictions on transition times.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">snd_soc_bias_level</span> <span class="p">{</span>
	<span class="n">SND_SOC_BIAS_OFF</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SND_SOC_BIAS_STANDBY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">SND_SOC_BIAS_PREPARE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">SND_SOC_BIAS_ON</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">device_node</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">snd_jack</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">snd_soc_card</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">snd_soc_pcm_stream</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">snd_soc_ops</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">snd_soc_pcm_runtime</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">snd_soc_dai</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">snd_soc_dai_driver</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">snd_soc_platform</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">snd_soc_dai_link</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">snd_soc_platform_driver</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">snd_soc_codec</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">snd_soc_codec_driver</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">soc_enum</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">snd_soc_jack</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">snd_soc_jack_zone</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">snd_soc_jack_pin</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">snd_soc_cache_ops</span><span class="p">;</span>
<span class="cp">#include &lt;sound/soc-dapm.h&gt;</span>
<span class="cp">#include &lt;sound/soc-dpcm.h&gt;</span>

<span class="cp">#ifdef CONFIG_GPIOLIB</span>
<span class="k">struct</span> <span class="n">snd_soc_jack_gpio</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hw_write_t</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="p">,</span><span class="kt">int</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">snd_ac97_bus_ops</span> <span class="n">soc_ac97_ops</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">snd_soc_control_type</span> <span class="p">{</span>
	<span class="n">SND_SOC_I2C</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">SND_SOC_SPI</span><span class="p">,</span>
	<span class="n">SND_SOC_REGMAP</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">snd_soc_compress_type</span> <span class="p">{</span>
	<span class="n">SND_SOC_FLAT_COMPRESSION</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">snd_soc_pcm_subclass</span> <span class="p">{</span>
	<span class="n">SND_SOC_PCM_CLASS_PCM</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SND_SOC_PCM_CLASS_BE</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">snd_soc_card_subclass</span> <span class="p">{</span>
	<span class="n">SND_SOC_CARD_CLASS_INIT</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SND_SOC_CARD_CLASS_RUNTIME</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">snd_soc_codec_set_sysclk</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clk_id</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">source</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_codec_set_pll</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pll_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">source</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freq_in</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freq_out</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">snd_soc_register_card</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_unregister_card</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_poweroff</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_register_platform</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">snd_soc_platform_driver</span> <span class="o">*</span><span class="n">platform_drv</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">snd_soc_unregister_platform</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_register_codec</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_soc_codec_driver</span> <span class="o">*</span><span class="n">codec_drv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">snd_soc_dai_driver</span> <span class="o">*</span><span class="n">dai_drv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_dai</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">snd_soc_unregister_codec</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_codec_volatile_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_codec_readable_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_codec_writable_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_codec_set_cache_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">addr_bits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data_bits</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">snd_soc_control_type</span> <span class="n">control</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_cache_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_cache_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_cache_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_cache_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_cache_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_default_volatile_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_default_readable_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_default_writable_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_platform_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_platform</span> <span class="o">*</span><span class="n">platform</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_platform_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_platform</span> <span class="o">*</span><span class="n">platform</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">soc_new_pcm</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_pcm_runtime</span> <span class="o">*</span><span class="n">rtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">snd_soc_get_dai_substream</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dai_link</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stream</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">snd_soc_pcm_runtime</span> <span class="o">*</span><span class="n">snd_soc_get_pcm_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dai_link</span><span class="p">);</span>

<span class="cm">/* Utility functions to get clock rates from various things */</span>
<span class="kt">int</span> <span class="n">snd_soc_calc_frame_size</span><span class="p">(</span><span class="kt">int</span> <span class="n">sample_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tdm_slots</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_params_to_frame_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_calc_bclk</span><span class="p">(</span><span class="kt">int</span> <span class="n">fs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sample_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tdm_slots</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_params_to_bclk</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="n">parms</span><span class="p">);</span>

<span class="cm">/* set runtime hw params */</span>
<span class="kt">int</span> <span class="n">snd_soc_set_runtime_hwparams</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_pcm_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">snd_soc_platform_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_soc_platform</span> <span class="o">*</span><span class="n">platform</span><span class="p">);</span>

<span class="cm">/* Jack reporting */</span>
<span class="kt">int</span> <span class="n">snd_soc_jack_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">snd_soc_jack</span> <span class="o">*</span><span class="n">jack</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">snd_soc_jack_report</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_jack</span> <span class="o">*</span><span class="n">jack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_jack_add_pins</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_jack</span> <span class="o">*</span><span class="n">jack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">snd_soc_jack_pin</span> <span class="o">*</span><span class="n">pins</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">snd_soc_jack_notifier_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_jack</span> <span class="o">*</span><span class="n">jack</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">snd_soc_jack_notifier_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_jack</span> <span class="o">*</span><span class="n">jack</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_jack_add_zones</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_jack</span> <span class="o">*</span><span class="n">jack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">snd_soc_jack_zone</span> <span class="o">*</span><span class="n">zones</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_jack_get_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_jack</span> <span class="o">*</span><span class="n">jack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">micbias_voltage</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_GPIOLIB</span>
<span class="kt">int</span> <span class="n">snd_soc_jack_add_gpios</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_jack</span> <span class="o">*</span><span class="n">jack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">snd_soc_jack_gpio</span> <span class="o">*</span><span class="n">gpios</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">snd_soc_jack_free_gpios</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_jack</span> <span class="o">*</span><span class="n">jack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">snd_soc_jack_gpio</span> <span class="o">*</span><span class="n">gpios</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* codec register bit access */</span>
<span class="kt">int</span> <span class="n">snd_soc_update_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_update_bits_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_test_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">snd_soc_new_ac97_codec</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ac97_bus_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">snd_soc_free_ac97_codec</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *Controls</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">snd_soc_cnew</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="o">*</span><span class="n">_template</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">long_name</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_add_codec_controls</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="o">*</span><span class="n">controls</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_controls</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_add_platform_controls</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_platform</span> <span class="o">*</span><span class="n">platform</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="o">*</span><span class="n">controls</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_controls</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_add_card_controls</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">soc_card</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="o">*</span><span class="n">controls</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_controls</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_add_dai_controls</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">dai</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="o">*</span><span class="n">controls</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_controls</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_info_enum_double</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_info_enum_ext</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_get_enum_double</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_put_enum_double</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_get_value_enum_double</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_put_value_enum_double</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_info_volsw</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_info_volsw_ext</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">);</span>
<span class="cp">#define snd_soc_info_bool_ext		snd_ctl_boolean_mono_info</span>
<span class="kt">int</span> <span class="n">snd_soc_get_volsw</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_put_volsw</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="cp">#define snd_soc_get_volsw_2r snd_soc_get_volsw</span>
<span class="cp">#define snd_soc_put_volsw_2r snd_soc_put_volsw</span>
<span class="kt">int</span> <span class="n">snd_soc_get_volsw_sx</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_put_volsw_sx</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_info_volsw_s8</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_get_volsw_s8</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_put_volsw_s8</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_limit_volume</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_bytes_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_bytes_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_bytes_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_info_xr_sx</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_get_xr_sx</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_put_xr_sx</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_get_strobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_put_strobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct snd_soc_reg_access - Describes whether a given register is</span>
<span class="cm"> * readable, writable or volatile.</span>
<span class="cm"> *</span>
<span class="cm"> * @reg: the register number</span>
<span class="cm"> * @read: whether this register is readable</span>
<span class="cm"> * @write: whether this register is writable</span>
<span class="cm"> * @vol: whether this register is volatile</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">snd_soc_reg_access</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">read</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">write</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vol</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct snd_soc_jack_pin - Describes a pin to update based on jack detection</span>
<span class="cm"> *</span>
<span class="cm"> * @pin:    name of the pin to update</span>
<span class="cm"> * @mask:   bits to check for in reported jack status</span>
<span class="cm"> * @invert: if non-zero then pin is enabled when status is not reported</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">snd_soc_jack_pin</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pin</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">invert</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct snd_soc_jack_zone - Describes voltage zones of jack detection</span>
<span class="cm"> *</span>
<span class="cm"> * @min_mv: start voltage in mv</span>
<span class="cm"> * @max_mv: end voltage in mv</span>
<span class="cm"> * @jack_type: type of jack that is expected for this voltage</span>
<span class="cm"> * @debounce_time: debounce_time for jack, codec driver should wait for this</span>
<span class="cm"> *		duration before reading the adc for voltages</span>
<span class="cm"> * @:list: list container</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">snd_soc_jack_zone</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min_mv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_mv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">jack_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">debounce_time</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct snd_soc_jack_gpio - Describes a gpio pin for jack detection</span>
<span class="cm"> *</span>
<span class="cm"> * @gpio:         gpio number</span>
<span class="cm"> * @name:         gpio name</span>
<span class="cm"> * @report:       value to report when jack detected</span>
<span class="cm"> * @invert:       report presence in low state</span>
<span class="cm"> * @debouce_time: debouce time in ms</span>
<span class="cm"> * @wake:	  enable as wake source</span>
<span class="cm"> * @jack_status_check: callback function which overrides the detection</span>
<span class="cm"> *		       to provide more complex checks (eg, reading an</span>
<span class="cm"> *		       ADC).</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_GPIOLIB</span>
<span class="k">struct</span> <span class="n">snd_soc_jack_gpio</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gpio</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">report</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">invert</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">debounce_time</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">wake</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">snd_soc_jack</span> <span class="o">*</span><span class="n">jack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">work</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">jack_status_check</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">snd_soc_jack</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_jack</span> <span class="o">*</span><span class="n">jack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pins</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blocking_notifier_head</span> <span class="n">notifier</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">jack_zones</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* SoC PCM stream information */</span>
<span class="k">struct</span> <span class="n">snd_soc_pcm_stream</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">stream_name</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">formats</span><span class="p">;</span>			<span class="cm">/* SNDRV_PCM_FMTBIT_* */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rates</span><span class="p">;</span>		<span class="cm">/* SNDRV_PCM_RATE_* */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rate_min</span><span class="p">;</span>		<span class="cm">/* min rate */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rate_max</span><span class="p">;</span>		<span class="cm">/* max rate */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channels_min</span><span class="p">;</span>	<span class="cm">/* min channels */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channels_max</span><span class="p">;</span>	<span class="cm">/* max channels */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sig_bits</span><span class="p">;</span>		<span class="cm">/* number of bits of content */</span>
<span class="p">};</span>

<span class="cm">/* SoC audio ops */</span>
<span class="k">struct</span> <span class="n">snd_soc_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">startup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hw_params</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hw_free</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">prepare</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">trigger</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* SoC cache ops */</span>
<span class="k">struct</span> <span class="n">snd_soc_cache_ops</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">snd_soc_compress_type</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">exit</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sync</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* SoC Audio Codec device */</span>
<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name_prefix</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_soc_codec_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">card_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_dai</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">snd_soc_compress_type</span> <span class="n">compress_type</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">reg_size</span><span class="p">;</span>	<span class="cm">/* reg_cache_size * reg_word_size */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">volatile_register</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">readable_register</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">writable_register</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

	<span class="cm">/* runtime */</span>
	<span class="k">struct</span> <span class="n">snd_ac97</span> <span class="o">*</span><span class="n">ac97</span><span class="p">;</span>  <span class="cm">/* for ad-hoc ac97 devices */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">active</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cache_bypass</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Suppress access to the cache */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">suspended</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Codec is in suspend PM state */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">probed</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Codec has been probed */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ac97_registered</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Codec has been AC97 registered */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ac97_created</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Codec has been created by SoC */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysfs_registered</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* codec has been sysfs registered */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cache_init</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* codec cache has been initialized */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">using_regmap</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* using regmap access */</span>
	<span class="n">u32</span> <span class="n">cache_only</span><span class="p">;</span>  <span class="cm">/* Suppress writes to hardware */</span>
	<span class="n">u32</span> <span class="n">cache_sync</span><span class="p">;</span> <span class="cm">/* Cache needs to be synced to hardware */</span>

	<span class="cm">/* codec IO */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">control_data</span><span class="p">;</span> <span class="cm">/* codec control (i2c/3wire) data */</span>
	<span class="k">enum</span> <span class="n">snd_soc_control_type</span> <span class="n">control_type</span><span class="p">;</span>
	<span class="n">hw_write_t</span> <span class="n">hw_write</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hw_read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bulk_write_raw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">reg_cache</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">reg_def_copy</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_soc_cache_ops</span> <span class="o">*</span><span class="n">cache_ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">cache_rw_mutex</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val_bytes</span><span class="p">;</span>

	<span class="cm">/* dapm */</span>
	<span class="k">struct</span> <span class="n">snd_soc_dapm_context</span> <span class="n">dapm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ignore_pmdown_time</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* pmdown_time is ignored at stop */</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_codec_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_dapm</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* codec driver */</span>
<span class="k">struct</span> <span class="n">snd_soc_codec_driver</span> <span class="p">{</span>

	<span class="cm">/* driver ops */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Default control and setup, added after probe() is run */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="o">*</span><span class="n">controls</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_controls</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_soc_dapm_widget</span> <span class="o">*</span><span class="n">dapm_widgets</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_dapm_widgets</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_soc_dapm_route</span> <span class="o">*</span><span class="n">dapm_routes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_dapm_routes</span><span class="p">;</span>

	<span class="cm">/* codec wide operations */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_sysclk</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">clk_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">source</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_pll</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pll_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">source</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freq_in</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freq_out</span><span class="p">);</span>

	<span class="cm">/* codec IO */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">display_register</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
				<span class="kt">size_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">volatile_register</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">readable_register</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">writable_register</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg_cache_size</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">reg_cache_step</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">reg_word_size</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">reg_cache_default</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">reg_access_size</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_soc_reg_access</span> <span class="o">*</span><span class="n">reg_access_default</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">snd_soc_compress_type</span> <span class="n">compress_type</span><span class="p">;</span>

	<span class="cm">/* codec bias level */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_bias_level</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">snd_soc_bias_level</span> <span class="n">level</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">idle_bias_off</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">seq_notifier</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_dapm_context</span> <span class="o">*</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">snd_soc_dapm_type</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

	<span class="cm">/* codec stream completion event */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">stream_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_dapm_context</span> <span class="o">*</span><span class="n">dapm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">);</span>

	<span class="n">bool</span> <span class="n">ignore_pmdown_time</span><span class="p">;</span>  <span class="cm">/* Doesn&#39;t benefit from pmdown delay */</span>

	<span class="cm">/* probe ordering - for components with runtime dependencies */</span>
	<span class="kt">int</span> <span class="n">probe_order</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">remove_order</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* SoC platform interface */</span>
<span class="k">struct</span> <span class="n">snd_soc_platform_driver</span> <span class="p">{</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_platform</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_platform</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">dai</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">dai</span><span class="p">);</span>

	<span class="cm">/* pcm creation and destruction */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pcm_new</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_pcm_runtime</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pcm_free</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_pcm</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Default control and setup, added after probe() is run */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="o">*</span><span class="n">controls</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_controls</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_soc_dapm_widget</span> <span class="o">*</span><span class="n">dapm_widgets</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_dapm_widgets</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_soc_dapm_route</span> <span class="o">*</span><span class="n">dapm_routes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_dapm_routes</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For platform caused delay reporting.</span>
<span class="cm">	 * Optional.</span>
<span class="cm">	 */</span>
	<span class="n">snd_pcm_sframes_t</span> <span class="p">(</span><span class="o">*</span><span class="n">delay</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* platform stream ops */</span>
	<span class="k">struct</span> <span class="n">snd_pcm_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>

	<span class="cm">/* platform stream completion event */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">stream_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_dapm_context</span> <span class="o">*</span><span class="n">dapm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">);</span>

	<span class="cm">/* probe ordering - for components with runtime dependencies */</span>
	<span class="kt">int</span> <span class="n">probe_order</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">remove_order</span><span class="p">;</span>

	<span class="cm">/* platform IO - used for platform DAPM */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_platform</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_platform</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bespoke_trigger</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_soc_platform</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_soc_platform_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">suspended</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* platform is suspended */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">probed</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">card_list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">snd_soc_dapm_context</span> <span class="n">dapm</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_platform_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_dapm</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_soc_dai_link</span> <span class="p">{</span>
	<span class="cm">/* config - must be set by machine driver */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>			<span class="cm">/* Codec name */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">stream_name</span><span class="p">;</span>		<span class="cm">/* Stream name */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">codec_name</span><span class="p">;</span>		<span class="cm">/* for multi-codec */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">codec_of_node</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">platform_name</span><span class="p">;</span>	<span class="cm">/* for multi-platform */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">platform_of_node</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cpu_dai_name</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">cpu_dai_of_node</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">codec_dai_name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">be_id</span><span class="p">;</span>	<span class="cm">/* optional ID for machine driver BE identification */</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_soc_pcm_stream</span> <span class="o">*</span><span class="n">params</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dai_fmt</span><span class="p">;</span>           <span class="cm">/* format to set on init */</span>

	<span class="k">enum</span> <span class="n">snd_soc_dpcm_trigger</span> <span class="n">trigger</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/* trigger type for DPCM */</span>

	<span class="cm">/* Keep DAI active over suspend */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ignore_suspend</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Symmetry requirements */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">symmetric_rates</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Do not create a PCM for this DAI link (Backend link) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_pcm</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* This DAI link can route to other DAI links at runtime (Frontend)*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dynamic</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* pmdown_time is ignored at stop */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ignore_pmdown_time</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* codec/machine specific init - e.g. add machine controls */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_pcm_runtime</span> <span class="o">*</span><span class="n">rtd</span><span class="p">);</span>

	<span class="cm">/* optional hw_params re-writing for BE and FE sync */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">be_hw_params_fixup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_pcm_runtime</span> <span class="o">*</span><span class="n">rtd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>

	<span class="cm">/* machine stream operations */</span>
	<span class="k">struct</span> <span class="n">snd_soc_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_soc_codec_conf</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * optional map of kcontrol, widget and path name prefixes that are</span>
<span class="cm">	 * associated per device</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name_prefix</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * set this to the desired compression type if you want to</span>
<span class="cm">	 * override the one supplied in codec-&gt;driver-&gt;compress_type</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">snd_soc_compress_type</span> <span class="n">compress_type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_soc_aux_dev</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>		<span class="cm">/* Codec name */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">codec_name</span><span class="p">;</span>		<span class="cm">/* for multi-codec */</span>

	<span class="cm">/* codec/machine specific init - e.g. add machine controls */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_dapm_context</span> <span class="o">*</span><span class="n">dapm</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* SoC card */</span>
<span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">long_name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver_name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">snd_card</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">dapm_mutex</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">instantiated</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">late_probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">);</span>

	<span class="cm">/* the pre and post PM functions are used to do any PM work before and</span>
<span class="cm">	 * after the codec and DAI&#39;s do any PM work. */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend_pre</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend_post</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume_pre</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume_post</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">);</span>

	<span class="cm">/* callbacks */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_bias_level</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">snd_soc_dapm_context</span> <span class="o">*</span><span class="n">dapm</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">snd_soc_bias_level</span> <span class="n">level</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_bias_level_post</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">snd_soc_dapm_context</span> <span class="o">*</span><span class="n">dapm</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">snd_soc_bias_level</span> <span class="n">level</span><span class="p">);</span>

	<span class="kt">long</span> <span class="n">pmdown_time</span><span class="p">;</span>

	<span class="cm">/* CPU &lt;--&gt; Codec DAI links  */</span>
	<span class="k">struct</span> <span class="n">snd_soc_dai_link</span> <span class="o">*</span><span class="n">dai_link</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_links</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_soc_pcm_runtime</span> <span class="o">*</span><span class="n">rtd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_rtd</span><span class="p">;</span>

	<span class="cm">/* optional codec specific configuration */</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec_conf</span> <span class="o">*</span><span class="n">codec_conf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_configs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * optional auxiliary devices such as amplifiers or codecs with DAI</span>
<span class="cm">	 * link unused</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">snd_soc_aux_dev</span> <span class="o">*</span><span class="n">aux_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_aux_devs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_soc_pcm_runtime</span> <span class="o">*</span><span class="n">rtd_aux</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_aux_rtd</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="o">*</span><span class="n">controls</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_controls</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Card-specific routes and widgets.</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_soc_dapm_widget</span> <span class="o">*</span><span class="n">dapm_widgets</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_dapm_widgets</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_soc_dapm_route</span> <span class="o">*</span><span class="n">dapm_routes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_dapm_routes</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">fully_routed</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">deferred_resume_work</span><span class="p">;</span>

	<span class="cm">/* lists of probed devices belonging to this card */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">codec_dev_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">platform_dev_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dai_dev_list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">widgets</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">paths</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dapm_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dapm_dirty</span><span class="p">;</span>

	<span class="cm">/* Generic DAPM context for the card */</span>
	<span class="k">struct</span> <span class="n">snd_soc_dapm_context</span> <span class="n">dapm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_soc_dapm_stats</span> <span class="n">dapm_stats</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_card_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_pop_time</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">u32</span> <span class="n">pop_time</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">drvdata</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* SoC machine DAI configuration, glues a codec and cpu DAI together */</span>
<span class="k">struct</span> <span class="n">snd_soc_pcm_runtime</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_soc_dai_link</span> <span class="o">*</span><span class="n">dai_link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">pcm_mutex</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">snd_soc_pcm_subclass</span> <span class="n">pcm_subclass</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_pcm_ops</span> <span class="n">ops</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dev_registered</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Dynamic PCM BE runtime data */</span>
	<span class="k">struct</span> <span class="n">snd_soc_dpcm_runtime</span> <span class="n">dpcm</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="kt">long</span> <span class="n">pmdown_time</span><span class="p">;</span>

	<span class="cm">/* runtime devices */</span>
	<span class="k">struct</span> <span class="n">snd_pcm</span> <span class="o">*</span><span class="n">pcm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_soc_platform</span> <span class="o">*</span><span class="n">platform</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">codec_dai</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">cpu_dai</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">delayed_work</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_dpcm_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_dpcm_state</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* mixer control */</span>
<span class="k">struct</span> <span class="n">soc_mixer_control</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">platform_max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">rreg</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">rshift</span><span class="p">,</span> <span class="n">invert</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">soc_bytes</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_regs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* multi register control */</span>
<span class="k">struct</span> <span class="n">soc_mreg_control</span> <span class="p">{</span>
	<span class="kt">long</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">regbase</span><span class="p">,</span> <span class="n">regcount</span><span class="p">,</span> <span class="n">nbits</span><span class="p">,</span> <span class="n">invert</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* enumerated kcontrol */</span>
<span class="k">struct</span> <span class="n">soc_enum</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">shift_l</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">shift_r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">texts</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">values</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dapm</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* codec IO */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">snd_soc_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">snd_soc_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">snd_soc_bulk_write_raw</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* device driver data */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">snd_soc_card_set_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">drvdata</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">snd_soc_card_get_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">drvdata</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">snd_soc_codec_set_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">snd_soc_platform_set_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_platform</span> <span class="o">*</span><span class="n">platform</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">platform</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">snd_soc_platform_get_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_platform</span> <span class="o">*</span><span class="n">platform</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">platform</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">snd_soc_pcm_set_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_pcm_runtime</span> <span class="o">*</span><span class="n">rtd</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">rtd</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">snd_soc_pcm_get_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_pcm_runtime</span> <span class="o">*</span><span class="n">rtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">rtd</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">snd_soc_initialize_card_lists</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">dai_dev_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">codec_dev_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">platform_dev_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">widgets</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">paths</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">dapm_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">snd_soc_volsw_is_stereo</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_mixer_control</span> <span class="o">*</span><span class="n">mc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">==</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">rreg</span> <span class="o">&amp;&amp;</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">shift</span> <span class="o">==</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">rshift</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * mc-&gt;reg == mc-&gt;rreg &amp;&amp; mc-&gt;shift != mc-&gt;rshift, or</span>
<span class="cm">	 * mc-&gt;reg != mc-&gt;rreg means that the control is</span>
<span class="cm">	 * stereo (bits in one register or in two registers)</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">snd_soc_util_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">snd_soc_util_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">snd_soc_of_parse_card_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_soc_of_parse_audio_routing</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">);</span>

<span class="cp">#include &lt;sound/soc-dai.h&gt;</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">snd_soc_debugfs_root</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">snd_soc_pm_ops</span><span class="p">;</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
