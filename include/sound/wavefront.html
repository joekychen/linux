<!DOCTYPE html>
<html><head><title>joekychen/linux » include › sound › wavefront.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>wavefront.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __SOUND_WAVEFRONT_H__</span>
<span class="cp">#define __SOUND_WAVEFRONT_H__</span>

<span class="cm">/*</span>
<span class="cm"> *  Driver for Turtle Beach Wavefront cards (Maui,Tropez,Tropez+)</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) by Paul Barton-Davis &lt;pbd@op.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *   GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#if (!defined(__GNUC__) &amp;&amp; !defined(__GNUG__))</span>

     <span class="n">You</span> <span class="n">will</span> <span class="n">not</span> <span class="n">be</span> <span class="n">able</span> <span class="n">to</span> <span class="n">compile</span> <span class="n">this</span> <span class="n">file</span> <span class="n">correctly</span> <span class="n">without</span> <span class="n">gcc</span><span class="p">,</span> <span class="n">because</span>
     <span class="n">it</span> <span class="n">is</span> <span class="n">necessary</span> <span class="n">to</span> <span class="n">pack</span> <span class="n">the</span> <span class="s">&quot;wavefront_alias&quot;</span> <span class="n">structure</span> <span class="n">to</span> <span class="n">a</span> <span class="n">size</span>
     <span class="n">of</span> <span class="mi">22</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">corresponding</span> <span class="n">to</span> <span class="mi">16</span><span class="o">-</span><span class="n">bit</span> <span class="n">alignment</span> <span class="p">(</span><span class="n">as</span> <span class="n">would</span> <span class="n">have</span> <span class="n">been</span>
     <span class="n">the</span> <span class="k">case</span> <span class="n">on</span> <span class="n">the</span> <span class="n">original</span> <span class="n">platform</span><span class="p">,</span> <span class="n">MS</span><span class="o">-</span><span class="n">DOS</span><span class="p">).</span> <span class="n">If</span> <span class="n">this</span> <span class="n">is</span> <span class="n">not</span> <span class="n">done</span><span class="p">,</span>
     <span class="n">then</span> <span class="n">WavePatch</span><span class="o">-</span><span class="n">format</span> <span class="n">files</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">read</span><span class="o">/</span><span class="n">written</span> <span class="n">correctly</span><span class="p">.</span>
     <span class="n">The</span> <span class="n">method</span> <span class="n">used</span> <span class="n">to</span> <span class="k">do</span> <span class="n">this</span> <span class="n">here</span> <span class="p">(</span><span class="s">&quot;__attribute__((packed)&quot;</span><span class="p">)</span> <span class="n">is</span>
     <span class="n">completely</span> <span class="n">compiler</span> <span class="n">dependent</span><span class="p">.</span>
     
     <span class="n">All</span> <span class="n">other</span> <span class="n">wavefront_</span><span class="o">*</span> <span class="n">types</span> <span class="n">end</span> <span class="n">up</span> <span class="n">aligned</span> <span class="n">to</span> <span class="mi">32</span> <span class="n">bit</span> <span class="n">values</span> <span class="n">and</span>
     <span class="n">still</span> <span class="n">have</span> <span class="n">the</span> <span class="n">same</span> <span class="p">(</span><span class="n">correct</span><span class="p">)</span> <span class="n">size</span><span class="p">.</span>

<span class="cp">#else</span>

     <span class="cm">/* However, note that as of G++ 2.7.3.2, g++ was unable to</span>
<span class="cm">	correctly parse *type* __attribute__ tags. It will do the</span>
<span class="cm">	right thing if we use the &quot;packed&quot; attribute on each struct</span>
<span class="cm">	member, which has the same semantics anyway. </span>
<span class="cm">     */</span>

<span class="cp">#endif </span><span class="cm">/* __GNUC__ */</span><span class="cp"></span>

<span class="cm">/***************************** WARNING ********************************</span>
<span class="cm">  PLEASE DO NOT MODIFY THIS FILE IN ANY WAY THAT AFFECTS ITS ABILITY TO </span>
<span class="cm">  BE USED WITH EITHER C *OR* C++.</span>
<span class="cm"> **********************************************************************/</span>

<span class="cp">#ifndef NUM_MIDIKEYS </span>
<span class="cp">#define NUM_MIDIKEYS 128</span>
<span class="cp">#endif  </span><span class="cm">/* NUM_MIDIKEYS */</span><span class="cp"></span>

<span class="cp">#ifndef NUM_MIDICHANNELS</span>
<span class="cp">#define NUM_MIDICHANNELS 16</span>
<span class="cp">#endif  </span><span class="cm">/* NUM_MIDICHANNELS */</span><span class="cp"></span>

<span class="cm">/* These are very useful/important. the original wavefront interface</span>
<span class="cm">   was developed on a 16 bit system, where sizeof(int) = 2</span>
<span class="cm">   bytes. Defining things like this makes the code much more portable, and</span>
<span class="cm">   easier to understand without having to toggle back and forth</span>
<span class="cm">   between a 16-bit view of the world and a 32-bit one. </span>
<span class="cm"> */</span>   

<span class="cp">#ifndef __KERNEL__</span>
<span class="cm">/* keep them for compatibility */</span>
<span class="k">typedef</span> <span class="kt">short</span> <span class="n">s16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">u16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">s32</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">u32</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">char</span> <span class="n">s8</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">u8</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">s16</span> <span class="n">INT16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">u16</span> <span class="n">UINT16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">s32</span> <span class="n">INT32</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">u32</span> <span class="n">UINT32</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">s8</span> <span class="n">CHAR8</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">u8</span> <span class="n">UCHAR8</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/* Pseudo-commands not part of the WaveFront command set.</span>
<span class="cm">   These are used for various driver controls and direct</span>
<span class="cm">   hardware control.</span>
<span class="cm"> */</span>

<span class="cp">#define WFC_DEBUG_DRIVER                0</span>
<span class="cp">#define WFC_FX_IOCTL                    1</span>
<span class="cp">#define WFC_PATCH_STATUS                2</span>
<span class="cp">#define WFC_PROGRAM_STATUS              3</span>
<span class="cp">#define WFC_SAMPLE_STATUS               4</span>
<span class="cp">#define WFC_DISABLE_INTERRUPTS          5</span>
<span class="cp">#define WFC_ENABLE_INTERRUPTS           6</span>
<span class="cp">#define WFC_INTERRUPT_STATUS            7</span>
<span class="cp">#define WFC_ROMSAMPLES_RDONLY           8</span>
<span class="cp">#define WFC_IDENTIFY_SLOT_TYPE          9</span>

<span class="cm">/* Wavefront synth commands</span>
<span class="cm"> */</span>

<span class="cp">#define WFC_DOWNLOAD_SAMPLE		0x80</span>
<span class="cp">#define WFC_DOWNLOAD_BLOCK		0x81</span>
<span class="cp">#define WFC_DOWNLOAD_MULTISAMPLE	0x82</span>
<span class="cp">#define WFC_DOWNLOAD_SAMPLE_ALIAS	0x83</span>
<span class="cp">#define WFC_DELETE_SAMPLE		0x84</span>
<span class="cp">#define WFC_REPORT_FREE_MEMORY		0x85</span>
<span class="cp">#define WFC_DOWNLOAD_PATCH		0x86</span>
<span class="cp">#define WFC_DOWNLOAD_PROGRAM		0x87</span>
<span class="cp">#define WFC_SET_SYNTHVOL		0x89</span>
<span class="cp">#define WFC_SET_NVOICES			0x8B</span>
<span class="cp">#define WFC_DOWNLOAD_DRUM		0x90</span>
<span class="cp">#define WFC_GET_SYNTHVOL		0x92</span>
<span class="cp">#define WFC_GET_NVOICES			0x94</span>
<span class="cp">#define WFC_DISABLE_CHANNEL		0x9A</span>
<span class="cp">#define WFC_ENABLE_CHANNEL		0x9B</span>
<span class="cp">#define WFC_MISYNTH_OFF			0x9D</span>
<span class="cp">#define WFC_MISYNTH_ON			0x9E</span>
<span class="cp">#define WFC_FIRMWARE_VERSION		0x9F</span>
<span class="cp">#define WFC_GET_NSAMPLES		0xA0</span>
<span class="cp">#define WFC_DISABLE_DRUM_PROGRAM	0xA2</span>
<span class="cp">#define WFC_UPLOAD_PATCH		0xA3</span>
<span class="cp">#define WFC_UPLOAD_PROGRAM		0xA4</span>
<span class="cp">#define WFC_SET_TUNING			0xA6</span>
<span class="cp">#define WFC_GET_TUNING			0xA7</span>
<span class="cp">#define WFC_VMIDI_ON			0xA8</span>
<span class="cp">#define WFC_VMIDI_OFF			0xA9</span>
<span class="cp">#define WFC_MIDI_STATUS			0xAA</span>
<span class="cp">#define WFC_GET_CHANNEL_STATUS		0xAB</span>
<span class="cp">#define WFC_DOWNLOAD_SAMPLE_HEADER	0xAC</span>
<span class="cp">#define WFC_UPLOAD_SAMPLE_HEADER	0xAD</span>
<span class="cp">#define WFC_UPLOAD_MULTISAMPLE		0xAE</span>
<span class="cp">#define WFC_UPLOAD_SAMPLE_ALIAS		0xAF</span>
<span class="cp">#define WFC_IDENTIFY_SAMPLE_TYPE	0xB0</span>
<span class="cp">#define WFC_DOWNLOAD_EDRUM_PROGRAM	0xB1</span>
<span class="cp">#define WFC_UPLOAD_EDRUM_PROGRAM	0xB2</span>
<span class="cp">#define WFC_SET_EDRUM_CHANNEL		0xB3</span>
<span class="cp">#define WFC_INSTOUT_LEVELS		0xB4</span>
<span class="cp">#define WFC_PEAKOUT_LEVELS		0xB5</span>
<span class="cp">#define WFC_REPORT_CHANNEL_PROGRAMS	0xB6</span>
<span class="cp">#define WFC_HARDWARE_VERSION		0xCF</span>
<span class="cp">#define WFC_UPLOAD_SAMPLE_PARAMS	0xD7</span>
<span class="cp">#define WFC_DOWNLOAD_OS			0xF1</span>
<span class="cp">#define WFC_NOOP                        0xFF</span>

<span class="cp">#define WF_MAX_SAMPLE   512</span>
<span class="cp">#define WF_MAX_PATCH    256</span>
<span class="cp">#define WF_MAX_PROGRAM  128</span>

<span class="cp">#define WF_SECTION_MAX  44   </span><span class="cm">/* longest OS section length */</span><span class="cp"></span>

<span class="cm">/* # of bytes we send to the board when sending it various kinds of</span>
<span class="cm">   substantive data, such as samples, patches and programs.</span>
<span class="cm">*/</span>

<span class="cp">#define WF_PROGRAM_BYTES 32</span>
<span class="cp">#define WF_PATCH_BYTES 132</span>
<span class="cp">#define WF_SAMPLE_BYTES 27</span>
<span class="cp">#define WF_SAMPLE_HDR_BYTES 25</span>
<span class="cp">#define WF_ALIAS_BYTES 25</span>
<span class="cp">#define WF_DRUM_BYTES 9</span>
<span class="cp">#define WF_MSAMPLE_BYTES 259 </span><span class="cm">/* (MIDI_KEYS * 2) + 3 */</span><span class="cp"></span>

<span class="cp">#define WF_ACK     0x80</span>
<span class="cp">#define WF_DMA_ACK 0x81</span>

<span class="cm">/* OR-values for MIDI status bits */</span>

<span class="cp">#define WF_MIDI_VIRTUAL_ENABLED 0x1</span>
<span class="cp">#define WF_MIDI_VIRTUAL_IS_EXTERNAL 0x2</span>
<span class="cp">#define WF_MIDI_IN_TO_SYNTH_DISABLED 0x4</span>

<span class="cm">/* slot indexes for struct address_info: makes code a little more mnemonic */</span>

<span class="cp">#define WF_SYNTH_SLOT         0</span>
<span class="cp">#define WF_INTERNAL_MIDI_SLOT 1</span>
<span class="cp">#define WF_EXTERNAL_MIDI_SLOT 2</span>

<span class="cm">/* Magic MIDI bytes used to switch I/O streams on the ICS2115 MPU401</span>
<span class="cm">   emulation. Note these NEVER show up in output from the device and</span>
<span class="cm">   should NEVER be used in input unless Virtual MIDI mode has been </span>
<span class="cm">   disabled. If they do show up as input, the results are unpredictable.</span>
<span class="cm">*/</span>

<span class="cp">#define WF_EXTERNAL_SWITCH  0xFD</span>
<span class="cp">#define WF_INTERNAL_SWITCH  0xF9</span>

<span class="cm">/* Debugging flags */</span>

<span class="cp">#define WF_DEBUG_CMD 0x1</span>
<span class="cp">#define WF_DEBUG_DATA 0x2</span>
<span class="cp">#define WF_DEBUG_LOAD_PATCH 0x4</span>
<span class="cp">#define WF_DEBUG_IO 0x8</span>

<span class="cm">/* WavePatch file format stuff */</span>

<span class="cp">#define WF_WAVEPATCH_VERSION     120;  </span><span class="cm">/*  Current version number (1.2)  */</span><span class="cp"></span>
<span class="cp">#define WF_MAX_COMMENT           64    </span><span class="cm">/*  Comment length */</span><span class="cp"></span>
<span class="cp">#define WF_NUM_LAYERS            4</span>
<span class="cp">#define WF_NAME_LENGTH           32</span>
<span class="cp">#define WF_SOURCE_LENGTH         260</span>

<span class="cp">#define BankFileID     &quot;Bank&quot;</span>
<span class="cp">#define DrumkitFileID  &quot;DrumKit&quot;</span>
<span class="cp">#define ProgramFileID  &quot;Program&quot;</span>

<span class="k">struct</span> <span class="n">wf_envelope</span>
<span class="p">{</span>
    <span class="n">u8</span> <span class="n">attack_time</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused1</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">decay1_time</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">decay2_time</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused3</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">sustain_time</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused4</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">release_time</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused5</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">release2_time</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused6</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">s8</span> <span class="n">attack_level</span><span class="p">;</span>
    <span class="n">s8</span> <span class="n">decay1_level</span><span class="p">;</span>
    <span class="n">s8</span> <span class="n">decay2_level</span><span class="p">;</span>
    <span class="n">s8</span> <span class="n">sustain_level</span><span class="p">;</span>
    <span class="n">s8</span> <span class="n">release_level</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">attack_velocity</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused7</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">volume_velocity</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused8</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">keyboard_scaling</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused9</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wf_envelope</span> <span class="n">wavefront_envelope</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">wf_lfo</span>
<span class="p">{</span>
    <span class="n">u8</span> <span class="n">sample_number</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">frequency</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused1</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">am_src</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">fm_src</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>

    <span class="n">s8</span> <span class="n">fm_amount</span><span class="p">;</span>
    <span class="n">s8</span> <span class="n">am_amount</span><span class="p">;</span>
    <span class="n">s8</span> <span class="n">start_level</span><span class="p">;</span>
    <span class="n">s8</span> <span class="n">end_level</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">ramp_delay</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">wave_restart</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* for LFO2 only */</span>

    <span class="n">u8</span> <span class="n">ramp_time</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wf_lfo</span> <span class="n">wavefront_lfo</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">wf_patch</span>
<span class="p">{</span>
    <span class="n">s16</span>  <span class="n">frequency_bias</span><span class="p">;</span>         <span class="cm">/*  ** THIS IS IN MOTOROLA FORMAT!! ** */</span>

    <span class="n">u8</span> <span class="n">amplitude_bias</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused1</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">portamento</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">sample_number</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">pitch_bend</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">sample_msb</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused3</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">mono</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">retrigger</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">nohold</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">restart</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">filterconfig</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span> <span class="cm">/* SDK says &quot;not used&quot; */</span>
    <span class="n">u8</span> <span class="n">reuse</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">reset_lfo</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>    

    <span class="n">u8</span> <span class="n">fm_src2</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">fm_src1</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>   

    <span class="n">s8</span> <span class="n">fm_amount1</span><span class="p">;</span>
    <span class="n">s8</span> <span class="n">fm_amount2</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">am_src</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused4</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>

    <span class="n">s8</span> <span class="n">am_amount</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">fc1_mode</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">fc2_mode</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>

    <span class="n">s8</span> <span class="n">fc1_mod_amount</span><span class="p">;</span>
    <span class="n">s8</span> <span class="n">fc1_keyboard_scaling</span><span class="p">;</span>
    <span class="n">s8</span> <span class="n">fc1_bias</span><span class="p">;</span>
    <span class="n">s8</span> <span class="n">fc2_mod_amount</span><span class="p">;</span>
    <span class="n">s8</span> <span class="n">fc2_keyboard_scaling</span><span class="p">;</span>
    <span class="n">s8</span> <span class="n">fc2_bias</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">randomizer</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused5</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">wf_envelope</span> <span class="n">envelope1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">wf_envelope</span> <span class="n">envelope2</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">wf_lfo</span> <span class="n">lfo1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">wf_lfo</span> <span class="n">lfo2</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wf_patch</span> <span class="n">wavefront_patch</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">wf_layer</span>
<span class="p">{</span>
    <span class="n">u8</span> <span class="n">patch_number</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">mix_level</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">mute</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">split_point</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">play_below</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">pan_mod_src</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">pan_or_mod</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">pan</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">split_type</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wf_layer</span> <span class="n">wavefront_layer</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">wf_program</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">wf_layer</span> <span class="n">layer</span><span class="p">[</span><span class="n">WF_NUM_LAYERS</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wf_program</span> <span class="n">wavefront_program</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">wf_sample_offset</span>
<span class="p">{</span>
    <span class="n">s32</span> <span class="n">Fraction</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">s32</span> <span class="n">Integer</span><span class="o">:</span><span class="mi">20</span><span class="p">;</span>
    <span class="n">s32</span> <span class="n">Unused</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wf_sample_offset</span> <span class="n">wavefront_sample_offset</span><span class="p">;</span>          
     
<span class="cm">/* Sample slot types */</span>

<span class="cp">#define WF_ST_SAMPLE      0</span>
<span class="cp">#define WF_ST_MULTISAMPLE 1</span>
<span class="cp">#define WF_ST_ALIAS       2</span>
<span class="cp">#define WF_ST_EMPTY       3</span>

<span class="cm">/* pseudo&#39;s */</span>

<span class="cp">#define WF_ST_DRUM        4</span>
<span class="cp">#define WF_ST_PROGRAM     5</span>
<span class="cp">#define WF_ST_PATCH       6</span>
<span class="cp">#define WF_ST_SAMPLEHDR   7</span>

<span class="cp">#define WF_ST_MASK        0xf</span>

<span class="cm">/* Flags for slot status. These occupy the upper bits of the same byte</span>
<span class="cm">   as a sample type.</span>
<span class="cm">*/</span>

<span class="cp">#define WF_SLOT_USED      0x80   </span><span class="cm">/* XXX don&#39;t rely on this being accurate */</span><span class="cp"></span>
<span class="cp">#define WF_SLOT_FILLED    0x40</span>
<span class="cp">#define WF_SLOT_ROM       0x20</span>

<span class="cp">#define WF_SLOT_MASK      0xf0</span>

<span class="cm">/* channel constants */</span>

<span class="cp">#define WF_CH_MONO  0</span>
<span class="cp">#define WF_CH_LEFT  1</span>
<span class="cp">#define WF_CH_RIGHT 2</span>

<span class="cm">/* Sample formats */</span>

<span class="cp">#define LINEAR_16BIT 0</span>
<span class="cp">#define WHITE_NOISE  1</span>
<span class="cp">#define LINEAR_8BIT  2</span>
<span class="cp">#define MULAW_8BIT   3</span>

<span class="cp">#define WF_SAMPLE_IS_8BIT(smpl) ((smpl)-&gt;SampleResolution&amp;2)</span>


<span class="cm">/* </span>

<span class="cm">  Because most/all of the sample data we pass in via pointers has</span>
<span class="cm">  never been copied (just mmap-ed into user space straight from the</span>
<span class="cm">  disk), it would be nice to allow handling of multi-channel sample</span>
<span class="cm">  data without forcing user-level extraction of the relevant bytes.</span>
<span class="cm">  </span>
<span class="cm">  So, we need a way of specifying which channel to use (the WaveFront</span>
<span class="cm">  only handles mono samples in a given slot), and the only way to do</span>
<span class="cm">  this without using some struct other than wavefront_sample as the</span>
<span class="cm">  interface is the awful hack of using the unused bits in a</span>
<span class="cm">  wavefront_sample:</span>
<span class="cm">  </span>
<span class="cm">  Val      Meaning</span>
<span class="cm">  ---      -------</span>
<span class="cm">  0        no channel selection (use channel 1, sample is MONO)</span>
<span class="cm">  1        use first channel, and skip one</span>
<span class="cm">  2        use second channel, and skip one</span>
<span class="cm">  3        use third channel, and skip two</span>
<span class="cm">  4        use fourth channel, skip three</span>
<span class="cm">  5        use fifth channel, skip four</span>
<span class="cm">  6        use six channel, skip five</span>


<span class="cm">  This can handle up to 4 channels, and anyone downloading &gt;4 channels</span>
<span class="cm">  of sample data just to select one of them needs to find some tools</span>
<span class="cm">  like sox ...</span>

<span class="cm">  NOTE: values 0, 1 and 2 correspond to WF_CH_* above. This is </span>
<span class="cm">  important.</span>

<span class="cm">*/</span>

<span class="cp">#define WF_SET_CHANNEL(samp,chn) \</span>
<span class="cp"> (samp)-&gt;Unused1 = chn &amp; 0x1; \</span>
<span class="cp"> (samp)-&gt;Unused2 = chn &amp; 0x2; \</span>
<span class="cp"> (samp)-&gt;Unused3 = chn &amp; 0x4 </span>
  
<span class="cp">#define WF_GET_CHANNEL(samp) \</span>
<span class="cp">  (((samp)-&gt;Unused3 &lt;&lt; 2)|((samp)-&gt;Unused2&lt;&lt;1)|(samp)-&gt;Unused1)</span>
  
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wf_sample</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">wf_sample_offset</span> <span class="n">sampleStartOffset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">wf_sample_offset</span> <span class="n">loopStartOffset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">wf_sample_offset</span> <span class="n">loopEndOffset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">wf_sample_offset</span> <span class="n">sampleEndOffset</span><span class="p">;</span>
    <span class="n">s16</span> <span class="n">FrequencyBias</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">SampleResolution</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>  <span class="cm">/* sample_format */</span>
    <span class="n">u8</span> <span class="n">Unused1</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Loop</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Bidirectional</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Reverse</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused3</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">wavefront_sample</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wf_multisample</span> <span class="p">{</span>
    <span class="n">s16</span> <span class="n">NumberOfSamples</span><span class="p">;</span>   <span class="cm">/* log2 of the number of samples */</span>
    <span class="n">s16</span> <span class="n">SampleNumber</span><span class="p">[</span><span class="n">NUM_MIDIKEYS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">wavefront_multisample</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wf_alias</span> <span class="p">{</span>
    <span class="n">s16</span> <span class="n">OriginalSample</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">wf_sample_offset</span> <span class="n">sampleStartOffset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">wf_sample_offset</span> <span class="n">loopStartOffset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">wf_sample_offset</span> <span class="n">sampleEndOffset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">wf_sample_offset</span> <span class="n">loopEndOffset</span><span class="p">;</span>

    <span class="n">s16</span>  <span class="n">FrequencyBias</span><span class="p">;</span>

    <span class="n">u8</span> <span class="n">SampleResolution</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused1</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Loop</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Bidirectional</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Reverse</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused3</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    
    <span class="cm">/* This structure is meant to be padded only to 16 bits on their</span>
<span class="cm">       original. Of course, whoever wrote their documentation didn&#39;t</span>
<span class="cm">       realize that sizeof(struct) can be &gt;=</span>
<span class="cm">       sum(sizeof(struct-fields)) and so thought that giving a C level</span>
<span class="cm">       description of the structs used in WavePatch files was</span>
<span class="cm">       sufficient. I suppose it was, as long as you remember the </span>
<span class="cm">       standard 16-&gt;32 bit issues.</span>
<span class="cm">    */</span>

    <span class="n">u8</span> <span class="n">sixteen_bit_padding</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">wavefront_alias</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wf_drum</span> <span class="p">{</span>
    <span class="n">u8</span> <span class="n">PatchNumber</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">MixLevel</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unmute</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Group</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused1</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">PanModSource</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">PanModulated</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">PanAmount</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">u8</span> <span class="n">Unused2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">wavefront_drum</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wf_drumkit</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">wf_drum</span> <span class="n">drum</span><span class="p">[</span><span class="n">NUM_MIDIKEYS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">wavefront_drumkit</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wf_channel_programs</span> <span class="p">{</span>
    <span class="n">u8</span> <span class="n">Program</span><span class="p">[</span><span class="n">NUM_MIDICHANNELS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">wavefront_channel_programs</span><span class="p">;</span>

<span class="cm">/* How to get MIDI channel status from the data returned by</span>
<span class="cm">   a WFC_GET_CHANNEL_STATUS command (a struct wf_channel_programs)</span>
<span class="cm">*/</span>

<span class="cp">#define WF_CHANNEL_STATUS(ch,wcp) (wcp)[(ch/7)] &amp; (1&lt;&lt;((ch)%7))</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">wf_any</span> <span class="p">{</span>
    <span class="n">wavefront_sample</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">wavefront_multisample</span> <span class="n">ms</span><span class="p">;</span>
    <span class="n">wavefront_alias</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">wavefront_program</span> <span class="n">pr</span><span class="p">;</span>
    <span class="n">wavefront_patch</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">wavefront_drum</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span> <span class="n">wavefront_any</span><span class="p">;</span>

<span class="cm">/* Hannu Solvainen hoped that his &quot;patch_info&quot; struct in soundcard.h</span>
<span class="cm">   might work for other wave-table based patch loading situations.</span>
<span class="cm">   Alas, his fears were correct. The WaveFront doesn&#39;t even come with</span>
<span class="cm">   just &quot;patches&quot;, but several different kind of structures that</span>
<span class="cm">   control the sound generation process.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wf_patch_info</span> <span class="p">{</span>
    
    <span class="cm">/* the first two fields are used by the OSS &quot;patch loading&quot; interface</span>
<span class="cm">       only, and are unused by the current user-level library.</span>
<span class="cm">    */</span>

    <span class="n">s16</span>   <span class="n">key</span><span class="p">;</span>               <span class="cm">/* Use WAVEFRONT_PATCH here */</span>
    <span class="n">u16</span>  <span class="n">devno</span><span class="p">;</span>             <span class="cm">/* fill in when sending */</span>
    <span class="n">u8</span>  <span class="n">subkey</span><span class="p">;</span>            <span class="cm">/* WF_ST_{SAMPLE,ALIAS,etc.} */</span>

<span class="cp">#define WAVEFRONT_FIND_FREE_SAMPLE_SLOT 999</span>

    <span class="n">u16</span>  <span class="n">number</span><span class="p">;</span>            <span class="cm">/* patch/sample/prog number */</span>

    <span class="n">u32</span>  <span class="n">size</span><span class="p">;</span>              <span class="cm">/* size of any data included in </span>
<span class="cm">				  one of the fields in `hdrptr&#39;, or</span>
<span class="cm">				  as `dataptr&#39;.</span>

<span class="cm">				  NOTE: for actual samples, this is</span>
<span class="cm">				  the size of the *SELECTED CHANNEL*</span>
<span class="cm">				  even if more data is actually available.</span>
<span class="cm">				  </span>
<span class="cm">				  So, a stereo sample (2 channels) of</span>
<span class="cm">				  6000 bytes total has `size&#39; = 3000.</span>

<span class="cm">				  See the macros and comments for</span>
<span class="cm">				  WF_{GET,SET}_CHANNEL above.</span>

<span class="cm">			       */</span>
    <span class="n">wavefront_any</span> <span class="n">__user</span> <span class="o">*</span><span class="n">hdrptr</span><span class="p">;</span>      <span class="cm">/* user-space ptr to hdr bytes */</span>
    <span class="n">u16</span> <span class="n">__user</span> <span class="o">*</span><span class="n">dataptr</span><span class="p">;</span>            <span class="cm">/* actual sample data */</span>

    <span class="n">wavefront_any</span> <span class="n">hdr</span><span class="p">;</span>          <span class="cm">/* kernel-space copy of hdr bytes */</span>         
<span class="p">}</span> <span class="n">wavefront_patch_info</span><span class="p">;</span>

<span class="cm">/* The maximum number of bytes we will ever move to or from user space</span>
<span class="cm">   in response to a WFC_* command.  This obviously doesn&#39;t cover</span>
<span class="cm">   actual sample data.</span>
<span class="cm">*/</span>

<span class="cp">#define WF_MAX_READ sizeof(wavefront_multisample)</span>
<span class="cp">#define WF_MAX_WRITE sizeof(wavefront_multisample)</span>

<span class="cm">/*</span>
<span class="cm">   This allows us to execute any WF command except the download/upload</span>
<span class="cm">   ones, which are handled differently due to copyin/copyout issues as</span>
<span class="cm">   well as data-nybbling to/from the card.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wavefront_control</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">cmd</span><span class="p">;</span>                           <span class="cm">/* WFC_* */</span>
    <span class="kt">char</span> <span class="n">status</span><span class="p">;</span>                       <span class="cm">/* return status to user-space */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">rbuf</span><span class="p">[</span><span class="n">WF_MAX_READ</span><span class="p">];</span>   <span class="cm">/* bytes read from card */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">wbuf</span><span class="p">[</span><span class="n">WF_MAX_WRITE</span><span class="p">];</span>  <span class="cm">/* bytes written to card */</span>
<span class="p">}</span> <span class="n">wavefront_control</span><span class="p">;</span>

<span class="cp">#define WFCTL_WFCMD    0x1</span>
<span class="cp">#define WFCTL_LOAD_SPP 0x2</span>

<span class="cm">/* Modulator table */</span>

<span class="cp">#define WF_MOD_LFO1      0</span>
<span class="cp">#define WF_MOD_LFO2      1</span>
<span class="cp">#define WF_MOD_ENV1      2</span>
<span class="cp">#define WF_MOD_ENV2      3</span>
<span class="cp">#define WF_MOD_KEYBOARD  4</span>
<span class="cp">#define WF_MOD_LOGKEY    5</span>
<span class="cp">#define WF_MOD_VELOCITY  6</span>
<span class="cp">#define WF_MOD_LOGVEL    7</span>
<span class="cp">#define WF_MOD_RANDOM    8</span>
<span class="cp">#define WF_MOD_PRESSURE  9</span>
<span class="cp">#define WF_MOD_MOD_WHEEL 10</span>
<span class="cp">#define WF_MOD_1         WF_MOD_MOD_WHEEL </span>
<span class="cp">#define WF_MOD_BREATH    11</span>
<span class="cp">#define WF_MOD_2         WF_MOD_BREATH</span>
<span class="cp">#define WF_MOD_FOOT      12</span>
<span class="cp">#define WF_MOD_4         WF_MOD_FOOT</span>
<span class="cp">#define WF_MOD_VOLUME    13</span>
<span class="cp">#define WF_MOD_7         WF_MOD_VOLUME</span>
<span class="cp">#define WF_MOD_PAN       14</span>
<span class="cp">#define WF_MOD_10        WF_MOD_PAN</span>
<span class="cp">#define WF_MOD_EXPR      15</span>
<span class="cp">#define WF_MOD_11        WF_MOD_EXPR</span>

<span class="cm">/* FX-related material */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wf_fx_info</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">request</span><span class="p">;</span>             <span class="cm">/* see list below */</span>
    <span class="kt">long</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>             <span class="cm">/* we don&#39;t need much */</span>
<span class="p">}</span> <span class="n">wavefront_fx_info</span><span class="p">;</span>

<span class="cm">/* support for each of these will be forthcoming once I or someone </span>
<span class="cm">   else has figured out which of the addresses on page 6 and page 7 of </span>
<span class="cm">   the YSS225 control each parameter. Incidentally, these come from</span>
<span class="cm">   the Windows driver interface, but again, Turtle Beach didn&#39;t</span>
<span class="cm">   document the API to use them.</span>
<span class="cm">*/</span>

<span class="cp">#define WFFX_SETOUTGAIN		        0</span>
<span class="cp">#define WFFX_SETSTEREOOUTGAIN		1</span>
<span class="cp">#define WFFX_SETREVERBIN1GAIN		2</span>
<span class="cp">#define WFFX_SETREVERBIN2GAIN		3</span>
<span class="cp">#define WFFX_SETREVERBIN3GAIN		4</span>
<span class="cp">#define WFFX_SETCHORUSINPORT		5</span>
<span class="cp">#define WFFX_SETREVERBIN1PORT		6</span>
<span class="cp">#define WFFX_SETREVERBIN2PORT		7</span>
<span class="cp">#define WFFX_SETREVERBIN3PORT		8</span>
<span class="cp">#define WFFX_SETEFFECTPORT		9</span>
<span class="cp">#define WFFX_SETAUXPORT		        10</span>
<span class="cp">#define WFFX_SETREVERBTYPE		11</span>
<span class="cp">#define WFFX_SETREVERBDELAY		12</span>
<span class="cp">#define WFFX_SETCHORUSLFO		13</span>
<span class="cp">#define WFFX_SETCHORUSPMD		14</span>
<span class="cp">#define WFFX_SETCHORUSAMD		15</span>
<span class="cp">#define WFFX_SETEFFECT		        16</span>
<span class="cp">#define WFFX_SETBASEALL		        17</span>
<span class="cp">#define WFFX_SETREVERBALL		18</span>
<span class="cp">#define WFFX_SETCHORUSALL		20</span>
<span class="cp">#define WFFX_SETREVERBDEF		22</span>
<span class="cp">#define WFFX_SETCHORUSDEF		23</span>
<span class="cp">#define WFFX_DELAYSETINGAIN		24</span>
<span class="cp">#define WFFX_DELAYSETFBGAIN	        25</span>
<span class="cp">#define WFFX_DELAYSETFBLPF		26</span>
<span class="cp">#define WFFX_DELAYSETGAIN		27</span>
<span class="cp">#define WFFX_DELAYSETTIME		28</span>
<span class="cp">#define WFFX_DELAYSETFBTIME		29</span>
<span class="cp">#define WFFX_DELAYSETALL		30</span>
<span class="cp">#define WFFX_DELAYSETDEF		32</span>
<span class="cp">#define WFFX_SDELAYSETINGAIN		33</span>
<span class="cp">#define WFFX_SDELAYSETFBGAIN		34</span>
<span class="cp">#define WFFX_SDELAYSETFBLPF		35</span>
<span class="cp">#define WFFX_SDELAYSETGAIN		36</span>
<span class="cp">#define WFFX_SDELAYSETTIME		37</span>
<span class="cp">#define WFFX_SDELAYSETFBTIME		38</span>
<span class="cp">#define WFFX_SDELAYSETALL		39</span>
<span class="cp">#define WFFX_SDELAYSETDEF		41</span>
<span class="cp">#define WFFX_DEQSETINGAIN		42</span>
<span class="cp">#define WFFX_DEQSETFILTER		43</span>
<span class="cp">#define WFFX_DEQSETALL		        44</span>
<span class="cp">#define WFFX_DEQSETDEF		        46</span>
<span class="cp">#define WFFX_MUTE		        47</span>
<span class="cp">#define WFFX_FLANGESETBALANCE	        48	</span>
<span class="cp">#define WFFX_FLANGESETDELAY		49</span>
<span class="cp">#define WFFX_FLANGESETDWFFX_TH		50</span>
<span class="cp">#define WFFX_FLANGESETFBGAIN		51</span>
<span class="cp">#define WFFX_FLANGESETINGAIN		52</span>
<span class="cp">#define WFFX_FLANGESETLFO		53</span>
<span class="cp">#define WFFX_FLANGESETALL		54</span>
<span class="cp">#define WFFX_FLANGESETDEF		56</span>
<span class="cp">#define WFFX_PITCHSETSHIFT		57</span>
<span class="cp">#define WFFX_PITCHSETBALANCE		58</span>
<span class="cp">#define WFFX_PITCHSETALL		59</span>
<span class="cp">#define WFFX_PITCHSETDEF		61</span>
<span class="cp">#define WFFX_SRSSETINGAIN		62</span>
<span class="cp">#define WFFX_SRSSETSPACE		63</span>
<span class="cp">#define WFFX_SRSSETCENTER		64</span>
<span class="cp">#define WFFX_SRSSETGAIN		        65</span>
<span class="cp">#define WFFX_SRSSETMODE	        	66</span>
<span class="cp">#define WFFX_SRSSETDEF		        68</span>

<span class="cm">/* Allow direct user-space control over FX memory/coefficient data.</span>
<span class="cm">   In theory this could be used to download the FX microprogram,</span>
<span class="cm">   but it would be a little slower, and involve some weird code.</span>
<span class="cm"> */</span>

<span class="cp">#define WFFX_MEMSET              69</span>

<span class="cp">#endif </span><span class="cm">/* __SOUND_WAVEFRONT_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
