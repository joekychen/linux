<!DOCTYPE html>
<html><head><title>joekychen/linux » include › sound › vx_core.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>vx_core.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Driver for Digigram VX soundcards</span>
<span class="cm"> *</span>
<span class="cm"> * Hardware core part</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2002 by Takashi Iwai &lt;tiwai@suse.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *   GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __SOUND_VX_COMMON_H</span>
<span class="cp">#define __SOUND_VX_COMMON_H</span>

<span class="cp">#include &lt;sound/pcm.h&gt;</span>
<span class="cp">#include &lt;sound/hwdep.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>

<span class="cp">#if defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE)</span>
<span class="cp">#if !defined(CONFIG_USE_VXLOADER) &amp;&amp; !defined(CONFIG_SND_VX_LIB) </span><span class="cm">/* built-in kernel */</span><span class="cp"></span>
<span class="cp">#define SND_VX_FW_LOADER	</span><span class="cm">/* use the standard firmware loader */</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">firmware</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>

<span class="cp">#define VX_DRIVER_VERSION	0x010000	</span><span class="cm">/* 1.0.0 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> */</span>
<span class="cp">#define SIZE_MAX_CMD    0x10</span>
<span class="cp">#define SIZE_MAX_STATUS 0x10</span>

<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="p">{</span>
	<span class="n">u16</span>	<span class="n">LgCmd</span><span class="p">;</span>		<span class="cm">/* length of the command to send (WORDs) */</span>
	<span class="n">u16</span>	<span class="n">LgStat</span><span class="p">;</span>		<span class="cm">/* length of the status received (WORDs) */</span>
	<span class="n">u32</span>	<span class="n">Cmd</span><span class="p">[</span><span class="n">SIZE_MAX_CMD</span><span class="p">];</span>
	<span class="n">u32</span>	<span class="n">Stat</span><span class="p">[</span><span class="n">SIZE_MAX_STATUS</span><span class="p">];</span>
	<span class="n">u16</span>	<span class="n">DspStat</span><span class="p">;</span>	<span class="cm">/* status type, RMP_SSIZE_XXX */</span>
<span class="p">};</span>
	
<span class="k">typedef</span> <span class="n">u64</span> <span class="n">pcx_time_t</span><span class="p">;</span>

<span class="cp">#define VX_MAX_PIPES	16</span>
<span class="cp">#define VX_MAX_PERIODS	32</span>
<span class="cp">#define VX_MAX_CODECS	2</span>

<span class="k">struct</span> <span class="n">vx_ibl_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>	<span class="cm">/* the current IBL size (0 = query) in bytes */</span>
	<span class="kt">int</span> <span class="n">max_size</span><span class="p">;</span>	<span class="cm">/* max. IBL size in bytes */</span>
	<span class="kt">int</span> <span class="n">min_size</span><span class="p">;</span>	<span class="cm">/* min. IBL size in bytes */</span>
	<span class="kt">int</span> <span class="n">granularity</span><span class="p">;</span>	<span class="cm">/* granularity */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_capture</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_mode</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">running</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prepared</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">channels</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">differed_type</span><span class="p">;</span>
	<span class="n">pcx_time_t</span> <span class="n">pcx_time</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">hbuf_size</span><span class="p">;</span>		<span class="cm">/* H-buffer size in bytes */</span>
	<span class="kt">int</span> <span class="n">buffer_bytes</span><span class="p">;</span>	<span class="cm">/* the ALSA pcm buffer size in bytes */</span>
	<span class="kt">int</span> <span class="n">period_bytes</span><span class="p">;</span>	<span class="cm">/* the ALSA pcm period size in bytes */</span>
	<span class="kt">int</span> <span class="n">hw_ptr</span><span class="p">;</span>		<span class="cm">/* the current hardware pointer in bytes */</span>
	<span class="kt">int</span> <span class="n">position</span><span class="p">;</span>		<span class="cm">/* the current position in frames (playback only) */</span>
	<span class="kt">int</span> <span class="n">transferred</span><span class="p">;</span>	<span class="cm">/* the transferred size (per period) in frames */</span>
	<span class="kt">int</span> <span class="n">align</span><span class="p">;</span>		<span class="cm">/* size of alignment */</span>
	<span class="n">u64</span> <span class="n">cur_count</span><span class="p">;</span>		<span class="cm">/* current sample position (for playback) */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">references</span><span class="p">;</span>     <span class="cm">/* an output pipe may be used for monitoring and/or playback */</span>
	<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">monitoring_pipe</span><span class="p">;</span>  <span class="cm">/* pointer to the monitoring pipe (capture pipe only)*/</span>

	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">start_tq</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vx_core</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">snd_vx_ops</span> <span class="p">{</span>
	<span class="cm">/* low-level i/o */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="p">(</span><span class="o">*</span><span class="n">in8</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">in32</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">out8</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">out32</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
	<span class="cm">/* irq */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test_and_ack</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">validate_irq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>
	<span class="cm">/* codec */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_codec</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">codec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">akm_write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset_codec</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">change_audio_source</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">src</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_clock_source</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">src</span><span class="p">);</span>
	<span class="cm">/* chip init */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">load_dsp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset_dsp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset_board</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cold_reset</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">add_controls</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
	<span class="cm">/* pcm */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dma_write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dma_read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_vx_hardware</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* VX_TYPE_XXX */</span>

	<span class="cm">/* hardware specs */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_codecs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_ins</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_outs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">output_level_max</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">output_level_db_scale</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* hwdep id string */</span>
<span class="cp">#define SND_VX_HWDEP_ID		&quot;VX Loader&quot;</span>

<span class="cm">/* hardware type */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* VX222 PCI */</span>
	<span class="n">VX_TYPE_BOARD</span><span class="p">,</span>		<span class="cm">/* old VX222 PCI */</span>
	<span class="n">VX_TYPE_V2</span><span class="p">,</span>		<span class="cm">/* VX222 V2 PCI */</span>
	<span class="n">VX_TYPE_MIC</span><span class="p">,</span>		<span class="cm">/* VX222 Mic PCI */</span>
	<span class="cm">/* VX-pocket */</span>
	<span class="n">VX_TYPE_VXPOCKET</span><span class="p">,</span>	<span class="cm">/* VXpocket V2 */</span>
	<span class="n">VX_TYPE_VXP440</span><span class="p">,</span>		<span class="cm">/* VXpocket 440 */</span>
	<span class="n">VX_TYPE_NUMS</span>
<span class="p">};</span>

<span class="cm">/* chip status */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">VX_STAT_XILINX_LOADED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* devices are registered */</span>
	<span class="n">VX_STAT_DEVICE_INIT</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>	<span class="cm">/* devices are registered */</span>
	<span class="n">VX_STAT_CHIP_INIT</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>	<span class="cm">/* all operational */</span>
	<span class="n">VX_STAT_IN_SUSPEND</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span>	<span class="cm">/* in suspend phase */</span>
	<span class="n">VX_STAT_IS_STALE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">)</span>	<span class="cm">/* device is stale */</span>
<span class="p">};</span>

<span class="cm">/* min/max values for analog output for old codecs */</span>
<span class="cp">#define VX_ANALOG_OUT_LEVEL_MAX		0xe3</span>

<span class="k">struct</span> <span class="n">vx_core</span> <span class="p">{</span>
	<span class="cm">/* ALSA stuff */</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_pcm</span> <span class="o">*</span><span class="n">pcm</span><span class="p">[</span><span class="n">VX_MAX_CODECS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* VX_TYPE_XXX */</span>

	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="cm">/* ports are defined externally */</span>

	<span class="cm">/* low-level functions */</span>
	<span class="k">struct</span> <span class="n">snd_vx_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_vx_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">irq_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">tq</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chip_status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pcm_running</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_hwdep</span> <span class="o">*</span><span class="n">hwdep</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">irq_rmh</span><span class="p">;</span>	<span class="cm">/* RMH used in interrupts */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">audio_info</span><span class="p">;</span> <span class="cm">/* see VX_AUDIO_INFO */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">audio_ins</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">audio_outs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">**</span><span class="n">playback_pipes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">**</span><span class="n">capture_pipes</span><span class="p">;</span>

	<span class="cm">/* clock and audio sources */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">audio_source</span><span class="p">;</span>	<span class="cm">/* current audio input source */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">audio_source_target</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clock_mode</span><span class="p">;</span>	<span class="cm">/* clock mode (VX_CLOCK_MODE_XXX) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clock_source</span><span class="p">;</span>	<span class="cm">/* current clock source (INTERNAL_QUARTZ or UER_SYNC) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freq</span><span class="p">;</span>		<span class="cm">/* current frequency */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freq_detected</span><span class="p">;</span>	<span class="cm">/* detected frequency from digital in */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uer_detected</span><span class="p">;</span>	<span class="cm">/* VX_UER_MODE_XXX */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uer_bits</span><span class="p">;</span>	<span class="cm">/* IEC958 status bits */</span>
	<span class="k">struct</span> <span class="n">vx_ibl_info</span> <span class="n">ibl</span><span class="p">;</span>	<span class="cm">/* IBL information */</span>

	<span class="cm">/* mixer setting */</span>
	<span class="kt">int</span> <span class="n">output_level</span><span class="p">[</span><span class="n">VX_MAX_CODECS</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* analog output level */</span>
	<span class="kt">int</span> <span class="n">audio_gain</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span>			<span class="cm">/* digital audio level (playback/capture) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">audio_active</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>		<span class="cm">/* mute/unmute on digital playback */</span>
	<span class="kt">int</span> <span class="n">audio_monitor</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>			<span class="cm">/* playback hw-monitor level */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">audio_monitor_active</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* playback hw-monitor mute/unmute */</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mixer_mutex</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">firmware</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="cm">/* loaded firmware data */</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * constructor</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">snd_vx_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_vx_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">snd_vx_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">extra_size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_vx_setup_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_vx_load_boot_image</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">dsp</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_vx_dsp_boot</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">dsp</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_vx_dsp_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">dsp</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">snd_vx_free_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * interrupt handler; exported for pcmcia</span>
<span class="cm"> */</span>
<span class="n">irqreturn_t</span> <span class="n">snd_vx_irq_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * lowlevel functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vx_test_and_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">test_and_ack</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vx_validate_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">validate_irq</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">snd_vx_inb</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">in8</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">snd_vx_inl</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">in32</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">snd_vx_outb</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">out8</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">snd_vx_outl</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">out32</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define vx_inb(chip,reg)	snd_vx_inb(chip, VX_##reg)</span>
<span class="cp">#define vx_outb(chip,reg,val)	snd_vx_outb(chip, VX_##reg,val)</span>
<span class="cp">#define vx_inl(chip,reg)	snd_vx_inl(chip, VX_##reg)</span>
<span class="cp">#define vx_outl(chip,reg,val)	snd_vx_outl(chip, VX_##reg,val)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vx_reset_dsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">reset_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">vx_send_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_rmh</span> <span class="o">*</span><span class="n">rmh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vx_send_msg_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_rmh</span> <span class="o">*</span><span class="n">rmh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vx_send_rih</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vx_send_rih_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vx_reset_codec</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cold_reset</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * check the bit on the specified register</span>
<span class="cm"> * returns zero if a bit matches, or a negative error code.</span>
<span class="cm"> * exported for vxpocket driver</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">snd_vx_check_reg_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">time</span><span class="p">);</span>
<span class="cp">#define vx_check_isr(chip,mask,bit,time) snd_vx_check_reg_bit(chip, VX_ISR, mask, bit, time)</span>
<span class="cp">#define vx_wait_isr_bit(chip,bit) vx_check_isr(chip, bit, bit, 200)</span>
<span class="cp">#define vx_wait_for_rx_full(chip) vx_wait_isr_bit(chip, ISR_RX_FULL)</span>


<span class="cm">/*</span>
<span class="cm"> * pseudo-DMA transfer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vx_pseudo_dma_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">dma_write</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vx_pseudo_dma_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">dma_read</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/* error with hardware code,</span>
<span class="cm"> * the return value is -(VX_ERR_MASK | actual-hw-error-code)</span>
<span class="cm"> */</span>
<span class="cp">#define VX_ERR_MASK	0x1000000</span>
<span class="cp">#define vx_get_error(err)	(-(err) &amp; ~VX_ERR_MASK)</span>


<span class="cm">/*</span>
<span class="cm"> * pcm stuff</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">snd_vx_pcm_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">vx_pcm_update_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">events</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * mixer stuff</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">snd_vx_mixer_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">vx_toggle_dac_mute</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mute</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vx_sync_audio_source</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vx_set_monitor_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">audio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">active</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * IEC958 &amp; clock stuff</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">vx_set_iec958_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vx_set_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freq</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">vx_set_internal_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freq</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vx_change_frequency</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * PM</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">snd_vx_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_vx_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">card</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * hardware constants</span>
<span class="cm"> */</span>

<span class="cp">#define vx_has_new_dsp(chip)	((chip)-&gt;type != VX_TYPE_BOARD)</span>
<span class="cp">#define vx_is_pcmcia(chip)	((chip)-&gt;type &gt;= VX_TYPE_VXPOCKET)</span>

<span class="cm">/* audio input source */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">VX_AUDIO_SRC_DIGITAL</span><span class="p">,</span>
	<span class="n">VX_AUDIO_SRC_LINE</span><span class="p">,</span>
	<span class="n">VX_AUDIO_SRC_MIC</span>
<span class="p">};</span>

<span class="cm">/* clock source */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">INTERNAL_QUARTZ</span><span class="p">,</span>
	<span class="n">UER_SYNC</span>
<span class="p">};</span>

<span class="cm">/* clock mode */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">VX_CLOCK_MODE_AUTO</span><span class="p">,</span>	<span class="cm">/* depending on the current audio source */</span>
	<span class="n">VX_CLOCK_MODE_INTERNAL</span><span class="p">,</span>	<span class="cm">/* fixed to internal quartz */</span>
	<span class="n">VX_CLOCK_MODE_EXTERNAL</span>	<span class="cm">/* fixed to UER sync */</span>
<span class="p">};</span>

<span class="cm">/* SPDIF/UER type */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">VX_UER_MODE_CONSUMER</span><span class="p">,</span>
	<span class="n">VX_UER_MODE_PROFESSIONAL</span><span class="p">,</span>
	<span class="n">VX_UER_MODE_NOT_PRESENT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* register indices */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">VX_ICR</span><span class="p">,</span>
	<span class="n">VX_CVR</span><span class="p">,</span>
	<span class="n">VX_ISR</span><span class="p">,</span>
	<span class="n">VX_IVR</span><span class="p">,</span>
	<span class="n">VX_RXH</span><span class="p">,</span>
	<span class="n">VX_TXH</span> <span class="o">=</span> <span class="n">VX_RXH</span><span class="p">,</span>
	<span class="n">VX_RXM</span><span class="p">,</span>
	<span class="n">VX_TXM</span> <span class="o">=</span> <span class="n">VX_RXM</span><span class="p">,</span>
	<span class="n">VX_RXL</span><span class="p">,</span>
	<span class="n">VX_TXL</span> <span class="o">=</span> <span class="n">VX_RXL</span><span class="p">,</span>
	<span class="n">VX_DMA</span><span class="p">,</span>
	<span class="n">VX_CDSP</span><span class="p">,</span>
	<span class="n">VX_RFREQ</span><span class="p">,</span>
	<span class="n">VX_RUER_V2</span><span class="p">,</span>
	<span class="n">VX_GAIN</span><span class="p">,</span>
	<span class="n">VX_DATA</span> <span class="o">=</span> <span class="n">VX_GAIN</span><span class="p">,</span>
	<span class="n">VX_MEMIRQ</span><span class="p">,</span>
	<span class="n">VX_ACQ</span><span class="p">,</span>
	<span class="n">VX_BIT0</span><span class="p">,</span>
	<span class="n">VX_BIT1</span><span class="p">,</span>
	<span class="n">VX_MIC0</span><span class="p">,</span>
	<span class="n">VX_MIC1</span><span class="p">,</span>
	<span class="n">VX_MIC2</span><span class="p">,</span>
	<span class="n">VX_MIC3</span><span class="p">,</span>
	<span class="n">VX_PLX0</span><span class="p">,</span>
	<span class="n">VX_PLX1</span><span class="p">,</span>
	<span class="n">VX_PLX2</span><span class="p">,</span>

	<span class="n">VX_LOFREQ</span><span class="p">,</span>  <span class="c1">// V2: ACQ, VP: RFREQ</span>
	<span class="n">VX_HIFREQ</span><span class="p">,</span>  <span class="c1">// V2: BIT0, VP: RUER_V2</span>
	<span class="n">VX_CSUER</span><span class="p">,</span>   <span class="c1">// V2: BIT1, VP: BIT0</span>
	<span class="n">VX_RUER</span><span class="p">,</span>    <span class="c1">// V2: RUER_V2, VP: BIT1</span>

	<span class="n">VX_REG_MAX</span><span class="p">,</span>

	<span class="cm">/* aliases for VX board */</span>
	<span class="n">VX_RESET_DMA</span> <span class="o">=</span> <span class="n">VX_ISR</span><span class="p">,</span>
	<span class="n">VX_CFG</span> <span class="o">=</span> <span class="n">VX_RFREQ</span><span class="p">,</span>
	<span class="n">VX_STATUS</span> <span class="o">=</span> <span class="n">VX_MEMIRQ</span><span class="p">,</span>
	<span class="n">VX_SELMIC</span> <span class="o">=</span> <span class="n">VX_MIC0</span><span class="p">,</span>
	<span class="n">VX_COMPOT</span> <span class="o">=</span> <span class="n">VX_MIC1</span><span class="p">,</span>
	<span class="n">VX_SCOMPR</span> <span class="o">=</span> <span class="n">VX_MIC2</span><span class="p">,</span>
	<span class="n">VX_GLIMIT</span> <span class="o">=</span> <span class="n">VX_MIC3</span><span class="p">,</span>
	<span class="n">VX_INTCSR</span> <span class="o">=</span> <span class="n">VX_PLX0</span><span class="p">,</span>
	<span class="n">VX_CNTRL</span> <span class="o">=</span> <span class="n">VX_PLX1</span><span class="p">,</span>
	<span class="n">VX_GPIOC</span> <span class="o">=</span> <span class="n">VX_PLX2</span><span class="p">,</span>

	<span class="cm">/* aliases for VXPOCKET board */</span>
	<span class="n">VX_MICRO</span> <span class="o">=</span> <span class="n">VX_MEMIRQ</span><span class="p">,</span>
	<span class="n">VX_CODEC2</span> <span class="o">=</span> <span class="n">VX_MEMIRQ</span><span class="p">,</span>
	<span class="n">VX_DIALOG</span> <span class="o">=</span> <span class="n">VX_ACQ</span><span class="p">,</span>

<span class="p">};</span>

<span class="cm">/* RMH status type */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RMH_SSIZE_FIXED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* status size given by the driver (in LgStat) */</span>
	<span class="n">RMH_SSIZE_ARG</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* status size given in the LSB byte */</span>
	<span class="n">RMH_SSIZE_MASK</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>	<span class="cm">/* status size given in bitmask */</span>
<span class="p">};</span>


<span class="cm">/* bits for ICR register */</span>
<span class="cp">#define ICR_HF1		0x10</span>
<span class="cp">#define ICR_HF0		0x08</span>
<span class="cp">#define ICR_TREQ	0x02	</span><span class="cm">/* Interrupt mode + HREQ set on for transfer (-&gt;DSP) request */</span><span class="cp"></span>
<span class="cp">#define ICR_RREQ	0x01	</span><span class="cm">/* Interrupt mode + RREQ set on for transfer (-&gt;PC) request */</span><span class="cp"></span>

<span class="cm">/* bits for CVR register */</span>
<span class="cp">#define CVR_HC		0x80</span>

<span class="cm">/* bits for ISR register */</span>
<span class="cp">#define ISR_HF3		0x10</span>
<span class="cp">#define ISR_HF2		0x08</span>
<span class="cp">#define ISR_CHK		0x10</span>
<span class="cp">#define ISR_ERR		0x08</span>
<span class="cp">#define ISR_TX_READY	0x04</span>
<span class="cp">#define ISR_TX_EMPTY	0x02</span>
<span class="cp">#define ISR_RX_FULL	0x01</span>

<span class="cm">/* Constants used to access the DATA register */</span>
<span class="cp">#define VX_DATA_CODEC_MASK	0x80</span>
<span class="cp">#define VX_DATA_XICOR_MASK	0x80</span>

<span class="cm">/* Constants used to access the CSUER register (both for VX2 and VXP) */</span>
<span class="cp">#define VX_SUER_FREQ_MASK		0x0c</span>
<span class="cp">#define VX_SUER_FREQ_32KHz_MASK		0x0c</span>
<span class="cp">#define VX_SUER_FREQ_44KHz_MASK		0x00</span>
<span class="cp">#define VX_SUER_FREQ_48KHz_MASK		0x04</span>
<span class="cp">#define VX_SUER_DATA_PRESENT_MASK	0x02</span>
<span class="cp">#define VX_SUER_CLOCK_PRESENT_MASK	0x01</span>

<span class="cp">#define VX_CUER_HH_BITC_SEL_MASK	0x08</span>
<span class="cp">#define VX_CUER_MH_BITC_SEL_MASK	0x04</span>
<span class="cp">#define VX_CUER_ML_BITC_SEL_MASK	0x02</span>
<span class="cp">#define VX_CUER_LL_BITC_SEL_MASK	0x01</span>

<span class="cp">#define XX_UER_CBITS_OFFSET_MASK	0x1f</span>


<span class="cm">/* bits for audio_info */</span>
<span class="cp">#define VX_AUDIO_INFO_REAL_TIME	(1&lt;&lt;0)	</span><span class="cm">/* real-time processing available */</span><span class="cp"></span>
<span class="cp">#define VX_AUDIO_INFO_OFFLINE	(1&lt;&lt;1)	</span><span class="cm">/* offline processing available */</span><span class="cp"></span>
<span class="cp">#define VX_AUDIO_INFO_MPEG1	(1&lt;&lt;5)</span>
<span class="cp">#define VX_AUDIO_INFO_MPEG2	(1&lt;&lt;6)</span>
<span class="cp">#define VX_AUDIO_INFO_LINEAR_8	(1&lt;&lt;7)</span>
<span class="cp">#define VX_AUDIO_INFO_LINEAR_16	(1&lt;&lt;8)</span>
<span class="cp">#define VX_AUDIO_INFO_LINEAR_24	(1&lt;&lt;9)</span>

<span class="cm">/* DSP Interrupt Request values */</span>
<span class="cp">#define VXP_IRQ_OFFSET		0x40 </span><span class="cm">/* add 0x40 offset for vxpocket and vx222/v2 */</span><span class="cp"></span>
<span class="cm">/* call with vx_send_irq_dsp() */</span>
<span class="cp">#define IRQ_MESS_WRITE_END          0x30</span>
<span class="cp">#define IRQ_MESS_WRITE_NEXT         0x32</span>
<span class="cp">#define IRQ_MESS_READ_NEXT          0x34</span>
<span class="cp">#define IRQ_MESS_READ_END           0x36</span>
<span class="cp">#define IRQ_MESSAGE                 0x38</span>
<span class="cp">#define IRQ_RESET_CHK               0x3A</span>
<span class="cp">#define IRQ_CONNECT_STREAM_NEXT     0x26</span>
<span class="cp">#define IRQ_CONNECT_STREAM_END      0x28</span>
<span class="cp">#define IRQ_PAUSE_START_CONNECT     0x2A</span>
<span class="cp">#define IRQ_END_CONNECTION          0x2C</span>

<span class="cm">/* Is there async. events pending ( IT Source Test ) */</span>
<span class="cp">#define ASYNC_EVENTS_PENDING            0x008000</span>
<span class="cp">#define HBUFFER_EVENTS_PENDING          0x004000   </span><span class="c1">// Not always accurate</span>
<span class="cp">#define NOTIF_EVENTS_PENDING            0x002000</span>
<span class="cp">#define TIME_CODE_EVENT_PENDING         0x001000</span>
<span class="cp">#define FREQUENCY_CHANGE_EVENT_PENDING  0x000800</span>
<span class="cp">#define END_OF_BUFFER_EVENTS_PENDING    0x000400</span>
<span class="cp">#define FATAL_DSP_ERROR                 0xff0000</span>

<span class="cm">/* Stream Format Header Defines */</span> 
<span class="cp">#define HEADER_FMT_BASE			0xFED00000</span>
<span class="cp">#define HEADER_FMT_MONO			0x000000C0</span>
<span class="cp">#define HEADER_FMT_INTEL		0x00008000</span>
<span class="cp">#define HEADER_FMT_16BITS		0x00002000</span>
<span class="cp">#define HEADER_FMT_24BITS		0x00004000</span>
<span class="cp">#define HEADER_FMT_UPTO11		0x00000200	</span><span class="cm">/* frequency is less or equ. to 11k.*/</span><span class="cp"></span>
<span class="cp">#define HEADER_FMT_UPTO32		0x00000100	</span><span class="cm">/* frequency is over 11k and less then 32k.*/</span><span class="cp"></span>

<span class="cm">/* Constants used to access the Codec */</span>
<span class="cp">#define XX_CODEC_SELECTOR               0x20</span>
<span class="cm">/* codec commands */</span>
<span class="cp">#define XX_CODEC_ADC_CONTROL_REGISTER   0x01</span>
<span class="cp">#define XX_CODEC_DAC_CONTROL_REGISTER   0x02</span>
<span class="cp">#define XX_CODEC_LEVEL_LEFT_REGISTER    0x03</span>
<span class="cp">#define XX_CODEC_LEVEL_RIGHT_REGISTER   0x04</span>
<span class="cp">#define XX_CODEC_PORT_MODE_REGISTER     0x05</span>
<span class="cp">#define XX_CODEC_STATUS_REPORT_REGISTER 0x06</span>
<span class="cp">#define XX_CODEC_CLOCK_CONTROL_REGISTER 0x07</span>

<span class="cm">/*</span>
<span class="cm"> * Audio-level control values</span>
<span class="cm"> */</span>
<span class="cp">#define CVAL_M110DB		0x000	</span><span class="cm">/* -110dB */</span><span class="cp"></span>
<span class="cp">#define CVAL_M99DB		0x02C</span>
<span class="cp">#define CVAL_M21DB		0x163</span>
<span class="cp">#define CVAL_M18DB		0x16F</span>
<span class="cp">#define CVAL_M10DB		0x18F</span>
<span class="cp">#define CVAL_0DB		0x1B7</span>
<span class="cp">#define CVAL_18DB		0x1FF	</span><span class="cm">/* +18dB */</span><span class="cp"></span>
<span class="cp">#define CVAL_MAX		0x1FF</span>

<span class="cp">#define AUDIO_IO_HAS_MUTE_LEVEL			0x400000</span>
<span class="cp">#define AUDIO_IO_HAS_MUTE_MONITORING_1		0x200000</span>
<span class="cp">#define AUDIO_IO_HAS_MUTE_MONITORING_2		0x100000</span>
<span class="cp">#define VALID_AUDIO_IO_DIGITAL_LEVEL		0x01</span>
<span class="cp">#define VALID_AUDIO_IO_MONITORING_LEVEL		0x02</span>
<span class="cp">#define VALID_AUDIO_IO_MUTE_LEVEL		0x04</span>
<span class="cp">#define VALID_AUDIO_IO_MUTE_MONITORING_1	0x08</span>
<span class="cp">#define VALID_AUDIO_IO_MUTE_MONITORING_2	0x10</span>


<span class="cp">#endif </span><span class="cm">/* __SOUND_VX_COMMON_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
