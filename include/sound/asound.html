<!DOCTYPE html>
<html><head><title>joekychen/linux » include › sound › asound.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>asound.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Advanced Linux Sound Architecture - ALSA - Driver</span>
<span class="cm"> *  Copyright (c) 1994-2003 by Jaroslav Kysela &lt;perex@perex.cz&gt;,</span>
<span class="cm"> *                             Abramo Bagnara &lt;abramo@alsa-project.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *   GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __SOUND_ASOUND_H</span>
<span class="cp">#define __SOUND_ASOUND_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#ifdef  __LITTLE_ENDIAN</span>
<span class="cp">#define SNDRV_LITTLE_ENDIAN</span>
<span class="cp">#else</span>
<span class="cp">#ifdef __BIG_ENDIAN</span>
<span class="cp">#define SNDRV_BIG_ENDIAN</span>
<span class="cp">#else</span>
<span class="cp">#error &quot;Unsupported endian...&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ **/</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *  protocol version</span>
<span class="cm"> */</span>

<span class="cp">#define SNDRV_PROTOCOL_VERSION(major, minor, subminor) (((major)&lt;&lt;16)|((minor)&lt;&lt;8)|(subminor))</span>
<span class="cp">#define SNDRV_PROTOCOL_MAJOR(version) (((version)&gt;&gt;16)&amp;0xffff)</span>
<span class="cp">#define SNDRV_PROTOCOL_MINOR(version) (((version)&gt;&gt;8)&amp;0xff)</span>
<span class="cp">#define SNDRV_PROTOCOL_MICRO(version) ((version)&amp;0xff)</span>
<span class="cp">#define SNDRV_PROTOCOL_INCOMPATIBLE(kversion, uversion) \</span>
<span class="cp">	(SNDRV_PROTOCOL_MAJOR(kversion) != SNDRV_PROTOCOL_MAJOR(uversion) || \</span>
<span class="cp">	 (SNDRV_PROTOCOL_MAJOR(kversion) == SNDRV_PROTOCOL_MAJOR(uversion) &amp;&amp; \</span>
<span class="cp">	   SNDRV_PROTOCOL_MINOR(kversion) != SNDRV_PROTOCOL_MINOR(uversion)))</span>

<span class="cm">/****************************************************************************</span>
<span class="cm"> *                                                                          *</span>
<span class="cm"> *        Digital audio interface					    *</span>
<span class="cm"> *                                                                          *</span>
<span class="cm"> ****************************************************************************/</span>

<span class="k">struct</span> <span class="n">snd_aes_iec958</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>	<span class="cm">/* AES/IEC958 channel status bits */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">subcode</span><span class="p">[</span><span class="mi">147</span><span class="p">];</span>	<span class="cm">/* AES/IEC958 subcode bits */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pad</span><span class="p">;</span>		<span class="cm">/* nothing */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dig_subframe</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* AES/IEC958 subframe bits */</span>
<span class="p">};</span>

<span class="cm">/****************************************************************************</span>
<span class="cm"> *                                                                          *</span>
<span class="cm"> *        CEA-861 Audio InfoFrame. Used in HDMI and DisplayPort		    *</span>
<span class="cm"> *                                                                          *</span>
<span class="cm"> ****************************************************************************/</span>

<span class="k">struct</span> <span class="n">snd_cea_861_aud_if</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">db1_ct_cc</span><span class="p">;</span> <span class="cm">/* coding type and channel count */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">db2_sf_ss</span><span class="p">;</span> <span class="cm">/* sample frequency and size */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">db3</span><span class="p">;</span> <span class="cm">/* not used, all zeros */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">db4_ca</span><span class="p">;</span> <span class="cm">/* channel allocation code */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">db5_dminh_lsv</span><span class="p">;</span> <span class="cm">/* downmix inhibit &amp; level-shit values */</span>
<span class="p">};</span>

<span class="cm">/****************************************************************************</span>
<span class="cm"> *                                                                          *</span>
<span class="cm"> *      Section for driver hardware dependent interface - /dev/snd/hw?      *</span>
<span class="cm"> *                                                                          *</span>
<span class="cm"> ****************************************************************************/</span>

<span class="cp">#define SNDRV_HWDEP_VERSION		SNDRV_PROTOCOL_VERSION(1, 0, 1)</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SNDRV_HWDEP_IFACE_OPL2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SNDRV_HWDEP_IFACE_OPL3</span><span class="p">,</span>
	<span class="n">SNDRV_HWDEP_IFACE_OPL4</span><span class="p">,</span>
	<span class="n">SNDRV_HWDEP_IFACE_SB16CSP</span><span class="p">,</span>	<span class="cm">/* Creative Signal Processor */</span>
	<span class="n">SNDRV_HWDEP_IFACE_EMU10K1</span><span class="p">,</span>	<span class="cm">/* FX8010 processor in EMU10K1 chip */</span>
	<span class="n">SNDRV_HWDEP_IFACE_YSS225</span><span class="p">,</span>	<span class="cm">/* Yamaha FX processor */</span>
	<span class="n">SNDRV_HWDEP_IFACE_ICS2115</span><span class="p">,</span>	<span class="cm">/* Wavetable synth */</span>
	<span class="n">SNDRV_HWDEP_IFACE_SSCAPE</span><span class="p">,</span>	<span class="cm">/* Ensoniq SoundScape ISA card (MC68EC000) */</span>
	<span class="n">SNDRV_HWDEP_IFACE_VX</span><span class="p">,</span>		<span class="cm">/* Digigram VX cards */</span>
	<span class="n">SNDRV_HWDEP_IFACE_MIXART</span><span class="p">,</span>	<span class="cm">/* Digigram miXart cards */</span>
	<span class="n">SNDRV_HWDEP_IFACE_USX2Y</span><span class="p">,</span>	<span class="cm">/* Tascam US122, US224 &amp; US428 usb */</span>
	<span class="n">SNDRV_HWDEP_IFACE_EMUX_WAVETABLE</span><span class="p">,</span> <span class="cm">/* EmuX wavetable */</span>	
	<span class="n">SNDRV_HWDEP_IFACE_BLUETOOTH</span><span class="p">,</span>	<span class="cm">/* Bluetooth audio */</span>
	<span class="n">SNDRV_HWDEP_IFACE_USX2Y_PCM</span><span class="p">,</span>	<span class="cm">/* Tascam US122, US224 &amp; US428 rawusb pcm */</span>
	<span class="n">SNDRV_HWDEP_IFACE_PCXHR</span><span class="p">,</span>	<span class="cm">/* Digigram PCXHR */</span>
	<span class="n">SNDRV_HWDEP_IFACE_SB_RC</span><span class="p">,</span>	<span class="cm">/* SB Extigy/Audigy2NX remote control */</span>
	<span class="n">SNDRV_HWDEP_IFACE_HDA</span><span class="p">,</span>		<span class="cm">/* HD-audio */</span>
	<span class="n">SNDRV_HWDEP_IFACE_USB_STREAM</span><span class="p">,</span>	<span class="cm">/* direct access to usb stream */</span>

	<span class="cm">/* Don&#39;t forget to change the following: */</span>
	<span class="n">SNDRV_HWDEP_IFACE_LAST</span> <span class="o">=</span> <span class="n">SNDRV_HWDEP_IFACE_USB_STREAM</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_hwdep_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">;</span>		<span class="cm">/* WR: device number */</span>
	<span class="kt">int</span> <span class="n">card</span><span class="p">;</span>			<span class="cm">/* R: card number */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">id</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>		<span class="cm">/* ID (user selectable) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>		<span class="cm">/* hwdep name */</span>
	<span class="kt">int</span> <span class="n">iface</span><span class="p">;</span>			<span class="cm">/* hwdep interface */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>	<span class="cm">/* reserved for future */</span>
<span class="p">};</span>

<span class="cm">/* generic DSP loader */</span>
<span class="k">struct</span> <span class="n">snd_hwdep_dsp_status</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">version</span><span class="p">;</span>		<span class="cm">/* R: driver-specific version */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">id</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>		<span class="cm">/* R: driver-specific ID string */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_dsps</span><span class="p">;</span>		<span class="cm">/* R: number of DSP images to transfer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dsp_loaded</span><span class="p">;</span>	<span class="cm">/* R: bit flags indicating the loaded DSPs */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chip_ready</span><span class="p">;</span>	<span class="cm">/* R: 1 = initialization finished */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* reserved for future use */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_hwdep_dsp_image</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>		<span class="cm">/* W: DSP index */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>		<span class="cm">/* W: ID (e.g. file name) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">image</span><span class="p">;</span>	<span class="cm">/* W: binary image */</span>
	<span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>			<span class="cm">/* W: size of image in bytes */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">driver_data</span><span class="p">;</span>	<span class="cm">/* W: driver-specific data */</span>
<span class="p">};</span>

<span class="cp">#define SNDRV_HWDEP_IOCTL_PVERSION	_IOR (&#39;H&#39;, 0x00, int)</span>
<span class="cp">#define SNDRV_HWDEP_IOCTL_INFO		_IOR (&#39;H&#39;, 0x01, struct snd_hwdep_info)</span>
<span class="cp">#define SNDRV_HWDEP_IOCTL_DSP_STATUS	_IOR(&#39;H&#39;, 0x02, struct snd_hwdep_dsp_status)</span>
<span class="cp">#define SNDRV_HWDEP_IOCTL_DSP_LOAD	_IOW(&#39;H&#39;, 0x03, struct snd_hwdep_dsp_image)</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *                                                                           *</span>
<span class="cm"> *             Digital Audio (PCM) interface - /dev/snd/pcm??                *</span>
<span class="cm"> *                                                                           *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cp">#define SNDRV_PCM_VERSION		SNDRV_PROTOCOL_VERSION(2, 0, 10)</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">snd_pcm_uframes_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">long</span> <span class="n">snd_pcm_sframes_t</span><span class="p">;</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SNDRV_PCM_CLASS_GENERIC</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* standard mono or stereo device */</span>
	<span class="n">SNDRV_PCM_CLASS_MULTI</span><span class="p">,</span>		<span class="cm">/* multichannel device */</span>
	<span class="n">SNDRV_PCM_CLASS_MODEM</span><span class="p">,</span>		<span class="cm">/* software modem class */</span>
	<span class="n">SNDRV_PCM_CLASS_DIGITIZER</span><span class="p">,</span>	<span class="cm">/* digitizer class */</span>
	<span class="cm">/* Don&#39;t forget to change the following: */</span>
	<span class="n">SNDRV_PCM_CLASS_LAST</span> <span class="o">=</span> <span class="n">SNDRV_PCM_CLASS_DIGITIZER</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SNDRV_PCM_SUBCLASS_GENERIC_MIX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* mono or stereo subdevices are mixed together */</span>
	<span class="n">SNDRV_PCM_SUBCLASS_MULTI_MIX</span><span class="p">,</span>	<span class="cm">/* multichannel subdevices are mixed together */</span>
	<span class="cm">/* Don&#39;t forget to change the following: */</span>
	<span class="n">SNDRV_PCM_SUBCLASS_LAST</span> <span class="o">=</span> <span class="n">SNDRV_PCM_SUBCLASS_MULTI_MIX</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SNDRV_PCM_STREAM_PLAYBACK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">,</span>
	<span class="n">SNDRV_PCM_STREAM_LAST</span> <span class="o">=</span> <span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="n">__bitwise</span> <span class="n">snd_pcm_access_t</span><span class="p">;</span>
<span class="cp">#define	SNDRV_PCM_ACCESS_MMAP_INTERLEAVED	((__force snd_pcm_access_t) 0) </span><span class="cm">/* interleaved mmap */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED	((__force snd_pcm_access_t) 1) </span><span class="cm">/* noninterleaved mmap */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_ACCESS_MMAP_COMPLEX		((__force snd_pcm_access_t) 2) </span><span class="cm">/* complex mmap */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_ACCESS_RW_INTERLEAVED		((__force snd_pcm_access_t) 3) </span><span class="cm">/* readi/writei */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_ACCESS_RW_NONINTERLEAVED	((__force snd_pcm_access_t) 4) </span><span class="cm">/* readn/writen */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_ACCESS_LAST		SNDRV_PCM_ACCESS_RW_NONINTERLEAVED</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="n">__bitwise</span> <span class="n">snd_pcm_format_t</span><span class="p">;</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S8	((__force snd_pcm_format_t) 0)</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U8	((__force snd_pcm_format_t) 1)</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S16_LE	((__force snd_pcm_format_t) 2)</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S16_BE	((__force snd_pcm_format_t) 3)</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U16_LE	((__force snd_pcm_format_t) 4)</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U16_BE	((__force snd_pcm_format_t) 5)</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S24_LE	((__force snd_pcm_format_t) 6) </span><span class="cm">/* low three bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S24_BE	((__force snd_pcm_format_t) 7) </span><span class="cm">/* low three bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U24_LE	((__force snd_pcm_format_t) 8) </span><span class="cm">/* low three bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U24_BE	((__force snd_pcm_format_t) 9) </span><span class="cm">/* low three bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S32_LE	((__force snd_pcm_format_t) 10)</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S32_BE	((__force snd_pcm_format_t) 11)</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U32_LE	((__force snd_pcm_format_t) 12)</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U32_BE	((__force snd_pcm_format_t) 13)</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_FLOAT_LE	((__force snd_pcm_format_t) 14) </span><span class="cm">/* 4-byte float, IEEE-754 32-bit, range -1.0 to 1.0 */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_FLOAT_BE	((__force snd_pcm_format_t) 15) </span><span class="cm">/* 4-byte float, IEEE-754 32-bit, range -1.0 to 1.0 */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_FLOAT64_LE	((__force snd_pcm_format_t) 16) </span><span class="cm">/* 8-byte float, IEEE-754 64-bit, range -1.0 to 1.0 */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_FLOAT64_BE	((__force snd_pcm_format_t) 17) </span><span class="cm">/* 8-byte float, IEEE-754 64-bit, range -1.0 to 1.0 */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE ((__force snd_pcm_format_t) 18) </span><span class="cm">/* IEC-958 subframe, Little Endian */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE ((__force snd_pcm_format_t) 19) </span><span class="cm">/* IEC-958 subframe, Big Endian */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_MU_LAW		((__force snd_pcm_format_t) 20)</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_A_LAW		((__force snd_pcm_format_t) 21)</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_IMA_ADPCM	((__force snd_pcm_format_t) 22)</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_MPEG		((__force snd_pcm_format_t) 23)</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_GSM		((__force snd_pcm_format_t) 24)</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_SPECIAL	((__force snd_pcm_format_t) 31)</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S24_3LE	((__force snd_pcm_format_t) 32)	</span><span class="cm">/* in three bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S24_3BE	((__force snd_pcm_format_t) 33)	</span><span class="cm">/* in three bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U24_3LE	((__force snd_pcm_format_t) 34)	</span><span class="cm">/* in three bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U24_3BE	((__force snd_pcm_format_t) 35)	</span><span class="cm">/* in three bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S20_3LE	((__force snd_pcm_format_t) 36)	</span><span class="cm">/* in three bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S20_3BE	((__force snd_pcm_format_t) 37)	</span><span class="cm">/* in three bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U20_3LE	((__force snd_pcm_format_t) 38)	</span><span class="cm">/* in three bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U20_3BE	((__force snd_pcm_format_t) 39)	</span><span class="cm">/* in three bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S18_3LE	((__force snd_pcm_format_t) 40)	</span><span class="cm">/* in three bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S18_3BE	((__force snd_pcm_format_t) 41)	</span><span class="cm">/* in three bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U18_3LE	((__force snd_pcm_format_t) 42)	</span><span class="cm">/* in three bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U18_3BE	((__force snd_pcm_format_t) 43)	</span><span class="cm">/* in three bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_G723_24	((__force snd_pcm_format_t) 44) </span><span class="cm">/* 8 samples in 3 bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_G723_24_1B	((__force snd_pcm_format_t) 45) </span><span class="cm">/* 1 sample in 1 byte */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_G723_40	((__force snd_pcm_format_t) 46) </span><span class="cm">/* 8 Samples in 5 bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_G723_40_1B	((__force snd_pcm_format_t) 47) </span><span class="cm">/* 1 sample in 1 byte */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_FORMAT_LAST		SNDRV_PCM_FORMAT_G723_40_1B</span>

<span class="cp">#ifdef SNDRV_LITTLE_ENDIAN</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S16		SNDRV_PCM_FORMAT_S16_LE</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U16		SNDRV_PCM_FORMAT_U16_LE</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S24		SNDRV_PCM_FORMAT_S24_LE</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U24		SNDRV_PCM_FORMAT_U24_LE</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S32		SNDRV_PCM_FORMAT_S32_LE</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U32		SNDRV_PCM_FORMAT_U32_LE</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_FLOAT		SNDRV_PCM_FORMAT_FLOAT_LE</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_FLOAT64	SNDRV_PCM_FORMAT_FLOAT64_LE</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_IEC958_SUBFRAME SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef SNDRV_BIG_ENDIAN</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S16		SNDRV_PCM_FORMAT_S16_BE</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U16		SNDRV_PCM_FORMAT_U16_BE</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S24		SNDRV_PCM_FORMAT_S24_BE</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U24		SNDRV_PCM_FORMAT_U24_BE</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_S32		SNDRV_PCM_FORMAT_S32_BE</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_U32		SNDRV_PCM_FORMAT_U32_BE</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_FLOAT		SNDRV_PCM_FORMAT_FLOAT_BE</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_FLOAT64	SNDRV_PCM_FORMAT_FLOAT64_BE</span>
<span class="cp">#define	SNDRV_PCM_FORMAT_IEC958_SUBFRAME SNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE</span>
<span class="cp">#endif</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="n">__bitwise</span> <span class="n">snd_pcm_subformat_t</span><span class="p">;</span>
<span class="cp">#define	SNDRV_PCM_SUBFORMAT_STD		((__force snd_pcm_subformat_t) 0)</span>
<span class="cp">#define	SNDRV_PCM_SUBFORMAT_LAST	SNDRV_PCM_SUBFORMAT_STD</span>

<span class="cp">#define SNDRV_PCM_INFO_MMAP		0x00000001	</span><span class="cm">/* hardware supports mmap */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_INFO_MMAP_VALID	0x00000002	</span><span class="cm">/* period data are valid during transfer */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_INFO_DOUBLE		0x00000004	</span><span class="cm">/* Double buffering needed for PCM start/stop */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_INFO_BATCH		0x00000010	</span><span class="cm">/* double buffering */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_INFO_INTERLEAVED	0x00000100	</span><span class="cm">/* channels are interleaved */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_INFO_NONINTERLEAVED	0x00000200	</span><span class="cm">/* channels are not interleaved */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_INFO_COMPLEX		0x00000400	</span><span class="cm">/* complex frame organization (mmap only) */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_INFO_BLOCK_TRANSFER	0x00010000	</span><span class="cm">/* hardware transfer block of samples */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_INFO_OVERRANGE	0x00020000	</span><span class="cm">/* hardware supports ADC (capture) overrange detection */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_INFO_RESUME		0x00040000	</span><span class="cm">/* hardware supports stream resume after suspend */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_INFO_PAUSE		0x00080000	</span><span class="cm">/* pause ioctl is supported */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_INFO_HALF_DUPLEX	0x00100000	</span><span class="cm">/* only half duplex */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_INFO_JOINT_DUPLEX	0x00200000	</span><span class="cm">/* playback and capture stream are somewhat correlated */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_INFO_SYNC_START	0x00400000	</span><span class="cm">/* pcm support some kind of sync go */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_INFO_NO_PERIOD_WAKEUP	0x00800000	</span><span class="cm">/* period wakeup can be disabled */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_INFO_FIFO_IN_FRAMES	0x80000000	</span><span class="cm">/* internal kernel flag - FIFO size is in frames */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="n">__bitwise</span> <span class="n">snd_pcm_state_t</span><span class="p">;</span>
<span class="cp">#define	SNDRV_PCM_STATE_OPEN		((__force snd_pcm_state_t) 0) </span><span class="cm">/* stream is open */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_STATE_SETUP		((__force snd_pcm_state_t) 1) </span><span class="cm">/* stream has a setup */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_STATE_PREPARED	((__force snd_pcm_state_t) 2) </span><span class="cm">/* stream is ready to start */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_STATE_RUNNING		((__force snd_pcm_state_t) 3) </span><span class="cm">/* stream is running */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_STATE_XRUN		((__force snd_pcm_state_t) 4) </span><span class="cm">/* stream reached an xrun */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_STATE_DRAINING	((__force snd_pcm_state_t) 5) </span><span class="cm">/* stream is draining */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_STATE_PAUSED		((__force snd_pcm_state_t) 6) </span><span class="cm">/* stream is paused */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_STATE_SUSPENDED	((__force snd_pcm_state_t) 7) </span><span class="cm">/* hardware is suspended */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_STATE_DISCONNECTED	((__force snd_pcm_state_t) 8) </span><span class="cm">/* hardware is disconnected */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_STATE_LAST		SNDRV_PCM_STATE_DISCONNECTED</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SNDRV_PCM_MMAP_OFFSET_DATA</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">,</span>
	<span class="n">SNDRV_PCM_MMAP_OFFSET_STATUS</span> <span class="o">=</span> <span class="mh">0x80000000</span><span class="p">,</span>
	<span class="n">SNDRV_PCM_MMAP_OFFSET_CONTROL</span> <span class="o">=</span> <span class="mh">0x81000000</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">snd_pcm_sync_id</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">id</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">id16</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id32</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_pcm_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">;</span>		<span class="cm">/* RO/WR (control): device number */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subdevice</span><span class="p">;</span>		<span class="cm">/* RO/WR (control): subdevice number */</span>
	<span class="kt">int</span> <span class="n">stream</span><span class="p">;</span>			<span class="cm">/* RO/WR (control): stream direction */</span>
	<span class="kt">int</span> <span class="n">card</span><span class="p">;</span>			<span class="cm">/* R: card number */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">id</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>		<span class="cm">/* ID (user selectable) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>		<span class="cm">/* name of this device */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">subname</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="cm">/* subdevice name */</span>
	<span class="kt">int</span> <span class="n">dev_class</span><span class="p">;</span>			<span class="cm">/* SNDRV_PCM_CLASS_* */</span>
	<span class="kt">int</span> <span class="n">dev_subclass</span><span class="p">;</span>		<span class="cm">/* SNDRV_PCM_SUBCLASS_* */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subdevices_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subdevices_avail</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">snd_pcm_sync_id</span> <span class="n">sync</span><span class="p">;</span>	<span class="cm">/* hardware synchronization ID */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>	<span class="cm">/* reserved for future... */</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="n">snd_pcm_hw_param_t</span><span class="p">;</span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_ACCESS	0	</span><span class="cm">/* Access type */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_FORMAT	1	</span><span class="cm">/* Format */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_SUBFORMAT	2	</span><span class="cm">/* Subformat */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_FIRST_MASK	SNDRV_PCM_HW_PARAM_ACCESS</span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_LAST_MASK	SNDRV_PCM_HW_PARAM_SUBFORMAT</span>

<span class="cp">#define	SNDRV_PCM_HW_PARAM_SAMPLE_BITS	8	</span><span class="cm">/* Bits per sample */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_FRAME_BITS	9	</span><span class="cm">/* Bits per frame */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_CHANNELS	10	</span><span class="cm">/* Channels */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_RATE		11	</span><span class="cm">/* Approx rate */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_PERIOD_TIME	12	</span><span class="cm">/* Approx distance between</span>
<span class="cm">						 * interrupts in us</span>
<span class="cm">						 */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_PERIOD_SIZE	13	</span><span class="cm">/* Approx frames between</span>
<span class="cm">						 * interrupts</span>
<span class="cm">						 */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_PERIOD_BYTES	14	</span><span class="cm">/* Approx bytes between</span>
<span class="cm">						 * interrupts</span>
<span class="cm">						 */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_PERIODS	15	</span><span class="cm">/* Approx interrupts per</span>
<span class="cm">						 * buffer</span>
<span class="cm">						 */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_BUFFER_TIME	16	</span><span class="cm">/* Approx duration of buffer</span>
<span class="cm">						 * in us</span>
<span class="cm">						 */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_BUFFER_SIZE	17	</span><span class="cm">/* Size of buffer in frames */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_BUFFER_BYTES	18	</span><span class="cm">/* Size of buffer in bytes */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_TICK_TIME	19	</span><span class="cm">/* Approx tick duration in us */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_FIRST_INTERVAL	SNDRV_PCM_HW_PARAM_SAMPLE_BITS</span>
<span class="cp">#define	SNDRV_PCM_HW_PARAM_LAST_INTERVAL	SNDRV_PCM_HW_PARAM_TICK_TIME</span>

<span class="cp">#define SNDRV_PCM_HW_PARAMS_NORESAMPLE	(1&lt;&lt;0)	</span><span class="cm">/* avoid rate resampling */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_HW_PARAMS_EXPORT_BUFFER	(1&lt;&lt;1)	</span><span class="cm">/* export buffer */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP	(1&lt;&lt;2)	</span><span class="cm">/* disable period wakeups */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">snd_interval</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">openmin</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
		     <span class="nl">openmax:</span><span class="mi">1</span><span class="p">,</span>
		     <span class="nl">integer:</span><span class="mi">1</span><span class="p">,</span>
		     <span class="nl">empty:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define SNDRV_MASK_MAX	256</span>

<span class="k">struct</span> <span class="n">snd_mask</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">bits</span><span class="p">[(</span><span class="n">SNDRV_MASK_MAX</span><span class="o">+</span><span class="mi">31</span><span class="p">)</span><span class="o">/</span><span class="mi">32</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_mask</span> <span class="n">masks</span><span class="p">[</span><span class="n">SNDRV_PCM_HW_PARAM_LAST_MASK</span> <span class="o">-</span> 
			       <span class="n">SNDRV_PCM_HW_PARAM_FIRST_MASK</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">snd_mask</span> <span class="n">mres</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* reserved masks */</span>
	<span class="k">struct</span> <span class="n">snd_interval</span> <span class="n">intervals</span><span class="p">[</span><span class="n">SNDRV_PCM_HW_PARAM_LAST_INTERVAL</span> <span class="o">-</span>
				        <span class="n">SNDRV_PCM_HW_PARAM_FIRST_INTERVAL</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">snd_interval</span> <span class="n">ires</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>	<span class="cm">/* reserved intervals */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rmask</span><span class="p">;</span>		<span class="cm">/* W: requested masks */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmask</span><span class="p">;</span>		<span class="cm">/* R: changed masks */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">info</span><span class="p">;</span>		<span class="cm">/* R: Info flags for returned setup */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msbits</span><span class="p">;</span>		<span class="cm">/* R: used most significant bits */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rate_num</span><span class="p">;</span>		<span class="cm">/* R: rate numerator */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rate_den</span><span class="p">;</span>		<span class="cm">/* R: rate denominator */</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">fifo_size</span><span class="p">;</span>	<span class="cm">/* R: chip FIFO size in frames */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>	<span class="cm">/* reserved for future */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SNDRV_PCM_TSTAMP_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SNDRV_PCM_TSTAMP_ENABLE</span><span class="p">,</span>
	<span class="n">SNDRV_PCM_TSTAMP_LAST</span> <span class="o">=</span> <span class="n">SNDRV_PCM_TSTAMP_ENABLE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_pcm_sw_params</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">tstamp_mode</span><span class="p">;</span>			<span class="cm">/* timestamp mode */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">period_step</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sleep_min</span><span class="p">;</span>			<span class="cm">/* min ticks to sleep */</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">avail_min</span><span class="p">;</span>		<span class="cm">/* min avail frames for wakeup */</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">xfer_align</span><span class="p">;</span>		<span class="cm">/* obsolete: xfer size need to be a multiple */</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">start_threshold</span><span class="p">;</span>	<span class="cm">/* min hw_avail frames for automatic start */</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">stop_threshold</span><span class="p">;</span>	<span class="cm">/* min avail frames for automatic stop */</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">silence_threshold</span><span class="p">;</span>	<span class="cm">/* min distance from noise for silence filling */</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">silence_size</span><span class="p">;</span>		<span class="cm">/* silence block size */</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">boundary</span><span class="p">;</span>		<span class="cm">/* pointers wrap point */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>		<span class="cm">/* reserved for future */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_pcm_channel_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">__kernel_off_t</span> <span class="n">offset</span><span class="p">;</span>		<span class="cm">/* mmap offset */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first</span><span class="p">;</span>		<span class="cm">/* offset to first sample in bits */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">step</span><span class="p">;</span>		<span class="cm">/* samples distance in bits */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_pcm_status</span> <span class="p">{</span>
	<span class="n">snd_pcm_state_t</span> <span class="n">state</span><span class="p">;</span>		<span class="cm">/* stream state */</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">trigger_tstamp</span><span class="p">;</span>	<span class="cm">/* time when stream was started/stopped/paused */</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">tstamp</span><span class="p">;</span>		<span class="cm">/* reference timestamp */</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">appl_ptr</span><span class="p">;</span>	<span class="cm">/* appl ptr */</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">hw_ptr</span><span class="p">;</span>	<span class="cm">/* hw ptr */</span>
	<span class="n">snd_pcm_sframes_t</span> <span class="n">delay</span><span class="p">;</span>	<span class="cm">/* current delay in frames */</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">avail</span><span class="p">;</span>	<span class="cm">/* number of frames available */</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">avail_max</span><span class="p">;</span>	<span class="cm">/* max frames available on hw since last status */</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">overrange</span><span class="p">;</span>	<span class="cm">/* count of ADC (capture) overrange detections from last status */</span>
	<span class="n">snd_pcm_state_t</span> <span class="n">suspended_state</span><span class="p">;</span> <span class="cm">/* suspended stream state */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">60</span><span class="p">];</span>	<span class="cm">/* must be filled with zero */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_pcm_mmap_status</span> <span class="p">{</span>
	<span class="n">snd_pcm_state_t</span> <span class="n">state</span><span class="p">;</span>		<span class="cm">/* RO: state - SNDRV_PCM_STATE_XXXX */</span>
	<span class="kt">int</span> <span class="n">pad1</span><span class="p">;</span>			<span class="cm">/* Needed for 64 bit alignment */</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">hw_ptr</span><span class="p">;</span>	<span class="cm">/* RO: hw ptr (0...boundary-1) */</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">tstamp</span><span class="p">;</span>		<span class="cm">/* Timestamp */</span>
	<span class="n">snd_pcm_state_t</span> <span class="n">suspended_state</span><span class="p">;</span> <span class="cm">/* RO: suspended stream state */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_pcm_mmap_control</span> <span class="p">{</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">appl_ptr</span><span class="p">;</span>	<span class="cm">/* RW: appl ptr (0...boundary-1) */</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">avail_min</span><span class="p">;</span>	<span class="cm">/* RW: min available frames for wakeup */</span>
<span class="p">};</span>

<span class="cp">#define SNDRV_PCM_SYNC_PTR_HWSYNC	(1&lt;&lt;0)	</span><span class="cm">/* execute hwsync */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_SYNC_PTR_APPL		(1&lt;&lt;1)	</span><span class="cm">/* get appl_ptr from driver (r/w op) */</span><span class="cp"></span>
<span class="cp">#define SNDRV_PCM_SYNC_PTR_AVAIL_MIN	(1&lt;&lt;2)	</span><span class="cm">/* get avail_min from driver */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">snd_pcm_sync_ptr</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">snd_pcm_mmap_status</span> <span class="n">status</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">s</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">snd_pcm_mmap_control</span> <span class="n">control</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_xferi</span> <span class="p">{</span>
	<span class="n">snd_pcm_sframes_t</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">frames</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_xfern</span> <span class="p">{</span>
	<span class="n">snd_pcm_sframes_t</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">__user</span> <span class="o">*</span><span class="n">bufs</span><span class="p">;</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">frames</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SNDRV_PCM_TSTAMP_TYPE_GETTIMEOFDAY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* gettimeofday equivalent */</span>
	<span class="n">SNDRV_PCM_TSTAMP_TYPE_MONOTONIC</span><span class="p">,</span>	<span class="cm">/* posix_clock_monotonic equivalent */</span>
	<span class="n">SNDRV_PCM_TSTAMP_TYPE_LAST</span> <span class="o">=</span> <span class="n">SNDRV_PCM_TSTAMP_TYPE_MONOTONIC</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define SNDRV_PCM_IOCTL_PVERSION	_IOR(&#39;A&#39;, 0x00, int)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_INFO		_IOR(&#39;A&#39;, 0x01, struct snd_pcm_info)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_TSTAMP		_IOW(&#39;A&#39;, 0x02, int)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_TTSTAMP		_IOW(&#39;A&#39;, 0x03, int)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_HW_REFINE	_IOWR(&#39;A&#39;, 0x10, struct snd_pcm_hw_params)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_HW_PARAMS	_IOWR(&#39;A&#39;, 0x11, struct snd_pcm_hw_params)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_HW_FREE		_IO(&#39;A&#39;, 0x12)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_SW_PARAMS	_IOWR(&#39;A&#39;, 0x13, struct snd_pcm_sw_params)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_STATUS		_IOR(&#39;A&#39;, 0x20, struct snd_pcm_status)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_DELAY		_IOR(&#39;A&#39;, 0x21, snd_pcm_sframes_t)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_HWSYNC		_IO(&#39;A&#39;, 0x22)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_SYNC_PTR	_IOWR(&#39;A&#39;, 0x23, struct snd_pcm_sync_ptr)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_CHANNEL_INFO	_IOR(&#39;A&#39;, 0x32, struct snd_pcm_channel_info)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_PREPARE		_IO(&#39;A&#39;, 0x40)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_RESET		_IO(&#39;A&#39;, 0x41)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_START		_IO(&#39;A&#39;, 0x42)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_DROP		_IO(&#39;A&#39;, 0x43)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_DRAIN		_IO(&#39;A&#39;, 0x44)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_PAUSE		_IOW(&#39;A&#39;, 0x45, int)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_REWIND		_IOW(&#39;A&#39;, 0x46, snd_pcm_uframes_t)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_RESUME		_IO(&#39;A&#39;, 0x47)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_XRUN		_IO(&#39;A&#39;, 0x48)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_FORWARD		_IOW(&#39;A&#39;, 0x49, snd_pcm_uframes_t)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_WRITEI_FRAMES	_IOW(&#39;A&#39;, 0x50, struct snd_xferi)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_READI_FRAMES	_IOR(&#39;A&#39;, 0x51, struct snd_xferi)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_WRITEN_FRAMES	_IOW(&#39;A&#39;, 0x52, struct snd_xfern)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_READN_FRAMES	_IOR(&#39;A&#39;, 0x53, struct snd_xfern)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_LINK		_IOW(&#39;A&#39;, 0x60, int)</span>
<span class="cp">#define SNDRV_PCM_IOCTL_UNLINK		_IO(&#39;A&#39;, 0x61)</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *                                                                           *</span>
<span class="cm"> *                            MIDI v1.0 interface                            *</span>
<span class="cm"> *                                                                           *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> *  Raw MIDI section - /dev/snd/midi??</span>
<span class="cm"> */</span>

<span class="cp">#define SNDRV_RAWMIDI_VERSION		SNDRV_PROTOCOL_VERSION(2, 0, 0)</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SNDRV_RAWMIDI_STREAM_OUTPUT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SNDRV_RAWMIDI_STREAM_INPUT</span><span class="p">,</span>
	<span class="n">SNDRV_RAWMIDI_STREAM_LAST</span> <span class="o">=</span> <span class="n">SNDRV_RAWMIDI_STREAM_INPUT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define SNDRV_RAWMIDI_INFO_OUTPUT		0x00000001</span>
<span class="cp">#define SNDRV_RAWMIDI_INFO_INPUT		0x00000002</span>
<span class="cp">#define SNDRV_RAWMIDI_INFO_DUPLEX		0x00000004</span>

<span class="k">struct</span> <span class="n">snd_rawmidi_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">;</span>		<span class="cm">/* RO/WR (control): device number */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subdevice</span><span class="p">;</span>		<span class="cm">/* RO/WR (control): subdevice number */</span>
	<span class="kt">int</span> <span class="n">stream</span><span class="p">;</span>			<span class="cm">/* WR: stream */</span>
	<span class="kt">int</span> <span class="n">card</span><span class="p">;</span>			<span class="cm">/* R: card number */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* SNDRV_RAWMIDI_INFO_XXXX */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">id</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>		<span class="cm">/* ID (user selectable) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>		<span class="cm">/* name of device */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">subname</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="cm">/* name of active or selected subdevice */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subdevices_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subdevices_avail</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>	<span class="cm">/* reserved for future use */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_rawmidi_params</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">stream</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">;</span>		<span class="cm">/* queue size in bytes */</span>
	<span class="kt">size_t</span> <span class="n">avail_min</span><span class="p">;</span>		<span class="cm">/* minimum avail bytes for wakeup */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_active_sensing</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* do not send active sensing byte in close() */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* reserved for future use */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_rawmidi_status</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">stream</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">tstamp</span><span class="p">;</span>		<span class="cm">/* Timestamp */</span>
	<span class="kt">size_t</span> <span class="n">avail</span><span class="p">;</span>			<span class="cm">/* available bytes */</span>
	<span class="kt">size_t</span> <span class="n">xruns</span><span class="p">;</span>			<span class="cm">/* count of overruns since last status (in bytes) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* reserved for future use */</span>
<span class="p">};</span>

<span class="cp">#define SNDRV_RAWMIDI_IOCTL_PVERSION	_IOR(&#39;W&#39;, 0x00, int)</span>
<span class="cp">#define SNDRV_RAWMIDI_IOCTL_INFO	_IOR(&#39;W&#39;, 0x01, struct snd_rawmidi_info)</span>
<span class="cp">#define SNDRV_RAWMIDI_IOCTL_PARAMS	_IOWR(&#39;W&#39;, 0x10, struct snd_rawmidi_params)</span>
<span class="cp">#define SNDRV_RAWMIDI_IOCTL_STATUS	_IOWR(&#39;W&#39;, 0x20, struct snd_rawmidi_status)</span>
<span class="cp">#define SNDRV_RAWMIDI_IOCTL_DROP	_IOW(&#39;W&#39;, 0x30, int)</span>
<span class="cp">#define SNDRV_RAWMIDI_IOCTL_DRAIN	_IOW(&#39;W&#39;, 0x31, int)</span>

<span class="cm">/*</span>
<span class="cm"> *  Timer section - /dev/snd/timer</span>
<span class="cm"> */</span>

<span class="cp">#define SNDRV_TIMER_VERSION		SNDRV_PROTOCOL_VERSION(2, 0, 6)</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SNDRV_TIMER_CLASS_NONE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">SNDRV_TIMER_CLASS_SLAVE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SNDRV_TIMER_CLASS_GLOBAL</span><span class="p">,</span>
	<span class="n">SNDRV_TIMER_CLASS_CARD</span><span class="p">,</span>
	<span class="n">SNDRV_TIMER_CLASS_PCM</span><span class="p">,</span>
	<span class="n">SNDRV_TIMER_CLASS_LAST</span> <span class="o">=</span> <span class="n">SNDRV_TIMER_CLASS_PCM</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* slave timer classes */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SNDRV_TIMER_SCLASS_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SNDRV_TIMER_SCLASS_APPLICATION</span><span class="p">,</span>
	<span class="n">SNDRV_TIMER_SCLASS_SEQUENCER</span><span class="p">,</span>		<span class="cm">/* alias */</span>
	<span class="n">SNDRV_TIMER_SCLASS_OSS_SEQUENCER</span><span class="p">,</span>	<span class="cm">/* alias */</span>
	<span class="n">SNDRV_TIMER_SCLASS_LAST</span> <span class="o">=</span> <span class="n">SNDRV_TIMER_SCLASS_OSS_SEQUENCER</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* global timers (device member) */</span>
<span class="cp">#define SNDRV_TIMER_GLOBAL_SYSTEM	0</span>
<span class="cp">#define SNDRV_TIMER_GLOBAL_RTC		1</span>
<span class="cp">#define SNDRV_TIMER_GLOBAL_HPET		2</span>
<span class="cp">#define SNDRV_TIMER_GLOBAL_HRTIMER	3</span>

<span class="cm">/* info flags */</span>
<span class="cp">#define SNDRV_TIMER_FLG_SLAVE		(1&lt;&lt;0)	</span><span class="cm">/* cannot be controlled */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">snd_timer_id</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">dev_class</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dev_sclass</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">card</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">device</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">subdevice</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_timer_ginfo</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_timer_id</span> <span class="n">tid</span><span class="p">;</span>	<span class="cm">/* requested timer ID */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* timer flags - SNDRV_TIMER_FLG_* */</span>
	<span class="kt">int</span> <span class="n">card</span><span class="p">;</span>			<span class="cm">/* card number */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">id</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>		<span class="cm">/* timer identification */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>		<span class="cm">/* timer name */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reserved0</span><span class="p">;</span>	<span class="cm">/* reserved for future use */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">resolution</span><span class="p">;</span>	<span class="cm">/* average period resolution in ns */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">resolution_min</span><span class="p">;</span>	<span class="cm">/* minimal period resolution in ns */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">resolution_max</span><span class="p">;</span>	<span class="cm">/* maximal period resolution in ns */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clients</span><span class="p">;</span>		<span class="cm">/* active timer clients */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_timer_gparams</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_timer_id</span> <span class="n">tid</span><span class="p">;</span>	<span class="cm">/* requested timer ID */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">period_num</span><span class="p">;</span>	<span class="cm">/* requested precise period duration (in seconds) - numerator */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">period_den</span><span class="p">;</span>	<span class="cm">/* requested precise period duration (in seconds) - denominator */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_timer_gstatus</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_timer_id</span> <span class="n">tid</span><span class="p">;</span>	<span class="cm">/* requested timer ID */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">resolution</span><span class="p">;</span>	<span class="cm">/* current period resolution in ns */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">resolution_num</span><span class="p">;</span>	<span class="cm">/* precise current period resolution (in seconds) - numerator */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">resolution_den</span><span class="p">;</span>	<span class="cm">/* precise current period resolution (in seconds) - denominator */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_timer_select</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_timer_id</span> <span class="n">id</span><span class="p">;</span>	<span class="cm">/* bind to timer ID */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="cm">/* reserved */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_timer_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* timer flags - SNDRV_TIMER_FLG_* */</span>
	<span class="kt">int</span> <span class="n">card</span><span class="p">;</span>			<span class="cm">/* card number */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">id</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>		<span class="cm">/* timer identificator */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>		<span class="cm">/* timer name */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reserved0</span><span class="p">;</span>	<span class="cm">/* reserved for future use */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">resolution</span><span class="p">;</span>	<span class="cm">/* average period resolution in ns */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>	<span class="cm">/* reserved */</span>
<span class="p">};</span>

<span class="cp">#define SNDRV_TIMER_PSFLG_AUTO		(1&lt;&lt;0)	</span><span class="cm">/* auto start, otherwise one-shot */</span><span class="cp"></span>
<span class="cp">#define SNDRV_TIMER_PSFLG_EXCLUSIVE	(1&lt;&lt;1)	</span><span class="cm">/* exclusive use, precise start/stop/pause/continue */</span><span class="cp"></span>
<span class="cp">#define SNDRV_TIMER_PSFLG_EARLY_EVENT	(1&lt;&lt;2)	</span><span class="cm">/* write early event to the poll queue */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">snd_timer_params</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* flags - SNDRV_MIXER_PSFLG_* */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ticks</span><span class="p">;</span>		<span class="cm">/* requested resolution in ticks */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue_size</span><span class="p">;</span>	<span class="cm">/* total size of queue (32-1024) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reserved0</span><span class="p">;</span>		<span class="cm">/* reserved, was: failure locations */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">filter</span><span class="p">;</span>		<span class="cm">/* event filter (bitmask of SNDRV_TIMER_EVENT_*) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">60</span><span class="p">];</span>	<span class="cm">/* reserved */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_timer_status</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">tstamp</span><span class="p">;</span>		<span class="cm">/* Timestamp - last update */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resolution</span><span class="p">;</span>	<span class="cm">/* current period resolution in ns */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lost</span><span class="p">;</span>		<span class="cm">/* counter of master tick lost */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">overrun</span><span class="p">;</span>		<span class="cm">/* count of read queue overruns */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">;</span>		<span class="cm">/* used queue size */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>	<span class="cm">/* reserved */</span>
<span class="p">};</span>

<span class="cp">#define SNDRV_TIMER_IOCTL_PVERSION	_IOR(&#39;T&#39;, 0x00, int)</span>
<span class="cp">#define SNDRV_TIMER_IOCTL_NEXT_DEVICE	_IOWR(&#39;T&#39;, 0x01, struct snd_timer_id)</span>
<span class="cp">#define SNDRV_TIMER_IOCTL_TREAD		_IOW(&#39;T&#39;, 0x02, int)</span>
<span class="cp">#define SNDRV_TIMER_IOCTL_GINFO		_IOWR(&#39;T&#39;, 0x03, struct snd_timer_ginfo)</span>
<span class="cp">#define SNDRV_TIMER_IOCTL_GPARAMS	_IOW(&#39;T&#39;, 0x04, struct snd_timer_gparams)</span>
<span class="cp">#define SNDRV_TIMER_IOCTL_GSTATUS	_IOWR(&#39;T&#39;, 0x05, struct snd_timer_gstatus)</span>
<span class="cp">#define SNDRV_TIMER_IOCTL_SELECT	_IOW(&#39;T&#39;, 0x10, struct snd_timer_select)</span>
<span class="cp">#define SNDRV_TIMER_IOCTL_INFO		_IOR(&#39;T&#39;, 0x11, struct snd_timer_info)</span>
<span class="cp">#define SNDRV_TIMER_IOCTL_PARAMS	_IOW(&#39;T&#39;, 0x12, struct snd_timer_params)</span>
<span class="cp">#define SNDRV_TIMER_IOCTL_STATUS	_IOR(&#39;T&#39;, 0x14, struct snd_timer_status)</span>
<span class="cm">/* The following four ioctls are changed since 1.0.9 due to confliction */</span>
<span class="cp">#define SNDRV_TIMER_IOCTL_START		_IO(&#39;T&#39;, 0xa0)</span>
<span class="cp">#define SNDRV_TIMER_IOCTL_STOP		_IO(&#39;T&#39;, 0xa1)</span>
<span class="cp">#define SNDRV_TIMER_IOCTL_CONTINUE	_IO(&#39;T&#39;, 0xa2)</span>
<span class="cp">#define SNDRV_TIMER_IOCTL_PAUSE		_IO(&#39;T&#39;, 0xa3)</span>

<span class="k">struct</span> <span class="n">snd_timer_read</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resolution</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ticks</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SNDRV_TIMER_EVENT_RESOLUTION</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* val = resolution in ns */</span>
	<span class="n">SNDRV_TIMER_EVENT_TICK</span><span class="p">,</span>			<span class="cm">/* val = ticks */</span>
	<span class="n">SNDRV_TIMER_EVENT_START</span><span class="p">,</span>		<span class="cm">/* val = resolution in ns */</span>
	<span class="n">SNDRV_TIMER_EVENT_STOP</span><span class="p">,</span>			<span class="cm">/* val = 0 */</span>
	<span class="n">SNDRV_TIMER_EVENT_CONTINUE</span><span class="p">,</span>		<span class="cm">/* val = resolution in ns */</span>
	<span class="n">SNDRV_TIMER_EVENT_PAUSE</span><span class="p">,</span>		<span class="cm">/* val = 0 */</span>
	<span class="n">SNDRV_TIMER_EVENT_EARLY</span><span class="p">,</span>		<span class="cm">/* val = 0, early event */</span>
	<span class="n">SNDRV_TIMER_EVENT_SUSPEND</span><span class="p">,</span>		<span class="cm">/* val = 0 */</span>
	<span class="n">SNDRV_TIMER_EVENT_RESUME</span><span class="p">,</span>		<span class="cm">/* val = resolution in ns */</span>
	<span class="cm">/* master timer events for slave timer instances */</span>
	<span class="n">SNDRV_TIMER_EVENT_MSTART</span> <span class="o">=</span> <span class="n">SNDRV_TIMER_EVENT_START</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">SNDRV_TIMER_EVENT_MSTOP</span> <span class="o">=</span> <span class="n">SNDRV_TIMER_EVENT_STOP</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">SNDRV_TIMER_EVENT_MCONTINUE</span> <span class="o">=</span> <span class="n">SNDRV_TIMER_EVENT_CONTINUE</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">SNDRV_TIMER_EVENT_MPAUSE</span> <span class="o">=</span> <span class="n">SNDRV_TIMER_EVENT_PAUSE</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">SNDRV_TIMER_EVENT_MSUSPEND</span> <span class="o">=</span> <span class="n">SNDRV_TIMER_EVENT_SUSPEND</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">SNDRV_TIMER_EVENT_MRESUME</span> <span class="o">=</span> <span class="n">SNDRV_TIMER_EVENT_RESUME</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_timer_tread</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">tstamp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/****************************************************************************</span>
<span class="cm"> *                                                                          *</span>
<span class="cm"> *        Section for driver control interface - /dev/snd/control?          *</span>
<span class="cm"> *                                                                          *</span>
<span class="cm"> ****************************************************************************/</span>

<span class="cp">#define SNDRV_CTL_VERSION		SNDRV_PROTOCOL_VERSION(2, 0, 7)</span>

<span class="k">struct</span> <span class="n">snd_ctl_card_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">card</span><span class="p">;</span>			<span class="cm">/* card number */</span>
	<span class="kt">int</span> <span class="n">pad</span><span class="p">;</span>			<span class="cm">/* reserved for future (was type) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">id</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>		<span class="cm">/* ID of card (user selectable) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">driver</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* Driver name */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>		<span class="cm">/* Short name of soundcard */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">longname</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>	<span class="cm">/* name + info text about soundcard */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved_</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* reserved for future (was ID of mixer) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mixername</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>	<span class="cm">/* visual mixer identification */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">components</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>	<span class="cm">/* card components / fine identification, delimited with one space (AC97 etc..) */</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="n">__bitwise</span> <span class="n">snd_ctl_elem_type_t</span><span class="p">;</span>
<span class="cp">#define	SNDRV_CTL_ELEM_TYPE_NONE	((__force snd_ctl_elem_type_t) 0) </span><span class="cm">/* invalid */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_CTL_ELEM_TYPE_BOOLEAN	((__force snd_ctl_elem_type_t) 1) </span><span class="cm">/* boolean type */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_CTL_ELEM_TYPE_INTEGER	((__force snd_ctl_elem_type_t) 2) </span><span class="cm">/* integer type */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_CTL_ELEM_TYPE_ENUMERATED	((__force snd_ctl_elem_type_t) 3) </span><span class="cm">/* enumerated type */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_CTL_ELEM_TYPE_BYTES	((__force snd_ctl_elem_type_t) 4) </span><span class="cm">/* byte array */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_CTL_ELEM_TYPE_IEC958	((__force snd_ctl_elem_type_t) 5) </span><span class="cm">/* IEC958 (S/PDIF) setup */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_CTL_ELEM_TYPE_INTEGER64	((__force snd_ctl_elem_type_t) 6) </span><span class="cm">/* 64-bit integer type */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_CTL_ELEM_TYPE_LAST	SNDRV_CTL_ELEM_TYPE_INTEGER64</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="n">__bitwise</span> <span class="n">snd_ctl_elem_iface_t</span><span class="p">;</span>
<span class="cp">#define	SNDRV_CTL_ELEM_IFACE_CARD	((__force snd_ctl_elem_iface_t) 0) </span><span class="cm">/* global control */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_CTL_ELEM_IFACE_HWDEP	((__force snd_ctl_elem_iface_t) 1) </span><span class="cm">/* hardware dependent device */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_CTL_ELEM_IFACE_MIXER	((__force snd_ctl_elem_iface_t) 2) </span><span class="cm">/* virtual mixer device */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_CTL_ELEM_IFACE_PCM	((__force snd_ctl_elem_iface_t) 3) </span><span class="cm">/* PCM device */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_CTL_ELEM_IFACE_RAWMIDI	((__force snd_ctl_elem_iface_t) 4) </span><span class="cm">/* RawMidi device */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_CTL_ELEM_IFACE_TIMER	((__force snd_ctl_elem_iface_t) 5) </span><span class="cm">/* timer device */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_CTL_ELEM_IFACE_SEQUENCER	((__force snd_ctl_elem_iface_t) 6) </span><span class="cm">/* sequencer client */</span><span class="cp"></span>
<span class="cp">#define	SNDRV_CTL_ELEM_IFACE_LAST	SNDRV_CTL_ELEM_IFACE_SEQUENCER</span>

<span class="cp">#define SNDRV_CTL_ELEM_ACCESS_READ		(1&lt;&lt;0)</span>
<span class="cp">#define SNDRV_CTL_ELEM_ACCESS_WRITE		(1&lt;&lt;1)</span>
<span class="cp">#define SNDRV_CTL_ELEM_ACCESS_READWRITE		(SNDRV_CTL_ELEM_ACCESS_READ|SNDRV_CTL_ELEM_ACCESS_WRITE)</span>
<span class="cp">#define SNDRV_CTL_ELEM_ACCESS_VOLATILE		(1&lt;&lt;2)	</span><span class="cm">/* control value may be changed without a notification */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_ELEM_ACCESS_TIMESTAMP		(1&lt;&lt;3)	</span><span class="cm">/* when was control changed */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_ELEM_ACCESS_TLV_READ		(1&lt;&lt;4)	</span><span class="cm">/* TLV read is possible */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_ELEM_ACCESS_TLV_WRITE		(1&lt;&lt;5)	</span><span class="cm">/* TLV write is possible */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE	(SNDRV_CTL_ELEM_ACCESS_TLV_READ|SNDRV_CTL_ELEM_ACCESS_TLV_WRITE)</span>
<span class="cp">#define SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND	(1&lt;&lt;6)	</span><span class="cm">/* TLV command is possible */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_ELEM_ACCESS_INACTIVE		(1&lt;&lt;8)	</span><span class="cm">/* control does actually nothing, but may be updated */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_ELEM_ACCESS_LOCK		(1&lt;&lt;9)	</span><span class="cm">/* write lock */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_ELEM_ACCESS_OWNER		(1&lt;&lt;10)	</span><span class="cm">/* write lock owner */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK	(1&lt;&lt;28)	</span><span class="cm">/* kernel use a TLV callback */</span><span class="cp"> </span>
<span class="cp">#define SNDRV_CTL_ELEM_ACCESS_USER		(1&lt;&lt;29) </span><span class="cm">/* user space element */</span><span class="cp"></span>
<span class="cm">/* bits 30 and 31 are obsoleted (for indirect access) */</span>

<span class="cm">/* for further details see the ACPI and PCI power management specification */</span>
<span class="cp">#define SNDRV_CTL_POWER_D0		0x0000	</span><span class="cm">/* full On */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_POWER_D1		0x0100	</span><span class="cm">/* partial On */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_POWER_D2		0x0200	</span><span class="cm">/* partial On */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_POWER_D3		0x0300	</span><span class="cm">/* Off */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_POWER_D3hot		(SNDRV_CTL_POWER_D3|0x0000)	</span><span class="cm">/* Off, with power */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_POWER_D3cold		(SNDRV_CTL_POWER_D3|0x0001)	</span><span class="cm">/* Off, without power */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">snd_ctl_elem_id</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numid</span><span class="p">;</span>		<span class="cm">/* numeric identifier, zero = invalid */</span>
	<span class="n">snd_ctl_elem_iface_t</span> <span class="n">iface</span><span class="p">;</span>	<span class="cm">/* interface identifier */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">;</span>		<span class="cm">/* device/client number */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subdevice</span><span class="p">;</span>		<span class="cm">/* subdevice (substream) number */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">44</span><span class="p">];</span>		<span class="cm">/* ASCII name of item */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>		<span class="cm">/* index of item */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_ctl_elem_list</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>		<span class="cm">/* W: first element ID to get */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">space</span><span class="p">;</span>		<span class="cm">/* W: count of element IDs to get */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">used</span><span class="p">;</span>		<span class="cm">/* R: count of element IDs set */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>		<span class="cm">/* R: count of all elements */</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_id</span> <span class="n">__user</span> <span class="o">*</span><span class="n">pids</span><span class="p">;</span> <span class="cm">/* R: IDs */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_id</span> <span class="n">id</span><span class="p">;</span>	<span class="cm">/* W: element ID */</span>
	<span class="n">snd_ctl_elem_type_t</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* R: value type - SNDRV_CTL_ELEM_TYPE_* */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">access</span><span class="p">;</span>		<span class="cm">/* R: value access (bitmask) - SNDRV_CTL_ELEM_ACCESS_* */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>		<span class="cm">/* count of values */</span>
	<span class="n">__kernel_pid_t</span> <span class="n">owner</span><span class="p">;</span>		<span class="cm">/* owner&#39;s PID of this control */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">long</span> <span class="n">min</span><span class="p">;</span>		<span class="cm">/* R: minimum value */</span>
			<span class="kt">long</span> <span class="n">max</span><span class="p">;</span>		<span class="cm">/* R: maximum value */</span>
			<span class="kt">long</span> <span class="n">step</span><span class="p">;</span>		<span class="cm">/* R: step (0 variable) */</span>
		<span class="p">}</span> <span class="n">integer</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">long</span> <span class="kt">long</span> <span class="n">min</span><span class="p">;</span>		<span class="cm">/* R: minimum value */</span>
			<span class="kt">long</span> <span class="kt">long</span> <span class="n">max</span><span class="p">;</span>		<span class="cm">/* R: maximum value */</span>
			<span class="kt">long</span> <span class="kt">long</span> <span class="n">step</span><span class="p">;</span>		<span class="cm">/* R: step (0 variable) */</span>
		<span class="p">}</span> <span class="n">integer64</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">items</span><span class="p">;</span>	<span class="cm">/* R: number of items */</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">item</span><span class="p">;</span>	<span class="cm">/* W: item number */</span>
			<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>		<span class="cm">/* R: value name */</span>
			<span class="n">__u64</span> <span class="n">names_ptr</span><span class="p">;</span>	<span class="cm">/* W: names list (ELEM_ADD only) */</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">names_length</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">enumerated</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">d</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>		<span class="cm">/* dimensions */</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">d_ptr</span><span class="p">;</span>		<span class="cm">/* indirect - obsoleted */</span>
	<span class="p">}</span> <span class="n">dimen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_id</span> <span class="n">id</span><span class="p">;</span>	<span class="cm">/* W: element ID */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">indirect</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* W: indirect access - obsoleted */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">union</span> <span class="p">{</span>
			<span class="kt">long</span> <span class="n">value</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
			<span class="kt">long</span> <span class="o">*</span><span class="n">value_ptr</span><span class="p">;</span>	<span class="cm">/* obsoleted */</span>
		<span class="p">}</span> <span class="n">integer</span><span class="p">;</span>
		<span class="k">union</span> <span class="p">{</span>
			<span class="kt">long</span> <span class="kt">long</span> <span class="n">value</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
			<span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">value_ptr</span><span class="p">;</span>	<span class="cm">/* obsoleted */</span>
		<span class="p">}</span> <span class="n">integer64</span><span class="p">;</span>
		<span class="k">union</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">item</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">item_ptr</span><span class="p">;</span>	<span class="cm">/* obsoleted */</span>
		<span class="p">}</span> <span class="n">enumerated</span><span class="p">;</span>
		<span class="k">union</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data_ptr</span><span class="p">;</span>	<span class="cm">/* obsoleted */</span>
		<span class="p">}</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">snd_aes_iec958</span> <span class="n">iec958</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">value</span><span class="p">;</span>		<span class="cm">/* RO */</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">tstamp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">128</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span><span class="p">)];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_ctl_tlv</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numid</span><span class="p">;</span>	<span class="cm">/* control element numeric identification */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>	<span class="cm">/* in bytes aligned to 4 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tlv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* first TLV */</span>
<span class="p">};</span>

<span class="cp">#define SNDRV_CTL_IOCTL_PVERSION	_IOR(&#39;U&#39;, 0x00, int)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_CARD_INFO	_IOR(&#39;U&#39;, 0x01, struct snd_ctl_card_info)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_ELEM_LIST	_IOWR(&#39;U&#39;, 0x10, struct snd_ctl_elem_list)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_ELEM_INFO	_IOWR(&#39;U&#39;, 0x11, struct snd_ctl_elem_info)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_ELEM_READ	_IOWR(&#39;U&#39;, 0x12, struct snd_ctl_elem_value)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_ELEM_WRITE	_IOWR(&#39;U&#39;, 0x13, struct snd_ctl_elem_value)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_ELEM_LOCK	_IOW(&#39;U&#39;, 0x14, struct snd_ctl_elem_id)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_ELEM_UNLOCK	_IOW(&#39;U&#39;, 0x15, struct snd_ctl_elem_id)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS _IOWR(&#39;U&#39;, 0x16, int)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_ELEM_ADD	_IOWR(&#39;U&#39;, 0x17, struct snd_ctl_elem_info)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_ELEM_REPLACE	_IOWR(&#39;U&#39;, 0x18, struct snd_ctl_elem_info)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_ELEM_REMOVE	_IOWR(&#39;U&#39;, 0x19, struct snd_ctl_elem_id)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_TLV_READ	_IOWR(&#39;U&#39;, 0x1a, struct snd_ctl_tlv)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_TLV_WRITE	_IOWR(&#39;U&#39;, 0x1b, struct snd_ctl_tlv)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_TLV_COMMAND	_IOWR(&#39;U&#39;, 0x1c, struct snd_ctl_tlv)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_HWDEP_NEXT_DEVICE _IOWR(&#39;U&#39;, 0x20, int)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_HWDEP_INFO	_IOR(&#39;U&#39;, 0x21, struct snd_hwdep_info)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE	_IOR(&#39;U&#39;, 0x30, int)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_PCM_INFO	_IOWR(&#39;U&#39;, 0x31, struct snd_pcm_info)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_PCM_PREFER_SUBDEVICE _IOW(&#39;U&#39;, 0x32, int)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_RAWMIDI_NEXT_DEVICE _IOWR(&#39;U&#39;, 0x40, int)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_RAWMIDI_INFO	_IOWR(&#39;U&#39;, 0x41, struct snd_rawmidi_info)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_RAWMIDI_PREFER_SUBDEVICE _IOW(&#39;U&#39;, 0x42, int)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_POWER		_IOWR(&#39;U&#39;, 0xd0, int)</span>
<span class="cp">#define SNDRV_CTL_IOCTL_POWER_STATE	_IOR(&#39;U&#39;, 0xd1, int)</span>

<span class="cm">/*</span>
<span class="cm"> *  Read interface.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">sndrv_ctl_event_type</span> <span class="p">{</span>
	<span class="n">SNDRV_CTL_EVENT_ELEM</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SNDRV_CTL_EVENT_LAST</span> <span class="o">=</span> <span class="n">SNDRV_CTL_EVENT_ELEM</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define SNDRV_CTL_EVENT_MASK_VALUE	(1&lt;&lt;0)	</span><span class="cm">/* element value was changed */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_EVENT_MASK_INFO	(1&lt;&lt;1)	</span><span class="cm">/* element info was changed */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_EVENT_MASK_ADD	(1&lt;&lt;2)	</span><span class="cm">/* element was added */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_EVENT_MASK_TLV	(1&lt;&lt;3)	</span><span class="cm">/* element TLV tree was changed */</span><span class="cp"></span>
<span class="cp">#define SNDRV_CTL_EVENT_MASK_REMOVE	(~0U)	</span><span class="cm">/* element was removed */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">snd_ctl_event</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* event type - SNDRV_CTL_EVENT_* */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">snd_ctl_elem_id</span> <span class="n">id</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">elem</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data8</span><span class="p">[</span><span class="mi">60</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  Control names</span>
<span class="cm"> */</span>

<span class="cp">#define SNDRV_CTL_NAME_NONE				&quot;&quot;</span>
<span class="cp">#define SNDRV_CTL_NAME_PLAYBACK				&quot;Playback &quot;</span>
<span class="cp">#define SNDRV_CTL_NAME_CAPTURE				&quot;Capture &quot;</span>

<span class="cp">#define SNDRV_CTL_NAME_IEC958_NONE			&quot;&quot;</span>
<span class="cp">#define SNDRV_CTL_NAME_IEC958_SWITCH			&quot;Switch&quot;</span>
<span class="cp">#define SNDRV_CTL_NAME_IEC958_VOLUME			&quot;Volume&quot;</span>
<span class="cp">#define SNDRV_CTL_NAME_IEC958_DEFAULT			&quot;Default&quot;</span>
<span class="cp">#define SNDRV_CTL_NAME_IEC958_MASK			&quot;Mask&quot;</span>
<span class="cp">#define SNDRV_CTL_NAME_IEC958_CON_MASK			&quot;Con Mask&quot;</span>
<span class="cp">#define SNDRV_CTL_NAME_IEC958_PRO_MASK			&quot;Pro Mask&quot;</span>
<span class="cp">#define SNDRV_CTL_NAME_IEC958_PCM_STREAM		&quot;PCM Stream&quot;</span>
<span class="cp">#define SNDRV_CTL_NAME_IEC958(expl,direction,what)	&quot;IEC958 &quot; expl SNDRV_CTL_NAME_##direction SNDRV_CTL_NAME_IEC958_##what</span>

<span class="cp">#endif </span><span class="cm">/* __SOUND_ASOUND_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
