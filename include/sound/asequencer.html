<!DOCTYPE html>
<html><head><title>joekychen/linux » include › sound › asequencer.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>asequencer.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Main header file for the ALSA sequencer</span>
<span class="cm"> *  Copyright (c) 1998-1999 by Frank van de Pol &lt;fvdpol@coil.demon.nl&gt;</span>
<span class="cm"> *            (c) 1998-1999 by Jaroslav Kysela &lt;perex@perex.cz&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *   GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __SOUND_ASEQUENCER_H</span>
<span class="cp">#define __SOUND_ASEQUENCER_H</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/ioctl.h&gt;</span>
<span class="cp">#include &lt;sound/asound.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/** version of the sequencer */</span>
<span class="cp">#define SNDRV_SEQ_VERSION SNDRV_PROTOCOL_VERSION (1, 0, 1)</span>

<span class="cm">/**</span>
<span class="cm"> * definition of sequencer event types</span>
<span class="cm"> */</span>

<span class="cm">/** system messages</span>
<span class="cm"> * event data type = #snd_seq_result</span>
<span class="cm"> */</span>
<span class="cp">#define SNDRV_SEQ_EVENT_SYSTEM		0</span>
<span class="cp">#define SNDRV_SEQ_EVENT_RESULT		1</span>

<span class="cm">/** note messages (channel specific)</span>
<span class="cm"> * event data type = #snd_seq_ev_note</span>
<span class="cm"> */</span>
<span class="cp">#define SNDRV_SEQ_EVENT_NOTE		5</span>
<span class="cp">#define SNDRV_SEQ_EVENT_NOTEON		6</span>
<span class="cp">#define SNDRV_SEQ_EVENT_NOTEOFF		7</span>
<span class="cp">#define SNDRV_SEQ_EVENT_KEYPRESS	8</span>
	
<span class="cm">/** control messages (channel specific)</span>
<span class="cm"> * event data type = #snd_seq_ev_ctrl</span>
<span class="cm"> */</span>
<span class="cp">#define SNDRV_SEQ_EVENT_CONTROLLER	10</span>
<span class="cp">#define SNDRV_SEQ_EVENT_PGMCHANGE	11</span>
<span class="cp">#define SNDRV_SEQ_EVENT_CHANPRESS	12</span>
<span class="cp">#define SNDRV_SEQ_EVENT_PITCHBEND	13	</span><span class="cm">/**&lt; from -8192 to 8191 */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_CONTROL14	14	</span><span class="cm">/**&lt; 14 bit controller value */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_NONREGPARAM	15	</span><span class="cm">/**&lt; 14 bit NRPN address + 14 bit unsigned value */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_REGPARAM	16	</span><span class="cm">/**&lt; 14 bit RPN address + 14 bit unsigned value */</span><span class="cp"></span>

<span class="cm">/** synchronisation messages</span>
<span class="cm"> * event data type = #snd_seq_ev_ctrl</span>
<span class="cm"> */</span>
<span class="cp">#define SNDRV_SEQ_EVENT_SONGPOS		20	</span><span class="cm">/* Song Position Pointer with LSB and MSB values */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_SONGSEL		21	</span><span class="cm">/* Song Select with song ID number */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_QFRAME		22	</span><span class="cm">/* midi time code quarter frame */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_TIMESIGN	23	</span><span class="cm">/* SMF Time Signature event */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_KEYSIGN		24	</span><span class="cm">/* SMF Key Signature event */</span><span class="cp"></span>
	        
<span class="cm">/** timer messages</span>
<span class="cm"> * event data type = snd_seq_ev_queue_control</span>
<span class="cm"> */</span>
<span class="cp">#define SNDRV_SEQ_EVENT_START		30	</span><span class="cm">/* midi Real Time Start message */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_CONTINUE	31	</span><span class="cm">/* midi Real Time Continue message */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_STOP		32	</span><span class="cm">/* midi Real Time Stop message */</span><span class="cp">	</span>
<span class="cp">#define	SNDRV_SEQ_EVENT_SETPOS_TICK	33	</span><span class="cm">/* set tick queue position */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_SETPOS_TIME	34	</span><span class="cm">/* set realtime queue position */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_TEMPO		35	</span><span class="cm">/* (SMF) Tempo event */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_CLOCK		36	</span><span class="cm">/* midi Real Time Clock message */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_TICK		37	</span><span class="cm">/* midi Real Time Tick message */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_QUEUE_SKEW	38	</span><span class="cm">/* skew queue tempo */</span><span class="cp"></span>

<span class="cm">/** others</span>
<span class="cm"> * event data type = none</span>
<span class="cm"> */</span>
<span class="cp">#define SNDRV_SEQ_EVENT_TUNE_REQUEST	40	</span><span class="cm">/* tune request */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_RESET		41	</span><span class="cm">/* reset to power-on state */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_SENSING		42	</span><span class="cm">/* &quot;active sensing&quot; event */</span><span class="cp"></span>

<span class="cm">/** echo back, kernel private messages</span>
<span class="cm"> * event data type = any type</span>
<span class="cm"> */</span>
<span class="cp">#define SNDRV_SEQ_EVENT_ECHO		50	</span><span class="cm">/* echo event */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_OSS		51	</span><span class="cm">/* OSS raw event */</span><span class="cp"></span>

<span class="cm">/** system status messages (broadcast for subscribers)</span>
<span class="cm"> * event data type = snd_seq_addr</span>
<span class="cm"> */</span>
<span class="cp">#define SNDRV_SEQ_EVENT_CLIENT_START	60	</span><span class="cm">/* new client has connected */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_CLIENT_EXIT	61	</span><span class="cm">/* client has left the system */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_CLIENT_CHANGE	62	</span><span class="cm">/* client status/info has changed */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_PORT_START	63	</span><span class="cm">/* new port was created */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_PORT_EXIT	64	</span><span class="cm">/* port was deleted from system */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_PORT_CHANGE	65	</span><span class="cm">/* port status/info has changed */</span><span class="cp"></span>

<span class="cm">/** port connection changes</span>
<span class="cm"> * event data type = snd_seq_connect</span>
<span class="cm"> */</span>
<span class="cp">#define SNDRV_SEQ_EVENT_PORT_SUBSCRIBED	66	</span><span class="cm">/* ports connected */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_PORT_UNSUBSCRIBED 67	</span><span class="cm">/* ports disconnected */</span><span class="cp"></span>

<span class="cm">/* 70-89:  synthesizer events - obsoleted */</span>

<span class="cm">/** user-defined events with fixed length</span>
<span class="cm"> * event data type = any</span>
<span class="cm"> */</span>
<span class="cp">#define SNDRV_SEQ_EVENT_USR0		90</span>
<span class="cp">#define SNDRV_SEQ_EVENT_USR1		91</span>
<span class="cp">#define SNDRV_SEQ_EVENT_USR2		92</span>
<span class="cp">#define SNDRV_SEQ_EVENT_USR3		93</span>
<span class="cp">#define SNDRV_SEQ_EVENT_USR4		94</span>
<span class="cp">#define SNDRV_SEQ_EVENT_USR5		95</span>
<span class="cp">#define SNDRV_SEQ_EVENT_USR6		96</span>
<span class="cp">#define SNDRV_SEQ_EVENT_USR7		97</span>
<span class="cp">#define SNDRV_SEQ_EVENT_USR8		98</span>
<span class="cp">#define SNDRV_SEQ_EVENT_USR9		99</span>

<span class="cm">/* 100-118: instrument layer - obsoleted */</span>
<span class="cm">/* 119-129: reserved */</span>

<span class="cm">/* 130-139: variable length events</span>
<span class="cm"> * event data type = snd_seq_ev_ext</span>
<span class="cm"> * (SNDRV_SEQ_EVENT_LENGTH_VARIABLE must be set)</span>
<span class="cm"> */</span>
<span class="cp">#define SNDRV_SEQ_EVENT_SYSEX		130	</span><span class="cm">/* system exclusive data (variable length) */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_BOUNCE		131	</span><span class="cm">/* error event */</span><span class="cp"></span>
<span class="cm">/* 132-134: reserved */</span>
<span class="cp">#define SNDRV_SEQ_EVENT_USR_VAR0	135</span>
<span class="cp">#define SNDRV_SEQ_EVENT_USR_VAR1	136</span>
<span class="cp">#define SNDRV_SEQ_EVENT_USR_VAR2	137</span>
<span class="cp">#define SNDRV_SEQ_EVENT_USR_VAR3	138</span>
<span class="cp">#define SNDRV_SEQ_EVENT_USR_VAR4	139</span>

<span class="cm">/* 150-151: kernel events with quote - DO NOT use in user clients */</span>
<span class="cp">#define SNDRV_SEQ_EVENT_KERNEL_ERROR	150</span>
<span class="cp">#define SNDRV_SEQ_EVENT_KERNEL_QUOTE	151	</span><span class="cm">/* obsolete */</span><span class="cp"></span>

<span class="cm">/* 152-191: reserved */</span>

<span class="cm">/* 192-254: hardware specific events */</span>

<span class="cm">/* 255: special event */</span>
<span class="cp">#define SNDRV_SEQ_EVENT_NONE		255</span>


<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">snd_seq_event_type_t</span><span class="p">;</span>

<span class="cm">/** event address */</span>
<span class="k">struct</span> <span class="n">snd_seq_addr</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">client</span><span class="p">;</span>	<span class="cm">/**&lt; Client number:         0..255, 255 = broadcast to all clients */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">port</span><span class="p">;</span>	<span class="cm">/**&lt; Port within client:    0..255, 255 = broadcast to all ports */</span>
<span class="p">};</span>

<span class="cm">/** port connection */</span>
<span class="k">struct</span> <span class="n">snd_seq_connect</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_seq_addr</span> <span class="n">sender</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_seq_addr</span> <span class="n">dest</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp">#define SNDRV_SEQ_ADDRESS_UNKNOWN	253	</span><span class="cm">/* unknown source */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_ADDRESS_SUBSCRIBERS	254	</span><span class="cm">/* send event to all subscribed ports */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_ADDRESS_BROADCAST	255	</span><span class="cm">/* send event to all queues/clients/ports/channels */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_QUEUE_DIRECT		253	</span><span class="cm">/* direct dispatch */</span><span class="cp"></span>

	<span class="cm">/* event mode flag - NOTE: only 8 bits available! */</span>
<span class="cp">#define SNDRV_SEQ_TIME_STAMP_TICK	(0&lt;&lt;0) </span><span class="cm">/* timestamp in clock ticks */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_TIME_STAMP_REAL	(1&lt;&lt;0) </span><span class="cm">/* timestamp in real time */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_TIME_STAMP_MASK	(1&lt;&lt;0)</span>

<span class="cp">#define SNDRV_SEQ_TIME_MODE_ABS		(0&lt;&lt;1)	</span><span class="cm">/* absolute timestamp */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_TIME_MODE_REL		(1&lt;&lt;1)	</span><span class="cm">/* relative to current time */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_TIME_MODE_MASK	(1&lt;&lt;1)</span>

<span class="cp">#define SNDRV_SEQ_EVENT_LENGTH_FIXED	(0&lt;&lt;2)	</span><span class="cm">/* fixed event size */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_LENGTH_VARIABLE	(1&lt;&lt;2)	</span><span class="cm">/* variable event size */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_LENGTH_VARUSR	(2&lt;&lt;2)	</span><span class="cm">/* variable event size - user memory space */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_EVENT_LENGTH_MASK	(3&lt;&lt;2)</span>

<span class="cp">#define SNDRV_SEQ_PRIORITY_NORMAL	(0&lt;&lt;4)	</span><span class="cm">/* normal priority */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PRIORITY_HIGH		(1&lt;&lt;4)	</span><span class="cm">/* event should be processed before others */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PRIORITY_MASK		(1&lt;&lt;4)</span>


	<span class="cm">/* note event */</span>
<span class="k">struct</span> <span class="n">snd_seq_ev_note</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">note</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">velocity</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">off_velocity</span><span class="p">;</span>	<span class="cm">/* only for SNDRV_SEQ_EVENT_NOTE */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">duration</span><span class="p">;</span>		<span class="cm">/* only for SNDRV_SEQ_EVENT_NOTE */</span>
<span class="p">};</span>

	<span class="cm">/* controller event */</span>
<span class="k">struct</span> <span class="n">snd_seq_ev_ctrl</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">unused1</span><span class="p">,</span> <span class="n">unused2</span><span class="p">,</span> <span class="n">unused3</span><span class="p">;</span>	<span class="cm">/* pad */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">param</span><span class="p">;</span>
	<span class="kt">signed</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

	<span class="cm">/* generic set of bytes (12x8 bit) */</span>
<span class="k">struct</span> <span class="n">snd_seq_ev_raw8</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">d</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>	<span class="cm">/* 8 bit value */</span>
<span class="p">};</span>

	<span class="cm">/* generic set of integers (3x32 bit) */</span>
<span class="k">struct</span> <span class="n">snd_seq_ev_raw32</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* 32 bit value */</span>
<span class="p">};</span>

	<span class="cm">/* external stored data */</span>
<span class="k">struct</span> <span class="n">snd_seq_ev_ext</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>	<span class="cm">/* length of data */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>		<span class="cm">/* pointer to data (note: maybe 64-bit) */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">snd_seq_result</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">event</span><span class="p">;</span>		<span class="cm">/* processed event type */</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">snd_seq_real_time</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tv_sec</span><span class="p">;</span>	<span class="cm">/* seconds */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tv_nsec</span><span class="p">;</span>	<span class="cm">/* nanoseconds */</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">snd_seq_tick_time_t</span><span class="p">;</span>	<span class="cm">/* midi ticks */</span>

<span class="k">union</span> <span class="n">snd_seq_timestamp</span> <span class="p">{</span>
	<span class="n">snd_seq_tick_time_t</span> <span class="n">tick</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_seq_real_time</span> <span class="n">time</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_seq_queue_skew</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">;</span>
<span class="p">};</span>

	<span class="cm">/* queue timer control */</span>
<span class="k">struct</span> <span class="n">snd_seq_ev_queue_control</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">queue</span><span class="p">;</span>			<span class="cm">/* affected queue */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pad</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>			<span class="cm">/* reserved */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">signed</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>		<span class="cm">/* affected value (e.g. tempo) */</span>
		<span class="k">union</span> <span class="n">snd_seq_timestamp</span> <span class="n">time</span><span class="p">;</span>	<span class="cm">/* time */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">position</span><span class="p">;</span>		<span class="cm">/* sync position */</span>
		<span class="k">struct</span> <span class="n">snd_seq_queue_skew</span> <span class="n">skew</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d32</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">d8</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">param</span><span class="p">;</span>
<span class="p">};</span>

	<span class="cm">/* quoted event - inside the kernel only */</span>
<span class="k">struct</span> <span class="n">snd_seq_ev_quote</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_seq_addr</span> <span class="n">origin</span><span class="p">;</span>		<span class="cm">/* original sender */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">value</span><span class="p">;</span>		<span class="cm">/* optional data */</span>
	<span class="k">struct</span> <span class="n">snd_seq_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>		<span class="cm">/* quoted event */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>


	<span class="cm">/* sequencer event */</span>
<span class="k">struct</span> <span class="n">snd_seq_event</span> <span class="p">{</span>
	<span class="n">snd_seq_event_type_t</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* event type */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* event flags */</span>
	<span class="kt">char</span> <span class="n">tag</span><span class="p">;</span>
	
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">queue</span><span class="p">;</span>		<span class="cm">/* schedule queue */</span>
	<span class="k">union</span> <span class="n">snd_seq_timestamp</span> <span class="n">time</span><span class="p">;</span>	<span class="cm">/* schedule time */</span>


	<span class="k">struct</span> <span class="n">snd_seq_addr</span> <span class="n">source</span><span class="p">;</span>	<span class="cm">/* source address */</span>
	<span class="k">struct</span> <span class="n">snd_seq_addr</span> <span class="n">dest</span><span class="p">;</span>	<span class="cm">/* destination address */</span>

	<span class="k">union</span> <span class="p">{</span>				<span class="cm">/* event data... */</span>
		<span class="k">struct</span> <span class="n">snd_seq_ev_note</span> <span class="n">note</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">snd_seq_ev_ctrl</span> <span class="n">control</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">snd_seq_ev_raw8</span> <span class="n">raw8</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">snd_seq_ev_raw32</span> <span class="n">raw32</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">snd_seq_ev_ext</span> <span class="n">ext</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">snd_seq_ev_queue_control</span> <span class="n">queue</span><span class="p">;</span>
		<span class="k">union</span> <span class="n">snd_seq_timestamp</span> <span class="n">time</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">snd_seq_addr</span> <span class="n">addr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">snd_seq_connect</span> <span class="n">connect</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">snd_seq_result</span> <span class="n">result</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">snd_seq_ev_quote</span> <span class="n">quote</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * bounce event - stored as variable size data</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">snd_seq_event_bounce</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_seq_event</span> <span class="n">event</span><span class="p">;</span>
	<span class="cm">/* external data follows here. */</span>
<span class="p">};</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/* helper macro */</span>
<span class="cp">#define snd_seq_event_bounce_ext_data(ev) ((void*)((char *)(ev)-&gt;data.ext.ptr + sizeof(struct snd_seq_event_bounce)))</span>

<span class="cm">/*</span>
<span class="cm"> * type check macros</span>
<span class="cm"> */</span>
<span class="cm">/* result events: 0-4 */</span>
<span class="cp">#define snd_seq_ev_is_result_type(ev)	((ev)-&gt;type &lt; 5)</span>
<span class="cm">/* channel specific events: 5-19 */</span>
<span class="cp">#define snd_seq_ev_is_channel_type(ev)	((ev)-&gt;type &gt;= 5 &amp;&amp; (ev)-&gt;type &lt; 20)</span>
<span class="cm">/* note events: 5-9 */</span>
<span class="cp">#define snd_seq_ev_is_note_type(ev)	((ev)-&gt;type &gt;= 5 &amp;&amp; (ev)-&gt;type &lt; 10)</span>
<span class="cm">/* control events: 10-19 */</span>
<span class="cp">#define snd_seq_ev_is_control_type(ev)	((ev)-&gt;type &gt;= 10 &amp;&amp; (ev)-&gt;type &lt; 20)</span>
<span class="cm">/* queue control events: 30-39 */</span>
<span class="cp">#define snd_seq_ev_is_queue_type(ev)	((ev)-&gt;type &gt;= 30 &amp;&amp; (ev)-&gt;type &lt; 40)</span>
<span class="cm">/* system status messages */</span>
<span class="cp">#define snd_seq_ev_is_message_type(ev)	((ev)-&gt;type &gt;= 60 &amp;&amp; (ev)-&gt;type &lt; 69)</span>
<span class="cm">/* sample messages */</span>
<span class="cp">#define snd_seq_ev_is_sample_type(ev)	((ev)-&gt;type &gt;= 70 &amp;&amp; (ev)-&gt;type &lt; 79)</span>
<span class="cm">/* user-defined messages */</span>
<span class="cp">#define snd_seq_ev_is_user_type(ev)	((ev)-&gt;type &gt;= 90 &amp;&amp; (ev)-&gt;type &lt; 99)</span>
<span class="cm">/* fixed length events: 0-99 */</span>
<span class="cp">#define snd_seq_ev_is_fixed_type(ev)	((ev)-&gt;type &lt; 100)</span>
<span class="cm">/* variable length events: 130-139 */</span>
<span class="cp">#define snd_seq_ev_is_variable_type(ev)	((ev)-&gt;type &gt;= 130 &amp;&amp; (ev)-&gt;type &lt; 140)</span>
<span class="cm">/* reserved for kernel */</span>
<span class="cp">#define snd_seq_ev_is_reserved(ev)	((ev)-&gt;type &gt;= 150)</span>

<span class="cm">/* direct dispatched events */</span>
<span class="cp">#define snd_seq_ev_is_direct(ev)	((ev)-&gt;queue == SNDRV_SEQ_QUEUE_DIRECT)</span>

<span class="cm">/*</span>
<span class="cm"> * macros to check event flags</span>
<span class="cm"> */</span>
<span class="cm">/* prior events */</span>
<span class="cp">#define snd_seq_ev_is_prior(ev)		(((ev)-&gt;flags &amp; SNDRV_SEQ_PRIORITY_MASK) == SNDRV_SEQ_PRIORITY_HIGH)</span>

<span class="cm">/* event length type */</span>
<span class="cp">#define snd_seq_ev_length_type(ev)	((ev)-&gt;flags &amp; SNDRV_SEQ_EVENT_LENGTH_MASK)</span>
<span class="cp">#define snd_seq_ev_is_fixed(ev)		(snd_seq_ev_length_type(ev) == SNDRV_SEQ_EVENT_LENGTH_FIXED)</span>
<span class="cp">#define snd_seq_ev_is_variable(ev)	(snd_seq_ev_length_type(ev) == SNDRV_SEQ_EVENT_LENGTH_VARIABLE)</span>
<span class="cp">#define snd_seq_ev_is_varusr(ev)	(snd_seq_ev_length_type(ev) == SNDRV_SEQ_EVENT_LENGTH_VARUSR)</span>

<span class="cm">/* time-stamp type */</span>
<span class="cp">#define snd_seq_ev_timestamp_type(ev)	((ev)-&gt;flags &amp; SNDRV_SEQ_TIME_STAMP_MASK)</span>
<span class="cp">#define snd_seq_ev_is_tick(ev)		(snd_seq_ev_timestamp_type(ev) == SNDRV_SEQ_TIME_STAMP_TICK)</span>
<span class="cp">#define snd_seq_ev_is_real(ev)		(snd_seq_ev_timestamp_type(ev) == SNDRV_SEQ_TIME_STAMP_REAL)</span>

<span class="cm">/* time-mode type */</span>
<span class="cp">#define snd_seq_ev_timemode_type(ev)	((ev)-&gt;flags &amp; SNDRV_SEQ_TIME_MODE_MASK)</span>
<span class="cp">#define snd_seq_ev_is_abstime(ev)	(snd_seq_ev_timemode_type(ev) == SNDRV_SEQ_TIME_MODE_ABS)</span>
<span class="cp">#define snd_seq_ev_is_reltime(ev)	(snd_seq_ev_timemode_type(ev) == SNDRV_SEQ_TIME_MODE_REL)</span>

<span class="cm">/* queue sync port */</span>
<span class="cp">#define snd_seq_queue_sync_port(q)	((q) + 16)</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

	<span class="cm">/* system information */</span>
<span class="k">struct</span> <span class="n">snd_seq_system_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">queues</span><span class="p">;</span>			<span class="cm">/* maximum queues count */</span>
	<span class="kt">int</span> <span class="n">clients</span><span class="p">;</span>			<span class="cm">/* maximum clients count */</span>
	<span class="kt">int</span> <span class="n">ports</span><span class="p">;</span>			<span class="cm">/* maximum ports per client */</span>
	<span class="kt">int</span> <span class="n">channels</span><span class="p">;</span>			<span class="cm">/* maximum channels per port */</span>
	<span class="kt">int</span> <span class="n">cur_clients</span><span class="p">;</span>		<span class="cm">/* current clients */</span>
	<span class="kt">int</span> <span class="n">cur_queues</span><span class="p">;</span>			<span class="cm">/* current queues */</span>
	<span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
<span class="p">};</span>


	<span class="cm">/* system running information */</span>
<span class="k">struct</span> <span class="n">snd_seq_running_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">client</span><span class="p">;</span>		<span class="cm">/* client id */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">big_endian</span><span class="p">;</span>	<span class="cm">/* 1 = big-endian */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cpu_mode</span><span class="p">;</span>		<span class="cm">/* 4 = 32bit, 8 = 64bit */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pad</span><span class="p">;</span>		<span class="cm">/* reserved */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="p">};</span>


	<span class="cm">/* known client numbers */</span>
<span class="cp">#define SNDRV_SEQ_CLIENT_SYSTEM		0</span>
	<span class="cm">/* internal client numbers */</span>
<span class="cp">#define SNDRV_SEQ_CLIENT_DUMMY		14	</span><span class="cm">/* midi through */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_CLIENT_OSS		15	</span><span class="cm">/* oss sequencer emulator */</span><span class="cp"></span>


	<span class="cm">/* client types */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">__bitwise</span> <span class="n">snd_seq_client_type_t</span><span class="p">;</span>
<span class="cp">#define	NO_CLIENT	((__force snd_seq_client_type_t) 0)</span>
<span class="cp">#define	USER_CLIENT	((__force snd_seq_client_type_t) 1)</span>
<span class="cp">#define	KERNEL_CLIENT	((__force snd_seq_client_type_t) 2)</span>
                        
	<span class="cm">/* event filter flags */</span>
<span class="cp">#define SNDRV_SEQ_FILTER_BROADCAST	(1&lt;&lt;0)	</span><span class="cm">/* accept broadcast messages */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_FILTER_MULTICAST	(1&lt;&lt;1)	</span><span class="cm">/* accept multicast messages */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_FILTER_BOUNCE		(1&lt;&lt;2)	</span><span class="cm">/* accept bounce event in error */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_FILTER_USE_EVENT	(1&lt;&lt;31)	</span><span class="cm">/* use event filter */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">snd_seq_client_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">client</span><span class="p">;</span>			<span class="cm">/* client number to inquire */</span>
	<span class="n">snd_seq_client_type_t</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* client type */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>			<span class="cm">/* client name */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">filter</span><span class="p">;</span>		<span class="cm">/* filter flags */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">multicast_filter</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* multicast filter bitmap */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">event_filter</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="cm">/* event filter bitmap */</span>
	<span class="kt">int</span> <span class="n">num_ports</span><span class="p">;</span>			<span class="cm">/* RO: number of ports */</span>
	<span class="kt">int</span> <span class="n">event_lost</span><span class="p">;</span>			<span class="cm">/* number of lost events */</span>
	<span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>		<span class="cm">/* for future use */</span>
<span class="p">};</span>


<span class="cm">/* client pool size */</span>
<span class="k">struct</span> <span class="n">snd_seq_client_pool</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">client</span><span class="p">;</span>			<span class="cm">/* client number to inquire */</span>
	<span class="kt">int</span> <span class="n">output_pool</span><span class="p">;</span>		<span class="cm">/* outgoing (write) pool size */</span>
	<span class="kt">int</span> <span class="n">input_pool</span><span class="p">;</span>			<span class="cm">/* incoming (read) pool size */</span>
	<span class="kt">int</span> <span class="n">output_room</span><span class="p">;</span>		<span class="cm">/* minimum free pool size for select/blocking mode */</span>
	<span class="kt">int</span> <span class="n">output_free</span><span class="p">;</span>		<span class="cm">/* unused size */</span>
	<span class="kt">int</span> <span class="n">input_free</span><span class="p">;</span>			<span class="cm">/* unused size */</span>
	<span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="p">};</span>


<span class="cm">/* Remove events by specified criteria */</span>

<span class="cp">#define SNDRV_SEQ_REMOVE_INPUT		(1&lt;&lt;0)	</span><span class="cm">/* Flush input queues */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_REMOVE_OUTPUT		(1&lt;&lt;1)	</span><span class="cm">/* Flush output queues */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_REMOVE_DEST		(1&lt;&lt;2)	</span><span class="cm">/* Restrict by destination q:client:port */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_REMOVE_DEST_CHANNEL	(1&lt;&lt;3)	</span><span class="cm">/* Restrict by channel */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_REMOVE_TIME_BEFORE	(1&lt;&lt;4)	</span><span class="cm">/* Restrict to before time */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_REMOVE_TIME_AFTER	(1&lt;&lt;5)	</span><span class="cm">/* Restrict to time or after */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_REMOVE_TIME_TICK	(1&lt;&lt;6)	</span><span class="cm">/* Time is in ticks */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_REMOVE_EVENT_TYPE	(1&lt;&lt;7)	</span><span class="cm">/* Restrict to event type */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_REMOVE_IGNORE_OFF 	(1&lt;&lt;8)	</span><span class="cm">/* Do not flush off events */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_REMOVE_TAG_MATCH 	(1&lt;&lt;9)	</span><span class="cm">/* Restrict to events with given tag */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">snd_seq_remove_events</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">remove_mode</span><span class="p">;</span>	<span class="cm">/* Flags that determine what gets removed */</span>

	<span class="k">union</span> <span class="n">snd_seq_timestamp</span> <span class="n">time</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">queue</span><span class="p">;</span>	<span class="cm">/* Queue for REMOVE_DEST */</span>
	<span class="k">struct</span> <span class="n">snd_seq_addr</span> <span class="n">dest</span><span class="p">;</span>	<span class="cm">/* Address for REMOVE_DEST */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">;</span>	<span class="cm">/* Channel for REMOVE_DEST */</span>

	<span class="kt">int</span>  <span class="n">type</span><span class="p">;</span>	<span class="cm">/* For REMOVE_EVENT_TYPE */</span>
	<span class="kt">char</span>  <span class="n">tag</span><span class="p">;</span>	<span class="cm">/* Tag for REMOVE_TAG */</span>

	<span class="kt">int</span>  <span class="n">reserved</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>	<span class="cm">/* To allow for future binary compatibility */</span>

<span class="p">};</span>


	<span class="cm">/* known port numbers */</span>
<span class="cp">#define SNDRV_SEQ_PORT_SYSTEM_TIMER	0</span>
<span class="cp">#define SNDRV_SEQ_PORT_SYSTEM_ANNOUNCE	1</span>

	<span class="cm">/* port capabilities (32 bits) */</span>
<span class="cp">#define SNDRV_SEQ_PORT_CAP_READ		(1&lt;&lt;0)	</span><span class="cm">/* readable from this port */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PORT_CAP_WRITE	(1&lt;&lt;1)	</span><span class="cm">/* writable to this port */</span><span class="cp"></span>

<span class="cp">#define SNDRV_SEQ_PORT_CAP_SYNC_READ	(1&lt;&lt;2)</span>
<span class="cp">#define SNDRV_SEQ_PORT_CAP_SYNC_WRITE	(1&lt;&lt;3)</span>

<span class="cp">#define SNDRV_SEQ_PORT_CAP_DUPLEX	(1&lt;&lt;4)</span>

<span class="cp">#define SNDRV_SEQ_PORT_CAP_SUBS_READ	(1&lt;&lt;5)	</span><span class="cm">/* allow read subscription */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PORT_CAP_SUBS_WRITE	(1&lt;&lt;6)	</span><span class="cm">/* allow write subscription */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PORT_CAP_NO_EXPORT	(1&lt;&lt;7)	</span><span class="cm">/* routing not allowed */</span><span class="cp"></span>

	<span class="cm">/* port type */</span>
<span class="cp">#define SNDRV_SEQ_PORT_TYPE_SPECIFIC	(1&lt;&lt;0)	</span><span class="cm">/* hardware specific */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC (1&lt;&lt;1)	</span><span class="cm">/* generic MIDI device */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PORT_TYPE_MIDI_GM	(1&lt;&lt;2)	</span><span class="cm">/* General MIDI compatible device */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PORT_TYPE_MIDI_GS	(1&lt;&lt;3)	</span><span class="cm">/* GS compatible device */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PORT_TYPE_MIDI_XG	(1&lt;&lt;4)	</span><span class="cm">/* XG compatible device */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PORT_TYPE_MIDI_MT32	(1&lt;&lt;5)	</span><span class="cm">/* MT-32 compatible device */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PORT_TYPE_MIDI_GM2	(1&lt;&lt;6)	</span><span class="cm">/* General MIDI 2 compatible device */</span><span class="cp"></span>

<span class="cm">/* other standards...*/</span>
<span class="cp">#define SNDRV_SEQ_PORT_TYPE_SYNTH	(1&lt;&lt;10)	</span><span class="cm">/* Synth device (no MIDI compatible - direct wavetable) */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PORT_TYPE_DIRECT_SAMPLE (1&lt;&lt;11)	</span><span class="cm">/* Sampling device (support sample download) */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PORT_TYPE_SAMPLE	(1&lt;&lt;12)	</span><span class="cm">/* Sampling device (sample can be downloaded at any time) */</span><span class="cp"></span>
<span class="cm">/*...*/</span>
<span class="cp">#define SNDRV_SEQ_PORT_TYPE_HARDWARE	(1&lt;&lt;16)	</span><span class="cm">/* driver for a hardware device */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PORT_TYPE_SOFTWARE	(1&lt;&lt;17)	</span><span class="cm">/* implemented in software */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PORT_TYPE_SYNTHESIZER	(1&lt;&lt;18)	</span><span class="cm">/* generates sound */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PORT_TYPE_PORT	(1&lt;&lt;19)	</span><span class="cm">/* connects to other device(s) */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PORT_TYPE_APPLICATION	(1&lt;&lt;20)	</span><span class="cm">/* application (sequencer/editor) */</span><span class="cp"></span>

<span class="cm">/* misc. conditioning flags */</span>
<span class="cp">#define SNDRV_SEQ_PORT_FLG_GIVEN_PORT	(1&lt;&lt;0)</span>
<span class="cp">#define SNDRV_SEQ_PORT_FLG_TIMESTAMP	(1&lt;&lt;1)</span>
<span class="cp">#define SNDRV_SEQ_PORT_FLG_TIME_REAL	(1&lt;&lt;2)</span>

<span class="k">struct</span> <span class="n">snd_seq_port_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_seq_addr</span> <span class="n">addr</span><span class="p">;</span>	<span class="cm">/* client/port numbers */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>			<span class="cm">/* port name */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">capability</span><span class="p">;</span>	<span class="cm">/* port capability bits */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>		<span class="cm">/* port type bits */</span>
	<span class="kt">int</span> <span class="n">midi_channels</span><span class="p">;</span>		<span class="cm">/* channels per MIDI port */</span>
	<span class="kt">int</span> <span class="n">midi_voices</span><span class="p">;</span>		<span class="cm">/* voices per MIDI port */</span>
	<span class="kt">int</span> <span class="n">synth_voices</span><span class="p">;</span>		<span class="cm">/* voices per SYNTH port */</span>

	<span class="kt">int</span> <span class="n">read_use</span><span class="p">;</span>			<span class="cm">/* R/O: subscribers for output (from this port) */</span>
	<span class="kt">int</span> <span class="n">write_use</span><span class="p">;</span>			<span class="cm">/* R/O: subscribers for input (to this port) */</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">kernel</span><span class="p">;</span>			<span class="cm">/* reserved for kernel use (must be NULL) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* misc. conditioning */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">time_queue</span><span class="p">;</span>	<span class="cm">/* queue # for timestamping */</span>
	<span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">59</span><span class="p">];</span>		<span class="cm">/* for future use */</span>
<span class="p">};</span>


<span class="cm">/* queue flags */</span>
<span class="cp">#define SNDRV_SEQ_QUEUE_FLG_SYNC	(1&lt;&lt;0)	</span><span class="cm">/* sync enabled */</span><span class="cp"></span>

<span class="cm">/* queue information */</span>
<span class="k">struct</span> <span class="n">snd_seq_queue_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">queue</span><span class="p">;</span>		<span class="cm">/* queue id */</span>

	<span class="cm">/*</span>
<span class="cm">	 *  security settings, only owner of this queue can start/stop timer</span>
<span class="cm">	 *  etc. if the queue is locked for other clients</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">owner</span><span class="p">;</span>		<span class="cm">/* client id for owner of the queue */</span>
	<span class="kt">unsigned</span> <span class="n">locked</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* timing queue locked for other queues */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>		<span class="cm">/* name of this queue */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* flags */</span>
	<span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">60</span><span class="p">];</span>	<span class="cm">/* for future use */</span>

<span class="p">};</span>

<span class="cm">/* queue info/status */</span>
<span class="k">struct</span> <span class="n">snd_seq_queue_status</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">queue</span><span class="p">;</span>			<span class="cm">/* queue id */</span>
	<span class="kt">int</span> <span class="n">events</span><span class="p">;</span>			<span class="cm">/* read-only - queue size */</span>
	<span class="n">snd_seq_tick_time_t</span> <span class="n">tick</span><span class="p">;</span>	<span class="cm">/* current tick */</span>
	<span class="k">struct</span> <span class="n">snd_seq_real_time</span> <span class="n">time</span><span class="p">;</span>	<span class="cm">/* current time */</span>
	<span class="kt">int</span> <span class="n">running</span><span class="p">;</span>			<span class="cm">/* running state of queue */</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>			<span class="cm">/* various flags */</span>
	<span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>		<span class="cm">/* for the future */</span>
<span class="p">};</span>


<span class="cm">/* queue tempo */</span>
<span class="k">struct</span> <span class="n">snd_seq_queue_tempo</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">queue</span><span class="p">;</span>			<span class="cm">/* sequencer queue */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tempo</span><span class="p">;</span>		<span class="cm">/* current tempo, us/tick */</span>
	<span class="kt">int</span> <span class="n">ppq</span><span class="p">;</span>			<span class="cm">/* time resolution, ticks/quarter */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">skew_value</span><span class="p">;</span>	<span class="cm">/* queue skew */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">skew_base</span><span class="p">;</span>		<span class="cm">/* queue skew base */</span>
	<span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>		<span class="cm">/* for the future */</span>
<span class="p">};</span>


<span class="cm">/* sequencer timer sources */</span>
<span class="cp">#define SNDRV_SEQ_TIMER_ALSA		0	</span><span class="cm">/* ALSA timer */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_TIMER_MIDI_CLOCK	1	</span><span class="cm">/* Midi Clock (CLOCK event) */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_TIMER_MIDI_TICK	2	</span><span class="cm">/* Midi Timer Tick (TICK event) */</span><span class="cp"></span>

<span class="cm">/* queue timer info */</span>
<span class="k">struct</span> <span class="n">snd_seq_queue_timer</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">queue</span><span class="p">;</span>			<span class="cm">/* sequencer queue */</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>			<span class="cm">/* source timer type */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">snd_timer_id</span> <span class="n">id</span><span class="p">;</span>	<span class="cm">/* ALSA&#39;s timer ID */</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resolution</span><span class="p">;</span>	<span class="cm">/* resolution in Hz */</span>
		<span class="p">}</span> <span class="n">alsa</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>		<span class="cm">/* for the future use */</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">snd_seq_queue_client</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">queue</span><span class="p">;</span>		<span class="cm">/* sequencer queue */</span>
	<span class="kt">int</span> <span class="n">client</span><span class="p">;</span>		<span class="cm">/* sequencer client */</span>
	<span class="kt">int</span> <span class="n">used</span><span class="p">;</span>		<span class="cm">/* queue is used with this client</span>
<span class="cm">				   (must be set for accepting events) */</span>
	<span class="cm">/* per client watermarks */</span>
	<span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>	<span class="cm">/* for future use */</span>
<span class="p">};</span>


<span class="cp">#define SNDRV_SEQ_PORT_SUBS_EXCLUSIVE	(1&lt;&lt;0)	</span><span class="cm">/* exclusive connection */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SEQ_PORT_SUBS_TIMESTAMP	(1&lt;&lt;1)</span>
<span class="cp">#define SNDRV_SEQ_PORT_SUBS_TIME_REAL	(1&lt;&lt;2)</span>

<span class="k">struct</span> <span class="n">snd_seq_port_subscribe</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_seq_addr</span> <span class="n">sender</span><span class="p">;</span>	<span class="cm">/* sender address */</span>
	<span class="k">struct</span> <span class="n">snd_seq_addr</span> <span class="n">dest</span><span class="p">;</span>	<span class="cm">/* destination address */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">voices</span><span class="p">;</span>		<span class="cm">/* number of voices to be allocated (0 = don&#39;t care) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* modes */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">queue</span><span class="p">;</span>		<span class="cm">/* input time-stamp queue (optional) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pad</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* reserved */</span>
	<span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* type of query subscription */</span>
<span class="cp">#define SNDRV_SEQ_QUERY_SUBS_READ	0</span>
<span class="cp">#define SNDRV_SEQ_QUERY_SUBS_WRITE	1</span>

<span class="k">struct</span> <span class="n">snd_seq_query_subs</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_seq_addr</span> <span class="n">root</span><span class="p">;</span>	<span class="cm">/* client/port id to be searched */</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>		<span class="cm">/* READ or WRITE */</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>		<span class="cm">/* 0..N-1 */</span>
	<span class="kt">int</span> <span class="n">num_subs</span><span class="p">;</span>		<span class="cm">/* R/O: number of subscriptions on this port */</span>
	<span class="k">struct</span> <span class="n">snd_seq_addr</span> <span class="n">addr</span><span class="p">;</span>	<span class="cm">/* R/O: result */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">queue</span><span class="p">;</span>	<span class="cm">/* R/O: result */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* R/O: result */</span>
	<span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>	<span class="cm">/* for future use */</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> *  IOCTL commands</span>
<span class="cm"> */</span>

<span class="cp">#define SNDRV_SEQ_IOCTL_PVERSION	_IOR (&#39;S&#39;, 0x00, int)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_CLIENT_ID	_IOR (&#39;S&#39;, 0x01, int)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_SYSTEM_INFO	_IOWR(&#39;S&#39;, 0x02, struct snd_seq_system_info)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_RUNNING_MODE	_IOWR(&#39;S&#39;, 0x03, struct snd_seq_running_info)</span>

<span class="cp">#define SNDRV_SEQ_IOCTL_GET_CLIENT_INFO	_IOWR(&#39;S&#39;, 0x10, struct snd_seq_client_info)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_SET_CLIENT_INFO	_IOW (&#39;S&#39;, 0x11, struct snd_seq_client_info)</span>

<span class="cp">#define SNDRV_SEQ_IOCTL_CREATE_PORT	_IOWR(&#39;S&#39;, 0x20, struct snd_seq_port_info)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_DELETE_PORT	_IOW (&#39;S&#39;, 0x21, struct snd_seq_port_info)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_GET_PORT_INFO	_IOWR(&#39;S&#39;, 0x22, struct snd_seq_port_info)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_SET_PORT_INFO	_IOW (&#39;S&#39;, 0x23, struct snd_seq_port_info)</span>

<span class="cp">#define SNDRV_SEQ_IOCTL_SUBSCRIBE_PORT	_IOW (&#39;S&#39;, 0x30, struct snd_seq_port_subscribe)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_UNSUBSCRIBE_PORT _IOW (&#39;S&#39;, 0x31, struct snd_seq_port_subscribe)</span>

<span class="cp">#define SNDRV_SEQ_IOCTL_CREATE_QUEUE	_IOWR(&#39;S&#39;, 0x32, struct snd_seq_queue_info)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_DELETE_QUEUE	_IOW (&#39;S&#39;, 0x33, struct snd_seq_queue_info)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_GET_QUEUE_INFO	_IOWR(&#39;S&#39;, 0x34, struct snd_seq_queue_info)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_SET_QUEUE_INFO	_IOWR(&#39;S&#39;, 0x35, struct snd_seq_queue_info)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_GET_NAMED_QUEUE	_IOWR(&#39;S&#39;, 0x36, struct snd_seq_queue_info)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_GET_QUEUE_STATUS _IOWR(&#39;S&#39;, 0x40, struct snd_seq_queue_status)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_GET_QUEUE_TEMPO	_IOWR(&#39;S&#39;, 0x41, struct snd_seq_queue_tempo)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_SET_QUEUE_TEMPO	_IOW (&#39;S&#39;, 0x42, struct snd_seq_queue_tempo)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_GET_QUEUE_OWNER	_IOWR(&#39;S&#39;, 0x43, struct snd_seq_queue_owner)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_SET_QUEUE_OWNER	_IOW (&#39;S&#39;, 0x44, struct snd_seq_queue_owner)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_GET_QUEUE_TIMER	_IOWR(&#39;S&#39;, 0x45, struct snd_seq_queue_timer)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_SET_QUEUE_TIMER	_IOW (&#39;S&#39;, 0x46, struct snd_seq_queue_timer)</span>
<span class="cm">/* XXX</span>
<span class="cm">#define SNDRV_SEQ_IOCTL_GET_QUEUE_SYNC	_IOWR(&#39;S&#39;, 0x53, struct snd_seq_queue_sync)</span>
<span class="cm">#define SNDRV_SEQ_IOCTL_SET_QUEUE_SYNC	_IOW (&#39;S&#39;, 0x54, struct snd_seq_queue_sync)</span>
<span class="cm">*/</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_GET_QUEUE_CLIENT	_IOWR(&#39;S&#39;, 0x49, struct snd_seq_queue_client)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_SET_QUEUE_CLIENT	_IOW (&#39;S&#39;, 0x4a, struct snd_seq_queue_client)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_GET_CLIENT_POOL	_IOWR(&#39;S&#39;, 0x4b, struct snd_seq_client_pool)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_SET_CLIENT_POOL	_IOW (&#39;S&#39;, 0x4c, struct snd_seq_client_pool)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_REMOVE_EVENTS	_IOW (&#39;S&#39;, 0x4e, struct snd_seq_remove_events)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_QUERY_SUBS	_IOWR(&#39;S&#39;, 0x4f, struct snd_seq_query_subs)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_GET_SUBSCRIPTION	_IOWR(&#39;S&#39;, 0x50, struct snd_seq_port_subscribe)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_QUERY_NEXT_CLIENT	_IOWR(&#39;S&#39;, 0x51, struct snd_seq_client_info)</span>
<span class="cp">#define SNDRV_SEQ_IOCTL_QUERY_NEXT_PORT	_IOWR(&#39;S&#39;, 0x52, struct snd_seq_port_info)</span>

<span class="cp">#endif </span><span class="cm">/* __SOUND_ASEQUENCER_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
