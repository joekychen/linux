<!DOCTYPE html>
<html><head><title>joekychen/linux » include › mtd › mtd-abi.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>mtd-abi.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright © 1999-2010 David Woodhouse &lt;dwmw2@infradead.org&gt; et al.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __MTD_ABI_H__</span>
<span class="cp">#define __MTD_ABI_H__</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="k">struct</span> <span class="n">erase_info_user</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">erase_info_user64</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mtd_oob_buf</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mtd_oob_buf64</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">usr_ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * MTD operation modes</span>
<span class="cm"> *</span>
<span class="cm"> * @MTD_OPS_PLACE_OOB:	OOB data are placed at the given offset (default)</span>
<span class="cm"> * @MTD_OPS_AUTO_OOB:	OOB data are automatically placed at the free areas</span>
<span class="cm"> *			which are defined by the internal ecclayout</span>
<span class="cm"> * @MTD_OPS_RAW:	data are transferred as-is, with no error correction;</span>
<span class="cm"> *			this mode implies %MTD_OPS_PLACE_OOB</span>
<span class="cm"> *</span>
<span class="cm"> * These modes can be passed to ioctl(MEMWRITE) and are also used internally.</span>
<span class="cm"> * See notes on &quot;MTD file modes&quot; for discussion on %MTD_OPS_RAW vs.</span>
<span class="cm"> * %MTD_FILE_MODE_RAW.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">MTD_OPS_PLACE_OOB</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">MTD_OPS_AUTO_OOB</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">MTD_OPS_RAW</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct mtd_write_req - data structure for requesting a write operation</span>
<span class="cm"> *</span>
<span class="cm"> * @start:	start address</span>
<span class="cm"> * @len:	length of data buffer</span>
<span class="cm"> * @ooblen:	length of OOB buffer</span>
<span class="cm"> * @usr_data:	user-provided data buffer</span>
<span class="cm"> * @usr_oob:	user-provided OOB buffer</span>
<span class="cm"> * @mode:	MTD mode (see &quot;MTD operation modes&quot;)</span>
<span class="cm"> * @padding:	reserved, must be set to 0</span>
<span class="cm"> *</span>
<span class="cm"> * This structure supports ioctl(MEMWRITE) operations, allowing data and/or OOB</span>
<span class="cm"> * writes in various modes. To write to OOB-only, set @usr_data == NULL, and to</span>
<span class="cm"> * write data-only, set @usr_oob == NULL. However, setting both @usr_data and</span>
<span class="cm"> * @usr_oob to NULL is not allowed.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mtd_write_req</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ooblen</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">usr_data</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">usr_oob</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">padding</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define MTD_ABSENT		0</span>
<span class="cp">#define MTD_RAM			1</span>
<span class="cp">#define MTD_ROM			2</span>
<span class="cp">#define MTD_NORFLASH		3</span>
<span class="cp">#define MTD_NANDFLASH		4</span>
<span class="cp">#define MTD_DATAFLASH		6</span>
<span class="cp">#define MTD_UBIVOLUME		7</span>
<span class="cp">#define MTD_MLCNANDFLASH	8</span>

<span class="cp">#define MTD_WRITEABLE		0x400	</span><span class="cm">/* Device is writeable */</span><span class="cp"></span>
<span class="cp">#define MTD_BIT_WRITEABLE	0x800	</span><span class="cm">/* Single bits can be flipped */</span><span class="cp"></span>
<span class="cp">#define MTD_NO_ERASE		0x1000	</span><span class="cm">/* No erase necessary */</span><span class="cp"></span>
<span class="cp">#define MTD_POWERUP_LOCK	0x2000	</span><span class="cm">/* Always locked after reset */</span><span class="cp"></span>

<span class="cm">/* Some common devices / combinations of capabilities */</span>
<span class="cp">#define MTD_CAP_ROM		0</span>
<span class="cp">#define MTD_CAP_RAM		(MTD_WRITEABLE | MTD_BIT_WRITEABLE | MTD_NO_ERASE)</span>
<span class="cp">#define MTD_CAP_NORFLASH	(MTD_WRITEABLE | MTD_BIT_WRITEABLE)</span>
<span class="cp">#define MTD_CAP_NANDFLASH	(MTD_WRITEABLE)</span>

<span class="cm">/* Obsolete ECC byte placement modes (used with obsolete MEMGETOOBSEL) */</span>
<span class="cp">#define MTD_NANDECC_OFF		0	</span><span class="c1">// Switch off ECC (Not recommended)</span>
<span class="cp">#define MTD_NANDECC_PLACE	1	</span><span class="c1">// Use the given placement in the structure (YAFFS1 legacy mode)</span>
<span class="cp">#define MTD_NANDECC_AUTOPLACE	2	</span><span class="c1">// Use the default placement scheme</span>
<span class="cp">#define MTD_NANDECC_PLACEONLY	3	</span><span class="c1">// Use the given placement in the structure (Do not store ecc result on read)</span>
<span class="cp">#define MTD_NANDECC_AUTOPL_USR 	4	</span><span class="c1">// Use the given autoplacement scheme rather than using the default</span>

<span class="cm">/* OTP mode selection */</span>
<span class="cp">#define MTD_OTP_OFF		0</span>
<span class="cp">#define MTD_OTP_FACTORY		1</span>
<span class="cp">#define MTD_OTP_USER		2</span>

<span class="k">struct</span> <span class="n">mtd_info_user</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">size</span><span class="p">;</span>	<span class="cm">/* Total size of the MTD */</span>
	<span class="n">__u32</span> <span class="n">erasesize</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">writesize</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">oobsize</span><span class="p">;</span>	<span class="cm">/* Amount of OOB data per block (e.g. 16) */</span>
	<span class="n">__u64</span> <span class="n">padding</span><span class="p">;</span>	<span class="cm">/* Old obsolete field; do not use */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">region_info_user</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">offset</span><span class="p">;</span>		<span class="cm">/* At which this region starts,</span>
<span class="cm">				 * from the beginning of the MTD */</span>
	<span class="n">__u32</span> <span class="n">erasesize</span><span class="p">;</span>	<span class="cm">/* For this region */</span>
	<span class="n">__u32</span> <span class="n">numblocks</span><span class="p">;</span>	<span class="cm">/* Number of blocks in this region */</span>
	<span class="n">__u32</span> <span class="n">regionindex</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">otp_info</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">locked</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Note, the following ioctl existed in the past and was removed:</span>
<span class="cm"> * #define MEMSETOOBSEL           _IOW(&#39;M&#39;, 9, struct nand_oobinfo)</span>
<span class="cm"> * Try to avoid adding a new ioctl with the same ioctl number.</span>
<span class="cm"> */</span>

<span class="cm">/* Get basic MTD characteristics info (better to use sysfs) */</span>
<span class="cp">#define MEMGETINFO		_IOR(&#39;M&#39;, 1, struct mtd_info_user)</span>
<span class="cm">/* Erase segment of MTD */</span>
<span class="cp">#define MEMERASE		_IOW(&#39;M&#39;, 2, struct erase_info_user)</span>
<span class="cm">/* Write out-of-band data from MTD */</span>
<span class="cp">#define MEMWRITEOOB		_IOWR(&#39;M&#39;, 3, struct mtd_oob_buf)</span>
<span class="cm">/* Read out-of-band data from MTD */</span>
<span class="cp">#define MEMREADOOB		_IOWR(&#39;M&#39;, 4, struct mtd_oob_buf)</span>
<span class="cm">/* Lock a chip (for MTD that supports it) */</span>
<span class="cp">#define MEMLOCK			_IOW(&#39;M&#39;, 5, struct erase_info_user)</span>
<span class="cm">/* Unlock a chip (for MTD that supports it) */</span>
<span class="cp">#define MEMUNLOCK		_IOW(&#39;M&#39;, 6, struct erase_info_user)</span>
<span class="cm">/* Get the number of different erase regions */</span>
<span class="cp">#define MEMGETREGIONCOUNT	_IOR(&#39;M&#39;, 7, int)</span>
<span class="cm">/* Get information about the erase region for a specific index */</span>
<span class="cp">#define MEMGETREGIONINFO	_IOWR(&#39;M&#39;, 8, struct region_info_user)</span>
<span class="cm">/* Get info about OOB modes (e.g., RAW, PLACE, AUTO) - legacy interface */</span>
<span class="cp">#define MEMGETOOBSEL		_IOR(&#39;M&#39;, 10, struct nand_oobinfo)</span>
<span class="cm">/* Check if an eraseblock is bad */</span>
<span class="cp">#define MEMGETBADBLOCK		_IOW(&#39;M&#39;, 11, __kernel_loff_t)</span>
<span class="cm">/* Mark an eraseblock as bad */</span>
<span class="cp">#define MEMSETBADBLOCK		_IOW(&#39;M&#39;, 12, __kernel_loff_t)</span>
<span class="cm">/* Set OTP (One-Time Programmable) mode (factory vs. user) */</span>
<span class="cp">#define OTPSELECT		_IOR(&#39;M&#39;, 13, int)</span>
<span class="cm">/* Get number of OTP (One-Time Programmable) regions */</span>
<span class="cp">#define OTPGETREGIONCOUNT	_IOW(&#39;M&#39;, 14, int)</span>
<span class="cm">/* Get all OTP (One-Time Programmable) info about MTD */</span>
<span class="cp">#define OTPGETREGIONINFO	_IOW(&#39;M&#39;, 15, struct otp_info)</span>
<span class="cm">/* Lock a given range of user data (must be in mode %MTD_FILE_MODE_OTP_USER) */</span>
<span class="cp">#define OTPLOCK			_IOR(&#39;M&#39;, 16, struct otp_info)</span>
<span class="cm">/* Get ECC layout (deprecated) */</span>
<span class="cp">#define ECCGETLAYOUT		_IOR(&#39;M&#39;, 17, struct nand_ecclayout_user)</span>
<span class="cm">/* Get statistics about corrected/uncorrected errors */</span>
<span class="cp">#define ECCGETSTATS		_IOR(&#39;M&#39;, 18, struct mtd_ecc_stats)</span>
<span class="cm">/* Set MTD mode on a per-file-descriptor basis (see &quot;MTD file modes&quot;) */</span>
<span class="cp">#define MTDFILEMODE		_IO(&#39;M&#39;, 19)</span>
<span class="cm">/* Erase segment of MTD (supports 64-bit address) */</span>
<span class="cp">#define MEMERASE64		_IOW(&#39;M&#39;, 20, struct erase_info_user64)</span>
<span class="cm">/* Write data to OOB (64-bit version) */</span>
<span class="cp">#define MEMWRITEOOB64		_IOWR(&#39;M&#39;, 21, struct mtd_oob_buf64)</span>
<span class="cm">/* Read data from OOB (64-bit version) */</span>
<span class="cp">#define MEMREADOOB64		_IOWR(&#39;M&#39;, 22, struct mtd_oob_buf64)</span>
<span class="cm">/* Check if chip is locked (for MTD that supports it) */</span>
<span class="cp">#define MEMISLOCKED		_IOR(&#39;M&#39;, 23, struct erase_info_user)</span>
<span class="cm">/*</span>
<span class="cm"> * Most generic write interface; can write in-band and/or out-of-band in various</span>
<span class="cm"> * modes (see &quot;struct mtd_write_req&quot;). This ioctl is not supported for flashes</span>
<span class="cm"> * without OOB, e.g., NOR flash.</span>
<span class="cm"> */</span>
<span class="cp">#define MEMWRITE		_IOWR(&#39;M&#39;, 24, struct mtd_write_req)</span>

<span class="cm">/*</span>
<span class="cm"> * Obsolete legacy interface. Keep it in order not to break userspace</span>
<span class="cm"> * interfaces</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nand_oobinfo</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">useecc</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">eccbytes</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">oobfree</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__u32</span> <span class="n">eccpos</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nand_oobfree</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define MTD_MAX_OOBFREE_ENTRIES	8</span>
<span class="cp">#define MTD_MAX_ECCPOS_ENTRIES	64</span>
<span class="cm">/*</span>
<span class="cm"> * OBSOLETE: ECC layout control structure. Exported to user-space via ioctl</span>
<span class="cm"> * ECCGETLAYOUT for backwards compatbility and should not be mistaken as a</span>
<span class="cm"> * complete set of ECC information. The ioctl truncates the larger internal</span>
<span class="cm"> * structure to retain binary compatibility with the static declaration of the</span>
<span class="cm"> * ioctl. Note that the &quot;MTD_MAX_..._ENTRIES&quot; macros represent the max size of</span>
<span class="cm"> * the user struct, not the MAX size of the internal struct nand_ecclayout.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nand_ecclayout_user</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">eccbytes</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">eccpos</span><span class="p">[</span><span class="n">MTD_MAX_ECCPOS_ENTRIES</span><span class="p">];</span>
	<span class="n">__u32</span> <span class="n">oobavail</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_oobfree</span> <span class="n">oobfree</span><span class="p">[</span><span class="n">MTD_MAX_OOBFREE_ENTRIES</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct mtd_ecc_stats - error correction stats</span>
<span class="cm"> *</span>
<span class="cm"> * @corrected:	number of corrected bits</span>
<span class="cm"> * @failed:	number of uncorrectable errors</span>
<span class="cm"> * @badblocks:	number of bad blocks in this partition</span>
<span class="cm"> * @bbtblocks:	number of blocks reserved for bad block tables</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mtd_ecc_stats</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">corrected</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">failed</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">badblocks</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">bbtblocks</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * MTD file modes - for read/write access to MTD</span>
<span class="cm"> *</span>
<span class="cm"> * @MTD_FILE_MODE_NORMAL:	OTP disabled, ECC enabled</span>
<span class="cm"> * @MTD_FILE_MODE_OTP_FACTORY:	OTP enabled in factory mode</span>
<span class="cm"> * @MTD_FILE_MODE_OTP_USER:	OTP enabled in user mode</span>
<span class="cm"> * @MTD_FILE_MODE_RAW:		OTP disabled, ECC disabled</span>
<span class="cm"> *</span>
<span class="cm"> * These modes can be set via ioctl(MTDFILEMODE). The mode mode will be retained</span>
<span class="cm"> * separately for each open file descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: %MTD_FILE_MODE_RAW provides the same functionality as %MTD_OPS_RAW -</span>
<span class="cm"> * raw access to the flash, without error correction or autoplacement schemes.</span>
<span class="cm"> * Wherever possible, the MTD_OPS_* mode will override the MTD_FILE_MODE_* mode</span>
<span class="cm"> * (e.g., when using ioctl(MEMWRITE)), but in some cases, the MTD_FILE_MODE is</span>
<span class="cm"> * used out of necessity (e.g., `write()&#39;, ioctl(MEMWRITEOOB64)).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">mtd_file_modes</span> <span class="p">{</span>
	<span class="n">MTD_FILE_MODE_NORMAL</span> <span class="o">=</span> <span class="n">MTD_OTP_OFF</span><span class="p">,</span>
	<span class="n">MTD_FILE_MODE_OTP_FACTORY</span> <span class="o">=</span> <span class="n">MTD_OTP_FACTORY</span><span class="p">,</span>
	<span class="n">MTD_FILE_MODE_OTP_USER</span> <span class="o">=</span> <span class="n">MTD_OTP_USER</span><span class="p">,</span>
	<span class="n">MTD_FILE_MODE_RAW</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* __MTD_ABI_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
