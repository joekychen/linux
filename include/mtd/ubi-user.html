<!DOCTYPE html>
<html><head><title>joekychen/linux » include › mtd › ubi-user.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ubi-user.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright © International Business Machines Corp., 2006</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See</span>
<span class="cm"> * the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __UBI_USER_H__</span>
<span class="cp">#define __UBI_USER_H__</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * UBI device creation (the same as MTD device attachment)</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> * MTD devices may be attached using %UBI_IOCATT ioctl command of the UBI</span>
<span class="cm"> * control device. The caller has to properly fill and pass</span>
<span class="cm"> * &amp;struct ubi_attach_req object - UBI will attach the MTD device specified in</span>
<span class="cm"> * the request and return the newly created UBI device number as the ioctl</span>
<span class="cm"> * return value.</span>
<span class="cm"> *</span>
<span class="cm"> * UBI device deletion (the same as MTD device detachment)</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> * An UBI device maybe deleted with %UBI_IOCDET ioctl command of the UBI</span>
<span class="cm"> * control device.</span>
<span class="cm"> *</span>
<span class="cm"> * UBI volume creation</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> * UBI volumes are created via the %UBI_IOCMKVOL ioctl command of UBI character</span>
<span class="cm"> * device. A &amp;struct ubi_mkvol_req object has to be properly filled and a</span>
<span class="cm"> * pointer to it has to be passed to the ioctl.</span>
<span class="cm"> *</span>
<span class="cm"> * UBI volume deletion</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> * To delete a volume, the %UBI_IOCRMVOL ioctl command of the UBI character</span>
<span class="cm"> * device should be used. A pointer to the 32-bit volume ID hast to be passed</span>
<span class="cm"> * to the ioctl.</span>
<span class="cm"> *</span>
<span class="cm"> * UBI volume re-size</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> * To re-size a volume, the %UBI_IOCRSVOL ioctl command of the UBI character</span>
<span class="cm"> * device should be used. A &amp;struct ubi_rsvol_req object has to be properly</span>
<span class="cm"> * filled and a pointer to it has to be passed to the ioctl.</span>
<span class="cm"> *</span>
<span class="cm"> * UBI volumes re-name</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> * To re-name several volumes atomically at one go, the %UBI_IOCRNVOL command</span>
<span class="cm"> * of the UBI character device should be used. A &amp;struct ubi_rnvol_req object</span>
<span class="cm"> * has to be properly filled and a pointer to it has to be passed to the ioctl.</span>
<span class="cm"> *</span>
<span class="cm"> * UBI volume update</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> * Volume update should be done via the %UBI_IOCVOLUP ioctl command of the</span>
<span class="cm"> * corresponding UBI volume character device. A pointer to a 64-bit update</span>
<span class="cm"> * size should be passed to the ioctl. After this, UBI expects user to write</span>
<span class="cm"> * this number of bytes to the volume character device. The update is finished</span>
<span class="cm"> * when the claimed number of bytes is passed. So, the volume update sequence</span>
<span class="cm"> * is something like:</span>
<span class="cm"> *</span>
<span class="cm"> * fd = open(&quot;/dev/my_volume&quot;);</span>
<span class="cm"> * ioctl(fd, UBI_IOCVOLUP, &amp;image_size);</span>
<span class="cm"> * write(fd, buf, image_size);</span>
<span class="cm"> * close(fd);</span>
<span class="cm"> *</span>
<span class="cm"> * Logical eraseblock erase</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> * To erase a logical eraseblock, the %UBI_IOCEBER ioctl command of the</span>
<span class="cm"> * corresponding UBI volume character device should be used. This command</span>
<span class="cm"> * unmaps the requested logical eraseblock, makes sure the corresponding</span>
<span class="cm"> * physical eraseblock is successfully erased, and returns.</span>
<span class="cm"> *</span>
<span class="cm"> * Atomic logical eraseblock change</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> * Atomic logical eraseblock change operation is called using the %UBI_IOCEBCH</span>
<span class="cm"> * ioctl command of the corresponding UBI volume character device. A pointer to</span>
<span class="cm"> * a &amp;struct ubi_leb_change_req object has to be passed to the ioctl. Then the</span>
<span class="cm"> * user is expected to write the requested amount of bytes (similarly to what</span>
<span class="cm"> * should be done in case of the &quot;volume update&quot; ioctl).</span>
<span class="cm"> *</span>
<span class="cm"> * Logical eraseblock map</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> * To map a logical eraseblock to a physical eraseblock, the %UBI_IOCEBMAP</span>
<span class="cm"> * ioctl command should be used. A pointer to a &amp;struct ubi_map_req object is</span>
<span class="cm"> * expected to be passed. The ioctl maps the requested logical eraseblock to</span>
<span class="cm"> * a physical eraseblock and returns.  Only non-mapped logical eraseblocks can</span>
<span class="cm"> * be mapped. If the logical eraseblock specified in the request is already</span>
<span class="cm"> * mapped to a physical eraseblock, the ioctl fails and returns error.</span>
<span class="cm"> *</span>
<span class="cm"> * Logical eraseblock unmap</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> * To unmap a logical eraseblock to a physical eraseblock, the %UBI_IOCEBUNMAP</span>
<span class="cm"> * ioctl command should be used. The ioctl unmaps the logical eraseblocks,</span>
<span class="cm"> * schedules corresponding physical eraseblock for erasure, and returns. Unlike</span>
<span class="cm"> * the &quot;LEB erase&quot; command, it does not wait for the physical eraseblock being</span>
<span class="cm"> * erased. Note, the side effect of this is that if an unclean reboot happens</span>
<span class="cm"> * after the unmap ioctl returns, you may find the LEB mapped again to the same</span>
<span class="cm"> * physical eraseblock after the UBI is run again.</span>
<span class="cm"> *</span>
<span class="cm"> * Check if logical eraseblock is mapped</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> * To check if a logical eraseblock is mapped to a physical eraseblock, the</span>
<span class="cm"> * %UBI_IOCEBISMAP ioctl command should be used. It returns %0 if the LEB is</span>
<span class="cm"> * not mapped, and %1 if it is mapped.</span>
<span class="cm"> *</span>
<span class="cm"> * Set an UBI volume property</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> * To set an UBI volume property the %UBI_IOCSETPROP ioctl command should be</span>
<span class="cm"> * used. A pointer to a &amp;struct ubi_set_vol_prop_req object is expected to be</span>
<span class="cm"> * passed. The object describes which property should be set, and to which value</span>
<span class="cm"> * it should be set.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * When a new UBI volume or UBI device is created, users may either specify the</span>
<span class="cm"> * volume/device number they want to create or to let UBI automatically assign</span>
<span class="cm"> * the number using these constants.</span>
<span class="cm"> */</span>
<span class="cp">#define UBI_VOL_NUM_AUTO (-1)</span>
<span class="cp">#define UBI_DEV_NUM_AUTO (-1)</span>

<span class="cm">/* Maximum volume name length */</span>
<span class="cp">#define UBI_MAX_VOLUME_NAME 127</span>

<span class="cm">/* ioctl commands of UBI character devices */</span>

<span class="cp">#define UBI_IOC_MAGIC &#39;o&#39;</span>

<span class="cm">/* Create an UBI volume */</span>
<span class="cp">#define UBI_IOCMKVOL _IOW(UBI_IOC_MAGIC, 0, struct ubi_mkvol_req)</span>
<span class="cm">/* Remove an UBI volume */</span>
<span class="cp">#define UBI_IOCRMVOL _IOW(UBI_IOC_MAGIC, 1, __s32)</span>
<span class="cm">/* Re-size an UBI volume */</span>
<span class="cp">#define UBI_IOCRSVOL _IOW(UBI_IOC_MAGIC, 2, struct ubi_rsvol_req)</span>
<span class="cm">/* Re-name volumes */</span>
<span class="cp">#define UBI_IOCRNVOL _IOW(UBI_IOC_MAGIC, 3, struct ubi_rnvol_req)</span>

<span class="cm">/* ioctl commands of the UBI control character device */</span>

<span class="cp">#define UBI_CTRL_IOC_MAGIC &#39;o&#39;</span>

<span class="cm">/* Attach an MTD device */</span>
<span class="cp">#define UBI_IOCATT _IOW(UBI_CTRL_IOC_MAGIC, 64, struct ubi_attach_req)</span>
<span class="cm">/* Detach an MTD device */</span>
<span class="cp">#define UBI_IOCDET _IOW(UBI_CTRL_IOC_MAGIC, 65, __s32)</span>

<span class="cm">/* ioctl commands of UBI volume character devices */</span>

<span class="cp">#define UBI_VOL_IOC_MAGIC &#39;O&#39;</span>

<span class="cm">/* Start UBI volume update */</span>
<span class="cp">#define UBI_IOCVOLUP _IOW(UBI_VOL_IOC_MAGIC, 0, __s64)</span>
<span class="cm">/* LEB erasure command, used for debugging, disabled by default */</span>
<span class="cp">#define UBI_IOCEBER _IOW(UBI_VOL_IOC_MAGIC, 1, __s32)</span>
<span class="cm">/* Atomic LEB change command */</span>
<span class="cp">#define UBI_IOCEBCH _IOW(UBI_VOL_IOC_MAGIC, 2, __s32)</span>
<span class="cm">/* Map LEB command */</span>
<span class="cp">#define UBI_IOCEBMAP _IOW(UBI_VOL_IOC_MAGIC, 3, struct ubi_map_req)</span>
<span class="cm">/* Unmap LEB command */</span>
<span class="cp">#define UBI_IOCEBUNMAP _IOW(UBI_VOL_IOC_MAGIC, 4, __s32)</span>
<span class="cm">/* Check if LEB is mapped command */</span>
<span class="cp">#define UBI_IOCEBISMAP _IOR(UBI_VOL_IOC_MAGIC, 5, __s32)</span>
<span class="cm">/* Set an UBI volume property */</span>
<span class="cp">#define UBI_IOCSETVOLPROP _IOW(UBI_VOL_IOC_MAGIC, 6, \</span>
<span class="cp">			       struct ubi_set_vol_prop_req)</span>

<span class="cm">/* Maximum MTD device name length supported by UBI */</span>
<span class="cp">#define MAX_UBI_MTD_NAME_LEN 127</span>

<span class="cm">/* Maximum amount of UBI volumes that can be re-named at one go */</span>
<span class="cp">#define UBI_MAX_RNVOL 32</span>

<span class="cm">/*</span>
<span class="cm"> * UBI volume type constants.</span>
<span class="cm"> *</span>
<span class="cm"> * @UBI_DYNAMIC_VOLUME: dynamic volume</span>
<span class="cm"> * @UBI_STATIC_VOLUME:  static volume</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBI_DYNAMIC_VOLUME</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">UBI_STATIC_VOLUME</span>  <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * UBI set volume property ioctl constants.</span>
<span class="cm"> *</span>
<span class="cm"> * @UBI_VOL_PROP_DIRECT_WRITE: allow (any non-zero value) or disallow (value 0)</span>
<span class="cm"> *                             user to directly write and erase individual</span>
<span class="cm"> *                             eraseblocks on dynamic volumes</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBI_VOL_PROP_DIRECT_WRITE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_attach_req - attach MTD device request.</span>
<span class="cm"> * @ubi_num: UBI device number to create</span>
<span class="cm"> * @mtd_num: MTD device number to attach</span>
<span class="cm"> * @vid_hdr_offset: VID header offset (use defaults if %0)</span>
<span class="cm"> * @padding: reserved for future, not used, has to be zeroed</span>
<span class="cm"> *</span>
<span class="cm"> * This data structure is used to specify MTD device UBI has to attach and the</span>
<span class="cm"> * parameters it has to use. The number which should be assigned to the new UBI</span>
<span class="cm"> * device is passed in @ubi_num. UBI may automatically assign the number if</span>
<span class="cm"> * @UBI_DEV_NUM_AUTO is passed. In this case, the device number is returned in</span>
<span class="cm"> * @ubi_num.</span>
<span class="cm"> *</span>
<span class="cm"> * Most applications should pass %0 in @vid_hdr_offset to make UBI use default</span>
<span class="cm"> * offset of the VID header within physical eraseblocks. The default offset is</span>
<span class="cm"> * the next min. I/O unit after the EC header. For example, it will be offset</span>
<span class="cm"> * 512 in case of a 512 bytes page NAND flash with no sub-page support. Or</span>
<span class="cm"> * it will be 512 in case of a 2KiB page NAND flash with 4 512-byte sub-pages.</span>
<span class="cm"> *</span>
<span class="cm"> * But in rare cases, if this optimizes things, the VID header may be placed to</span>
<span class="cm"> * a different offset. For example, the boot-loader might do things faster if</span>
<span class="cm"> * the VID header sits at the end of the first 2KiB NAND page with 4 sub-pages.</span>
<span class="cm"> * As the boot-loader would not normally need to read EC headers (unless it</span>
<span class="cm"> * needs UBI in RW mode), it might be faster to calculate ECC. This is weird</span>
<span class="cm"> * example, but it real-life example. So, in this example, @vid_hdr_offer would</span>
<span class="cm"> * be 2KiB-64 bytes = 1984. Note, that this position is not even 512-bytes</span>
<span class="cm"> * aligned, which is OK, as UBI is clever enough to realize this is 4th</span>
<span class="cm"> * sub-page of the first page and add needed padding.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_attach_req</span> <span class="p">{</span>
	<span class="n">__s32</span> <span class="n">ubi_num</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">mtd_num</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">vid_hdr_offset</span><span class="p">;</span>
	<span class="n">__s8</span> <span class="n">padding</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_mkvol_req - volume description data structure used in</span>
<span class="cm"> *                        volume creation requests.</span>
<span class="cm"> * @vol_id: volume number</span>
<span class="cm"> * @alignment: volume alignment</span>
<span class="cm"> * @bytes: volume size in bytes</span>
<span class="cm"> * @vol_type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)</span>
<span class="cm"> * @padding1: reserved for future, not used, has to be zeroed</span>
<span class="cm"> * @name_len: volume name length</span>
<span class="cm"> * @padding2: reserved for future, not used, has to be zeroed</span>
<span class="cm"> * @name: volume name</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is used by user-space programs when creating new volumes. The</span>
<span class="cm"> * @used_bytes field is only necessary when creating static volumes.</span>
<span class="cm"> *</span>
<span class="cm"> * The @alignment field specifies the required alignment of the volume logical</span>
<span class="cm"> * eraseblock. This means, that the size of logical eraseblocks will be aligned</span>
<span class="cm"> * to this number, i.e.,</span>
<span class="cm"> *	(UBI device logical eraseblock size) mod (@alignment) = 0.</span>
<span class="cm"> *</span>
<span class="cm"> * To put it differently, the logical eraseblock of this volume may be slightly</span>
<span class="cm"> * shortened in order to make it properly aligned. The alignment has to be</span>
<span class="cm"> * multiple of the flash minimal input/output unit, or %1 to utilize the entire</span>
<span class="cm"> * available space of logical eraseblocks.</span>
<span class="cm"> *</span>
<span class="cm"> * The @alignment field may be useful, for example, when one wants to maintain</span>
<span class="cm"> * a block device on top of an UBI volume. In this case, it is desirable to fit</span>
<span class="cm"> * an integer number of blocks in logical eraseblocks of this UBI volume. With</span>
<span class="cm"> * alignment it is possible to update this volume using plane UBI volume image</span>
<span class="cm"> * BLOBs, without caring about how to properly align them.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_mkvol_req</span> <span class="p">{</span>
	<span class="n">__s32</span> <span class="n">vol_id</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">alignment</span><span class="p">;</span>
	<span class="n">__s64</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">__s8</span> <span class="n">vol_type</span><span class="p">;</span>
	<span class="n">__s8</span> <span class="n">padding1</span><span class="p">;</span>
	<span class="n">__s16</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="n">__s8</span> <span class="n">padding2</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">UBI_MAX_VOLUME_NAME</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_rsvol_req - a data structure used in volume re-size requests.</span>
<span class="cm"> * @vol_id: ID of the volume to re-size</span>
<span class="cm"> * @bytes: new size of the volume in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Re-sizing is possible for both dynamic and static volumes. But while dynamic</span>
<span class="cm"> * volumes may be re-sized arbitrarily, static volumes cannot be made to be</span>
<span class="cm"> * smaller than the number of bytes they bear. To arbitrarily shrink a static</span>
<span class="cm"> * volume, it must be wiped out first (by means of volume update operation with</span>
<span class="cm"> * zero number of bytes).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_rsvol_req</span> <span class="p">{</span>
	<span class="n">__s64</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">vol_id</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_rnvol_req - volumes re-name request.</span>
<span class="cm"> * @count: count of volumes to re-name</span>
<span class="cm"> * @padding1:  reserved for future, not used, has to be zeroed</span>
<span class="cm"> * @vol_id: ID of the volume to re-name</span>
<span class="cm"> * @name_len: name length</span>
<span class="cm"> * @padding2:  reserved for future, not used, has to be zeroed</span>
<span class="cm"> * @name: new volume name</span>
<span class="cm"> *</span>
<span class="cm"> * UBI allows to re-name up to %32 volumes at one go. The count of volumes to</span>
<span class="cm"> * re-name is specified in the @count field. The ID of the volumes to re-name</span>
<span class="cm"> * and the new names are specified in the @vol_id and @name fields.</span>
<span class="cm"> *</span>
<span class="cm"> * The UBI volume re-name operation is atomic, which means that should power cut</span>
<span class="cm"> * happen, the volumes will have either old name or new name. So the possible</span>
<span class="cm"> * use-cases of this command is atomic upgrade. Indeed, to upgrade, say, volumes</span>
<span class="cm"> * A and B one may create temporary volumes %A1 and %B1 with the new contents,</span>
<span class="cm"> * then atomically re-name A1-&gt;A and B1-&gt;B, in which case old %A and %B will</span>
<span class="cm"> * be removed.</span>
<span class="cm"> *</span>
<span class="cm"> * If it is not desirable to remove old A and B, the re-name request has to</span>
<span class="cm"> * contain 4 entries: A1-&gt;A, A-&gt;A1, B1-&gt;B, B-&gt;B1, in which case old A1 and B1</span>
<span class="cm"> * become A and B, and old A and B will become A1 and B1.</span>
<span class="cm"> *</span>
<span class="cm"> * It is also OK to request: A1-&gt;A, A1-&gt;X, B1-&gt;B, B-&gt;Y, in which case old A1</span>
<span class="cm"> * and B1 become A and B, and old A and B become X and Y.</span>
<span class="cm"> *</span>
<span class="cm"> * In other words, in case of re-naming into an existing volume name, the</span>
<span class="cm"> * existing volume is removed, unless it is re-named as well at the same</span>
<span class="cm"> * re-name request.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_rnvol_req</span> <span class="p">{</span>
	<span class="n">__s32</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">__s8</span> <span class="n">padding1</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">__s32</span> <span class="n">vol_id</span><span class="p">;</span>
		<span class="n">__s16</span> <span class="n">name_len</span><span class="p">;</span>
		<span class="n">__s8</span>  <span class="n">padding2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="kt">char</span>    <span class="n">name</span><span class="p">[</span><span class="n">UBI_MAX_VOLUME_NAME</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">ents</span><span class="p">[</span><span class="n">UBI_MAX_RNVOL</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_leb_change_req - a data structure used in atomic LEB change</span>
<span class="cm"> *                             requests.</span>
<span class="cm"> * @lnum: logical eraseblock number to change</span>
<span class="cm"> * @bytes: how many bytes will be written to the logical eraseblock</span>
<span class="cm"> * @dtype: pass &quot;3&quot; for better compatibility with old kernels</span>
<span class="cm"> * @padding: reserved for future, not used, has to be zeroed</span>
<span class="cm"> *</span>
<span class="cm"> * The @dtype field used to inform UBI about what kind of data will be written</span>
<span class="cm"> * to the LEB: long term (value 1), short term (value 2), unknown (value 3).</span>
<span class="cm"> * UBI tried to pick a PEB with lower erase counter for short term data and a</span>
<span class="cm"> * PEB with higher erase counter for long term data. But this was not really</span>
<span class="cm"> * used because users usually do not know this and could easily mislead UBI. We</span>
<span class="cm"> * removed this feature in May 2012. UBI currently just ignores the @dtype</span>
<span class="cm"> * field. But for better compatibility with older kernels it is recommended to</span>
<span class="cm"> * set @dtype to 3 (unknown).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_leb_change_req</span> <span class="p">{</span>
	<span class="n">__s32</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">__s8</span>  <span class="n">dtype</span><span class="p">;</span> <span class="cm">/* obsolete, do not use! */</span>
	<span class="n">__s8</span>  <span class="n">padding</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_map_req - a data structure used in map LEB requests.</span>
<span class="cm"> * @dtype: pass &quot;3&quot; for better compatibility with old kernels</span>
<span class="cm"> * @lnum: logical eraseblock number to unmap</span>
<span class="cm"> * @padding: reserved for future, not used, has to be zeroed</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_map_req</span> <span class="p">{</span>
	<span class="n">__s32</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">__s8</span>  <span class="n">dtype</span><span class="p">;</span> <span class="cm">/* obsolete, do not use! */</span>
	<span class="n">__s8</span>  <span class="n">padding</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * struct ubi_set_vol_prop_req - a data structure used to set an UBI volume</span>
<span class="cm"> *                               property.</span>
<span class="cm"> * @property: property to set (%UBI_VOL_PROP_DIRECT_WRITE)</span>
<span class="cm"> * @padding: reserved for future, not used, has to be zeroed</span>
<span class="cm"> * @value: value to set</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_set_vol_prop_req</span> <span class="p">{</span>
	<span class="n">__u8</span>  <span class="n">property</span><span class="p">;</span>
	<span class="n">__u8</span>  <span class="n">padding</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
	<span class="n">__u64</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>  <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* __UBI_USER_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
