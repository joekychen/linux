<!DOCTYPE html>
<html><head><title>joekychen/linux » include › drm › drm_mode.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>drm_mode.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2007 Dave Airlie &lt;airlied@linux.ie&gt;</span>
<span class="cm"> * Copyright (c) 2007 Jakob Bornecrantz &lt;wallbraker@gmail.com&gt;</span>
<span class="cm"> * Copyright (c) 2008 Red Hat Inc.</span>
<span class="cm"> * Copyright (c) 2007-2008 Tungsten Graphics, Inc., Cedar Park, TX., USA</span>
<span class="cm"> * Copyright (c) 2007-2008 Intel Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="cm"> * to deal in the Software without restriction, including without limitation</span>
<span class="cm"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="cm"> * and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="cm"> * Software is furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be included in</span>
<span class="cm"> * all copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="cm"> * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="cm"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="cm"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</span>
<span class="cm"> * IN THE SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _DRM_MODE_H</span>
<span class="cp">#define _DRM_MODE_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#define DRM_DISPLAY_INFO_LEN	32</span>
<span class="cp">#define DRM_CONNECTOR_NAME_LEN	32</span>
<span class="cp">#define DRM_DISPLAY_MODE_LEN	32</span>
<span class="cp">#define DRM_PROP_NAME_LEN	32</span>

<span class="cp">#define DRM_MODE_TYPE_BUILTIN	(1&lt;&lt;0)</span>
<span class="cp">#define DRM_MODE_TYPE_CLOCK_C	((1&lt;&lt;1) | DRM_MODE_TYPE_BUILTIN)</span>
<span class="cp">#define DRM_MODE_TYPE_CRTC_C	((1&lt;&lt;2) | DRM_MODE_TYPE_BUILTIN)</span>
<span class="cp">#define DRM_MODE_TYPE_PREFERRED	(1&lt;&lt;3)</span>
<span class="cp">#define DRM_MODE_TYPE_DEFAULT	(1&lt;&lt;4)</span>
<span class="cp">#define DRM_MODE_TYPE_USERDEF	(1&lt;&lt;5)</span>
<span class="cp">#define DRM_MODE_TYPE_DRIVER	(1&lt;&lt;6)</span>

<span class="cm">/* Video mode flags */</span>
<span class="cm">/* bit compatible with the xorg definitions. */</span>
<span class="cp">#define DRM_MODE_FLAG_PHSYNC	(1&lt;&lt;0)</span>
<span class="cp">#define DRM_MODE_FLAG_NHSYNC	(1&lt;&lt;1)</span>
<span class="cp">#define DRM_MODE_FLAG_PVSYNC	(1&lt;&lt;2)</span>
<span class="cp">#define DRM_MODE_FLAG_NVSYNC	(1&lt;&lt;3)</span>
<span class="cp">#define DRM_MODE_FLAG_INTERLACE	(1&lt;&lt;4)</span>
<span class="cp">#define DRM_MODE_FLAG_DBLSCAN	(1&lt;&lt;5)</span>
<span class="cp">#define DRM_MODE_FLAG_CSYNC	(1&lt;&lt;6)</span>
<span class="cp">#define DRM_MODE_FLAG_PCSYNC	(1&lt;&lt;7)</span>
<span class="cp">#define DRM_MODE_FLAG_NCSYNC	(1&lt;&lt;8)</span>
<span class="cp">#define DRM_MODE_FLAG_HSKEW	(1&lt;&lt;9) </span><span class="cm">/* hskew provided */</span><span class="cp"></span>
<span class="cp">#define DRM_MODE_FLAG_BCAST	(1&lt;&lt;10)</span>
<span class="cp">#define DRM_MODE_FLAG_PIXMUX	(1&lt;&lt;11)</span>
<span class="cp">#define DRM_MODE_FLAG_DBLCLK	(1&lt;&lt;12)</span>
<span class="cp">#define DRM_MODE_FLAG_CLKDIV2	(1&lt;&lt;13)</span>

<span class="cm">/* DPMS flags */</span>
<span class="cm">/* bit compatible with the xorg definitions. */</span>
<span class="cp">#define DRM_MODE_DPMS_ON	0</span>
<span class="cp">#define DRM_MODE_DPMS_STANDBY	1</span>
<span class="cp">#define DRM_MODE_DPMS_SUSPEND	2</span>
<span class="cp">#define DRM_MODE_DPMS_OFF	3</span>

<span class="cm">/* Scaling mode options */</span>
<span class="cp">#define DRM_MODE_SCALE_NONE		0 </span><span class="cm">/* Unmodified timing (display or</span>
<span class="cm">					     software can still scale) */</span><span class="cp"></span>
<span class="cp">#define DRM_MODE_SCALE_FULLSCREEN	1 </span><span class="cm">/* Full screen, ignore aspect */</span><span class="cp"></span>
<span class="cp">#define DRM_MODE_SCALE_CENTER		2 </span><span class="cm">/* Centered, no scaling */</span><span class="cp"></span>
<span class="cp">#define DRM_MODE_SCALE_ASPECT		3 </span><span class="cm">/* Full screen, preserve aspect */</span><span class="cp"></span>

<span class="cm">/* Dithering mode options */</span>
<span class="cp">#define DRM_MODE_DITHERING_OFF	0</span>
<span class="cp">#define DRM_MODE_DITHERING_ON	1</span>
<span class="cp">#define DRM_MODE_DITHERING_AUTO 2</span>

<span class="cm">/* Dirty info options */</span>
<span class="cp">#define DRM_MODE_DIRTY_OFF      0</span>
<span class="cp">#define DRM_MODE_DIRTY_ON       1</span>
<span class="cp">#define DRM_MODE_DIRTY_ANNOTATE 2</span>

<span class="k">struct</span> <span class="n">drm_mode_modeinfo</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">clock</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">hdisplay</span><span class="p">,</span> <span class="n">hsync_start</span><span class="p">,</span> <span class="n">hsync_end</span><span class="p">,</span> <span class="n">htotal</span><span class="p">,</span> <span class="n">hskew</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">vdisplay</span><span class="p">,</span> <span class="n">vsync_start</span><span class="p">,</span> <span class="n">vsync_end</span><span class="p">,</span> <span class="n">vtotal</span><span class="p">,</span> <span class="n">vscan</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">vrefresh</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">DRM_DISPLAY_MODE_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_mode_card_res</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">fb_id_ptr</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">crtc_id_ptr</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">connector_id_ptr</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">encoder_id_ptr</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">count_fbs</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">count_crtcs</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">count_connectors</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">count_encoders</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">min_width</span><span class="p">,</span> <span class="n">max_width</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">min_height</span><span class="p">,</span> <span class="n">max_height</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_mode_crtc</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">set_connectors_ptr</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">count_connectors</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">crtc_id</span><span class="p">;</span> <span class="cm">/**&lt; Id */</span>
	<span class="n">__u32</span> <span class="n">fb_id</span><span class="p">;</span> <span class="cm">/**&lt; Id of framebuffer */</span>

	<span class="n">__u32</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="cm">/**&lt; Position on the frameuffer */</span>

	<span class="n">__u32</span> <span class="n">gamma_size</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">mode_valid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_mode_modeinfo</span> <span class="n">mode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DRM_MODE_PRESENT_TOP_FIELD	(1&lt;&lt;0)</span>
<span class="cp">#define DRM_MODE_PRESENT_BOTTOM_FIELD	(1&lt;&lt;1)</span>

<span class="cm">/* Planes blend with or override other bits on the CRTC */</span>
<span class="k">struct</span> <span class="n">drm_mode_set_plane</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">plane_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">crtc_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">fb_id</span><span class="p">;</span> <span class="cm">/* fb object contains surface format type */</span>
	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* see above flags */</span>

	<span class="cm">/* Signed dest location allows it to be partially off screen */</span>
	<span class="n">__s32</span> <span class="n">crtc_x</span><span class="p">,</span> <span class="n">crtc_y</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">crtc_w</span><span class="p">,</span> <span class="n">crtc_h</span><span class="p">;</span>

	<span class="cm">/* Source values are 16.16 fixed point */</span>
	<span class="n">__u32</span> <span class="n">src_x</span><span class="p">,</span> <span class="n">src_y</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">src_h</span><span class="p">,</span> <span class="n">src_w</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_mode_get_plane</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">plane_id</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">crtc_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">fb_id</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">possible_crtcs</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">gamma_size</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">count_format_types</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">format_type_ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_mode_get_plane_res</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">plane_id_ptr</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">count_planes</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DRM_MODE_ENCODER_NONE	0</span>
<span class="cp">#define DRM_MODE_ENCODER_DAC	1</span>
<span class="cp">#define DRM_MODE_ENCODER_TMDS	2</span>
<span class="cp">#define DRM_MODE_ENCODER_LVDS	3</span>
<span class="cp">#define DRM_MODE_ENCODER_TVDAC	4</span>
<span class="cp">#define DRM_MODE_ENCODER_VIRTUAL 5</span>

<span class="k">struct</span> <span class="n">drm_mode_get_encoder</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">encoder_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">encoder_type</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">crtc_id</span><span class="p">;</span> <span class="cm">/**&lt; Id of crtc */</span>

	<span class="n">__u32</span> <span class="n">possible_crtcs</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">possible_clones</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* This is for connectors with multiple signal types. */</span>
<span class="cm">/* Try to match DRM_MODE_CONNECTOR_X as closely as possible. */</span>
<span class="cp">#define DRM_MODE_SUBCONNECTOR_Automatic	0</span>
<span class="cp">#define DRM_MODE_SUBCONNECTOR_Unknown	0</span>
<span class="cp">#define DRM_MODE_SUBCONNECTOR_DVID	3</span>
<span class="cp">#define DRM_MODE_SUBCONNECTOR_DVIA	4</span>
<span class="cp">#define DRM_MODE_SUBCONNECTOR_Composite	5</span>
<span class="cp">#define DRM_MODE_SUBCONNECTOR_SVIDEO	6</span>
<span class="cp">#define DRM_MODE_SUBCONNECTOR_Component	8</span>
<span class="cp">#define DRM_MODE_SUBCONNECTOR_SCART	9</span>

<span class="cp">#define DRM_MODE_CONNECTOR_Unknown	0</span>
<span class="cp">#define DRM_MODE_CONNECTOR_VGA		1</span>
<span class="cp">#define DRM_MODE_CONNECTOR_DVII		2</span>
<span class="cp">#define DRM_MODE_CONNECTOR_DVID		3</span>
<span class="cp">#define DRM_MODE_CONNECTOR_DVIA		4</span>
<span class="cp">#define DRM_MODE_CONNECTOR_Composite	5</span>
<span class="cp">#define DRM_MODE_CONNECTOR_SVIDEO	6</span>
<span class="cp">#define DRM_MODE_CONNECTOR_LVDS		7</span>
<span class="cp">#define DRM_MODE_CONNECTOR_Component	8</span>
<span class="cp">#define DRM_MODE_CONNECTOR_9PinDIN	9</span>
<span class="cp">#define DRM_MODE_CONNECTOR_DisplayPort	10</span>
<span class="cp">#define DRM_MODE_CONNECTOR_HDMIA	11</span>
<span class="cp">#define DRM_MODE_CONNECTOR_HDMIB	12</span>
<span class="cp">#define DRM_MODE_CONNECTOR_TV		13</span>
<span class="cp">#define DRM_MODE_CONNECTOR_eDP		14</span>
<span class="cp">#define DRM_MODE_CONNECTOR_VIRTUAL      15</span>

<span class="k">struct</span> <span class="n">drm_mode_get_connector</span> <span class="p">{</span>

	<span class="n">__u64</span> <span class="n">encoders_ptr</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">modes_ptr</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">props_ptr</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">prop_values_ptr</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">count_modes</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">count_props</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">count_encoders</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">encoder_id</span><span class="p">;</span> <span class="cm">/**&lt; Current Encoder */</span>
	<span class="n">__u32</span> <span class="n">connector_id</span><span class="p">;</span> <span class="cm">/**&lt; Id */</span>
	<span class="n">__u32</span> <span class="n">connector_type</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">connector_type_id</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">connection</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">mm_width</span><span class="p">,</span> <span class="n">mm_height</span><span class="p">;</span> <span class="cm">/**&lt; HxW in millimeters */</span>
	<span class="n">__u32</span> <span class="n">subpixel</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DRM_MODE_PROP_PENDING	(1&lt;&lt;0)</span>
<span class="cp">#define DRM_MODE_PROP_RANGE	(1&lt;&lt;1)</span>
<span class="cp">#define DRM_MODE_PROP_IMMUTABLE	(1&lt;&lt;2)</span>
<span class="cp">#define DRM_MODE_PROP_ENUM	(1&lt;&lt;3) </span><span class="cm">/* enumerated type with text strings */</span><span class="cp"></span>
<span class="cp">#define DRM_MODE_PROP_BLOB	(1&lt;&lt;4)</span>
<span class="cp">#define DRM_MODE_PROP_BITMASK	(1&lt;&lt;5) </span><span class="cm">/* bitmask of enumerated types */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">drm_mode_property_enum</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">DRM_PROP_NAME_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_mode_get_property</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">values_ptr</span><span class="p">;</span> <span class="cm">/* values and blob lengths */</span>
	<span class="n">__u64</span> <span class="n">enum_blob_ptr</span><span class="p">;</span> <span class="cm">/* enum and blob id ptrs */</span>

	<span class="n">__u32</span> <span class="n">prop_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">DRM_PROP_NAME_LEN</span><span class="p">];</span>

	<span class="n">__u32</span> <span class="n">count_values</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">count_enum_blobs</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_mode_connector_set_property</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">prop_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">connector_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_mode_obj_get_properties</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">props_ptr</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">prop_values_ptr</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">count_props</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">obj_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">obj_type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_mode_obj_set_property</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">prop_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">obj_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">obj_type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_mode_get_blob</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">blob_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_mode_fb_cmd</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">fb_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pitch</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">bpp</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">depth</span><span class="p">;</span>
	<span class="cm">/* driver specific handle */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DRM_MODE_FB_INTERLACED	(1&lt;&lt;0) </span><span class="cm">/* for interlaced framebuffers */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">drm_mode_fb_cmd2</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">fb_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pixel_format</span><span class="p">;</span> <span class="cm">/* fourcc code from drm_fourcc.h */</span>
	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* see above flags */</span>

	<span class="cm">/*</span>
<span class="cm">	 * In case of planar formats, this ioctl allows up to 4</span>
<span class="cm">	 * buffer objects with offets and pitches per plane.</span>
<span class="cm">	 * The pitch and offset order is dictated by the fourcc,</span>
<span class="cm">	 * e.g. NV12 (http://fourcc.org/yuv.php#NV12) is described as:</span>
<span class="cm">	 *</span>
<span class="cm">	 *   YUV 4:2:0 image with a plane of 8 bit Y samples</span>
<span class="cm">	 *   followed by an interleaved U/V plane containing</span>
<span class="cm">	 *   8 bit 2x2 subsampled colour difference samples.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So it would consist of Y as offset[0] and UV as</span>
<span class="cm">	 * offeset[1].  Note that offset[0] will generally</span>
<span class="cm">	 * be 0.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">handles</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">__u32</span> <span class="n">pitches</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="cm">/* pitch for each plane */</span>
	<span class="n">__u32</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="cm">/* offset of each plane */</span>
<span class="p">};</span>

<span class="cp">#define DRM_MODE_FB_DIRTY_ANNOTATE_COPY 0x01</span>
<span class="cp">#define DRM_MODE_FB_DIRTY_ANNOTATE_FILL 0x02</span>
<span class="cp">#define DRM_MODE_FB_DIRTY_FLAGS         0x03</span>

<span class="cp">#define DRM_MODE_FB_DIRTY_MAX_CLIPS     256</span>

<span class="cm">/*</span>
<span class="cm"> * Mark a region of a framebuffer as dirty.</span>
<span class="cm"> *</span>
<span class="cm"> * Some hardware does not automatically update display contents</span>
<span class="cm"> * as a hardware or software draw to a framebuffer. This ioctl</span>
<span class="cm"> * allows userspace to tell the kernel and the hardware what</span>
<span class="cm"> * regions of the framebuffer have changed.</span>
<span class="cm"> *</span>
<span class="cm"> * The kernel or hardware is free to update more then just the</span>
<span class="cm"> * region specified by the clip rects. The kernel or hardware</span>
<span class="cm"> * may also delay and/or coalesce several calls to dirty into a</span>
<span class="cm"> * single update.</span>
<span class="cm"> *</span>
<span class="cm"> * Userspace may annotate the updates, the annotates are a</span>
<span class="cm"> * promise made by the caller that the change is either a copy</span>
<span class="cm"> * of pixels or a fill of a single color in the region specified.</span>
<span class="cm"> *</span>
<span class="cm"> * If the DRM_MODE_FB_DIRTY_ANNOTATE_COPY flag is given then</span>
<span class="cm"> * the number of updated regions are half of num_clips given,</span>
<span class="cm"> * where the clip rects are paired in src and dst. The width and</span>
<span class="cm"> * height of each one of the pairs must match.</span>
<span class="cm"> *</span>
<span class="cm"> * If the DRM_MODE_FB_DIRTY_ANNOTATE_FILL flag is given the caller</span>
<span class="cm"> * promises that the region specified of the clip rects is filled</span>
<span class="cm"> * completely with a single color as given in the color argument.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_mode_fb_dirty_cmd</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">fb_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">color</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">num_clips</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">clips_ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_mode_mode_cmd</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">connector_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_mode_modeinfo</span> <span class="n">mode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DRM_MODE_CURSOR_BO	(1&lt;&lt;0)</span>
<span class="cp">#define DRM_MODE_CURSOR_MOVE	(1&lt;&lt;1)</span>

<span class="cm">/*</span>
<span class="cm"> * depending on the value in flags different members are used.</span>
<span class="cm"> *</span>
<span class="cm"> * CURSOR_BO uses</span>
<span class="cm"> *    crtc</span>
<span class="cm"> *    width</span>
<span class="cm"> *    height</span>
<span class="cm"> *    handle - if 0 turns the cursor of</span>
<span class="cm"> *</span>
<span class="cm"> * CURSOR_MOVE uses</span>
<span class="cm"> *    crtc</span>
<span class="cm"> *    x</span>
<span class="cm"> *    y</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_mode_cursor</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">crtc_id</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">x</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">y</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">width</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">height</span><span class="p">;</span>
	<span class="cm">/* driver specific handle */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_mode_crtc_lut</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">crtc_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">gamma_size</span><span class="p">;</span>

	<span class="cm">/* pointers to arrays */</span>
	<span class="n">__u64</span> <span class="n">red</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">green</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">blue</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DRM_MODE_PAGE_FLIP_EVENT 0x01</span>
<span class="cp">#define DRM_MODE_PAGE_FLIP_FLAGS DRM_MODE_PAGE_FLIP_EVENT</span>

<span class="cm">/*</span>
<span class="cm"> * Request a page flip on the specified crtc.</span>
<span class="cm"> *</span>
<span class="cm"> * This ioctl will ask KMS to schedule a page flip for the specified</span>
<span class="cm"> * crtc.  Once any pending rendering targeting the specified fb (as of</span>
<span class="cm"> * ioctl time) has completed, the crtc will be reprogrammed to display</span>
<span class="cm"> * that fb after the next vertical refresh.  The ioctl returns</span>
<span class="cm"> * immediately, but subsequent rendering to the current fb will block</span>
<span class="cm"> * in the execbuffer ioctl until the page flip happens.  If a page</span>
<span class="cm"> * flip is already pending as the ioctl is called, EBUSY will be</span>
<span class="cm"> * returned.</span>
<span class="cm"> *</span>
<span class="cm"> * The ioctl supports one flag, DRM_MODE_PAGE_FLIP_EVENT, which will</span>
<span class="cm"> * request that drm sends back a vblank event (see drm.h: struct</span>
<span class="cm"> * drm_event_vblank) when the page flip is done.  The user_data field</span>
<span class="cm"> * passed in with this ioctl will be returned as the user_data field</span>
<span class="cm"> * in the vblank event struct.</span>
<span class="cm"> *</span>
<span class="cm"> * The reserved field must be zero until we figure out something</span>
<span class="cm"> * clever to use it for.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_mode_crtc_page_flip</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">crtc_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">fb_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">user_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* create a dumb scanout buffer */</span>
<span class="k">struct</span> <span class="n">drm_mode_create_dumb</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">height</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">width</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">bpp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
	<span class="cm">/* handle, pitch, size will be returned */</span>
	<span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pitch</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* set up for mmap of a dumb scanout buffer */</span>
<span class="k">struct</span> <span class="n">drm_mode_map_dumb</span> <span class="p">{</span>
	<span class="cm">/** Handle for the object being mapped. */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
	<span class="cm">/**</span>
<span class="cm">	 * Fake offset to use for subsequent mmap call</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is a fixed-size type for 32/64 compatibility.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_mode_destroy_dumb</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
