<!DOCTYPE html>
<html><head><title>joekychen/linux » include › drm › drm_crtc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>drm_crtc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright © 2006 Keith Packard</span>
<span class="cm"> * Copyright © 2007-2008 Dave Airlie</span>
<span class="cm"> * Copyright © 2007-2008 Intel Corporation</span>
<span class="cm"> *   Jesse Barnes &lt;jesse.barnes@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="cm"> * to deal in the Software without restriction, including without limitation</span>
<span class="cm"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="cm"> * and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="cm"> * Software is furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be included in</span>
<span class="cm"> * all copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span>
<span class="cm"> * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR</span>
<span class="cm"> * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,</span>
<span class="cm"> * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</span>
<span class="cm"> * OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __DRM_CRTC_H__</span>
<span class="cp">#define __DRM_CRTC_H__</span>

<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/fb.h&gt;</span>

<span class="cp">#include &lt;drm/drm_fourcc.h&gt;</span>

<span class="k">struct</span> <span class="n">drm_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">drm_mode_set</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">drm_framebuffer</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">drm_object_properties</span><span class="p">;</span>


<span class="cp">#define DRM_MODE_OBJECT_CRTC 0xcccccccc</span>
<span class="cp">#define DRM_MODE_OBJECT_CONNECTOR 0xc0c0c0c0</span>
<span class="cp">#define DRM_MODE_OBJECT_ENCODER 0xe0e0e0e0</span>
<span class="cp">#define DRM_MODE_OBJECT_MODE 0xdededede</span>
<span class="cp">#define DRM_MODE_OBJECT_PROPERTY 0xb0b0b0b0</span>
<span class="cp">#define DRM_MODE_OBJECT_FB 0xfbfbfbfb</span>
<span class="cp">#define DRM_MODE_OBJECT_BLOB 0xbbbbbbbb</span>
<span class="cp">#define DRM_MODE_OBJECT_PLANE 0xeeeeeeee</span>

<span class="k">struct</span> <span class="n">drm_mode_object</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_object_properties</span> <span class="o">*</span><span class="n">properties</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DRM_OBJECT_MAX_PROPERTY 24</span>
<span class="k">struct</span> <span class="n">drm_object_properties</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ids</span><span class="p">[</span><span class="n">DRM_OBJECT_MAX_PROPERTY</span><span class="p">];</span>
	<span class="kt">uint64_t</span> <span class="n">values</span><span class="p">[</span><span class="n">DRM_OBJECT_MAX_PROPERTY</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Note on terminology:  here, for brevity and convenience, we refer to connector</span>
<span class="cm"> * control chips as &#39;CRTCs&#39;.  They can control any type of connector, VGA, LVDS,</span>
<span class="cm"> * DVI, etc.  And &#39;screen&#39; refers to the whole of the visible display, which</span>
<span class="cm"> * may span multiple monitors (and therefore multiple CRTC and connector</span>
<span class="cm"> * structures).</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">drm_mode_status</span> <span class="p">{</span>
    <span class="n">MODE_OK</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* Mode OK */</span>
    <span class="n">MODE_HSYNC</span><span class="p">,</span>		<span class="cm">/* hsync out of range */</span>
    <span class="n">MODE_VSYNC</span><span class="p">,</span>		<span class="cm">/* vsync out of range */</span>
    <span class="n">MODE_H_ILLEGAL</span><span class="p">,</span>	<span class="cm">/* mode has illegal horizontal timings */</span>
    <span class="n">MODE_V_ILLEGAL</span><span class="p">,</span>	<span class="cm">/* mode has illegal horizontal timings */</span>
    <span class="n">MODE_BAD_WIDTH</span><span class="p">,</span>	<span class="cm">/* requires an unsupported linepitch */</span>
    <span class="n">MODE_NOMODE</span><span class="p">,</span>	<span class="cm">/* no mode with a matching name */</span>
    <span class="n">MODE_NO_INTERLACE</span><span class="p">,</span>	<span class="cm">/* interlaced mode not supported */</span>
    <span class="n">MODE_NO_DBLESCAN</span><span class="p">,</span>	<span class="cm">/* doublescan mode not supported */</span>
    <span class="n">MODE_NO_VSCAN</span><span class="p">,</span>	<span class="cm">/* multiscan mode not supported */</span>
    <span class="n">MODE_MEM</span><span class="p">,</span>		<span class="cm">/* insufficient video memory */</span>
    <span class="n">MODE_VIRTUAL_X</span><span class="p">,</span>	<span class="cm">/* mode width too large for specified virtual size */</span>
    <span class="n">MODE_VIRTUAL_Y</span><span class="p">,</span>	<span class="cm">/* mode height too large for specified virtual size */</span>
    <span class="n">MODE_MEM_VIRT</span><span class="p">,</span>	<span class="cm">/* insufficient video memory given virtual size */</span>
    <span class="n">MODE_NOCLOCK</span><span class="p">,</span>	<span class="cm">/* no fixed clock available */</span>
    <span class="n">MODE_CLOCK_HIGH</span><span class="p">,</span>	<span class="cm">/* clock required is too high */</span>
    <span class="n">MODE_CLOCK_LOW</span><span class="p">,</span>	<span class="cm">/* clock required is too low */</span>
    <span class="n">MODE_CLOCK_RANGE</span><span class="p">,</span>	<span class="cm">/* clock/mode isn&#39;t in a ClockRange */</span>
    <span class="n">MODE_BAD_HVALUE</span><span class="p">,</span>	<span class="cm">/* horizontal timing was out of range */</span>
    <span class="n">MODE_BAD_VVALUE</span><span class="p">,</span>	<span class="cm">/* vertical timing was out of range */</span>
    <span class="n">MODE_BAD_VSCAN</span><span class="p">,</span>	<span class="cm">/* VScan value out of range */</span>
    <span class="n">MODE_HSYNC_NARROW</span><span class="p">,</span>	<span class="cm">/* horizontal sync too narrow */</span>
    <span class="n">MODE_HSYNC_WIDE</span><span class="p">,</span>	<span class="cm">/* horizontal sync too wide */</span>
    <span class="n">MODE_HBLANK_NARROW</span><span class="p">,</span>	<span class="cm">/* horizontal blanking too narrow */</span>
    <span class="n">MODE_HBLANK_WIDE</span><span class="p">,</span>	<span class="cm">/* horizontal blanking too wide */</span>
    <span class="n">MODE_VSYNC_NARROW</span><span class="p">,</span>	<span class="cm">/* vertical sync too narrow */</span>
    <span class="n">MODE_VSYNC_WIDE</span><span class="p">,</span>	<span class="cm">/* vertical sync too wide */</span>
    <span class="n">MODE_VBLANK_NARROW</span><span class="p">,</span>	<span class="cm">/* vertical blanking too narrow */</span>
    <span class="n">MODE_VBLANK_WIDE</span><span class="p">,</span>	<span class="cm">/* vertical blanking too wide */</span>
    <span class="n">MODE_PANEL</span><span class="p">,</span>         <span class="cm">/* exceeds panel dimensions */</span>
    <span class="n">MODE_INTERLACE_WIDTH</span><span class="p">,</span> <span class="cm">/* width too large for interlaced mode */</span>
    <span class="n">MODE_ONE_WIDTH</span><span class="p">,</span>     <span class="cm">/* only one width is supported */</span>
    <span class="n">MODE_ONE_HEIGHT</span><span class="p">,</span>    <span class="cm">/* only one height is supported */</span>
    <span class="n">MODE_ONE_SIZE</span><span class="p">,</span>      <span class="cm">/* only one resolution is supported */</span>
    <span class="n">MODE_NO_REDUCED</span><span class="p">,</span>    <span class="cm">/* monitor doesn&#39;t accept reduced blanking */</span>
    <span class="n">MODE_UNVERIFIED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="cm">/* mode needs to reverified */</span>
    <span class="n">MODE_BAD</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>	<span class="cm">/* unspecified reason */</span>
    <span class="n">MODE_ERROR</span>	<span class="o">=</span> <span class="o">-</span><span class="mi">1</span>	<span class="cm">/* error condition */</span>
<span class="p">};</span>

<span class="cp">#define DRM_MODE_TYPE_CLOCK_CRTC_C (DRM_MODE_TYPE_CLOCK_C | \</span>
<span class="cp">				    DRM_MODE_TYPE_CRTC_C)</span>

<span class="cp">#define DRM_MODE(nm, t, c, hd, hss, hse, ht, hsk, vd, vss, vse, vt, vs, f) \</span>
<span class="cp">	.name = nm, .status = 0, .type = (t), .clock = (c), \</span>
<span class="cp">	.hdisplay = (hd), .hsync_start = (hss), .hsync_end = (hse), \</span>
<span class="cp">	.htotal = (ht), .hskew = (hsk), .vdisplay = (vd), \</span>
<span class="cp">	.vsync_start = (vss), .vsync_end = (vse), .vtotal = (vt), \</span>
<span class="cp">	.vscan = (vs), .flags = (f), .vrefresh = 0</span>

<span class="cp">#define CRTC_INTERLACE_HALVE_V 0x1 </span><span class="cm">/* halve V values for interlacing */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="p">{</span>
	<span class="cm">/* Header */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_mode_object</span> <span class="n">base</span><span class="p">;</span>

	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">DRM_DISPLAY_MODE_LEN</span><span class="p">];</span>

	<span class="k">enum</span> <span class="n">drm_mode_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>

	<span class="cm">/* Proposed mode values */</span>
	<span class="kt">int</span> <span class="n">clock</span><span class="p">;</span>		<span class="cm">/* in kHz */</span>
	<span class="kt">int</span> <span class="n">hdisplay</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hsync_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hsync_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">htotal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hskew</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vdisplay</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vsync_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vsync_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vtotal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vscan</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Addressable image size (may be 0 for projectors, etc.) */</span>
	<span class="kt">int</span> <span class="n">width_mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">height_mm</span><span class="p">;</span>

	<span class="cm">/* Actual mode we give to hw */</span>
	<span class="kt">int</span> <span class="n">clock_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">synth_clock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crtc_hdisplay</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crtc_hblank_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crtc_hblank_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crtc_hsync_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crtc_hsync_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crtc_htotal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crtc_hskew</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crtc_vdisplay</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crtc_vblank_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crtc_vblank_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crtc_vsync_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crtc_vsync_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crtc_vtotal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crtc_hadjusted</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crtc_vadjusted</span><span class="p">;</span>

	<span class="cm">/* Driver private mode info */</span>
	<span class="kt">int</span> <span class="n">private_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">private_flags</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">vrefresh</span><span class="p">;</span>		<span class="cm">/* in Hz */</span>
	<span class="kt">int</span> <span class="n">hsync</span><span class="p">;</span>		<span class="cm">/* in kHz */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">drm_connector_status</span> <span class="p">{</span>
	<span class="n">connector_status_connected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">connector_status_disconnected</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">connector_status_unknown</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">subpixel_order</span> <span class="p">{</span>
	<span class="n">SubPixelUnknown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SubPixelHorizontalRGB</span><span class="p">,</span>
	<span class="n">SubPixelHorizontalBGR</span><span class="p">,</span>
	<span class="n">SubPixelVerticalRGB</span><span class="p">,</span>
	<span class="n">SubPixelVerticalBGR</span><span class="p">,</span>
	<span class="n">SubPixelNone</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define DRM_COLOR_FORMAT_RGB444		(1&lt;&lt;0)</span>
<span class="cp">#define DRM_COLOR_FORMAT_YCRCB444	(1&lt;&lt;1)</span>
<span class="cp">#define DRM_COLOR_FORMAT_YCRCB422	(1&lt;&lt;2)</span>
<span class="cm">/*</span>
<span class="cm"> * Describes a given display (e.g. CRT or flat panel) and its limitations.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_display_info</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">DRM_DISPLAY_INFO_LEN</span><span class="p">];</span>

	<span class="cm">/* Physical size */</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">width_mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">height_mm</span><span class="p">;</span>

	<span class="cm">/* Clock limits FIXME: storage format */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min_vfreq</span><span class="p">,</span> <span class="n">max_vfreq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min_hfreq</span><span class="p">,</span> <span class="n">max_hfreq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pixel_clock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bpc</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">subpixel_order</span> <span class="n">subpixel_order</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">color_formats</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">cea_rev</span><span class="p">;</span>

	<span class="kt">char</span> <span class="o">*</span><span class="n">raw_edid</span><span class="p">;</span> <span class="cm">/* if any */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_framebuffer_funcs</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_framebuffer</span> <span class="o">*</span><span class="n">framebuffer</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">create_handle</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_framebuffer</span> <span class="o">*</span><span class="n">fb</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>
	<span class="cm">/**</span>
<span class="cm">	 * Optinal callback for the dirty fb ioctl.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Userspace can notify the driver via this callback</span>
<span class="cm">	 * that a area of the framebuffer has changed and should</span>
<span class="cm">	 * be flushed to the display hardware.</span>
<span class="cm">	 *</span>
<span class="cm">	 * See documentation in drm_mode.h for the struct</span>
<span class="cm">	 * drm_mode_fb_dirty_cmd for more information as all</span>
<span class="cm">	 * the semantics and arguments have a one to one mapping</span>
<span class="cm">	 * on this function.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dirty</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_framebuffer</span> <span class="o">*</span><span class="n">framebuffer</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="n">color</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_clip_rect</span> <span class="o">*</span><span class="n">clips</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="n">num_clips</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_framebuffer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_mode_object</span> <span class="n">base</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">drm_framebuffer_funcs</span> <span class="o">*</span><span class="n">funcs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pitches</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
	<span class="cm">/* depth can be 15 or 16 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bits_per_pixel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pixel_format</span><span class="p">;</span> <span class="cm">/* fourcc format */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">filp_head</span><span class="p">;</span>
	<span class="cm">/* if you are using the helper */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">helper_private</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_property_blob</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_mode_object</span> <span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_property_enum</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">DRM_PROP_NAME_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_property</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_mode_object</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">DRM_PROP_NAME_LEN</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">num_values</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="o">*</span><span class="n">values</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">enum_blob_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_crtc</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">drm_connector</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">drm_encoder</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">drm_pending_vblank_event</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">drm_plane</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * drm_crtc_funcs - control CRTCs for a given device</span>
<span class="cm"> * @save: save CRTC state</span>
<span class="cm"> * @restore: restore CRTC state</span>
<span class="cm"> * @reset: reset CRTC after state has been invalidate (e.g. resume)</span>
<span class="cm"> * @cursor_set: setup the cursor</span>
<span class="cm"> * @cursor_move: move the cursor</span>
<span class="cm"> * @gamma_set: specify color ramp for CRTC</span>
<span class="cm"> * @destroy: deinit and free object</span>
<span class="cm"> * @set_property: called when a property is changed</span>
<span class="cm"> * @set_config: apply a new CRTC configuration</span>
<span class="cm"> * @page_flip: initiate a page flip</span>
<span class="cm"> *</span>
<span class="cm"> * The drm_crtc_funcs structure is the central CRTC management structure</span>
<span class="cm"> * in the DRM.  Each CRTC controls one or more connectors (note that the name</span>
<span class="cm"> * CRTC is simply historical, a CRTC may control LVDS, VGA, DVI, TV out, etc.</span>
<span class="cm"> * connectors, not just CRTs).</span>
<span class="cm"> *</span>
<span class="cm"> * Each driver is responsible for filling out this structure at startup time,</span>
<span class="cm"> * in addition to providing other modesetting features, like i2c and DDC</span>
<span class="cm"> * bus accessors.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_crtc_funcs</span> <span class="p">{</span>
	<span class="cm">/* Save CRTC state */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">save</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">);</span> <span class="cm">/* suspend? */</span>
	<span class="cm">/* Restore CRTC state */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">restore</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">);</span> <span class="cm">/* resume? */</span>
	<span class="cm">/* Reset CRTC state */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">);</span>

	<span class="cm">/* cursor controls */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cursor_set</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span>
			  <span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">width</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">height</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cursor_move</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>

	<span class="cm">/* Set gamma on the CRTC */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">gamma_set</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span>
			  <span class="kt">uint32_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">);</span>
	<span class="cm">/* Object destroy routine */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_config</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_mode_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Flip to the given framebuffer.  This implements the page</span>
<span class="cm">	 * flip ioctl described in drm_mode.h, specifically, the</span>
<span class="cm">	 * implementation must return immediately and block all</span>
<span class="cm">	 * rendering to the current fb until the flip has completed.</span>
<span class="cm">	 * If userspace set the event flag in the ioctl, the event</span>
<span class="cm">	 * argument will point to an event to send back when the flip</span>
<span class="cm">	 * completes, otherwise it will be NULL.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">page_flip</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">drm_framebuffer</span> <span class="o">*</span><span class="n">fb</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">drm_pending_vblank_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_property</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">val</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * drm_crtc - central CRTC control structure</span>
<span class="cm"> * @dev: parent DRM device</span>
<span class="cm"> * @head: list management</span>
<span class="cm"> * @base: base KMS object for ID tracking etc.</span>
<span class="cm"> * @enabled: is this CRTC enabled?</span>
<span class="cm"> * @mode: current mode timings</span>
<span class="cm"> * @hwmode: mode timings as programmed to hw regs</span>
<span class="cm"> * @x: x position on screen</span>
<span class="cm"> * @y: y position on screen</span>
<span class="cm"> * @funcs: CRTC control functions</span>
<span class="cm"> * @gamma_size: size of gamma ramp</span>
<span class="cm"> * @gamma_store: gamma ramp values</span>
<span class="cm"> * @framedur_ns: precise frame timing</span>
<span class="cm"> * @framedur_ns: precise line timing</span>
<span class="cm"> * @pixeldur_ns: precise pixel timing</span>
<span class="cm"> * @helper_private: mid-layer private data</span>
<span class="cm"> * @properties: property tracking for this CRTC</span>
<span class="cm"> *</span>
<span class="cm"> * Each CRTC may have one or more connectors associated with it.  This structure</span>
<span class="cm"> * allows the CRTC to be controlled.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_crtc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drm_mode_object</span> <span class="n">base</span><span class="p">;</span>

	<span class="cm">/* framebuffer the connector is currently bound to */</span>
	<span class="k">struct</span> <span class="n">drm_framebuffer</span> <span class="o">*</span><span class="n">fb</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">enabled</span><span class="p">;</span>

	<span class="cm">/* Requested mode from modesetting. */</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="n">mode</span><span class="p">;</span>

	<span class="cm">/* Programmed mode in hw, after adjustments for encoders,</span>
<span class="cm">	 * crtc, panel scaling etc. Needed for timestamping etc.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="n">hwmode</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">drm_crtc_funcs</span> <span class="o">*</span><span class="n">funcs</span><span class="p">;</span>

	<span class="cm">/* CRTC gamma size for reporting to userspace */</span>
	<span class="kt">uint32_t</span> <span class="n">gamma_size</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="o">*</span><span class="n">gamma_store</span><span class="p">;</span>

	<span class="cm">/* Constants needed for precise vblank and swap timestamping. */</span>
	<span class="n">s64</span> <span class="n">framedur_ns</span><span class="p">,</span> <span class="n">linedur_ns</span><span class="p">,</span> <span class="n">pixeldur_ns</span><span class="p">;</span>

	<span class="cm">/* if you are using the helper */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">helper_private</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drm_object_properties</span> <span class="n">properties</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * drm_connector_funcs - control connectors on a given device</span>
<span class="cm"> * @dpms: set power state (see drm_crtc_funcs above)</span>
<span class="cm"> * @save: save connector state</span>
<span class="cm"> * @restore: restore connector state</span>
<span class="cm"> * @reset: reset connector after state has been invalidate (e.g. resume)</span>
<span class="cm"> * @detect: is this connector active?</span>
<span class="cm"> * @fill_modes: fill mode list for this connector</span>
<span class="cm"> * @set_property: property for this connector may need update</span>
<span class="cm"> * @destroy: make object go away</span>
<span class="cm"> * @force: notify the driver the connector is forced on</span>
<span class="cm"> *</span>
<span class="cm"> * Each CRTC may have one or more connectors attached to it.  The functions</span>
<span class="cm"> * below allow the core DRM code to control connectors, enumerate available modes,</span>
<span class="cm"> * etc.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_connector_funcs</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dpms</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">save</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">restore</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">);</span>

	<span class="cm">/* Check to see if anything is attached to the connector.</span>
<span class="cm">	 * @force is set to false whilst polling, true when checking the</span>
<span class="cm">	 * connector due to user request. @force can be used by the driver</span>
<span class="cm">	 * to avoid expensive, destructive operations during automated</span>
<span class="cm">	 * probing.</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">drm_connector_status</span> <span class="p">(</span><span class="o">*</span><span class="n">detect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
					    <span class="n">bool</span> <span class="n">force</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fill_modes</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">max_width</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">max_height</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_property</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span>
			     <span class="kt">uint64_t</span> <span class="n">val</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">force</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * drm_encoder_funcs - encoder controls</span>
<span class="cm"> * @reset: reset state (e.g. at init or resume time)</span>
<span class="cm"> * @destroy: cleanup and free associated data</span>
<span class="cm"> *</span>
<span class="cm"> * Encoders sit between CRTCs and connectors.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_encoder_funcs</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_encoder</span> <span class="o">*</span><span class="n">encoder</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_encoder</span> <span class="o">*</span><span class="n">encoder</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define DRM_CONNECTOR_MAX_UMODES 16</span>
<span class="cp">#define DRM_CONNECTOR_LEN 32</span>
<span class="cp">#define DRM_CONNECTOR_MAX_ENCODER 3</span>

<span class="cm">/**</span>
<span class="cm"> * drm_encoder - central DRM encoder structure</span>
<span class="cm"> * @dev: parent DRM device</span>
<span class="cm"> * @head: list management</span>
<span class="cm"> * @base: base KMS object</span>
<span class="cm"> * @encoder_type: one of the %DRM_MODE_ENCODER_&lt;foo&gt; types in drm_mode.h</span>
<span class="cm"> * @possible_crtcs: bitmask of potential CRTC bindings</span>
<span class="cm"> * @possible_clones: bitmask of potential sibling encoders for cloning</span>
<span class="cm"> * @crtc: currently bound CRTC</span>
<span class="cm"> * @funcs: control functions</span>
<span class="cm"> * @helper_private: mid-layer private data</span>
<span class="cm"> *</span>
<span class="cm"> * CRTCs drive pixels to encoders, which convert them into signals</span>
<span class="cm"> * appropriate for a given connector or set of connectors.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_encoder</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drm_mode_object</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">encoder_type</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">possible_crtcs</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">possible_clones</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">drm_encoder_funcs</span> <span class="o">*</span><span class="n">funcs</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">helper_private</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">drm_connector_force</span> <span class="p">{</span>
	<span class="n">DRM_FORCE_UNSPECIFIED</span><span class="p">,</span>
	<span class="n">DRM_FORCE_OFF</span><span class="p">,</span>
	<span class="n">DRM_FORCE_ON</span><span class="p">,</span>         <span class="cm">/* force on analog part normally */</span>
	<span class="n">DRM_FORCE_ON_DIGITAL</span><span class="p">,</span> <span class="cm">/* for DVI-I use digital connector */</span>
<span class="p">};</span>

<span class="cm">/* should we poll this connector for connects and disconnects */</span>
<span class="cm">/* hot plug detectable */</span>
<span class="cp">#define DRM_CONNECTOR_POLL_HPD (1 &lt;&lt; 0)</span>
<span class="cm">/* poll for connections */</span>
<span class="cp">#define DRM_CONNECTOR_POLL_CONNECT (1 &lt;&lt; 1)</span>
<span class="cm">/* can cleanly poll for disconnections without flickering the screen */</span>
<span class="cm">/* DACs should rarely do this without a lot of testing */</span>
<span class="cp">#define DRM_CONNECTOR_POLL_DISCONNECT (1 &lt;&lt; 2)</span>

<span class="cp">#define MAX_ELD_BYTES	128</span>

<span class="cm">/**</span>
<span class="cm"> * drm_connector - central DRM connector control structure</span>
<span class="cm"> * @dev: parent DRM device</span>
<span class="cm"> * @kdev: kernel device for sysfs attributes</span>
<span class="cm"> * @attr: sysfs attributes</span>
<span class="cm"> * @head: list management</span>
<span class="cm"> * @base: base KMS object</span>
<span class="cm"> * @connector_type: one of the %DRM_MODE_CONNECTOR_&lt;foo&gt; types from drm_mode.h</span>
<span class="cm"> * @connector_type_id: index into connector type enum</span>
<span class="cm"> * @interlace_allowed: can this connector handle interlaced modes?</span>
<span class="cm"> * @doublescan_allowed: can this connector handle doublescan?</span>
<span class="cm"> * @modes: modes available on this connector (from fill_modes() + user)</span>
<span class="cm"> * @status: one of the drm_connector_status enums (connected, not, or unknown)</span>
<span class="cm"> * @probed_modes: list of modes derived directly from the display</span>
<span class="cm"> * @display_info: information about attached display (e.g. from EDID)</span>
<span class="cm"> * @funcs: connector control functions</span>
<span class="cm"> * @user_modes: user added mode list</span>
<span class="cm"> * @edid_blob_ptr: DRM property containing EDID if present</span>
<span class="cm"> * @properties: property tracking for this connector</span>
<span class="cm"> * @polled: a %DRM_CONNECTOR_POLL_&lt;foo&gt; value for core driven polling</span>
<span class="cm"> * @dpms: current dpms state</span>
<span class="cm"> * @helper_private: mid-layer private data</span>
<span class="cm"> * @force: a %DRM_FORCE_&lt;foo&gt; state for forced mode sets</span>
<span class="cm"> * @encoder_ids: valid encoders for this connector</span>
<span class="cm"> * @encoder: encoder driving this connector, if any</span>
<span class="cm"> * @eld: EDID-like data, if present</span>
<span class="cm"> * @dvi_dual: dual link DVI, if found</span>
<span class="cm"> * @max_tmds_clock: max clock rate, if found</span>
<span class="cm"> * @latency_present: AV delay info from ELD, if found</span>
<span class="cm"> * @video_latency: video latency info from ELD, if found</span>
<span class="cm"> * @audio_latency: audio latency info from ELD, if found</span>
<span class="cm"> * @null_edid_counter: track sinks that give us all zeros for the EDID</span>
<span class="cm"> *</span>
<span class="cm"> * Each connector may be connected to one or more CRTCs, or may be clonable by</span>
<span class="cm"> * another connector if they can share a CRTC.  Each connector also has a specific</span>
<span class="cm"> * position in the broader display (referred to as a &#39;screen&#39; though it could</span>
<span class="cm"> * span multiple monitors).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_connector</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">kdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drm_mode_object</span> <span class="n">base</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">connector_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">connector_type_id</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">interlace_allowed</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">doublescan_allowed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">modes</span><span class="p">;</span> <span class="cm">/* list of modes on this connector */</span>

	<span class="k">enum</span> <span class="n">drm_connector_status</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* these are modes added by probing with DDC or the BIOS */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">probed_modes</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drm_display_info</span> <span class="n">display_info</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">drm_connector_funcs</span> <span class="o">*</span><span class="n">funcs</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">user_modes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property_blob</span> <span class="o">*</span><span class="n">edid_blob_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_object_properties</span> <span class="n">properties</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="n">polled</span><span class="p">;</span> <span class="cm">/* DRM_CONNECTOR_POLL_* */</span>

	<span class="cm">/* requested DPMS state */</span>
	<span class="kt">int</span> <span class="n">dpms</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">helper_private</span><span class="p">;</span>

	<span class="cm">/* forced on connector */</span>
	<span class="k">enum</span> <span class="n">drm_connector_force</span> <span class="n">force</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">encoder_ids</span><span class="p">[</span><span class="n">DRM_CONNECTOR_MAX_ENCODER</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">drm_encoder</span> <span class="o">*</span><span class="n">encoder</span><span class="p">;</span> <span class="cm">/* currently active encoder */</span>

	<span class="cm">/* EDID bits */</span>
	<span class="kt">uint8_t</span> <span class="n">eld</span><span class="p">[</span><span class="n">MAX_ELD_BYTES</span><span class="p">];</span>
	<span class="n">bool</span> <span class="n">dvi_dual</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_tmds_clock</span><span class="p">;</span>	<span class="cm">/* in MHz */</span>
	<span class="n">bool</span> <span class="n">latency_present</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">video_latency</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* [0]: progressive, [1]: interlaced */</span>
	<span class="kt">int</span> <span class="n">audio_latency</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">null_edid_counter</span><span class="p">;</span> <span class="cm">/* needed to workaround some HW bugs where we get all 0s */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * drm_plane_funcs - driver plane control functions</span>
<span class="cm"> * @update_plane: update the plane configuration</span>
<span class="cm"> * @disable_plane: shut down the plane</span>
<span class="cm"> * @destroy: clean up plane resources</span>
<span class="cm"> * @set_property: called when a property is changed</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_plane_funcs</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">update_plane</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_plane</span> <span class="o">*</span><span class="n">plane</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_framebuffer</span> <span class="o">*</span><span class="n">fb</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">crtc_x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc_y</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">crtc_w</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">crtc_h</span><span class="p">,</span>
			    <span class="kt">uint32_t</span> <span class="n">src_x</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">src_y</span><span class="p">,</span>
			    <span class="kt">uint32_t</span> <span class="n">src_w</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">src_h</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">disable_plane</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_plane</span> <span class="o">*</span><span class="n">plane</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_plane</span> <span class="o">*</span><span class="n">plane</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_property</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_plane</span> <span class="o">*</span><span class="n">plane</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">val</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * drm_plane - central DRM plane control structure</span>
<span class="cm"> * @dev: DRM device this plane belongs to</span>
<span class="cm"> * @head: for list management</span>
<span class="cm"> * @base: base mode object</span>
<span class="cm"> * @possible_crtcs: pipes this plane can be bound to</span>
<span class="cm"> * @format_types: array of formats supported by this plane</span>
<span class="cm"> * @format_count: number of formats supported</span>
<span class="cm"> * @crtc: currently bound CRTC</span>
<span class="cm"> * @fb: currently bound fb</span>
<span class="cm"> * @gamma_size: size of gamma table</span>
<span class="cm"> * @gamma_store: gamma correction table</span>
<span class="cm"> * @enabled: enabled flag</span>
<span class="cm"> * @funcs: helper functions</span>
<span class="cm"> * @helper_private: storage for drver layer</span>
<span class="cm"> * @properties: property tracking for this plane</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_plane</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drm_mode_object</span> <span class="n">base</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">possible_crtcs</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">format_types</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">format_count</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_framebuffer</span> <span class="o">*</span><span class="n">fb</span><span class="p">;</span>

	<span class="cm">/* CRTC gamma size for reporting to userspace */</span>
	<span class="kt">uint32_t</span> <span class="n">gamma_size</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="o">*</span><span class="n">gamma_store</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">enabled</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">drm_plane_funcs</span> <span class="o">*</span><span class="n">funcs</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">helper_private</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drm_object_properties</span> <span class="n">properties</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_set - new values for a CRTC config change</span>
<span class="cm"> * @head: list management</span>
<span class="cm"> * @fb: framebuffer to use for new config</span>
<span class="cm"> * @crtc: CRTC whose configuration we&#39;re about to change</span>
<span class="cm"> * @mode: mode timings to use</span>
<span class="cm"> * @x: position of this CRTC relative to @fb</span>
<span class="cm"> * @y: position of this CRTC relative to @fb</span>
<span class="cm"> * @connectors: array of connectors to drive with this CRTC if possible</span>
<span class="cm"> * @num_connectors: size of @connectors array</span>
<span class="cm"> *</span>
<span class="cm"> * Represents a single crtc the connectors that it drives with what mode</span>
<span class="cm"> * and from which framebuffer it scans out from.</span>
<span class="cm"> *</span>
<span class="cm"> * This is used to set modes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_mode_set</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drm_framebuffer</span> <span class="o">*</span><span class="n">fb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">x</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">y</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">**</span><span class="n">connectors</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">num_connectors</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_mode_config_funcs - basic driver provided mode setting functions</span>
<span class="cm"> * @fb_create: create a new framebuffer object</span>
<span class="cm"> * @output_poll_changed: function to handle output configuration changes</span>
<span class="cm"> *</span>
<span class="cm"> * Some global (i.e. not per-CRTC, connector, etc) mode setting functions that</span>
<span class="cm"> * involve drivers.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_mode_config_funcs</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_framebuffer</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">fb_create</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">drm_mode_fb_cmd2</span> <span class="o">*</span><span class="n">mode_cmd</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">output_poll_changed</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_group - group of mode setting resources for potential sub-grouping</span>
<span class="cm"> * @num_crtcs: CRTC count</span>
<span class="cm"> * @num_encoders: encoder count</span>
<span class="cm"> * @num_connectors: connector count</span>
<span class="cm"> * @id_list: list of KMS object IDs in this group</span>
<span class="cm"> *</span>
<span class="cm"> * Currently this simply tracks the global mode setting state.  But in the</span>
<span class="cm"> * future it could allow groups of objects to be set aside into independent</span>
<span class="cm"> * control groups for use by different user level processes (e.g. two X servers</span>
<span class="cm"> * running simultaneously on different heads, each with their own mode</span>
<span class="cm"> * configuration and freedom of mode setting).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_mode_group</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">num_crtcs</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">num_encoders</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">num_connectors</span><span class="p">;</span>

	<span class="cm">/* list of object IDs for this group */</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">id_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_config - Mode configuration control structure</span>
<span class="cm"> * @mutex: mutex protecting KMS related lists and structures</span>
<span class="cm"> * @idr_mutex: mutex for KMS ID allocation and management</span>
<span class="cm"> * @crtc_idr: main KMS ID tracking object</span>
<span class="cm"> * @num_fb: number of fbs available</span>
<span class="cm"> * @fb_list: list of framebuffers available</span>
<span class="cm"> * @num_connector: number of connectors on this device</span>
<span class="cm"> * @connector_list: list of connector objects</span>
<span class="cm"> * @num_encoder: number of encoders on this device</span>
<span class="cm"> * @encoder_list: list of encoder objects</span>
<span class="cm"> * @num_crtc: number of CRTCs on this device</span>
<span class="cm"> * @crtc_list: list of CRTC objects</span>
<span class="cm"> * @min_width: minimum pixel width on this device</span>
<span class="cm"> * @min_height: minimum pixel height on this device</span>
<span class="cm"> * @max_width: maximum pixel width on this device</span>
<span class="cm"> * @max_height: maximum pixel height on this device</span>
<span class="cm"> * @funcs: core driver provided mode setting functions</span>
<span class="cm"> * @fb_base: base address of the framebuffer</span>
<span class="cm"> * @poll_enabled: track polling status for this device</span>
<span class="cm"> * @output_poll_work: delayed work for polling in process context</span>
<span class="cm"> * @*_property: core property tracking</span>
<span class="cm"> *</span>
<span class="cm"> * Core mode resource tracking structure.  All CRTC, encoders, and connectors</span>
<span class="cm"> * enumerated by the driver are added here, as are global properties.  Some</span>
<span class="cm"> * global restrictions are also here, e.g. dimension restrictions.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_mode_config</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span> <span class="cm">/* protects configuration (mode lists etc.) */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">idr_mutex</span><span class="p">;</span> <span class="cm">/* for IDR management */</span>
	<span class="k">struct</span> <span class="n">idr</span> <span class="n">crtc_idr</span><span class="p">;</span> <span class="cm">/* use this idr for all IDs, fb, crtc, connector, modes - just makes life easier */</span>
	<span class="cm">/* this is limited to one for now */</span>
	<span class="kt">int</span> <span class="n">num_fb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">fb_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_connector</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">connector_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_encoder</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">encoder_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_plane</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">plane_list</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">num_crtc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">crtc_list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">property_list</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">min_width</span><span class="p">,</span> <span class="n">min_height</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_width</span><span class="p">,</span> <span class="n">max_height</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">drm_mode_config_funcs</span> <span class="o">*</span><span class="n">funcs</span><span class="p">;</span>
	<span class="n">resource_size_t</span> <span class="n">fb_base</span><span class="p">;</span>

	<span class="cm">/* output poll support */</span>
	<span class="n">bool</span> <span class="n">poll_enabled</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">output_poll_work</span><span class="p">;</span>

	<span class="cm">/* pointers to standard properties */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">property_blob_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">edid_property</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">dpms_property</span><span class="p">;</span>

	<span class="cm">/* DVI-I properties */</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">dvi_i_subconnector_property</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">dvi_i_select_subconnector_property</span><span class="p">;</span>

	<span class="cm">/* TV properties */</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">tv_subconnector_property</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">tv_select_subconnector_property</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">tv_mode_property</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">tv_left_margin_property</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">tv_right_margin_property</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">tv_top_margin_property</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">tv_bottom_margin_property</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">tv_brightness_property</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">tv_contrast_property</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">tv_flicker_reduction_property</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">tv_overscan_property</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">tv_saturation_property</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">tv_hue_property</span><span class="p">;</span>

	<span class="cm">/* Optional properties */</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">scaling_mode_property</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">dithering_mode_property</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">dirty_info_property</span><span class="p">;</span>

	<span class="cm">/* dumb ioctl parameters */</span>
	<span class="kt">uint32_t</span> <span class="n">preferred_depth</span><span class="p">,</span> <span class="n">prefer_shadow</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define obj_to_crtc(x) container_of(x, struct drm_crtc, base)</span>
<span class="cp">#define obj_to_connector(x) container_of(x, struct drm_connector, base)</span>
<span class="cp">#define obj_to_encoder(x) container_of(x, struct drm_encoder, base)</span>
<span class="cp">#define obj_to_mode(x) container_of(x, struct drm_display_mode, base)</span>
<span class="cp">#define obj_to_fb(x) container_of(x, struct drm_framebuffer, base)</span>
<span class="cp">#define obj_to_property(x) container_of(x, struct drm_property, base)</span>
<span class="cp">#define obj_to_blob(x) container_of(x, struct drm_property_blob, base)</span>
<span class="cp">#define obj_to_plane(x) container_of(x, struct drm_plane, base)</span>

<span class="k">struct</span> <span class="n">drm_prop_enum_list</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_crtc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">drm_crtc_funcs</span> <span class="o">*</span><span class="n">funcs</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_crtc_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_connector_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">drm_connector_funcs</span> <span class="o">*</span><span class="n">funcs</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">connector_type</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_connector_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">);</span>
<span class="cm">/* helper to unplug all connectors from sysfs for device */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_connector_unplug_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_encoder_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">drm_encoder</span> <span class="o">*</span><span class="n">encoder</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">drm_encoder_funcs</span> <span class="o">*</span><span class="n">funcs</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">encoder_type</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_plane_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">drm_plane</span> <span class="o">*</span><span class="n">plane</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">possible_crtcs</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">drm_plane_funcs</span> <span class="o">*</span><span class="n">funcs</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">formats</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">format_count</span><span class="p">,</span>
			  <span class="n">bool</span> <span class="n">priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_plane_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_plane</span> <span class="o">*</span><span class="n">plane</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_encoder_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_encoder</span> <span class="o">*</span><span class="n">encoder</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">drm_get_connector_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">drm_get_dpms_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">drm_get_dvi_i_subconnector_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">drm_get_dvi_i_select_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">drm_get_tv_subconnector_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">drm_get_tv_select_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_fb_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_group_init_legacy_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_mode_group</span> <span class="o">*</span><span class="n">group</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">drm_get_edid</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_add_edid_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_mode_probed_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_mode_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_mode_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">src</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">drm_mode_duplicate</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						   <span class="k">const</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_mode_debug_printmodeline</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_mode_config_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_mode_config_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_mode_config_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_mode_set_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">drm_mode_equal</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode2</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_width</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_height</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>

<span class="cm">/* for us by fb module */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_attachmode_crtc</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_detachmode_crtc</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">drm_mode_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_mode_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_mode_list_concat</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">new</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_mode_validate_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">mode_list</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">maxX</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxY</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxPitch</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_mode_prune_invalid</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">mode_list</span><span class="p">,</span> <span class="n">bool</span> <span class="n">verbose</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_mode_sort</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">mode_list</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_hsync</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_vrefresh</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_mode_set_crtcinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">adjust_flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_mode_connector_list_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_connector_update_edid_property</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_connector_property_set_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span>
					 <span class="kt">uint64_t</span> <span class="n">value</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_connector_property_get_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span>
					 <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_object_property_set_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_mode_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span>
					 <span class="kt">uint64_t</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_object_property_get_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_mode_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span>
					 <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">drm_crtc_mode_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_framebuffer_set_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">handle</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_framebuffer_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">drm_framebuffer</span> <span class="o">*</span><span class="n">fb</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">drm_framebuffer_funcs</span> <span class="o">*</span><span class="n">funcs</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_framebuffer_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_framebuffer</span> <span class="o">*</span><span class="n">fb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drmfb_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drmfb_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_framebuffer</span> <span class="o">*</span><span class="n">fb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_crtc_probe_connector_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxX</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxY</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">drm_crtc_in_use</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_connector_attach_property</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">init_val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_object_attach_property</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_mode_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span>
				       <span class="kt">uint64_t</span> <span class="n">init_val</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">drm_property_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
						<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_values</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">drm_property_create_enum</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">drm_prop_enum_list</span> <span class="o">*</span><span class="n">props</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">num_values</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">drm_property_create_bitmask</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">drm_prop_enum_list</span> <span class="o">*</span><span class="n">props</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">num_values</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">drm_property_create_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					 <span class="kt">uint64_t</span> <span class="n">min</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">max</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_property_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">property</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_property_add_enum</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_property</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
				 <span class="kt">uint64_t</span> <span class="n">value</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_create_dvi_i_properties</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_create_tv_properties</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_formats</span><span class="p">,</span>
				     <span class="kt">char</span> <span class="o">*</span><span class="n">formats</span><span class="p">[]);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_create_scaling_mode_property</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_create_dithering_property</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_create_dirty_info_property</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">drm_get_encoder_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_encoder</span> <span class="o">*</span><span class="n">encoder</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_connector_attach_encoder</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">drm_encoder</span> <span class="o">*</span><span class="n">encoder</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_mode_connector_detach_encoder</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">drm_encoder</span> <span class="o">*</span><span class="n">encoder</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_crtc_set_gamma_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">gamma_size</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">drm_mode_object</span> <span class="o">*</span><span class="n">drm_mode_object_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="kt">uint32_t</span> <span class="n">id</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">type</span><span class="p">);</span>
<span class="cm">/* IOCTLs */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_getresources</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_getplane_res</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_getcrtc</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_getconnector</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_setcrtc</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_getplane</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_setplane</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_cursor_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_addfb</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_addfb2</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">uint32_t</span> <span class="n">drm_mode_legacy_fb_format</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">bpp</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">depth</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_rmfb</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_getfb</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_dirtyfb_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_addmode_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_rmmode_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_attachmode_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_detachmode_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_getproperty_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_getblob_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_connector_property_set_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_hotplug_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_replacefb</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_getencoder</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_gamma_get_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_gamma_set_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u8</span> <span class="o">*</span><span class="n">drm_find_cea_extension</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">drm_detect_hdmi_monitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">drm_detect_monitor_audio</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_page_flip_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">drm_cvt_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">hdisplay</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vdisplay</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vrefresh</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">reduced</span><span class="p">,</span> <span class="n">bool</span> <span class="n">interlaced</span><span class="p">,</span> <span class="n">bool</span> <span class="n">margins</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">drm_gtf_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">hdisplay</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vdisplay</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vrefresh</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">interlaced</span><span class="p">,</span> <span class="kt">int</span> <span class="n">margins</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">drm_gtf_mode_complex</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">hdisplay</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vdisplay</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vrefresh</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">interlaced</span><span class="p">,</span> <span class="kt">int</span> <span class="n">margins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">GTF_M</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">GTF_2C</span><span class="p">,</span> <span class="kt">int</span> <span class="n">GTF_K</span><span class="p">,</span> <span class="kt">int</span> <span class="n">GTF_2J</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_add_modes_noedid</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">hdisplay</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vdisplay</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_edid_header_is_valid</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">raw_edid</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">drm_edid_block_valid</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">raw_edid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">drm_edid_is_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">drm_mode_find_dmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">hsize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vsize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fresh</span><span class="p">,</span>
					   <span class="n">bool</span> <span class="n">rb</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_create_dumb_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_mmap_dumb_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_destroy_dumb_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_obj_get_properties_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mode_obj_set_property_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_fb_get_bpp_depth</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">format</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">depth</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="o">*</span><span class="n">bpp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_format_num_planes</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">format</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_format_plane_cpp</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">format</span><span class="p">,</span> <span class="kt">int</span> <span class="n">plane</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_format_horz_chroma_subsampling</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">format</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_format_vert_chroma_subsampling</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">format</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __DRM_CRTC_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
