<!DOCTYPE html>
<html><head><title>joekychen/linux » include › drm › vmwgfx_drm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>vmwgfx_drm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright © 2009 VMware, Inc., Palo Alto, CA., USA</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the</span>
<span class="cm"> * &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="cm"> * without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="cm"> * distribute, sub license, and/or sell copies of the Software, and to</span>
<span class="cm"> * permit persons to whom the Software is furnished to do so, subject to</span>
<span class="cm"> * the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice (including the</span>
<span class="cm"> * next paragraph) shall be included in all copies or substantial portions</span>
<span class="cm"> * of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL</span>
<span class="cm"> * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,</span>
<span class="cm"> * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="cm"> * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="cm"> * USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cp">#ifndef __VMWGFX_DRM_H__</span>
<span class="cp">#define __VMWGFX_DRM_H__</span>

<span class="cp">#define DRM_VMW_MAX_SURFACE_FACES 6</span>
<span class="cp">#define DRM_VMW_MAX_MIP_LEVELS 24</span>


<span class="cp">#define DRM_VMW_GET_PARAM            0</span>
<span class="cp">#define DRM_VMW_ALLOC_DMABUF         1</span>
<span class="cp">#define DRM_VMW_UNREF_DMABUF         2</span>
<span class="cp">#define DRM_VMW_CURSOR_BYPASS        3</span>
<span class="cm">/* guarded by DRM_VMW_PARAM_NUM_STREAMS != 0*/</span>
<span class="cp">#define DRM_VMW_CONTROL_STREAM       4</span>
<span class="cp">#define DRM_VMW_CLAIM_STREAM         5</span>
<span class="cp">#define DRM_VMW_UNREF_STREAM         6</span>
<span class="cm">/* guarded by DRM_VMW_PARAM_3D == 1 */</span>
<span class="cp">#define DRM_VMW_CREATE_CONTEXT       7</span>
<span class="cp">#define DRM_VMW_UNREF_CONTEXT        8</span>
<span class="cp">#define DRM_VMW_CREATE_SURFACE       9</span>
<span class="cp">#define DRM_VMW_UNREF_SURFACE        10</span>
<span class="cp">#define DRM_VMW_REF_SURFACE          11</span>
<span class="cp">#define DRM_VMW_EXECBUF              12</span>
<span class="cp">#define DRM_VMW_GET_3D_CAP           13</span>
<span class="cp">#define DRM_VMW_FENCE_WAIT           14</span>
<span class="cp">#define DRM_VMW_FENCE_SIGNALED       15</span>
<span class="cp">#define DRM_VMW_FENCE_UNREF          16</span>
<span class="cp">#define DRM_VMW_FENCE_EVENT          17</span>
<span class="cp">#define DRM_VMW_PRESENT              18</span>
<span class="cp">#define DRM_VMW_PRESENT_READBACK     19</span>
<span class="cp">#define DRM_VMW_UPDATE_LAYOUT        20</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_GET_PARAM - get device information.</span>
<span class="cm"> *</span>
<span class="cm"> * DRM_VMW_PARAM_FIFO_OFFSET:</span>
<span class="cm"> * Offset to use to map the first page of the FIFO read-only.</span>
<span class="cm"> * The fifo is mapped using the mmap() system call on the drm device.</span>
<span class="cm"> *</span>
<span class="cm"> * DRM_VMW_PARAM_OVERLAY_IOCTL:</span>
<span class="cm"> * Does the driver support the overlay ioctl.</span>
<span class="cm"> */</span>

<span class="cp">#define DRM_VMW_PARAM_NUM_STREAMS      0</span>
<span class="cp">#define DRM_VMW_PARAM_NUM_FREE_STREAMS 1</span>
<span class="cp">#define DRM_VMW_PARAM_3D               2</span>
<span class="cp">#define DRM_VMW_PARAM_HW_CAPS          3</span>
<span class="cp">#define DRM_VMW_PARAM_FIFO_CAPS        4</span>
<span class="cp">#define DRM_VMW_PARAM_MAX_FB_SIZE      5</span>
<span class="cp">#define DRM_VMW_PARAM_FIFO_HW_VERSION  6</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_getparam_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @value: Returned value. //Out</span>
<span class="cm"> * @param: Parameter to query. //In.</span>
<span class="cm"> *</span>
<span class="cm"> * Argument to the DRM_VMW_GET_PARAM Ioctl.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_getparam_arg</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">param</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pad64</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_CREATE_CONTEXT - Create a host context.</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates a device unique context id, and queues a create context command</span>
<span class="cm"> * for the host. Does not wait for host completion.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_context_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @cid: Device unique context ID.</span>
<span class="cm"> *</span>
<span class="cm"> * Output argument to the DRM_VMW_CREATE_CONTEXT Ioctl.</span>
<span class="cm"> * Input argument to the DRM_VMW_UNREF_CONTEXT Ioctl.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_context_arg</span> <span class="p">{</span>
	<span class="kt">int32_t</span> <span class="n">cid</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pad64</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_UNREF_CONTEXT - Create a host context.</span>
<span class="cm"> *</span>
<span class="cm"> * Frees a global context id, and queues a destroy host command for the host.</span>
<span class="cm"> * Does not wait for host completion. The context ID can be used directly</span>
<span class="cm"> * in the command stream and shows up as the same context ID on the host.</span>
<span class="cm"> */</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_CREATE_SURFACE - Create a host suface.</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates a device unique surface id, and queues a create surface command</span>
<span class="cm"> * for the host. Does not wait for host completion. The surface ID can be</span>
<span class="cm"> * used directly in the command stream and shows up as the same surface</span>
<span class="cm"> * ID on the host.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_wmv_surface_create_req</span>
<span class="cm"> *</span>
<span class="cm"> * @flags: Surface flags as understood by the host.</span>
<span class="cm"> * @format: Surface format as understood by the host.</span>
<span class="cm"> * @mip_levels: Number of mip levels for each face.</span>
<span class="cm"> * An unused face should have 0 encoded.</span>
<span class="cm"> * @size_addr: Address of a user-space array of sruct drm_vmw_size</span>
<span class="cm"> * cast to an uint64_t for 32-64 bit compatibility.</span>
<span class="cm"> * The size of the array should equal the total number of mipmap levels.</span>
<span class="cm"> * @shareable: Boolean whether other clients (as identified by file descriptors)</span>
<span class="cm"> * may reference this surface.</span>
<span class="cm"> * @scanout: Boolean whether the surface is intended to be used as a</span>
<span class="cm"> * scanout.</span>
<span class="cm"> *</span>
<span class="cm"> * Input data to the DRM_VMW_CREATE_SURFACE Ioctl.</span>
<span class="cm"> * Output data from the DRM_VMW_REF_SURFACE Ioctl.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_surface_create_req</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">format</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mip_levels</span><span class="p">[</span><span class="n">DRM_VMW_MAX_SURFACE_FACES</span><span class="p">];</span>
	<span class="kt">uint64_t</span> <span class="n">size_addr</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">shareable</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">scanout</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_wmv_surface_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @sid: Surface id of created surface or surface to destroy or reference.</span>
<span class="cm"> *</span>
<span class="cm"> * Output data from the DRM_VMW_CREATE_SURFACE Ioctl.</span>
<span class="cm"> * Input argument to the DRM_VMW_UNREF_SURFACE Ioctl.</span>
<span class="cm"> * Input argument to the DRM_VMW_REF_SURFACE Ioctl.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_surface_arg</span> <span class="p">{</span>
	<span class="kt">int32_t</span> <span class="n">sid</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pad64</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_size ioctl.</span>
<span class="cm"> *</span>
<span class="cm"> * @width - mip level width</span>
<span class="cm"> * @height - mip level height</span>
<span class="cm"> * @depth - mip level depth</span>
<span class="cm"> *</span>
<span class="cm"> * Description of a mip level.</span>
<span class="cm"> * Input data to the DRM_WMW_CREATE_SURFACE Ioctl.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_size</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">width</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">height</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">depth</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pad64</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * union drm_vmw_surface_create_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @rep: Output data as described above.</span>
<span class="cm"> * @req: Input data as described above.</span>
<span class="cm"> *</span>
<span class="cm"> * Argument to the DRM_VMW_CREATE_SURFACE Ioctl.</span>
<span class="cm"> */</span>

<span class="k">union</span> <span class="n">drm_vmw_surface_create_arg</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_vmw_surface_arg</span> <span class="n">rep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_vmw_surface_create_req</span> <span class="n">req</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_REF_SURFACE - Reference a host surface.</span>
<span class="cm"> *</span>
<span class="cm"> * Puts a reference on a host surface with a give sid, as previously</span>
<span class="cm"> * returned by the DRM_VMW_CREATE_SURFACE ioctl.</span>
<span class="cm"> * A reference will make sure the surface isn&#39;t destroyed while we hold</span>
<span class="cm"> * it and will allow the calling client to use the surface ID in the command</span>
<span class="cm"> * stream.</span>
<span class="cm"> *</span>
<span class="cm"> * On successful return, the Ioctl returns the surface information given</span>
<span class="cm"> * in the DRM_VMW_CREATE_SURFACE ioctl.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * union drm_vmw_surface_reference_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @rep: Output data as described above.</span>
<span class="cm"> * @req: Input data as described above.</span>
<span class="cm"> *</span>
<span class="cm"> * Argument to the DRM_VMW_REF_SURFACE Ioctl.</span>
<span class="cm"> */</span>

<span class="k">union</span> <span class="n">drm_vmw_surface_reference_arg</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_vmw_surface_create_req</span> <span class="n">rep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_vmw_surface_arg</span> <span class="n">req</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_UNREF_SURFACE - Unreference a host surface.</span>
<span class="cm"> *</span>
<span class="cm"> * Clear a reference previously put on a host surface.</span>
<span class="cm"> * When all references are gone, including the one implicitly placed</span>
<span class="cm"> * on creation,</span>
<span class="cm"> * a destroy surface command will be queued for the host.</span>
<span class="cm"> * Does not wait for completion.</span>
<span class="cm"> */</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_EXECBUF</span>
<span class="cm"> *</span>
<span class="cm"> * Submit a command buffer for execution on the host, and return a</span>
<span class="cm"> * fence seqno that when signaled, indicates that the command buffer has</span>
<span class="cm"> * executed.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_execbuf_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @commands: User-space address of a command buffer cast to an uint64_t.</span>
<span class="cm"> * @command-size: Size in bytes of the command buffer.</span>
<span class="cm"> * @throttle-us: Sleep until software is less than @throttle_us</span>
<span class="cm"> * microseconds ahead of hardware. The driver may round this value</span>
<span class="cm"> * to the nearest kernel tick.</span>
<span class="cm"> * @fence_rep: User-space address of a struct drm_vmw_fence_rep cast to an</span>
<span class="cm"> * uint64_t.</span>
<span class="cm"> * @version: Allows expanding the execbuf ioctl parameters without breaking</span>
<span class="cm"> * backwards compatibility, since user-space will always tell the kernel</span>
<span class="cm"> * which version it uses.</span>
<span class="cm"> * @flags: Execbuf flags. None currently.</span>
<span class="cm"> *</span>
<span class="cm"> * Argument to the DRM_VMW_EXECBUF Ioctl.</span>
<span class="cm"> */</span>

<span class="cp">#define DRM_VMW_EXECBUF_VERSION 1</span>

<span class="k">struct</span> <span class="n">drm_vmw_execbuf_arg</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">commands</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">command_size</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">throttle_us</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">fence_rep</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">version</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_fence_rep</span>
<span class="cm"> *</span>
<span class="cm"> * @handle: Fence object handle for fence associated with a command submission.</span>
<span class="cm"> * @mask: Fence flags relevant for this fence object.</span>
<span class="cm"> * @seqno: Fence sequence number in fifo. A fence object with a lower</span>
<span class="cm"> * seqno will signal the EXEC flag before a fence object with a higher</span>
<span class="cm"> * seqno. This can be used by user-space to avoid kernel calls to determine</span>
<span class="cm"> * whether a fence has signaled the EXEC flag. Note that @seqno will</span>
<span class="cm"> * wrap at 32-bit.</span>
<span class="cm"> * @passed_seqno: The highest seqno number processed by the hardware</span>
<span class="cm"> * so far. This can be used to mark user-space fence objects as signaled, and</span>
<span class="cm"> * to determine whether a fence seqno might be stale.</span>
<span class="cm"> * @error: This member should&#39;ve been set to -EFAULT on submission.</span>
<span class="cm"> * The following actions should be take on completion:</span>
<span class="cm"> * error == -EFAULT: Fence communication failed. The host is synchronized.</span>
<span class="cm"> * Use the last fence id read from the FIFO fence register.</span>
<span class="cm"> * error != 0 &amp;&amp; error != -EFAULT:</span>
<span class="cm"> * Fence submission failed. The host is synchronized. Use the fence_seq member.</span>
<span class="cm"> * error == 0: All is OK, The host may not be synchronized.</span>
<span class="cm"> * Use the fence_seq member.</span>
<span class="cm"> *</span>
<span class="cm"> * Input / Output data to the DRM_VMW_EXECBUF Ioctl.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_fence_rep</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">seqno</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">passed_seqno</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pad64</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">error</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_ALLOC_DMABUF</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate a DMA buffer that is visible also to the host.</span>
<span class="cm"> * NOTE: The buffer is</span>
<span class="cm"> * identified by a handle and an offset, which are private to the guest, but</span>
<span class="cm"> * useable in the command stream. The guest kernel may translate these</span>
<span class="cm"> * and patch up the command stream accordingly. In the future, the offset may</span>
<span class="cm"> * be zero at all times, or it may disappear from the interface before it is</span>
<span class="cm"> * fixed.</span>
<span class="cm"> *</span>
<span class="cm"> * The DMA buffer may stay user-space mapped in the guest at all times,</span>
<span class="cm"> * and is thus suitable for sub-allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * DMA buffers are mapped using the mmap() syscall on the drm device.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_alloc_dmabuf_req</span>
<span class="cm"> *</span>
<span class="cm"> * @size: Required minimum size of the buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Input data to the DRM_VMW_ALLOC_DMABUF Ioctl.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_alloc_dmabuf_req</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pad64</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_dmabuf_rep</span>
<span class="cm"> *</span>
<span class="cm"> * @map_handle: Offset to use in the mmap() call used to map the buffer.</span>
<span class="cm"> * @handle: Handle unique to this buffer. Used for unreferencing.</span>
<span class="cm"> * @cur_gmr_id: GMR id to use in the command stream when this buffer is</span>
<span class="cm"> * referenced. See not above.</span>
<span class="cm"> * @cur_gmr_offset: Offset to use in the command stream when this buffer is</span>
<span class="cm"> * referenced. See note above.</span>
<span class="cm"> *</span>
<span class="cm"> * Output data from the DRM_VMW_ALLOC_DMABUF Ioctl.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_dmabuf_rep</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">map_handle</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cur_gmr_id</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cur_gmr_offset</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pad64</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * union drm_vmw_dmabuf_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @req: Input data as described above.</span>
<span class="cm"> * @rep: Output data as described above.</span>
<span class="cm"> *</span>
<span class="cm"> * Argument to the DRM_VMW_ALLOC_DMABUF Ioctl.</span>
<span class="cm"> */</span>

<span class="k">union</span> <span class="n">drm_vmw_alloc_dmabuf_arg</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_vmw_alloc_dmabuf_req</span> <span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_vmw_dmabuf_rep</span> <span class="n">rep</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_UNREF_DMABUF - Free a DMA buffer.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_unref_dmabuf_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @handle: Handle indicating what buffer to free. Obtained from the</span>
<span class="cm"> * DRM_VMW_ALLOC_DMABUF Ioctl.</span>
<span class="cm"> *</span>
<span class="cm"> * Argument to the DRM_VMW_UNREF_DMABUF Ioctl.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_unref_dmabuf_arg</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pad64</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_CONTROL_STREAM - Control overlays, aka streams.</span>
<span class="cm"> *</span>
<span class="cm"> * This IOCTL controls the overlay units of the svga device.</span>
<span class="cm"> * The SVGA overlay units does not work like regular hardware units in</span>
<span class="cm"> * that they do not automaticaly read back the contents of the given dma</span>
<span class="cm"> * buffer. But instead only read back for each call to this ioctl, and</span>
<span class="cm"> * at any point between this call being made and a following call that</span>
<span class="cm"> * either changes the buffer or disables the stream.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_rect</span>
<span class="cm"> *</span>
<span class="cm"> * Defines a rectangle. Used in the overlay ioctl to define</span>
<span class="cm"> * source and destination rectangle.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_rect</span> <span class="p">{</span>
	<span class="kt">int32_t</span> <span class="n">x</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">y</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">w</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">h</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_control_stream_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @stream_id: Stearm to control</span>
<span class="cm"> * @enabled: If false all following arguments are ignored.</span>
<span class="cm"> * @handle: Handle to buffer for getting data from.</span>
<span class="cm"> * @format: Format of the overlay as understood by the host.</span>
<span class="cm"> * @width: Width of the overlay.</span>
<span class="cm"> * @height: Height of the overlay.</span>
<span class="cm"> * @size: Size of the overlay in bytes.</span>
<span class="cm"> * @pitch: Array of pitches, the two last are only used for YUV12 formats.</span>
<span class="cm"> * @offset: Offset from start of dma buffer to overlay.</span>
<span class="cm"> * @src: Source rect, must be within the defined area above.</span>
<span class="cm"> * @dst: Destination rect, x and y may be negative.</span>
<span class="cm"> *</span>
<span class="cm"> * Argument to the DRM_VMW_CONTROL_STREAM Ioctl.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_control_stream_arg</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">stream_id</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">enabled</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">color_key</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">format</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">width</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">height</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pitch</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="kt">uint32_t</span> <span class="n">pad64</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_vmw_rect</span> <span class="n">src</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_vmw_rect</span> <span class="n">dst</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_CURSOR_BYPASS - Give extra information about cursor bypass.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define DRM_VMW_CURSOR_BYPASS_ALL    (1 &lt;&lt; 0)</span>
<span class="cp">#define DRM_VMW_CURSOR_BYPASS_FLAGS       (1)</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_cursor_bypass_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @flags: Flags.</span>
<span class="cm"> * @crtc_id: Crtc id, only used if DMR_CURSOR_BYPASS_ALL isn&#39;t passed.</span>
<span class="cm"> * @xpos: X position of cursor.</span>
<span class="cm"> * @ypos: Y position of cursor.</span>
<span class="cm"> * @xhot: X hotspot.</span>
<span class="cm"> * @yhot: Y hotspot.</span>
<span class="cm"> *</span>
<span class="cm"> * Argument to the DRM_VMW_CURSOR_BYPASS Ioctl.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_cursor_bypass_arg</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crtc_id</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">xpos</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">ypos</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">xhot</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">yhot</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_CLAIM_STREAM - Claim a single stream.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_context_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @stream_id: Device unique context ID.</span>
<span class="cm"> *</span>
<span class="cm"> * Output argument to the DRM_VMW_CREATE_CONTEXT Ioctl.</span>
<span class="cm"> * Input argument to the DRM_VMW_UNREF_CONTEXT Ioctl.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_stream_arg</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">stream_id</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pad64</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_UNREF_STREAM - Unclaim a stream.</span>
<span class="cm"> *</span>
<span class="cm"> * Return a single stream that was claimed by this process. Also makes</span>
<span class="cm"> * sure that the stream has been stopped.</span>
<span class="cm"> */</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_GET_3D_CAP</span>
<span class="cm"> *</span>
<span class="cm"> * Read 3D capabilities from the FIFO</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_get_3d_cap_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @buffer: Pointer to a buffer for capability data, cast to an uint64_t</span>
<span class="cm"> * @size: Max size to copy</span>
<span class="cm"> *</span>
<span class="cm"> * Input argument to the DRM_VMW_GET_3D_CAP_IOCTL</span>
<span class="cm"> * ioctls.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_get_3d_cap_arg</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">max_size</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pad64</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_FENCE_WAIT</span>
<span class="cm"> *</span>
<span class="cm"> * Waits for a fence object to signal. The wait is interruptible, so that</span>
<span class="cm"> * signals may be delivered during the interrupt. The wait may timeout,</span>
<span class="cm"> * in which case the calls returns -EBUSY. If the wait is restarted,</span>
<span class="cm"> * that is restarting without resetting @cookie_valid to zero,</span>
<span class="cm"> * the timeout is computed from the first call.</span>
<span class="cm"> *</span>
<span class="cm"> * The flags argument to the DRM_VMW_FENCE_WAIT ioctl indicates what to wait</span>
<span class="cm"> * on:</span>
<span class="cm"> * DRM_VMW_FENCE_FLAG_EXEC: All commands ahead of the fence in the command</span>
<span class="cm"> * stream</span>
<span class="cm"> * have executed.</span>
<span class="cm"> * DRM_VMW_FENCE_FLAG_QUERY: All query results resulting from query finish</span>
<span class="cm"> * commands</span>
<span class="cm"> * in the buffer given to the EXECBUF ioctl returning the fence object handle</span>
<span class="cm"> * are available to user-space.</span>
<span class="cm"> *</span>
<span class="cm"> * DRM_VMW_WAIT_OPTION_UNREF: If this wait option is given, and the</span>
<span class="cm"> * fenc wait ioctl returns 0, the fence object has been unreferenced after</span>
<span class="cm"> * the wait.</span>
<span class="cm"> */</span>

<span class="cp">#define DRM_VMW_FENCE_FLAG_EXEC   (1 &lt;&lt; 0)</span>
<span class="cp">#define DRM_VMW_FENCE_FLAG_QUERY  (1 &lt;&lt; 1)</span>

<span class="cp">#define DRM_VMW_WAIT_OPTION_UNREF (1 &lt;&lt; 0)</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_fence_wait_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @handle: Fence object handle as returned by the DRM_VMW_EXECBUF ioctl.</span>
<span class="cm"> * @cookie_valid: Must be reset to 0 on first call. Left alone on restart.</span>
<span class="cm"> * @kernel_cookie: Set to 0 on first call. Left alone on restart.</span>
<span class="cm"> * @timeout_us: Wait timeout in microseconds. 0 for indefinite timeout.</span>
<span class="cm"> * @lazy: Set to 1 if timing is not critical. Allow more than a kernel tick</span>
<span class="cm"> * before returning.</span>
<span class="cm"> * @flags: Fence flags to wait on.</span>
<span class="cm"> * @wait_options: Options that control the behaviour of the wait ioctl.</span>
<span class="cm"> *</span>
<span class="cm"> * Input argument to the DRM_VMW_FENCE_WAIT ioctl.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_fence_wait_arg</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">;</span>
	<span class="kt">int32_t</span>  <span class="n">cookie_valid</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">kernel_cookie</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">timeout_us</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">lazy</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">wait_options</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">pad64</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_FENCE_SIGNALED</span>
<span class="cm"> *</span>
<span class="cm"> * Checks if a fence object is signaled..</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_fence_signaled_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @handle: Fence object handle as returned by the DRM_VMW_EXECBUF ioctl.</span>
<span class="cm"> * @flags: Fence object flags input to DRM_VMW_FENCE_SIGNALED ioctl</span>
<span class="cm"> * @signaled: Out: Flags signaled.</span>
<span class="cm"> * @sequence: Out: Highest sequence passed so far. Can be used to signal the</span>
<span class="cm"> * EXEC flag of user-space fence objects.</span>
<span class="cm"> *</span>
<span class="cm"> * Input/Output argument to the DRM_VMW_FENCE_SIGNALED and DRM_VMW_FENCE_UNREF</span>
<span class="cm"> * ioctls.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_fence_signaled_arg</span> <span class="p">{</span>
	 <span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">;</span>
	 <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
	 <span class="kt">int32_t</span> <span class="n">signaled</span><span class="p">;</span>
	 <span class="kt">uint32_t</span> <span class="n">passed_seqno</span><span class="p">;</span>
	 <span class="kt">uint32_t</span> <span class="n">signaled_flags</span><span class="p">;</span>
	 <span class="kt">uint32_t</span> <span class="n">pad64</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_FENCE_UNREF</span>
<span class="cm"> *</span>
<span class="cm"> * Unreferences a fence object, and causes it to be destroyed if there are no</span>
<span class="cm"> * other references to it.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_fence_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @handle: Fence object handle as returned by the DRM_VMW_EXECBUF ioctl.</span>
<span class="cm"> *</span>
<span class="cm"> * Input/Output argument to the DRM_VMW_FENCE_UNREF ioctl..</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_fence_arg</span> <span class="p">{</span>
	 <span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">;</span>
	 <span class="kt">uint32_t</span> <span class="n">pad64</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_FENCE_EVENT</span>
<span class="cm"> *</span>
<span class="cm"> * Queues an event on a fence to be delivered on the drm character device</span>
<span class="cm"> * when the fence has signaled the DRM_VMW_FENCE_FLAG_EXEC flag.</span>
<span class="cm"> * Optionally the approximate time when the fence signaled is</span>
<span class="cm"> * given by the event.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The event type</span>
<span class="cm"> */</span>
<span class="cp">#define DRM_VMW_EVENT_FENCE_SIGNALED 0x80000000</span>

<span class="k">struct</span> <span class="n">drm_vmw_event_fence</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_event</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">user_data</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">tv_sec</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">tv_usec</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Flags that may be given to the command.</span>
<span class="cm"> */</span>
<span class="cm">/* Request fence signaled time on the event. */</span>
<span class="cp">#define DRM_VMW_FE_FLAG_REQ_TIME (1 &lt;&lt; 0)</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_fence_event_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @fence_rep: Pointer to fence_rep structure cast to uint64_t or 0 if</span>
<span class="cm"> * the fence is not supposed to be referenced by user-space.</span>
<span class="cm"> * @user_info: Info to be delivered with the event.</span>
<span class="cm"> * @handle: Attach the event to this fence only.</span>
<span class="cm"> * @flags: A set of flags as defined above.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_vmw_fence_event_arg</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">fence_rep</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">user_data</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_PRESENT</span>
<span class="cm"> *</span>
<span class="cm"> * Executes an SVGA present on a given fb for a given surface. The surface</span>
<span class="cm"> * is placed on the framebuffer. Cliprects are given relative to the given</span>
<span class="cm"> * point (the point disignated by dest_{x|y}).</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_present_arg</span>
<span class="cm"> * @fb_id: framebuffer id to present / read back from.</span>
<span class="cm"> * @sid: Surface id to present from.</span>
<span class="cm"> * @dest_x: X placement coordinate for surface.</span>
<span class="cm"> * @dest_y: Y placement coordinate for surface.</span>
<span class="cm"> * @clips_ptr: Pointer to an array of clip rects cast to an uint64_t.</span>
<span class="cm"> * @num_clips: Number of cliprects given relative to the framebuffer origin,</span>
<span class="cm"> * in the same coordinate space as the frame buffer.</span>
<span class="cm"> * @pad64: Unused 64-bit padding.</span>
<span class="cm"> *</span>
<span class="cm"> * Input argument to the DRM_VMW_PRESENT ioctl.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_present_arg</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">fb_id</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">sid</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">dest_x</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">dest_y</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">clips_ptr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">num_clips</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pad64</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_PRESENT_READBACK</span>
<span class="cm"> *</span>
<span class="cm"> * Executes an SVGA present readback from a given fb to the dma buffer</span>
<span class="cm"> * currently bound as the fb. If there is no dma buffer bound to the fb,</span>
<span class="cm"> * an error will be returned.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_present_arg</span>
<span class="cm"> * @fb_id: fb_id to present / read back from.</span>
<span class="cm"> * @num_clips: Number of cliprects.</span>
<span class="cm"> * @clips_ptr: Pointer to an array of clip rects cast to an uint64_t.</span>
<span class="cm"> * @fence_rep: Pointer to a struct drm_vmw_fence_rep, cast to an uint64_t.</span>
<span class="cm"> * If this member is NULL, then the ioctl should not return a fence.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">drm_vmw_present_readback_arg</span> <span class="p">{</span>
	 <span class="kt">uint32_t</span> <span class="n">fb_id</span><span class="p">;</span>
	 <span class="kt">uint32_t</span> <span class="n">num_clips</span><span class="p">;</span>
	 <span class="kt">uint64_t</span> <span class="n">clips_ptr</span><span class="p">;</span>
	 <span class="kt">uint64_t</span> <span class="n">fence_rep</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm"> * DRM_VMW_UPDATE_LAYOUT - Update layout</span>
<span class="cm"> *</span>
<span class="cm"> * Updates the preferred modes and connection status for connectors. The</span>
<span class="cm"> * command consists of one drm_vmw_update_layout_arg pointing to an array</span>
<span class="cm"> * of num_outputs drm_vmw_rect&#39;s.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct drm_vmw_update_layout_arg</span>
<span class="cm"> *</span>
<span class="cm"> * @num_outputs: number of active connectors</span>
<span class="cm"> * @rects: pointer to array of drm_vmw_rect cast to an uint64_t</span>
<span class="cm"> *</span>
<span class="cm"> * Input argument to the DRM_VMW_UPDATE_LAYOUT Ioctl.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_vmw_update_layout_arg</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">num_outputs</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pad64</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">rects</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
