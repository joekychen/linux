<!DOCTYPE html>
<html><head><title>joekychen/linux » include › drm › mga_drm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>mga_drm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* mga_drm.h -- Public header for the Matrox g200/g400 driver -*- linux-c -*-</span>
<span class="cm"> * Created: Tue Jan 25 01:50:01 1999 by jhartmann@precisioninsight.com</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.</span>
<span class="cm"> * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="cm"> * to deal in the Software without restriction, including without limitation</span>
<span class="cm"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="cm"> * and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="cm"> * Software is furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice (including the next</span>
<span class="cm"> * paragraph) shall be included in all copies or substantial portions of the</span>
<span class="cm"> * Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span>
<span class="cm"> * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR</span>
<span class="cm"> * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,</span>
<span class="cm"> * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</span>
<span class="cm"> * OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:</span>
<span class="cm"> *    Jeff Hartmann &lt;jhartmann@valinux.com&gt;</span>
<span class="cm"> *    Keith Whitwell &lt;keith@tungstengraphics.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Rewritten by:</span>
<span class="cm"> *    Gareth Hughes &lt;gareth@valinux.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __MGA_DRM_H__</span>
<span class="cp">#define __MGA_DRM_H__</span>

<span class="cp">#include &quot;drm.h&quot;</span>

<span class="cm">/* WARNING: If you change any of these defines, make sure to change the</span>
<span class="cm"> * defines in the Xserver file (mga_sarea.h)</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __MGA_SAREA_DEFINES__</span>
<span class="cp">#define __MGA_SAREA_DEFINES__</span>

<span class="cm">/* WARP pipe flags</span>
<span class="cm"> */</span>
<span class="cp">#define MGA_F			0x1	</span><span class="cm">/* fog */</span><span class="cp"></span>
<span class="cp">#define MGA_A			0x2	</span><span class="cm">/* alpha */</span><span class="cp"></span>
<span class="cp">#define MGA_S			0x4	</span><span class="cm">/* specular */</span><span class="cp"></span>
<span class="cp">#define MGA_T2			0x8	</span><span class="cm">/* multitexture */</span><span class="cp"></span>

<span class="cp">#define MGA_WARP_TGZ		0</span>
<span class="cp">#define MGA_WARP_TGZF		(MGA_F)</span>
<span class="cp">#define MGA_WARP_TGZA		(MGA_A)</span>
<span class="cp">#define MGA_WARP_TGZAF		(MGA_F|MGA_A)</span>
<span class="cp">#define MGA_WARP_TGZS		(MGA_S)</span>
<span class="cp">#define MGA_WARP_TGZSF		(MGA_S|MGA_F)</span>
<span class="cp">#define MGA_WARP_TGZSA		(MGA_S|MGA_A)</span>
<span class="cp">#define MGA_WARP_TGZSAF		(MGA_S|MGA_F|MGA_A)</span>
<span class="cp">#define MGA_WARP_T2GZ		(MGA_T2)</span>
<span class="cp">#define MGA_WARP_T2GZF		(MGA_T2|MGA_F)</span>
<span class="cp">#define MGA_WARP_T2GZA		(MGA_T2|MGA_A)</span>
<span class="cp">#define MGA_WARP_T2GZAF		(MGA_T2|MGA_A|MGA_F)</span>
<span class="cp">#define MGA_WARP_T2GZS		(MGA_T2|MGA_S)</span>
<span class="cp">#define MGA_WARP_T2GZSF		(MGA_T2|MGA_S|MGA_F)</span>
<span class="cp">#define MGA_WARP_T2GZSA		(MGA_T2|MGA_S|MGA_A)</span>
<span class="cp">#define MGA_WARP_T2GZSAF	(MGA_T2|MGA_S|MGA_F|MGA_A)</span>

<span class="cp">#define MGA_MAX_G200_PIPES	8	</span><span class="cm">/* no multitex */</span><span class="cp"></span>
<span class="cp">#define MGA_MAX_G400_PIPES	16</span>
<span class="cp">#define MGA_MAX_WARP_PIPES	MGA_MAX_G400_PIPES</span>
<span class="cp">#define MGA_WARP_UCODE_SIZE	32768	</span><span class="cm">/* in bytes */</span><span class="cp"></span>

<span class="cp">#define MGA_CARD_TYPE_G200	1</span>
<span class="cp">#define MGA_CARD_TYPE_G400	2</span>
<span class="cp">#define MGA_CARD_TYPE_G450	3	</span><span class="cm">/* not currently used */</span><span class="cp"></span>
<span class="cp">#define MGA_CARD_TYPE_G550	4</span>

<span class="cp">#define MGA_FRONT		0x1</span>
<span class="cp">#define MGA_BACK		0x2</span>
<span class="cp">#define MGA_DEPTH		0x4</span>

<span class="cm">/* What needs to be changed for the current vertex dma buffer?</span>
<span class="cm"> */</span>
<span class="cp">#define MGA_UPLOAD_CONTEXT	0x1</span>
<span class="cp">#define MGA_UPLOAD_TEX0		0x2</span>
<span class="cp">#define MGA_UPLOAD_TEX1		0x4</span>
<span class="cp">#define MGA_UPLOAD_PIPE		0x8</span>
<span class="cp">#define MGA_UPLOAD_TEX0IMAGE	0x10	</span><span class="cm">/* handled client-side */</span><span class="cp"></span>
<span class="cp">#define MGA_UPLOAD_TEX1IMAGE	0x20	</span><span class="cm">/* handled client-side */</span><span class="cp"></span>
<span class="cp">#define MGA_UPLOAD_2D		0x40</span>
<span class="cp">#define MGA_WAIT_AGE		0x80	</span><span class="cm">/* handled client-side */</span><span class="cp"></span>
<span class="cp">#define MGA_UPLOAD_CLIPRECTS	0x100	</span><span class="cm">/* handled client-side */</span><span class="cp"></span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define MGA_DMA_FLUSH		0x200	/* set when someone gets the lock</span>
<span class="c">					   quiescent */</span>
<span class="cp">#endif</span>

<span class="cm">/* 32 buffers of 64k each, total 2 meg.</span>
<span class="cm"> */</span>
<span class="cp">#define MGA_BUFFER_SIZE		(1 &lt;&lt; 16)</span>
<span class="cp">#define MGA_NUM_BUFFERS		128</span>

<span class="cm">/* Keep these small for testing.</span>
<span class="cm"> */</span>
<span class="cp">#define MGA_NR_SAREA_CLIPRECTS	8</span>

<span class="cm">/* 2 heaps (1 for card, 1 for agp), each divided into up to 128</span>
<span class="cm"> * regions, subject to a minimum region size of (1&lt;&lt;16) == 64k.</span>
<span class="cm"> *</span>
<span class="cm"> * Clients may subdivide regions internally, but when sharing between</span>
<span class="cm"> * clients, the region size is the minimum granularity.</span>
<span class="cm"> */</span>

<span class="cp">#define MGA_CARD_HEAP			0</span>
<span class="cp">#define MGA_AGP_HEAP			1</span>
<span class="cp">#define MGA_NR_TEX_HEAPS		2</span>
<span class="cp">#define MGA_NR_TEX_REGIONS		16</span>
<span class="cp">#define MGA_LOG_MIN_TEX_REGION_SIZE	16</span>

<span class="cp">#define  DRM_MGA_IDLE_RETRY          2048</span>

<span class="cp">#endif				</span><span class="cm">/* __MGA_SAREA_DEFINES__ */</span><span class="cp"></span>

<span class="cm">/* Setup registers for 3D context</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dstorg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maccess</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plnwt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dwgctl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alphactrl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fogcolor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wflag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tdualstage0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tdualstage1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fcol</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stencil</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stencilctl</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_mga_context_regs_t</span><span class="p">;</span>

<span class="cm">/* Setup registers for 2D, X server</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pitch</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_mga_server_regs_t</span><span class="p">;</span>

<span class="cm">/* Setup registers for each texture unit</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texctl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texctl2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texfilter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texbordercol</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texorg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texwidth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texheight</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texorg1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texorg2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texorg3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texorg4</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_mga_texture_regs_t</span><span class="p">;</span>

<span class="cm">/* General aging mechanism</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head</span><span class="p">;</span>	<span class="cm">/* Position of head pointer          */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wrap</span><span class="p">;</span>	<span class="cm">/* Primary DMA wrap count            */</span>
<span class="p">}</span> <span class="n">drm_mga_age_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_drm_mga_sarea</span> <span class="p">{</span>
	<span class="cm">/* The channel for communication of state information to the kernel</span>
<span class="cm">	 * on firing a vertex dma buffer.</span>
<span class="cm">	 */</span>
	<span class="n">drm_mga_context_regs_t</span> <span class="n">context_state</span><span class="p">;</span>
	<span class="n">drm_mga_server_regs_t</span> <span class="n">server_state</span><span class="p">;</span>
	<span class="n">drm_mga_texture_regs_t</span> <span class="n">tex_state</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">warp_pipe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vertsize</span><span class="p">;</span>

	<span class="cm">/* The current cliprects, or a subset thereof.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">drm_clip_rect</span> <span class="n">boxes</span><span class="p">[</span><span class="n">MGA_NR_SAREA_CLIPRECTS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nbox</span><span class="p">;</span>

	<span class="cm">/* Information about the most recently used 3d drawable.  The</span>
<span class="cm">	 * client fills in the req_* fields, the server fills in the</span>
<span class="cm">	 * exported_ fields and puts the cliprects into boxes, above.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The client clears the exported_drawable field before</span>
<span class="cm">	 * clobbering the boxes data.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">req_drawable</span><span class="p">;</span>	<span class="cm">/* the X drawable id */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">req_draw_buffer</span><span class="p">;</span>	<span class="cm">/* MGA_FRONT or MGA_BACK */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">exported_drawable</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">exported_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">exported_stamp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">exported_buffers</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">exported_nfront</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">exported_nback</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">exported_back_x</span><span class="p">,</span> <span class="n">exported_front_x</span><span class="p">,</span> <span class="n">exported_w</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">exported_back_y</span><span class="p">,</span> <span class="n">exported_front_y</span><span class="p">,</span> <span class="n">exported_h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_clip_rect</span> <span class="n">exported_boxes</span><span class="p">[</span><span class="n">MGA_NR_SAREA_CLIPRECTS</span><span class="p">];</span>

	<span class="cm">/* Counters for aging textures and for client-side throttling.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_wrap</span><span class="p">;</span>

	<span class="n">drm_mga_age_t</span> <span class="n">last_frame</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_enqueue</span><span class="p">;</span>	<span class="cm">/* last time a buffer was enqueued */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_dispatch</span><span class="p">;</span>	<span class="cm">/* age of the most recently dispatched buffer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_quiescent</span><span class="p">;</span>	<span class="cm">/*  */</span>

	<span class="cm">/* LRU lists for texture memory in agp space and on the card.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">drm_tex_region</span> <span class="n">texList</span><span class="p">[</span><span class="n">MGA_NR_TEX_HEAPS</span><span class="p">][</span><span class="n">MGA_NR_TEX_REGIONS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texAge</span><span class="p">[</span><span class="n">MGA_NR_TEX_HEAPS</span><span class="p">];</span>

	<span class="cm">/* Mechanism to validate card state.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">ctxOwner</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_mga_sarea_t</span><span class="p">;</span>

<span class="cm">/* MGA specific ioctls</span>
<span class="cm"> * The device specific ioctl range is 0x40 to 0x79.</span>
<span class="cm"> */</span>
<span class="cp">#define DRM_MGA_INIT     0x00</span>
<span class="cp">#define DRM_MGA_FLUSH    0x01</span>
<span class="cp">#define DRM_MGA_RESET    0x02</span>
<span class="cp">#define DRM_MGA_SWAP     0x03</span>
<span class="cp">#define DRM_MGA_CLEAR    0x04</span>
<span class="cp">#define DRM_MGA_VERTEX   0x05</span>
<span class="cp">#define DRM_MGA_INDICES  0x06</span>
<span class="cp">#define DRM_MGA_ILOAD    0x07</span>
<span class="cp">#define DRM_MGA_BLIT     0x08</span>
<span class="cp">#define DRM_MGA_GETPARAM 0x09</span>

<span class="cm">/* 3.2:</span>
<span class="cm"> * ioctls for operating on fences.</span>
<span class="cm"> */</span>
<span class="cp">#define DRM_MGA_SET_FENCE      0x0a</span>
<span class="cp">#define DRM_MGA_WAIT_FENCE     0x0b</span>
<span class="cp">#define DRM_MGA_DMA_BOOTSTRAP  0x0c</span>

<span class="cp">#define DRM_IOCTL_MGA_INIT     DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_INIT, drm_mga_init_t)</span>
<span class="cp">#define DRM_IOCTL_MGA_FLUSH    DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_FLUSH, struct drm_lock)</span>
<span class="cp">#define DRM_IOCTL_MGA_RESET    DRM_IO(  DRM_COMMAND_BASE + DRM_MGA_RESET)</span>
<span class="cp">#define DRM_IOCTL_MGA_SWAP     DRM_IO(  DRM_COMMAND_BASE + DRM_MGA_SWAP)</span>
<span class="cp">#define DRM_IOCTL_MGA_CLEAR    DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_CLEAR, drm_mga_clear_t)</span>
<span class="cp">#define DRM_IOCTL_MGA_VERTEX   DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_VERTEX, drm_mga_vertex_t)</span>
<span class="cp">#define DRM_IOCTL_MGA_INDICES  DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_INDICES, drm_mga_indices_t)</span>
<span class="cp">#define DRM_IOCTL_MGA_ILOAD    DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_ILOAD, drm_mga_iload_t)</span>
<span class="cp">#define DRM_IOCTL_MGA_BLIT     DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_BLIT, drm_mga_blit_t)</span>
<span class="cp">#define DRM_IOCTL_MGA_GETPARAM DRM_IOWR(DRM_COMMAND_BASE + DRM_MGA_GETPARAM, drm_mga_getparam_t)</span>
<span class="cp">#define DRM_IOCTL_MGA_SET_FENCE     DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_SET_FENCE, __u32)</span>
<span class="cp">#define DRM_IOCTL_MGA_WAIT_FENCE    DRM_IOWR(DRM_COMMAND_BASE + DRM_MGA_WAIT_FENCE, __u32)</span>
<span class="cp">#define DRM_IOCTL_MGA_DMA_BOOTSTRAP DRM_IOWR(DRM_COMMAND_BASE + DRM_MGA_DMA_BOOTSTRAP, drm_mga_dma_bootstrap_t)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_drm_mga_warp_index</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">installed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_mga_warp_index_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_mga_init</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">MGA_INIT_DMA</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
		<span class="n">MGA_CLEANUP_DMA</span> <span class="o">=</span> <span class="mh">0x02</span>
	<span class="p">}</span> <span class="n">func</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sarea_priv_offset</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">chipset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sgram</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maccess</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fb_cpp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">front_offset</span><span class="p">,</span> <span class="n">front_pitch</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">back_offset</span><span class="p">,</span> <span class="n">back_pitch</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth_cpp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth_offset</span><span class="p">,</span> <span class="n">depth_pitch</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texture_offset</span><span class="p">[</span><span class="n">MGA_NR_TEX_HEAPS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texture_size</span><span class="p">[</span><span class="n">MGA_NR_TEX_HEAPS</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fb_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmio_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">warp_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">primary_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffers_offset</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_mga_init_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_mga_dma_bootstrap</span> <span class="p">{</span>
	<span class="cm">/**</span>
<span class="cm">	 * \name AGP texture region</span>
<span class="cm">	 *</span>
<span class="cm">	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, these fields will</span>
<span class="cm">	 * be filled in with the actual AGP texture settings.</span>
<span class="cm">	 *</span>
<span class="cm">	 * \warning</span>
<span class="cm">	 * If these fields are non-zero, but dma_mga_dma_bootstrap::agp_mode</span>
<span class="cm">	 * is zero, it means that PCI memory (most likely through the use of</span>
<span class="cm">	 * an IOMMU) is being used for &quot;AGP&quot; textures.</span>
<span class="cm">	 */</span>
	<span class="cm">/*@{ */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">texture_handle</span><span class="p">;</span> <span class="cm">/**&lt; Handle used to map AGP textures. */</span>
	<span class="n">__u32</span> <span class="n">texture_size</span><span class="p">;</span>	      <span class="cm">/**&lt; Size of the AGP texture region. */</span>
	<span class="cm">/*@} */</span>

	<span class="cm">/**</span>
<span class="cm">	 * Requested size of the primary DMA region.</span>
<span class="cm">	 *</span>
<span class="cm">	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be</span>
<span class="cm">	 * filled in with the actual AGP mode.  If AGP was not available</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">primary_size</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Requested number of secondary DMA buffers.</span>
<span class="cm">	 *</span>
<span class="cm">	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be</span>
<span class="cm">	 * filled in with the actual number of secondary DMA buffers</span>
<span class="cm">	 * allocated.  Particularly when PCI DMA is used, this may be</span>
<span class="cm">	 * (subtantially) less than the number requested.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">secondary_bin_count</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Requested size of each secondary DMA buffer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * While the kernel \b is free to reduce</span>
<span class="cm">	 * dma_mga_dma_bootstrap::secondary_bin_count, it is \b not allowed</span>
<span class="cm">	 * to reduce dma_mga_dma_bootstrap::secondary_bin_size.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">secondary_bin_size</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Bit-wise mask of AGPSTAT2_* values.  Currently only \c AGPSTAT2_1X,</span>
<span class="cm">	 * \c AGPSTAT2_2X, and \c AGPSTAT2_4X are supported.  If this value is</span>
<span class="cm">	 * zero, it means that PCI DMA should be used, even if AGP is</span>
<span class="cm">	 * possible.</span>
<span class="cm">	 *</span>
<span class="cm">	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be</span>
<span class="cm">	 * filled in with the actual AGP mode.  If AGP was not available</span>
<span class="cm">	 * (i.e., PCI DMA was used), this value will be zero.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">agp_mode</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Desired AGP GART size, measured in megabytes.</span>
<span class="cm">	 */</span>
	<span class="n">__u8</span> <span class="n">agp_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_mga_dma_bootstrap_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_mga_clear</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clear_color</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clear_depth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">color_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth_mask</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_mga_clear_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_mga_vertex</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>		<span class="cm">/* buffer to queue */</span>
	<span class="kt">int</span> <span class="n">used</span><span class="p">;</span>		<span class="cm">/* bytes in use */</span>
	<span class="kt">int</span> <span class="n">discard</span><span class="p">;</span>		<span class="cm">/* client finished with buffer?  */</span>
<span class="p">}</span> <span class="n">drm_mga_vertex_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_mga_indices</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>		<span class="cm">/* buffer to queue */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">discard</span><span class="p">;</span>		<span class="cm">/* client finished with buffer?  */</span>
<span class="p">}</span> <span class="n">drm_mga_indices_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_mga_iload</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dstorg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_mga_iload_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_drm_mga_blit</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">planemask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">srcorg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dstorg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">src_pitch</span><span class="p">,</span> <span class="n">dst_pitch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">delta_sx</span><span class="p">,</span> <span class="n">delta_sy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">delta_dx</span><span class="p">,</span> <span class="n">delta_dy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="n">ydir</span><span class="p">;</span>	<span class="cm">/* flip image vertically */</span>
	<span class="kt">int</span> <span class="n">source_pitch</span><span class="p">,</span> <span class="n">dest_pitch</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_mga_blit_t</span><span class="p">;</span>

<span class="cm">/* 3.1: An ioctl to get parameters that aren&#39;t available to the 3d</span>
<span class="cm"> * client any other way.</span>
<span class="cm"> */</span>
<span class="cp">#define MGA_PARAM_IRQ_NR            1</span>

<span class="cm">/* 3.2: Query the actual card type.  The DDX only distinguishes between</span>
<span class="cm"> * G200 chips and non-G200 chips, which it calls G400.  It turns out that</span>
<span class="cm"> * there are some very sublte differences between the G4x0 chips and the G550</span>
<span class="cm"> * chips.  Using this parameter query, a client-side driver can detect the</span>
<span class="cm"> * difference between a G4x0 and a G550.</span>
<span class="cm"> */</span>
<span class="cp">#define MGA_PARAM_CARD_TYPE         2</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_mga_getparam</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">param</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_mga_getparam_t</span><span class="p">;</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
