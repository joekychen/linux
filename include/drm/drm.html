<!DOCTYPE html>
<html><head><title>joekychen/linux » include › drm › drm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>drm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * \file drm.h</span>
<span class="cm"> * Header for the Direct Rendering Manager</span>
<span class="cm"> *</span>
<span class="cm"> * \author Rickard E. (Rik) Faith &lt;faith@valinux.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * \par Acknowledgments:</span>
<span class="cm"> * Dec 1999, Richard Henderson &lt;rth@twiddle.net&gt;, move to generic \c cmpxchg.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.</span>
<span class="cm"> * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="cm"> * to deal in the Software without restriction, including without limitation</span>
<span class="cm"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="cm"> * and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="cm"> * Software is furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice (including the next</span>
<span class="cm"> * paragraph) shall be included in all copies or substantial portions of the</span>
<span class="cm"> * Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span>
<span class="cm"> * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR</span>
<span class="cm"> * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,</span>
<span class="cm"> * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</span>
<span class="cm"> * OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _DRM_H_</span>
<span class="cp">#define _DRM_H_</span>

<span class="cp">#if defined(__linux__)</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;asm/ioctl.h&gt;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drm_handle_t</span><span class="p">;</span>

<span class="cp">#else </span><span class="cm">/* One of the BSDs */</span><span class="cp"></span>

<span class="cp">#include &lt;sys/ioccom.h&gt;</span>
<span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="k">typedef</span> <span class="kt">int8_t</span>   <span class="n">__s8</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">uint8_t</span>  <span class="n">__u8</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int16_t</span>  <span class="n">__s16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">uint16_t</span> <span class="n">__u16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int32_t</span>  <span class="n">__s32</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">__u32</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int64_t</span>  <span class="n">__s64</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">uint64_t</span> <span class="n">__u64</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">drm_handle_t</span><span class="p">;</span>

<span class="cp">#endif</span>

<span class="cp">#define DRM_NAME	&quot;drm&quot;	  </span><span class="cm">/**&lt; Name in kernel, /dev, and /proc */</span><span class="cp"></span>
<span class="cp">#define DRM_MIN_ORDER	5	  </span><span class="cm">/**&lt; At least 2^5 bytes = 32 bytes */</span><span class="cp"></span>
<span class="cp">#define DRM_MAX_ORDER	22	  </span><span class="cm">/**&lt; Up to 2^22 bytes = 4MB */</span><span class="cp"></span>
<span class="cp">#define DRM_RAM_PERCENT 10	  </span><span class="cm">/**&lt; How much system ram can we lock? */</span><span class="cp"></span>

<span class="cp">#define _DRM_LOCK_HELD	0x80000000U </span><span class="cm">/**&lt; Hardware lock is held */</span><span class="cp"></span>
<span class="cp">#define _DRM_LOCK_CONT	0x40000000U </span><span class="cm">/**&lt; Hardware lock is contended */</span><span class="cp"></span>
<span class="cp">#define _DRM_LOCK_IS_HELD(lock)	   ((lock) &amp; _DRM_LOCK_HELD)</span>
<span class="cp">#define _DRM_LOCK_IS_CONT(lock)	   ((lock) &amp; _DRM_LOCK_CONT)</span>
<span class="cp">#define _DRM_LOCKING_CONTEXT(lock) ((lock) &amp; ~(_DRM_LOCK_HELD|_DRM_LOCK_CONT))</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drm_context_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drm_drawable_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drm_magic_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Cliprect.</span>
<span class="cm"> *</span>
<span class="cm"> * \warning: If you change this structure, make sure you change</span>
<span class="cm"> * XF86DRIClipRectRec in the server as well</span>
<span class="cm"> *</span>
<span class="cm"> * \note KW: Actually it&#39;s illegal to change either for</span>
<span class="cm"> * backwards-compatibility reasons.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_clip_rect</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">x1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">y1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">x2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">y2</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Drawable information.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_drawable_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_rects</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_clip_rect</span> <span class="o">*</span><span class="n">rects</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Texture region,</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_tex_region</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">prev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">in_use</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">padding</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Hardware lock.</span>
<span class="cm"> *</span>
<span class="cm"> * The lock structure is a simple cache-line aligned integer.  To avoid</span>
<span class="cm"> * processor bus contention on a multiprocessor system, there should not be any</span>
<span class="cm"> * other data stored in the same cache line.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_hw_lock</span> <span class="p">{</span>
	<span class="n">__volatile__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lock</span><span class="p">;</span>		<span class="cm">/**&lt; lock variable */</span>
	<span class="kt">char</span> <span class="n">padding</span><span class="p">[</span><span class="mi">60</span><span class="p">];</span>			<span class="cm">/**&lt; Pad to cache line */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_VERSION ioctl argument type.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drmGetVersion().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_version</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">version_major</span><span class="p">;</span>	  <span class="cm">/**&lt; Major version */</span>
	<span class="kt">int</span> <span class="n">version_minor</span><span class="p">;</span>	  <span class="cm">/**&lt; Minor version */</span>
	<span class="kt">int</span> <span class="n">version_patchlevel</span><span class="p">;</span>	  <span class="cm">/**&lt; Patch level */</span>
	<span class="kt">size_t</span> <span class="n">name_len</span><span class="p">;</span>	  <span class="cm">/**&lt; Length of name buffer */</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>	  <span class="cm">/**&lt; Name of driver */</span>
	<span class="kt">size_t</span> <span class="n">date_len</span><span class="p">;</span>	  <span class="cm">/**&lt; Length of date buffer */</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">date</span><span class="p">;</span>	  <span class="cm">/**&lt; User-space buffer to hold date */</span>
	<span class="kt">size_t</span> <span class="n">desc_len</span><span class="p">;</span>	  <span class="cm">/**&lt; Length of desc buffer */</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>	  <span class="cm">/**&lt; User-space buffer to hold desc */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_GET_UNIQUE ioctl argument type.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drmGetBusid() and drmSetBusId().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_unique</span> <span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">unique_len</span><span class="p">;</span>	  <span class="cm">/**&lt; Length of unique */</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">unique</span><span class="p">;</span>	  <span class="cm">/**&lt; Unique name for driver instantiation */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_list</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>		  <span class="cm">/**&lt; Length of user-space structures */</span>
	<span class="k">struct</span> <span class="n">drm_version</span> <span class="n">__user</span> <span class="o">*</span><span class="n">version</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_block</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">unused</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_CONTROL ioctl argument type.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drmCtlInstHandler() and drmCtlUninstHandler().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_control</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">DRM_ADD_COMMAND</span><span class="p">,</span>
		<span class="n">DRM_RM_COMMAND</span><span class="p">,</span>
		<span class="n">DRM_INST_HANDLER</span><span class="p">,</span>
		<span class="n">DRM_UNINST_HANDLER</span>
	<span class="p">}</span> <span class="n">func</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Type of memory to map.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">drm_map_type</span> <span class="p">{</span>
	<span class="n">_DRM_FRAME_BUFFER</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	  <span class="cm">/**&lt; WC (no caching), no core dump */</span>
	<span class="n">_DRM_REGISTERS</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	  <span class="cm">/**&lt; no caching, no core dump */</span>
	<span class="n">_DRM_SHM</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>		  <span class="cm">/**&lt; shared, cached */</span>
	<span class="n">_DRM_AGP</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>		  <span class="cm">/**&lt; AGP/GART */</span>
	<span class="n">_DRM_SCATTER_GATHER</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>  <span class="cm">/**&lt; Scatter/gather memory for PCI DMA */</span>
	<span class="n">_DRM_CONSISTENT</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>	  <span class="cm">/**&lt; Consistent memory for PCI DMA */</span>
	<span class="n">_DRM_GEM</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>		  <span class="cm">/**&lt; GEM object */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Memory mapping flags.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">drm_map_flags</span> <span class="p">{</span>
	<span class="n">_DRM_RESTRICTED</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>	     <span class="cm">/**&lt; Cannot be mapped to user-virtual */</span>
	<span class="n">_DRM_READ_ONLY</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">_DRM_LOCKED</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>	     <span class="cm">/**&lt; shared, cached, locked */</span>
	<span class="n">_DRM_KERNEL</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>	     <span class="cm">/**&lt; kernel requires access */</span>
	<span class="n">_DRM_WRITE_COMBINING</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span> <span class="cm">/**&lt; use write-combining if available */</span>
	<span class="n">_DRM_CONTAINS_LOCK</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>   <span class="cm">/**&lt; SHM page that contains lock */</span>
	<span class="n">_DRM_REMOVABLE</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>	     <span class="cm">/**&lt; Removable mapping */</span>
	<span class="n">_DRM_DRIVER</span> <span class="o">=</span> <span class="mh">0x80</span>	     <span class="cm">/**&lt; Managed by driver */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_ctx_priv_map</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctx_id</span><span class="p">;</span>	 <span class="cm">/**&lt; Context requesting private mapping */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>		 <span class="cm">/**&lt; Handle of map */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_GET_MAP, DRM_IOCTL_ADD_MAP and DRM_IOCTL_RM_MAP ioctls</span>
<span class="cm"> * argument type.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drmAddMap().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_map</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>	 <span class="cm">/**&lt; Requested physical address (0 for SAREA)*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>	 <span class="cm">/**&lt; Requested physical size (bytes) */</span>
	<span class="k">enum</span> <span class="n">drm_map_type</span> <span class="n">type</span><span class="p">;</span>	 <span class="cm">/**&lt; Type of memory to map */</span>
	<span class="k">enum</span> <span class="n">drm_map_flags</span> <span class="n">flags</span><span class="p">;</span>	 <span class="cm">/**&lt; Flags */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>		 <span class="cm">/**&lt; User-space: &quot;Handle&quot; to pass to mmap() */</span>
				 <span class="cm">/**&lt; Kernel-space: kernel-virtual address */</span>
	<span class="kt">int</span> <span class="n">mtrr</span><span class="p">;</span>		 <span class="cm">/**&lt; MTRR slot used */</span>
	<span class="cm">/*   Private data */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_GET_CLIENT ioctl argument type.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_client</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>		<span class="cm">/**&lt; Which client desired? */</span>
	<span class="kt">int</span> <span class="n">auth</span><span class="p">;</span>		<span class="cm">/**&lt; Is client authenticated? */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pid</span><span class="p">;</span>	<span class="cm">/**&lt; Process ID */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uid</span><span class="p">;</span>	<span class="cm">/**&lt; User ID */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">magic</span><span class="p">;</span>	<span class="cm">/**&lt; Magic */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iocs</span><span class="p">;</span>	<span class="cm">/**&lt; Ioctl count */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">drm_stat_type</span> <span class="p">{</span>
	<span class="n">_DRM_STAT_LOCK</span><span class="p">,</span>
	<span class="n">_DRM_STAT_OPENS</span><span class="p">,</span>
	<span class="n">_DRM_STAT_CLOSES</span><span class="p">,</span>
	<span class="n">_DRM_STAT_IOCTLS</span><span class="p">,</span>
	<span class="n">_DRM_STAT_LOCKS</span><span class="p">,</span>
	<span class="n">_DRM_STAT_UNLOCKS</span><span class="p">,</span>
	<span class="n">_DRM_STAT_VALUE</span><span class="p">,</span>	<span class="cm">/**&lt; Generic value */</span>
	<span class="n">_DRM_STAT_BYTE</span><span class="p">,</span>		<span class="cm">/**&lt; Generic byte counter (1024bytes/K) */</span>
	<span class="n">_DRM_STAT_COUNT</span><span class="p">,</span>	<span class="cm">/**&lt; Generic non-byte counter (1000/k) */</span>

	<span class="n">_DRM_STAT_IRQ</span><span class="p">,</span>		<span class="cm">/**&lt; IRQ */</span>
	<span class="n">_DRM_STAT_PRIMARY</span><span class="p">,</span>	<span class="cm">/**&lt; Primary DMA bytes */</span>
	<span class="n">_DRM_STAT_SECONDARY</span><span class="p">,</span>	<span class="cm">/**&lt; Secondary DMA bytes */</span>
	<span class="n">_DRM_STAT_DMA</span><span class="p">,</span>		<span class="cm">/**&lt; DMA */</span>
	<span class="n">_DRM_STAT_SPECIAL</span><span class="p">,</span>	<span class="cm">/**&lt; Special DMA (e.g., priority or polled) */</span>
	<span class="n">_DRM_STAT_MISSED</span>	<span class="cm">/**&lt; Missed DMA opportunity */</span>
	    <span class="cm">/* Add to the *END* of the list */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_GET_STATS ioctl argument type.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_stats</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">;</span>
		<span class="k">enum</span> <span class="n">drm_stat_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">data</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Hardware locking flags.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">drm_lock_flags</span> <span class="p">{</span>
	<span class="n">_DRM_LOCK_READY</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>	     <span class="cm">/**&lt; Wait until hardware is ready for DMA */</span>
	<span class="n">_DRM_LOCK_QUIESCENT</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>  <span class="cm">/**&lt; Wait until hardware quiescent */</span>
	<span class="n">_DRM_LOCK_FLUSH</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>	     <span class="cm">/**&lt; Flush this context&#39;s DMA queue first */</span>
	<span class="n">_DRM_LOCK_FLUSH_ALL</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>  <span class="cm">/**&lt; Flush all DMA queues first */</span>
	<span class="cm">/* These *HALT* flags aren&#39;t supported yet</span>
<span class="cm">	   -- they will be used to support the</span>
<span class="cm">	   full-screen DGA-like mode. */</span>
	<span class="n">_DRM_HALT_ALL_QUEUES</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span> <span class="cm">/**&lt; Halt all current and future queues */</span>
	<span class="n">_DRM_HALT_CUR_QUEUES</span> <span class="o">=</span> <span class="mh">0x20</span>  <span class="cm">/**&lt; Halt all current queues */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_LOCK, DRM_IOCTL_UNLOCK and DRM_IOCTL_FINISH ioctl argument type.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drmGetLock() and drmUnlock().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_lock</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">drm_lock_flags</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DMA flags</span>
<span class="cm"> *</span>
<span class="cm"> * \warning</span>
<span class="cm"> * These values \e must match xf86drm.h.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drm_dma.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">drm_dma_flags</span> <span class="p">{</span>
	<span class="cm">/* Flags for DMA buffer dispatch */</span>
	<span class="n">_DRM_DMA_BLOCK</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>	      <span class="cm">/**&lt;</span>
<span class="cm">				       * Block until buffer dispatched.</span>
<span class="cm">				       *</span>
<span class="cm">				       * \note The buffer may not yet have</span>
<span class="cm">				       * been processed by the hardware --</span>
<span class="cm">				       * getting a hardware lock with the</span>
<span class="cm">				       * hardware quiescent will ensure</span>
<span class="cm">				       * that the buffer has been</span>
<span class="cm">				       * processed.</span>
<span class="cm">				       */</span>
	<span class="n">_DRM_DMA_WHILE_LOCKED</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span> <span class="cm">/**&lt; Dispatch while lock held */</span>
	<span class="n">_DRM_DMA_PRIORITY</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>     <span class="cm">/**&lt; High priority dispatch */</span>

	<span class="cm">/* Flags for DMA buffer request */</span>
	<span class="n">_DRM_DMA_WAIT</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>	      <span class="cm">/**&lt; Wait for free buffers */</span>
	<span class="n">_DRM_DMA_SMALLER_OK</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>   <span class="cm">/**&lt; Smaller-than-requested buffers OK */</span>
	<span class="n">_DRM_DMA_LARGER_OK</span> <span class="o">=</span> <span class="mh">0x40</span>     <span class="cm">/**&lt; Larger-than-requested buffers OK */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_ADD_BUFS and DRM_IOCTL_MARK_BUFS ioctl argument type.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drmAddBufs().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_buf_desc</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>		 <span class="cm">/**&lt; Number of buffers of this size */</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>		 <span class="cm">/**&lt; Size in bytes */</span>
	<span class="kt">int</span> <span class="n">low_mark</span><span class="p">;</span>		 <span class="cm">/**&lt; Low water mark */</span>
	<span class="kt">int</span> <span class="n">high_mark</span><span class="p">;</span>		 <span class="cm">/**&lt; High water mark */</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">_DRM_PAGE_ALIGN</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>	<span class="cm">/**&lt; Align on page boundaries for DMA */</span>
		<span class="n">_DRM_AGP_BUFFER</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>	<span class="cm">/**&lt; Buffer is in AGP space */</span>
		<span class="n">_DRM_SG_BUFFER</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>	<span class="cm">/**&lt; Scatter/gather memory buffer */</span>
		<span class="n">_DRM_FB_BUFFER</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>	<span class="cm">/**&lt; Buffer is in frame buffer */</span>
		<span class="n">_DRM_PCI_BUFFER_RO</span> <span class="o">=</span> <span class="mh">0x10</span> <span class="cm">/**&lt; Map PCI DMA buffer read-only */</span>
	<span class="p">}</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">agp_start</span><span class="p">;</span> <span class="cm">/**&lt;</span>
<span class="cm">				  * Start address of where the AGP buffers are</span>
<span class="cm">				  * in the AGP aperture</span>
<span class="cm">				  */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_INFO_BUFS ioctl argument type.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_buf_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>		<span class="cm">/**&lt; Entries in list */</span>
	<span class="k">struct</span> <span class="n">drm_buf_desc</span> <span class="n">__user</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_FREE_BUFS ioctl argument type.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_buf_free</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Buffer information</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drm_buf_map.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_buf_pub</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>		       <span class="cm">/**&lt; Index into the master buffer list */</span>
	<span class="kt">int</span> <span class="n">total</span><span class="p">;</span>		       <span class="cm">/**&lt; Buffer size */</span>
	<span class="kt">int</span> <span class="n">used</span><span class="p">;</span>		       <span class="cm">/**&lt; Amount of buffer in use (for DMA) */</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">address</span><span class="p">;</span>	       <span class="cm">/**&lt; Address of buffer */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_MAP_BUFS ioctl argument type.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_buf_map</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>		<span class="cm">/**&lt; Length of the buffer list */</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="k">virtual</span><span class="p">;</span>		<span class="cm">/**&lt; Mmap&#39;d area in user-virtual */</span>
	<span class="k">struct</span> <span class="n">drm_buf_pub</span> <span class="n">__user</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>	<span class="cm">/**&lt; Buffer information */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_DMA ioctl argument type.</span>
<span class="cm"> *</span>
<span class="cm"> * Indices here refer to the offset into the buffer list in drm_buf_get.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drmDMA().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_dma</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">context</span><span class="p">;</span>			  <span class="cm">/**&lt; Context handle */</span>
	<span class="kt">int</span> <span class="n">send_count</span><span class="p">;</span>			  <span class="cm">/**&lt; Number of buffers to send */</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">send_indices</span><span class="p">;</span>	  <span class="cm">/**&lt; List of handles to buffers */</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">send_sizes</span><span class="p">;</span>		  <span class="cm">/**&lt; Lengths of data to send */</span>
	<span class="k">enum</span> <span class="n">drm_dma_flags</span> <span class="n">flags</span><span class="p">;</span>	  <span class="cm">/**&lt; Flags */</span>
	<span class="kt">int</span> <span class="n">request_count</span><span class="p">;</span>		  <span class="cm">/**&lt; Number of buffers requested */</span>
	<span class="kt">int</span> <span class="n">request_size</span><span class="p">;</span>		  <span class="cm">/**&lt; Desired size for buffers */</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">request_indices</span><span class="p">;</span>	  <span class="cm">/**&lt; Buffer information */</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">request_sizes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">granted_count</span><span class="p">;</span>		  <span class="cm">/**&lt; Number of buffers granted */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">drm_ctx_flags</span> <span class="p">{</span>
	<span class="n">_DRM_CONTEXT_PRESERVED</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">_DRM_CONTEXT_2DONLY</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_ADD_CTX ioctl argument type.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drmCreateContext() and drmDestroyContext().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_ctx</span> <span class="p">{</span>
	<span class="n">drm_context_t</span> <span class="n">handle</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">drm_ctx_flags</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_RES_CTX ioctl argument type.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_ctx_res</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_ctx</span> <span class="n">__user</span> <span class="o">*</span><span class="n">contexts</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_ADD_DRAW and DRM_IOCTL_RM_DRAW ioctl argument type.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_draw</span> <span class="p">{</span>
	<span class="n">drm_drawable_t</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_UPDATE_DRAW ioctl argument type.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">DRM_DRAWABLE_CLIPRECTS</span><span class="p">,</span>
<span class="p">}</span> <span class="n">drm_drawable_info_type_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">drm_update_draw</span> <span class="p">{</span>
	<span class="n">drm_drawable_t</span> <span class="n">handle</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_GET_MAGIC and DRM_IOCTL_AUTH_MAGIC ioctl argument type.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_auth</span> <span class="p">{</span>
	<span class="n">drm_magic_t</span> <span class="n">magic</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_IRQ_BUSID ioctl argument type.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drmGetInterruptFromBusID().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_irq_busid</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>	<span class="cm">/**&lt; IRQ number */</span>
	<span class="kt">int</span> <span class="n">busnum</span><span class="p">;</span>	<span class="cm">/**&lt; bus number */</span>
	<span class="kt">int</span> <span class="n">devnum</span><span class="p">;</span>	<span class="cm">/**&lt; device number */</span>
	<span class="kt">int</span> <span class="n">funcnum</span><span class="p">;</span>	<span class="cm">/**&lt; function number */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">drm_vblank_seq_type</span> <span class="p">{</span>
	<span class="n">_DRM_VBLANK_ABSOLUTE</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>	<span class="cm">/**&lt; Wait for specific vblank sequence number */</span>
	<span class="n">_DRM_VBLANK_RELATIVE</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>	<span class="cm">/**&lt; Wait for given number of vblanks */</span>
	<span class="cm">/* bits 1-6 are reserved for high crtcs */</span>
	<span class="n">_DRM_VBLANK_HIGH_CRTC_MASK</span> <span class="o">=</span> <span class="mh">0x0000003e</span><span class="p">,</span>
	<span class="n">_DRM_VBLANK_EVENT</span> <span class="o">=</span> <span class="mh">0x4000000</span><span class="p">,</span>   <span class="cm">/**&lt; Send event instead of blocking */</span>
	<span class="n">_DRM_VBLANK_FLIP</span> <span class="o">=</span> <span class="mh">0x8000000</span><span class="p">,</span>   <span class="cm">/**&lt; Scheduled buffer swap should flip */</span>
	<span class="n">_DRM_VBLANK_NEXTONMISS</span> <span class="o">=</span> <span class="mh">0x10000000</span><span class="p">,</span>	<span class="cm">/**&lt; If missed, wait for next vblank */</span>
	<span class="n">_DRM_VBLANK_SECONDARY</span> <span class="o">=</span> <span class="mh">0x20000000</span><span class="p">,</span>	<span class="cm">/**&lt; Secondary display controller */</span>
	<span class="n">_DRM_VBLANK_SIGNAL</span> <span class="o">=</span> <span class="mh">0x40000000</span>	<span class="cm">/**&lt; Send signal instead of blocking, unsupported */</span>
<span class="p">};</span>
<span class="cp">#define _DRM_VBLANK_HIGH_CRTC_SHIFT 1</span>

<span class="cp">#define _DRM_VBLANK_TYPES_MASK (_DRM_VBLANK_ABSOLUTE | _DRM_VBLANK_RELATIVE)</span>
<span class="cp">#define _DRM_VBLANK_FLAGS_MASK (_DRM_VBLANK_EVENT | _DRM_VBLANK_SIGNAL | \</span>
<span class="cp">				_DRM_VBLANK_SECONDARY | _DRM_VBLANK_NEXTONMISS)</span>

<span class="k">struct</span> <span class="n">drm_wait_vblank_request</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">drm_vblank_seq_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sequence</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">signal</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_wait_vblank_reply</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">drm_vblank_seq_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sequence</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">tval_sec</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">tval_usec</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_WAIT_VBLANK ioctl argument type.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drmWaitVBlank().</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">drm_wait_vblank</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_wait_vblank_request</span> <span class="n">request</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_wait_vblank_reply</span> <span class="n">reply</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define _DRM_PRE_MODESET 1</span>
<span class="cp">#define _DRM_POST_MODESET 2</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_MODESET_CTL ioctl argument type</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drmModesetCtl().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_modeset_ctl</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">crtc</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_AGP_ENABLE ioctl argument type.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drmAgpEnable().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_agp_mode</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mode</span><span class="p">;</span>	<span class="cm">/**&lt; AGP mode */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_AGP_ALLOC and DRM_IOCTL_AGP_FREE ioctls argument type.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drmAgpAlloc() and drmAgpFree().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_agp_buffer</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>	<span class="cm">/**&lt; In bytes -- will round to page boundary */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">handle</span><span class="p">;</span>	<span class="cm">/**&lt; Used for binding / unbinding */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/**&lt; Type of memory to allocate */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">physical</span><span class="p">;</span>	<span class="cm">/**&lt; Physical used by i810 */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_AGP_BIND and DRM_IOCTL_AGP_UNBIND ioctls argument type.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drmAgpBind() and drmAgpUnbind().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_agp_binding</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">handle</span><span class="p">;</span>	<span class="cm">/**&lt; From drm_agp_buffer */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>	<span class="cm">/**&lt; In bytes -- will round to page boundary */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_AGP_INFO ioctl argument type.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drmAgpVersionMajor(), drmAgpVersionMinor(), drmAgpGetMode(),</span>
<span class="cm"> * drmAgpBase(), drmAgpSize(), drmAgpMemoryUsed(), drmAgpMemoryAvail(),</span>
<span class="cm"> * drmAgpVendorId() and drmAgpDeviceId().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_agp_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">agp_version_major</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">agp_version_minor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">aperture_base</span><span class="p">;</span>	<span class="cm">/* physical address */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">aperture_size</span><span class="p">;</span>	<span class="cm">/* bytes */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">memory_allowed</span><span class="p">;</span>	<span class="cm">/* bytes */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">memory_used</span><span class="p">;</span>

	<span class="cm">/* PCI information */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">id_vendor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">id_device</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_SG_ALLOC ioctl argument type.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_scatter_gather</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>	<span class="cm">/**&lt; In bytes -- will round to page boundary */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">handle</span><span class="p">;</span>	<span class="cm">/**&lt; Used for mapping / unmapping */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM_IOCTL_SET_VERSION ioctl argument type.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_set_version</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">drm_di_major</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drm_di_minor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drm_dd_major</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drm_dd_minor</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** DRM_IOCTL_GEM_CLOSE ioctl argument type */</span>
<span class="k">struct</span> <span class="n">drm_gem_close</span> <span class="p">{</span>
	<span class="cm">/** Handle of the object to be closed. */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** DRM_IOCTL_GEM_FLINK ioctl argument type */</span>
<span class="k">struct</span> <span class="n">drm_gem_flink</span> <span class="p">{</span>
	<span class="cm">/** Handle for the object being named */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>

	<span class="cm">/** Returned global name */</span>
	<span class="n">__u32</span> <span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** DRM_IOCTL_GEM_OPEN ioctl argument type */</span>
<span class="k">struct</span> <span class="n">drm_gem_open</span> <span class="p">{</span>
	<span class="cm">/** Name of object being opened */</span>
	<span class="n">__u32</span> <span class="n">name</span><span class="p">;</span>

	<span class="cm">/** Returned handle for the object */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>

	<span class="cm">/** Returned size of the object */</span>
	<span class="n">__u64</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** DRM_IOCTL_GET_CAP ioctl argument type */</span>
<span class="k">struct</span> <span class="n">drm_get_cap</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">capability</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DRM_CLOEXEC O_CLOEXEC</span>
<span class="k">struct</span> <span class="n">drm_prime_handle</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>

	<span class="cm">/** Flags.. only applicable for handle-&gt;fd */</span>
	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/** Returned dmabuf file descriptor */</span>
	<span class="n">__s32</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#include &quot;drm_mode.h&quot;</span>

<span class="cp">#define DRM_IOCTL_BASE			&#39;d&#39;</span>
<span class="cp">#define DRM_IO(nr)			_IO(DRM_IOCTL_BASE,nr)</span>
<span class="cp">#define DRM_IOR(nr,type)		_IOR(DRM_IOCTL_BASE,nr,type)</span>
<span class="cp">#define DRM_IOW(nr,type)		_IOW(DRM_IOCTL_BASE,nr,type)</span>
<span class="cp">#define DRM_IOWR(nr,type)		_IOWR(DRM_IOCTL_BASE,nr,type)</span>

<span class="cp">#define DRM_IOCTL_VERSION		DRM_IOWR(0x00, struct drm_version)</span>
<span class="cp">#define DRM_IOCTL_GET_UNIQUE		DRM_IOWR(0x01, struct drm_unique)</span>
<span class="cp">#define DRM_IOCTL_GET_MAGIC		DRM_IOR( 0x02, struct drm_auth)</span>
<span class="cp">#define DRM_IOCTL_IRQ_BUSID		DRM_IOWR(0x03, struct drm_irq_busid)</span>
<span class="cp">#define DRM_IOCTL_GET_MAP               DRM_IOWR(0x04, struct drm_map)</span>
<span class="cp">#define DRM_IOCTL_GET_CLIENT            DRM_IOWR(0x05, struct drm_client)</span>
<span class="cp">#define DRM_IOCTL_GET_STATS             DRM_IOR( 0x06, struct drm_stats)</span>
<span class="cp">#define DRM_IOCTL_SET_VERSION		DRM_IOWR(0x07, struct drm_set_version)</span>
<span class="cp">#define DRM_IOCTL_MODESET_CTL           DRM_IOW(0x08, struct drm_modeset_ctl)</span>
<span class="cp">#define DRM_IOCTL_GEM_CLOSE		DRM_IOW (0x09, struct drm_gem_close)</span>
<span class="cp">#define DRM_IOCTL_GEM_FLINK		DRM_IOWR(0x0a, struct drm_gem_flink)</span>
<span class="cp">#define DRM_IOCTL_GEM_OPEN		DRM_IOWR(0x0b, struct drm_gem_open)</span>
<span class="cp">#define DRM_IOCTL_GET_CAP		DRM_IOWR(0x0c, struct drm_get_cap)</span>

<span class="cp">#define DRM_IOCTL_SET_UNIQUE		DRM_IOW( 0x10, struct drm_unique)</span>
<span class="cp">#define DRM_IOCTL_AUTH_MAGIC		DRM_IOW( 0x11, struct drm_auth)</span>
<span class="cp">#define DRM_IOCTL_BLOCK			DRM_IOWR(0x12, struct drm_block)</span>
<span class="cp">#define DRM_IOCTL_UNBLOCK		DRM_IOWR(0x13, struct drm_block)</span>
<span class="cp">#define DRM_IOCTL_CONTROL		DRM_IOW( 0x14, struct drm_control)</span>
<span class="cp">#define DRM_IOCTL_ADD_MAP		DRM_IOWR(0x15, struct drm_map)</span>
<span class="cp">#define DRM_IOCTL_ADD_BUFS		DRM_IOWR(0x16, struct drm_buf_desc)</span>
<span class="cp">#define DRM_IOCTL_MARK_BUFS		DRM_IOW( 0x17, struct drm_buf_desc)</span>
<span class="cp">#define DRM_IOCTL_INFO_BUFS		DRM_IOWR(0x18, struct drm_buf_info)</span>
<span class="cp">#define DRM_IOCTL_MAP_BUFS		DRM_IOWR(0x19, struct drm_buf_map)</span>
<span class="cp">#define DRM_IOCTL_FREE_BUFS		DRM_IOW( 0x1a, struct drm_buf_free)</span>

<span class="cp">#define DRM_IOCTL_RM_MAP		DRM_IOW( 0x1b, struct drm_map)</span>

<span class="cp">#define DRM_IOCTL_SET_SAREA_CTX		DRM_IOW( 0x1c, struct drm_ctx_priv_map)</span>
<span class="cp">#define DRM_IOCTL_GET_SAREA_CTX 	DRM_IOWR(0x1d, struct drm_ctx_priv_map)</span>

<span class="cp">#define DRM_IOCTL_SET_MASTER            DRM_IO(0x1e)</span>
<span class="cp">#define DRM_IOCTL_DROP_MASTER           DRM_IO(0x1f)</span>

<span class="cp">#define DRM_IOCTL_ADD_CTX		DRM_IOWR(0x20, struct drm_ctx)</span>
<span class="cp">#define DRM_IOCTL_RM_CTX		DRM_IOWR(0x21, struct drm_ctx)</span>
<span class="cp">#define DRM_IOCTL_MOD_CTX		DRM_IOW( 0x22, struct drm_ctx)</span>
<span class="cp">#define DRM_IOCTL_GET_CTX		DRM_IOWR(0x23, struct drm_ctx)</span>
<span class="cp">#define DRM_IOCTL_SWITCH_CTX		DRM_IOW( 0x24, struct drm_ctx)</span>
<span class="cp">#define DRM_IOCTL_NEW_CTX		DRM_IOW( 0x25, struct drm_ctx)</span>
<span class="cp">#define DRM_IOCTL_RES_CTX		DRM_IOWR(0x26, struct drm_ctx_res)</span>
<span class="cp">#define DRM_IOCTL_ADD_DRAW		DRM_IOWR(0x27, struct drm_draw)</span>
<span class="cp">#define DRM_IOCTL_RM_DRAW		DRM_IOWR(0x28, struct drm_draw)</span>
<span class="cp">#define DRM_IOCTL_DMA			DRM_IOWR(0x29, struct drm_dma)</span>
<span class="cp">#define DRM_IOCTL_LOCK			DRM_IOW( 0x2a, struct drm_lock)</span>
<span class="cp">#define DRM_IOCTL_UNLOCK		DRM_IOW( 0x2b, struct drm_lock)</span>
<span class="cp">#define DRM_IOCTL_FINISH		DRM_IOW( 0x2c, struct drm_lock)</span>

<span class="cp">#define DRM_IOCTL_PRIME_HANDLE_TO_FD    DRM_IOWR(0x2d, struct drm_prime_handle)</span>
<span class="cp">#define DRM_IOCTL_PRIME_FD_TO_HANDLE    DRM_IOWR(0x2e, struct drm_prime_handle)</span>

<span class="cp">#define DRM_IOCTL_AGP_ACQUIRE		DRM_IO(  0x30)</span>
<span class="cp">#define DRM_IOCTL_AGP_RELEASE		DRM_IO(  0x31)</span>
<span class="cp">#define DRM_IOCTL_AGP_ENABLE		DRM_IOW( 0x32, struct drm_agp_mode)</span>
<span class="cp">#define DRM_IOCTL_AGP_INFO		DRM_IOR( 0x33, struct drm_agp_info)</span>
<span class="cp">#define DRM_IOCTL_AGP_ALLOC		DRM_IOWR(0x34, struct drm_agp_buffer)</span>
<span class="cp">#define DRM_IOCTL_AGP_FREE		DRM_IOW( 0x35, struct drm_agp_buffer)</span>
<span class="cp">#define DRM_IOCTL_AGP_BIND		DRM_IOW( 0x36, struct drm_agp_binding)</span>
<span class="cp">#define DRM_IOCTL_AGP_UNBIND		DRM_IOW( 0x37, struct drm_agp_binding)</span>

<span class="cp">#define DRM_IOCTL_SG_ALLOC		DRM_IOWR(0x38, struct drm_scatter_gather)</span>
<span class="cp">#define DRM_IOCTL_SG_FREE		DRM_IOW( 0x39, struct drm_scatter_gather)</span>

<span class="cp">#define DRM_IOCTL_WAIT_VBLANK		DRM_IOWR(0x3a, union drm_wait_vblank)</span>

<span class="cp">#define DRM_IOCTL_UPDATE_DRAW		DRM_IOW(0x3f, struct drm_update_draw)</span>

<span class="cp">#define DRM_IOCTL_MODE_GETRESOURCES	DRM_IOWR(0xA0, struct drm_mode_card_res)</span>
<span class="cp">#define DRM_IOCTL_MODE_GETCRTC		DRM_IOWR(0xA1, struct drm_mode_crtc)</span>
<span class="cp">#define DRM_IOCTL_MODE_SETCRTC		DRM_IOWR(0xA2, struct drm_mode_crtc)</span>
<span class="cp">#define DRM_IOCTL_MODE_CURSOR		DRM_IOWR(0xA3, struct drm_mode_cursor)</span>
<span class="cp">#define DRM_IOCTL_MODE_GETGAMMA		DRM_IOWR(0xA4, struct drm_mode_crtc_lut)</span>
<span class="cp">#define DRM_IOCTL_MODE_SETGAMMA		DRM_IOWR(0xA5, struct drm_mode_crtc_lut)</span>
<span class="cp">#define DRM_IOCTL_MODE_GETENCODER	DRM_IOWR(0xA6, struct drm_mode_get_encoder)</span>
<span class="cp">#define DRM_IOCTL_MODE_GETCONNECTOR	DRM_IOWR(0xA7, struct drm_mode_get_connector)</span>
<span class="cp">#define DRM_IOCTL_MODE_ATTACHMODE	DRM_IOWR(0xA8, struct drm_mode_mode_cmd)</span>
<span class="cp">#define DRM_IOCTL_MODE_DETACHMODE	DRM_IOWR(0xA9, struct drm_mode_mode_cmd)</span>

<span class="cp">#define DRM_IOCTL_MODE_GETPROPERTY	DRM_IOWR(0xAA, struct drm_mode_get_property)</span>
<span class="cp">#define DRM_IOCTL_MODE_SETPROPERTY	DRM_IOWR(0xAB, struct drm_mode_connector_set_property)</span>
<span class="cp">#define DRM_IOCTL_MODE_GETPROPBLOB	DRM_IOWR(0xAC, struct drm_mode_get_blob)</span>
<span class="cp">#define DRM_IOCTL_MODE_GETFB		DRM_IOWR(0xAD, struct drm_mode_fb_cmd)</span>
<span class="cp">#define DRM_IOCTL_MODE_ADDFB		DRM_IOWR(0xAE, struct drm_mode_fb_cmd)</span>
<span class="cp">#define DRM_IOCTL_MODE_RMFB		DRM_IOWR(0xAF, unsigned int)</span>
<span class="cp">#define DRM_IOCTL_MODE_PAGE_FLIP	DRM_IOWR(0xB0, struct drm_mode_crtc_page_flip)</span>
<span class="cp">#define DRM_IOCTL_MODE_DIRTYFB		DRM_IOWR(0xB1, struct drm_mode_fb_dirty_cmd)</span>

<span class="cp">#define DRM_IOCTL_MODE_CREATE_DUMB DRM_IOWR(0xB2, struct drm_mode_create_dumb)</span>
<span class="cp">#define DRM_IOCTL_MODE_MAP_DUMB    DRM_IOWR(0xB3, struct drm_mode_map_dumb)</span>
<span class="cp">#define DRM_IOCTL_MODE_DESTROY_DUMB    DRM_IOWR(0xB4, struct drm_mode_destroy_dumb)</span>
<span class="cp">#define DRM_IOCTL_MODE_GETPLANERESOURCES DRM_IOWR(0xB5, struct drm_mode_get_plane_res)</span>
<span class="cp">#define DRM_IOCTL_MODE_GETPLANE	DRM_IOWR(0xB6, struct drm_mode_get_plane)</span>
<span class="cp">#define DRM_IOCTL_MODE_SETPLANE	DRM_IOWR(0xB7, struct drm_mode_set_plane)</span>
<span class="cp">#define DRM_IOCTL_MODE_ADDFB2		DRM_IOWR(0xB8, struct drm_mode_fb_cmd2)</span>
<span class="cp">#define DRM_IOCTL_MODE_OBJ_GETPROPERTIES	DRM_IOWR(0xB9, struct drm_mode_obj_get_properties)</span>
<span class="cp">#define DRM_IOCTL_MODE_OBJ_SETPROPERTY	DRM_IOWR(0xBA, struct drm_mode_obj_set_property)</span>

<span class="cm">/**</span>
<span class="cm"> * Device specific ioctls should only be in their respective headers</span>
<span class="cm"> * The device specific ioctl range is from 0x40 to 0x99.</span>
<span class="cm"> * Generic IOCTLS restart at 0xA0.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drmCommandNone(), drmCommandRead(), drmCommandWrite(), and</span>
<span class="cm"> * drmCommandReadWrite().</span>
<span class="cm"> */</span>
<span class="cp">#define DRM_COMMAND_BASE                0x40</span>
<span class="cp">#define DRM_COMMAND_END			0xA0</span>

<span class="cm">/**</span>
<span class="cm"> * Header for events written back to userspace on the drm fd.  The</span>
<span class="cm"> * type defines the type of event, the length specifies the total</span>
<span class="cm"> * length of the event (including the header), and user_data is</span>
<span class="cm"> * typically a 64 bit value passed with the ioctl that triggered the</span>
<span class="cm"> * event.  A read on the drm fd will always only return complete</span>
<span class="cm"> * events, that is, if for example the read buffer is 100 bytes, and</span>
<span class="cm"> * there are two 64 byte events pending, only one will be returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Event types 0 - 0x7fffffff are generic drm events, 0x80000000 and</span>
<span class="cm"> * up are chipset specific.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_event</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DRM_EVENT_VBLANK 0x01</span>
<span class="cp">#define DRM_EVENT_FLIP_COMPLETE 0x02</span>

<span class="k">struct</span> <span class="n">drm_event_vblank</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_event</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">user_data</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">tv_usec</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sequence</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DRM_CAP_DUMB_BUFFER 0x1</span>
<span class="cp">#define DRM_CAP_VBLANK_HIGH_CRTC 0x2</span>
<span class="cp">#define DRM_CAP_DUMB_PREFERRED_DEPTH 0x3</span>
<span class="cp">#define DRM_CAP_DUMB_PREFER_SHADOW 0x4</span>
<span class="cp">#define DRM_CAP_PRIME 0x5</span>

<span class="cp">#define DRM_PRIME_CAP_IMPORT 0x1</span>
<span class="cp">#define DRM_PRIME_CAP_EXPORT 0x2</span>

<span class="cm">/* typedef area */</span>
<span class="cp">#ifndef __KERNEL__</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_clip_rect</span> <span class="n">drm_clip_rect_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_drawable_info</span> <span class="n">drm_drawable_info_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_tex_region</span> <span class="n">drm_tex_region_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_hw_lock</span> <span class="n">drm_hw_lock_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_version</span> <span class="n">drm_version_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_unique</span> <span class="n">drm_unique_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_list</span> <span class="n">drm_list_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_block</span> <span class="n">drm_block_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_control</span> <span class="n">drm_control_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">drm_map_type</span> <span class="n">drm_map_type_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">drm_map_flags</span> <span class="n">drm_map_flags_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_ctx_priv_map</span> <span class="n">drm_ctx_priv_map_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_map</span> <span class="n">drm_map_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_client</span> <span class="n">drm_client_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">drm_stat_type</span> <span class="n">drm_stat_type_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_stats</span> <span class="n">drm_stats_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">drm_lock_flags</span> <span class="n">drm_lock_flags_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_lock</span> <span class="n">drm_lock_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">drm_dma_flags</span> <span class="n">drm_dma_flags_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_buf_desc</span> <span class="n">drm_buf_desc_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_buf_info</span> <span class="n">drm_buf_info_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_buf_free</span> <span class="n">drm_buf_free_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_buf_pub</span> <span class="n">drm_buf_pub_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_buf_map</span> <span class="n">drm_buf_map_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_dma</span> <span class="n">drm_dma_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="n">drm_wait_vblank</span> <span class="n">drm_wait_vblank_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_agp_mode</span> <span class="n">drm_agp_mode_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">drm_ctx_flags</span> <span class="n">drm_ctx_flags_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_ctx</span> <span class="n">drm_ctx_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_ctx_res</span> <span class="n">drm_ctx_res_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_draw</span> <span class="n">drm_draw_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_update_draw</span> <span class="n">drm_update_draw_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_auth</span> <span class="n">drm_auth_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_irq_busid</span> <span class="n">drm_irq_busid_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">drm_vblank_seq_type</span> <span class="n">drm_vblank_seq_type_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_agp_buffer</span> <span class="n">drm_agp_buffer_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_agp_binding</span> <span class="n">drm_agp_binding_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_agp_info</span> <span class="n">drm_agp_info_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_scatter_gather</span> <span class="n">drm_scatter_gather_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_set_version</span> <span class="n">drm_set_version_t</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
