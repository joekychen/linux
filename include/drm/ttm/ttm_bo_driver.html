<!DOCTYPE html>
<html><head><title>joekychen/linux » include › drm › ttm › ttm_bo_driver.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ttm_bo_driver.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2006-2009 Vmware, Inc., Palo Alto, CA., USA</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the</span>
<span class="cm"> * &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="cm"> * without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="cm"> * distribute, sub license, and/or sell copies of the Software, and to</span>
<span class="cm"> * permit persons to whom the Software is furnished to do so, subject to</span>
<span class="cm"> * the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice (including the</span>
<span class="cm"> * next paragraph) shall be included in all copies or substantial portions</span>
<span class="cm"> * of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL</span>
<span class="cm"> * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,</span>
<span class="cm"> * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="cm"> * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="cm"> * USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Authors: Thomas Hellstrom &lt;thellstrom-at-vmware-dot-com&gt;</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _TTM_BO_DRIVER_H_</span>
<span class="cp">#define _TTM_BO_DRIVER_H_</span>

<span class="cp">#include &quot;ttm/ttm_bo_api.h&quot;</span>
<span class="cp">#include &quot;ttm/ttm_memory.h&quot;</span>
<span class="cp">#include &quot;ttm/ttm_module.h&quot;</span>
<span class="cp">#include &quot;drm_mm.h&quot;</span>
<span class="cp">#include &quot;drm_global.h&quot;</span>
<span class="cp">#include &quot;linux/workqueue.h&quot;</span>
<span class="cp">#include &quot;linux/fs.h&quot;</span>
<span class="cp">#include &quot;linux/spinlock.h&quot;</span>

<span class="k">struct</span> <span class="n">ttm_backend</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ttm_backend_func</span> <span class="p">{</span>
	<span class="cm">/**</span>
<span class="cm">	 * struct ttm_backend_func member bind</span>
<span class="cm">	 *</span>
<span class="cm">	 * @ttm: Pointer to a struct ttm_tt.</span>
<span class="cm">	 * @bo_mem: Pointer to a struct ttm_mem_reg describing the</span>
<span class="cm">	 * memory type and location for binding.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Bind the backend pages into the aperture in the location</span>
<span class="cm">	 * indicated by @bo_mem. This function should be able to handle</span>
<span class="cm">	 * differences between aperture and system page sizes.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="o">*</span><span class="n">bo_mem</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * struct ttm_backend_func member unbind</span>
<span class="cm">	 *</span>
<span class="cm">	 * @ttm: Pointer to a struct ttm_tt.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Unbind previously bound backend pages. This function should be</span>
<span class="cm">	 * able to handle differences between aperture and system page sizes.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">unbind</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * struct ttm_backend_func member destroy</span>
<span class="cm">	 *</span>
<span class="cm">	 * @ttm: Pointer to a struct ttm_tt.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Destroy the backend. This will be call back from ttm_tt_destroy so</span>
<span class="cm">	 * don&#39;t call ttm_tt_destroy from the callback or infinite loop.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define TTM_PAGE_FLAG_WRITE           (1 &lt;&lt; 3)</span>
<span class="cp">#define TTM_PAGE_FLAG_SWAPPED         (1 &lt;&lt; 4)</span>
<span class="cp">#define TTM_PAGE_FLAG_PERSISTENT_SWAP (1 &lt;&lt; 5)</span>
<span class="cp">#define TTM_PAGE_FLAG_ZERO_ALLOC      (1 &lt;&lt; 6)</span>
<span class="cp">#define TTM_PAGE_FLAG_DMA32           (1 &lt;&lt; 7)</span>
<span class="cp">#define TTM_PAGE_FLAG_SG              (1 &lt;&lt; 8)</span>

<span class="k">enum</span> <span class="n">ttm_caching_state</span> <span class="p">{</span>
	<span class="n">tt_uncached</span><span class="p">,</span>
	<span class="n">tt_wc</span><span class="p">,</span>
	<span class="n">tt_cached</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ttm_tt</span>
<span class="cm"> *</span>
<span class="cm"> * @bdev: Pointer to a struct ttm_bo_device.</span>
<span class="cm"> * @func: Pointer to a struct ttm_backend_func that describes</span>
<span class="cm"> * the backend methods.</span>
<span class="cm"> * @dummy_read_page: Page to map where the ttm_tt page array contains a NULL</span>
<span class="cm"> * pointer.</span>
<span class="cm"> * @pages: Array of pages backing the data.</span>
<span class="cm"> * @num_pages: Number of pages in the page array.</span>
<span class="cm"> * @bdev: Pointer to the current struct ttm_bo_device.</span>
<span class="cm"> * @be: Pointer to the ttm backend.</span>
<span class="cm"> * @swap_storage: Pointer to shmem struct file for swap storage.</span>
<span class="cm"> * @caching_state: The current caching state of the pages.</span>
<span class="cm"> * @state: The current binding state of the pages.</span>
<span class="cm"> *</span>
<span class="cm"> * This is a structure holding the pages, caching- and aperture binding</span>
<span class="cm"> * status for a buffer object that isn&#39;t backed by fixed (VRAM / AGP)</span>
<span class="cm"> * memory.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ttm_tt</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_backend_func</span> <span class="o">*</span><span class="n">func</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dummy_read_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">page_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sg_table</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span> <span class="cm">/* for SG objects via dma-buf */</span>
	<span class="k">struct</span> <span class="n">ttm_bo_global</span> <span class="o">*</span><span class="n">glob</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_backend</span> <span class="o">*</span><span class="n">be</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">swap_storage</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ttm_caching_state</span> <span class="n">caching_state</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">tt_bound</span><span class="p">,</span>
		<span class="n">tt_unbound</span><span class="p">,</span>
		<span class="n">tt_unpopulated</span><span class="p">,</span>
	<span class="p">}</span> <span class="n">state</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ttm_dma_tt</span>
<span class="cm"> *</span>
<span class="cm"> * @ttm: Base ttm_tt struct.</span>
<span class="cm"> * @dma_address: The DMA (bus) addresses of the pages</span>
<span class="cm"> * @pages_list: used by some page allocation backend</span>
<span class="cm"> *</span>
<span class="cm"> * This is a structure holding the pages, caching- and aperture binding</span>
<span class="cm"> * status for a buffer object that isn&#39;t backed by fixed (VRAM / AGP)</span>
<span class="cm"> * memory.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ttm_dma_tt</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ttm_tt</span> <span class="n">ttm</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma_address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pages_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define TTM_MEMTYPE_FLAG_FIXED         (1 &lt;&lt; 0)	</span><span class="cm">/* Fixed (on-card) PCI memory */</span><span class="cp"></span>
<span class="cp">#define TTM_MEMTYPE_FLAG_MAPPABLE      (1 &lt;&lt; 1)	</span><span class="cm">/* Memory mappable */</span><span class="cp"></span>
<span class="cp">#define TTM_MEMTYPE_FLAG_CMA           (1 &lt;&lt; 3)	</span><span class="cm">/* Can&#39;t map aperture */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">ttm_mem_type_manager</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ttm_mem_type_manager_func</span> <span class="p">{</span>
	<span class="cm">/**</span>
<span class="cm">	 * struct ttm_mem_type_manager member init</span>
<span class="cm">	 *</span>
<span class="cm">	 * @man: Pointer to a memory type manager.</span>
<span class="cm">	 * @p_size: Implementation dependent, but typically the size of the</span>
<span class="cm">	 * range to be managed in pages.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Called to initialize a private range manager. The function is</span>
<span class="cm">	 * expected to initialize the man::priv member.</span>
<span class="cm">	 * Returns 0 on success, negative error code on failure.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ttm_mem_type_manager</span> <span class="o">*</span><span class="n">man</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p_size</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * struct ttm_mem_type_manager member takedown</span>
<span class="cm">	 *</span>
<span class="cm">	 * @man: Pointer to a memory type manager.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Called to undo the setup done in init. All allocated resources</span>
<span class="cm">	 * should be freed.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">takedown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ttm_mem_type_manager</span> <span class="o">*</span><span class="n">man</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * struct ttm_mem_type_manager member get_node</span>
<span class="cm">	 *</span>
<span class="cm">	 * @man: Pointer to a memory type manager.</span>
<span class="cm">	 * @bo: Pointer to the buffer object we&#39;re allocating space for.</span>
<span class="cm">	 * @placement: Placement details.</span>
<span class="cm">	 * @mem: Pointer to a struct ttm_mem_reg to be filled in.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This function should allocate space in the memory type managed</span>
<span class="cm">	 * by @man. Placement details if</span>
<span class="cm">	 * applicable are given by @placement. If successful,</span>
<span class="cm">	 * @mem::mm_node should be set to a non-null value, and</span>
<span class="cm">	 * @mem::start should be set to a value identifying the beginning</span>
<span class="cm">	 * of the range allocated, and the function should return zero.</span>
<span class="cm">	 * If the memory region accommodate the buffer object, @mem::mm_node</span>
<span class="cm">	 * should be set to NULL, and the function should return 0.</span>
<span class="cm">	 * If a system error occurred, preventing the request to be fulfilled,</span>
<span class="cm">	 * the function should return a negative error code.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that @mem::mm_node will only be dereferenced by</span>
<span class="cm">	 * struct ttm_mem_type_manager functions and optionally by the driver,</span>
<span class="cm">	 * which has knowledge of the underlying type.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This function may not be called from within atomic context, so</span>
<span class="cm">	 * an implementation can and must use either a mutex or a spinlock to</span>
<span class="cm">	 * protect any data structures managing the space.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">get_node</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ttm_mem_type_manager</span> <span class="o">*</span><span class="n">man</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ttm_placement</span> <span class="o">*</span><span class="n">placement</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * struct ttm_mem_type_manager member put_node</span>
<span class="cm">	 *</span>
<span class="cm">	 * @man: Pointer to a memory type manager.</span>
<span class="cm">	 * @mem: Pointer to a struct ttm_mem_reg to be filled in.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This function frees memory type resources previously allocated</span>
<span class="cm">	 * and that are identified by @mem::mm_node and @mem::start. May not</span>
<span class="cm">	 * be called from within atomic context.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">put_node</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ttm_mem_type_manager</span> <span class="o">*</span><span class="n">man</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * struct ttm_mem_type_manager member debug</span>
<span class="cm">	 *</span>
<span class="cm">	 * @man: Pointer to a memory type manager.</span>
<span class="cm">	 * @prefix: Prefix to be used in printout to identify the caller.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This function is called to print out the state of the memory</span>
<span class="cm">	 * type manager to aid debugging of out-of-memory conditions.</span>
<span class="cm">	 * It may not be called from within atomic context.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">debug</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ttm_mem_type_manager</span> <span class="o">*</span><span class="n">man</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ttm_mem_type_manager</span>
<span class="cm"> *</span>
<span class="cm"> * @has_type: The memory type has been initialized.</span>
<span class="cm"> * @use_type: The memory type is enabled.</span>
<span class="cm"> * @flags: TTM_MEMTYPE_XX flags identifying the traits of the memory</span>
<span class="cm"> * managed by this memory type.</span>
<span class="cm"> * @gpu_offset: If used, the GPU offset of the first managed page of</span>
<span class="cm"> * fixed memory or the first managed location in an aperture.</span>
<span class="cm"> * @size: Size of the managed region.</span>
<span class="cm"> * @available_caching: A mask of available caching types, TTM_PL_FLAG_XX,</span>
<span class="cm"> * as defined in ttm_placement_common.h</span>
<span class="cm"> * @default_caching: The default caching policy used for a buffer object</span>
<span class="cm"> * placed in this memory type if the user doesn&#39;t provide one.</span>
<span class="cm"> * @func: structure pointer implementing the range manager. See above</span>
<span class="cm"> * @priv: Driver private closure for @func.</span>
<span class="cm"> * @io_reserve_mutex: Mutex optionally protecting shared io_reserve structures</span>
<span class="cm"> * @use_io_reserve_lru: Use an lru list to try to unreserve io_mem_regions</span>
<span class="cm"> * reserved by the TTM vm system.</span>
<span class="cm"> * @io_reserve_lru: Optional lru list for unreserving io mem regions.</span>
<span class="cm"> * @io_reserve_fastpath: Only use bdev::driver::io_mem_reserve to obtain</span>
<span class="cm"> * static information. bdev::driver::io_mem_free is never used.</span>
<span class="cm"> * @lru: The lru list for this memory type.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is used to identify and manage memory types for a device.</span>
<span class="cm"> * It&#39;s set up by the ttm_bo_driver::init_mem_type method.</span>
<span class="cm"> */</span>



<span class="k">struct</span> <span class="n">ttm_mem_type_manager</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * No protection. Constant from start.</span>
<span class="cm">	 */</span>

	<span class="n">bool</span> <span class="n">has_type</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">use_type</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gpu_offset</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">available_caching</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">default_caching</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ttm_mem_type_manager_func</span> <span class="o">*</span><span class="n">func</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">io_reserve_mutex</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">use_io_reserve_lru</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">io_reserve_fastpath</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protected by @io_reserve_mutex:</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">io_reserve_lru</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protected by the global-&gt;lru_lock.</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">lru</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ttm_bo_driver</span>
<span class="cm"> *</span>
<span class="cm"> * @create_ttm_backend_entry: Callback to create a struct ttm_backend.</span>
<span class="cm"> * @invalidate_caches: Callback to invalidate read caches when a buffer object</span>
<span class="cm"> * has been evicted.</span>
<span class="cm"> * @init_mem_type: Callback to initialize a struct ttm_mem_type_manager</span>
<span class="cm"> * structure.</span>
<span class="cm"> * @evict_flags: Callback to obtain placement flags when a buffer is evicted.</span>
<span class="cm"> * @move: Callback for a driver to hook in accelerated functions to</span>
<span class="cm"> * move a buffer.</span>
<span class="cm"> * If set to NULL, a potentially slow memcpy() move is used.</span>
<span class="cm"> * @sync_obj_signaled: See ttm_fence_api.h</span>
<span class="cm"> * @sync_obj_wait: See ttm_fence_api.h</span>
<span class="cm"> * @sync_obj_flush: See ttm_fence_api.h</span>
<span class="cm"> * @sync_obj_unref: See ttm_fence_api.h</span>
<span class="cm"> * @sync_obj_ref: See ttm_fence_api.h</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ttm_bo_driver</span> <span class="p">{</span>
	<span class="cm">/**</span>
<span class="cm">	 * ttm_tt_create</span>
<span class="cm">	 *</span>
<span class="cm">	 * @bdev: pointer to a struct ttm_bo_device:</span>
<span class="cm">	 * @size: Size of the data needed backing.</span>
<span class="cm">	 * @page_flags: Page flags as identified by TTM_PAGE_FLAG_XX flags.</span>
<span class="cm">	 * @dummy_read_page: See struct ttm_bo_device.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Create a struct ttm_tt to back data with system memory pages.</span>
<span class="cm">	 * No pages are actually allocated.</span>
<span class="cm">	 * Returns:</span>
<span class="cm">	 * NULL: Out of memory.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">ttm_tt_create</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
					<span class="kt">uint32_t</span> <span class="n">page_flags</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dummy_read_page</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * ttm_tt_populate</span>
<span class="cm">	 *</span>
<span class="cm">	 * @ttm: The struct ttm_tt to contain the backing pages.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Allocate all backing pages</span>
<span class="cm">	 * Returns:</span>
<span class="cm">	 * -ENOMEM: Out of memory.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ttm_tt_populate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * ttm_tt_unpopulate</span>
<span class="cm">	 *</span>
<span class="cm">	 * @ttm: The struct ttm_tt to contain the backing pages.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Free all backing page</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ttm_tt_unpopulate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * struct ttm_bo_driver member invalidate_caches</span>
<span class="cm">	 *</span>
<span class="cm">	 * @bdev: the buffer object device.</span>
<span class="cm">	 * @flags: new placement of the rebound buffer object.</span>
<span class="cm">	 *</span>
<span class="cm">	 * A previosly evicted buffer has been rebound in a</span>
<span class="cm">	 * potentially new location. Tell the driver that it might</span>
<span class="cm">	 * consider invalidating read (texture) caches on the next command</span>
<span class="cm">	 * submission as a consequence.</span>
<span class="cm">	 */</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">invalidate_caches</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init_mem_type</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">type</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ttm_mem_type_manager</span> <span class="o">*</span><span class="n">man</span><span class="p">);</span>
	<span class="cm">/**</span>
<span class="cm">	 * struct ttm_bo_driver member evict_flags:</span>
<span class="cm">	 *</span>
<span class="cm">	 * @bo: the buffer object to be evicted</span>
<span class="cm">	 *</span>
<span class="cm">	 * Return the bo flags for a buffer which is not mapped to the hardware.</span>
<span class="cm">	 * These will be placed in proposed_flags so that when the move is</span>
<span class="cm">	 * finished, they&#39;ll end up in bo-&gt;mem.flags</span>
<span class="cm">	 */</span>

	 <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">evict_flags</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ttm_placement</span> <span class="o">*</span><span class="n">placement</span><span class="p">);</span>
	<span class="cm">/**</span>
<span class="cm">	 * struct ttm_bo_driver member move:</span>
<span class="cm">	 *</span>
<span class="cm">	 * @bo: the buffer to move</span>
<span class="cm">	 * @evict: whether this motion is evicting the buffer from</span>
<span class="cm">	 * the graphics address space</span>
<span class="cm">	 * @interruptible: Use interruptible sleeps if possible when sleeping.</span>
<span class="cm">	 * @no_wait: whether this should give up and return -EBUSY</span>
<span class="cm">	 * if this move would require sleeping</span>
<span class="cm">	 * @new_mem: the new memory region receiving the buffer</span>
<span class="cm">	 *</span>
<span class="cm">	 * Move a buffer between two memory regions.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">move</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
		     <span class="n">bool</span> <span class="n">evict</span><span class="p">,</span> <span class="n">bool</span> <span class="n">interruptible</span><span class="p">,</span>
		     <span class="n">bool</span> <span class="n">no_wait_reserve</span><span class="p">,</span> <span class="n">bool</span> <span class="n">no_wait_gpu</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="o">*</span><span class="n">new_mem</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * struct ttm_bo_driver_member verify_access</span>
<span class="cm">	 *</span>
<span class="cm">	 * @bo: Pointer to a buffer object.</span>
<span class="cm">	 * @filp: Pointer to a struct file trying to access the object.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Called from the map / write / read methods to verify that the</span>
<span class="cm">	 * caller is permitted to access the buffer object.</span>
<span class="cm">	 * This member may be set to NULL, which will refuse this kind of</span>
<span class="cm">	 * access for all buffer objects.</span>
<span class="cm">	 * This function should return 0 if access is granted, -EPERM otherwise.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">verify_access</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * In case a driver writer dislikes the TTM fence objects,</span>
<span class="cm">	 * the driver writer can replace those with sync objects of</span>
<span class="cm">	 * his / her own. If it turns out that no driver writer is</span>
<span class="cm">	 * using these. I suggest we remove these hooks and plug in</span>
<span class="cm">	 * fences directly. The bo driver needs the following functionality:</span>
<span class="cm">	 * See the corresponding functions in the fence object API</span>
<span class="cm">	 * documentation.</span>
<span class="cm">	 */</span>

	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">sync_obj_signaled</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">sync_obj</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sync_arg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sync_obj_wait</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">sync_obj</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sync_arg</span><span class="p">,</span>
			      <span class="n">bool</span> <span class="n">lazy</span><span class="p">,</span> <span class="n">bool</span> <span class="n">interruptible</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sync_obj_flush</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">sync_obj</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sync_arg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sync_obj_unref</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">sync_obj</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">sync_obj_ref</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">sync_obj</span><span class="p">);</span>

	<span class="cm">/* hook to notify driver about a driver move so it</span>
<span class="cm">	 * can do tiling things */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">move_notify</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="o">*</span><span class="n">new_mem</span><span class="p">);</span>
	<span class="cm">/* notify the driver we are taking a fault on this BO</span>
<span class="cm">	 * and have reserved it */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fault_reserve_notify</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * notify the driver that we&#39;re about to swap out this bo</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">swap_notify</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * Driver callback on when mapping io memory (for bo_move_memcpy</span>
<span class="cm">	 * for instance). TTM will take care to call io_mem_free whenever</span>
<span class="cm">	 * the mapping is not use anymore. io_mem_reserve &amp; io_mem_free</span>
<span class="cm">	 * are balanced.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">io_mem_reserve</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">io_mem_free</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ttm_bo_global_ref - Argument to initialize a struct ttm_bo_global.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ttm_bo_global_ref</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_global_reference</span> <span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_mem_global</span> <span class="o">*</span><span class="n">mem_glob</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ttm_bo_global - Buffer object driver global data.</span>
<span class="cm"> *</span>
<span class="cm"> * @mem_glob: Pointer to a struct ttm_mem_global object for accounting.</span>
<span class="cm"> * @dummy_read_page: Pointer to a dummy page used for mapping requests</span>
<span class="cm"> * of unpopulated pages.</span>
<span class="cm"> * @shrink: A shrink callback object used for buffer object swap.</span>
<span class="cm"> * @device_list_mutex: Mutex protecting the device list.</span>
<span class="cm"> * This mutex is held while traversing the device list for pm options.</span>
<span class="cm"> * @lru_lock: Spinlock protecting the bo subsystem lru lists.</span>
<span class="cm"> * @device_list: List of buffer object devices.</span>
<span class="cm"> * @swap_lru: Lru list of buffer objects used for swapping.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ttm_bo_global</span> <span class="p">{</span>

	<span class="cm">/**</span>
<span class="cm">	 * Constant after init.</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_mem_global</span> <span class="o">*</span><span class="n">mem_glob</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dummy_read_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_mem_shrink</span> <span class="n">shrink</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">device_list_mutex</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lru_lock</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Protected by device_list_mutex.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">device_list</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Protected by the lru_lock.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">swap_lru</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Internal protection.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span> <span class="n">bo_count</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp">#define TTM_NUM_MEM_TYPES 8</span>

<span class="cp">#define TTM_BO_PRIV_FLAG_MOVING  0	</span><span class="cm">/* Buffer object is moving and needs</span>
<span class="cm">					   idling before CPU mapping */</span><span class="cp"></span>
<span class="cp">#define TTM_BO_PRIV_FLAG_MAX 1</span>
<span class="cm">/**</span>
<span class="cm"> * struct ttm_bo_device - Buffer object driver device-specific data.</span>
<span class="cm"> *</span>
<span class="cm"> * @driver: Pointer to a struct ttm_bo_driver struct setup by the driver.</span>
<span class="cm"> * @man: An array of mem_type_managers.</span>
<span class="cm"> * @fence_lock: Protects the synchronizing members on *all* bos belonging</span>
<span class="cm"> * to this device.</span>
<span class="cm"> * @addr_space_mm: Range manager for the device address space.</span>
<span class="cm"> * lru_lock: Spinlock that protects the buffer+device lru lists and</span>
<span class="cm"> * ddestroy lists.</span>
<span class="cm"> * @val_seq: Current validation sequence.</span>
<span class="cm"> * @nice_mode: Try nicely to wait for buffer idle when cleaning a manager.</span>
<span class="cm"> * If a GPU lockup has been detected, this is forced to 0.</span>
<span class="cm"> * @dev_mapping: A pointer to the struct address_space representing the</span>
<span class="cm"> * device address space.</span>
<span class="cm"> * @wq: Work queue structure for the delayed delete workqueue.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="p">{</span>

	<span class="cm">/*</span>
<span class="cm">	 * Constant after bo device init / atomic.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">device_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_bo_global</span> <span class="o">*</span><span class="n">glob</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_bo_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
	<span class="n">rwlock_t</span> <span class="n">vm_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_mem_type_manager</span> <span class="n">man</span><span class="p">[</span><span class="n">TTM_NUM_MEM_TYPES</span><span class="p">];</span>
	<span class="n">spinlock_t</span> <span class="n">fence_lock</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Protected by the vm lock.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">addr_space_rb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_mm</span> <span class="n">addr_space_mm</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protected by the global:lru lock.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ddestroy</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">val_seq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protected by load / firstopen / lastclose /unload sync.</span>
<span class="cm">	 */</span>

	<span class="n">bool</span> <span class="n">nice_mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">dev_mapping</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Internal protection.</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">wq</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">need_dma32</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_flag_masked</span>
<span class="cm"> *</span>
<span class="cm"> * @old: Pointer to the result and original value.</span>
<span class="cm"> * @new: New value of bits.</span>
<span class="cm"> * @mask: Mask of bits to change.</span>
<span class="cm"> *</span>
<span class="cm"> * Convenience function to change a number of bits identified by a mask.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span>
<span class="nf">ttm_flag_masked</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">new</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">old</span> <span class="o">^=</span> <span class="p">(</span><span class="o">*</span><span class="n">old</span> <span class="o">^</span> <span class="n">new</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_tt_init</span>
<span class="cm"> *</span>
<span class="cm"> * @ttm: The struct ttm_tt.</span>
<span class="cm"> * @bdev: pointer to a struct ttm_bo_device:</span>
<span class="cm"> * @size: Size of the data needed backing.</span>
<span class="cm"> * @page_flags: Page flags as identified by TTM_PAGE_FLAG_XX flags.</span>
<span class="cm"> * @dummy_read_page: See struct ttm_bo_device.</span>
<span class="cm"> *</span>
<span class="cm"> * Create a struct ttm_tt to back data with system memory pages.</span>
<span class="cm"> * No pages are actually allocated.</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * NULL: Out of memory.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_tt_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_flags</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dummy_read_page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_dma_tt_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_dma_tt</span> <span class="o">*</span><span class="n">ttm_dma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_flags</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dummy_read_page</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_tt_fini</span>
<span class="cm"> *</span>
<span class="cm"> * @ttm: the ttm_tt structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Free memory of ttm_tt structure</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_tt_fini</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_dma_tt_fini</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_dma_tt</span> <span class="o">*</span><span class="n">ttm_dma</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_ttm_bind:</span>
<span class="cm"> *</span>
<span class="cm"> * @ttm: The struct ttm_tt containing backing pages.</span>
<span class="cm"> * @bo_mem: The struct ttm_mem_reg identifying the binding location.</span>
<span class="cm"> *</span>
<span class="cm"> * Bind the pages of @ttm to an aperture location identified by @bo_mem</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_tt_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="o">*</span><span class="n">bo_mem</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_ttm_destroy:</span>
<span class="cm"> *</span>
<span class="cm"> * @ttm: The struct ttm_tt.</span>
<span class="cm"> *</span>
<span class="cm"> * Unbind, unpopulate and destroy common struct ttm_tt.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_tt_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_ttm_unbind:</span>
<span class="cm"> *</span>
<span class="cm"> * @ttm: The struct ttm_tt.</span>
<span class="cm"> *</span>
<span class="cm"> * Unbind a struct ttm_tt.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_tt_unbind</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_tt_swapin:</span>
<span class="cm"> *</span>
<span class="cm"> * @ttm: The struct ttm_tt.</span>
<span class="cm"> *</span>
<span class="cm"> * Swap in a previously swap out ttm_tt.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_tt_swapin</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_tt_cache_flush:</span>
<span class="cm"> *</span>
<span class="cm"> * @pages: An array of pointers to struct page:s to flush.</span>
<span class="cm"> * @num_pages: Number of pages to flush.</span>
<span class="cm"> *</span>
<span class="cm"> * Flush the data of the indicated pages from the cpu caches.</span>
<span class="cm"> * This is used when changing caching attributes of the pages from</span>
<span class="cm"> * cache-coherent.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_tt_cache_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_pages</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_tt_set_placement_caching:</span>
<span class="cm"> *</span>
<span class="cm"> * @ttm A struct ttm_tt the backing pages of which will change caching policy.</span>
<span class="cm"> * @placement: Flag indicating the desired caching policy.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will change caching policy of any default kernel mappings of</span>
<span class="cm"> * the pages backing @ttm. If changing from cached to uncached or</span>
<span class="cm"> * write-combined,</span>
<span class="cm"> * all CPU caches will first be flushed to make sure the data of the pages</span>
<span class="cm"> * hit RAM. This function may be very costly as it involves global TLB</span>
<span class="cm"> * and cache flushes and potential page splitting / combining.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_tt_set_placement_caching</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">placement</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_tt_swapout</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">persistent_swap_storage</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ttm_bo.c</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_mem_reg_is_pci</span>
<span class="cm"> *</span>
<span class="cm"> * @bdev: Pointer to a struct ttm_bo_device.</span>
<span class="cm"> * @mem: A valid struct ttm_mem_reg.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if the memory described by @mem is PCI memory,</span>
<span class="cm"> * false otherwise.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">ttm_mem_reg_is_pci</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_mem_space</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: Pointer to a struct ttm_buffer_object. the data of which</span>
<span class="cm"> * we want to allocate space for.</span>
<span class="cm"> * @proposed_placement: Proposed new placement for the buffer object.</span>
<span class="cm"> * @mem: A struct ttm_mem_reg.</span>
<span class="cm"> * @interruptible: Sleep interruptible when sliping.</span>
<span class="cm"> * @no_wait_reserve: Return immediately if other buffers are busy.</span>
<span class="cm"> * @no_wait_gpu: Return immediately if the GPU is busy.</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate memory space for the buffer object pointed to by @bo, using</span>
<span class="cm"> * the placement flags in @mem, potentially evicting other idle buffer objects.</span>
<span class="cm"> * This function may sleep while waiting for space to become available.</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EBUSY: No space available (only if no_wait == 1).</span>
<span class="cm"> * -ENOMEM: Could not allocate memory for the buffer object, either due to</span>
<span class="cm"> * fragmentation or concurrent allocators.</span>
<span class="cm"> * -ERESTARTSYS: An interruptible sleep was interrupted by a signal.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_mem_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ttm_placement</span> <span class="o">*</span><span class="n">placement</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">interruptible</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">no_wait_reserve</span><span class="p">,</span> <span class="n">bool</span> <span class="n">no_wait_gpu</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_bo_mem_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_bo_mem_put_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_wait_for_cpu</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: Pointer to a struct ttm_buffer_object.</span>
<span class="cm"> * @no_wait: Don&#39;t sleep while waiting.</span>
<span class="cm"> *</span>
<span class="cm"> * Wait until a buffer object is no longer sync&#39;ed for CPU access.</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EBUSY: Buffer object was sync&#39;ed for CPU access. (only if no_wait == 1).</span>
<span class="cm"> * -ERESTARTSYS: An interruptible sleep was interrupted by a signal.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_wait_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span> <span class="n">bool</span> <span class="n">no_wait</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_bo_global_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_global_reference</span> <span class="o">*</span><span class="n">ref</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_global_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_global_reference</span> <span class="o">*</span><span class="n">ref</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_device_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_device_init</span>
<span class="cm"> *</span>
<span class="cm"> * @bdev: A pointer to a struct ttm_bo_device to initialize.</span>
<span class="cm"> * @glob: A pointer to an initialized struct ttm_bo_global.</span>
<span class="cm"> * @driver: A pointer to a struct ttm_bo_driver set up by the caller.</span>
<span class="cm"> * @file_page_offset: Offset into the device address space that is available</span>
<span class="cm"> * for buffer data. This ensures compatibility with other users of the</span>
<span class="cm"> * address space.</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes a struct ttm_bo_device:</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * !0: Failure.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_device_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ttm_bo_global</span> <span class="o">*</span><span class="n">glob</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ttm_bo_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
			      <span class="kt">uint64_t</span> <span class="n">file_page_offset</span><span class="p">,</span> <span class="n">bool</span> <span class="n">need_dma32</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_unmap_virtual</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: tear down the virtual mappings for this BO</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_bo_unmap_virtual</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_unmap_virtual</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: tear down the virtual mappings for this BO</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must take ttm_mem_io_lock before calling this function.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_bo_unmap_virtual_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_mem_io_reserve_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_mem_io_free_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_mem_io_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_mem_type_manager</span> <span class="o">*</span><span class="n">man</span><span class="p">,</span>
			   <span class="n">bool</span> <span class="n">interruptible</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_mem_io_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_mem_type_manager</span> <span class="o">*</span><span class="n">man</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * ttm_bo_reserve:</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: A pointer to a struct ttm_buffer_object.</span>
<span class="cm"> * @interruptible: Sleep interruptible if waiting.</span>
<span class="cm"> * @no_wait: Don&#39;t sleep while trying to reserve, rather return -EBUSY.</span>
<span class="cm"> * @use_sequence: If @bo is already reserved, Only sleep waiting for</span>
<span class="cm"> * it to become unreserved if @sequence &lt; (@bo)-&gt;sequence.</span>
<span class="cm"> *</span>
<span class="cm"> * Locks a buffer object for validation. (Or prevents other processes from</span>
<span class="cm"> * locking it for validation) and removes it from lru lists, while taking</span>
<span class="cm"> * a number of measures to prevent deadlocks.</span>
<span class="cm"> *</span>
<span class="cm"> * Deadlocks may occur when two processes try to reserve multiple buffers in</span>
<span class="cm"> * different order, either by will or as a result of a buffer being evicted</span>
<span class="cm"> * to make room for a buffer already reserved. (Buffers are reserved before</span>
<span class="cm"> * they are evicted). The following algorithm prevents such deadlocks from</span>
<span class="cm"> * occurring:</span>
<span class="cm"> * 1) Buffers are reserved with the lru spinlock held. Upon successful</span>
<span class="cm"> * reservation they are removed from the lru list. This stops a reserved buffer</span>
<span class="cm"> * from being evicted. However the lru spinlock is released between the time</span>
<span class="cm"> * a buffer is selected for eviction and the time it is reserved.</span>
<span class="cm"> * Therefore a check is made when a buffer is reserved for eviction, that it</span>
<span class="cm"> * is still the first buffer in the lru list, before it is removed from the</span>
<span class="cm"> * list. @check_lru == 1 forces this check. If it fails, the function returns</span>
<span class="cm"> * -EINVAL, and the caller should then choose a new buffer to evict and repeat</span>
<span class="cm"> * the procedure.</span>
<span class="cm"> * 2) Processes attempting to reserve multiple buffers other than for eviction,</span>
<span class="cm"> * (typically execbuf), should first obtain a unique 32-bit</span>
<span class="cm"> * validation sequence number,</span>
<span class="cm"> * and call this function with @use_sequence == 1 and @sequence == the unique</span>
<span class="cm"> * sequence number. If upon call of this function, the buffer object is already</span>
<span class="cm"> * reserved, the validation sequence is checked against the validation</span>
<span class="cm"> * sequence of the process currently reserving the buffer,</span>
<span class="cm"> * and if the current validation sequence is greater than that of the process</span>
<span class="cm"> * holding the reservation, the function returns -EAGAIN. Otherwise it sleeps</span>
<span class="cm"> * waiting for the buffer to become unreserved, after which it retries</span>
<span class="cm"> * reserving.</span>
<span class="cm"> * The caller should, when receiving an -EAGAIN error</span>
<span class="cm"> * release all its buffer reservations, wait for @bo to become unreserved, and</span>
<span class="cm"> * then rerun the validation with the same validation sequence. This procedure</span>
<span class="cm"> * will always guarantee that the process with the lowest validation sequence</span>
<span class="cm"> * will eventually succeed, preventing both deadlocks and starvation.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EAGAIN: The reservation may cause a deadlock.</span>
<span class="cm"> * Release all buffer reservations, wait for @bo to become unreserved and</span>
<span class="cm"> * try again. (only if use_sequence == 1).</span>
<span class="cm"> * -ERESTARTSYS: A wait for the buffer to become unreserved was interrupted by</span>
<span class="cm"> * a signal. Release all buffer reservations and return to user-space.</span>
<span class="cm"> * -EBUSY: The function needed to sleep, but @no_wait was true</span>
<span class="cm"> * -EDEADLK: Bo already reserved using @sequence. This error code will only</span>
<span class="cm"> * be returned if @use_sequence is set to true.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
			  <span class="n">bool</span> <span class="n">interruptible</span><span class="p">,</span>
			  <span class="n">bool</span> <span class="n">no_wait</span><span class="p">,</span> <span class="n">bool</span> <span class="n">use_sequence</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">sequence</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * ttm_bo_reserve_locked:</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: A pointer to a struct ttm_buffer_object.</span>
<span class="cm"> * @interruptible: Sleep interruptible if waiting.</span>
<span class="cm"> * @no_wait: Don&#39;t sleep while trying to reserve, rather return -EBUSY.</span>
<span class="cm"> * @use_sequence: If @bo is already reserved, Only sleep waiting for</span>
<span class="cm"> * it to become unreserved if @sequence &lt; (@bo)-&gt;sequence.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with struct ttm_bo_global::lru_lock held,</span>
<span class="cm"> * and will not remove reserved buffers from the lru lists.</span>
<span class="cm"> * The function may release the LRU spinlock if it needs to sleep.</span>
<span class="cm"> * Otherwise identical to ttm_bo_reserve.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EAGAIN: The reservation may cause a deadlock.</span>
<span class="cm"> * Release all buffer reservations, wait for @bo to become unreserved and</span>
<span class="cm"> * try again. (only if use_sequence == 1).</span>
<span class="cm"> * -ERESTARTSYS: A wait for the buffer to become unreserved was interrupted by</span>
<span class="cm"> * a signal. Release all buffer reservations and return to user-space.</span>
<span class="cm"> * -EBUSY: The function needed to sleep, but @no_wait was true</span>
<span class="cm"> * -EDEADLK: Bo already reserved using @sequence. This error code will only</span>
<span class="cm"> * be returned if @use_sequence is set to true.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_reserve_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
				 <span class="n">bool</span> <span class="n">interruptible</span><span class="p">,</span>
				 <span class="n">bool</span> <span class="n">no_wait</span><span class="p">,</span> <span class="n">bool</span> <span class="n">use_sequence</span><span class="p">,</span>
				 <span class="kt">uint32_t</span> <span class="n">sequence</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_unreserve</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: A pointer to a struct ttm_buffer_object.</span>
<span class="cm"> *</span>
<span class="cm"> * Unreserve a previous reservation of @bo.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_bo_unreserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_unreserve_locked</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: A pointer to a struct ttm_buffer_object.</span>
<span class="cm"> *</span>
<span class="cm"> * Unreserve a previous reservation of @bo.</span>
<span class="cm"> * Needs to be called with struct ttm_bo_global::lru_lock held.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_bo_unreserve_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_wait_unreserved</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: A pointer to a struct ttm_buffer_object.</span>
<span class="cm"> *</span>
<span class="cm"> * Wait for a struct ttm_buffer_object to become unreserved.</span>
<span class="cm"> * This is typically used in the execbuf code to relax cpu-usage when</span>
<span class="cm"> * a potential deadlock condition backoff.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_wait_unreserved</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
				  <span class="n">bool</span> <span class="n">interruptible</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ttm_bo_util.c</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_move_ttm</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: A pointer to a struct ttm_buffer_object.</span>
<span class="cm"> * @evict: 1: This is an eviction. Don&#39;t try to pipeline.</span>
<span class="cm"> * @no_wait_reserve: Return immediately if other buffers are busy.</span>
<span class="cm"> * @no_wait_gpu: Return immediately if the GPU is busy.</span>
<span class="cm"> * @new_mem: struct ttm_mem_reg indicating where to move.</span>
<span class="cm"> *</span>
<span class="cm"> * Optimized move function for a buffer object with both old and</span>
<span class="cm"> * new placement backed by a TTM. The function will, if successful,</span>
<span class="cm"> * free any old aperture space, and set (@new_mem)-&gt;mm_node to NULL,</span>
<span class="cm"> * and update the (@bo)-&gt;mem placement flags. If unsuccessful, the old</span>
<span class="cm"> * data remains untouched, and it&#39;s up to the caller to free the</span>
<span class="cm"> * memory space indicated by @new_mem.</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * !0: Failure.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_move_ttm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
			   <span class="n">bool</span> <span class="n">evict</span><span class="p">,</span> <span class="n">bool</span> <span class="n">no_wait_reserve</span><span class="p">,</span>
			   <span class="n">bool</span> <span class="n">no_wait_gpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="o">*</span><span class="n">new_mem</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_move_memcpy</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: A pointer to a struct ttm_buffer_object.</span>
<span class="cm"> * @evict: 1: This is an eviction. Don&#39;t try to pipeline.</span>
<span class="cm"> * @no_wait_reserve: Return immediately if other buffers are busy.</span>
<span class="cm"> * @no_wait_gpu: Return immediately if the GPU is busy.</span>
<span class="cm"> * @new_mem: struct ttm_mem_reg indicating where to move.</span>
<span class="cm"> *</span>
<span class="cm"> * Fallback move function for a mappable buffer object in mappable memory.</span>
<span class="cm"> * The function will, if successful,</span>
<span class="cm"> * free any old aperture space, and set (@new_mem)-&gt;mm_node to NULL,</span>
<span class="cm"> * and update the (@bo)-&gt;mem placement flags. If unsuccessful, the old</span>
<span class="cm"> * data remains untouched, and it&#39;s up to the caller to free the</span>
<span class="cm"> * memory space indicated by @new_mem.</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * !0: Failure.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_move_memcpy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
			      <span class="n">bool</span> <span class="n">evict</span><span class="p">,</span> <span class="n">bool</span> <span class="n">no_wait_reserve</span><span class="p">,</span>
			      <span class="n">bool</span> <span class="n">no_wait_gpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="o">*</span><span class="n">new_mem</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_free_old_node</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: A pointer to a struct ttm_buffer_object.</span>
<span class="cm"> *</span>
<span class="cm"> * Utility function to free an old placement after a successful move.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_bo_free_old_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_move_accel_cleanup.</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: A pointer to a struct ttm_buffer_object.</span>
<span class="cm"> * @sync_obj: A sync object that signals when moving is complete.</span>
<span class="cm"> * @sync_obj_arg: An argument to pass to the sync object idle / wait</span>
<span class="cm"> * functions.</span>
<span class="cm"> * @evict: This is an evict move. Don&#39;t return until the buffer is idle.</span>
<span class="cm"> * @no_wait_reserve: Return immediately if other buffers are busy.</span>
<span class="cm"> * @no_wait_gpu: Return immediately if the GPU is busy.</span>
<span class="cm"> * @new_mem: struct ttm_mem_reg indicating where to move.</span>
<span class="cm"> *</span>
<span class="cm"> * Accelerated move function to be called when an accelerated move</span>
<span class="cm"> * has been scheduled. The function will create a new temporary buffer object</span>
<span class="cm"> * representing the old placement, and put the sync object on both buffer</span>
<span class="cm"> * objects. After that the newly created buffer object is unref&#39;d to be</span>
<span class="cm"> * destroyed when the move is complete. This will help pipeline</span>
<span class="cm"> * buffer moves.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_move_accel_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">sync_obj</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">sync_obj_arg</span><span class="p">,</span>
				     <span class="n">bool</span> <span class="n">evict</span><span class="p">,</span> <span class="n">bool</span> <span class="n">no_wait_reserve</span><span class="p">,</span>
				     <span class="n">bool</span> <span class="n">no_wait_gpu</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="o">*</span><span class="n">new_mem</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * ttm_io_prot</span>
<span class="cm"> *</span>
<span class="cm"> * @c_state: Caching state.</span>
<span class="cm"> * @tmp: Page protection flag for a normal, cached mapping.</span>
<span class="cm"> *</span>
<span class="cm"> * Utility function that returns the pgprot_t that should be used for</span>
<span class="cm"> * setting up a PTE with the caching model indicated by @c_state.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">pgprot_t</span> <span class="n">ttm_io_prot</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">caching_flags</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">tmp</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ttm_mem_type_manager_func</span> <span class="n">ttm_bo_manager_func</span><span class="p">;</span>

<span class="cp">#if (defined(CONFIG_AGP) || (defined(CONFIG_AGP_MODULE) &amp;&amp; defined(MODULE)))</span>
<span class="cp">#define TTM_HAS_AGP</span>
<span class="cp">#include &lt;linux/agp_backend.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_agp_tt_create</span>
<span class="cm"> *</span>
<span class="cm"> * @bdev: Pointer to a struct ttm_bo_device.</span>
<span class="cm"> * @bridge: The agp bridge this device is sitting on.</span>
<span class="cm"> * @size: Size of the data needed backing.</span>
<span class="cm"> * @page_flags: Page flags as identified by TTM_PAGE_FLAG_XX flags.</span>
<span class="cm"> * @dummy_read_page: See struct ttm_bo_device.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Create a TTM backend that uses the indicated AGP bridge as an aperture</span>
<span class="cm"> * for TT memory. This function uses the linux agpgart interface to</span>
<span class="cm"> * bind and unbind memory backing a ttm_tt.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm_agp_tt_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">agp_bridge_data</span> <span class="o">*</span><span class="n">bridge</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_flags</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dummy_read_page</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ttm_agp_tt_populate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ttm_agp_tt_unpopulate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
