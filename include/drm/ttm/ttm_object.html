<!DOCTYPE html>
<html><head><title>joekychen/linux » include › drm › ttm › ttm_object.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ttm_object.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2006-2009 VMware, Inc., Palo Alto, CA., USA</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the</span>
<span class="cm"> * &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="cm"> * without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="cm"> * distribute, sub license, and/or sell copies of the Software, and to</span>
<span class="cm"> * permit persons to whom the Software is furnished to do so, subject to</span>
<span class="cm"> * the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice (including the</span>
<span class="cm"> * next paragraph) shall be included in all copies or substantial portions</span>
<span class="cm"> * of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL</span>
<span class="cm"> * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,</span>
<span class="cm"> * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="cm"> * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="cm"> * USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Authors: Thomas Hellstrom &lt;thellstrom-at-vmware-dot-com&gt;</span>
<span class="cm"> */</span>
<span class="cm">/** @file ttm_object.h</span>
<span class="cm"> *</span>
<span class="cm"> * Base- and reference object implementation for the various</span>
<span class="cm"> * ttm objects. Implements reference counting, minimal security checks</span>
<span class="cm"> * and release on file close.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _TTM_OBJECT_H_</span>
<span class="cp">#define _TTM_OBJECT_H_</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &quot;drm_hashtab.h&quot;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;ttm/ttm_memory.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * enum ttm_ref_type</span>
<span class="cm"> *</span>
<span class="cm"> * Describes what type of reference a ref object holds.</span>
<span class="cm"> *</span>
<span class="cm"> * TTM_REF_USAGE is a simple refcount on a base object.</span>
<span class="cm"> *</span>
<span class="cm"> * TTM_REF_SYNCCPU_READ is a SYNCCPU_READ reference on a</span>
<span class="cm"> * buffer object.</span>
<span class="cm"> *</span>
<span class="cm"> * TTM_REF_SYNCCPU_WRITE is a SYNCCPU_WRITE reference on a</span>
<span class="cm"> * buffer object.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">ttm_ref_type</span> <span class="p">{</span>
	<span class="n">TTM_REF_USAGE</span><span class="p">,</span>
	<span class="n">TTM_REF_SYNCCPU_READ</span><span class="p">,</span>
	<span class="n">TTM_REF_SYNCCPU_WRITE</span><span class="p">,</span>
	<span class="n">TTM_REF_NUM</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ttm_object_type</span>
<span class="cm"> *</span>
<span class="cm"> * One entry per ttm object type.</span>
<span class="cm"> * Device-specific types should use the</span>
<span class="cm"> * ttm_driver_typex types.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">ttm_object_type</span> <span class="p">{</span>
	<span class="n">ttm_fence_type</span><span class="p">,</span>
	<span class="n">ttm_buffer_type</span><span class="p">,</span>
	<span class="n">ttm_lock_type</span><span class="p">,</span>
	<span class="n">ttm_driver_type0</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
	<span class="n">ttm_driver_type1</span><span class="p">,</span>
	<span class="n">ttm_driver_type2</span><span class="p">,</span>
	<span class="n">ttm_driver_type3</span><span class="p">,</span>
	<span class="n">ttm_driver_type4</span><span class="p">,</span>
	<span class="n">ttm_driver_type5</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ttm_object_file</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ttm_object_device</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ttm_base_object</span>
<span class="cm"> *</span>
<span class="cm"> * @hash: hash entry for the per-device object hash.</span>
<span class="cm"> * @type: derived type this object is base class for.</span>
<span class="cm"> * @shareable: Other ttm_object_files can access this object.</span>
<span class="cm"> *</span>
<span class="cm"> * @tfile: Pointer to ttm_object_file of the creator.</span>
<span class="cm"> * NULL if the object was not created by a user request.</span>
<span class="cm"> * (kernel object).</span>
<span class="cm"> *</span>
<span class="cm"> * @refcount: Number of references to this object, not</span>
<span class="cm"> * including the hash entry. A reference to a base object can</span>
<span class="cm"> * only be held by a ref object.</span>
<span class="cm"> *</span>
<span class="cm"> * @refcount_release: A function to be called when there are</span>
<span class="cm"> * no more references to this object. This function should</span>
<span class="cm"> * destroy the object (or make sure destruction eventually happens),</span>
<span class="cm"> * and when it is called, the object has</span>
<span class="cm"> * already been taken out of the per-device hash. The parameter</span>
<span class="cm"> * &quot;base&quot; should be set to NULL by the function.</span>
<span class="cm"> *</span>
<span class="cm"> * @ref_obj_release: A function to be called when a reference object</span>
<span class="cm"> * with another ttm_ref_type than TTM_REF_USAGE is deleted.</span>
<span class="cm"> * This function may, for example, release a lock held by a user-space</span>
<span class="cm"> * process.</span>
<span class="cm"> *</span>
<span class="cm"> * This struct is intended to be used as a base struct for objects that</span>
<span class="cm"> * are visible to user-space. It provides a global name, race-safe</span>
<span class="cm"> * access and refcounting, minimal access contol and hooks for unref actions.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ttm_base_object</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_hash_item</span> <span class="n">hash</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ttm_object_type</span> <span class="n">object_type</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">shareable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_object_file</span> <span class="o">*</span><span class="n">tfile</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">refcount</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">refcount_release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_base_object</span> <span class="o">**</span><span class="n">base</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ref_obj_release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_base_object</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">ttm_ref_type</span> <span class="n">ref_type</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_base_object_init</span>
<span class="cm"> *</span>
<span class="cm"> * @tfile: Pointer to a struct ttm_object_file.</span>
<span class="cm"> * @base: The struct ttm_base_object to initialize.</span>
<span class="cm"> * @shareable: This object is shareable with other applcations.</span>
<span class="cm"> * (different @tfile pointers.)</span>
<span class="cm"> * @type: The object type.</span>
<span class="cm"> * @refcount_release: See the struct ttm_base_object description.</span>
<span class="cm"> * @ref_obj_release: See the struct ttm_base_object description.</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes a struct ttm_base_object.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_base_object_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_object_file</span> <span class="o">*</span><span class="n">tfile</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ttm_base_object</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">shareable</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">ttm_object_type</span> <span class="n">type</span><span class="p">,</span>
				<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">refcount_release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_base_object</span>
							  <span class="o">**</span><span class="p">),</span>
				<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ref_obj_release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_base_object</span>
							 <span class="o">*</span><span class="p">,</span>
							 <span class="k">enum</span> <span class="n">ttm_ref_type</span>
							 <span class="n">ref_type</span><span class="p">));</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_base_object_lookup</span>
<span class="cm"> *</span>
<span class="cm"> * @tfile: Pointer to a struct ttm_object_file.</span>
<span class="cm"> * @key: Hash key</span>
<span class="cm"> *</span>
<span class="cm"> * Looks up a struct ttm_base_object with the key @key.</span>
<span class="cm"> * Also verifies that the object is visible to the application, by</span>
<span class="cm"> * comparing the @tfile argument and checking the object shareable flag.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">ttm_base_object</span> <span class="o">*</span><span class="n">ttm_base_object_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_object_file</span>
						      <span class="o">*</span><span class="n">tfile</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_base_object_unref</span>
<span class="cm"> *</span>
<span class="cm"> * @p_base: Pointer to a pointer referencing a struct ttm_base_object.</span>
<span class="cm"> *</span>
<span class="cm"> * Decrements the base object refcount and clears the pointer pointed to by</span>
<span class="cm"> * p_base.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_base_object_unref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_base_object</span> <span class="o">**</span><span class="n">p_base</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_ref_object_add.</span>
<span class="cm"> *</span>
<span class="cm"> * @tfile: A struct ttm_object_file representing the application owning the</span>
<span class="cm"> * ref_object.</span>
<span class="cm"> * @base: The base object to reference.</span>
<span class="cm"> * @ref_type: The type of reference.</span>
<span class="cm"> * @existed: Upon completion, indicates that an identical reference object</span>
<span class="cm"> * already existed, and the refcount was upped on that object instead.</span>
<span class="cm"> *</span>
<span class="cm"> * Adding a ref object to a base object is basically like referencing the</span>
<span class="cm"> * base object, but a user-space application holds the reference. When the</span>
<span class="cm"> * file corresponding to @tfile is closed, all its reference objects are</span>
<span class="cm"> * deleted. A reference object can have different types depending on what</span>
<span class="cm"> * it&#39;s intended for. It can be refcounting to prevent object destruction,</span>
<span class="cm"> * When user-space takes a lock, it can add a ref object to that lock to</span>
<span class="cm"> * make sure the lock is released if the application dies. A ref object</span>
<span class="cm"> * will hold a single reference on a base object.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_ref_object_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_object_file</span> <span class="o">*</span><span class="n">tfile</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ttm_base_object</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">ttm_ref_type</span> <span class="n">ref_type</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">existed</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * ttm_ref_object_base_unref</span>
<span class="cm"> *</span>
<span class="cm"> * @key: Key representing the base object.</span>
<span class="cm"> * @ref_type: Ref type of the ref object to be dereferenced.</span>
<span class="cm"> *</span>
<span class="cm"> * Unreference a ref object with type @ref_type</span>
<span class="cm"> * on the base object identified by @key. If there are no duplicate</span>
<span class="cm"> * references, the ref object will be destroyed and the base object</span>
<span class="cm"> * will be unreferenced.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_ref_object_base_unref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_object_file</span> <span class="o">*</span><span class="n">tfile</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">key</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">ttm_ref_type</span> <span class="n">ref_type</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_object_file_init - initialize a struct ttm_object file</span>
<span class="cm"> *</span>
<span class="cm"> * @tdev: A struct ttm_object device this file is initialized on.</span>
<span class="cm"> * @hash_order: Order of the hash table used to hold the reference objects.</span>
<span class="cm"> *</span>
<span class="cm"> * This is typically called by the file_ops::open function.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">ttm_object_file</span> <span class="o">*</span><span class="n">ttm_object_file_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_object_device</span>
						    <span class="o">*</span><span class="n">tdev</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash_order</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_object_file_release - release data held by a ttm_object_file</span>
<span class="cm"> *</span>
<span class="cm"> * @p_tfile: Pointer to pointer to the ttm_object_file object to release.</span>
<span class="cm"> * *p_tfile will be set to NULL by this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Releases all data associated by a ttm_object_file.</span>
<span class="cm"> * Typically called from file_ops::release. The caller must</span>
<span class="cm"> * ensure that there are no concurrent users of tfile.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_object_file_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_object_file</span> <span class="o">**</span><span class="n">p_tfile</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_object device init - initialize a struct ttm_object_device</span>
<span class="cm"> *</span>
<span class="cm"> * @hash_order: Order of hash table used to hash the base objects.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is typically called on device initialization to prepare</span>
<span class="cm"> * data structures needed for ttm base and ref objects.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">ttm_object_device</span> <span class="o">*</span><span class="n">ttm_object_device_init</span>
    <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_mem_global</span> <span class="o">*</span><span class="n">mem_glob</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash_order</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_object_device_release - release data held by a ttm_object_device</span>
<span class="cm"> *</span>
<span class="cm"> * @p_tdev: Pointer to pointer to the ttm_object_device object to release.</span>
<span class="cm"> * *p_tdev will be set to NULL by this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Releases all data associated by a ttm_object_device.</span>
<span class="cm"> * Typically called from driver::unload before the destruction of the</span>
<span class="cm"> * device private data structure.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_object_device_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_object_device</span> <span class="o">**</span><span class="n">p_tdev</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
