<!DOCTYPE html>
<html><head><title>joekychen/linux » include › drm › ttm › ttm_bo_api.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ttm_bo_api.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2006-2009 VMware, Inc., Palo Alto, CA., USA</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the</span>
<span class="cm"> * &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="cm"> * without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="cm"> * distribute, sub license, and/or sell copies of the Software, and to</span>
<span class="cm"> * permit persons to whom the Software is furnished to do so, subject to</span>
<span class="cm"> * the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice (including the</span>
<span class="cm"> * next paragraph) shall be included in all copies or substantial portions</span>
<span class="cm"> * of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL</span>
<span class="cm"> * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,</span>
<span class="cm"> * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="cm"> * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="cm"> * USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Authors: Thomas Hellstrom &lt;thellstrom-at-vmware-dot-com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _TTM_BO_API_H_</span>
<span class="cp">#define _TTM_BO_API_H_</span>

<span class="cp">#include &quot;drm_hashtab.h&quot;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/bitmap.h&gt;</span>

<span class="k">struct</span> <span class="n">ttm_bo_device</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">drm_mm_node</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * struct ttm_placement</span>
<span class="cm"> *</span>
<span class="cm"> * @fpfn:		first valid page frame number to put the object</span>
<span class="cm"> * @lpfn:		last valid page frame number to put the object</span>
<span class="cm"> * @num_placement:	number of preferred placements</span>
<span class="cm"> * @placement:		preferred placements</span>
<span class="cm"> * @num_busy_placement:	number of preferred placements when need to evict buffer</span>
<span class="cm"> * @busy_placement:	preferred placements when need to evict buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Structure indicating the placement you request for an object.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ttm_placement</span> <span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">fpfn</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">lpfn</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">num_placement</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">uint32_t</span>	<span class="o">*</span><span class="n">placement</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">num_busy_placement</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">uint32_t</span>	<span class="o">*</span><span class="n">busy_placement</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ttm_bus_placement</span>
<span class="cm"> *</span>
<span class="cm"> * @addr:		mapped virtual address</span>
<span class="cm"> * @base:		bus base address</span>
<span class="cm"> * @is_iomem:		is this io memory ?</span>
<span class="cm"> * @size:		size in byte</span>
<span class="cm"> * @offset:		offset from the base address</span>
<span class="cm"> * @io_reserved_vm:     The VM system has a refcount in @io_reserved_count</span>
<span class="cm"> * @io_reserved_count:  Refcounting the numbers of callers to ttm_mem_io_reserve</span>
<span class="cm"> *</span>
<span class="cm"> * Structure indicating the bus placement of an object.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ttm_bus_placement</span> <span class="p">{</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">offset</span><span class="p">;</span>
	<span class="n">bool</span>		<span class="n">is_iomem</span><span class="p">;</span>
	<span class="n">bool</span>		<span class="n">io_reserved_vm</span><span class="p">;</span>
	<span class="kt">uint64_t</span>        <span class="n">io_reserved_count</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * struct ttm_mem_reg</span>
<span class="cm"> *</span>
<span class="cm"> * @mm_node: Memory manager node.</span>
<span class="cm"> * @size: Requested size of memory region.</span>
<span class="cm"> * @num_pages: Actual size of memory region in pages.</span>
<span class="cm"> * @page_alignment: Page alignment.</span>
<span class="cm"> * @placement: Placement flags.</span>
<span class="cm"> * @bus: Placement on io bus accessible to the CPU</span>
<span class="cm"> *</span>
<span class="cm"> * Structure indicating the placement and space resources used by a</span>
<span class="cm"> * buffer object.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mm_node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_pages</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">page_alignment</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mem_type</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">placement</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_bus_placement</span> <span class="n">bus</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ttm_bo_type</span>
<span class="cm"> *</span>
<span class="cm"> * @ttm_bo_type_device:	These are &#39;normal&#39; buffers that can</span>
<span class="cm"> * be mmapped by user space. Each of these bos occupy a slot in the</span>
<span class="cm"> * device address space, that can be used for normal vm operations.</span>
<span class="cm"> *</span>
<span class="cm"> * @ttm_bo_type_kernel: These buffers are like ttm_bo_type_device buffers,</span>
<span class="cm"> * but they cannot be accessed from user-space. For kernel-only use.</span>
<span class="cm"> *</span>
<span class="cm"> * @ttm_bo_type_sg: Buffer made from dmabuf sg table shared with another</span>
<span class="cm"> * driver.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">ttm_bo_type</span> <span class="p">{</span>
	<span class="n">ttm_bo_type_device</span><span class="p">,</span>
	<span class="n">ttm_bo_type_kernel</span><span class="p">,</span>
	<span class="n">ttm_bo_type_sg</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ttm_tt</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ttm_buffer_object</span>
<span class="cm"> *</span>
<span class="cm"> * @bdev: Pointer to the buffer object device structure.</span>
<span class="cm"> * @buffer_start: The virtual user-space start address of ttm_bo_type_user</span>
<span class="cm"> * buffers.</span>
<span class="cm"> * @type: The bo type.</span>
<span class="cm"> * @destroy: Destruction function. If NULL, kfree is used.</span>
<span class="cm"> * @num_pages: Actual number of pages.</span>
<span class="cm"> * @addr_space_offset: Address space offset.</span>
<span class="cm"> * @acc_size: Accounted size for this object.</span>
<span class="cm"> * @kref: Reference count of this buffer object. When this refcount reaches</span>
<span class="cm"> * zero, the object is put on the delayed delete list.</span>
<span class="cm"> * @list_kref: List reference count of this buffer object. This member is</span>
<span class="cm"> * used to avoid destruction while the buffer object is still on a list.</span>
<span class="cm"> * Lru lists may keep one refcount, the delayed delete list, and kref != 0</span>
<span class="cm"> * keeps one refcount. When this refcount reaches zero,</span>
<span class="cm"> * the object is destroyed.</span>
<span class="cm"> * @event_queue: Queue for processes waiting on buffer object status change.</span>
<span class="cm"> * @mem: structure describing current placement.</span>
<span class="cm"> * @persistent_swap_storage: Usually the swap storage is deleted for buffers</span>
<span class="cm"> * pinned in physical memory. If this behaviour is not desired, this member</span>
<span class="cm"> * holds a pointer to a persistent shmem object.</span>
<span class="cm"> * @ttm: TTM structure holding system pages.</span>
<span class="cm"> * @evicted: Whether the object was evicted without user-space knowing.</span>
<span class="cm"> * @cpu_writes: For synchronization. Number of cpu writers.</span>
<span class="cm"> * @lru: List head for the lru list.</span>
<span class="cm"> * @ddestroy: List head for the delayed destroy list.</span>
<span class="cm"> * @swap: List head for swap LRU list.</span>
<span class="cm"> * @val_seq: Sequence of the validation holding the @reserved lock.</span>
<span class="cm"> * Used to avoid starvation when many processes compete to validate the</span>
<span class="cm"> * buffer. This member is protected by the bo_device::lru_lock.</span>
<span class="cm"> * @seq_valid: The value of @val_seq is valid. This value is protected by</span>
<span class="cm"> * the bo_device::lru_lock.</span>
<span class="cm"> * @reserved: Deadlock-free lock used for synchronization state transitions.</span>
<span class="cm"> * @sync_obj_arg: Opaque argument to synchronization object function.</span>
<span class="cm"> * @sync_obj: Pointer to a synchronization object.</span>
<span class="cm"> * @priv_flags: Flags describing buffer object internal state.</span>
<span class="cm"> * @vm_rb: Rb node for the vm rb tree.</span>
<span class="cm"> * @vm_node: Address space manager node.</span>
<span class="cm"> * @offset: The current GPU offset, which can have different meanings</span>
<span class="cm"> * depending on the memory type. For SYSTEM type memory, it should be 0.</span>
<span class="cm"> * @cur_placement: Hint of current placement.</span>
<span class="cm"> *</span>
<span class="cm"> * Base class for TTM buffer object, that deals with data placement and CPU</span>
<span class="cm"> * mappings. GPU mappings are really up to the driver, but for simpler GPUs</span>
<span class="cm"> * the driver can usually use the placement offset @offset directly as the</span>
<span class="cm"> * GPU virtual address. For drivers implementing multiple</span>
<span class="cm"> * GPU memory manager contexts, the driver should manage the address space</span>
<span class="cm"> * in these contexts separately and use these objects to get the correct</span>
<span class="cm"> * placement and caching for these GPU maps. This makes it possible to use</span>
<span class="cm"> * these objects for even quite elaborate memory management schemes.</span>
<span class="cm"> * The destroy member, the API visibility of this object makes it possible</span>
<span class="cm"> * to derive driver specific types.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="p">{</span>
	<span class="cm">/**</span>
<span class="cm">	 * Members constant at init.</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">ttm_bo_global</span> <span class="o">*</span><span class="n">glob</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffer_start</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ttm_bo_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_pages</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">addr_space_offset</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">acc_size</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	* Members not needing protection.</span>
<span class="cm">	*/</span>

	<span class="k">struct</span> <span class="n">kref</span> <span class="n">kref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">list_kref</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">event_queue</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Members protected by the bo::reserved lock.</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">ttm_mem_reg</span> <span class="n">mem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">persistent_swap_storage</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_tt</span> <span class="o">*</span><span class="n">ttm</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">evicted</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Members protected by the bo::reserved lock only when written to.</span>
<span class="cm">	 */</span>

	<span class="n">atomic_t</span> <span class="n">cpu_writers</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Members protected by the bdev::lru_lock.</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">lru</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ddestroy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">swap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">io_reserve_lru</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">val_seq</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">seq_valid</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Members protected by the bdev::lru_lock</span>
<span class="cm">	 * only when written to.</span>
<span class="cm">	 */</span>

	<span class="n">atomic_t</span> <span class="n">reserved</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Members protected by struct buffer_object_device::fence_lock</span>
<span class="cm">	 * In addition, setting sync_obj to anything else</span>
<span class="cm">	 * than NULL requires bo::reserved to be held. This allows for</span>
<span class="cm">	 * checking NULL while reserved but not holding the mentioned lock.</span>
<span class="cm">	 */</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">sync_obj_arg</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">sync_obj</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">priv_flags</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Members protected by the bdev::vm_lock</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">vm_rb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_mm_node</span> <span class="o">*</span><span class="n">vm_node</span><span class="p">;</span>


	<span class="cm">/**</span>
<span class="cm">	 * Special members that are protected by the reserve lock</span>
<span class="cm">	 * and the bo::lock when written to. Can be read with</span>
<span class="cm">	 * either of these locks held.</span>
<span class="cm">	 */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cur_placement</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sg_table</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ttm_bo_kmap_obj</span>
<span class="cm"> *</span>
<span class="cm"> * @virtual: The current kernel virtual address.</span>
<span class="cm"> * @page: The page when kmap&#39;ing a single page.</span>
<span class="cm"> * @bo_kmap_type: Type of bo_kmap.</span>
<span class="cm"> *</span>
<span class="cm"> * Object describing a kernel mapping. Since a TTM bo may be located</span>
<span class="cm"> * in various memory types with various caching policies, the</span>
<span class="cm"> * mapping can either be an ioremap, a vmap, a kmap or part of a</span>
<span class="cm"> * premapped region.</span>
<span class="cm"> */</span>

<span class="cp">#define TTM_BO_MAP_IOMEM_MASK 0x80</span>
<span class="k">struct</span> <span class="n">ttm_bo_kmap_obj</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="k">virtual</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">ttm_bo_map_iomap</span>        <span class="o">=</span> <span class="mi">1</span> <span class="o">|</span> <span class="n">TTM_BO_MAP_IOMEM_MASK</span><span class="p">,</span>
		<span class="n">ttm_bo_map_vmap</span>         <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
		<span class="n">ttm_bo_map_kmap</span>         <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
		<span class="n">ttm_bo_map_premapped</span>    <span class="o">=</span> <span class="mi">4</span> <span class="o">|</span> <span class="n">TTM_BO_MAP_IOMEM_MASK</span><span class="p">,</span>
	<span class="p">}</span> <span class="n">bo_kmap_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_reference - reference a struct ttm_buffer_object</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: The buffer object.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a refcounted pointer to a buffer object.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span>
<span class="nf">ttm_bo_reference</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bo</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bo</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_wait - wait for buffer idle.</span>
<span class="cm"> *</span>
<span class="cm"> * @bo:  The buffer object.</span>
<span class="cm"> * @interruptible:  Use interruptible wait.</span>
<span class="cm"> * @no_wait:  Return immediately if buffer is busy.</span>
<span class="cm"> *</span>
<span class="cm"> * This function must be called with the bo::mutex held, and makes</span>
<span class="cm"> * sure any previous rendering to the buffer is completed.</span>
<span class="cm"> * Note: It might be necessary to block validations before the</span>
<span class="cm"> * wait by reserving the buffer.</span>
<span class="cm"> * Returns -EBUSY if no_wait is true and the buffer is busy.</span>
<span class="cm"> * Returns -ERESTARTSYS if interrupted by a signal.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span> <span class="n">bool</span> <span class="n">lazy</span><span class="p">,</span>
		       <span class="n">bool</span> <span class="n">interruptible</span><span class="p">,</span> <span class="n">bool</span> <span class="n">no_wait</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * ttm_bo_validate</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: The buffer object.</span>
<span class="cm"> * @placement: Proposed placement for the buffer object.</span>
<span class="cm"> * @interruptible: Sleep interruptible if sleeping.</span>
<span class="cm"> * @no_wait_reserve: Return immediately if other buffers are busy.</span>
<span class="cm"> * @no_wait_gpu: Return immediately if the GPU is busy.</span>
<span class="cm"> *</span>
<span class="cm"> * Changes placement and caching policy of the buffer object</span>
<span class="cm"> * according proposed placement.</span>
<span class="cm"> * Returns</span>
<span class="cm"> * -EINVAL on invalid proposed placement.</span>
<span class="cm"> * -ENOMEM on out-of-memory condition.</span>
<span class="cm"> * -EBUSY if no_wait is true and buffer busy.</span>
<span class="cm"> * -ERESTARTSYS if interrupted by a signal.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_validate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ttm_placement</span> <span class="o">*</span><span class="n">placement</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">interruptible</span><span class="p">,</span> <span class="n">bool</span> <span class="n">no_wait_reserve</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">no_wait_gpu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_unref</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: The buffer object.</span>
<span class="cm"> *</span>
<span class="cm"> * Unreference and clear a pointer to a buffer object.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_bo_unref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">**</span><span class="n">bo</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * ttm_bo_list_ref_sub</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: The buffer object.</span>
<span class="cm"> * @count: The number of references with which to decrease @bo::list_kref;</span>
<span class="cm"> * @never_free: The refcount should not reach zero with this operation.</span>
<span class="cm"> *</span>
<span class="cm"> * Release @count lru list references to this buffer object.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_bo_list_ref_sub</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">never_free</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_add_to_lru</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: The buffer object.</span>
<span class="cm"> *</span>
<span class="cm"> * Add this bo to the relevant mem type lru and, if it&#39;s backed by</span>
<span class="cm"> * system pages (ttms) to the swap list.</span>
<span class="cm"> * This function must be called with struct ttm_bo_global::lru_lock held, and</span>
<span class="cm"> * is typically called immediately prior to unreserving a bo.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_bo_add_to_lru</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_del_from_lru</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: The buffer object.</span>
<span class="cm"> *</span>
<span class="cm"> * Remove this bo from all lru lists used to lookup and reserve an object.</span>
<span class="cm"> * This function must be called with struct ttm_bo_global::lru_lock held,</span>
<span class="cm"> * and is usually called just immediately after the bo has been reserved to</span>
<span class="cm"> * avoid recursive reservation from lru lists.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_del_from_lru</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * ttm_bo_lock_delayed_workqueue</span>
<span class="cm"> *</span>
<span class="cm"> * Prevent the delayed workqueue from running.</span>
<span class="cm"> * Returns</span>
<span class="cm"> * True if the workqueue was queued at the time</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_lock_delayed_workqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_unlock_delayed_workqueue</span>
<span class="cm"> *</span>
<span class="cm"> * Allows the delayed workqueue to run.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_bo_unlock_delayed_workqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">resched</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_synccpu_write_grab</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: The buffer object:</span>
<span class="cm"> * @no_wait: Return immediately if buffer is busy.</span>
<span class="cm"> *</span>
<span class="cm"> * Synchronizes a buffer object for CPU RW access. This means</span>
<span class="cm"> * blocking command submission that affects the buffer and</span>
<span class="cm"> * waiting for buffer idle. This lock is recursive.</span>
<span class="cm"> * Returns</span>
<span class="cm"> * -EBUSY if the buffer is busy and no_wait is true.</span>
<span class="cm"> * -ERESTARTSYS if interrupted by a signal.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span>
<span class="n">ttm_bo_synccpu_write_grab</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span> <span class="n">bool</span> <span class="n">no_wait</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_synccpu_write_release:</span>
<span class="cm"> *</span>
<span class="cm"> * @bo : The buffer object.</span>
<span class="cm"> *</span>
<span class="cm"> * Releases a synccpu lock.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_bo_synccpu_write_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_acc_size</span>
<span class="cm"> *</span>
<span class="cm"> * @bdev: Pointer to a ttm_bo_device struct.</span>
<span class="cm"> * @bo_size: size of the buffer object in byte.</span>
<span class="cm"> * @struct_size: size of the structure holding buffer object datas</span>
<span class="cm"> *</span>
<span class="cm"> * Returns size to account for a buffer object</span>
<span class="cm"> */</span>
<span class="kt">size_t</span> <span class="n">ttm_bo_acc_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bo_size</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="n">struct_size</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="n">ttm_bo_dma_acc_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bo_size</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="n">struct_size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_init</span>
<span class="cm"> *</span>
<span class="cm"> * @bdev: Pointer to a ttm_bo_device struct.</span>
<span class="cm"> * @bo: Pointer to a ttm_buffer_object to be initialized.</span>
<span class="cm"> * @size: Requested size of buffer object.</span>
<span class="cm"> * @type: Requested type of buffer object.</span>
<span class="cm"> * @flags: Initial placement flags.</span>
<span class="cm"> * @page_alignment: Data alignment in pages.</span>
<span class="cm"> * @buffer_start: Virtual address of user space data backing a</span>
<span class="cm"> * user buffer object.</span>
<span class="cm"> * @interruptible: If needing to sleep to wait for GPU resources,</span>
<span class="cm"> * sleep interruptible.</span>
<span class="cm"> * @persistent_swap_storage: Usually the swap storage is deleted for buffers</span>
<span class="cm"> * pinned in physical memory. If this behaviour is not desired, this member</span>
<span class="cm"> * holds a pointer to a persistent shmem object. Typically, this would</span>
<span class="cm"> * point to the shmem object backing a GEM object if TTM is used to back a</span>
<span class="cm"> * GEM user interface.</span>
<span class="cm"> * @acc_size: Accounted size for this object.</span>
<span class="cm"> * @destroy: Destroy function. Use NULL for kfree().</span>
<span class="cm"> *</span>
<span class="cm"> * This function initializes a pre-allocated struct ttm_buffer_object.</span>
<span class="cm"> * As this object may be part of a larger structure, this function,</span>
<span class="cm"> * together with the @destroy function,</span>
<span class="cm"> * enables driver-specific objects derived from a ttm_buffer_object.</span>
<span class="cm"> * On successful return, the object kref and list_kref are set to 1.</span>
<span class="cm"> * If a failure occurs, the function will call the @destroy function, or</span>
<span class="cm"> * kfree() if @destroy is NULL. Thus, after a failure, dereferencing @bo is</span>
<span class="cm"> * illegal and will likely cause memory corruption.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns</span>
<span class="cm"> * -ENOMEM: Out of memory.</span>
<span class="cm"> * -EINVAL: Invalid placement flags.</span>
<span class="cm"> * -ERESTARTSYS: Interrupted by signal while sleeping waiting for resources.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">ttm_bo_type</span> <span class="n">type</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ttm_placement</span> <span class="o">*</span><span class="n">placement</span><span class="p">,</span>
			<span class="kt">uint32_t</span> <span class="n">page_alignment</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffer_start</span><span class="p">,</span>
			<span class="n">bool</span> <span class="n">interrubtible</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">persistent_swap_storage</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">acc_size</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sg_table</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
			<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="p">));</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_synccpu_object_init</span>
<span class="cm"> *</span>
<span class="cm"> * @bdev: Pointer to a ttm_bo_device struct.</span>
<span class="cm"> * @bo: Pointer to a ttm_buffer_object to be initialized.</span>
<span class="cm"> * @size: Requested size of buffer object.</span>
<span class="cm"> * @type: Requested type of buffer object.</span>
<span class="cm"> * @flags: Initial placement flags.</span>
<span class="cm"> * @page_alignment: Data alignment in pages.</span>
<span class="cm"> * @buffer_start: Virtual address of user space data backing a</span>
<span class="cm"> * user buffer object.</span>
<span class="cm"> * @interruptible: If needing to sleep while waiting for GPU resources,</span>
<span class="cm"> * sleep interruptible.</span>
<span class="cm"> * @persistent_swap_storage: Usually the swap storage is deleted for buffers</span>
<span class="cm"> * pinned in physical memory. If this behaviour is not desired, this member</span>
<span class="cm"> * holds a pointer to a persistent shmem object. Typically, this would</span>
<span class="cm"> * point to the shmem object backing a GEM object if TTM is used to back a</span>
<span class="cm"> * GEM user interface.</span>
<span class="cm"> * @p_bo: On successful completion *p_bo points to the created object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates a ttm_buffer_object, and then calls ttm_bo_init</span>
<span class="cm"> * on that object. The destroy function is set to kfree().</span>
<span class="cm"> * Returns</span>
<span class="cm"> * -ENOMEM: Out of memory.</span>
<span class="cm"> * -EINVAL: Invalid placement flags.</span>
<span class="cm"> * -ERESTARTSYS: Interrupted by signal while waiting for resources.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">ttm_bo_type</span> <span class="n">type</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ttm_placement</span> <span class="o">*</span><span class="n">placement</span><span class="p">,</span>
				<span class="kt">uint32_t</span> <span class="n">page_alignment</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffer_start</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">interruptible</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">persistent_swap_storage</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">**</span><span class="n">p_bo</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_check_placement</span>
<span class="cm"> *</span>
<span class="cm"> * @bo:		the buffer object.</span>
<span class="cm"> * @placement:	placements</span>
<span class="cm"> *</span>
<span class="cm"> * Performs minimal validity checking on an intended change of</span>
<span class="cm"> * placement flags.</span>
<span class="cm"> * Returns</span>
<span class="cm"> * -EINVAL: Intended change is invalid or not allowed.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_check_placement</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ttm_placement</span> <span class="o">*</span><span class="n">placement</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_init_mm</span>
<span class="cm"> *</span>
<span class="cm"> * @bdev: Pointer to a ttm_bo_device struct.</span>
<span class="cm"> * @mem_type: The memory type.</span>
<span class="cm"> * @p_size: size managed area in pages.</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize a manager for a given memory type.</span>
<span class="cm"> * Note: if part of driver firstopen, it must be protected from a</span>
<span class="cm"> * potentially racing lastclose.</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EINVAL: invalid size or memory type.</span>
<span class="cm"> * -ENOMEM: Not enough memory.</span>
<span class="cm"> * May also return driver-specified errors.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_init_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">type</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p_size</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * ttm_bo_clean_mm</span>
<span class="cm"> *</span>
<span class="cm"> * @bdev: Pointer to a ttm_bo_device struct.</span>
<span class="cm"> * @mem_type: The memory type.</span>
<span class="cm"> *</span>
<span class="cm"> * Take down a manager for a given memory type after first walking</span>
<span class="cm"> * the LRU list to evict any buffers left alive.</span>
<span class="cm"> *</span>
<span class="cm"> * Normally, this function is part of lastclose() or unload(), and at that</span>
<span class="cm"> * point there shouldn&#39;t be any buffers left created by user-space, since</span>
<span class="cm"> * there should&#39;ve been removed by the file descriptor release() method.</span>
<span class="cm"> * However, before this function is run, make sure to signal all sync objects,</span>
<span class="cm"> * and verify that the delayed delete queue is empty. The driver must also</span>
<span class="cm"> * make sure that there are no NO_EVICT buffers present in this memory type</span>
<span class="cm"> * when the call is made.</span>
<span class="cm"> *</span>
<span class="cm"> * If this function is part of a VT switch, the caller must make sure that</span>
<span class="cm"> * there are no appications currently validating buffers before this</span>
<span class="cm"> * function is called. The caller can do that by first taking the</span>
<span class="cm"> * struct ttm_bo_device::ttm_lock in write mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EINVAL: invalid or uninitialized memory type.</span>
<span class="cm"> * -EBUSY: There are still buffers left in this memory type.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_clean_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mem_type</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_evict_mm</span>
<span class="cm"> *</span>
<span class="cm"> * @bdev: Pointer to a ttm_bo_device struct.</span>
<span class="cm"> * @mem_type: The memory type.</span>
<span class="cm"> *</span>
<span class="cm"> * Evicts all buffers on the lru list of the memory type.</span>
<span class="cm"> * This is normally part of a VT switch or an</span>
<span class="cm"> * out-of-memory-space-due-to-fragmentation handler.</span>
<span class="cm"> * The caller must make sure that there are no other processes</span>
<span class="cm"> * currently validating buffers, and can do that by taking the</span>
<span class="cm"> * struct ttm_bo_device::ttm_lock in write mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EINVAL: Invalid or uninitialized memory type.</span>
<span class="cm"> * -ERESTARTSYS: The call was interrupted by a signal while waiting to</span>
<span class="cm"> * evict a buffer.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_evict_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mem_type</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_kmap_obj_virtual</span>
<span class="cm"> *</span>
<span class="cm"> * @map: A struct ttm_bo_kmap_obj returned from ttm_bo_kmap.</span>
<span class="cm"> * @is_iomem: Pointer to an integer that on return indicates 1 if the</span>
<span class="cm"> * virtual map is io memory, 0 if normal memory.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the virtual address of a buffer object area mapped by ttm_bo_kmap.</span>
<span class="cm"> * If *is_iomem is 1 on return, the virtual address points to an io memory area,</span>
<span class="cm"> * that should strictly be accessed by the iowriteXX() and similar functions.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">ttm_kmap_obj_virtual</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_kmap_obj</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
					 <span class="n">bool</span> <span class="o">*</span><span class="n">is_iomem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">is_iomem</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">bo_kmap_type</span> <span class="o">&amp;</span> <span class="n">TTM_BO_MAP_IOMEM_MASK</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">map</span><span class="o">-&gt;</span><span class="k">virtual</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_kmap</span>
<span class="cm"> *</span>
<span class="cm"> * @bo: The buffer object.</span>
<span class="cm"> * @start_page: The first page to map.</span>
<span class="cm"> * @num_pages: Number of pages to map.</span>
<span class="cm"> * @map: pointer to a struct ttm_bo_kmap_obj representing the map.</span>
<span class="cm"> *</span>
<span class="cm"> * Sets up a kernel virtual mapping, using ioremap, vmap or kmap to the</span>
<span class="cm"> * data in the buffer object. The ttm_kmap_obj_virtual function can then be</span>
<span class="cm"> * used to obtain a virtual address to the data.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns</span>
<span class="cm"> * -ENOMEM: Out of memory.</span>
<span class="cm"> * -EINVAL: Invalid range.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_kmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_page</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ttm_bo_kmap_obj</span> <span class="o">*</span><span class="n">map</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_kunmap</span>
<span class="cm"> *</span>
<span class="cm"> * @map: Object describing the map to unmap.</span>
<span class="cm"> *</span>
<span class="cm"> * Unmaps a kernel map set up by ttm_bo_kmap.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_bo_kunmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_kmap_obj</span> <span class="o">*</span><span class="n">map</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_fbdev_mmap - mmap fbdev memory backed by a ttm buffer object.</span>
<span class="cm"> *</span>
<span class="cm"> * @vma:       vma as input from the fbdev mmap method.</span>
<span class="cm"> * @bo:        The bo backing the address space. The address space will</span>
<span class="cm"> * have the same size as the bo, and start at offset 0.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is intended to be called by the fbdev mmap method</span>
<span class="cm"> * if the fbdev address space is to be backed by a bo.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_fbdev_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ttm_buffer_object</span> <span class="o">*</span><span class="n">bo</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_mmap - mmap out of the ttm device address space.</span>
<span class="cm"> *</span>
<span class="cm"> * @filp:      filp as input from the mmap method.</span>
<span class="cm"> * @vma:       vma as input from the mmap method.</span>
<span class="cm"> * @bdev:      Pointer to the ttm_bo_device with the address space manager.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is intended to be called by the device mmap method.</span>
<span class="cm"> * if the device address space is to be backed by the bo manager.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ttm_bo_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ttm_bo_io</span>
<span class="cm"> *</span>
<span class="cm"> * @bdev:      Pointer to the struct ttm_bo_device.</span>
<span class="cm"> * @filp:      Pointer to the struct file attempting to read / write.</span>
<span class="cm"> * @wbuf:      User-space pointer to address of buffer to write. NULL on read.</span>
<span class="cm"> * @rbuf:      User-space pointer to address of buffer to read into.</span>
<span class="cm"> * Null on write.</span>
<span class="cm"> * @count:     Number of bytes to read / write.</span>
<span class="cm"> * @f_pos:     Pointer to current file position.</span>
<span class="cm"> * @write:     1 for read, 0 for write.</span>
<span class="cm"> *</span>
<span class="cm"> * This function implements read / write into ttm buffer objects, and is</span>
<span class="cm"> * intended to</span>
<span class="cm"> * be called from the fops::read and fops::write method.</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * See man (2) write, man(2) read. In particular,</span>
<span class="cm"> * the function may return -ERESTARTSYS if</span>
<span class="cm"> * interrupted by a signal.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">ttm_bo_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">f_pos</span><span class="p">,</span> <span class="n">bool</span> <span class="n">write</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ttm_bo_swapout_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_bo_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
