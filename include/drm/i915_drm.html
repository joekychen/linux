<!DOCTYPE html>
<html><head><title>joekychen/linux » include › drm › i915_drm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>i915_drm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the</span>
<span class="cm"> * &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="cm"> * without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="cm"> * distribute, sub license, and/or sell copies of the Software, and to</span>
<span class="cm"> * permit persons to whom the Software is furnished to do so, subject to</span>
<span class="cm"> * the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice (including the</span>
<span class="cm"> * next paragraph) shall be included in all copies or substantial portions</span>
<span class="cm"> * of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="cm"> * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.</span>
<span class="cm"> * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR</span>
<span class="cm"> * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,</span>
<span class="cm"> * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE</span>
<span class="cm"> * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _I915_DRM_H_</span>
<span class="cp">#define _I915_DRM_H_</span>

<span class="cp">#include &quot;drm.h&quot;</span>

<span class="cm">/* Please note that modifications to all structs defined here are</span>
<span class="cm"> * subject to backwards-compatibility constraints.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cm">/* For use by IPS driver */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i915_read_mch_val</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">i915_gpu_raise</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">i915_gpu_lower</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">i915_gpu_busy</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">i915_gpu_turbo_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Each region is a minimum of 16k, and there are at most 255 of them.</span>
<span class="cm"> */</span>
<span class="cp">#define I915_NR_TEX_REGIONS 255	</span><span class="cm">/* table size 2k - maximum due to use</span>
<span class="cm">				 * of chars for next/prev indices */</span><span class="cp"></span>
<span class="cp">#define I915_LOG_MIN_TEX_REGION_SIZE 14</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_drm_i915_init</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">I915_INIT_DMA</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
		<span class="n">I915_CLEANUP_DMA</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
		<span class="n">I915_RESUME_DMA</span> <span class="o">=</span> <span class="mh">0x03</span>
	<span class="p">}</span> <span class="n">func</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mmio_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sarea_priv_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ring_start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ring_end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ring_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">front_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">back_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">w</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pitch</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pitch_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">back_pitch</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth_pitch</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chipset</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_i915_init_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_drm_i915_sarea</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_tex_region</span> <span class="n">texList</span><span class="p">[</span><span class="n">I915_NR_TEX_REGIONS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">last_upload</span><span class="p">;</span>	<span class="cm">/* last time texture was uploaded */</span>
	<span class="kt">int</span> <span class="n">last_enqueue</span><span class="p">;</span>	<span class="cm">/* last time a buffer was enqueued */</span>
	<span class="kt">int</span> <span class="n">last_dispatch</span><span class="p">;</span>	<span class="cm">/* age of the most recently dispatched buffer */</span>
	<span class="kt">int</span> <span class="n">ctxOwner</span><span class="p">;</span>		<span class="cm">/* last context to upload state */</span>
	<span class="kt">int</span> <span class="n">texAge</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pf_enabled</span><span class="p">;</span>		<span class="cm">/* is pageflipping allowed? */</span>
	<span class="kt">int</span> <span class="n">pf_active</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pf_current_page</span><span class="p">;</span>	<span class="cm">/* which buffer is being displayed? */</span>
	<span class="kt">int</span> <span class="n">perf_boxes</span><span class="p">;</span>		<span class="cm">/* performance boxes to be displayed */</span>
	<span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>      <span class="cm">/* screen size in pixels */</span>

	<span class="n">drm_handle_t</span> <span class="n">front_handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">front_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">front_size</span><span class="p">;</span>

	<span class="n">drm_handle_t</span> <span class="n">back_handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">back_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">back_size</span><span class="p">;</span>

	<span class="n">drm_handle_t</span> <span class="n">depth_handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth_size</span><span class="p">;</span>

	<span class="n">drm_handle_t</span> <span class="n">tex_handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tex_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tex_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">log_tex_granularity</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pitch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rotation</span><span class="p">;</span>           <span class="cm">/* 0, 90, 180 or 270 */</span>
	<span class="kt">int</span> <span class="n">rotated_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rotated_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rotated_pitch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">virtualX</span><span class="p">,</span> <span class="n">virtualY</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">front_tiled</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">back_tiled</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth_tiled</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rotated_tiled</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rotated2_tiled</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">pipeA_x</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pipeA_y</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pipeA_w</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pipeA_h</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pipeB_x</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pipeB_y</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pipeB_w</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pipeB_h</span><span class="p">;</span>

	<span class="cm">/* fill out some space for old userspace triple buffer */</span>
	<span class="n">drm_handle_t</span> <span class="n">unused_handle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">unused1</span><span class="p">,</span> <span class="n">unused2</span><span class="p">,</span> <span class="n">unused3</span><span class="p">;</span>

	<span class="cm">/* buffer object handles for static buffers. May change</span>
<span class="cm">	 * over the lifetime of the client.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">front_bo_handle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">back_bo_handle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">unused_bo_handle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">depth_bo_handle</span><span class="p">;</span>

<span class="p">}</span> <span class="n">drm_i915_sarea_t</span><span class="p">;</span>

<span class="cm">/* due to userspace building against these headers we need some compat here */</span>
<span class="cp">#define planeA_x pipeA_x</span>
<span class="cp">#define planeA_y pipeA_y</span>
<span class="cp">#define planeA_w pipeA_w</span>
<span class="cp">#define planeA_h pipeA_h</span>
<span class="cp">#define planeB_x pipeB_x</span>
<span class="cp">#define planeB_y pipeB_y</span>
<span class="cp">#define planeB_w pipeB_w</span>
<span class="cp">#define planeB_h pipeB_h</span>

<span class="cm">/* Flags for perf_boxes</span>
<span class="cm"> */</span>
<span class="cp">#define I915_BOX_RING_EMPTY    0x1</span>
<span class="cp">#define I915_BOX_FLIP          0x2</span>
<span class="cp">#define I915_BOX_WAIT          0x4</span>
<span class="cp">#define I915_BOX_TEXTURE_LOAD  0x8</span>
<span class="cp">#define I915_BOX_LOST_CONTEXT  0x10</span>

<span class="cm">/* I915 specific ioctls</span>
<span class="cm"> * The device specific ioctl range is 0x40 to 0x79.</span>
<span class="cm"> */</span>
<span class="cp">#define DRM_I915_INIT		0x00</span>
<span class="cp">#define DRM_I915_FLUSH		0x01</span>
<span class="cp">#define DRM_I915_FLIP		0x02</span>
<span class="cp">#define DRM_I915_BATCHBUFFER	0x03</span>
<span class="cp">#define DRM_I915_IRQ_EMIT	0x04</span>
<span class="cp">#define DRM_I915_IRQ_WAIT	0x05</span>
<span class="cp">#define DRM_I915_GETPARAM	0x06</span>
<span class="cp">#define DRM_I915_SETPARAM	0x07</span>
<span class="cp">#define DRM_I915_ALLOC		0x08</span>
<span class="cp">#define DRM_I915_FREE		0x09</span>
<span class="cp">#define DRM_I915_INIT_HEAP	0x0a</span>
<span class="cp">#define DRM_I915_CMDBUFFER	0x0b</span>
<span class="cp">#define DRM_I915_DESTROY_HEAP	0x0c</span>
<span class="cp">#define DRM_I915_SET_VBLANK_PIPE	0x0d</span>
<span class="cp">#define DRM_I915_GET_VBLANK_PIPE	0x0e</span>
<span class="cp">#define DRM_I915_VBLANK_SWAP	0x0f</span>
<span class="cp">#define DRM_I915_HWS_ADDR	0x11</span>
<span class="cp">#define DRM_I915_GEM_INIT	0x13</span>
<span class="cp">#define DRM_I915_GEM_EXECBUFFER	0x14</span>
<span class="cp">#define DRM_I915_GEM_PIN	0x15</span>
<span class="cp">#define DRM_I915_GEM_UNPIN	0x16</span>
<span class="cp">#define DRM_I915_GEM_BUSY	0x17</span>
<span class="cp">#define DRM_I915_GEM_THROTTLE	0x18</span>
<span class="cp">#define DRM_I915_GEM_ENTERVT	0x19</span>
<span class="cp">#define DRM_I915_GEM_LEAVEVT	0x1a</span>
<span class="cp">#define DRM_I915_GEM_CREATE	0x1b</span>
<span class="cp">#define DRM_I915_GEM_PREAD	0x1c</span>
<span class="cp">#define DRM_I915_GEM_PWRITE	0x1d</span>
<span class="cp">#define DRM_I915_GEM_MMAP	0x1e</span>
<span class="cp">#define DRM_I915_GEM_SET_DOMAIN	0x1f</span>
<span class="cp">#define DRM_I915_GEM_SW_FINISH	0x20</span>
<span class="cp">#define DRM_I915_GEM_SET_TILING	0x21</span>
<span class="cp">#define DRM_I915_GEM_GET_TILING	0x22</span>
<span class="cp">#define DRM_I915_GEM_GET_APERTURE 0x23</span>
<span class="cp">#define DRM_I915_GEM_MMAP_GTT	0x24</span>
<span class="cp">#define DRM_I915_GET_PIPE_FROM_CRTC_ID	0x25</span>
<span class="cp">#define DRM_I915_GEM_MADVISE	0x26</span>
<span class="cp">#define DRM_I915_OVERLAY_PUT_IMAGE	0x27</span>
<span class="cp">#define DRM_I915_OVERLAY_ATTRS	0x28</span>
<span class="cp">#define DRM_I915_GEM_EXECBUFFER2	0x29</span>
<span class="cp">#define DRM_I915_GET_SPRITE_COLORKEY	0x2a</span>
<span class="cp">#define DRM_I915_SET_SPRITE_COLORKEY	0x2b</span>

<span class="cp">#define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)</span>
<span class="cp">#define DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)</span>
<span class="cp">#define DRM_IOCTL_I915_FLIP		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLIP)</span>
<span class="cp">#define DRM_IOCTL_I915_BATCHBUFFER	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_BATCHBUFFER, drm_i915_batchbuffer_t)</span>
<span class="cp">#define DRM_IOCTL_I915_IRQ_EMIT         DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_IRQ_EMIT, drm_i915_irq_emit_t)</span>
<span class="cp">#define DRM_IOCTL_I915_IRQ_WAIT         DRM_IOW( DRM_COMMAND_BASE + DRM_I915_IRQ_WAIT, drm_i915_irq_wait_t)</span>
<span class="cp">#define DRM_IOCTL_I915_GETPARAM         DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GETPARAM, drm_i915_getparam_t)</span>
<span class="cp">#define DRM_IOCTL_I915_SETPARAM         DRM_IOW( DRM_COMMAND_BASE + DRM_I915_SETPARAM, drm_i915_setparam_t)</span>
<span class="cp">#define DRM_IOCTL_I915_ALLOC            DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_ALLOC, drm_i915_mem_alloc_t)</span>
<span class="cp">#define DRM_IOCTL_I915_FREE             DRM_IOW( DRM_COMMAND_BASE + DRM_I915_FREE, drm_i915_mem_free_t)</span>
<span class="cp">#define DRM_IOCTL_I915_INIT_HEAP        DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT_HEAP, drm_i915_mem_init_heap_t)</span>
<span class="cp">#define DRM_IOCTL_I915_CMDBUFFER	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_CMDBUFFER, drm_i915_cmdbuffer_t)</span>
<span class="cp">#define DRM_IOCTL_I915_DESTROY_HEAP	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_DESTROY_HEAP, drm_i915_mem_destroy_heap_t)</span>
<span class="cp">#define DRM_IOCTL_I915_SET_VBLANK_PIPE	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_SET_VBLANK_PIPE, drm_i915_vblank_pipe_t)</span>
<span class="cp">#define DRM_IOCTL_I915_GET_VBLANK_PIPE	DRM_IOR( DRM_COMMAND_BASE + DRM_I915_GET_VBLANK_PIPE, drm_i915_vblank_pipe_t)</span>
<span class="cp">#define DRM_IOCTL_I915_VBLANK_SWAP	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_VBLANK_SWAP, drm_i915_vblank_swap_t)</span>
<span class="cp">#define DRM_IOCTL_I915_HWS_ADDR		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_HWS_ADDR, struct drm_i915_gem_init)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_INIT		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_INIT, struct drm_i915_gem_init)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_EXECBUFFER	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER, struct drm_i915_gem_execbuffer)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_EXECBUFFER2	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER2, struct drm_i915_gem_execbuffer2)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_PIN		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_PIN, struct drm_i915_gem_pin)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_UNPIN	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_UNPIN, struct drm_i915_gem_unpin)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_BUSY		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_BUSY, struct drm_i915_gem_busy)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_THROTTLE	DRM_IO ( DRM_COMMAND_BASE + DRM_I915_GEM_THROTTLE)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_ENTERVT	DRM_IO(DRM_COMMAND_BASE + DRM_I915_GEM_ENTERVT)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_LEAVEVT	DRM_IO(DRM_COMMAND_BASE + DRM_I915_GEM_LEAVEVT)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_CREATE, struct drm_i915_gem_create)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_PREAD	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_PREAD, struct drm_i915_gem_pread)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_PWRITE	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_PWRITE, struct drm_i915_gem_pwrite)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_MMAP		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP, struct drm_i915_gem_mmap)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_MMAP_GTT	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP_GTT, struct drm_i915_gem_mmap_gtt)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_SET_DOMAIN	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_SET_DOMAIN, struct drm_i915_gem_set_domain)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_SW_FINISH	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_SW_FINISH, struct drm_i915_gem_sw_finish)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_SET_TILING	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_SET_TILING, struct drm_i915_gem_set_tiling)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_GET_TILING	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_GET_TILING, struct drm_i915_gem_get_tiling)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_GET_APERTURE	DRM_IOR  (DRM_COMMAND_BASE + DRM_I915_GEM_GET_APERTURE, struct drm_i915_gem_get_aperture)</span>
<span class="cp">#define DRM_IOCTL_I915_GET_PIPE_FROM_CRTC_ID DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GET_PIPE_FROM_CRTC_ID, struct drm_i915_get_pipe_from_crtc_id)</span>
<span class="cp">#define DRM_IOCTL_I915_GEM_MADVISE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MADVISE, struct drm_i915_gem_madvise)</span>
<span class="cp">#define DRM_IOCTL_I915_OVERLAY_PUT_IMAGE	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_OVERLAY_PUT_IMAGE, struct drm_intel_overlay_put_image)</span>
<span class="cp">#define DRM_IOCTL_I915_OVERLAY_ATTRS	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_OVERLAY_ATTRS, struct drm_intel_overlay_attrs)</span>
<span class="cp">#define DRM_IOCTL_I915_SET_SPRITE_COLORKEY DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_SET_SPRITE_COLORKEY, struct drm_intel_sprite_colorkey)</span>
<span class="cp">#define DRM_IOCTL_I915_GET_SPRITE_COLORKEY DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_SET_SPRITE_COLORKEY, struct drm_intel_sprite_colorkey)</span>

<span class="cm">/* Allow drivers to submit batchbuffers directly to hardware, relying</span>
<span class="cm"> * on the security mechanisms provided by hardware.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_i915_batchbuffer</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">start</span><span class="p">;</span>		<span class="cm">/* agp offset */</span>
	<span class="kt">int</span> <span class="n">used</span><span class="p">;</span>		<span class="cm">/* nr bytes in use */</span>
	<span class="kt">int</span> <span class="n">DR1</span><span class="p">;</span>		<span class="cm">/* hw flags for GFX_OP_DRAWRECT_INFO */</span>
	<span class="kt">int</span> <span class="n">DR4</span><span class="p">;</span>		<span class="cm">/* window origin for GFX_OP_DRAWRECT_INFO */</span>
	<span class="kt">int</span> <span class="n">num_cliprects</span><span class="p">;</span>	<span class="cm">/* mulitpass with multiple cliprects? */</span>
	<span class="k">struct</span> <span class="n">drm_clip_rect</span> <span class="n">__user</span> <span class="o">*</span><span class="n">cliprects</span><span class="p">;</span>	<span class="cm">/* pointer to userspace cliprects */</span>
<span class="p">}</span> <span class="n">drm_i915_batchbuffer_t</span><span class="p">;</span>

<span class="cm">/* As above, but pass a pointer to userspace buffer which can be</span>
<span class="cm"> * validated by the kernel prior to sending to hardware.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_drm_i915_cmdbuffer</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>	<span class="cm">/* pointer to userspace command buffer */</span>
	<span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>			<span class="cm">/* nr bytes in buf */</span>
	<span class="kt">int</span> <span class="n">DR1</span><span class="p">;</span>		<span class="cm">/* hw flags for GFX_OP_DRAWRECT_INFO */</span>
	<span class="kt">int</span> <span class="n">DR4</span><span class="p">;</span>		<span class="cm">/* window origin for GFX_OP_DRAWRECT_INFO */</span>
	<span class="kt">int</span> <span class="n">num_cliprects</span><span class="p">;</span>	<span class="cm">/* mulitpass with multiple cliprects? */</span>
	<span class="k">struct</span> <span class="n">drm_clip_rect</span> <span class="n">__user</span> <span class="o">*</span><span class="n">cliprects</span><span class="p">;</span>	<span class="cm">/* pointer to userspace cliprects */</span>
<span class="p">}</span> <span class="n">drm_i915_cmdbuffer_t</span><span class="p">;</span>

<span class="cm">/* Userspace can request &amp; wait on irq&#39;s:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_i915_irq_emit</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">irq_seq</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_i915_irq_emit_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_i915_irq_wait</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq_seq</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_i915_irq_wait_t</span><span class="p">;</span>

<span class="cm">/* Ioctl to query kernel params:</span>
<span class="cm"> */</span>
<span class="cp">#define I915_PARAM_IRQ_ACTIVE            1</span>
<span class="cp">#define I915_PARAM_ALLOW_BATCHBUFFER     2</span>
<span class="cp">#define I915_PARAM_LAST_DISPATCH         3</span>
<span class="cp">#define I915_PARAM_CHIPSET_ID            4</span>
<span class="cp">#define I915_PARAM_HAS_GEM               5</span>
<span class="cp">#define I915_PARAM_NUM_FENCES_AVAIL      6</span>
<span class="cp">#define I915_PARAM_HAS_OVERLAY           7</span>
<span class="cp">#define I915_PARAM_HAS_PAGEFLIPPING	 8</span>
<span class="cp">#define I915_PARAM_HAS_EXECBUF2          9</span>
<span class="cp">#define I915_PARAM_HAS_BSD		 10</span>
<span class="cp">#define I915_PARAM_HAS_BLT		 11</span>
<span class="cp">#define I915_PARAM_HAS_RELAXED_FENCING	 12</span>
<span class="cp">#define I915_PARAM_HAS_COHERENT_RINGS	 13</span>
<span class="cp">#define I915_PARAM_HAS_EXEC_CONSTANTS	 14</span>
<span class="cp">#define I915_PARAM_HAS_RELAXED_DELTA	 15</span>
<span class="cp">#define I915_PARAM_HAS_GEN7_SOL_RESET	 16</span>
<span class="cp">#define I915_PARAM_HAS_LLC     	 	 17</span>
<span class="cp">#define I915_PARAM_HAS_ALIASING_PPGTT	 18</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_i915_getparam</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">param</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_i915_getparam_t</span><span class="p">;</span>

<span class="cm">/* Ioctl to set kernel params:</span>
<span class="cm"> */</span>
<span class="cp">#define I915_SETPARAM_USE_MI_BATCHBUFFER_START            1</span>
<span class="cp">#define I915_SETPARAM_TEX_LRU_LOG_GRANULARITY             2</span>
<span class="cp">#define I915_SETPARAM_ALLOW_BATCHBUFFER                   3</span>
<span class="cp">#define I915_SETPARAM_NUM_USED_FENCES                     4</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_i915_setparam</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">param</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_i915_setparam_t</span><span class="p">;</span>

<span class="cm">/* A memory manager for regions of shared memory:</span>
<span class="cm"> */</span>
<span class="cp">#define I915_MEM_REGION_AGP 1</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_i915_mem_alloc</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">region</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alignment</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">region_offset</span><span class="p">;</span>	<span class="cm">/* offset from start of fb or agp */</span>
<span class="p">}</span> <span class="n">drm_i915_mem_alloc_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_i915_mem_free</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">region</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">region_offset</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_i915_mem_free_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_i915_mem_init_heap</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">region</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_i915_mem_init_heap_t</span><span class="p">;</span>

<span class="cm">/* Allow memory manager to be torn down and re-initialized (eg on</span>
<span class="cm"> * rotate):</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_i915_mem_destroy_heap</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">region</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_i915_mem_destroy_heap_t</span><span class="p">;</span>

<span class="cm">/* Allow X server to configure which pipes to monitor for vblank signals</span>
<span class="cm"> */</span>
<span class="cp">#define	DRM_I915_VBLANK_PIPE_A	1</span>
<span class="cp">#define	DRM_I915_VBLANK_PIPE_B	2</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_i915_vblank_pipe</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">pipe</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_i915_vblank_pipe_t</span><span class="p">;</span>

<span class="cm">/* Schedule buffer swap at given vertical blank:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_i915_vblank_swap</span> <span class="p">{</span>
	<span class="n">drm_drawable_t</span> <span class="n">drawable</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">drm_vblank_seq_type</span> <span class="n">seqtype</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sequence</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_i915_vblank_swap_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_i915_hws_addr</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_i915_hws_addr_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_init</span> <span class="p">{</span>
	<span class="cm">/**</span>
<span class="cm">	 * Beginning offset in the GTT to be managed by the DRM memory</span>
<span class="cm">	 * manager.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">gtt_start</span><span class="p">;</span>
	<span class="cm">/**</span>
<span class="cm">	 * Ending offset in the GTT to be managed by the DRM memory</span>
<span class="cm">	 * manager.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">gtt_end</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_create</span> <span class="p">{</span>
	<span class="cm">/**</span>
<span class="cm">	 * Requested size for the object.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The (page-aligned) allocated size for the object will be returned.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">size</span><span class="p">;</span>
	<span class="cm">/**</span>
<span class="cm">	 * Returned handle for the object.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Object handles are nonzero.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_pread</span> <span class="p">{</span>
	<span class="cm">/** Handle for the object being read. */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
	<span class="cm">/** Offset into the object to read from */</span>
	<span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span>
	<span class="cm">/** Length of data to read */</span>
	<span class="n">__u64</span> <span class="n">size</span><span class="p">;</span>
	<span class="cm">/**</span>
<span class="cm">	 * Pointer to write the data into.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is a fixed-size type for 32/64 compatibility.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">data_ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_pwrite</span> <span class="p">{</span>
	<span class="cm">/** Handle for the object being written to. */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
	<span class="cm">/** Offset into the object to write to */</span>
	<span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span>
	<span class="cm">/** Length of data to write */</span>
	<span class="n">__u64</span> <span class="n">size</span><span class="p">;</span>
	<span class="cm">/**</span>
<span class="cm">	 * Pointer to read the data from.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is a fixed-size type for 32/64 compatibility.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">data_ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_mmap</span> <span class="p">{</span>
	<span class="cm">/** Handle for the object being mapped. */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
	<span class="cm">/** Offset in the object to map. */</span>
	<span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span>
	<span class="cm">/**</span>
<span class="cm">	 * Length of data to map.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The value will be page-aligned.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">size</span><span class="p">;</span>
	<span class="cm">/**</span>
<span class="cm">	 * Returned pointer the data was mapped at.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is a fixed-size type for 32/64 compatibility.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">addr_ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_mmap_gtt</span> <span class="p">{</span>
	<span class="cm">/** Handle for the object being mapped. */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
	<span class="cm">/**</span>
<span class="cm">	 * Fake offset to use for subsequent mmap call</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is a fixed-size type for 32/64 compatibility.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_set_domain</span> <span class="p">{</span>
	<span class="cm">/** Handle for the object */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>

	<span class="cm">/** New read domains */</span>
	<span class="n">__u32</span> <span class="n">read_domains</span><span class="p">;</span>

	<span class="cm">/** New write domain */</span>
	<span class="n">__u32</span> <span class="n">write_domain</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_sw_finish</span> <span class="p">{</span>
	<span class="cm">/** Handle for the object */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_relocation_entry</span> <span class="p">{</span>
	<span class="cm">/**</span>
<span class="cm">	 * Handle of the buffer being pointed to by this relocation entry.</span>
<span class="cm">	 *</span>
<span class="cm">	 * It&#39;s appealing to make this be an index into the mm_validate_entry</span>
<span class="cm">	 * list to refer to the buffer, but this allows the driver to create</span>
<span class="cm">	 * a relocation list for state buffers and not re-write it per</span>
<span class="cm">	 * exec using the buffer.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">target_handle</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Value to be added to the offset of the target buffer to make up</span>
<span class="cm">	 * the relocation entry.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">delta</span><span class="p">;</span>

	<span class="cm">/** Offset in the buffer the relocation entry will be written into */</span>
	<span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Offset value of the target buffer that the relocation entry was last</span>
<span class="cm">	 * written as.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the buffer has the same offset as last time, we can skip syncing</span>
<span class="cm">	 * and writing the relocation.  This value is written back out by</span>
<span class="cm">	 * the execbuffer ioctl when the relocation is written.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">presumed_offset</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Target memory domains read by this operation.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">read_domains</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Target memory domains written by this operation.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that only one domain may be written by the whole</span>
<span class="cm">	 * execbuffer operation, so that where there are conflicts,</span>
<span class="cm">	 * the application will get -EINVAL back.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">write_domain</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** @{</span>
<span class="cm"> * Intel memory domains</span>
<span class="cm"> *</span>
<span class="cm"> * Most of these just align with the various caches in</span>
<span class="cm"> * the system and are used to flush and invalidate as</span>
<span class="cm"> * objects end up cached in different domains.</span>
<span class="cm"> */</span>
<span class="cm">/** CPU cache */</span>
<span class="cp">#define I915_GEM_DOMAIN_CPU		0x00000001</span>
<span class="cm">/** Render cache, used by 2D and 3D drawing */</span>
<span class="cp">#define I915_GEM_DOMAIN_RENDER		0x00000002</span>
<span class="cm">/** Sampler cache, used by texture engine */</span>
<span class="cp">#define I915_GEM_DOMAIN_SAMPLER		0x00000004</span>
<span class="cm">/** Command queue, used to load batch buffers */</span>
<span class="cp">#define I915_GEM_DOMAIN_COMMAND		0x00000008</span>
<span class="cm">/** Instruction cache, used by shader programs */</span>
<span class="cp">#define I915_GEM_DOMAIN_INSTRUCTION	0x00000010</span>
<span class="cm">/** Vertex address cache */</span>
<span class="cp">#define I915_GEM_DOMAIN_VERTEX		0x00000020</span>
<span class="cm">/** GTT domain - aperture and scanout */</span>
<span class="cp">#define I915_GEM_DOMAIN_GTT		0x00000040</span>
<span class="cm">/** @} */</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_exec_object</span> <span class="p">{</span>
	<span class="cm">/**</span>
<span class="cm">	 * User&#39;s handle for a buffer to be bound into the GTT for this</span>
<span class="cm">	 * operation.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>

	<span class="cm">/** Number of relocations to be performed on this buffer */</span>
	<span class="n">__u32</span> <span class="n">relocation_count</span><span class="p">;</span>
	<span class="cm">/**</span>
<span class="cm">	 * Pointer to array of struct drm_i915_gem_relocation_entry containing</span>
<span class="cm">	 * the relocations to be performed in this buffer.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">relocs_ptr</span><span class="p">;</span>

	<span class="cm">/** Required alignment in graphics aperture */</span>
	<span class="n">__u64</span> <span class="n">alignment</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Returned value of the updated offset of the object, for future</span>
<span class="cm">	 * presumed_offset writes.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_execbuffer</span> <span class="p">{</span>
	<span class="cm">/**</span>
<span class="cm">	 * List of buffers to be validated with their relocations to be</span>
<span class="cm">	 * performend on them.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is a pointer to an array of struct drm_i915_gem_validate_entry.</span>
<span class="cm">	 *</span>
<span class="cm">	 * These buffers must be listed in an order such that all relocations</span>
<span class="cm">	 * a buffer is performing refer to buffers that have already appeared</span>
<span class="cm">	 * in the validate list.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">buffers_ptr</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">buffer_count</span><span class="p">;</span>

	<span class="cm">/** Offset in the batchbuffer to start execution from. */</span>
	<span class="n">__u32</span> <span class="n">batch_start_offset</span><span class="p">;</span>
	<span class="cm">/** Bytes used in batchbuffer from batch_start_offset */</span>
	<span class="n">__u32</span> <span class="n">batch_len</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">DR1</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">DR4</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">num_cliprects</span><span class="p">;</span>
	<span class="cm">/** This is a struct drm_clip_rect *cliprects */</span>
	<span class="n">__u64</span> <span class="n">cliprects_ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_exec_object2</span> <span class="p">{</span>
	<span class="cm">/**</span>
<span class="cm">	 * User&#39;s handle for a buffer to be bound into the GTT for this</span>
<span class="cm">	 * operation.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>

	<span class="cm">/** Number of relocations to be performed on this buffer */</span>
	<span class="n">__u32</span> <span class="n">relocation_count</span><span class="p">;</span>
	<span class="cm">/**</span>
<span class="cm">	 * Pointer to array of struct drm_i915_gem_relocation_entry containing</span>
<span class="cm">	 * the relocations to be performed in this buffer.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">relocs_ptr</span><span class="p">;</span>

	<span class="cm">/** Required alignment in graphics aperture */</span>
	<span class="n">__u64</span> <span class="n">alignment</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Returned value of the updated offset of the object, for future</span>
<span class="cm">	 * presumed_offset writes.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span>

<span class="cp">#define EXEC_OBJECT_NEEDS_FENCE (1&lt;&lt;0)</span>
	<span class="n">__u64</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">rsvd1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">rsvd2</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_execbuffer2</span> <span class="p">{</span>
	<span class="cm">/**</span>
<span class="cm">	 * List of gem_exec_object2 structs</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">buffers_ptr</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">buffer_count</span><span class="p">;</span>

	<span class="cm">/** Offset in the batchbuffer to start execution from. */</span>
	<span class="n">__u32</span> <span class="n">batch_start_offset</span><span class="p">;</span>
	<span class="cm">/** Bytes used in batchbuffer from batch_start_offset */</span>
	<span class="n">__u32</span> <span class="n">batch_len</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">DR1</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">DR4</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">num_cliprects</span><span class="p">;</span>
	<span class="cm">/** This is a struct drm_clip_rect *cliprects */</span>
	<span class="n">__u64</span> <span class="n">cliprects_ptr</span><span class="p">;</span>
<span class="cp">#define I915_EXEC_RING_MASK              (7&lt;&lt;0)</span>
<span class="cp">#define I915_EXEC_DEFAULT                (0&lt;&lt;0)</span>
<span class="cp">#define I915_EXEC_RENDER                 (1&lt;&lt;0)</span>
<span class="cp">#define I915_EXEC_BSD                    (2&lt;&lt;0)</span>
<span class="cp">#define I915_EXEC_BLT                    (3&lt;&lt;0)</span>

<span class="cm">/* Used for switching the constants addressing mode on gen4+ RENDER ring.</span>
<span class="cm"> * Gen6+ only supports relative addressing to dynamic state (default) and</span>
<span class="cm"> * absolute addressing.</span>
<span class="cm"> *</span>
<span class="cm"> * These flags are ignored for the BSD and BLT rings.</span>
<span class="cm"> */</span>
<span class="cp">#define I915_EXEC_CONSTANTS_MASK 	(3&lt;&lt;6)</span>
<span class="cp">#define I915_EXEC_CONSTANTS_REL_GENERAL (0&lt;&lt;6) </span><span class="cm">/* default */</span><span class="cp"></span>
<span class="cp">#define I915_EXEC_CONSTANTS_ABSOLUTE 	(1&lt;&lt;6)</span>
<span class="cp">#define I915_EXEC_CONSTANTS_REL_SURFACE (2&lt;&lt;6) </span><span class="cm">/* gen4/5 only */</span><span class="cp"></span>
	<span class="n">__u64</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">rsvd1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">rsvd2</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** Resets the SO write offset registers for transform feedback on gen7. */</span>
<span class="cp">#define I915_EXEC_GEN7_SOL_RESET	(1&lt;&lt;8)</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_pin</span> <span class="p">{</span>
	<span class="cm">/** Handle of the buffer to be pinned. */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>

	<span class="cm">/** alignment required within the aperture */</span>
	<span class="n">__u64</span> <span class="n">alignment</span><span class="p">;</span>

	<span class="cm">/** Returned GTT offset of the buffer. */</span>
	<span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_unpin</span> <span class="p">{</span>
	<span class="cm">/** Handle of the buffer to be unpinned. */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_busy</span> <span class="p">{</span>
	<span class="cm">/** Handle of the buffer to check for busy */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>

	<span class="cm">/** Return busy status (1 if busy, 0 if idle) */</span>
	<span class="n">__u32</span> <span class="n">busy</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define I915_TILING_NONE	0</span>
<span class="cp">#define I915_TILING_X		1</span>
<span class="cp">#define I915_TILING_Y		2</span>

<span class="cp">#define I915_BIT_6_SWIZZLE_NONE		0</span>
<span class="cp">#define I915_BIT_6_SWIZZLE_9		1</span>
<span class="cp">#define I915_BIT_6_SWIZZLE_9_10		2</span>
<span class="cp">#define I915_BIT_6_SWIZZLE_9_11		3</span>
<span class="cp">#define I915_BIT_6_SWIZZLE_9_10_11	4</span>
<span class="cm">/* Not seen by userland */</span>
<span class="cp">#define I915_BIT_6_SWIZZLE_UNKNOWN	5</span>
<span class="cm">/* Seen by userland. */</span>
<span class="cp">#define I915_BIT_6_SWIZZLE_9_17		6</span>
<span class="cp">#define I915_BIT_6_SWIZZLE_9_10_17	7</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_set_tiling</span> <span class="p">{</span>
	<span class="cm">/** Handle of the buffer to have its tiling state updated */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Tiling mode for the object (I915_TILING_NONE, I915_TILING_X,</span>
<span class="cm">	 * I915_TILING_Y).</span>
<span class="cm">	 *</span>
<span class="cm">	 * This value is to be set on request, and will be updated by the</span>
<span class="cm">	 * kernel on successful return with the actual chosen tiling layout.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The tiling mode may be demoted to I915_TILING_NONE when the system</span>
<span class="cm">	 * has bit 6 swizzling that can&#39;t be managed correctly by GEM.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Buffer contents become undefined when changing tiling_mode.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">tiling_mode</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Stride in bytes for the object when in I915_TILING_X or</span>
<span class="cm">	 * I915_TILING_Y.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">stride</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Returned address bit 6 swizzling required for CPU access through</span>
<span class="cm">	 * mmap mapping.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">swizzle_mode</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_get_tiling</span> <span class="p">{</span>
	<span class="cm">/** Handle of the buffer to get tiling state for. */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Current tiling mode for the object (I915_TILING_NONE, I915_TILING_X,</span>
<span class="cm">	 * I915_TILING_Y).</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">tiling_mode</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Returned address bit 6 swizzling required for CPU access through</span>
<span class="cm">	 * mmap mapping.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">swizzle_mode</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_i915_gem_get_aperture</span> <span class="p">{</span>
	<span class="cm">/** Total size of the aperture used by i915_gem_execbuffer, in bytes */</span>
	<span class="n">__u64</span> <span class="n">aper_size</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Available space in the aperture used by i915_gem_execbuffer, in</span>
<span class="cm">	 * bytes</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">aper_available_size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_i915_get_pipe_from_crtc_id</span> <span class="p">{</span>
	<span class="cm">/** ID of CRTC being requested **/</span>
	<span class="n">__u32</span> <span class="n">crtc_id</span><span class="p">;</span>

	<span class="cm">/** pipe of requested CRTC **/</span>
	<span class="n">__u32</span> <span class="n">pipe</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define I915_MADV_WILLNEED 0</span>
<span class="cp">#define I915_MADV_DONTNEED 1</span>
<span class="cp">#define __I915_MADV_PURGED 2 </span><span class="cm">/* internal state */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">drm_i915_gem_madvise</span> <span class="p">{</span>
	<span class="cm">/** Handle of the buffer to change the backing store advice */</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>

	<span class="cm">/* Advice: either the buffer will be needed again in the near future,</span>
<span class="cm">	 *         or wont be and could be discarded under memory pressure.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">madv</span><span class="p">;</span>

	<span class="cm">/** Whether the backing store still exists. */</span>
	<span class="n">__u32</span> <span class="n">retained</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* flags */</span>
<span class="cp">#define I915_OVERLAY_TYPE_MASK 		0xff</span>
<span class="cp">#define I915_OVERLAY_YUV_PLANAR 	0x01</span>
<span class="cp">#define I915_OVERLAY_YUV_PACKED 	0x02</span>
<span class="cp">#define I915_OVERLAY_RGB		0x03</span>

<span class="cp">#define I915_OVERLAY_DEPTH_MASK		0xff00</span>
<span class="cp">#define I915_OVERLAY_RGB24		0x1000</span>
<span class="cp">#define I915_OVERLAY_RGB16		0x2000</span>
<span class="cp">#define I915_OVERLAY_RGB15		0x3000</span>
<span class="cp">#define I915_OVERLAY_YUV422		0x0100</span>
<span class="cp">#define I915_OVERLAY_YUV411		0x0200</span>
<span class="cp">#define I915_OVERLAY_YUV420		0x0300</span>
<span class="cp">#define I915_OVERLAY_YUV410		0x0400</span>

<span class="cp">#define I915_OVERLAY_SWAP_MASK		0xff0000</span>
<span class="cp">#define I915_OVERLAY_NO_SWAP		0x000000</span>
<span class="cp">#define I915_OVERLAY_UV_SWAP		0x010000</span>
<span class="cp">#define I915_OVERLAY_Y_SWAP		0x020000</span>
<span class="cp">#define I915_OVERLAY_Y_AND_UV_SWAP	0x030000</span>

<span class="cp">#define I915_OVERLAY_FLAGS_MASK		0xff000000</span>
<span class="cp">#define I915_OVERLAY_ENABLE		0x01000000</span>

<span class="k">struct</span> <span class="n">drm_intel_overlay_put_image</span> <span class="p">{</span>
	<span class="cm">/* various flags and src format description */</span>
	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="cm">/* source picture description */</span>
	<span class="n">__u32</span> <span class="n">bo_handle</span><span class="p">;</span>
	<span class="cm">/* stride values and offsets are in bytes, buffer relative */</span>
	<span class="n">__u16</span> <span class="n">stride_Y</span><span class="p">;</span> <span class="cm">/* stride for packed formats */</span>
	<span class="n">__u16</span> <span class="n">stride_UV</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">offset_Y</span><span class="p">;</span> <span class="cm">/* offset for packet formats */</span>
	<span class="n">__u32</span> <span class="n">offset_U</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">offset_V</span><span class="p">;</span>
	<span class="cm">/* in pixels */</span>
	<span class="n">__u16</span> <span class="n">src_width</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">src_height</span><span class="p">;</span>
	<span class="cm">/* to compensate the scaling factors for partially covered surfaces */</span>
	<span class="n">__u16</span> <span class="n">src_scan_width</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">src_scan_height</span><span class="p">;</span>
	<span class="cm">/* output crtc description */</span>
	<span class="n">__u32</span> <span class="n">crtc_id</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">dst_x</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">dst_y</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">dst_width</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">dst_height</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* flags */</span>
<span class="cp">#define I915_OVERLAY_UPDATE_ATTRS	(1&lt;&lt;0)</span>
<span class="cp">#define I915_OVERLAY_UPDATE_GAMMA	(1&lt;&lt;1)</span>
<span class="k">struct</span> <span class="n">drm_intel_overlay_attrs</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">color_key</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">brightness</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">contrast</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">saturation</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">gamma0</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">gamma1</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">gamma2</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">gamma3</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">gamma4</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">gamma5</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Intel sprite handling</span>
<span class="cm"> *</span>
<span class="cm"> * Color keying works with a min/mask/max tuple.  Both source and destination</span>
<span class="cm"> * color keying is allowed.</span>
<span class="cm"> *</span>
<span class="cm"> * Source keying:</span>
<span class="cm"> * Sprite pixels within the min &amp; max values, masked against the color channels</span>
<span class="cm"> * specified in the mask field, will be transparent.  All other pixels will</span>
<span class="cm"> * be displayed on top of the primary plane.  For RGB surfaces, only the min</span>
<span class="cm"> * and mask fields will be used; ranged compares are not allowed.</span>
<span class="cm"> *</span>
<span class="cm"> * Destination keying:</span>
<span class="cm"> * Primary plane pixels that match the min value, masked against the color</span>
<span class="cm"> * channels specified in the mask field, will be replaced by corresponding</span>
<span class="cm"> * pixels from the sprite plane.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that source &amp; destination keying are exclusive; only one can be</span>
<span class="cm"> * active on a given plane.</span>
<span class="cm"> */</span>

<span class="cp">#define I915_SET_COLORKEY_NONE		(1&lt;&lt;0) </span><span class="cm">/* disable color key matching */</span><span class="cp"></span>
<span class="cp">#define I915_SET_COLORKEY_DESTINATION	(1&lt;&lt;1)</span>
<span class="cp">#define I915_SET_COLORKEY_SOURCE	(1&lt;&lt;2)</span>
<span class="k">struct</span> <span class="n">drm_intel_sprite_colorkey</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">plane_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">min_value</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">channel_mask</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">max_value</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif				</span><span class="cm">/* _I915_DRM_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
