<!DOCTYPE html>
<html><head><title>joekychen/linux » include › drm › drmP.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>drmP.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * \file drmP.h</span>
<span class="cm"> * Private header for Direct Rendering Manager</span>
<span class="cm"> *</span>
<span class="cm"> * \author Rickard E. (Rik) Faith &lt;faith@valinux.com&gt;</span>
<span class="cm"> * \author Gareth Hughes &lt;gareth@valinux.com&gt;</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.</span>
<span class="cm"> * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.</span>
<span class="cm"> * Copyright (c) 2009-2010, Code Aurora Forum.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="cm"> * to deal in the Software without restriction, including without limitation</span>
<span class="cm"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="cm"> * and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="cm"> * Software is furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice (including the next</span>
<span class="cm"> * paragraph) shall be included in all copies or substantial portions of the</span>
<span class="cm"> * Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span>
<span class="cm"> * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR</span>
<span class="cm"> * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,</span>
<span class="cm"> * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</span>
<span class="cm"> * OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _DRM_P_H_</span>
<span class="cp">#define _DRM_P_H_</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#ifdef __alpha__</span>
<span class="cm">/* add include of current.h so that &quot;current&quot; is defined</span>
<span class="cm"> * before static inline funcs in wait.h. Doing this so we</span>
<span class="cm"> * can build the DRM (part of PI DRI). 4/21/2000 S + B */</span>
<span class="cp">#include &lt;asm/current.h&gt;</span>
<span class="cp">#endif				</span><span class="cm">/* __alpha__ */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/cdev.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#if defined(__alpha__) || defined(__powerpc__)</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;	</span><span class="cm">/* For pte_wrprotect */</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/mman.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#ifdef CONFIG_MTRR</span>
<span class="cp">#include &lt;asm/mtrr.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/agp_backend.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &quot;drm.h&quot;</span>

<span class="cp">#include &lt;linux/idr.h&gt;</span>

<span class="cp">#define __OS_HAS_AGP (defined(CONFIG_AGP) || (defined(CONFIG_AGP_MODULE) &amp;&amp; defined(MODULE)))</span>
<span class="cp">#define __OS_HAS_MTRR (defined(CONFIG_MTRR))</span>

<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">drm_file</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">drm_device</span><span class="p">;</span>

<span class="cp">#include &quot;drm_os_linux.h&quot;</span>
<span class="cp">#include &quot;drm_hashtab.h&quot;</span>
<span class="cp">#include &quot;drm_mm.h&quot;</span>

<span class="cp">#define DRM_UT_CORE 		0x01</span>
<span class="cp">#define DRM_UT_DRIVER		0x02</span>
<span class="cp">#define DRM_UT_KMS		0x04</span>
<span class="cp">#define DRM_UT_PRIME		0x08</span>
<span class="cm">/*</span>
<span class="cm"> * Three debug levels are defined.</span>
<span class="cm"> * drm_core, drm_driver, drm_kms</span>
<span class="cm"> * drm_core level can be used in the generic drm code. For example:</span>
<span class="cm"> * 	drm_ioctl, drm_mm, drm_memory</span>
<span class="cm"> * The macro definition of DRM_DEBUG is used.</span>
<span class="cm"> * 	DRM_DEBUG(fmt, args...)</span>
<span class="cm"> * 	The debug info by using the DRM_DEBUG can be obtained by adding</span>
<span class="cm"> * 	the boot option of &quot;drm.debug=1&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * drm_driver level can be used in the specific drm driver. It is used</span>
<span class="cm"> * to add the debug info related with the drm driver. For example:</span>
<span class="cm"> * i915_drv, i915_dma, i915_gem, radeon_drv,</span>
<span class="cm"> * 	The macro definition of DRM_DEBUG_DRIVER can be used.</span>
<span class="cm"> * 	DRM_DEBUG_DRIVER(fmt, args...)</span>
<span class="cm"> * 	The debug info by using the DRM_DEBUG_DRIVER can be obtained by</span>
<span class="cm"> * 	adding the boot option of &quot;drm.debug=0x02&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * drm_kms level can be used in the KMS code related with specific drm driver.</span>
<span class="cm"> * It is used to add the debug info related with KMS mode. For example:</span>
<span class="cm"> * the connector/crtc ,</span>
<span class="cm"> * 	The macro definition of DRM_DEBUG_KMS can be used.</span>
<span class="cm"> * 	DRM_DEBUG_KMS(fmt, args...)</span>
<span class="cm"> * 	The debug info by using the DRM_DEBUG_KMS can be obtained by</span>
<span class="cm"> * 	adding the boot option of &quot;drm.debug=0x04&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * If we add the boot option of &quot;drm.debug=0x06&quot;, we can get the debug info by</span>
<span class="cm"> * using the DRM_DEBUG_KMS and DRM_DEBUG_DRIVER.</span>
<span class="cm"> * If we add the boot option of &quot;drm.debug=0x05&quot;, we can get the debug info by</span>
<span class="cm"> * using the DRM_DEBUG_KMS and DRM_DEBUG.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">drm_ut_debug_printk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">request_level</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function_name</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">drm_err</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="cm">/***********************************************************************/</span>
<span class="cm">/** \name DRM template customization defaults */</span>
<span class="cm">/*@{*/</span>

<span class="cm">/* driver capabilities and requirements mask */</span>
<span class="cp">#define DRIVER_USE_AGP     0x1</span>
<span class="cp">#define DRIVER_REQUIRE_AGP 0x2</span>
<span class="cp">#define DRIVER_USE_MTRR    0x4</span>
<span class="cp">#define DRIVER_PCI_DMA     0x8</span>
<span class="cp">#define DRIVER_SG          0x10</span>
<span class="cp">#define DRIVER_HAVE_DMA    0x20</span>
<span class="cp">#define DRIVER_HAVE_IRQ    0x40</span>
<span class="cp">#define DRIVER_IRQ_SHARED  0x80</span>
<span class="cp">#define DRIVER_IRQ_VBL     0x100</span>
<span class="cp">#define DRIVER_DMA_QUEUE   0x200</span>
<span class="cp">#define DRIVER_FB_DMA      0x400</span>
<span class="cp">#define DRIVER_IRQ_VBL2    0x800</span>
<span class="cp">#define DRIVER_GEM         0x1000</span>
<span class="cp">#define DRIVER_MODESET     0x2000</span>
<span class="cp">#define DRIVER_PRIME       0x4000</span>

<span class="cp">#define DRIVER_BUS_PCI 0x1</span>
<span class="cp">#define DRIVER_BUS_PLATFORM 0x2</span>
<span class="cp">#define DRIVER_BUS_USB 0x3</span>

<span class="cm">/***********************************************************************/</span>
<span class="cm">/** \name Begin the DRM... */</span>
<span class="cm">/*@{*/</span>

<span class="cp">#define DRM_DEBUG_CODE 2	  </span><span class="cm">/**&lt; Include debugging code if &gt; 1, then</span>
<span class="cm">				     also include looping detection. */</span><span class="cp"></span>

<span class="cp">#define DRM_MAGIC_HASH_ORDER  4  </span><span class="cm">/**&lt; Size of key hash table. Must be power of 2. */</span><span class="cp"></span>
<span class="cp">#define DRM_KERNEL_CONTEXT    0	 </span><span class="cm">/**&lt; Change drm_resctx if changed */</span><span class="cp"></span>
<span class="cp">#define DRM_RESERVED_CONTEXTS 1	 </span><span class="cm">/**&lt; Change drm_resctx if changed */</span><span class="cp"></span>
<span class="cp">#define DRM_LOOPING_LIMIT     5000000</span>
<span class="cp">#define DRM_TIME_SLICE	      (HZ/20)  </span><span class="cm">/**&lt; Time slice for GLXContexts */</span><span class="cp"></span>
<span class="cp">#define DRM_LOCK_SLICE	      1	</span><span class="cm">/**&lt; Time slice for lock, in jiffies */</span><span class="cp"></span>

<span class="cp">#define DRM_FLAG_DEBUG	  0x01</span>

<span class="cp">#define DRM_MAX_CTXBITMAP (PAGE_SIZE * 8)</span>
<span class="cp">#define DRM_MAP_HASH_OFFSET 0x10000000</span>

<span class="cm">/*@}*/</span>

<span class="cm">/***********************************************************************/</span>
<span class="cm">/** \name Macros to make printk easier */</span>
<span class="cm">/*@{*/</span>

<span class="cm">/**</span>
<span class="cm"> * Error output.</span>
<span class="cm"> *</span>
<span class="cm"> * \param fmt printf() like format string.</span>
<span class="cm"> * \param arg arguments</span>
<span class="cm"> */</span>
<span class="cp">#define DRM_ERROR(fmt, ...)				\</span>
<span class="cp">	drm_err(__func__, fmt, ##__VA_ARGS__)</span>

<span class="cp">#define DRM_INFO(fmt, ...)				\</span>
<span class="cp">	printk(KERN_INFO &quot;[&quot; DRM_NAME &quot;] &quot; fmt, ##__VA_ARGS__)</span>

<span class="cm">/**</span>
<span class="cm"> * Debug output.</span>
<span class="cm"> *</span>
<span class="cm"> * \param fmt printf() like format string.</span>
<span class="cm"> * \param arg arguments</span>
<span class="cm"> */</span>
<span class="cp">#if DRM_DEBUG_CODE</span>
<span class="cp">#define DRM_DEBUG(fmt, args...)						\</span>
<span class="cp">	do {								\</span>
<span class="cp">		drm_ut_debug_printk(DRM_UT_CORE, DRM_NAME, 		\</span>
<span class="cp">					__func__, fmt, ##args);		\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define DRM_DEBUG_DRIVER(fmt, args...)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		drm_ut_debug_printk(DRM_UT_DRIVER, DRM_NAME,		\</span>
<span class="cp">					__func__, fmt, ##args);		\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define DRM_DEBUG_KMS(fmt, args...)				\</span>
<span class="cp">	do {								\</span>
<span class="cp">		drm_ut_debug_printk(DRM_UT_KMS, DRM_NAME, 		\</span>
<span class="cp">					 __func__, fmt, ##args);	\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define DRM_DEBUG_PRIME(fmt, args...)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		drm_ut_debug_printk(DRM_UT_PRIME, DRM_NAME,		\</span>
<span class="cp">					__func__, fmt, ##args);		\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define DRM_LOG(fmt, args...)						\</span>
<span class="cp">	do {								\</span>
<span class="cp">		drm_ut_debug_printk(DRM_UT_CORE, NULL,			\</span>
<span class="cp">					NULL, fmt, ##args);		\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define DRM_LOG_KMS(fmt, args...)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		drm_ut_debug_printk(DRM_UT_KMS, NULL,			\</span>
<span class="cp">					NULL, fmt, ##args);		\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define DRM_LOG_MODE(fmt, args...)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		drm_ut_debug_printk(DRM_UT_MODE, NULL,			\</span>
<span class="cp">					NULL, fmt, ##args);		\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define DRM_LOG_DRIVER(fmt, args...)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		drm_ut_debug_printk(DRM_UT_DRIVER, NULL,		\</span>
<span class="cp">					NULL, fmt, ##args);		\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define DRM_DEBUG_DRIVER(fmt, args...) do { } while (0)</span>
<span class="cp">#define DRM_DEBUG_KMS(fmt, args...)	do { } while (0)</span>
<span class="cp">#define DRM_DEBUG_PRIME(fmt, args...)	do { } while (0)</span>
<span class="cp">#define DRM_DEBUG(fmt, arg...)		 do { } while (0)</span>
<span class="cp">#define DRM_LOG(fmt, arg...)		do { } while (0)</span>
<span class="cp">#define DRM_LOG_KMS(fmt, args...) do { } while (0)</span>
<span class="cp">#define DRM_LOG_MODE(fmt, arg...) do { } while (0)</span>
<span class="cp">#define DRM_LOG_DRIVER(fmt, arg...) do { } while (0)</span>

<span class="cp">#endif</span>

<span class="cm">/*@}*/</span>

<span class="cm">/***********************************************************************/</span>
<span class="cm">/** \name Internal types and structures */</span>
<span class="cm">/*@{*/</span>

<span class="cp">#define DRM_ARRAY_SIZE(x) ARRAY_SIZE(x)</span>

<span class="cp">#define DRM_LEFTCOUNT(x) (((x)-&gt;rp + (x)-&gt;count - (x)-&gt;wp) % ((x)-&gt;count + 1))</span>
<span class="cp">#define DRM_BUFCOUNT(x) ((x)-&gt;count - DRM_LEFTCOUNT(x))</span>

<span class="cp">#define DRM_IF_VERSION(maj, min) (maj &lt;&lt; 16 | min)</span>

<span class="cm">/**</span>
<span class="cm"> * Test that the hardware lock is held by the caller, returning otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * \param dev DRM device.</span>
<span class="cm"> * \param filp file pointer of the caller.</span>
<span class="cm"> */</span>
<span class="cp">#define LOCK_TEST_WITH_RETURN( dev, _file_priv )				\</span>
<span class="cp">do {										\</span>
<span class="cp">	if (!_DRM_LOCK_IS_HELD(_file_priv-&gt;master-&gt;lock.hw_lock-&gt;lock) ||	\</span>
<span class="cp">	    _file_priv-&gt;master-&gt;lock.file_priv != _file_priv)	{		\</span>
<span class="cp">		DRM_ERROR( &quot;%s called without lock held, held  %d owner %p %p\n&quot;,\</span>
<span class="cp">			   __func__, _DRM_LOCK_IS_HELD(_file_priv-&gt;master-&gt;lock.hw_lock-&gt;lock),\</span>
<span class="cp">			   _file_priv-&gt;master-&gt;lock.file_priv, _file_priv);	\</span>
<span class="cp">		return -EINVAL;							\</span>
<span class="cp">	}									\</span>
<span class="cp">} while (0)</span>

<span class="cm">/**</span>
<span class="cm"> * Ioctl function type.</span>
<span class="cm"> *</span>
<span class="cm"> * \param inode device inode.</span>
<span class="cm"> * \param file_priv DRM file private pointer.</span>
<span class="cm"> * \param cmd command.</span>
<span class="cm"> * \param arg argument.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">drm_ioctl_t</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="n">drm_ioctl_compat_t</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>

<span class="cp">#define DRM_IOCTL_NR(n)                _IOC_NR(n)</span>
<span class="cp">#define DRM_MAJOR       226</span>

<span class="cp">#define DRM_AUTH	0x1</span>
<span class="cp">#define	DRM_MASTER	0x2</span>
<span class="cp">#define DRM_ROOT_ONLY	0x4</span>
<span class="cp">#define DRM_CONTROL_ALLOW 0x8</span>
<span class="cp">#define DRM_UNLOCKED	0x10</span>

<span class="k">struct</span> <span class="n">drm_ioctl_desc</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">drm_ioctl_t</span> <span class="o">*</span><span class="n">func</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd_drv</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Creates a driver or general drm_ioctl_desc array entry for the given</span>
<span class="cm"> * ioctl, for use by drm_ioctl().</span>
<span class="cm"> */</span>

<span class="cp">#define DRM_IOCTL_DEF_DRV(ioctl, _func, _flags)			\</span>
<span class="cp">	[DRM_IOCTL_NR(DRM_##ioctl)] = {.cmd = DRM_##ioctl, .func = _func, .flags = _flags, .cmd_drv = DRM_IOCTL_##ioctl}</span>

<span class="k">struct</span> <span class="n">drm_magic_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_hash_item</span> <span class="n">hash_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_vma_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DMA buffer.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_buf</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>		       <span class="cm">/**&lt; Index into master buflist */</span>
	<span class="kt">int</span> <span class="n">total</span><span class="p">;</span>		       <span class="cm">/**&lt; Buffer size */</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>		       <span class="cm">/**&lt; log-base-2(total) */</span>
	<span class="kt">int</span> <span class="n">used</span><span class="p">;</span>		       <span class="cm">/**&lt; Amount of buffer in use (for DMA) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>	       <span class="cm">/**&lt; Byte offset (used internally) */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">address</span><span class="p">;</span>		       <span class="cm">/**&lt; Address of buffer */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bus_address</span><span class="p">;</span>     <span class="cm">/**&lt; Bus address of buffer */</span>
	<span class="k">struct</span> <span class="n">drm_buf</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>	       <span class="cm">/**&lt; Kernel-only: used for free list */</span>
	<span class="n">__volatile__</span> <span class="kt">int</span> <span class="n">waiting</span><span class="p">;</span>      <span class="cm">/**&lt; On kernel DMA queue */</span>
	<span class="n">__volatile__</span> <span class="kt">int</span> <span class="n">pending</span><span class="p">;</span>      <span class="cm">/**&lt; On hardware DMA queue */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">dma_wait</span><span class="p">;</span>    <span class="cm">/**&lt; Processes waiting */</span>
	<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">;</span>    <span class="cm">/**&lt; Private of holding file descr */</span>
	<span class="kt">int</span> <span class="n">context</span><span class="p">;</span>		       <span class="cm">/**&lt; Kernel queue for this buffer */</span>
	<span class="kt">int</span> <span class="n">while_locked</span><span class="p">;</span>	       <span class="cm">/**&lt; Dispatch this buffer while locked */</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">DRM_LIST_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">DRM_LIST_FREE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="n">DRM_LIST_WAIT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
		<span class="n">DRM_LIST_PEND</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
		<span class="n">DRM_LIST_PRIO</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
		<span class="n">DRM_LIST_RECLAIM</span> <span class="o">=</span> <span class="mi">5</span>
	<span class="p">}</span> <span class="n">list</span><span class="p">;</span>			       <span class="cm">/**&lt; Which list we&#39;re on */</span>

	<span class="kt">int</span> <span class="n">dev_priv_size</span><span class="p">;</span>		 <span class="cm">/**&lt; Size of buffer private storage */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dev_private</span><span class="p">;</span>		 <span class="cm">/**&lt; Per-buffer private storage */</span>
<span class="p">};</span>

<span class="cm">/** bufs is one longer than it has to be */</span>
<span class="k">struct</span> <span class="n">drm_waitlist</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>			<span class="cm">/**&lt; Number of possible buffers */</span>
	<span class="k">struct</span> <span class="n">drm_buf</span> <span class="o">**</span><span class="n">bufs</span><span class="p">;</span>		<span class="cm">/**&lt; List of pointers to buffers */</span>
	<span class="k">struct</span> <span class="n">drm_buf</span> <span class="o">**</span><span class="n">rp</span><span class="p">;</span>			<span class="cm">/**&lt; Read pointer */</span>
	<span class="k">struct</span> <span class="n">drm_buf</span> <span class="o">**</span><span class="n">wp</span><span class="p">;</span>			<span class="cm">/**&lt; Write pointer */</span>
	<span class="k">struct</span> <span class="n">drm_buf</span> <span class="o">**</span><span class="n">end</span><span class="p">;</span>		<span class="cm">/**&lt; End pointer */</span>
	<span class="n">spinlock_t</span> <span class="n">read_lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">write_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_freelist</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">initialized</span><span class="p">;</span>	       <span class="cm">/**&lt; Freelist in use */</span>
	<span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span>		       <span class="cm">/**&lt; Number of free buffers */</span>
	<span class="k">struct</span> <span class="n">drm_buf</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>	       <span class="cm">/**&lt; End pointer */</span>

	<span class="n">wait_queue_head_t</span> <span class="n">waiting</span><span class="p">;</span>     <span class="cm">/**&lt; Processes waiting on free bufs */</span>
	<span class="kt">int</span> <span class="n">low_mark</span><span class="p">;</span>		       <span class="cm">/**&lt; Low water mark */</span>
	<span class="kt">int</span> <span class="n">high_mark</span><span class="p">;</span>		       <span class="cm">/**&lt; High water mark */</span>
	<span class="n">atomic_t</span> <span class="n">wfh</span><span class="p">;</span>		       <span class="cm">/**&lt; If waiting for high mark */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_dma_handle</span> <span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">busaddr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">drm_dma_handle_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Buffer entry.  There is one of this for each buffer size order.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_buf_entry</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">buf_size</span><span class="p">;</span>			<span class="cm">/**&lt; size */</span>
	<span class="kt">int</span> <span class="n">buf_count</span><span class="p">;</span>			<span class="cm">/**&lt; number of buffers */</span>
	<span class="k">struct</span> <span class="n">drm_buf</span> <span class="o">*</span><span class="n">buflist</span><span class="p">;</span>		<span class="cm">/**&lt; buffer list */</span>
	<span class="kt">int</span> <span class="n">seg_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_order</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_dma_handle</span> <span class="o">**</span><span class="n">seglist</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drm_freelist</span> <span class="n">freelist</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Event queued up for userspace to read */</span>
<span class="k">struct</span> <span class="n">drm_pending_event</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span> <span class="cm">/* pid of requester, no guarantee it&#39;s valid by the time</span>
<span class="cm">		      we deliver the event, for tracing only */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_pending_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* initial implementaton using a linked list - todo hashtab */</span>
<span class="k">struct</span> <span class="n">drm_prime_file_private</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** File private data */</span>
<span class="k">struct</span> <span class="n">drm_file</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">authenticated</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">uid</span><span class="p">;</span>
	<span class="n">drm_magic_t</span> <span class="n">magic</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioctl_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">lhead</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">minor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_count</span><span class="p">;</span>

	<span class="cm">/** Mapping of mm object handles to object pointers. */</span>
	<span class="k">struct</span> <span class="n">idr</span> <span class="n">object_idr</span><span class="p">;</span>
	<span class="cm">/** Lock for synchronization of access to object_idr. */</span>
	<span class="n">spinlock_t</span> <span class="n">table_lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">driver_priv</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">is_master</span><span class="p">;</span> <span class="cm">/* this file private is a master for a minor */</span>
	<span class="k">struct</span> <span class="n">drm_master</span> <span class="o">*</span><span class="n">master</span><span class="p">;</span> <span class="cm">/* master this node is currently associated with</span>
<span class="cm">				      N.B. not always minor-&gt;master */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">fbs</span><span class="p">;</span>

	<span class="n">wait_queue_head_t</span> <span class="n">event_wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">event_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">event_space</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drm_prime_file_private</span> <span class="n">prime</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** Wait queue */</span>
<span class="k">struct</span> <span class="n">drm_queue</span> <span class="p">{</span>
	<span class="n">atomic_t</span> <span class="n">use_count</span><span class="p">;</span>		<span class="cm">/**&lt; Outstanding uses (+1) */</span>
	<span class="n">atomic_t</span> <span class="n">finalization</span><span class="p">;</span>		<span class="cm">/**&lt; Finalization in progress */</span>
	<span class="n">atomic_t</span> <span class="n">block_count</span><span class="p">;</span>		<span class="cm">/**&lt; Count of processes waiting */</span>
	<span class="n">atomic_t</span> <span class="n">block_read</span><span class="p">;</span>		<span class="cm">/**&lt; Queue blocked for reads */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">read_queue</span><span class="p">;</span>	<span class="cm">/**&lt; Processes waiting on block_read */</span>
	<span class="n">atomic_t</span> <span class="n">block_write</span><span class="p">;</span>		<span class="cm">/**&lt; Queue blocked for writes */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">write_queue</span><span class="p">;</span>	<span class="cm">/**&lt; Processes waiting on block_write */</span>
	<span class="n">atomic_t</span> <span class="n">total_queued</span><span class="p">;</span>		<span class="cm">/**&lt; Total queued statistic */</span>
	<span class="n">atomic_t</span> <span class="n">total_flushed</span><span class="p">;</span>		<span class="cm">/**&lt; Total flushes statistic */</span>
	<span class="n">atomic_t</span> <span class="n">total_locks</span><span class="p">;</span>		<span class="cm">/**&lt; Total locks statistics */</span>
	<span class="k">enum</span> <span class="n">drm_ctx_flags</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/**&lt; Context preserving and 2D-only */</span>
	<span class="k">struct</span> <span class="n">drm_waitlist</span> <span class="n">waitlist</span><span class="p">;</span>	<span class="cm">/**&lt; Pending buffers */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">flush_queue</span><span class="p">;</span>	<span class="cm">/**&lt; Processes waiting until flush */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Lock data.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_lock_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_hw_lock</span> <span class="o">*</span><span class="n">hw_lock</span><span class="p">;</span>	<span class="cm">/**&lt; Hardware lock */</span>
	<span class="cm">/** Private of lock holder&#39;s file (NULL=kernel) */</span>
	<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">lock_queue</span><span class="p">;</span>	<span class="cm">/**&lt; Queue of blocked processes */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_time</span><span class="p">;</span>	<span class="cm">/**&lt; Time of last lock in jiffies */</span>
	<span class="n">spinlock_t</span> <span class="n">spinlock</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">kernel_waiters</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">user_waiters</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idle_has_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DMA data.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_device_dma</span> <span class="p">{</span>

	<span class="k">struct</span> <span class="n">drm_buf_entry</span> <span class="n">bufs</span><span class="p">[</span><span class="n">DRM_MAX_ORDER</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>	<span class="cm">/**&lt; buffers, grouped by their size order */</span>
	<span class="kt">int</span> <span class="n">buf_count</span><span class="p">;</span>			<span class="cm">/**&lt; total number of buffers */</span>
	<span class="k">struct</span> <span class="n">drm_buf</span> <span class="o">**</span><span class="n">buflist</span><span class="p">;</span>		<span class="cm">/**&lt; Vector of pointers into drm_device_dma::bufs */</span>
	<span class="kt">int</span> <span class="n">seg_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_count</span><span class="p">;</span>			<span class="cm">/**&lt; number of pages */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pagelist</span><span class="p">;</span>	<span class="cm">/**&lt; page list */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">byte_count</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">_DRM_DMA_USE_AGP</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
		<span class="n">_DRM_DMA_USE_SG</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
		<span class="n">_DRM_DMA_USE_FB</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
		<span class="n">_DRM_DMA_USE_PCI_RO</span> <span class="o">=</span> <span class="mh">0x08</span>
	<span class="p">}</span> <span class="n">flags</span><span class="p">;</span>

<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * AGP memory entry.  Stored as a doubly linked list.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_agp_mem</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">handle</span><span class="p">;</span>		<span class="cm">/**&lt; handle */</span>
	<span class="n">DRM_AGP_MEM</span> <span class="o">*</span><span class="n">memory</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bound</span><span class="p">;</span>		<span class="cm">/**&lt; address */</span>
	<span class="kt">int</span> <span class="n">pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * AGP data.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa drm_agp_init() and drm_device::agp.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_agp_head</span> <span class="p">{</span>
	<span class="n">DRM_AGP_KERN</span> <span class="n">agp_info</span><span class="p">;</span>		<span class="cm">/**&lt; AGP device information */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">memory</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mode</span><span class="p">;</span>		<span class="cm">/**&lt; AGP mode */</span>
	<span class="k">struct</span> <span class="n">agp_bridge_data</span> <span class="o">*</span><span class="n">bridge</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">enabled</span><span class="p">;</span>			<span class="cm">/**&lt; whether the AGP bus as been enabled */</span>
	<span class="kt">int</span> <span class="n">acquired</span><span class="p">;</span>			<span class="cm">/**&lt; whether the AGP device has been acquired */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">agp_mtrr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cant_use_aperture</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Scatter-gather memory.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_sg_mem</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">handle</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="k">virtual</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagelist</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">busaddr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">drm_sigdata</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_hw_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * Kernel side of a mapping</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_local_map</span> <span class="p">{</span>
	<span class="n">resource_size_t</span> <span class="n">offset</span><span class="p">;</span>	 <span class="cm">/**&lt; Requested physical address (0 for SAREA)*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>	 <span class="cm">/**&lt; Requested physical size (bytes) */</span>
	<span class="k">enum</span> <span class="n">drm_map_type</span> <span class="n">type</span><span class="p">;</span>	 <span class="cm">/**&lt; Type of memory to map */</span>
	<span class="k">enum</span> <span class="n">drm_map_flags</span> <span class="n">flags</span><span class="p">;</span>	 <span class="cm">/**&lt; Flags */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>		 <span class="cm">/**&lt; User-space: &quot;Handle&quot; to pass to mmap() */</span>
				 <span class="cm">/**&lt; Kernel-space: kernel-virtual address */</span>
	<span class="kt">int</span> <span class="n">mtrr</span><span class="p">;</span>		 <span class="cm">/**&lt; MTRR slot used */</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">drm_local_map</span> <span class="n">drm_local_map_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Mappings list</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_map_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>		<span class="cm">/**&lt; list head */</span>
	<span class="k">struct</span> <span class="n">drm_hash_item</span> <span class="n">hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_local_map</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>	<span class="cm">/**&lt; mapping */</span>
	<span class="kt">uint64_t</span> <span class="n">user_token</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_master</span> <span class="o">*</span><span class="n">master</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_mm_node</span> <span class="o">*</span><span class="n">file_offset_node</span><span class="p">;</span>	<span class="cm">/**&lt; fake offset */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Context handle list</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_ctx_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>		<span class="cm">/**&lt; list head */</span>
	<span class="n">drm_context_t</span> <span class="n">handle</span><span class="p">;</span>		<span class="cm">/**&lt; context handle */</span>
	<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">tag</span><span class="p">;</span>		<span class="cm">/**&lt; associated fd private data */</span>
<span class="p">};</span>

<span class="cm">/* location of GART table */</span>
<span class="cp">#define DRM_ATI_GART_MAIN 1</span>
<span class="cp">#define DRM_ATI_GART_FB   2</span>

<span class="cp">#define DRM_ATI_GART_PCI 1</span>
<span class="cp">#define DRM_ATI_GART_PCIE 2</span>
<span class="cp">#define DRM_ATI_GART_IGP 3</span>

<span class="k">struct</span> <span class="n">drm_ati_pcigart_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">gart_table_location</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">gart_reg_if</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">bus_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">table_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_dma_handle</span> <span class="o">*</span><span class="n">table_handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_local_map</span> <span class="n">mapping</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">table_size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * GEM specific mm private for tracking GEM objects</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_gem_mm</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_mm</span> <span class="n">offset_manager</span><span class="p">;</span>	<span class="cm">/**&lt; Offset mgmt for buffer objects */</span>
	<span class="k">struct</span> <span class="n">drm_open_hash</span> <span class="n">offset_hash</span><span class="p">;</span> <span class="cm">/**&lt; User token hash table for maps */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * This structure defines the drm_mm memory object, which will be used by the</span>
<span class="cm"> * DRM for its buffer objects.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="p">{</span>
	<span class="cm">/** Reference count of this object */</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">refcount</span><span class="p">;</span>

	<span class="cm">/** Handle count of this object. Each handle also holds a reference */</span>
	<span class="n">atomic_t</span> <span class="n">handle_count</span><span class="p">;</span> <span class="cm">/* number of handles on this object */</span>

	<span class="cm">/** Related drm device */</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/** File representing the shmem storage */</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>

	<span class="cm">/* Mapping info for this object */</span>
	<span class="k">struct</span> <span class="n">drm_map_list</span> <span class="n">map_list</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Size of the object, in bytes.  Immutable over the object&#39;s</span>
<span class="cm">	 * lifetime.</span>
<span class="cm">	 */</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Global name for this object, starts at 1. 0 means unnamed.</span>
<span class="cm">	 * Access is covered by the object_name_lock in the related drm_device</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">name</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Memory domains. These monitor which caches contain read/write data</span>
<span class="cm">	 * related to the object. When transitioning from one set of domains</span>
<span class="cm">	 * to another, the driver is called to ensure that caches are suitably</span>
<span class="cm">	 * flushed and invalidated</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span> <span class="n">read_domains</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">write_domain</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * While validating an exec operation, the</span>
<span class="cm">	 * new read/write domain values are computed here.</span>
<span class="cm">	 * They will be transferred to the above values</span>
<span class="cm">	 * at the point that any cache flushing occurs</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span> <span class="n">pending_read_domains</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pending_write_domain</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">driver_private</span><span class="p">;</span>

	<span class="cm">/* dma buf exported from this GEM object */</span>
	<span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">export_dma_buf</span><span class="p">;</span>

	<span class="cm">/* dma buf attachment backing this object */</span>
	<span class="k">struct</span> <span class="n">dma_buf_attachment</span> <span class="o">*</span><span class="n">import_attach</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#include &quot;drm_crtc.h&quot;</span>

<span class="cm">/* per-master structure */</span>
<span class="k">struct</span> <span class="n">drm_master</span> <span class="p">{</span>

	<span class="k">struct</span> <span class="n">kref</span> <span class="n">refcount</span><span class="p">;</span> <span class="cm">/* refcount for this master */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span> <span class="cm">/**&lt; each minor contains a list of masters */</span>
	<span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">minor</span><span class="p">;</span> <span class="cm">/**&lt; link back to minor we are a master for */</span>

	<span class="kt">char</span> <span class="o">*</span><span class="n">unique</span><span class="p">;</span>			<span class="cm">/**&lt; Unique identifier: e.g., busid */</span>
	<span class="kt">int</span> <span class="n">unique_len</span><span class="p">;</span>			<span class="cm">/**&lt; Length of unique field */</span>
	<span class="kt">int</span> <span class="n">unique_size</span><span class="p">;</span>		<span class="cm">/**&lt; amount allocated */</span>

	<span class="kt">int</span> <span class="n">blocked</span><span class="p">;</span>			<span class="cm">/**&lt; Blocked due to VC switch? */</span>

	<span class="cm">/** \name Authentication */</span>
	<span class="cm">/*@{ */</span>
	<span class="k">struct</span> <span class="n">drm_open_hash</span> <span class="n">magiclist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">magicfree</span><span class="p">;</span>
	<span class="cm">/*@} */</span>

	<span class="k">struct</span> <span class="n">drm_lock_data</span> <span class="n">lock</span><span class="p">;</span>	<span class="cm">/**&lt; Information on hardware lock */</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">driver_priv</span><span class="p">;</span> <span class="cm">/**&lt; Private structure for driver to use */</span>
<span class="p">};</span>

<span class="cm">/* Size of ringbuffer for vblank timestamps. Just double-buffer</span>
<span class="cm"> * in initial implementation.</span>
<span class="cm"> */</span>
<span class="cp">#define DRM_VBLANKTIME_RBSIZE 2</span>

<span class="cm">/* Flags and return codes for get_vblank_timestamp() driver function. */</span>
<span class="cp">#define DRM_CALLED_FROM_VBLIRQ 1</span>
<span class="cp">#define DRM_VBLANKTIME_SCANOUTPOS_METHOD (1 &lt;&lt; 0)</span>
<span class="cp">#define DRM_VBLANKTIME_INVBL             (1 &lt;&lt; 1)</span>

<span class="cm">/* get_scanout_position() return flags */</span>
<span class="cp">#define DRM_SCANOUTPOS_VALID        (1 &lt;&lt; 0)</span>
<span class="cp">#define DRM_SCANOUTPOS_INVBL        (1 &lt;&lt; 1)</span>
<span class="cp">#define DRM_SCANOUTPOS_ACCURATE     (1 &lt;&lt; 2)</span>

<span class="k">struct</span> <span class="n">drm_bus</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">bus_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_irq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_name</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_busid</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_master</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_unique</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_master</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">drm_unique</span> <span class="o">*</span><span class="n">unique</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_by_busid</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_irq_busid</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="cm">/* hooks that are for PCI */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">agp_init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM driver structure. This structure represent the common code for</span>
<span class="cm"> * a family of cards. There will one drm_device for each card present</span>
<span class="cm"> * in this family</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_driver</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">load</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">firstopen</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">preclose</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">postclose</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lastclose</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">unload</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dma_ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dma_quiescent</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">context_dtor</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">context</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * get_vblank_counter - get raw hardware vblank counter</span>
<span class="cm">	 * @dev: DRM device</span>
<span class="cm">	 * @crtc: counter to fetch</span>
<span class="cm">	 *</span>
<span class="cm">	 * Driver callback for fetching a raw hardware vblank counter for @crtc.</span>
<span class="cm">	 * If a device doesn&#39;t have a hardware counter, the driver can simply</span>
<span class="cm">	 * return the value of drm_vblank_count. The DRM core will account for</span>
<span class="cm">	 * missed vblank events while interrupts where disabled based on system</span>
<span class="cm">	 * timestamps.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Wraparound handling and loss of events due to modesetting is dealt</span>
<span class="cm">	 * with in the DRM core code.</span>
<span class="cm">	 *</span>
<span class="cm">	 * RETURNS</span>
<span class="cm">	 * Raw vblank counter value.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">get_vblank_counter</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * enable_vblank - enable vblank interrupt events</span>
<span class="cm">	 * @dev: DRM device</span>
<span class="cm">	 * @crtc: which irq to enable</span>
<span class="cm">	 *</span>
<span class="cm">	 * Enable vblank interrupts for @crtc.  If the device doesn&#39;t have</span>
<span class="cm">	 * a hardware vblank counter, this routine should be a no-op, since</span>
<span class="cm">	 * interrupts will have to stay on to keep the count accurate.</span>
<span class="cm">	 *</span>
<span class="cm">	 * RETURNS</span>
<span class="cm">	 * Zero on success, appropriate errno if the given @crtc&#39;s vblank</span>
<span class="cm">	 * interrupt cannot be enabled.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enable_vblank</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * disable_vblank - disable vblank interrupt events</span>
<span class="cm">	 * @dev: DRM device</span>
<span class="cm">	 * @crtc: which irq to enable</span>
<span class="cm">	 *</span>
<span class="cm">	 * Disable vblank interrupts for @crtc.  If the device doesn&#39;t have</span>
<span class="cm">	 * a hardware vblank counter, this routine should be a no-op, since</span>
<span class="cm">	 * interrupts will have to stay on to keep the count accurate.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disable_vblank</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * Called by \c drm_device_is_agp.  Typically used to determine if a</span>
<span class="cm">	 * card is really attached to AGP or not.</span>
<span class="cm">	 *</span>
<span class="cm">	 * \param dev  DRM device handle</span>
<span class="cm">	 *</span>
<span class="cm">	 * \returns</span>
<span class="cm">	 * One of three values is returned depending on whether or not the</span>
<span class="cm">	 * card is absolutely \b not AGP (return of 0), absolutely \b is AGP</span>
<span class="cm">	 * (return of 1), or may or may not be AGP (return of 2).</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">device_is_agp</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * Called by vblank timestamping code.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Return the current display scanout position from a crtc.</span>
<span class="cm">	 *</span>
<span class="cm">	 * \param dev  DRM device.</span>
<span class="cm">	 * \param crtc Id of the crtc to query.</span>
<span class="cm">	 * \param *vpos Target location for current vertical scanout position.</span>
<span class="cm">	 * \param *hpos Target location for current horizontal scanout position.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Returns vpos as a positive number while in active scanout area.</span>
<span class="cm">	 * Returns vpos as a negative number inside vblank, counting the number</span>
<span class="cm">	 * of scanlines to go until end of vblank, e.g., -1 means &quot;one scanline</span>
<span class="cm">	 * until start of active scanout / end of vblank.&quot;</span>
<span class="cm">	 *</span>
<span class="cm">	 * \return Flags, or&#39;ed together as follows:</span>
<span class="cm">	 *</span>
<span class="cm">	 * DRM_SCANOUTPOS_VALID = Query successful.</span>
<span class="cm">	 * DRM_SCANOUTPOS_INVBL = Inside vblank.</span>
<span class="cm">	 * DRM_SCANOUTPOS_ACCURATE = Returned position is accurate. A lack of</span>
<span class="cm">	 * this flag means that returned position may be offset by a constant</span>
<span class="cm">	 * but unknown small number of scanlines wrt. real scanout position.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_scanout_position</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="o">*</span><span class="n">vpos</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">hpos</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * Called by \c drm_get_last_vbltimestamp. Should return a precise</span>
<span class="cm">	 * timestamp when the most recent VBLANK interval ended or will end.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Specifically, the timestamp in @vblank_time should correspond as</span>
<span class="cm">	 * closely as possible to the time when the first video scanline of</span>
<span class="cm">	 * the video frame after the end of VBLANK will start scanning out,</span>
<span class="cm">	 * the time immediately after end of the VBLANK interval. If the</span>
<span class="cm">	 * @crtc is currently inside VBLANK, this will be a time in the future.</span>
<span class="cm">	 * If the @crtc is currently scanning out a frame, this will be the</span>
<span class="cm">	 * past start time of the current scanout. This is meant to adhere</span>
<span class="cm">	 * to the OpenML OML_sync_control extension specification.</span>
<span class="cm">	 *</span>
<span class="cm">	 * \param dev dev DRM device handle.</span>
<span class="cm">	 * \param crtc crtc for which timestamp should be returned.</span>
<span class="cm">	 * \param *max_error Maximum allowable timestamp error in nanoseconds.</span>
<span class="cm">	 *                   Implementation should strive to provide timestamp</span>
<span class="cm">	 *                   with an error of at most *max_error nanoseconds.</span>
<span class="cm">	 *                   Returns true upper bound on error for timestamp.</span>
<span class="cm">	 * \param *vblank_time Target location for returned vblank timestamp.</span>
<span class="cm">	 * \param flags 0 = Defaults, no special treatment needed.</span>
<span class="cm">	 * \param       DRM_CALLED_FROM_VBLIRQ = Function is called from vblank</span>
<span class="cm">	 *	        irq handler. Some drivers need to apply some workarounds</span>
<span class="cm">	 *              for gpu-specific vblank irq quirks if flag is set.</span>
<span class="cm">	 *</span>
<span class="cm">	 * \returns</span>
<span class="cm">	 * Zero if timestamping isn&#39;t supported in current display mode or a</span>
<span class="cm">	 * negative number on failure. A positive status code on success,</span>
<span class="cm">	 * which describes how the vblank_time timestamp was computed.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_vblank_timestamp</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="o">*</span><span class="n">max_error</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">vblank_time</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* these have to be filled in */</span>

	<span class="n">irqreturn_t</span><span class="p">(</span><span class="o">*</span><span class="n">irq_handler</span><span class="p">)</span> <span class="p">(</span><span class="n">DRM_IRQ_ARGS</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_preinstall</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_postinstall</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_uninstall</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reclaim_buffers</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span> <span class="n">file_priv</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reclaim_buffers_locked</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reclaim_buffers_idlelocked</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_version</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">drm_set_version</span> <span class="o">*</span><span class="n">sv</span><span class="p">);</span>

	<span class="cm">/* Master routines */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">master_create</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_master</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">master_destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_master</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>
	<span class="cm">/**</span>
<span class="cm">	 * master_set is called whenever the minor master is set.</span>
<span class="cm">	 * master_drop is called whenever the minor master is dropped.</span>
<span class="cm">	 */</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">master_set</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span>
			  <span class="n">bool</span> <span class="n">from_open</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">master_drop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span>
			    <span class="n">bool</span> <span class="n">from_release</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">debugfs_init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">minor</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">debugfs_cleanup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">minor</span><span class="p">);</span>

	<span class="cm">/**</span>
<span class="cm">	 * Driver-specific constructor for drm_gem_objects, to set up</span>
<span class="cm">	 * obj-&gt;driver_private.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Returns 0 on success.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">gem_init_object</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">gem_free_object</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">gem_open_object</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">gem_close_object</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* prime: */</span>
	<span class="cm">/* export handle -&gt; fd (see drm_gem_prime_handle_to_fd() helper) */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">prime_handle_to_fd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span>
				<span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">prime_fd</span><span class="p">);</span>
	<span class="cm">/* import fd -&gt; handle (see drm_gem_prime_fd_to_handle() helper) */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">prime_fd_to_handle</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">prime_fd</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>
	<span class="cm">/* export GEM -&gt; dmabuf */</span>
	<span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">gem_prime_export</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* import dmabuf -&gt; GEM */</span>
	<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">gem_prime_import</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dma_buf</span><span class="p">);</span>

	<span class="cm">/* vga arb irq handler */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">vgaarb_irq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">state</span><span class="p">);</span>

	<span class="cm">/* dumb alloc support */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dumb_create</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">drm_mode_create_dumb</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dumb_map_offset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">,</span>
			       <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dumb_destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">);</span>

	<span class="cm">/* Driver private ops for this object */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="o">*</span><span class="n">gem_vm_ops</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">major</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">minor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">patchlevel</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">date</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">driver_features</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dev_priv_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_ioctl_desc</span> <span class="o">*</span><span class="n">ioctls</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_ioctls</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">pci</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">platform_device</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">usb</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">kdriver</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>

	<span class="cm">/* List of devices hanging off this driver */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">device_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DRM_MINOR_UNASSIGNED 0</span>
<span class="cp">#define DRM_MINOR_LEGACY 1</span>
<span class="cp">#define DRM_MINOR_CONTROL 2</span>
<span class="cp">#define DRM_MINOR_RENDER 3</span>


<span class="cm">/**</span>
<span class="cm"> * debugfs node list. This structure represents a debugfs file to</span>
<span class="cm"> * be created by the drm core</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_debugfs_list</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span> <span class="cm">/** file name */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">seq_file</span><span class="o">*</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">);</span> <span class="cm">/** show callback */</span>
	<span class="n">u32</span> <span class="n">driver_features</span><span class="p">;</span> <span class="cm">/**&lt; Required driver features for this entry */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * debugfs node structure. This structure represents a debugfs file.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_debugfs_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">minor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_debugfs_list</span> <span class="o">*</span><span class="n">debugfs_ent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dent</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Info file list entry. This structure represents a debugfs or proc file to</span>
<span class="cm"> * be created by the drm core</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_info_list</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span> <span class="cm">/** file name */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">seq_file</span><span class="o">*</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">);</span> <span class="cm">/** show callback */</span>
	<span class="n">u32</span> <span class="n">driver_features</span><span class="p">;</span> <span class="cm">/**&lt; Required driver features for this entry */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * debugfs node structure. This structure represents a debugfs file.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_info_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">minor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_info_list</span> <span class="o">*</span><span class="n">info_ent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dent</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM minor structure. This structure represents a drm minor number.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_minor</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>			<span class="cm">/**&lt; Minor device number */</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>                       <span class="cm">/**&lt; Control or render */</span>
	<span class="n">dev_t</span> <span class="n">device</span><span class="p">;</span>			<span class="cm">/**&lt; Device number for mknod */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">kdev</span><span class="p">;</span>		<span class="cm">/**&lt; Linux device */</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc_root</span><span class="p">;</span>  <span class="cm">/**&lt; proc directory entry */</span>
	<span class="k">struct</span> <span class="n">drm_info_node</span> <span class="n">proc_nodes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_root</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">debugfs_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">debugfs_lock</span><span class="p">;</span> <span class="cm">/* Protects debugfs_list. */</span>

	<span class="k">struct</span> <span class="n">drm_master</span> <span class="o">*</span><span class="n">master</span><span class="p">;</span> <span class="cm">/* currently active master for this node */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">master_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_mode_group</span> <span class="n">mode_group</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* mode specified on the command line */</span>
<span class="k">struct</span> <span class="n">drm_cmdline_mode</span> <span class="p">{</span>
	<span class="n">bool</span> <span class="n">specified</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">refresh_specified</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bpp_specified</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xres</span><span class="p">,</span> <span class="n">yres</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bpp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">refresh</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rb</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">interlace</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">cvt</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">margins</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">drm_connector_force</span> <span class="n">force</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">drm_pending_vblank_event</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_pending_event</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pipe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_event_vblank</span> <span class="n">event</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * DRM device structure. This structure represent a complete card that</span>
<span class="cm"> * may contain multiple heads.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">driver_item</span><span class="p">;</span>	<span class="cm">/**&lt; list of devices per driver */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">;</span>			<span class="cm">/**&lt; For /proc/interrupts */</span>
	<span class="kt">int</span> <span class="n">if_version</span><span class="p">;</span>			<span class="cm">/**&lt; Highest interface version set */</span>

	<span class="cm">/** \name Locks */</span>
	<span class="cm">/*@{ */</span>
	<span class="n">spinlock_t</span> <span class="n">count_lock</span><span class="p">;</span>		<span class="cm">/**&lt; For inuse, drm_device::open_count, drm_device::buf_use */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">struct_mutex</span><span class="p">;</span>	<span class="cm">/**&lt; For others */</span>
	<span class="cm">/*@} */</span>

	<span class="cm">/** \name Usage Counters */</span>
	<span class="cm">/*@{ */</span>
	<span class="kt">int</span> <span class="n">open_count</span><span class="p">;</span>			<span class="cm">/**&lt; Outstanding files open */</span>
	<span class="n">atomic_t</span> <span class="n">ioctl_count</span><span class="p">;</span>		<span class="cm">/**&lt; Outstanding IOCTLs pending */</span>
	<span class="n">atomic_t</span> <span class="n">vma_count</span><span class="p">;</span>		<span class="cm">/**&lt; Outstanding vma areas open */</span>
	<span class="kt">int</span> <span class="n">buf_use</span><span class="p">;</span>			<span class="cm">/**&lt; Buffers in use -- cannot alloc */</span>
	<span class="n">atomic_t</span> <span class="n">buf_alloc</span><span class="p">;</span>		<span class="cm">/**&lt; Buffer allocation in progress */</span>
	<span class="cm">/*@} */</span>

	<span class="cm">/** \name Performance counters */</span>
	<span class="cm">/*@{ */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">counters</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">drm_stat_type</span> <span class="n">types</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
	<span class="n">atomic_t</span> <span class="n">counts</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
	<span class="cm">/*@} */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">filelist</span><span class="p">;</span>

	<span class="cm">/** \name Memory management */</span>
	<span class="cm">/*@{ */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">maplist</span><span class="p">;</span>	<span class="cm">/**&lt; Linked list of regions */</span>
	<span class="kt">int</span> <span class="n">map_count</span><span class="p">;</span>			<span class="cm">/**&lt; Number of mappable regions */</span>
	<span class="k">struct</span> <span class="n">drm_open_hash</span> <span class="n">map_hash</span><span class="p">;</span>	<span class="cm">/**&lt; User token hash table for maps */</span>

	<span class="cm">/** \name Context handle management */</span>
	<span class="cm">/*@{ */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ctxlist</span><span class="p">;</span>	<span class="cm">/**&lt; Linked list of context handles */</span>
	<span class="kt">int</span> <span class="n">ctx_count</span><span class="p">;</span>			<span class="cm">/**&lt; Number of context handles */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">ctxlist_mutex</span><span class="p">;</span>	<span class="cm">/**&lt; For ctxlist */</span>

	<span class="k">struct</span> <span class="n">idr</span> <span class="n">ctx_idr</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">vmalist</span><span class="p">;</span>	<span class="cm">/**&lt; List of vmas (for debugging) */</span>

	<span class="cm">/*@} */</span>

	<span class="cm">/** \name DMA queues (contexts) */</span>
	<span class="cm">/*@{ */</span>
	<span class="kt">int</span> <span class="n">queue_count</span><span class="p">;</span>		<span class="cm">/**&lt; Number of active DMA queues */</span>
	<span class="kt">int</span> <span class="n">queue_reserved</span><span class="p">;</span>		  <span class="cm">/**&lt; Number of reserved DMA queues */</span>
	<span class="kt">int</span> <span class="n">queue_slots</span><span class="p">;</span>		<span class="cm">/**&lt; Actual length of queuelist */</span>
	<span class="k">struct</span> <span class="n">drm_queue</span> <span class="o">**</span><span class="n">queuelist</span><span class="p">;</span>	<span class="cm">/**&lt; Vector of pointers to DMA queues */</span>
	<span class="k">struct</span> <span class="n">drm_device_dma</span> <span class="o">*</span><span class="n">dma</span><span class="p">;</span>		<span class="cm">/**&lt; Optional pointer for DMA support */</span>
	<span class="cm">/*@} */</span>

	<span class="cm">/** \name Context support */</span>
	<span class="cm">/*@{ */</span>
	<span class="kt">int</span> <span class="n">irq_enabled</span><span class="p">;</span>		<span class="cm">/**&lt; True if irq handler is enabled */</span>
	<span class="n">__volatile__</span> <span class="kt">long</span> <span class="n">context_flag</span><span class="p">;</span>	<span class="cm">/**&lt; Context swapping flag */</span>
	<span class="n">__volatile__</span> <span class="kt">long</span> <span class="n">interrupt_flag</span><span class="p">;</span> <span class="cm">/**&lt; Interruption handler flag */</span>
	<span class="n">__volatile__</span> <span class="kt">long</span> <span class="n">dma_flag</span><span class="p">;</span>	<span class="cm">/**&lt; DMA dispatch flag */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">context_wait</span><span class="p">;</span>	<span class="cm">/**&lt; Processes waiting on ctx switch */</span>
	<span class="kt">int</span> <span class="n">last_checked</span><span class="p">;</span>		<span class="cm">/**&lt; Last context checked for DMA */</span>
	<span class="kt">int</span> <span class="n">last_context</span><span class="p">;</span>		<span class="cm">/**&lt; Last current context */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_switch</span><span class="p">;</span>	<span class="cm">/**&lt; jiffies at last context switch */</span>
	<span class="cm">/*@} */</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
	<span class="cm">/** \name VBLANK IRQ support */</span>
	<span class="cm">/*@{ */</span>

	<span class="cm">/*</span>
<span class="cm">	 * At load time, disabling the vblank interrupt won&#39;t be allowed since</span>
<span class="cm">	 * old clients may not call the modeset ioctl and therefore misbehave.</span>
<span class="cm">	 * Once the modeset ioctl *has* been called though, we can safely</span>
<span class="cm">	 * disable them when unused.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">vblank_disable_allowed</span><span class="p">;</span>

	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">vbl_queue</span><span class="p">;</span>   <span class="cm">/**&lt; VBLANK wait queue */</span>
	<span class="n">atomic_t</span> <span class="o">*</span><span class="n">_vblank_count</span><span class="p">;</span>        <span class="cm">/**&lt; number of VBLANK interrupts (driver must alloc the right number of counters) */</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">_vblank_time</span><span class="p">;</span>   <span class="cm">/**&lt; timestamp of current vblank_count (drivers must alloc right number of fields) */</span>
	<span class="n">spinlock_t</span> <span class="n">vblank_time_lock</span><span class="p">;</span>    <span class="cm">/**&lt; Protects vblank count and time updates during vblank enable/disable */</span>
	<span class="n">spinlock_t</span> <span class="n">vbl_lock</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="o">*</span><span class="n">vblank_refcount</span><span class="p">;</span>      <span class="cm">/* number of users of vblank interruptsper crtc */</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">last_vblank</span><span class="p">;</span>               <span class="cm">/* protected by dev-&gt;vbl_lock, used */</span>
					<span class="cm">/* for wraparound handling */</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">vblank_enabled</span><span class="p">;</span>            <span class="cm">/* so we don&#39;t call enable more than</span>
<span class="cm">					   once per disable */</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">vblank_inmodeset</span><span class="p">;</span>          <span class="cm">/* Display driver is setting mode */</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">last_vblank_wait</span><span class="p">;</span>		<span class="cm">/* Last vblank seqno waited per CRTC */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">vblank_disable_timer</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">max_vblank_count</span><span class="p">;</span>           <span class="cm">/**&lt; size of vblank counter register */</span>

	<span class="cm">/**</span>
<span class="cm">	 * List of events</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">vblank_event_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">event_lock</span><span class="p">;</span>

	<span class="cm">/*@} */</span>
	<span class="n">cycles_t</span> <span class="n">ctx_start</span><span class="p">;</span>
	<span class="n">cycles_t</span> <span class="n">lck_start</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">*</span><span class="n">buf_async</span><span class="p">;</span><span class="cm">/**&lt; Processes waiting for SIGIO */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">buf_readers</span><span class="p">;</span>	<span class="cm">/**&lt; Processes waiting to read */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">buf_writers</span><span class="p">;</span>	<span class="cm">/**&lt; Processes waiting to ctx switch */</span>

	<span class="k">struct</span> <span class="n">drm_agp_head</span> <span class="o">*</span><span class="n">agp</span><span class="p">;</span>	<span class="cm">/**&lt; AGP data */</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>             <span class="cm">/**&lt; Device structure */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>		<span class="cm">/**&lt; PCI device structure */</span>
	<span class="kt">int</span> <span class="n">pci_vendor</span><span class="p">;</span>			<span class="cm">/**&lt; PCI vendor id */</span>
	<span class="kt">int</span> <span class="n">pci_device</span><span class="p">;</span>			<span class="cm">/**&lt; PCI device id */</span>
<span class="cp">#ifdef __alpha__</span>
	<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">hose</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">platformdev</span><span class="p">;</span> <span class="cm">/**&lt; Platform device struture */</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usbdev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drm_sg_mem</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>	<span class="cm">/**&lt; Scatter gather memory */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_crtcs</span><span class="p">;</span>                  <span class="cm">/**&lt; Number of CRTCs on this device */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dev_private</span><span class="p">;</span>		<span class="cm">/**&lt; device private data */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mm_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">dev_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_sigdata</span> <span class="n">sigdata</span><span class="p">;</span>	   <span class="cm">/**&lt; For block_all_signals */</span>
	<span class="n">sigset_t</span> <span class="n">sigmask</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drm_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_local_map</span> <span class="o">*</span><span class="n">agp_buffer_map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">agp_buffer_token</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">control</span><span class="p">;</span>		<span class="cm">/**&lt; Control node for card */</span>
	<span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">primary</span><span class="p">;</span>		<span class="cm">/**&lt; render type primary screen head */</span>

        <span class="k">struct</span> <span class="n">drm_mode_config</span> <span class="n">mode_config</span><span class="p">;</span>	<span class="cm">/**&lt; Current mode config */</span>

	<span class="cm">/** \name GEM information */</span>
	<span class="cm">/*@{ */</span>
	<span class="n">spinlock_t</span> <span class="n">object_name_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idr</span> <span class="n">object_name_idr</span><span class="p">;</span>
	<span class="cm">/*@} */</span>
	<span class="kt">int</span> <span class="n">switch_power_state</span><span class="p">;</span>

	<span class="n">atomic_t</span> <span class="n">unplugged</span><span class="p">;</span> <span class="cm">/* device has been unplugged or gone away */</span>
<span class="p">};</span>

<span class="cp">#define DRM_SWITCH_POWER_ON 0</span>
<span class="cp">#define DRM_SWITCH_POWER_OFF 1</span>
<span class="cp">#define DRM_SWITCH_POWER_CHANGING 2</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="nf">drm_core_check_feature</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">feature</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver_features</span> <span class="o">&amp;</span> <span class="n">feature</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drm_dev_to_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">get_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#if __OS_HAS_AGP</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drm_core_has_AGP</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">drm_core_check_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DRIVER_USE_AGP</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define drm_core_has_AGP(dev) (0)</span>
<span class="cp">#endif</span>

<span class="cp">#if __OS_HAS_MTRR</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drm_core_has_MTRR</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">drm_core_check_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DRIVER_USE_MTRR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define DRM_MTRR_WC		MTRR_TYPE_WRCOMB</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drm_mtrr_add</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mtrr_add</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drm_mtrr_del</span><span class="p">(</span><span class="kt">int</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mtrr_del</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="cp">#define drm_core_has_MTRR(dev) (0)</span>

<span class="cp">#define DRM_MTRR_WC		0</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drm_mtrr_add</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drm_mtrr_del</span><span class="p">(</span><span class="kt">int</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drm_device_set_unplugged</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">unplugged</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drm_device_is_unplugged</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">unplugged</span><span class="p">);</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************/</span>
<span class="cm">/** \name Internal function definitions */</span>
<span class="cm">/*@{*/</span>

				<span class="cm">/* Driver support (drm_drv.h) */</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">drm_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">drm_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_lastclose</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

				<span class="cm">/* Device support (drm_fops.h) */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="n">drm_global_mutex</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_stub_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">drm_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>

				<span class="cm">/* Mapping support (drm_vm.h) */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mmap_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_vm_open_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_vm_close_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drm_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="n">wait</span><span class="p">);</span>

				<span class="cm">/* Memory management support (drm_memory.h) */</span>
<span class="cp">#include &quot;drm_memory.h&quot;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_free_agp</span><span class="p">(</span><span class="n">DRM_AGP_MEM</span> <span class="o">*</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pages</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_bind_agp</span><span class="p">(</span><span class="n">DRM_AGP_MEM</span> <span class="o">*</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">DRM_AGP_MEM</span> <span class="o">*</span><span class="n">drm_agp_bind_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_pages</span><span class="p">,</span>
				       <span class="kt">uint32_t</span> <span class="n">gtt_offset</span><span class="p">,</span>
				       <span class="kt">uint32_t</span> <span class="n">type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_unbind_agp</span><span class="p">(</span><span class="n">DRM_AGP_MEM</span> <span class="o">*</span> <span class="n">handle</span><span class="p">);</span>

				<span class="cm">/* Misc. IOCTL support (drm_ioctl.h) */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_irq_by_busid</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_getunique</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_setunique</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_getmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_getclient</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_getstats</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_getcap</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_setversion</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_noop</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>

				<span class="cm">/* Context IOCTL support (drm_context.h) */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_resctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_addctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_modctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_getctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_switchctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_newctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_rmctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_ctxbitmap_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_ctxbitmap_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_ctxbitmap_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ctx_handle</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_setsareactx</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_getsareactx</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>

				<span class="cm">/* Authentication IOCTL support (drm_auth.h) */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_getmagic</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_authmagic</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_remove_magic</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_master</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span> <span class="n">drm_magic_t</span> <span class="n">magic</span><span class="p">);</span>

<span class="cm">/* Cache management (drm_cache.c) */</span>
<span class="kt">void</span> <span class="n">drm_clflush_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_pages</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drm_clflush_virt_range</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">);</span>

				<span class="cm">/* Locking IOCTL support (drm_lock.h) */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_lock_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_lock_data</span> <span class="o">*</span><span class="n">lock_data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">context</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_idlelock_take</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_lock_data</span> <span class="o">*</span><span class="n">lock_data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_idlelock_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_lock_data</span> <span class="o">*</span><span class="n">lock_data</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * These are exported to drivers so that they can implement fencing using</span>
<span class="cm"> * DMA quiscent + idle. DMA quiescent usually requires the hardware lock.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_i_have_hw_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>

				<span class="cm">/* Buffer management support (drm_bufs.h) */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_addbufs_agp</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_buf_desc</span> <span class="o">*</span> <span class="n">request</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_addbufs_pci</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_buf_desc</span> <span class="o">*</span> <span class="n">request</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_addmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">drm_map_type</span> <span class="n">type</span><span class="p">,</span>
		      <span class="k">enum</span> <span class="n">drm_map_flags</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_local_map</span> <span class="o">**</span><span class="n">map_ptr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_addmap_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_rmmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_local_map</span> <span class="o">*</span><span class="n">map</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_rmmap_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_local_map</span> <span class="o">*</span><span class="n">map</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_rmmap_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_addbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_infobufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_markbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_freebufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_mapbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_order</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>

				<span class="cm">/* DMA support (drm_dma.h) */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_dma_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_dma_takedown</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_free_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_buf</span> <span class="o">*</span> <span class="n">buf</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_core_reclaim_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>

				<span class="cm">/* IRQ support (drm_irq.h) */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_irq_install</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_irq_uninstall</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_vblank_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_crtcs</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_wait_vblank</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_vblank_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">vbl_seq</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">drm_vblank_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">drm_vblank_count_and_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">vblanktime</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">drm_handle_vblank</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_vblank_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_vblank_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_vblank_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_vblank_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">drm_get_last_vbltimestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">tvblank</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_calc_vbltimestamp_from_scanoutpos</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						 <span class="kt">int</span> <span class="n">crtc</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">max_error</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">vblank_time</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">refcrtc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_calc_timestamping_constants</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">bool</span>
<span class="n">drm_mode_parse_command_line_for_connector</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mode_option</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">drm_cmdline_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span>
<span class="n">drm_mode_create_from_cmdline_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">drm_cmdline_mode</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>

<span class="cm">/* Modesetting support */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_vblank_pre_modeset</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_vblank_post_modeset</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_modeset_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>

				<span class="cm">/* AGP/GART support (drm_agpsupport.h) */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">drm_agp_head</span> <span class="o">*</span><span class="n">drm_agp_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_agp_acquire</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_agp_acquire_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_agp_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_agp_release_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_agp_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_agp_mode</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_agp_enable_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_agp_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_agp_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_agp_info_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_agp_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_agp_buffer</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_agp_alloc_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_agp_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_agp_buffer</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_agp_free_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_agp_unbind</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_agp_binding</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_agp_unbind_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_agp_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_agp_binding</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_agp_bind_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>

				<span class="cm">/* Stub support (drm_stub.h) */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_setmaster_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_dropmaster_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">drm_master</span> <span class="o">*</span><span class="n">drm_master_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">minor</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">drm_master</span> <span class="o">*</span><span class="n">drm_master_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_master</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_master_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_master</span> <span class="o">**</span><span class="n">master</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_put_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_put_minor</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">**</span><span class="n">minor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_unplug_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drm_debug</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drm_vblank_offdelay</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drm_timestamp_precision</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">drm_class</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">drm_proc_root</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">drm_debugfs_root</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">idr</span> <span class="n">drm_minors_idr</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">drm_local_map</span> <span class="o">*</span><span class="n">drm_getsarea</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

				<span class="cm">/* Proc support (drm_proc.h) */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_proc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">minor</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minor_id</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_proc_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">minor</span><span class="p">,</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>

				<span class="cm">/* Debugfs support */</span>
<span class="cp">#if defined(CONFIG_DEBUG_FS)</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_debugfs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">minor</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minor_id</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_debugfs_create_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_info_list</span> <span class="o">*</span><span class="n">files</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">minor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_debugfs_remove_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_info_list</span> <span class="o">*</span><span class="n">files</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
                                    <span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">minor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_debugfs_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">minor</span><span class="p">);</span>
<span class="cp">#endif</span>

				<span class="cm">/* Info file support */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_name_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_vm_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_queues_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_bufs_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_vblank_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_clients_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_gem_name_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>


<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_gem_prime_handle_to_fd</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">prime_fd</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_gem_prime_fd_to_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prime_fd</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_prime_handle_to_fd_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_prime_fd_to_handle_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_prime_sg_to_page_addr_arrays</span><span class="p">(</span><span class="k">struct</span> <span class="n">sg_table</span> <span class="o">*</span><span class="n">sgt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
					    <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">addrs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_pages</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sg_table</span> <span class="o">*</span><span class="n">drm_prime_pages_to_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_prime_gem_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sg_table</span> <span class="o">*</span><span class="n">sg</span><span class="p">);</span>


<span class="kt">void</span> <span class="n">drm_prime_init_file_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_prime_file_private</span> <span class="o">*</span><span class="n">prime_fpriv</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drm_prime_destroy_file_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_prime_file_private</span> <span class="o">*</span><span class="n">prime_fpriv</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">drm_prime_add_imported_buf_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_prime_file_private</span> <span class="o">*</span><span class="n">prime_fpriv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dma_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">drm_prime_lookup_imported_buf_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_prime_file_private</span> <span class="o">*</span><span class="n">prime_fpriv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dma_buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drm_prime_remove_imported_buf_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_prime_file_private</span> <span class="o">*</span><span class="n">prime_fpriv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dma_buf</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">drm_prime_add_dma_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">drm_prime_lookup_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">**</span><span class="n">obj</span><span class="p">);</span>

<span class="cp">#if DRM_DEBUG_CODE</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_vma_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cp">#endif</span>

				<span class="cm">/* Scatter Gather Support (drm_scatter.h) */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_sg_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_sg_mem</span> <span class="o">*</span> <span class="n">entry</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_sg_alloc_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_sg_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_scatter_gather</span> <span class="o">*</span> <span class="n">request</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_sg_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>

			       <span class="cm">/* ATI PCIGART support (ati_pcigart.h) */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_ati_pcigart_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">drm_ati_pcigart_info</span> <span class="o">*</span> <span class="n">gart_info</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_ati_pcigart_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">drm_ati_pcigart_info</span> <span class="o">*</span> <span class="n">gart_info</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">drm_dma_handle_t</span> <span class="o">*</span><span class="n">drm_pci_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				       <span class="kt">size_t</span> <span class="n">align</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__drm_pci_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">drm_dma_handle_t</span> <span class="o">*</span> <span class="n">dmah</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_pci_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">drm_dma_handle_t</span> <span class="o">*</span> <span class="n">dmah</span><span class="p">);</span>

			       <span class="cm">/* sysfs support (drm_sysfs.c) */</span>
<span class="k">struct</span> <span class="n">drm_sysfs_class</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">drm_sysfs_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_sysfs_destroy</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_sysfs_device_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">minor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_sysfs_hotplug_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_sysfs_device_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">*</span><span class="n">minor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">drm_get_connector_status_name</span><span class="p">(</span><span class="k">enum</span> <span class="n">drm_connector_status</span> <span class="n">status</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_sysfs_connector_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_sysfs_connector_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">);</span>

<span class="cm">/* Graphics Execution Manager library functions (drm_gem.c) */</span>
<span class="kt">int</span> <span class="n">drm_gem_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drm_gem_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drm_gem_object_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drm_gem_object_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">drm_gem_object_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					    <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">drm_gem_object_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">drm_gem_private_object_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drm_gem_object_handle_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drm_gem_vm_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drm_gem_vm_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">drm_gem_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>

<span class="cp">#include &quot;drm_global.h&quot;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">drm_gem_object_reference</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">drm_gem_object_unreference</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">drm_gem_object_free</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">drm_gem_object_unreference_unlocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">drm_gem_object_free</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">drm_gem_handle_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="o">*</span><span class="n">handlep</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">drm_gem_handle_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">handle</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">drm_gem_object_handle_reference</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">drm_gem_object_reference</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">handle_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">drm_gem_object_handle_unreference</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">handle_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Must bump handle count first as this may be the last</span>
<span class="cm">	 * ref, in which case the object would disappear before we</span>
<span class="cm">	 * checked for a name</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">handle_count</span><span class="p">))</span>
		<span class="n">drm_gem_object_handle_free</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="n">drm_gem_object_unreference</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">drm_gem_object_handle_unreference_unlocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">handle_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	* Must bump handle count first as this may be the last</span>
<span class="cm">	* ref, in which case the object would disappear before we</span>
<span class="cm">	* checked for a name</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">handle_count</span><span class="p">))</span>
		<span class="n">drm_gem_object_handle_free</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="n">drm_gem_object_unreference_unlocked</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">drm_gem_free_mmap_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">drm_gem_create_mmap_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">drm_gem_object_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
					     <span class="n">u32</span> <span class="n">handle</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">drm_gem_close_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">drm_gem_flink_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">drm_gem_open_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drm_gem_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_private</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">drm_gem_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_private</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_core_ioremap</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_local_map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_core_ioremap_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_local_map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_core_ioremapfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_local_map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="k">struct</span> <span class="n">drm_local_map</span> <span class="o">*</span><span class="nf">drm_core_findmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
							 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_map_list</span> <span class="o">*</span><span class="n">_entry</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">maplist</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">_entry</span><span class="o">-&gt;</span><span class="n">user_token</span> <span class="o">==</span> <span class="n">token</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">_entry</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">drm_core_dropmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_local_map</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#include &quot;drm_mem_util.h&quot;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_fill_in_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">drm_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">drm_get_minor</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_minor</span> <span class="o">**</span><span class="n">minor</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="cm">/*@}*/</span>

<span class="cm">/* PCI section */</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="nf">drm_pci_device_is_agp</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">device_is_agp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">device_is_agp</span><span class="p">)</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_AGP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_pci_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">pdriver</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_pci_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">pdriver</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_get_pci_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">drm_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>


<span class="cm">/* platform section */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_platform_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">platform_device</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drm_platform_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">platform_device</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">drm_get_platform_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">drm_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>

<span class="cm">/* returns true if currently okay to sleep */</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="n">bool</span> <span class="nf">drm_can_sleep</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_atomic</span><span class="p">()</span> <span class="o">||</span> <span class="n">in_dbg_master</span><span class="p">()</span> <span class="o">||</span> <span class="n">irqs_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif				</span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
