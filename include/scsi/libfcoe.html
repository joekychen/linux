<!DOCTYPE html>
<html><head><title>joekychen/linux » include › scsi › libfcoe.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>libfcoe.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2008-2009 Cisco Systems, Inc.  All rights reserved.</span>
<span class="cm"> * Copyright (c) 2007-2008 Intel Corporation.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintained at www.Open-FCoE.org</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LIBFCOE_H</span>
<span class="cp">#define _LIBFCOE_H</span>

<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;scsi/fc/fc_fcoe.h&gt;</span>
<span class="cp">#include &lt;scsi/libfc.h&gt;</span>
<span class="cp">#include &lt;scsi/fcoe_sysfs.h&gt;</span>

<span class="cp">#define FCOE_MAX_CMD_LEN	16	</span><span class="cm">/* Supported CDB length */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Max MTU for FCoE: 14 (FCoE header) + 24 (FC header) + 2112 (max FC payload)</span>
<span class="cm"> * + 4 (FC CRC) + 4 (FCoE trailer) =  2158 bytes</span>
<span class="cm"> */</span>
<span class="cp">#define FCOE_MTU	2158</span>

<span class="cm">/*</span>
<span class="cm"> * FIP tunable parameters.</span>
<span class="cm"> */</span>
<span class="cp">#define FCOE_CTLR_START_DELAY	2000	</span><span class="cm">/* mS after first adv. to choose FCF */</span><span class="cp"></span>
<span class="cp">#define FCOE_CTRL_SOL_TOV	2000	</span><span class="cm">/* min. solicitation interval (mS) */</span><span class="cp"></span>
<span class="cp">#define FCOE_CTLR_FCF_LIMIT	20	</span><span class="cm">/* max. number of FCF entries */</span><span class="cp"></span>
<span class="cp">#define FCOE_CTLR_VN2VN_LOGIN_LIMIT 3	</span><span class="cm">/* max. VN2VN rport login retries */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * enum fip_state - internal state of FCoE controller.</span>
<span class="cm"> * @FIP_ST_DISABLED: 	controller has been disabled or not yet enabled.</span>
<span class="cm"> * @FIP_ST_LINK_WAIT:	the physical link is down or unusable.</span>
<span class="cm"> * @FIP_ST_AUTO:	determining whether to use FIP or non-FIP mode.</span>
<span class="cm"> * @FIP_ST_NON_FIP:	non-FIP mode selected.</span>
<span class="cm"> * @FIP_ST_ENABLED:	FIP mode selected.</span>
<span class="cm"> * @FIP_ST_VNMP_START:	VN2VN multipath mode start, wait</span>
<span class="cm"> * @FIP_ST_VNMP_PROBE1:	VN2VN sent first probe, listening</span>
<span class="cm"> * @FIP_ST_VNMP_PROBE2:	VN2VN sent second probe, listening</span>
<span class="cm"> * @FIP_ST_VNMP_CLAIM:	VN2VN sent claim, waiting for responses</span>
<span class="cm"> * @FIP_ST_VNMP_UP:	VN2VN multipath mode operation</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">fip_state</span> <span class="p">{</span>
	<span class="n">FIP_ST_DISABLED</span><span class="p">,</span>
	<span class="n">FIP_ST_LINK_WAIT</span><span class="p">,</span>
	<span class="n">FIP_ST_AUTO</span><span class="p">,</span>
	<span class="n">FIP_ST_NON_FIP</span><span class="p">,</span>
	<span class="n">FIP_ST_ENABLED</span><span class="p">,</span>
	<span class="n">FIP_ST_VNMP_START</span><span class="p">,</span>
	<span class="n">FIP_ST_VNMP_PROBE1</span><span class="p">,</span>
	<span class="n">FIP_ST_VNMP_PROBE2</span><span class="p">,</span>
	<span class="n">FIP_ST_VNMP_CLAIM</span><span class="p">,</span>
	<span class="n">FIP_ST_VNMP_UP</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Modes:</span>
<span class="cm"> * The mode is the state that is to be entered after link up.</span>
<span class="cm"> * It must not change after fcoe_ctlr_init() sets it.</span>
<span class="cm"> */</span>
<span class="cp">#define FIP_MODE_AUTO		FIP_ST_AUTO</span>
<span class="cp">#define FIP_MODE_NON_FIP	FIP_ST_NON_FIP</span>
<span class="cp">#define FIP_MODE_FABRIC		FIP_ST_ENABLED</span>
<span class="cp">#define FIP_MODE_VN2VN		FIP_ST_VNMP_START</span>

<span class="cm">/**</span>
<span class="cm"> * struct fcoe_ctlr - FCoE Controller and FIP state</span>
<span class="cm"> * @state:	   internal FIP state for network link and FIP or non-FIP mode.</span>
<span class="cm"> * @mode:	   LLD-selected mode.</span>
<span class="cm"> * @lp:		   &amp;fc_lport: libfc local port.</span>
<span class="cm"> * @sel_fcf:	   currently selected FCF, or NULL.</span>
<span class="cm"> * @fcfs:	   list of discovered FCFs.</span>
<span class="cm"> * @fcf_count:	   number of discovered FCF entries.</span>
<span class="cm"> * @sol_time:	   time when a multicast solicitation was last sent.</span>
<span class="cm"> * @sel_time:	   time after which to select an FCF.</span>
<span class="cm"> * @port_ka_time:  time of next port keep-alive.</span>
<span class="cm"> * @ctlr_ka_time:  time of next controller keep-alive.</span>
<span class="cm"> * @timer:	   timer struct used for all delayed events.</span>
<span class="cm"> * @timer_work:	   &amp;work_struct for doing keep-alives and resets.</span>
<span class="cm"> * @recv_work:	   &amp;work_struct for receiving FIP frames.</span>
<span class="cm"> * @fip_recv_list: list of received FIP frames.</span>
<span class="cm"> * @flogi_req:	   clone of FLOGI request sent</span>
<span class="cm"> * @rnd_state:	   state for pseudo-random number generator.</span>
<span class="cm"> * @port_id:	   proposed or selected local-port ID.</span>
<span class="cm"> * @user_mfs:	   configured maximum FC frame size, including FC header.</span>
<span class="cm"> * @flogi_oxid:    exchange ID of most recent fabric login.</span>
<span class="cm"> * @flogi_req_send: send of FLOGI requested</span>
<span class="cm"> * @flogi_count:   number of FLOGI attempts in AUTO mode.</span>
<span class="cm"> * @map_dest:	   use the FC_MAP mode for destination MAC addresses.</span>
<span class="cm"> * @spma:	   supports SPMA server-provided MACs mode</span>
<span class="cm"> * @probe_tries:   number of FC_IDs probed</span>
<span class="cm"> * @dest_addr:	   MAC address of the selected FC forwarder.</span>
<span class="cm"> * @ctl_src_addr:  the native MAC address of our local port.</span>
<span class="cm"> * @send:	   LLD-supplied function to handle sending FIP Ethernet frames</span>
<span class="cm"> * @update_mac:    LLD-supplied function to handle changes to MAC addresses.</span>
<span class="cm"> * @get_src_addr:  LLD-supplied function to supply a source MAC address.</span>
<span class="cm"> * @ctlr_mutex:	   lock protecting this structure.</span>
<span class="cm"> * @ctlr_lock:     spinlock covering flogi_req</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is used by all FCoE drivers.  It contains information</span>
<span class="cm"> * needed by all FCoE low-level drivers (LLDs) as well as internal state</span>
<span class="cm"> * for FIP, and fields shared with the LLDS.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">fip_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fip_state</span> <span class="n">mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_fcf</span> <span class="o">*</span><span class="n">sel_fcf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">fcfs</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fcf_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sol_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sel_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">port_ka_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ctlr_ka_time</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">timer_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">recv_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">fip_recv_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">flogi_req</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">rnd_state</span> <span class="n">rnd_state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">port_id</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">user_mfs</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flogi_oxid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flogi_req_send</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flogi_count</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">map_dest</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">spma</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">probe_tries</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">priority</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dest_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">ctl_src_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">send</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">update_mac</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">u8</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">get_src_addr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">ctlr_mutex</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">ctlr_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * fcoe_ctlr_priv() - Return the private data from a fcoe_ctlr</span>
<span class="cm"> * @cltr: The fcoe_ctlr whose private data will be returned</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">fcoe_ctlr_priv</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">ctlr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">ctlr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define fcoe_ctlr_to_ctlr_dev(x)					\</span>
<span class="cp">	(struct fcoe_ctlr_device *)(((struct fcoe_ctlr_device *)(x)) - 1)</span>

<span class="cm">/**</span>
<span class="cm"> * struct fcoe_fcf - Fibre-Channel Forwarder</span>
<span class="cm"> * @list:	 list linkage</span>
<span class="cm"> * @event_work:  Work for FC Transport actions queue</span>
<span class="cm"> * @event:       The event to be processed</span>
<span class="cm"> * @fip:         The controller that the FCF was discovered on</span>
<span class="cm"> * @fcf_dev:     The associated fcoe_fcf_device instance</span>
<span class="cm"> * @time:	 system time (jiffies) when an advertisement was last received</span>
<span class="cm"> * @switch_name: WWN of switch from advertisement</span>
<span class="cm"> * @fabric_name: WWN of fabric from advertisement</span>
<span class="cm"> * @fc_map:	 FC_MAP value from advertisement</span>
<span class="cm"> * @fcf_mac:	 Ethernet address of the FCF for FIP traffic</span>
<span class="cm"> * @fcoe_mac:	 Ethernet address of the FCF for FCoE traffic</span>
<span class="cm"> * @vfid:	 virtual fabric ID</span>
<span class="cm"> * @pri:	 selection priority, smaller values are better</span>
<span class="cm"> * @flogi_sent:	 current FLOGI sent to this FCF</span>
<span class="cm"> * @flags:	 flags received from advertisement</span>
<span class="cm"> * @fka_period:	 keep-alive period, in jiffies</span>
<span class="cm"> *</span>
<span class="cm"> * A Fibre-Channel Forwarder (FCF) is the entity on the Ethernet that</span>
<span class="cm"> * passes FCoE frames on to an FC fabric.  This structure represents</span>
<span class="cm"> * one FCF from which advertisements have been received.</span>
<span class="cm"> *</span>
<span class="cm"> * When looking up an FCF, @switch_name, @fabric_name, @fc_map, @vfid, and</span>
<span class="cm"> * @fcf_mac together form the lookup key.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fcoe_fcf</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">event_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">fip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="n">fcf_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time</span><span class="p">;</span>

	<span class="n">u64</span> <span class="n">switch_name</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">fabric_name</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fc_map</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vfid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">fcf_mac</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">fcoe_mac</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>

	<span class="n">u8</span> <span class="n">pri</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flogi_sent</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fka_period</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">fd_flags</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define fcoe_fcf_to_fcf_dev(x)			\</span>
<span class="cp">	((x)-&gt;fcf_dev)</span>

<span class="cm">/**</span>
<span class="cm"> * struct fcoe_rport - VN2VN remote port</span>
<span class="cm"> * @time:	time of create or last beacon packet received from node</span>
<span class="cm"> * @fcoe_len:	max FCoE frame size, not including VLAN or Ethernet headers</span>
<span class="cm"> * @flags:	flags from probe or claim</span>
<span class="cm"> * @login_count: number of unsuccessful rport logins to this port</span>
<span class="cm"> * @enode_mac:	E_Node control MAC address</span>
<span class="cm"> * @vn_mac:	VN_Node assigned MAC address for data</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fcoe_rport</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fcoe_len</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">login_count</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">enode_mac</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">vn_mac</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* FIP API functions */</span>
<span class="kt">void</span> <span class="n">fcoe_ctlr_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fip_state</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fcoe_ctlr_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fcoe_ctlr_link_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fcoe_ctlr_link_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fcoe_ctlr_els_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fcoe_ctlr_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fcoe_ctlr_recv_flogi</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* libfcoe funcs */</span>
<span class="n">u64</span> <span class="n">fcoe_wwn_from_mac</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mac</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fcoe_libfc_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">libfc_function_template</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">init_fcp</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">fcoe_fc_crc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fcoe_start_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fcoe_get_wwn</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">wwn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__fcoe_get_lesb</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_els_lesb</span> <span class="o">*</span><span class="n">fc_lesb</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fcoe_wwn_to_str</span><span class="p">(</span><span class="n">u64</span> <span class="n">wwn</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fcoe_validate_vport_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * is_fip_mode() - returns true if FIP mode selected.</span>
<span class="cm"> * @fip:	FCoE controller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_fip_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr</span> <span class="o">*</span><span class="n">fip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">fip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FIP_ST_ENABLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* helper for FCoE SW HBA drivers, can include subven and subdev if needed. The</span>
<span class="cm"> * modpost would use pci_device_id table to auto-generate formatted module alias</span>
<span class="cm"> * into the corresponding .mod.c file, but there may or may not be a pci device</span>
<span class="cm"> * id table for FCoE drivers so we use the following helper for build the fcoe</span>
<span class="cm"> * driver module alias.</span>
<span class="cm"> */</span>
<span class="cp">#define MODULE_ALIAS_FCOE_PCI(ven, dev) \</span>
<span class="cp">	MODULE_ALIAS(&quot;fcoe-pci:&quot;	\</span>
<span class="cp">		&quot;v&quot; __stringify(ven)	\</span>
<span class="cp">		&quot;d&quot; __stringify(dev) &quot;sv*sd*bc*sc*i*&quot;)</span>

<span class="cm">/* the name of the default FCoE transport driver fcoe.ko */</span>
<span class="cp">#define FCOE_TRANSPORT_DEFAULT	&quot;fcoe&quot;</span>

<span class="cm">/* struct fcoe_transport - The FCoE transport interface</span>
<span class="cm"> * @name:	a vendor specific name for their FCoE transport driver</span>
<span class="cm"> * @attached:	whether this transport is already attached</span>
<span class="cm"> * @list:	list linkage to all attached transports</span>
<span class="cm"> * @match:	handler to allow the transport driver to match up a given netdev</span>
<span class="cm"> * @create:	handler to sysfs entry of create for FCoE instances</span>
<span class="cm"> * @destroy:	handler to sysfs entry of destroy for FCoE instances</span>
<span class="cm"> * @enable:	handler to sysfs entry of enable for FCoE instances</span>
<span class="cm"> * @disable:	handler to sysfs entry of disable for FCoE instances</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="n">bool</span> <span class="n">attached</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fip_state</span> <span class="n">fip_mode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enable</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">disable</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fcoe_percpu_s - The context for FCoE receive thread(s)</span>
<span class="cm"> * @thread:	    The thread context</span>
<span class="cm"> * @fcoe_rx_list:   The queue of pending packets to process</span>
<span class="cm"> * @page:	    The memory page for calculating frame trailer CRCs</span>
<span class="cm"> * @crc_eof_offset: The offset into the CRC page pointing to available</span>
<span class="cm"> *		    memory for a new trailer</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fcoe_percpu_s</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">fcoe_rx_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">crc_eof_page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crc_eof_offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fcoe_port - The FCoE private structure</span>
<span class="cm"> * @priv:		       The associated fcoe interface. The structure is</span>
<span class="cm"> *			       defined by the low level driver</span>
<span class="cm"> * @lport:		       The associated local port</span>
<span class="cm"> * @fcoe_pending_queue:	       The pending Rx queue of skbs</span>
<span class="cm"> * @fcoe_pending_queue_active: Indicates if the pending queue is active</span>
<span class="cm"> * @priority:		       Packet priority (DCB)</span>
<span class="cm"> * @max_queue_depth:	       Max queue depth of pending queue</span>
<span class="cm"> * @min_queue_depth:	       Min queue depth of pending queue</span>
<span class="cm"> * @timer:		       The queue timer</span>
<span class="cm"> * @destroy_work:	       Handle for work context</span>
<span class="cm"> *			       (to prevent RTNL deadlocks)</span>
<span class="cm"> * @data_srt_addr:	       Source address for data</span>
<span class="cm"> *</span>
<span class="cm"> * An instance of this structure is to be allocated along with the</span>
<span class="cm"> * Scsi_Host and libfc fc_lport structures.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fcoe_port</span> <span class="p">{</span>
	<span class="kt">void</span>		      <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span>	      <span class="o">*</span><span class="n">lport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span>   <span class="n">fcoe_pending_queue</span><span class="p">;</span>
	<span class="n">u8</span>		      <span class="n">fcoe_pending_queue_active</span><span class="p">;</span>
	<span class="n">u8</span>		      <span class="n">priority</span><span class="p">;</span>
	<span class="n">u32</span>		      <span class="n">max_queue_depth</span><span class="p">;</span>
	<span class="n">u32</span>		      <span class="n">min_queue_depth</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span>     <span class="n">timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>    <span class="n">destroy_work</span><span class="p">;</span>
	<span class="n">u8</span>		      <span class="n">data_src_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">fcoe_clean_pending_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fcoe_check_wait_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fcoe_queue_timer</span><span class="p">(</span><span class="n">ulong</span> <span class="n">lport</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fcoe_get_paged_crc_eof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tlen</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">fcoe_percpu_s</span> <span class="o">*</span><span class="n">fps</span><span class="p">);</span>

<span class="cm">/* FCoE Sysfs helpers */</span>
<span class="kt">void</span> <span class="n">fcoe_fcf_get_selected</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_fcf_device</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fcoe_ctlr_get_fip_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_ctlr_device</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct netdev_list</span>
<span class="cm"> * A mapping from netdevice to fcoe_transport</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fcoe_netdev_mapping</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="n">ft</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* fcoe transports registration and deregistration */</span>
<span class="kt">int</span> <span class="n">fcoe_transport_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="n">ft</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fcoe_transport_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_transport</span> <span class="o">*</span><span class="n">ft</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _LIBFCOE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
