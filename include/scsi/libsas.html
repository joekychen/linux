<!DOCTYPE html>
<html><head><title>joekychen/linux » include › scsi › libsas.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>libsas.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * SAS host prototypes and structures header file</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005 Adaptec, Inc.  All rights reserved.</span>
<span class="cm"> * Copyright (C) 2005 Luben Tuikov &lt;luben_tuikov@adaptec.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is licensed under GPLv2.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation; either version 2 of the</span>
<span class="cm"> * License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307</span>
<span class="cm"> * USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LIBSAS_H_</span>
<span class="cp">#define _LIBSAS_H_</span>


<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;scsi/sas.h&gt;</span>
<span class="cp">#include &lt;linux/libata.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport_sas.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="k">struct</span> <span class="n">block_device</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">sas_class</span> <span class="p">{</span>
	<span class="n">SAS</span><span class="p">,</span>
	<span class="n">EXPANDER</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">sas_phy_role</span> <span class="p">{</span>
	<span class="n">PHY_ROLE_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">PHY_ROLE_TARGET</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
	<span class="n">PHY_ROLE_INITIATOR</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">sas_phy_type</span> <span class="p">{</span>
        <span class="n">PHY_TYPE_PHYSICAL</span><span class="p">,</span>
        <span class="n">PHY_TYPE_VIRTUAL</span>
<span class="p">};</span>

<span class="cm">/* The events are mnemonically described in sas_dump.c</span>
<span class="cm"> * so when updating/adding events here, please also</span>
<span class="cm"> * update the other file too.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ha_event</span> <span class="p">{</span>
	<span class="n">HAE_RESET</span>             <span class="o">=</span> <span class="mi">0U</span><span class="p">,</span>
	<span class="n">HA_NUM_EVENTS</span>         <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">port_event</span> <span class="p">{</span>
	<span class="n">PORTE_BYTES_DMAED</span>     <span class="o">=</span> <span class="mi">0U</span><span class="p">,</span>
	<span class="n">PORTE_BROADCAST_RCVD</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">PORTE_LINK_RESET_ERR</span>  <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">PORTE_TIMER_EVENT</span>     <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">PORTE_HARD_RESET</span>      <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">PORT_NUM_EVENTS</span>       <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">phy_event</span> <span class="p">{</span>
	<span class="n">PHYE_LOSS_OF_SIGNAL</span>   <span class="o">=</span> <span class="mi">0U</span><span class="p">,</span>
	<span class="n">PHYE_OOB_DONE</span>         <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">PHYE_OOB_ERROR</span>        <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">PHYE_SPINUP_HOLD</span>      <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="cm">/* hot plug SATA, no COMWAKE sent */</span>
	<span class="n">PHY_NUM_EVENTS</span>        <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">discover_event</span> <span class="p">{</span>
	<span class="n">DISCE_DISCOVER_DOMAIN</span>   <span class="o">=</span> <span class="mi">0U</span><span class="p">,</span>
	<span class="n">DISCE_REVALIDATE_DOMAIN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">DISCE_PORT_GONE</span>         <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">DISCE_PROBE</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">DISCE_DESTRUCT</span>		<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">DISC_NUM_EVENTS</span>		<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* ---------- Expander Devices ---------- */</span>

<span class="cp">#define to_dom_device(_obj) container_of(_obj, struct domain_device, dev_obj)</span>
<span class="cp">#define to_dev_attr(_attr)  container_of(_attr, struct domain_dev_attribute,\</span>
<span class="cp">                                         attr)</span>

<span class="k">enum</span> <span class="n">routing_attribute</span> <span class="p">{</span>
	<span class="n">DIRECT_ROUTING</span><span class="p">,</span>
	<span class="n">SUBTRACTIVE_ROUTING</span><span class="p">,</span>
	<span class="n">TABLE_ROUTING</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ex_phy_state</span> <span class="p">{</span>
	<span class="n">PHY_EMPTY</span><span class="p">,</span>
	<span class="n">PHY_VACANT</span><span class="p">,</span>
	<span class="n">PHY_NOT_PRESENT</span><span class="p">,</span>
	<span class="n">PHY_DEVICE_DISCOVERED</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ex_phy</span> <span class="p">{</span>
	<span class="kt">int</span>    <span class="n">phy_id</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">ex_phy_state</span> <span class="n">phy_state</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">sas_dev_type</span> <span class="n">attached_dev_type</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sas_linkrate</span> <span class="n">linkrate</span><span class="p">;</span>

	<span class="n">u8</span>   <span class="n">attached_sata_host</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span>   <span class="n">attached_sata_dev</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span>   <span class="n">attached_sata_ps</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">sas_protocol</span> <span class="n">attached_tproto</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sas_protocol</span> <span class="n">attached_iproto</span><span class="p">;</span>

	<span class="n">u8</span>   <span class="n">attached_sas_addr</span><span class="p">[</span><span class="n">SAS_ADDR_SIZE</span><span class="p">];</span>
	<span class="n">u8</span>   <span class="n">attached_phy_id</span><span class="p">;</span>

	<span class="n">u8</span>   <span class="n">phy_change_count</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">routing_attribute</span> <span class="n">routing_attr</span><span class="p">;</span>
	<span class="n">u8</span>   <span class="k">virtual</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="kt">int</span>  <span class="n">last_da_index</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sas_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sas_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">expander_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">children</span><span class="p">;</span>

	<span class="n">u16</span>    <span class="n">ex_change_count</span><span class="p">;</span>
	<span class="n">u16</span>    <span class="n">max_route_indexes</span><span class="p">;</span>
	<span class="n">u8</span>     <span class="n">num_phys</span><span class="p">;</span>

	<span class="n">u8</span>     <span class="n">t2t_supp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span>     <span class="n">configuring</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span>     <span class="n">conf_route_table</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">u8</span>     <span class="n">enclosure_logical_id</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">ex_phy</span> <span class="o">*</span><span class="n">ex_phy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sas_port</span> <span class="o">*</span><span class="n">parent_port</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">cmd_mutex</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* ---------- SATA device ---------- */</span>
<span class="k">enum</span> <span class="n">ata_command_set</span> <span class="p">{</span>
        <span class="n">ATA_COMMAND_SET</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">ATAPI_COMMAND_SET</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sata_device</span> <span class="p">{</span>
        <span class="k">enum</span>   <span class="n">ata_command_set</span> <span class="n">command_set</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">smp_resp</span>        <span class="n">rps_resp</span><span class="p">;</span> <span class="cm">/* report_phy_sata_resp */</span>
        <span class="n">u8</span>     <span class="n">port_no</span><span class="p">;</span>        <span class="cm">/* port number, if this is a PM (Port) */</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">children</span><span class="p">;</span> <span class="cm">/* PM Ports if this is a PM */</span>

	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="n">ata_host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="n">tf</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SAS_DEV_GONE</span><span class="p">,</span>
	<span class="n">SAS_DEV_DESTROY</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">domain_device</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">done_lock</span><span class="p">;</span>
        <span class="k">enum</span> <span class="n">sas_dev_type</span> <span class="n">dev_type</span><span class="p">;</span>

        <span class="k">enum</span> <span class="n">sas_linkrate</span> <span class="n">linkrate</span><span class="p">;</span>
        <span class="k">enum</span> <span class="n">sas_linkrate</span> <span class="n">min_linkrate</span><span class="p">;</span>
        <span class="k">enum</span> <span class="n">sas_linkrate</span> <span class="n">max_linkrate</span><span class="p">;</span>

        <span class="kt">int</span>  <span class="n">pathways</span><span class="p">;</span>

        <span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">siblings</span><span class="p">;</span> <span class="cm">/* devices on the same level */</span>
        <span class="k">struct</span> <span class="n">asd_sas_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>        <span class="cm">/* shortcut to root of the tree */</span>
	<span class="k">struct</span> <span class="n">sas_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">;</span>

        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">dev_list_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">disco_list_node</span><span class="p">;</span> <span class="cm">/* awaiting probe or destruct */</span>

        <span class="k">enum</span> <span class="n">sas_protocol</span>    <span class="n">iproto</span><span class="p">;</span>
        <span class="k">enum</span> <span class="n">sas_protocol</span>    <span class="n">tproto</span><span class="p">;</span>

        <span class="k">struct</span> <span class="n">sas_rphy</span> <span class="o">*</span><span class="n">rphy</span><span class="p">;</span>

        <span class="n">u8</span>  <span class="n">sas_addr</span><span class="p">[</span><span class="n">SAS_ADDR_SIZE</span><span class="p">];</span>
        <span class="n">u8</span>  <span class="n">hashed_sas_addr</span><span class="p">[</span><span class="n">HASHED_SAS_ADDR_SIZE</span><span class="p">];</span>

        <span class="n">u8</span>  <span class="n">frame_rcvd</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

        <span class="k">union</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">expander_device</span> <span class="n">ex_dev</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">sata_device</span>     <span class="n">sata_dev</span><span class="p">;</span> <span class="cm">/* STP &amp; directly attached */</span>
        <span class="p">};</span>

        <span class="kt">void</span> <span class="o">*</span><span class="n">lldd_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">kref</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sas_work</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">drain_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">INIT_SAS_WORK</span><span class="p">(</span><span class="k">struct</span> <span class="n">sas_work</span> <span class="o">*</span><span class="n">sw</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">drain_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sas_discovery_event</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sas_work</span> <span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asd_sas_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sas_discovery_event</span> <span class="o">*</span><span class="nf">to_sas_discovery_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sas_discovery_event</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ev</span><span class="p">),</span> <span class="n">work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sas_discovery</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sas_discovery_event</span> <span class="n">disc_work</span><span class="p">[</span><span class="n">DISC_NUM_EVENTS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>    <span class="n">pending</span><span class="p">;</span>
	<span class="n">u8</span>     <span class="n">fanout_sas_addr</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u8</span>     <span class="n">eeds_a</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u8</span>     <span class="n">eeds_b</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">int</span>    <span class="n">max_level</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The port struct is Class:RW, driver:RO */</span>
<span class="k">struct</span> <span class="n">asd_sas_port</span> <span class="p">{</span>
<span class="cm">/* private: */</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">port_gone_completion</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sas_discovery</span> <span class="n">disc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="n">port_dev</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">dev_list_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dev_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">disco_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">destroy_list</span><span class="p">;</span>
	<span class="k">enum</span>   <span class="n">sas_linkrate</span> <span class="n">linkrate</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sas_work</span> <span class="n">work</span><span class="p">;</span>

<span class="cm">/* public: */</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">sas_class</span>   <span class="n">class</span><span class="p">;</span>
	<span class="n">u8</span>               <span class="n">sas_addr</span><span class="p">[</span><span class="n">SAS_ADDR_SIZE</span><span class="p">];</span>
	<span class="n">u8</span>               <span class="n">attached_sas_addr</span><span class="p">[</span><span class="n">SAS_ADDR_SIZE</span><span class="p">];</span>
	<span class="k">enum</span> <span class="n">sas_protocol</span>   <span class="n">iproto</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sas_protocol</span>   <span class="n">tproto</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">sas_oob_mode</span> <span class="n">oob_mode</span><span class="p">;</span>

	<span class="n">spinlock_t</span>       <span class="n">phy_list_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">phy_list</span><span class="p">;</span>
	<span class="kt">int</span>              <span class="n">num_phys</span><span class="p">;</span>
	<span class="n">u32</span>              <span class="n">phy_mask</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sas_port</span>	<span class="o">*</span><span class="n">port</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">lldd_port</span><span class="p">;</span>	  <span class="cm">/* not touched by the sas class code */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">asd_sas_event</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sas_work</span> <span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asd_sas_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">asd_sas_event</span> <span class="o">*</span><span class="nf">to_asd_sas_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asd_sas_event</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ev</span><span class="p">),</span> <span class="n">work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The phy pretty much is controlled by the LLDD.</span>
<span class="cm"> * The class only reads those fields.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">asd_sas_phy</span> <span class="p">{</span>
<span class="cm">/* private: */</span>
	<span class="k">struct</span> <span class="n">asd_sas_event</span>   <span class="n">port_events</span><span class="p">[</span><span class="n">PORT_NUM_EVENTS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">asd_sas_event</span>   <span class="n">phy_events</span><span class="p">[</span><span class="n">PHY_NUM_EVENTS</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">port_events_pending</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phy_events_pending</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sas_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">;</span>

<span class="cm">/* public: */</span>
	<span class="cm">/* The following are class:RO, driver:R/W */</span>
	<span class="kt">int</span>            <span class="n">enabled</span><span class="p">;</span>	  <span class="cm">/* must be set */</span>

	<span class="kt">int</span>            <span class="n">id</span><span class="p">;</span>	  <span class="cm">/* must be set */</span>
	<span class="k">enum</span> <span class="n">sas_class</span> <span class="n">class</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sas_protocol</span> <span class="n">iproto</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sas_protocol</span> <span class="n">tproto</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">sas_phy_type</span>  <span class="n">type</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sas_phy_role</span>  <span class="n">role</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sas_oob_mode</span>  <span class="n">oob_mode</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sas_linkrate</span> <span class="n">linkrate</span><span class="p">;</span>

	<span class="n">u8</span>   <span class="o">*</span><span class="n">sas_addr</span><span class="p">;</span>		  <span class="cm">/* must be set */</span>
	<span class="n">u8</span>   <span class="n">attached_sas_addr</span><span class="p">[</span><span class="n">SAS_ADDR_SIZE</span><span class="p">];</span> <span class="cm">/* class:RO, driver: R/W */</span>

	<span class="n">spinlock_t</span>     <span class="n">frame_rcvd_lock</span><span class="p">;</span>
	<span class="n">u8</span>             <span class="o">*</span><span class="n">frame_rcvd</span><span class="p">;</span> <span class="cm">/* must be set */</span>
	<span class="kt">int</span>            <span class="n">frame_rcvd_size</span><span class="p">;</span>

	<span class="n">spinlock_t</span>     <span class="n">sas_prim_lock</span><span class="p">;</span>
	<span class="n">u32</span>            <span class="n">sas_prim</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">port_phy_el</span><span class="p">;</span> <span class="cm">/* driver:RO */</span>
	<span class="k">struct</span> <span class="n">asd_sas_port</span>      <span class="o">*</span><span class="n">port</span><span class="p">;</span> <span class="cm">/* Class:RW, driver: RO */</span>

	<span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span> <span class="cm">/* may be set; the class sets it anyway */</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">lldd_phy</span><span class="p">;</span>		  <span class="cm">/* not touched by the sas_class_code */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">scsi_core</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span>	  <span class="n">task_queue_flush</span><span class="p">;</span>
	<span class="n">spinlock_t</span>        <span class="n">task_queue_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>  <span class="n">task_queue</span><span class="p">;</span>
	<span class="kt">int</span>               <span class="n">task_queue_size</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">queue_thread</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sas_ha_event</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sas_work</span> <span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sas_ha_event</span> <span class="o">*</span><span class="nf">to_sas_ha_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sas_ha_event</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ev</span><span class="p">),</span> <span class="n">work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">sas_ha_state</span> <span class="p">{</span>
	<span class="n">SAS_HA_REGISTERED</span><span class="p">,</span>
	<span class="n">SAS_HA_DRAINING</span><span class="p">,</span>
	<span class="n">SAS_HA_ATA_EH_ACTIVE</span><span class="p">,</span>
	<span class="n">SAS_HA_FROZEN</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="p">{</span>
<span class="cm">/* private: */</span>
	<span class="k">struct</span> <span class="n">sas_ha_event</span> <span class="n">ha_events</span><span class="p">[</span><span class="n">HA_NUM_EVENTS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	 <span class="n">pending</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>  <span class="n">defer_q</span><span class="p">;</span> <span class="cm">/* work queued while draining */</span>
	<span class="k">struct</span> <span class="n">mutex</span>	  <span class="n">drain_mutex</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	  <span class="n">state</span><span class="p">;</span>
	<span class="n">spinlock_t</span> 	  <span class="n">state_lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">disco_mutex</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">scsi_core</span> <span class="n">core</span><span class="p">;</span>

<span class="cm">/* public: */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sas_ha_name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>	  <span class="cm">/* should be set */</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">lldd_module</span><span class="p">;</span> <span class="cm">/* should be set */</span>

	<span class="n">u8</span> <span class="o">*</span><span class="n">sas_addr</span><span class="p">;</span>		  <span class="cm">/* must be set */</span>
	<span class="n">u8</span> <span class="n">hashed_sas_addr</span><span class="p">[</span><span class="n">HASHED_SAS_ADDR_SIZE</span><span class="p">];</span>

	<span class="n">spinlock_t</span>      <span class="n">phy_port_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asd_sas_phy</span>  <span class="o">**</span><span class="n">sas_phy</span><span class="p">;</span> <span class="cm">/* array of valid pointers, must be set */</span>
	<span class="k">struct</span> <span class="n">asd_sas_port</span> <span class="o">**</span><span class="n">sas_port</span><span class="p">;</span> <span class="cm">/* array of valid pointers, must be set */</span>
	<span class="kt">int</span>             <span class="n">num_phys</span><span class="p">;</span> <span class="cm">/* must be set, gt 0, static */</span>

	<span class="cm">/* The class calls this to send a task for execution. */</span>
	<span class="kt">int</span> <span class="n">lldd_max_execute_num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lldd_queue_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">strict_wide_ports</span><span class="p">;</span> <span class="cm">/* both sas_addr and attached_sas_addr must match</span>
<span class="cm">				* their siblings when forming wide ports */</span>

	<span class="cm">/* LLDD calls these to notify the class of an event. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">notify_ha_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ha_event</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">notify_port_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">asd_sas_phy</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">port_event</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">notify_phy_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">asd_sas_phy</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">phy_event</span><span class="p">);</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">lldd_ha</span><span class="p">;</span>		  <span class="cm">/* not touched by sas class code */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">eh_done_q</span><span class="p">;</span>  <span class="cm">/* complete via scsi_eh_flush_done_q */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">eh_ata_q</span><span class="p">;</span> <span class="cm">/* scmds to promote from sas to ata eh */</span>
<span class="p">};</span>

<span class="cp">#define SHOST_TO_SAS_HA(_shost) (*(struct sas_ha_struct **)(_shost)-&gt;hostdata)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span>
<span class="nf">starget_to_domain_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">starget</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span>
<span class="nf">sdev_to_domain_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">starget_to_domain_dev</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="nf">sas_to_ata_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sata_dev</span><span class="p">.</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">device</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span>
<span class="nf">cmd_to_domain_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sdev_to_domain_dev</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">sas_hash_addr</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">hashed</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">sas_addr</span><span class="p">);</span>

<span class="cm">/* Before calling a notify event, LLDD should use this function</span>
<span class="cm"> * when the link is severed (possibly from its tasklet).</span>
<span class="cm"> * The idea is that the Class only reads those, while the LLDD,</span>
<span class="cm"> * can R/W these (thus avoiding a race).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sas_phy_disconnected</span><span class="p">(</span><span class="k">struct</span> <span class="n">asd_sas_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">oob_mode</span> <span class="o">=</span> <span class="n">OOB_NOT_CONNECTED</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">linkrate</span> <span class="o">=</span> <span class="n">SAS_LINK_RATE_UNKNOWN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">to_sas_gpio_od</span><span class="p">(</span><span class="kt">int</span> <span class="n">device</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">device</span> <span class="o">+</span> <span class="n">bit</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sas_put_local_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sas_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SCSI_SAS_HOST_SMP</span>
<span class="kt">int</span> <span class="n">try_test_sas_gpio_gp_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">od</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u8</span> <span class="n">index</span><span class="p">,</span> <span class="n">u8</span> <span class="n">count</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">try_test_sas_gpio_gp_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">od</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u8</span> <span class="n">index</span><span class="p">,</span> <span class="n">u8</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* ---------- Tasks ---------- */</span>
<span class="cm">/*</span>
<span class="cm">      service_response |  SAS_TASK_COMPLETE  |  SAS_TASK_UNDELIVERED |</span>
<span class="cm">  exec_status          |                     |                       |</span>
<span class="cm">  ---------------------+---------------------+-----------------------+</span>
<span class="cm">       SAM_...         |         X           |                       |</span>
<span class="cm">       DEV_NO_RESPONSE |         X           |           X           |</span>
<span class="cm">       INTERRUPTED     |         X           |                       |</span>
<span class="cm">       QUEUE_FULL      |                     |           X           |</span>
<span class="cm">       DEVICE_UNKNOWN  |                     |           X           |</span>
<span class="cm">       SG_ERR          |                     |           X           |</span>
<span class="cm">  ---------------------+---------------------+-----------------------+</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">service_response</span> <span class="p">{</span>
	<span class="n">SAS_TASK_COMPLETE</span><span class="p">,</span>
	<span class="n">SAS_TASK_UNDELIVERED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">exec_status</span> <span class="p">{</span>
	<span class="cm">/* The SAM_STAT_.. codes fit in the lower 6 bits, alias some of</span>
<span class="cm">	 * them here to silence &#39;case value not in enumerated type&#39; warnings</span>
<span class="cm">	 */</span>
	<span class="n">__SAM_STAT_CHECK_CONDITION</span> <span class="o">=</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">,</span>

	<span class="n">SAS_DEV_NO_RESPONSE</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span>
	<span class="n">SAS_DATA_UNDERRUN</span><span class="p">,</span>
	<span class="n">SAS_DATA_OVERRUN</span><span class="p">,</span>
	<span class="n">SAS_INTERRUPTED</span><span class="p">,</span>
	<span class="n">SAS_QUEUE_FULL</span><span class="p">,</span>
	<span class="n">SAS_DEVICE_UNKNOWN</span><span class="p">,</span>
	<span class="n">SAS_SG_ERR</span><span class="p">,</span>
	<span class="n">SAS_OPEN_REJECT</span><span class="p">,</span>
	<span class="n">SAS_OPEN_TO</span><span class="p">,</span>
	<span class="n">SAS_PROTO_RESPONSE</span><span class="p">,</span>
	<span class="n">SAS_PHY_DOWN</span><span class="p">,</span>
	<span class="n">SAS_NAK_R_ERR</span><span class="p">,</span>
	<span class="n">SAS_PENDING</span><span class="p">,</span>
	<span class="n">SAS_ABORTED_TASK</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* When a task finishes with a response, the LLDD examines the</span>
<span class="cm"> * response:</span>
<span class="cm"> * 	- For an ATA task task_status_struct::stat is set to</span>
<span class="cm"> * SAS_PROTO_RESPONSE, and the task_status_struct::buf is set to the</span>
<span class="cm"> * contents of struct ata_task_resp.</span>
<span class="cm"> * 	- For SSP tasks, if no data is present or status/TMF response</span>
<span class="cm"> * is valid, task_status_struct::stat is set.  If data is present</span>
<span class="cm"> * (SENSE data), the LLDD copies up to SAS_STATUS_BUF_SIZE, sets</span>
<span class="cm"> * task_status_struct::buf_valid_size, and task_status_struct::stat is</span>
<span class="cm"> * set to SAM_CHECK_COND.</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;buf&quot; has format SCSI Sense for SSP task, or struct ata_task_resp</span>
<span class="cm"> * for ATA task.</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;frame_len&quot; is the total frame length, which could be more or less</span>
<span class="cm"> * than actually copied.</span>
<span class="cm"> *</span>
<span class="cm"> * Tasks ending with response, always set the residual field.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ata_task_resp</span> <span class="p">{</span>
	<span class="n">u16</span>  <span class="n">frame_len</span><span class="p">;</span>
	<span class="n">u8</span>   <span class="n">ending_fis</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>	  <span class="cm">/* dev to host or data-in */</span>
<span class="p">};</span>

<span class="cp">#define SAS_STATUS_BUF_SIZE 96</span>

<span class="k">struct</span> <span class="n">task_status_struct</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">service_response</span> <span class="n">resp</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">exec_status</span>      <span class="n">stat</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">buf_valid_size</span><span class="p">;</span>

	<span class="n">u8</span>   <span class="n">buf</span><span class="p">[</span><span class="n">SAS_STATUS_BUF_SIZE</span><span class="p">];</span>

	<span class="n">u32</span>  <span class="n">residual</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sas_open_rej_reason</span> <span class="n">open_rej_reason</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* ATA and ATAPI task queuable to a SAS LLDD.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sas_ata_task</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">host_to_dev_fis</span> <span class="n">fis</span><span class="p">;</span>
	<span class="n">u8</span>     <span class="n">atapi_packet</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>  <span class="cm">/* 0 if not ATAPI task */</span>

	<span class="n">u8</span>     <span class="n">retry_count</span><span class="p">;</span>	  <span class="cm">/* hardware retry, should be &gt; 0 */</span>

	<span class="n">u8</span>     <span class="n">dma_xfer</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	  <span class="cm">/* PIO:0 or DMA:1 */</span>
	<span class="n">u8</span>     <span class="n">use_ncq</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span>     <span class="n">set_affil_pol</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span>     <span class="n">stp_affil_pol</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">u8</span>     <span class="n">device_control_reg_update</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sas_smp_task</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">smp_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">smp_resp</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">task_attribute</span> <span class="p">{</span>
	<span class="n">TASK_ATTR_SIMPLE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">TASK_ATTR_HOQ</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">TASK_ATTR_ORDERED</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">TASK_ATTR_ACA</span>    <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sas_ssp_task</span> <span class="p">{</span>
	<span class="n">u8</span>     <span class="n">retry_count</span><span class="p">;</span>	  <span class="cm">/* hardware retry, should be &gt; 0 */</span>

	<span class="n">u8</span>     <span class="n">LUN</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u8</span>     <span class="n">enable_first_burst</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">enum</span>   <span class="n">task_attribute</span> <span class="n">task_attr</span><span class="p">;</span>
	<span class="n">u8</span>     <span class="n">task_prio</span><span class="p">;</span>
	<span class="n">u8</span>     <span class="n">cdb</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sas_task</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>      <span class="n">list</span><span class="p">;</span>

	<span class="n">spinlock_t</span>   <span class="n">task_state_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span>     <span class="n">task_state_flags</span><span class="p">;</span>

	<span class="k">enum</span>   <span class="n">sas_protocol</span>      <span class="n">task_proto</span><span class="p">;</span>

	<span class="cm">/* Used by the discovery code. */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>     <span class="n">timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>     <span class="n">completion</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sas_ata_task</span> <span class="n">ata_task</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sas_smp_task</span> <span class="n">smp_task</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sas_ssp_task</span> <span class="n">ssp_task</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">scatter</span><span class="p">;</span>
	<span class="kt">int</span>    <span class="n">num_scatter</span><span class="p">;</span>
	<span class="n">u32</span>    <span class="n">total_xfer_len</span><span class="p">;</span>
	<span class="n">u8</span>     <span class="n">data_dir</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>	  <span class="cm">/* Use PCI_DMA_... */</span>

	<span class="k">struct</span> <span class="n">task_status_struct</span> <span class="n">task_status</span><span class="p">;</span>
	<span class="kt">void</span>   <span class="p">(</span><span class="o">*</span><span class="n">task_done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sas_task</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">void</span>   <span class="o">*</span><span class="n">lldd_task</span><span class="p">;</span>	  <span class="cm">/* for use by LLDDs */</span>
	<span class="kt">void</span>   <span class="o">*</span><span class="n">uldd_task</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">abort_work</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define SAS_TASK_STATE_PENDING      1</span>
<span class="cp">#define SAS_TASK_STATE_DONE         2</span>
<span class="cp">#define SAS_TASK_STATE_ABORTED      4</span>
<span class="cp">#define SAS_TASK_NEED_DEV_RESET     8</span>
<span class="cp">#define SAS_TASK_AT_INITIATOR       16</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">sas_task</span> <span class="o">*</span><span class="n">sas_alloc_task</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sas_free_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">sas_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">sas_domain_function_template</span> <span class="p">{</span>
	<span class="cm">/* The class calls these to notify the LLDD of an event. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_port_formed</span><span class="p">)(</span><span class="k">struct</span> <span class="n">asd_sas_phy</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_port_deformed</span><span class="p">)(</span><span class="k">struct</span> <span class="n">asd_sas_phy</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* The class calls these when a device is found or gone. */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">lldd_dev_found</span><span class="p">)(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_dev_gone</span><span class="p">)(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_execute_task</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sas_task</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span>
				 <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">);</span>

	<span class="cm">/* Task Management Functions. Must be called from process context. */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_abort_task</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sas_task</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_abort_task_set</span><span class="p">)(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">lun</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_clear_aca</span><span class="p">)(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">lun</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_clear_task_set</span><span class="p">)(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">lun</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_I_T_nexus_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_ata_check_ready</span><span class="p">)(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_ata_set_dmamode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_lu_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">lun</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_query_task</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sas_task</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Port and Adapter management */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_clear_nexus_port</span><span class="p">)(</span><span class="k">struct</span> <span class="n">asd_sas_port</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_clear_nexus_ha</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Phy management */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_control_phy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">asd_sas_phy</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">phy_func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* GPIO support */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lldd_write_gpio</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg_type</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="n">reg_index</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg_count</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">write_data</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sas_register_ha</span><span class="p">(</span><span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sas_unregister_ha</span><span class="p">(</span><span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">sas_set_phy_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">sas_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">sas_phy_linkrates</span> <span class="o">*</span><span class="n">rates</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sas_phy_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sas_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hard_reset</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sas_queue_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">sas_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sas_queuecommand</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span> <span class="p">,</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sas_target_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sas_slave_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sas_change_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_depth</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">reason</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sas_change_queue_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sas_bios_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span>
			  <span class="n">sector_t</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">hsc</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="o">*</span>
<span class="n">sas_domain_attach_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">sas_domain_function_template</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sas_domain_release_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span>  <span class="n">sas_discover_root_expander</span><span class="p">(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">sas_init_ex_attr</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span>  <span class="n">sas_ex_revalidate_domain</span><span class="p">(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">sas_unregister_domain_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">asd_sas_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gone</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sas_init_disc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sas_discovery</span> <span class="o">*</span><span class="n">disc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">asd_sas_port</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span>  <span class="n">sas_discover_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">asd_sas_port</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">discover_event</span> <span class="n">ev</span><span class="p">);</span>

<span class="kt">int</span>  <span class="n">sas_discover_sata</span><span class="p">(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span>  <span class="n">sas_discover_end_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">sas_unregister_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">asd_sas_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">sas_init_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">sas_task_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">sas_task</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sas_eh_device_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sas_eh_bus_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sas_target_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sas_slave_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sas_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sas_drain_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="n">ha</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sas_smp_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sas_rphy</span> <span class="o">*</span><span class="n">rphy</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sas_ssp_task_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sas_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ssp_response_iu</span> <span class="o">*</span><span class="n">iu</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sas_phy</span> <span class="o">*</span><span class="n">sas_get_local_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">sas_request_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _SASLIB_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
