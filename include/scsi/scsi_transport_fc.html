<!DOCTYPE html>
<html><head><title>joekychen/linux » include › scsi › scsi_transport_fc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>scsi_transport_fc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  FiberChannel transport specific attributes exported to sysfs.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) 2003 Silicon Graphics, Inc.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> *</span>
<span class="cm"> *  ========</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2004-2007   James Smart, Emulex Corporation</span>
<span class="cm"> *    Rewrite for host, target, device, and remote port attributes,</span>
<span class="cm"> *    statistics, and service functions...</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifndef SCSI_TRANSPORT_FC_H</span>
<span class="cp">#define SCSI_TRANSPORT_FC_H</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_netlink.h&gt;</span>

<span class="k">struct</span> <span class="n">scsi_transport_template</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * FC Port definitions - Following FC HBAAPI guidelines</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Not all binary values for the different fields match HBAAPI.</span>
<span class="cm"> *  Instead, we use densely packed ordinal values or enums.</span>
<span class="cm"> *  We get away with this as we never present the actual binary values</span>
<span class="cm"> *  externally. For sysfs, we always present the string that describes</span>
<span class="cm"> *  the value. Thus, an admin doesn&#39;t need a magic HBAAPI decoder ring</span>
<span class="cm"> *  to understand the values. The HBAAPI user-space library is free to</span>
<span class="cm"> *  convert the strings into the HBAAPI-specified binary values.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Not all HBAAPI-defined values are contained in the definitions</span>
<span class="cm"> *  below. Those not appropriate to an fc_host (e.g. FCP initiator) have</span>
<span class="cm"> *  been removed.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * fc_port_type: If you alter this, you also need to alter scsi_transport_fc.c</span>
<span class="cm"> * (for the ascii descriptions).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">fc_port_type</span> <span class="p">{</span>
	<span class="n">FC_PORTTYPE_UNKNOWN</span><span class="p">,</span>
	<span class="n">FC_PORTTYPE_OTHER</span><span class="p">,</span>
	<span class="n">FC_PORTTYPE_NOTPRESENT</span><span class="p">,</span>
	<span class="n">FC_PORTTYPE_NPORT</span><span class="p">,</span>		<span class="cm">/* Attached to FPort */</span>
	<span class="n">FC_PORTTYPE_NLPORT</span><span class="p">,</span>		<span class="cm">/* (Public) Loop w/ FLPort */</span>
	<span class="n">FC_PORTTYPE_LPORT</span><span class="p">,</span>		<span class="cm">/* (Private) Loop w/o FLPort */</span>
	<span class="n">FC_PORTTYPE_PTP</span><span class="p">,</span>		<span class="cm">/* Point to Point w/ another NPort */</span>
	<span class="n">FC_PORTTYPE_NPIV</span><span class="p">,</span>		<span class="cm">/* VPORT based on NPIV */</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * fc_port_state: If you alter this, you also need to alter scsi_transport_fc.c</span>
<span class="cm"> * (for the ascii descriptions).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">fc_port_state</span> <span class="p">{</span>
	<span class="n">FC_PORTSTATE_UNKNOWN</span><span class="p">,</span>
	<span class="n">FC_PORTSTATE_NOTPRESENT</span><span class="p">,</span>
	<span class="n">FC_PORTSTATE_ONLINE</span><span class="p">,</span>
	<span class="n">FC_PORTSTATE_OFFLINE</span><span class="p">,</span>		<span class="cm">/* User has taken Port Offline */</span>
	<span class="n">FC_PORTSTATE_BLOCKED</span><span class="p">,</span>
	<span class="n">FC_PORTSTATE_BYPASSED</span><span class="p">,</span>
	<span class="n">FC_PORTSTATE_DIAGNOSTICS</span><span class="p">,</span>
	<span class="n">FC_PORTSTATE_LINKDOWN</span><span class="p">,</span>
	<span class="n">FC_PORTSTATE_ERROR</span><span class="p">,</span>
	<span class="n">FC_PORTSTATE_LOOPBACK</span><span class="p">,</span>
	<span class="n">FC_PORTSTATE_DELETED</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * fc_vport_state: If you alter this, you also need to alter</span>
<span class="cm"> * scsi_transport_fc.c (for the ascii descriptions).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">fc_vport_state</span> <span class="p">{</span>
	<span class="n">FC_VPORT_UNKNOWN</span><span class="p">,</span>
	<span class="n">FC_VPORT_ACTIVE</span><span class="p">,</span>
	<span class="n">FC_VPORT_DISABLED</span><span class="p">,</span>
	<span class="n">FC_VPORT_LINKDOWN</span><span class="p">,</span>
	<span class="n">FC_VPORT_INITIALIZING</span><span class="p">,</span>
	<span class="n">FC_VPORT_NO_FABRIC_SUPP</span><span class="p">,</span>
	<span class="n">FC_VPORT_NO_FABRIC_RSCS</span><span class="p">,</span>
	<span class="n">FC_VPORT_FABRIC_LOGOUT</span><span class="p">,</span>
	<span class="n">FC_VPORT_FABRIC_REJ_WWN</span><span class="p">,</span>
	<span class="n">FC_VPORT_FAILED</span><span class="p">,</span>
<span class="p">};</span>



<span class="cm">/*</span>
<span class="cm"> * FC Classes of Service</span>
<span class="cm"> * Note: values are not enumerated, as they can be &quot;or&#39;d&quot; together</span>
<span class="cm"> * for reporting (e.g. report supported_classes). If you alter this list,</span>
<span class="cm"> * you also need to alter scsi_transport_fc.c (for the ascii descriptions).</span>
<span class="cm"> */</span>
<span class="cp">#define FC_COS_UNSPECIFIED		0</span>
<span class="cp">#define FC_COS_CLASS1			2</span>
<span class="cp">#define FC_COS_CLASS2			4</span>
<span class="cp">#define FC_COS_CLASS3			8</span>
<span class="cp">#define FC_COS_CLASS4			0x10</span>
<span class="cp">#define FC_COS_CLASS6			0x40</span>

<span class="cm">/*</span>
<span class="cm"> * FC Port Speeds</span>
<span class="cm"> * Note: values are not enumerated, as they can be &quot;or&#39;d&quot; together</span>
<span class="cm"> * for reporting (e.g. report supported_speeds). If you alter this list,</span>
<span class="cm"> * you also need to alter scsi_transport_fc.c (for the ascii descriptions).</span>
<span class="cm"> */</span>
<span class="cp">#define FC_PORTSPEED_UNKNOWN		0 </span><span class="cm">/* Unknown - transceiver</span>
<span class="cm">					     incapable of reporting */</span><span class="cp"></span>
<span class="cp">#define FC_PORTSPEED_1GBIT		1</span>
<span class="cp">#define FC_PORTSPEED_2GBIT		2</span>
<span class="cp">#define FC_PORTSPEED_10GBIT		4</span>
<span class="cp">#define FC_PORTSPEED_4GBIT		8</span>
<span class="cp">#define FC_PORTSPEED_8GBIT		0x10</span>
<span class="cp">#define FC_PORTSPEED_16GBIT		0x20</span>
<span class="cp">#define FC_PORTSPEED_NOT_NEGOTIATED	(1 &lt;&lt; 15) </span><span class="cm">/* Speed not established */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * fc_tgtid_binding_type: If you alter this, you also need to alter</span>
<span class="cm"> * scsi_transport_fc.c (for the ascii descriptions).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">fc_tgtid_binding_type</span>  <span class="p">{</span>
	<span class="n">FC_TGTID_BIND_NONE</span><span class="p">,</span>
	<span class="n">FC_TGTID_BIND_BY_WWPN</span><span class="p">,</span>
	<span class="n">FC_TGTID_BIND_BY_WWNN</span><span class="p">,</span>
	<span class="n">FC_TGTID_BIND_BY_ID</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * FC Port Roles</span>
<span class="cm"> * Note: values are not enumerated, as they can be &quot;or&#39;d&quot; together</span>
<span class="cm"> * for reporting (e.g. report roles). If you alter this list,</span>
<span class="cm"> * you also need to alter scsi_transport_fc.c (for the ascii descriptions).</span>
<span class="cm"> */</span>
<span class="cp">#define FC_PORT_ROLE_UNKNOWN			0x00</span>
<span class="cp">#define FC_PORT_ROLE_FCP_TARGET			0x01</span>
<span class="cp">#define FC_PORT_ROLE_FCP_INITIATOR		0x02</span>
<span class="cp">#define FC_PORT_ROLE_IP_PORT			0x04</span>

<span class="cm">/* The following are for compatibility */</span>
<span class="cp">#define FC_RPORT_ROLE_UNKNOWN			FC_PORT_ROLE_UNKNOWN</span>
<span class="cp">#define FC_RPORT_ROLE_FCP_TARGET		FC_PORT_ROLE_FCP_TARGET</span>
<span class="cp">#define FC_RPORT_ROLE_FCP_INITIATOR		FC_PORT_ROLE_FCP_INITIATOR</span>
<span class="cp">#define FC_RPORT_ROLE_IP_PORT			FC_PORT_ROLE_IP_PORT</span>


<span class="cm">/* Macro for use in defining Virtual Port attributes */</span>
<span class="cp">#define FC_VPORT_ATTR(_name,_mode,_show,_store)		\</span>
<span class="cp">struct device_attribute dev_attr_vport_##_name = 	\</span>
<span class="cp">	__ATTR(_name,_mode,_show,_store)</span>

<span class="cm">/*</span>
<span class="cm"> * fc_vport_identifiers: This set of data contains all elements</span>
<span class="cm"> * to uniquely identify and instantiate a FC virtual port.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *   symbolic_name: The driver is to append the symbolic_name string data</span>
<span class="cm"> *      to the symbolic_node_name data that it generates by default.</span>
<span class="cm"> *      the resulting combination should then be registered with the switch.</span>
<span class="cm"> *      It is expected that things like Xen may stuff a VM title into</span>
<span class="cm"> *      this field.</span>
<span class="cm"> */</span>
<span class="cp">#define FC_VPORT_SYMBOLIC_NAMELEN		64</span>
<span class="k">struct</span> <span class="n">fc_vport_identifiers</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">node_name</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">port_name</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">roles</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">disable</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_port_type</span> <span class="n">vport_type</span><span class="p">;</span>	<span class="cm">/* only FC_PORTTYPE_NPIV allowed */</span>
	<span class="kt">char</span> <span class="n">symbolic_name</span><span class="p">[</span><span class="n">FC_VPORT_SYMBOLIC_NAMELEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * FC Virtual Port Attributes</span>
<span class="cm"> *</span>
<span class="cm"> * This structure exists for each FC port is a virtual FC port. Virtual</span>
<span class="cm"> * ports share the physical link with the Physical port. Each virtual</span>
<span class="cm"> * ports has a unique presence on the SAN, and may be instantiated via</span>
<span class="cm"> * NPIV, Virtual Fabrics, or via additional ALPAs. As the vport is a</span>
<span class="cm"> * unique presence, each vport has it&#39;s own view of the fabric,</span>
<span class="cm"> * authentication privilege, and priorities.</span>
<span class="cm"> *</span>
<span class="cm"> * A virtual port may support 1 or more FC4 roles. Typically it is a</span>
<span class="cm"> * FCP Initiator. It could be a FCP Target, or exist sole for an IP over FC</span>
<span class="cm"> * roles. FC port attributes for the vport will be reported on any</span>
<span class="cm"> * fc_host class object allocated for an FCP Initiator.</span>
<span class="cm"> *</span>
<span class="cm"> * --</span>
<span class="cm"> *</span>
<span class="cm"> * Fixed attributes are not expected to change. The driver is</span>
<span class="cm"> * expected to set these values after receiving the fc_vport structure</span>
<span class="cm"> * via the vport_create() call from the transport.</span>
<span class="cm"> * The transport fully manages all get functions w/o driver interaction.</span>
<span class="cm"> *</span>
<span class="cm"> * Dynamic attributes are expected to change. The driver participates</span>
<span class="cm"> * in all get/set operations via functions provided by the driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Private attributes are transport-managed values. They are fully</span>
<span class="cm"> * managed by the transport w/o driver interaction.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">fc_vport</span> <span class="p">{</span>
	<span class="cm">/* Fixed Attributes */</span>

	<span class="cm">/* Dynamic Attributes */</span>

	<span class="cm">/* Private (Transport-managed) Attributes */</span>
	<span class="k">enum</span> <span class="n">fc_vport_state</span> <span class="n">vport_state</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_vport_state</span> <span class="n">vport_last_state</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">node_name</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">port_name</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">roles</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vport_id</span><span class="p">;</span>		<span class="cm">/* Admin Identifier for the vport */</span>
	<span class="k">enum</span> <span class="n">fc_port_type</span> <span class="n">vport_type</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">symbolic_name</span><span class="p">[</span><span class="n">FC_VPORT_SYMBOLIC_NAMELEN</span><span class="p">];</span>

	<span class="cm">/* exported data */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dd_data</span><span class="p">;</span>			<span class="cm">/* Used for driver-specific storage */</span>

	<span class="cm">/* internal data */</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>	<span class="cm">/* Physical Port Parent */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">number</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">peers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">vport_delete_work</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))));</span>

<span class="cm">/* bit field values for struct fc_vport &quot;flags&quot; field: */</span>
<span class="cp">#define FC_VPORT_CREATING		0x01</span>
<span class="cp">#define FC_VPORT_DELETING		0x02</span>
<span class="cp">#define FC_VPORT_DELETED		0x04</span>
<span class="cp">#define FC_VPORT_DEL			0x06	</span><span class="cm">/* Any DELETE state */</span><span class="cp"></span>

<span class="cp">#define	dev_to_vport(d)				\</span>
<span class="cp">	container_of(d, struct fc_vport, dev)</span>
<span class="cp">#define transport_class_to_vport(dev)		\</span>
<span class="cp">	dev_to_vport(dev-&gt;parent)</span>
<span class="cp">#define vport_to_shost(v)			\</span>
<span class="cp">	(v-&gt;shost)</span>
<span class="cp">#define vport_to_shost_channel(v)		\</span>
<span class="cp">	(v-&gt;channel)</span>
<span class="cp">#define vport_to_parent(v)			\</span>
<span class="cp">	(v-&gt;dev.parent)</span>


<span class="cm">/* Error return codes for vport_create() callback */</span>
<span class="cp">#define VPCERR_UNSUPPORTED		-ENOSYS		</span><span class="cm">/* no driver/adapter</span>
<span class="cm">							   support */</span><span class="cp"></span>
<span class="cp">#define VPCERR_BAD_WWN			-ENOTUNIQ	</span><span class="cm">/* driver validation</span>
<span class="cm">							   of WWNs failed */</span><span class="cp"></span>
<span class="cp">#define VPCERR_NO_FABRIC_SUPP		-EOPNOTSUPP	</span><span class="cm">/* Fabric connection</span>
<span class="cm">							   is loop or the</span>
<span class="cm">							   Fabric Port does</span>
<span class="cm">							   not support NPIV */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * fc_rport_identifiers: This set of data contains all elements</span>
<span class="cm"> * to uniquely identify a remote FC port. The driver uses this data</span>
<span class="cm"> * to report the existence of a remote FC port in the topology. Internally,</span>
<span class="cm"> * the transport uses this data for attributes and to manage consistent</span>
<span class="cm"> * target id bindings.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_rport_identifiers</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">node_name</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">port_name</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">port_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">roles</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* Macro for use in defining Remote Port attributes */</span>
<span class="cp">#define FC_RPORT_ATTR(_name,_mode,_show,_store)				\</span>
<span class="cp">struct device_attribute dev_attr_rport_##_name = 	\</span>
<span class="cp">	__ATTR(_name,_mode,_show,_store)</span>


<span class="cm">/*</span>
<span class="cm"> * FC Remote Port Attributes</span>
<span class="cm"> *</span>
<span class="cm"> * This structure exists for each remote FC port that a LLDD notifies</span>
<span class="cm"> * the subsystem of.  A remote FC port may or may not be a SCSI Target,</span>
<span class="cm"> * also be a SCSI initiator, IP endpoint, etc. As such, the remote</span>
<span class="cm"> * port is considered a separate entity, independent of &quot;role&quot; (such</span>
<span class="cm"> * as scsi target).</span>
<span class="cm"> *</span>
<span class="cm"> * --</span>
<span class="cm"> *</span>
<span class="cm"> * Attributes are based on HBAAPI V2.0 definitions. Only those</span>
<span class="cm"> * attributes that are determinable by the local port (aka Host)</span>
<span class="cm"> * are contained.</span>
<span class="cm"> *</span>
<span class="cm"> * Fixed attributes are not expected to change. The driver is</span>
<span class="cm"> * expected to set these values after successfully calling</span>
<span class="cm"> * fc_remote_port_add(). The transport fully manages all get functions</span>
<span class="cm"> * w/o driver interaction.</span>
<span class="cm"> *</span>
<span class="cm"> * Dynamic attributes are expected to change. The driver participates</span>
<span class="cm"> * in all get/set operations via functions provided by the driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Private attributes are transport-managed values. They are fully</span>
<span class="cm"> * managed by the transport w/o driver interaction.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">fc_rport</span> <span class="p">{</span>	<span class="cm">/* aka fc_starget_attrs */</span>
	<span class="cm">/* Fixed Attributes */</span>
	<span class="n">u32</span> <span class="n">maxframe_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">supported_classes</span><span class="p">;</span>

	<span class="cm">/* Dynamic Attributes */</span>
	<span class="n">u32</span> <span class="n">dev_loss_tmo</span><span class="p">;</span>	<span class="cm">/* Remote Port loss timeout in seconds. */</span>

	<span class="cm">/* Private (Transport-managed) Attributes */</span>
	<span class="n">u64</span> <span class="n">node_name</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">port_name</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">port_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">roles</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_port_state</span> <span class="n">port_state</span><span class="p">;</span>	<span class="cm">/* Will only be ONLINE or UNKNOWN */</span>
	<span class="n">u32</span> <span class="n">scsi_target_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fast_io_fail_tmo</span><span class="p">;</span>

	<span class="cm">/* exported data */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dd_data</span><span class="p">;</span>			<span class="cm">/* Used for driver-specific storage */</span>

	<span class="cm">/* internal data */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">number</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">peers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>
 	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">dev_loss_work</span><span class="p">;</span>
 	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">scan_work</span><span class="p">;</span>
 	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">fail_io_work</span><span class="p">;</span>
 	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">stgt_delete_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">rport_delete_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">rqst_q</span><span class="p">;</span>	<span class="cm">/* bsg support */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))));</span>

<span class="cm">/* bit field values for struct fc_rport &quot;flags&quot; field: */</span>
<span class="cp">#define FC_RPORT_DEVLOSS_PENDING	0x01</span>
<span class="cp">#define FC_RPORT_SCAN_PENDING		0x02</span>
<span class="cp">#define FC_RPORT_FAST_FAIL_TIMEDOUT	0x04</span>
<span class="cp">#define FC_RPORT_DEVLOSS_CALLBK_DONE	0x08</span>

<span class="cp">#define	dev_to_rport(d)				\</span>
<span class="cp">	container_of(d, struct fc_rport, dev)</span>
<span class="cp">#define transport_class_to_rport(dev)	\</span>
<span class="cp">	dev_to_rport(dev-&gt;parent)</span>
<span class="cp">#define rport_to_shost(r)			\</span>
<span class="cp">	dev_to_shost(r-&gt;dev.parent)</span>

<span class="cm">/*</span>
<span class="cm"> * FC SCSI Target Attributes</span>
<span class="cm"> *</span>
<span class="cm"> * The SCSI Target is considered an extension of a remote port (as</span>
<span class="cm"> * a remote port can be more than a SCSI Target). Within the scsi</span>
<span class="cm"> * subsystem, we leave the Target as a separate entity. Doing so</span>
<span class="cm"> * provides backward compatibility with prior FC transport api&#39;s,</span>
<span class="cm"> * and lets remote ports be handled entirely within the FC transport</span>
<span class="cm"> * and independently from the scsi subsystem. The drawback is that</span>
<span class="cm"> * some data will be duplicated.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">fc_starget_attrs</span> <span class="p">{</span>	<span class="cm">/* aka fc_target_attrs */</span>
	<span class="cm">/* Dynamic Attributes */</span>
	<span class="n">u64</span> <span class="n">node_name</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">port_name</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">port_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define fc_starget_node_name(x) \</span>
<span class="cp">	(((struct fc_starget_attrs *)&amp;(x)-&gt;starget_data)-&gt;node_name)</span>
<span class="cp">#define fc_starget_port_name(x)	\</span>
<span class="cp">	(((struct fc_starget_attrs *)&amp;(x)-&gt;starget_data)-&gt;port_name)</span>
<span class="cp">#define fc_starget_port_id(x) \</span>
<span class="cp">	(((struct fc_starget_attrs *)&amp;(x)-&gt;starget_data)-&gt;port_id)</span>

<span class="cp">#define starget_to_rport(s)			\</span>
<span class="cp">	scsi_is_fc_rport(s-&gt;dev.parent) ? dev_to_rport(s-&gt;dev.parent) : NULL</span>


<span class="cm">/*</span>
<span class="cm"> * FC Local Port (Host) Statistics</span>
<span class="cm"> */</span>

<span class="cm">/* FC Statistics - Following FC HBAAPI v2.0 guidelines */</span>
<span class="k">struct</span> <span class="n">fc_host_statistics</span> <span class="p">{</span>
	<span class="cm">/* port statistics */</span>
	<span class="n">u64</span> <span class="n">seconds_since_last_reset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_frames</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_words</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_frames</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_words</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">lip_count</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">nos_count</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">error_frames</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dumped_frames</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">link_failure_count</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">loss_of_sync_count</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">loss_of_signal_count</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">prim_seq_protocol_err_count</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">invalid_tx_word_count</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">invalid_crc_count</span><span class="p">;</span>

	<span class="cm">/* fc4 statistics  (only FCP supported currently) */</span>
	<span class="n">u64</span> <span class="n">fcp_input_requests</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">fcp_output_requests</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">fcp_control_requests</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">fcp_input_megabytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">fcp_output_megabytes</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * FC Event Codes - Polled and Async, following FC HBAAPI v2.0 guidelines</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * fc_host_event_code: If you alter this, you also need to alter</span>
<span class="cm"> * scsi_transport_fc.c (for the ascii descriptions).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">fc_host_event_code</span>  <span class="p">{</span>
	<span class="n">FCH_EVT_LIP</span>			<span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">FCH_EVT_LINKUP</span>			<span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
	<span class="n">FCH_EVT_LINKDOWN</span>		<span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span>
	<span class="n">FCH_EVT_LIPRESET</span>		<span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>
	<span class="n">FCH_EVT_RSCN</span>			<span class="o">=</span> <span class="mh">0x5</span><span class="p">,</span>
	<span class="n">FCH_EVT_ADAPTER_CHANGE</span>		<span class="o">=</span> <span class="mh">0x103</span><span class="p">,</span>
	<span class="n">FCH_EVT_PORT_UNKNOWN</span>		<span class="o">=</span> <span class="mh">0x200</span><span class="p">,</span>
	<span class="n">FCH_EVT_PORT_OFFLINE</span>		<span class="o">=</span> <span class="mh">0x201</span><span class="p">,</span>
	<span class="n">FCH_EVT_PORT_ONLINE</span>		<span class="o">=</span> <span class="mh">0x202</span><span class="p">,</span>
	<span class="n">FCH_EVT_PORT_FABRIC</span>		<span class="o">=</span> <span class="mh">0x204</span><span class="p">,</span>
	<span class="n">FCH_EVT_LINK_UNKNOWN</span>		<span class="o">=</span> <span class="mh">0x500</span><span class="p">,</span>
	<span class="n">FCH_EVT_VENDOR_UNIQUE</span>		<span class="o">=</span> <span class="mh">0xffff</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * FC Local Port (Host) Attributes</span>
<span class="cm"> *</span>
<span class="cm"> * Attributes are based on HBAAPI V2.0 definitions.</span>
<span class="cm"> * Note: OSDeviceName is determined by user-space library</span>
<span class="cm"> *</span>
<span class="cm"> * Fixed attributes are not expected to change. The driver is</span>
<span class="cm"> * expected to set these values after successfully calling scsi_add_host().</span>
<span class="cm"> * The transport fully manages all get functions w/o driver interaction.</span>
<span class="cm"> *</span>
<span class="cm"> * Dynamic attributes are expected to change. The driver participates</span>
<span class="cm"> * in all get/set operations via functions provided by the driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Private attributes are transport-managed values. They are fully</span>
<span class="cm"> * managed by the transport w/o driver interaction.</span>
<span class="cm"> */</span>

<span class="cp">#define FC_FC4_LIST_SIZE		32</span>
<span class="cp">#define FC_SYMBOLIC_NAME_SIZE		256</span>
<span class="cp">#define FC_VERSION_STRING_SIZE		64</span>
<span class="cp">#define FC_SERIAL_NUMBER_SIZE		80</span>

<span class="k">struct</span> <span class="n">fc_host_attrs</span> <span class="p">{</span>
	<span class="cm">/* Fixed Attributes */</span>
	<span class="n">u64</span> <span class="n">node_name</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">port_name</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">permanent_port_name</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">supported_classes</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">supported_fc4s</span><span class="p">[</span><span class="n">FC_FC4_LIST_SIZE</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">supported_speeds</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">maxframe_size</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">max_npiv_vports</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">serial_number</span><span class="p">[</span><span class="n">FC_SERIAL_NUMBER_SIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">manufacturer</span><span class="p">[</span><span class="n">FC_SERIAL_NUMBER_SIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">model</span><span class="p">[</span><span class="n">FC_SYMBOLIC_NAME_SIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">model_description</span><span class="p">[</span><span class="n">FC_SYMBOLIC_NAME_SIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">hardware_version</span><span class="p">[</span><span class="n">FC_VERSION_STRING_SIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">driver_version</span><span class="p">[</span><span class="n">FC_VERSION_STRING_SIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">firmware_version</span><span class="p">[</span><span class="n">FC_VERSION_STRING_SIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">optionrom_version</span><span class="p">[</span><span class="n">FC_VERSION_STRING_SIZE</span><span class="p">];</span>

	<span class="cm">/* Dynamic Attributes */</span>
	<span class="n">u32</span> <span class="n">port_id</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_port_type</span> <span class="n">port_type</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_port_state</span> <span class="n">port_state</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">active_fc4s</span><span class="p">[</span><span class="n">FC_FC4_LIST_SIZE</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">speed</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">fabric_name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">symbolic_name</span><span class="p">[</span><span class="n">FC_SYMBOLIC_NAME_SIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">system_hostname</span><span class="p">[</span><span class="n">FC_SYMBOLIC_NAME_SIZE</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">dev_loss_tmo</span><span class="p">;</span>

	<span class="cm">/* Private (Transport-managed) Attributes */</span>
	<span class="k">enum</span> <span class="n">fc_tgtid_binding_type</span>  <span class="n">tgtid_bind_type</span><span class="p">;</span>

	<span class="cm">/* internal data */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rports</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rport_bindings</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">vports</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">next_rport_number</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">next_target_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">next_vport_number</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">npiv_vports_inuse</span><span class="p">;</span>

	<span class="cm">/* work queues for rport state manipulation */</span>
	<span class="kt">char</span> <span class="n">work_q_name</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">work_q</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">devloss_work_q_name</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">devloss_work_q</span><span class="p">;</span>

	<span class="cm">/* bsg support */</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">rqst_q</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define shost_to_fc_host(x) \</span>
<span class="cp">	((struct fc_host_attrs *)(x)-&gt;shost_data)</span>

<span class="cp">#define fc_host_node_name(x) \</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;node_name)</span>
<span class="cp">#define fc_host_port_name(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;port_name)</span>
<span class="cp">#define fc_host_permanent_port_name(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;permanent_port_name)</span>
<span class="cp">#define fc_host_supported_classes(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;supported_classes)</span>
<span class="cp">#define fc_host_supported_fc4s(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;supported_fc4s)</span>
<span class="cp">#define fc_host_supported_speeds(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;supported_speeds)</span>
<span class="cp">#define fc_host_maxframe_size(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;maxframe_size)</span>
<span class="cp">#define fc_host_max_npiv_vports(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;max_npiv_vports)</span>
<span class="cp">#define fc_host_serial_number(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;serial_number)</span>
<span class="cp">#define fc_host_manufacturer(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;manufacturer)</span>
<span class="cp">#define fc_host_model(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;model)</span>
<span class="cp">#define fc_host_model_description(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;model_description)</span>
<span class="cp">#define fc_host_hardware_version(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;hardware_version)</span>
<span class="cp">#define fc_host_driver_version(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;driver_version)</span>
<span class="cp">#define fc_host_firmware_version(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;firmware_version)</span>
<span class="cp">#define fc_host_optionrom_version(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;optionrom_version)</span>
<span class="cp">#define fc_host_port_id(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;port_id)</span>
<span class="cp">#define fc_host_port_type(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;port_type)</span>
<span class="cp">#define fc_host_port_state(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;port_state)</span>
<span class="cp">#define fc_host_active_fc4s(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;active_fc4s)</span>
<span class="cp">#define fc_host_speed(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;speed)</span>
<span class="cp">#define fc_host_fabric_name(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;fabric_name)</span>
<span class="cp">#define fc_host_symbolic_name(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;symbolic_name)</span>
<span class="cp">#define fc_host_system_hostname(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;system_hostname)</span>
<span class="cp">#define fc_host_tgtid_bind_type(x) \</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;tgtid_bind_type)</span>
<span class="cp">#define fc_host_rports(x) \</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;rports)</span>
<span class="cp">#define fc_host_rport_bindings(x) \</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;rport_bindings)</span>
<span class="cp">#define fc_host_vports(x) \</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;vports)</span>
<span class="cp">#define fc_host_next_rport_number(x) \</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;next_rport_number)</span>
<span class="cp">#define fc_host_next_target_id(x) \</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;next_target_id)</span>
<span class="cp">#define fc_host_next_vport_number(x) \</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;next_vport_number)</span>
<span class="cp">#define fc_host_npiv_vports_inuse(x)	\</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;npiv_vports_inuse)</span>
<span class="cp">#define fc_host_work_q_name(x) \</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;work_q_name)</span>
<span class="cp">#define fc_host_work_q(x) \</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;work_q)</span>
<span class="cp">#define fc_host_devloss_work_q_name(x) \</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;devloss_work_q_name)</span>
<span class="cp">#define fc_host_devloss_work_q(x) \</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;devloss_work_q)</span>
<span class="cp">#define fc_host_dev_loss_tmo(x) \</span>
<span class="cp">	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;dev_loss_tmo)</span>


<span class="k">struct</span> <span class="n">fc_bsg_buffer</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">payload_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sg_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Values for fc_bsg_job-&gt;state_flags (bitflags) */</span>
<span class="cp">#define FC_RQST_STATE_INPROGRESS	0</span>
<span class="cp">#define FC_RQST_STATE_DONE		1</span>

<span class="k">struct</span> <span class="n">fc_bsg_job</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">job_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ref_cnt</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">job_done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_bsg_job</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">fc_bsg_request</span> <span class="o">*</span><span class="n">request</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_bsg_reply</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">request_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reply_len</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * On entry : reply_len indicates the buffer size allocated for</span>
<span class="cm">	 * the reply.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Upon completion : the message handler must set reply_len</span>
<span class="cm">	 *  to indicates the size of the reply to be returned to the</span>
<span class="cm">	 *  caller.</span>
<span class="cm">	 */</span>

	<span class="cm">/* DMA payloads for the request/response */</span>
	<span class="k">struct</span> <span class="n">fc_bsg_buffer</span> <span class="n">request_payload</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_bsg_buffer</span> <span class="n">reply_payload</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">dd_data</span><span class="p">;</span>			<span class="cm">/* Used for driver-specific storage */</span>
<span class="p">};</span>


<span class="cm">/* The functions by which the transport class and the driver communicate */</span>
<span class="k">struct</span> <span class="n">fc_function_template</span> <span class="p">{</span>
	<span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">get_rport_dev_loss_tmo</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_rport_dev_loss_tmo</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>

	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_starget_node_name</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_starget_port_name</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> 	<span class="p">(</span><span class="o">*</span><span class="n">get_starget_port_id</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">void</span> 	<span class="p">(</span><span class="o">*</span><span class="n">get_host_port_id</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_host_port_type</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_host_port_state</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_host_active_fc4s</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_host_speed</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_host_fabric_name</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_host_symbolic_name</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_host_system_hostname</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">fc_host_statistics</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">get_fc_host_stats</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">reset_fc_host_stats</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">issue_fc_host_lip</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">dev_loss_tmo_callbk</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">terminate_rport_io</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_vport_symbolic_name</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>  	<span class="p">(</span><span class="o">*</span><span class="n">vport_create</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="p">,</span> <span class="n">bool</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">vport_disable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="p">,</span> <span class="n">bool</span><span class="p">);</span>
	<span class="kt">int</span>  	<span class="p">(</span><span class="o">*</span><span class="n">vport_delete</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* target-mode drivers&#39; functions */</span>
	<span class="kt">int</span>     <span class="p">(</span><span class="o">*</span> <span class="n">tsk_mgmt_response</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span>     <span class="p">(</span><span class="o">*</span> <span class="n">it_nexus_response</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

	<span class="cm">/* bsg support */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">bsg_request</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_bsg_job</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">bsg_timeout</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_bsg_job</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* allocation lengths for host-specific data */</span>
	<span class="n">u32</span>	 			<span class="n">dd_fcrport_size</span><span class="p">;</span>
	<span class="n">u32</span>	 			<span class="n">dd_fcvport_size</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">dd_bsg_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The driver sets these to tell the transport class it</span>
<span class="cm">	 * wants the attributes displayed in sysfs.  If the show_ flag</span>
<span class="cm">	 * is not set, the attribute will be private to the transport</span>
<span class="cm">	 * class</span>
<span class="cm">	 */</span>

	<span class="cm">/* remote port fixed attributes */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_rport_maxframe_size</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_rport_supported_classes</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">show_rport_dev_loss_tmo</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * target dynamic attributes</span>
<span class="cm">	 * These should all be &quot;1&quot; if the driver uses the remote port</span>
<span class="cm">	 * add/delete functions (so attributes reflect rport values).</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_starget_node_name</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_starget_port_name</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_starget_port_id</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* host fixed attributes */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_node_name</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_port_name</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_permanent_port_name</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_supported_classes</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_supported_fc4s</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_supported_speeds</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_maxframe_size</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_serial_number</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_manufacturer</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_model</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_model_description</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_hardware_version</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_driver_version</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_firmware_version</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_optionrom_version</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* host dynamic attributes */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_port_id</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_port_type</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_port_state</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_active_fc4s</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_speed</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_fabric_name</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_symbolic_name</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">show_host_system_hostname</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">disable_target_scan</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * fc_remote_port_chkready - called to validate the remote port state</span>
<span class="cm"> *   prior to initiating io to the port.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a scsi result code that can be returned by the LLDD.</span>
<span class="cm"> *</span>
<span class="cm"> * @rport:	remote port to be checked</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">fc_remote_port_chkready</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FC_PORTSTATE_ONLINE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">roles</span> <span class="o">&amp;</span> <span class="n">FC_PORT_ROLE_FCP_TARGET</span><span class="p">)</span>
			<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FC_RPORT_DEVLOSS_PENDING</span><span class="p">)</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">DID_IMM_RETRY</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FC_PORTSTATE_BLOCKED</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FC_RPORT_FAST_FAIL_TIMEDOUT</span><span class="p">)</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">DID_TRANSPORT_FAILFAST</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">DID_IMM_RETRY</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">wwn_to_u64</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">wwn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">wwn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">56</span> <span class="o">|</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">wwn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">48</span> <span class="o">|</span>
	    <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">wwn</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">40</span> <span class="o">|</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">wwn</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span> <span class="o">|</span>
	    <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">wwn</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">wwn</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>
	    <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">wwn</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span>  <span class="mi">8</span> <span class="o">|</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">wwn</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">u64_to_wwn</span><span class="p">(</span><span class="n">u64</span> <span class="n">inm</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">wwn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wwn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">inm</span> <span class="o">&gt;&gt;</span> <span class="mi">56</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">wwn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">inm</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">wwn</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">inm</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">wwn</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">inm</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">wwn</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">inm</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">wwn</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">inm</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">wwn</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">inm</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">wwn</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">inm</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_vport_set_state() - called to set a vport&#39;s state. Saves the old state,</span>
<span class="cm"> *   excepting the transitory states of initializing and sending the ELS</span>
<span class="cm"> *   traffic to instantiate the vport on the link.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumes the driver has surrounded this with the proper locking to ensure</span>
<span class="cm"> * a coherent state change.</span>
<span class="cm"> *</span>
<span class="cm"> * @vport:	virtual port whose state is changing</span>
<span class="cm"> * @new_state:  new state</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">fc_vport_set_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fc_vport_state</span> <span class="n">new_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">new_state</span> <span class="o">!=</span> <span class="n">FC_VPORT_UNKNOWN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">new_state</span> <span class="o">!=</span> <span class="n">FC_VPORT_INITIALIZING</span><span class="p">))</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">vport_last_state</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">vport_state</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">vport_state</span> <span class="o">=</span> <span class="n">new_state</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="o">*</span><span class="n">fc_attach_transport</span><span class="p">(</span>
			<span class="k">struct</span> <span class="n">fc_function_template</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_release_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_remove_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">fc_remote_port_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_rport_identifiers</span>  <span class="o">*</span><span class="n">ids</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_remote_port_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport</span>  <span class="o">*</span><span class="n">rport</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_remote_port_rolechg</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport</span>  <span class="o">*</span><span class="n">rport</span><span class="p">,</span> <span class="n">u32</span> <span class="n">roles</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">scsi_is_fc_rport</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">fc_get_event_number</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_host_post_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event_number</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">fc_host_event_code</span> <span class="n">event_code</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event_data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_host_post_vendor_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event_number</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">data_len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">data_buf</span><span class="p">,</span> <span class="n">u64</span> <span class="n">vendor_id</span><span class="p">);</span>
	<span class="cm">/* Note: when specifying vendor_id to fc_host_post_vendor_event()</span>
<span class="cm">	 *   be sure to read the Vendor Type and ID formatting requirements</span>
<span class="cm">	 *   specified in scsi_netlink.h</span>
<span class="cm">	 */</span>
<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">fc_vport_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">fc_vport_identifiers</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fc_vport_terminate</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fc_block_scsi_eh</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmnd</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* SCSI_TRANSPORT_FC_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
