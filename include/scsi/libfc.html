<!DOCTYPE html>
<html><head><title>joekychen/linux » include › scsi › libfc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>libfc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright(c) 2007 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintained at www.Open-FCoE.org</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LIBFC_H_</span>
<span class="cp">#define _LIBFC_H_</span>

<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/if.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi_transport.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport_fc.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_bsg_fc.h&gt;</span>

<span class="cp">#include &lt;scsi/fc/fc_fcp.h&gt;</span>
<span class="cp">#include &lt;scsi/fc/fc_ns.h&gt;</span>
<span class="cp">#include &lt;scsi/fc/fc_ms.h&gt;</span>
<span class="cp">#include &lt;scsi/fc/fc_els.h&gt;</span>
<span class="cp">#include &lt;scsi/fc/fc_gs.h&gt;</span>

<span class="cp">#include &lt;scsi/fc_frame.h&gt;</span>

<span class="cp">#define	FC_FC4_PROV_SIZE	(FC_TYPE_FCP + 1)	</span><span class="cm">/* size of tables */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * libfc error codes</span>
<span class="cm"> */</span>
<span class="cp">#define	FC_NO_ERR	0	</span><span class="cm">/* no error */</span><span class="cp"></span>
<span class="cp">#define	FC_EX_TIMEOUT	1	</span><span class="cm">/* Exchange timeout */</span><span class="cp"></span>
<span class="cp">#define	FC_EX_CLOSED	2	</span><span class="cm">/* Exchange closed */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * enum fc_lport_state - Local port states</span>
<span class="cm"> * @LPORT_ST_DISABLED: Disabled</span>
<span class="cm"> * @LPORT_ST_FLOGI:    Fabric login (FLOGI) sent</span>
<span class="cm"> * @LPORT_ST_DNS:      Waiting for name server remote port to become ready</span>
<span class="cm"> * @LPORT_ST_RPN_ID:   Register port name by ID (RPN_ID) sent</span>
<span class="cm"> * @LPORT_ST_RFT_ID:   Register Fibre Channel types by ID (RFT_ID) sent</span>
<span class="cm"> * @LPORT_ST_RFF_ID:   Register FC-4 Features by ID (RFF_ID) sent</span>
<span class="cm"> * @LPORT_ST_FDMI:     Waiting for mgmt server rport to become ready</span>
<span class="cm"> * @LPORT_ST_RHBA:</span>
<span class="cm"> * @LPORT_ST_SCR:      State Change Register (SCR) sent</span>
<span class="cm"> * @LPORT_ST_READY:    Ready for use</span>
<span class="cm"> * @LPORT_ST_LOGO:     Local port logout (LOGO) sent</span>
<span class="cm"> * @LPORT_ST_RESET:    Local port reset</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">fc_lport_state</span> <span class="p">{</span>
	<span class="n">LPORT_ST_DISABLED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">LPORT_ST_FLOGI</span><span class="p">,</span>
	<span class="n">LPORT_ST_DNS</span><span class="p">,</span>
	<span class="n">LPORT_ST_RNN_ID</span><span class="p">,</span>
	<span class="n">LPORT_ST_RSNN_NN</span><span class="p">,</span>
	<span class="n">LPORT_ST_RSPN_ID</span><span class="p">,</span>
	<span class="n">LPORT_ST_RFT_ID</span><span class="p">,</span>
	<span class="n">LPORT_ST_RFF_ID</span><span class="p">,</span>
	<span class="n">LPORT_ST_FDMI</span><span class="p">,</span>
	<span class="n">LPORT_ST_RHBA</span><span class="p">,</span>
	<span class="n">LPORT_ST_RPA</span><span class="p">,</span>
	<span class="n">LPORT_ST_DHBA</span><span class="p">,</span>
	<span class="n">LPORT_ST_DPRT</span><span class="p">,</span>
	<span class="n">LPORT_ST_SCR</span><span class="p">,</span>
	<span class="n">LPORT_ST_READY</span><span class="p">,</span>
	<span class="n">LPORT_ST_LOGO</span><span class="p">,</span>
	<span class="n">LPORT_ST_RESET</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">fc_disc_event</span> <span class="p">{</span>
	<span class="n">DISC_EV_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">DISC_EV_SUCCESS</span><span class="p">,</span>
	<span class="n">DISC_EV_FAILED</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum fc_rport_state - Remote port states</span>
<span class="cm"> * @RPORT_ST_INIT:    Initialized</span>
<span class="cm"> * @RPORT_ST_FLOGI:   Waiting for FLOGI completion for point-to-multipoint</span>
<span class="cm"> * @RPORT_ST_PLOGI_WAIT:   Waiting for peer to login for point-to-multipoint</span>
<span class="cm"> * @RPORT_ST_PLOGI:   Waiting for PLOGI completion</span>
<span class="cm"> * @RPORT_ST_PRLI:    Waiting for PRLI completion</span>
<span class="cm"> * @RPORT_ST_RTV:     Waiting for RTV completion</span>
<span class="cm"> * @RPORT_ST_READY:   Ready for use</span>
<span class="cm"> * @RPORT_ST_ADISC:   Discover Address sent</span>
<span class="cm"> * @RPORT_ST_DELETE:  Remote port being deleted</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">fc_rport_state</span> <span class="p">{</span>
	<span class="n">RPORT_ST_INIT</span><span class="p">,</span>
	<span class="n">RPORT_ST_FLOGI</span><span class="p">,</span>
	<span class="n">RPORT_ST_PLOGI_WAIT</span><span class="p">,</span>
	<span class="n">RPORT_ST_PLOGI</span><span class="p">,</span>
	<span class="n">RPORT_ST_PRLI</span><span class="p">,</span>
	<span class="n">RPORT_ST_RTV</span><span class="p">,</span>
	<span class="n">RPORT_ST_READY</span><span class="p">,</span>
	<span class="n">RPORT_ST_ADISC</span><span class="p">,</span>
	<span class="n">RPORT_ST_DELETE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fc_disc_port - temporary discovery port to hold rport identifiers</span>
<span class="cm"> * @lp:         Fibre Channel host port instance</span>
<span class="cm"> * @peers:      Node for list management during discovery and RSCN processing</span>
<span class="cm"> * @rport_work: Work struct for starting the rport state machine</span>
<span class="cm"> * @port_id:    Port ID of the discovered port</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_disc_port</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span>    <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>   <span class="n">peers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">rport_work</span><span class="p">;</span>
	<span class="n">u32</span>                <span class="n">port_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum fc_rport_event - Remote port events</span>
<span class="cm"> * @RPORT_EV_NONE:   No event</span>
<span class="cm"> * @RPORT_EV_READY:  Remote port is ready for use</span>
<span class="cm"> * @RPORT_EV_FAILED: State machine failed, remote port is not ready</span>
<span class="cm"> * @RPORT_EV_STOP:   Remote port has been stopped</span>
<span class="cm"> * @RPORT_EV_LOGO:   Remote port logout (LOGO) sent</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">fc_rport_event</span> <span class="p">{</span>
	<span class="n">RPORT_EV_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RPORT_EV_READY</span><span class="p">,</span>
	<span class="n">RPORT_EV_FAILED</span><span class="p">,</span>
	<span class="n">RPORT_EV_STOP</span><span class="p">,</span>
	<span class="n">RPORT_EV_LOGO</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fc_rport_priv</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct fc_rport_operations - Operations for a remote port</span>
<span class="cm"> * @event_callback: Function to be called for remote port events</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_rport_operations</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">event_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_rport_priv</span> <span class="o">*</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">fc_rport_event</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fc_rport_libfc_priv - libfc internal information about a remote port</span>
<span class="cm"> * @local_port: The associated local port</span>
<span class="cm"> * @rp_state:   Indicates READY for I/O or DELETE when blocked</span>
<span class="cm"> * @flags:      REC and RETRY supported flags</span>
<span class="cm"> * @e_d_tov:    Error detect timeout value (in msec)</span>
<span class="cm"> * @r_a_tov:    Resource allocation timeout value (in msec)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_rport_libfc_priv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span>		   <span class="o">*</span><span class="n">local_port</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_rport_state</span>        <span class="n">rp_state</span><span class="p">;</span>
	<span class="n">u16</span>			   <span class="n">flags</span><span class="p">;</span>
	<span class="cp">#define FC_RP_FLAGS_REC_SUPPORTED	(1 &lt;&lt; 0)</span>
	<span class="cp">#define FC_RP_FLAGS_RETRY		(1 &lt;&lt; 1)</span>
	<span class="cp">#define FC_RP_STARTED			(1 &lt;&lt; 2)</span>
	<span class="cp">#define FC_RP_FLAGS_CONF_REQ		(1 &lt;&lt; 3)</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	           <span class="n">e_d_tov</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	           <span class="n">r_a_tov</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fc_rport_priv - libfc remote port and discovery info</span>
<span class="cm"> * @local_port:     The associated local port</span>
<span class="cm"> * @rport:          The FC transport remote port</span>
<span class="cm"> * @kref:           Reference counter</span>
<span class="cm"> * @rp_state:       Enumeration that tracks progress of PLOGI, PRLI,</span>
<span class="cm"> *                  and RTV exchanges</span>
<span class="cm"> * @ids:            The remote port identifiers and roles</span>
<span class="cm"> * @flags:          STARTED, REC and RETRY_SUPPORTED flags</span>
<span class="cm"> * @max_seq:        Maximum number of concurrent sequences</span>
<span class="cm"> * @disc_id:        The discovery identifier</span>
<span class="cm"> * @maxframe_size:  The maximum frame size</span>
<span class="cm"> * @retries:        The retry count for the current state</span>
<span class="cm"> * @major_retries:  The retry count for the entire PLOGI/PRLI state machine</span>
<span class="cm"> * @e_d_tov:        Error detect timeout value (in msec)</span>
<span class="cm"> * @r_a_tov:        Resource allocation timeout value (in msec)</span>
<span class="cm"> * @rp_mutex:       The mutex that protects the remote port</span>
<span class="cm"> * @retry_work:     Handle for retries</span>
<span class="cm"> * @event_callback: Callback when READY, FAILED or LOGO states complete</span>
<span class="cm"> * @prli_count:     Count of open PRLI sessions in providers</span>
<span class="cm"> * @rcu:	    Structure used for freeing in an RCU-safe manner</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_rport_priv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span>		    <span class="o">*</span><span class="n">local_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span>		    <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span>		    <span class="n">kref</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_rport_state</span>         <span class="n">rp_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport_identifiers</span> <span class="n">ids</span><span class="p">;</span>
	<span class="n">u16</span>			    <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span>		            <span class="n">max_seq</span><span class="p">;</span>
	<span class="n">u16</span>			    <span class="n">disc_id</span><span class="p">;</span>
	<span class="n">u16</span>			    <span class="n">maxframe_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	            <span class="n">retries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	            <span class="n">major_retries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	            <span class="n">e_d_tov</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	            <span class="n">r_a_tov</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>                <span class="n">rp_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	    <span class="n">retry_work</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_rport_event</span>         <span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport_operations</span>  <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>            <span class="n">peers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>          <span class="n">event_work</span><span class="p">;</span>
	<span class="n">u32</span>			    <span class="n">supported_classes</span><span class="p">;</span>
	<span class="n">u16</span>                         <span class="n">prli_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span>		    <span class="n">rcu</span><span class="p">;</span>
	<span class="n">u16</span>			    <span class="n">sp_features</span><span class="p">;</span>
	<span class="n">u8</span>			    <span class="n">spp_type</span><span class="p">;</span>
	<span class="kt">void</span>			    <span class="p">(</span><span class="o">*</span><span class="n">lld_event_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span>
						      <span class="k">struct</span> <span class="n">fc_rport_priv</span> <span class="o">*</span><span class="p">,</span>
						      <span class="k">enum</span> <span class="n">fc_rport_event</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fcoe_dev_stats - fcoe stats structure</span>
<span class="cm"> * @SecondsSinceLastReset: Seconds since the last reset</span>
<span class="cm"> * @TxFrames:              Number of transmitted frames</span>
<span class="cm"> * @TxWords:               Number of transmitted words</span>
<span class="cm"> * @RxFrames:              Number of received frames</span>
<span class="cm"> * @RxWords:               Number of received words</span>
<span class="cm"> * @ErrorFrames:           Number of received error frames</span>
<span class="cm"> * @DumpedFrames:          Number of dumped frames</span>
<span class="cm"> * @LinkFailureCount:      Number of link failures</span>
<span class="cm"> * @LossOfSignalCount:     Number for signal losses</span>
<span class="cm"> * @InvalidTxWordCount:    Number of invalid transmitted words</span>
<span class="cm"> * @InvalidCRCCount:       Number of invalid CRCs</span>
<span class="cm"> * @InputRequests:         Number of input requests</span>
<span class="cm"> * @OutputRequests:        Number of output requests</span>
<span class="cm"> * @ControlRequests:       Number of control requests</span>
<span class="cm"> * @InputBytes:            Number of received bytes</span>
<span class="cm"> * @OutputBytes:           Number of transmitted bytes</span>
<span class="cm"> * @VLinkFailureCount:     Number of virtual link failures</span>
<span class="cm"> * @MissDiscAdvCount:      Number of missing FIP discovery advertisement</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fcoe_dev_stats</span> <span class="p">{</span>
	<span class="n">u64</span>		<span class="n">SecondsSinceLastReset</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">TxFrames</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">TxWords</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">RxFrames</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">RxWords</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">ErrorFrames</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">DumpedFrames</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">LinkFailureCount</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">LossOfSignalCount</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">InvalidTxWordCount</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">InvalidCRCCount</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">InputRequests</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">OutputRequests</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">ControlRequests</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">InputBytes</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">OutputBytes</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">VLinkFailureCount</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">MissDiscAdvCount</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fc_seq_els_data - ELS data used for passing ELS specific responses</span>
<span class="cm"> * @reason: The reason for rejection</span>
<span class="cm"> * @explan: The explanation of the rejection</span>
<span class="cm"> *</span>
<span class="cm"> * Mainly used by the exchange manager layer.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_seq_els_data</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">fc_els_rjt_reason</span> <span class="n">reason</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_els_rjt_explan</span> <span class="n">explan</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fc_fcp_pkt - FCP request structure (one for each scsi_cmnd request)</span>
<span class="cm"> * @lp:              The associated local port</span>
<span class="cm"> * @state:           The state of the I/O</span>
<span class="cm"> * @ref_cnt:         Reference count</span>
<span class="cm"> * @scsi_pkt_lock:   Lock to protect the SCSI packet (must be taken before the</span>
<span class="cm"> *                   host_lock if both are to be held at the same time)</span>
<span class="cm"> * @cmd:             The SCSI command (set and clear with the host_lock held)</span>
<span class="cm"> * @list:            Tracks queued commands (accessed with the host_lock held)</span>
<span class="cm"> * @timer:           The command timer</span>
<span class="cm"> * @tm_done:         Completion indicator</span>
<span class="cm"> * @wait_for_comp:   Indicator to wait for completion of the I/O (in jiffies)</span>
<span class="cm"> * @data_len:        The length of the data</span>
<span class="cm"> * @cdb_cmd:         The CDB command</span>
<span class="cm"> * @xfer_len:        The transfer length</span>
<span class="cm"> * @xfer_ddp:        Indicates if this transfer used DDP (XID of the exchange</span>
<span class="cm"> *                   will be set here if DDP was setup)</span>
<span class="cm"> * @xfer_contig_end: The offset into the buffer if the buffer is contiguous</span>
<span class="cm"> *                   (Tx and Rx)</span>
<span class="cm"> * @max_payload:     The maximum payload size (in bytes)</span>
<span class="cm"> * @io_status:       SCSI result (upper 24 bits)</span>
<span class="cm"> * @cdb_status:      CDB status</span>
<span class="cm"> * @status_code:     FCP I/O status</span>
<span class="cm"> * @scsi_comp_flags: Completion flags (bit 3 Underrun bit 2: overrun)</span>
<span class="cm"> * @req_flags:       Request flags (bit 0: read bit:1 write)</span>
<span class="cm"> * @scsi_resid:      SCSI residule length</span>
<span class="cm"> * @rport:           The remote port that the SCSI command is targeted at</span>
<span class="cm"> * @seq_ptr:         The sequence that will carry the SCSI command</span>
<span class="cm"> * @recov_retry:     Number of recovery retries</span>
<span class="cm"> * @recov_seq:       The sequence for REC or SRR</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>	  <span class="n">scsi_pkt_lock</span><span class="p">;</span>
	<span class="n">atomic_t</span>	  <span class="n">ref_cnt</span><span class="p">;</span>

	<span class="cm">/* SCSI command and data transfer information */</span>
	<span class="n">u32</span>		  <span class="n">data_len</span><span class="p">;</span>

	<span class="cm">/* SCSI I/O related information */</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span>  <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>  <span class="n">list</span><span class="p">;</span>

	<span class="cm">/* Housekeeping information */</span>
	<span class="k">struct</span> <span class="n">fc_lport</span>   <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="n">u8</span>		  <span class="n">state</span><span class="p">;</span>

	<span class="cm">/* SCSI/FCP return status */</span>
	<span class="n">u8</span>		  <span class="n">cdb_status</span><span class="p">;</span>
	<span class="n">u8</span>		  <span class="n">status_code</span><span class="p">;</span>
	<span class="n">u8</span>		  <span class="n">scsi_comp_flags</span><span class="p">;</span>
	<span class="n">u32</span>		  <span class="n">io_status</span><span class="p">;</span>
	<span class="n">u32</span>		  <span class="n">req_flags</span><span class="p">;</span>
	<span class="n">u32</span>		  <span class="n">scsi_resid</span><span class="p">;</span>

	<span class="cm">/* Transport related veriables */</span>
	<span class="kt">size_t</span>		  <span class="n">xfer_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcp_cmnd</span>   <span class="n">cdb_cmd</span><span class="p">;</span>
	<span class="n">u32</span>		  <span class="n">xfer_contig_end</span><span class="p">;</span>
	<span class="n">u16</span>		  <span class="n">max_payload</span><span class="p">;</span>
	<span class="n">u16</span>		  <span class="n">xfer_ddp</span><span class="p">;</span>

	<span class="cm">/* Associated structures */</span>
	<span class="k">struct</span> <span class="n">fc_rport</span>	  <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_seq</span>	  <span class="o">*</span><span class="n">seq_ptr</span><span class="p">;</span>

	<span class="cm">/* Timeout/error related information */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="kt">int</span>	          <span class="n">wait_for_comp</span><span class="p">;</span>
	<span class="n">u32</span>		  <span class="n">recov_retry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_seq</span>	  <span class="o">*</span><span class="n">recov_seq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">tm_done</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Structure and function definitions for managing Fibre Channel Exchanges</span>
<span class="cm"> * and Sequences</span>
<span class="cm"> *</span>
<span class="cm"> * fc_exch holds state for one exchange and links to its active sequence.</span>
<span class="cm"> *</span>
<span class="cm"> * fc_seq holds the state for an individual sequence.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">fc_exch_mgr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">fc_exch_mgr_anchor</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">u16</span> <span class="n">fc_cpu_mask</span><span class="p">;</span>	<span class="cm">/* cpu mask for possible cpus */</span>

<span class="cm">/**</span>
<span class="cm"> * struct fc_seq - FC sequence</span>
<span class="cm"> * @id:       The sequence ID</span>
<span class="cm"> * @ssb_stat: Status flags for the sequence status block (SSB)</span>
<span class="cm"> * @cnt:      Number of frames sent so far</span>
<span class="cm"> * @rec_data: FC-4 value for REC</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_seq</span> <span class="p">{</span>
	<span class="n">u8</span>  <span class="n">id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ssb_stat</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rec_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define FC_EX_DONE		(1 &lt;&lt; 0) </span><span class="cm">/* ep is completed */</span><span class="cp"></span>
<span class="cp">#define FC_EX_RST_CLEANUP	(1 &lt;&lt; 1) </span><span class="cm">/* reset is forcing completion */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * struct fc_exch - Fibre Channel Exchange</span>
<span class="cm"> * @em:           Exchange manager</span>
<span class="cm"> * @pool:         Exchange pool</span>
<span class="cm"> * @state:        The exchange&#39;s state</span>
<span class="cm"> * @xid:          The exchange ID</span>
<span class="cm"> * @ex_list:      Handle used by the EM to track free exchanges</span>
<span class="cm"> * @ex_lock:      Lock that protects the exchange</span>
<span class="cm"> * @ex_refcnt:    Reference count</span>
<span class="cm"> * @timeout_work: Handle for timeout handler</span>
<span class="cm"> * @lp:           The local port that this exchange is on</span>
<span class="cm"> * @oxid:         Originator&#39;s exchange ID</span>
<span class="cm"> * @rxid:         Responder&#39;s exchange ID</span>
<span class="cm"> * @oid:          Originator&#39;s FCID</span>
<span class="cm"> * @sid:          Source FCID</span>
<span class="cm"> * @did:          Destination FCID</span>
<span class="cm"> * @esb_stat:     ESB exchange status</span>
<span class="cm"> * @r_a_tov:      Resouce allocation time out value (in msecs)</span>
<span class="cm"> * @seq_id:       The next sequence ID to use</span>
<span class="cm"> * @encaps:       encapsulation information for lower-level driver</span>
<span class="cm"> * @f_ctl:        F_CTL flags for the sequence</span>
<span class="cm"> * @fh_type:      The frame type</span>
<span class="cm"> * @class:        The class of service</span>
<span class="cm"> * @seq:          The sequence in use on this exchange</span>
<span class="cm"> * @resp:         Callback for responses on this exchange</span>
<span class="cm"> * @destructor:   Called when destroying the exchange</span>
<span class="cm"> * @arg:          Passed as a void pointer to the resp() callback</span>
<span class="cm"> *</span>
<span class="cm"> * Locking notes: The ex_lock protects following items:</span>
<span class="cm"> *	state, esb_stat, f_ctl, seq.ssb_stat</span>
<span class="cm"> *	seq_id</span>
<span class="cm"> *	sequence allocation</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_exch</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>	    <span class="n">ex_lock</span><span class="p">;</span>
	<span class="n">atomic_t</span>	    <span class="n">ex_refcnt</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_class</span>	    <span class="n">class</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch_mgr</span>  <span class="o">*</span><span class="n">em</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_exch_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>    <span class="n">ex_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span>	    <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="n">u32</span>		    <span class="n">esb_stat</span><span class="p">;</span>
	<span class="n">u8</span>		    <span class="n">state</span><span class="p">;</span>
	<span class="n">u8</span>		    <span class="n">fh_type</span><span class="p">;</span>
	<span class="n">u8</span>		    <span class="n">seq_id</span><span class="p">;</span>
	<span class="n">u8</span>		    <span class="n">encaps</span><span class="p">;</span>
	<span class="n">u16</span>		    <span class="n">xid</span><span class="p">;</span>
	<span class="n">u16</span>		    <span class="n">oxid</span><span class="p">;</span>
	<span class="n">u16</span>		    <span class="n">rxid</span><span class="p">;</span>
	<span class="n">u32</span>		    <span class="n">oid</span><span class="p">;</span>
	<span class="n">u32</span>		    <span class="n">sid</span><span class="p">;</span>
	<span class="n">u32</span>		    <span class="n">did</span><span class="p">;</span>
	<span class="n">u32</span>		    <span class="n">r_a_tov</span><span class="p">;</span>
	<span class="n">u32</span>		    <span class="n">f_ctl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_seq</span>       <span class="n">seq</span><span class="p">;</span>
	<span class="kt">void</span>		    <span class="p">(</span><span class="o">*</span><span class="n">resp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		    <span class="o">*</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">void</span>		    <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">timeout_work</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
<span class="cp">#define	fc_seq_exch(sp) container_of(sp, struct fc_exch, seq)</span>


<span class="k">struct</span> <span class="n">libfc_function_template</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Interface to send a FC frame</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: REQUIRED</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">frame_send</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Interface to send ELS/CT frames</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">elsct_send</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="n">did</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">),</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timer_msec</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send the FC frame payload using a new exchange and sequence.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The exchange response handler is set in this routine to resp()</span>
<span class="cm">	 * function pointer. It can be called in two scenarios: if a timeout</span>
<span class="cm">	 * occurs or if a response frame is received for the exchange. The</span>
<span class="cm">	 * fc_frame pointer in response handler will also indicate timeout</span>
<span class="cm">	 * as error using IS_ERR related macros.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The exchange destructor handler is also set in this routine.</span>
<span class="cm">	 * The destructor handler is invoked by EM layer when exchange</span>
<span class="cm">	 * is about to free, this can be used by caller to free its</span>
<span class="cm">	 * resources along with exchange free.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The arg is passed back to resp and destructor handler.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The timeout value (in msec) for an exchange is set if non zero</span>
<span class="cm">	 * timer_msec argument is specified. The timer is canceled when</span>
<span class="cm">	 * it fires or when the exchange is done. The exchange timeout handler</span>
<span class="cm">	 * is registered by EM layer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">exch_seq_send</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span>
					<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span>
						     <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
					<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span>
							   <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
					<span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timer_msec</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sets up the DDP context for a given exchange id on the given</span>
<span class="cm">	 * scatterlist if LLD supports DDP for large receive.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ddp_setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Completes the DDP transfer and returns the length of data DDPed</span>
<span class="cm">	 * for the given exchange id.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ddp_done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Sets up the DDP context for a given exchange id on the given</span>
<span class="cm">	 * scatterlist if LLD supports DDP for FCoE target.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ddp_target</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allow LLD to fill its own Link Error Status Block</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_lesb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_els_lesb</span> <span class="o">*</span><span class="n">lesb</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Send a frame using an existing sequence and exchange.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">seq_send</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send an ELS response using information from the received frame.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">seq_els_rsp_send</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fc_els_cmd</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">fc_seq_els_data</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Abort an exchange and sequence. Generally called because of a</span>
<span class="cm">	 * exchange timeout or an abort from the upper layer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * A timer_msec can be specified for abort timeout, if non-zero</span>
<span class="cm">	 * timer_msec value is specified then exchange resp handler</span>
<span class="cm">	 * will be called with timeout error if no response to abort.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">seq_exch_abort</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timer_msec</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Indicate that an exchange/sequence tuple is complete and the memory</span>
<span class="cm">	 * allocated for the related objects may be freed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exch_done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start a new sequence on the same exchange/sequence tuple.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">seq_start_next</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set a response handler for the exchange of the sequence.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">seq_set_resp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Assign a sequence for an incoming request frame.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">seq_assign</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Release the reference on the sequence returned by seq_assign().</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">seq_release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset an exchange manager, completing all sequences and exchanges.</span>
<span class="cm">	 * If s_id is non-zero, reset only exchanges originating from that FID.</span>
<span class="cm">	 * If d_id is non-zero, reset only exchanges sending to that FID.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exch_mgr_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="n">s_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">d_id</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Flush the rport work queue. Generally used before shutdown.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rport_flush_queue</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Receive a frame for a local port.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lport_recv</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset the local port.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lport_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the local port FC_ID.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This may be provided by the LLD to allow it to be</span>
<span class="cm">	 * notified when the local port is assigned a FC-ID.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The frame, if non-NULL, is the incoming frame with the</span>
<span class="cm">	 * FLOGI LS_ACC or FLOGI, and may contain the granted MAC</span>
<span class="cm">	 * address for the LLD.  The frame pointer may be NULL if</span>
<span class="cm">	 * no MAC is associated with this assignment (LOGO or PLOGI).</span>
<span class="cm">	 *</span>
<span class="cm">	 * If FC_ID is non-zero, r_a_tov and e_d_tov must be valid.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: this is called with the local port mutex held.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lport_set_port_id</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port_id</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create a remote port with a given port ID</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">fc_rport_priv</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">rport_create</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initiates the RP state machine. It is called from the LP module.</span>
<span class="cm">	 * This function will issue the following commands to the N_Port</span>
<span class="cm">	 * identified by the FC ID provided.</span>
<span class="cm">	 *</span>
<span class="cm">	 * - PLOGI</span>
<span class="cm">	 * - PRLI</span>
<span class="cm">	 * - RTV</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rport_login</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_rport_priv</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Logoff, and remove the rport from the transport if</span>
<span class="cm">	 * it had been added. This will send a LOGO to the target.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rport_logoff</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_rport_priv</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Receive a request from a remote port.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rport_recv_req</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * lookup an rport by it&#39;s port ID.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">fc_rport_priv</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">rport_lookup</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Destroy an rport after final kref_put().</span>
<span class="cm">	 * The argument is a pointer to the kref inside the fc_rport_priv.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rport_destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Callback routine after the remote port is logged in</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rport_event_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">fc_rport_priv</span> <span class="o">*</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">fc_rport_event</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send a fcp cmd from fsp pkt.</span>
<span class="cm">	 * Called with the SCSI host lock unlocked and irqs disabled.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The resp handler is called when FCP_RSP received.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fcp_cmd_send</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="o">*</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cleanup the FCP layer, used during link down and reset</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fcp_cleanup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Abort all I/O on a local port</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fcp_abort_io</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Receive a request for the discovery layer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disc_recv_req</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start discovery for a local port.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disc_start</span><span class="p">)(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disc_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span>
						 <span class="k">enum</span> <span class="n">fc_disc_event</span><span class="p">),</span>
			   <span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Stop discovery for a given lport. This will remove</span>
<span class="cm">	 * all discovered rports</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disc_stop</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Stop discovery for a given lport. This will block</span>
<span class="cm">	 * until all discovered rports are deleted from the</span>
<span class="cm">	 * FC transport class</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disc_stop_final</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fc_disc - Discovery context</span>
<span class="cm"> * @retry_count:   Number of retries</span>
<span class="cm"> * @pending:       1 if discovery is pending, 0 if not</span>
<span class="cm"> * @requested:     1 if discovery has been requested, 0 if not</span>
<span class="cm"> * @seq_count:     Number of sequences used for discovery</span>
<span class="cm"> * @buf_len:       Length of the discovery buffer</span>
<span class="cm"> * @disc_id:       Discovery ID</span>
<span class="cm"> * @rports:        List of discovered remote ports</span>
<span class="cm"> * @priv:          Private pointer for use by discovery code</span>
<span class="cm"> * @disc_mutex:    Mutex that protects the discovery context</span>
<span class="cm"> * @partial_buf:   Partial name buffer (if names are returned</span>
<span class="cm"> *                 in multiple frames)</span>
<span class="cm"> * @disc_work:     handle for delayed work context</span>
<span class="cm"> * @disc_callback: Callback routine called when discovery completes</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_disc</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>         <span class="n">retry_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>         <span class="n">pending</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>         <span class="n">requested</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>        <span class="n">seq_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>         <span class="n">buf_len</span><span class="p">;</span>
	<span class="n">u16</span>                   <span class="n">disc_id</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>      <span class="n">rports</span><span class="p">;</span>
	<span class="kt">void</span>		      <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>	      <span class="n">disc_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_gpn_ft_resp</span> <span class="n">partial_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>   <span class="n">disc_work</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disc_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">fc_disc_event</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Local port notifier and events.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">blocking_notifier_head</span> <span class="n">fc_lport_notifier_head</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">fc_lport_event</span> <span class="p">{</span>
	<span class="n">FC_LPORT_EV_ADD</span><span class="p">,</span>
	<span class="n">FC_LPORT_EV_DEL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fc_lport - Local port</span>
<span class="cm"> * @host:                  The SCSI host associated with a local port</span>
<span class="cm"> * @ema_list:              Exchange manager anchor list</span>
<span class="cm"> * @dns_rdata:             The directory server remote port</span>
<span class="cm"> * @ms_rdata:		   The management server remote port</span>
<span class="cm"> * @ptp_rdata:             Point to point remote port</span>
<span class="cm"> * @scsi_priv:             FCP layer internal data</span>
<span class="cm"> * @disc:                  Discovery context</span>
<span class="cm"> * @vports:                Child vports if N_Port</span>
<span class="cm"> * @vport:                 Parent vport if VN_Port</span>
<span class="cm"> * @tt:                    Libfc function template</span>
<span class="cm"> * @link_up:               Link state (1 = link up, 0 = link down)</span>
<span class="cm"> * @qfull:                 Queue state (1 queue is full, 0 queue is not full)</span>
<span class="cm"> * @state:                 Identifies the state</span>
<span class="cm"> * @boot_time:             Timestamp indicating when the local port came online</span>
<span class="cm"> * @host_stats:            SCSI host statistics</span>
<span class="cm"> * @dev_stats:             FCoE device stats (TODO: libfc should not be</span>
<span class="cm"> *                         FCoE aware)</span>
<span class="cm"> * @retry_count:           Number of retries in the current state</span>
<span class="cm"> * @port_id:               FC Port ID</span>
<span class="cm"> * @wwpn:                  World Wide Port Name</span>
<span class="cm"> * @wwnn:                  World Wide Node Name</span>
<span class="cm"> * @service_params:        Common service parameters</span>
<span class="cm"> * @e_d_tov:               Error detection timeout value</span>
<span class="cm"> * @r_a_tov:               Resouce allocation timeout value</span>
<span class="cm"> * @rnid_gen:              RNID information</span>
<span class="cm"> * @sg_supp:               Indicates if scatter gather is supported</span>
<span class="cm"> * @seq_offload:           Indicates if sequence offload is supported</span>
<span class="cm"> * @crc_offload:           Indicates if CRC offload is supported</span>
<span class="cm"> * @lro_enabled:           Indicates if large receive offload is supported</span>
<span class="cm"> * @does_npiv:             Supports multiple vports</span>
<span class="cm"> * @npiv_enabled:          Switch/fabric allows NPIV</span>
<span class="cm"> * @mfs:                   The maximum Fibre Channel payload size</span>
<span class="cm"> * @max_retry_count:       The maximum retry attempts</span>
<span class="cm"> * @max_rport_retry_count: The maximum remote port retry attempts</span>
<span class="cm"> * @rport_priv_size:       Size needed by driver after struct fc_rport_priv</span>
<span class="cm"> * @lro_xid:               The maximum XID for LRO</span>
<span class="cm"> * @lso_max:               The maximum large offload send size</span>
<span class="cm"> * @fcts:                  FC-4 type mask</span>
<span class="cm"> * @lp_mutex:              Mutex to protect the local port</span>
<span class="cm"> * @list:                  Linkage on list of vport peers</span>
<span class="cm"> * @retry_work:            Handle to local port for delayed retry context</span>
<span class="cm"> * @prov:		   Pointers available for use by passive FC-4 providers</span>
<span class="cm"> * @lport_list:            Linkage on module-wide list of local ports</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc_lport</span> <span class="p">{</span>
	<span class="cm">/* Associations */</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>	       <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	       <span class="n">ema_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport_priv</span>	       <span class="o">*</span><span class="n">dns_rdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport_priv</span>	       <span class="o">*</span><span class="n">ms_rdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport_priv</span>	       <span class="o">*</span><span class="n">ptp_rdata</span><span class="p">;</span>
	<span class="kt">void</span>			       <span class="o">*</span><span class="n">scsi_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_disc</span>                 <span class="n">disc</span><span class="p">;</span>

	<span class="cm">/* Virtual port information */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	       <span class="n">vports</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_vport</span>		       <span class="o">*</span><span class="n">vport</span><span class="p">;</span>

	<span class="cm">/* Operational Information */</span>
	<span class="k">struct</span> <span class="n">libfc_function_template</span> <span class="n">tt</span><span class="p">;</span>
	<span class="n">u8</span>			       <span class="n">link_up</span><span class="p">;</span>
	<span class="n">u8</span>			       <span class="n">qfull</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fc_lport_state</span>	       <span class="n">state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		       <span class="n">boot_time</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_host_statistics</span>      <span class="n">host_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcoe_dev_stats</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">dev_stats</span><span class="p">;</span>
	<span class="n">u8</span>			       <span class="n">retry_count</span><span class="p">;</span>

	<span class="cm">/* Fabric information */</span>
	<span class="n">u32</span>                            <span class="n">port_id</span><span class="p">;</span>
	<span class="n">u64</span>			       <span class="n">wwpn</span><span class="p">;</span>
	<span class="n">u64</span>			       <span class="n">wwnn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		       <span class="n">service_params</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		       <span class="n">e_d_tov</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		       <span class="n">r_a_tov</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_els_rnid_gen</span>	       <span class="n">rnid_gen</span><span class="p">;</span>

	<span class="cm">/* Capabilities */</span>
	<span class="n">u32</span>			       <span class="n">sg_supp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span>			       <span class="n">seq_offload</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span>			       <span class="n">crc_offload</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span>			       <span class="n">lro_enabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span>			       <span class="n">does_npiv</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span>			       <span class="n">npiv_enabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span>			       <span class="n">point_to_multipoint</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span>			       <span class="n">fdmi_enabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span>			       <span class="n">mfs</span><span class="p">;</span>
	<span class="n">u8</span>			       <span class="n">max_retry_count</span><span class="p">;</span>
	<span class="n">u8</span>			       <span class="n">max_rport_retry_count</span><span class="p">;</span>
	<span class="n">u16</span>			       <span class="n">rport_priv_size</span><span class="p">;</span>
	<span class="n">u16</span>			       <span class="n">link_speed</span><span class="p">;</span>
	<span class="n">u16</span>			       <span class="n">link_supported_speeds</span><span class="p">;</span>
	<span class="n">u16</span>			       <span class="n">lro_xid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		       <span class="n">lso_max</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_ns_fts</span>	       <span class="n">fcts</span><span class="p">;</span>

	<span class="cm">/* Miscellaneous */</span>
	<span class="k">struct</span> <span class="n">mutex</span>                   <span class="n">lp_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>               <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	       <span class="n">retry_work</span><span class="p">;</span>
	<span class="kt">void</span>			       <span class="o">*</span><span class="n">prov</span><span class="p">[</span><span class="n">FC_FC4_PROV_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span>               <span class="n">lport_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fc4_prov - FC-4 provider registration</span>
<span class="cm"> * @prli:               Handler for incoming PRLI</span>
<span class="cm"> * @prlo:               Handler for session reset</span>
<span class="cm"> * @recv:		Handler for incoming request</span>
<span class="cm"> * @module:		Pointer to module.  May be NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fc4_prov</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">prli</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_rport_priv</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="n">spp_len</span><span class="p">,</span>
		    <span class="k">const</span> <span class="k">struct</span> <span class="n">fc_els_spp</span> <span class="o">*</span><span class="n">spp_in</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">fc_els_spp</span> <span class="o">*</span><span class="n">spp_out</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">prlo</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_rport_priv</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">recv</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Register FC-4 provider with libfc.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fc_fc4_register_provider</span><span class="p">(</span><span class="k">enum</span> <span class="n">fc_fh_type</span> <span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc4_prov</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_fc4_deregister_provider</span><span class="p">(</span><span class="k">enum</span> <span class="n">fc_fh_type</span> <span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc4_prov</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * FC_LPORT HELPER FUNCTIONS</span>
<span class="cm"> *****************************/</span>

<span class="cm">/**</span>
<span class="cm"> * fc_lport_test_ready() - Determine if a local port is in the READY state</span>
<span class="cm"> * @lport: The local port to test</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fc_lport_test_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">LPORT_ST_READY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_set_wwnn() - Set the World Wide Node Name of a local port</span>
<span class="cm"> * @lport: The local port whose WWNN is to be set</span>
<span class="cm"> * @wwnn:  The new WWNN</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fc_set_wwnn</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="n">u64</span> <span class="n">wwnn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">wwnn</span> <span class="o">=</span> <span class="n">wwnn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_set_wwpn() - Set the World Wide Port Name of a local port</span>
<span class="cm"> * @lport: The local port whose WWPN is to be set</span>
<span class="cm"> * @wwnn:  The new WWPN</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fc_set_wwpn</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span> <span class="n">u64</span> <span class="n">wwnn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">wwpn</span> <span class="o">=</span> <span class="n">wwnn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_lport_state_enter() - Change a local port&#39;s state</span>
<span class="cm"> * @lport: The local port whose state is to change</span>
<span class="cm"> * @state: The new state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fc_lport_state_enter</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">fc_lport_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">lport</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span>
		<span class="n">lport</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_lport_init_stats() - Allocate per-CPU statistics for a local port</span>
<span class="cm"> * @lport: The local port whose statistics are to be initialized</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fc_lport_init_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">dev_stats</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcoe_dev_stats</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">dev_stats</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fc_lport_free_stats() - Free memory for a local port&#39;s statistics</span>
<span class="cm"> * @lport: The local port whose statistics are to be freed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fc_lport_free_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">dev_stats</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lport_priv() - Return the private data from a local port</span>
<span class="cm"> * @lport: The local port whose private data is to be retreived</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">lport_priv</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">lport</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * libfc_host_alloc() - Allocate a Scsi_Host with room for a local port and</span>
<span class="cm"> *                      LLD private data</span>
<span class="cm"> * @sht:       The SCSI host template</span>
<span class="cm"> * @priv_size: Size of private data</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: libfc lport</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span>
<span class="nf">libfc_host_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priv_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="n">sht</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lport</span><span class="p">)</span> <span class="o">+</span> <span class="n">priv_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lport</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">shost</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">ema_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">vports</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lport</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * FC_FCP HELPER FUNCTIONS</span>
<span class="cm"> *****************************/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">fc_fcp_is_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">fc_fcp_pkt</span> <span class="o">*</span><span class="n">fsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span> <span class="o">&amp;&amp;</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * LOCAL PORT LAYER</span>
<span class="cm"> *****************************/</span>
<span class="kt">int</span> <span class="n">fc_lport_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fc_lport_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fc_fabric_logoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fc_fabric_login</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__fc_linkup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_linkup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__fc_linkdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_linkdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_vport_setlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_vports_linkchange</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fc_lport_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fc_lport_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fc_set_mfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mfs</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">libfc_vport_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">privsize</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">fc_vport_id_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port_id</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fc_lport_bsg_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_bsg_job</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_lport_set_local_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port_id</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_lport_iterate</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * REMOTE PORT LAYER</span>
<span class="cm"> *****************************/</span>
<span class="kt">int</span> <span class="n">fc_rport_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_rport_terminate_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * DISCOVERY LAYER</span>
<span class="cm"> *****************************/</span>
<span class="kt">int</span> <span class="n">fc_disc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="nf">fc_disc_lport</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_disc</span> <span class="o">*</span><span class="n">disc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">disc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_lport</span><span class="p">,</span> <span class="n">disc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * FCP LAYER</span>
<span class="cm"> *****************************/</span>
<span class="kt">int</span> <span class="n">fc_fcp_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_fcp_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * SCSI INTERACTION LAYER</span>
<span class="cm"> *****************************/</span>
<span class="kt">int</span> <span class="n">fc_queuecommand</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fc_eh_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fc_eh_device_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fc_eh_host_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fc_slave_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fc_change_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qdepth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fc_change_queue_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tag_type</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ELS/CT interface</span>
<span class="cm"> *****************************/</span>
<span class="kt">int</span> <span class="n">fc_elsct_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="n">fc_elsct_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="n">did</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span>
						 <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">),</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timer_msec</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_lport_flogi_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_lport_logo_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_seq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_fill_reply_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span>
		       <span class="k">enum</span> <span class="n">fc_rctl</span><span class="p">,</span> <span class="n">u32</span> <span class="n">parm_offset</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_fill_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">,</span>
		 <span class="k">enum</span> <span class="n">fc_rctl</span><span class="p">,</span> <span class="n">u32</span> <span class="n">f_ctl</span><span class="p">,</span> <span class="n">u16</span> <span class="n">seq_cnt</span><span class="p">,</span> <span class="n">u32</span> <span class="n">parm_offset</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * EXCHANGE MANAGER LAYER</span>
<span class="cm"> *****************************/</span>
<span class="kt">int</span> <span class="n">fc_exch_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">fc_exch_mgr_anchor</span> <span class="o">*</span><span class="n">fc_exch_mgr_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="p">,</span>
					   <span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">void</span> <span class="n">fc_exch_mgr_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_exch_mgr_anchor</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fc_exch_mgr_list_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">dst</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">fc_exch_mgr</span> <span class="o">*</span><span class="n">fc_exch_mgr_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fc_class</span> <span class="n">class</span><span class="p">,</span>
				      <span class="n">u16</span> <span class="n">min_xid</span><span class="p">,</span> <span class="n">u16</span> <span class="n">max_xid</span><span class="p">,</span>
				      <span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">void</span> <span class="n">fc_exch_mgr_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_exch_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_exch_mgr_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="n">s_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">d_id</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Functions for fc_functions_template</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fc_get_host_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_get_host_port_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fc_set_rport_loss_tmo</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">fc_host_statistics</span> <span class="o">*</span><span class="n">fc_get_host_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _LIBFC_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
