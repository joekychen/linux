<!DOCTYPE html>
<html><head><title>joekychen/linux » include › scsi › scsi_host.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>scsi_host.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _SCSI_SCSI_HOST_H</span>
<span class="cp">#define _SCSI_SCSI_HOST_H</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>

<span class="k">struct</span> <span class="n">request_queue</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">block_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">completion</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">scsi_cmnd</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">scsi_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">scsi_target</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Scsi_Host</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">scsi_host_cmd_pool</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">scsi_transport_template</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">blk_queue_tags</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * The various choices mean:</span>
<span class="cm"> * NONE: Self evident.	Host adapter is not capable of scatter-gather.</span>
<span class="cm"> * ALL:	 Means that the host adapter module can do scatter-gather,</span>
<span class="cm"> *	 and that there is no limit to the size of the table to which</span>
<span class="cm"> *	 we scatter/gather data.  The value we set here is the maximum</span>
<span class="cm"> *	 single element sglist.  To use chained sglists, the adapter</span>
<span class="cm"> *	 has to set a value beyond ALL (and correctly use the chain</span>
<span class="cm"> *	 handling API.</span>
<span class="cm"> * Anything else:  Indicates the maximum number of chains that can be</span>
<span class="cm"> *	 used in one scatter-gather request.</span>
<span class="cm"> */</span>
<span class="cp">#define SG_NONE 0</span>
<span class="cp">#define SG_ALL	SCSI_MAX_SG_SEGMENTS</span>

<span class="cp">#define MODE_UNKNOWN 0x00</span>
<span class="cp">#define MODE_INITIATOR 0x01</span>
<span class="cp">#define MODE_TARGET 0x02</span>

<span class="cp">#define DISABLE_CLUSTERING 0</span>
<span class="cp">#define ENABLE_CLUSTERING 1</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SCSI_QDEPTH_DEFAULT</span><span class="p">,</span>	<span class="cm">/* default requested change, e.g. from sysfs */</span>
	<span class="n">SCSI_QDEPTH_QFULL</span><span class="p">,</span>	<span class="cm">/* scsi-ml requested due to queue full */</span>
	<span class="n">SCSI_QDEPTH_RAMP_UP</span><span class="p">,</span>	<span class="cm">/* scsi-ml requested due to threshold event */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Used to initialize old-style drivers.  For new-style drivers</span>
<span class="cm">	 * just perform all work in your module initialization function.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status:  OBSOLETE</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">detect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Used as unload callback for hosts with old-style drivers.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OBSOLETE</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The info function will return whatever useful information the</span>
<span class="cm">	 * developer sees fit.  If not provided, then the name field will</span>
<span class="cm">	 * be used instead.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span> <span class="n">info</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ioctl interface</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>


<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="cm">/* </span>
<span class="cm">	 * Compat handler. Handle 32bit ABI.</span>
<span class="cm">	 * When unknown ioctl is passed return -ENOIOCTLCMD.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">compat_ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * The queuecommand function is used to queue up a scsi</span>
<span class="cm">	 * command block to the LLDD.  When the driver finished</span>
<span class="cm">	 * processing the command the done callback is invoked.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If queuecommand returns 0, then the HBA has accepted the</span>
<span class="cm">	 * command.  The done() function must be called on the command</span>
<span class="cm">	 * when the driver has finished with it. (you may call done on the</span>
<span class="cm">	 * command before queuecommand returns, but in this case you</span>
<span class="cm">	 * *must* return 0 from queuecommand).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Queuecommand may also reject the command, in which case it may</span>
<span class="cm">	 * not touch the command and must not call done() for it.</span>
<span class="cm">	 *</span>
<span class="cm">	 * There are two possible rejection returns:</span>
<span class="cm">	 *</span>
<span class="cm">	 *   SCSI_MLQUEUE_DEVICE_BUSY: Block this device temporarily, but</span>
<span class="cm">	 *   allow commands to other devices serviced by this host.</span>
<span class="cm">	 *</span>
<span class="cm">	 *   SCSI_MLQUEUE_HOST_BUSY: Block all devices served by this</span>
<span class="cm">	 *   host temporarily.</span>
<span class="cm">	 *</span>
<span class="cm">         * For compatibility, any other non-zero return is treated the</span>
<span class="cm">         * same as SCSI_MLQUEUE_HOST_BUSY.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: &quot;temporarily&quot; means either until the next command for#</span>
<span class="cm">	 * this device/host completes, or a period of time determined by</span>
<span class="cm">	 * I/O pressure in the system if there are no other outstanding</span>
<span class="cm">	 * commands.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: REQUIRED</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">queuecommand</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The transfer functions are used to queue a scsi command to</span>
<span class="cm">	 * the LLD. When the driver is finished processing the command</span>
<span class="cm">	 * the done callback is invoked.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is called to inform the LLD to transfer</span>
<span class="cm">	 * scsi_bufflen(cmd) bytes. scsi_sg_count(cmd) speciefies the</span>
<span class="cm">	 * number of scatterlist entried in the command and</span>
<span class="cm">	 * scsi_sglist(cmd) returns the scatterlist.</span>
<span class="cm">	 *</span>
<span class="cm">	 * return values: see queuecommand</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the LLD accepts the cmd, it should set the result to an</span>
<span class="cm">	 * appropriate value when completed before calling the done function.</span>
<span class="cm">	 *</span>
<span class="cm">	 * STATUS: REQUIRED FOR TARGET DRIVERS</span>
<span class="cm">	 */</span>
	<span class="cm">/* TODO: rename */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">transfer_response</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is an error handling strategy routine.  You don&#39;t need to</span>
<span class="cm">	 * define one of these if you don&#39;t want to - there is a default</span>
<span class="cm">	 * routine that is present that should work in most cases.  For those</span>
<span class="cm">	 * driver authors that have the inclination and ability to write their</span>
<span class="cm">	 * own strategy routine, this is where it is specified.  Note - the</span>
<span class="cm">	 * strategy routine is *ALWAYS* run in the context of the kernel eh</span>
<span class="cm">	 * thread.  Thus you are guaranteed to *NOT* be in an interrupt</span>
<span class="cm">	 * handler when you execute this, and you are also guaranteed to</span>
<span class="cm">	 * *NOT* have any other commands being queued while you are in the</span>
<span class="cm">	 * strategy routine. When you return from this function, operations</span>
<span class="cm">	 * return to normal.</span>
<span class="cm">	 *</span>
<span class="cm">	 * See scsi_error.c scsi_unjam_host for additional comments about</span>
<span class="cm">	 * what this function should and should not be attempting to do.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: REQUIRED	(at least one of them)</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">eh_abort_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">eh_device_reset_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">eh_target_reset_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">eh_bus_reset_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">eh_host_reset_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Before the mid layer attempts to scan for a new device where none</span>
<span class="cm">	 * currently exists, it will call this entry in your driver.  Should</span>
<span class="cm">	 * your driver need to allocate any structs or perform any other init</span>
<span class="cm">	 * items in order to send commands to a currently unused target/lun</span>
<span class="cm">	 * combo, then this is where you can perform those allocations.  This</span>
<span class="cm">	 * is specifically so that drivers won&#39;t have to perform any kind of</span>
<span class="cm">	 * &quot;is this a new device&quot; checks in their queuecommand routine,</span>
<span class="cm">	 * thereby making the hot path a bit quicker.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Return values: 0 on success, non-0 on failure</span>
<span class="cm">	 *</span>
<span class="cm">	 * Deallocation:  If we didn&#39;t find any devices at this ID, you will</span>
<span class="cm">	 * get an immediate call to slave_destroy().  If we find something</span>
<span class="cm">	 * here then you will get a call to slave_configure(), then the</span>
<span class="cm">	 * device will be used for however long it is kept around, then when</span>
<span class="cm">	 * the device is removed from the system (or * possibly at reboot</span>
<span class="cm">	 * time), you will then get a call to slave_destroy().  This is</span>
<span class="cm">	 * assuming you implement slave_configure and slave_destroy.</span>
<span class="cm">	 * However, if you allocate memory and hang it off the device struct,</span>
<span class="cm">	 * then you must implement the slave_destroy() routine at a minimum</span>
<span class="cm">	 * in order to avoid leaking memory</span>
<span class="cm">	 * each time a device is tore down.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">slave_alloc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Once the device has responded to an INQUIRY and we know the</span>
<span class="cm">	 * device is online, we call into the low level driver with the</span>
<span class="cm">	 * struct scsi_device *.  If the low level device driver implements</span>
<span class="cm">	 * this function, it *must* perform the task of setting the queue</span>
<span class="cm">	 * depth on the device.  All other tasks are optional and depend</span>
<span class="cm">	 * on what the driver supports and various implementation details.</span>
<span class="cm">	 * </span>
<span class="cm">	 * Things currently recommended to be handled at this time include:</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1.  Setting the device queue depth.  Proper setting of this is</span>
<span class="cm">	 *     described in the comments for scsi_adjust_queue_depth.</span>
<span class="cm">	 * 2.  Determining if the device supports the various synchronous</span>
<span class="cm">	 *     negotiation protocols.  The device struct will already have</span>
<span class="cm">	 *     responded to INQUIRY and the results of the standard items</span>
<span class="cm">	 *     will have been shoved into the various device flag bits, eg.</span>
<span class="cm">	 *     device-&gt;sdtr will be true if the device supports SDTR messages.</span>
<span class="cm">	 * 3.  Allocating command structs that the device will need.</span>
<span class="cm">	 * 4.  Setting the default timeout on this device (if needed).</span>
<span class="cm">	 * 5.  Anything else the low level driver might want to do on a device</span>
<span class="cm">	 *     specific setup basis...</span>
<span class="cm">	 * 6.  Return 0 on success, non-0 on error.  The device will be marked</span>
<span class="cm">	 *     as offline on error so that no access will occur.  If you return</span>
<span class="cm">	 *     non-0, your slave_destroy routine will never get called for this</span>
<span class="cm">	 *     device, so don&#39;t leave any loose memory hanging around, clean</span>
<span class="cm">	 *     up after yourself before returning non-0</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">slave_configure</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Immediately prior to deallocating the device and after all activity</span>
<span class="cm">	 * has ceased the mid layer calls this point so that the low level</span>
<span class="cm">	 * driver may completely detach itself from the scsi device and vice</span>
<span class="cm">	 * versa.  The low level driver is responsible for freeing any memory</span>
<span class="cm">	 * it allocated in the slave_alloc or slave_configure calls. </span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">slave_destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Before the mid layer attempts to scan for a new device attached</span>
<span class="cm">	 * to a target where no target currently exists, it will call this</span>
<span class="cm">	 * entry in your driver.  Should your driver need to allocate any</span>
<span class="cm">	 * structs or perform any other init items in order to send commands</span>
<span class="cm">	 * to a currently unused target, then this is where you can perform</span>
<span class="cm">	 * those allocations.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Return values: 0 on success, non-0 on failure</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">target_alloc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Immediately prior to deallocating the target structure, and</span>
<span class="cm">	 * after all activity to attached scsi devices has ceased, the</span>
<span class="cm">	 * midlayer calls this point so that the driver may deallocate</span>
<span class="cm">	 * and terminate any references to the target.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">target_destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a host has the ability to discover targets on its own instead</span>
<span class="cm">	 * of scanning the entire bus, it can fill in this function and</span>
<span class="cm">	 * call scsi_scan_host().  This function will be called periodically</span>
<span class="cm">	 * until it returns 1 with the scsi_host and the elapsed time of</span>
<span class="cm">	 * the scan in jiffies.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">scan_finished</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the host wants to be called before the scan starts, but</span>
<span class="cm">	 * after the midlayer has set up ready for the scan, it can fill</span>
<span class="cm">	 * in this function.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">scan_start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill in this function to allow the queue depth of this host</span>
<span class="cm">	 * to be changeable (on a per device basis).  Returns either</span>
<span class="cm">	 * the current queue depth setting (may be different from what</span>
<span class="cm">	 * was passed in) or an error.  An error should only be</span>
<span class="cm">	 * returned if the requested depth is legal but the driver was</span>
<span class="cm">	 * unable to set it.  If the requested depth is illegal, the</span>
<span class="cm">	 * driver should set and return the closest legal queue depth.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">change_queue_depth</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill in this function to allow the changing of tag types</span>
<span class="cm">	 * (this also allows the enabling/disabling of tag command</span>
<span class="cm">	 * queueing).  An error should only be returned if something</span>
<span class="cm">	 * went wrong in the driver while trying to set the tag type.</span>
<span class="cm">	 * If the driver doesn&#39;t support the requested tag type, then</span>
<span class="cm">	 * it should set the closest type it does support without</span>
<span class="cm">	 * returning an error.  Returns the actual tag type set.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">change_queue_type</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This function determines the BIOS parameters for a given</span>
<span class="cm">	 * harddisk.  These tend to be numbers that are made up by</span>
<span class="cm">	 * the host adapter.  Parameters:</span>
<span class="cm">	 * size, device, list (heads, sectors, cylinders)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="n">bios_param</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span>
			<span class="n">sector_t</span><span class="p">,</span> <span class="kt">int</span> <span class="p">[]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This function is called when one or more partitions on the</span>
<span class="cm">	 * device reach beyond the end of the device.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">unlock_native_capacity</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Can be used to export driver statistics and other infos to the</span>
<span class="cm">	 * world outside the kernel ie. userspace and it also provides an</span>
<span class="cm">	 * interface to feed the driver with information.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OBSOLETE</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">proc_info</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="p">,</span> <span class="kt">off_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is an optional routine that allows the transport to become</span>
<span class="cm">	 * involved when a scsi io timer fires. The return value tells the</span>
<span class="cm">	 * timer routine how to finish the io timeout handling:</span>
<span class="cm">	 * EH_HANDLED:		I fixed the error, please complete the command</span>
<span class="cm">	 * EH_RESET_TIMER:	I need more time, reset the timer and</span>
<span class="cm">	 *			begin counting again</span>
<span class="cm">	 * EH_NOT_HANDLED	Begin normal error recovery</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OPTIONAL</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">blk_eh_timer_return</span> <span class="p">(</span><span class="o">*</span><span class="n">eh_timed_out</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* This is an optional routine that allows transport to initiate</span>
<span class="cm">	 * LLD adapter or firmware reset using sysfs attribute.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Return values: 0 on success, -ve value on failure.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Status: OPTIONAL</span>
<span class="cm">	 */</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">host_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reset_type</span><span class="p">);</span>
<span class="cp">#define SCSI_ADAPTER_RESET	1</span>
<span class="cp">#define SCSI_FIRMWARE_RESET	2</span>


	<span class="cm">/*</span>
<span class="cm">	 * Name of proc directory</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">proc_name</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Used to store the procfs directory if a driver implements the</span>
<span class="cm">	 * proc_info method.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc_dir</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This determines if we will use a non-interrupt driven</span>
<span class="cm">	 * or an interrupt driven scheme.  It is set to the maximum number</span>
<span class="cm">	 * of simultaneous commands a given host adapter will accept.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">can_queue</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In many instances, especially where disconnect / reconnect are</span>
<span class="cm">	 * supported, our host also has an ID on the SCSI bus.  If this is</span>
<span class="cm">	 * the case, then it must be reserved.  Please set this_id to -1 if</span>
<span class="cm">	 * your setup is in single initiator mode, and the host lacks an</span>
<span class="cm">	 * ID.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">this_id</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This determines the degree to which the host adapter is capable</span>
<span class="cm">	 * of scatter-gather.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">sg_tablesize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">sg_prot_tablesize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set this if the host adapter has limitations beside segment count.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">max_sectors</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * DMA scatter gather segment boundary limit. A segment crossing this</span>
<span class="cm">	 * boundary will be split in two.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dma_boundary</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This specifies &quot;machine infinity&quot; for host templates which don&#39;t</span>
<span class="cm">	 * limit the transfer size.  Note this limit represents an absolute</span>
<span class="cm">	 * maximum, and may be over the transfer limits allowed for</span>
<span class="cm">	 * individual devices (e.g. 256 for SCSI-1).</span>
<span class="cm">	 */</span>
<span class="cp">#define SCSI_DEFAULT_MAX_SECTORS	1024</span>

	<span class="cm">/*</span>
<span class="cm">	 * True if this host adapter can make good use of linked commands.</span>
<span class="cm">	 * This will allow more than one command to be queued to a given</span>
<span class="cm">	 * unit on a given host.  Set this to the maximum number of command</span>
<span class="cm">	 * blocks to be provided for each device.  Set this to 1 for one</span>
<span class="cm">	 * command block per lun, 2 for two, etc.  Do not set this to 0.</span>
<span class="cm">	 * You should make sure that the host adapter will do the right thing</span>
<span class="cm">	 * before you try setting this above 1.</span>
<span class="cm">	 */</span>
	<span class="kt">short</span> <span class="n">cmd_per_lun</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * present contains counter indicating how many boards of this</span>
<span class="cm">	 * type were found when we did the scan.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">present</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This specifies the mode that a LLD supports.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="n">supported_mode</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * True if this host adapter uses unchecked DMA onto an ISA bus.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="n">unchecked_isa_dma</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * True if this host adapter can make good use of clustering.</span>
<span class="cm">	 * I originally thought that if the tablesize was large that it</span>
<span class="cm">	 * was a waste of CPU cycles to prepare a cluster list, but</span>
<span class="cm">	 * it works out that the Buslogic is faster if you use a smaller</span>
<span class="cm">	 * number of segments (i.e. use clustering).  I guess it is</span>
<span class="cm">	 * inefficient.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="n">use_clustering</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * True for emulated SCSI host adapters (e.g. ATAPI).</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="n">emulated</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * True if the low-level driver performs its own reset-settle delays.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="n">skip_settle_delay</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * True if we are using ordered write support.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="n">ordered_tag</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Countdown for host blocking with no commands outstanding.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_host_blocked</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Default value for the blocking.  If the queue is empty,</span>
<span class="cm">	 * host_blocked counts down in the request_fn until it restarts</span>
<span class="cm">	 * host operations as zero is reached.  </span>
<span class="cm">	 *</span>
<span class="cm">	 * FIXME: This should probably be a value in the template</span>
<span class="cm">	 */</span>
<span class="cp">#define SCSI_DEFAULT_HOST_BLOCKED	7</span>

	<span class="cm">/*</span>
<span class="cm">	 * Pointer to the sysfs class properties for this host, NULL terminated.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">**</span><span class="n">shost_attrs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Pointer to the SCSI device properties for this host, NULL terminated.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">**</span><span class="n">sdev_attrs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * List of hosts per template.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is only for use by scsi_module.c for legacy templates.</span>
<span class="cm">	 * For these access to it is synchronized implicitly by</span>
<span class="cm">	 * module_init/module_exit.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">legacy_hosts</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Vendor Identifier associated with the host</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: When specifying vendor_id, be sure to read the</span>
<span class="cm">	 *   Vendor Type and ID formatting requirements specified in</span>
<span class="cm">	 *   scsi_netlink.h</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="n">vendor_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Temporary #define for host lock push down. Can be removed when all</span>
<span class="cm"> * drivers have been updated to take advantage of unlocked</span>
<span class="cm"> * queuecommand.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define DEF_SCSI_QCMD(func_name) \</span>
<span class="cp">	int func_name(struct Scsi_Host *shost, struct scsi_cmnd *cmd)	\</span>
<span class="cp">	{								\</span>
<span class="cp">		unsigned long irq_flags;				\</span>
<span class="cp">		int rc;							\</span>
<span class="cp">		spin_lock_irqsave(shost-&gt;host_lock, irq_flags);		\</span>
<span class="cp">		scsi_cmd_get_serial(shost, cmd);			\</span>
<span class="cp">		rc = func_name##_lck (cmd, cmd-&gt;scsi_done);			\</span>
<span class="cp">		spin_unlock_irqrestore(shost-&gt;host_lock, irq_flags);	\</span>
<span class="cp">		return rc;						\</span>
<span class="cp">	}</span>


<span class="cm">/*</span>
<span class="cm"> * shost state: If you alter this, you also need to alter scsi_sysfs.c</span>
<span class="cm"> * (for the ascii descriptions) and the state model enforcer:</span>
<span class="cm"> * scsi_host_set_state()</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">scsi_host_state</span> <span class="p">{</span>
	<span class="n">SHOST_CREATED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">SHOST_RUNNING</span><span class="p">,</span>
	<span class="n">SHOST_CANCEL</span><span class="p">,</span>
	<span class="n">SHOST_DEL</span><span class="p">,</span>
	<span class="n">SHOST_RECOVERY</span><span class="p">,</span>
	<span class="n">SHOST_CANCEL_RECOVERY</span><span class="p">,</span>
	<span class="n">SHOST_DEL_RECOVERY</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * __devices is protected by the host_lock, but you should</span>
<span class="cm">	 * usually use scsi_device_lookup / shost_for_each_device</span>
<span class="cm">	 * to access it and don&#39;t care about locking yourself.</span>
<span class="cm">	 * In the rare case of beeing in irq context you can use</span>
<span class="cm">	 * their __ prefixed variants with the lock held. NEVER</span>
<span class="cm">	 * access this list directly from a driver.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">__devices</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">__targets</span><span class="p">;</span>
	
	<span class="k">struct</span> <span class="n">scsi_host_cmd_pool</span> <span class="o">*</span><span class="n">cmd_pool</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">free_list_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">free_list</span><span class="p">;</span> <span class="cm">/* backup store of cmd structs */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">starved_list</span><span class="p">;</span>

	<span class="n">spinlock_t</span>		<span class="n">default_lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="o">*</span><span class="n">host_lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">scan_mutex</span><span class="p">;</span><span class="cm">/* serialize scanning activity */</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">eh_cmd_q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>    <span class="o">*</span> <span class="n">ehandler</span><span class="p">;</span>  <span class="cm">/* Error recovery thread. */</span>
	<span class="k">struct</span> <span class="n">completion</span>     <span class="o">*</span> <span class="n">eh_action</span><span class="p">;</span> <span class="cm">/* Wait for specific actions on the</span>
<span class="cm">					      host. */</span>
	<span class="n">wait_queue_head_t</span>       <span class="n">host_wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">hostt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="o">*</span><span class="n">transportt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Area to keep a shared tag map (if needed, will be</span>
<span class="cm">	 * NULL if not).</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">blk_queue_tag</span>	<span class="o">*</span><span class="n">bqt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following two fields are protected with host_lock;</span>
<span class="cm">	 * however, eh routines can safely access during eh processing</span>
<span class="cm">	 * without acquiring the lock.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">host_busy</span><span class="p">;</span>		   <span class="cm">/* commands actually active on low-level */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">host_failed</span><span class="p">;</span>	   <span class="cm">/* commands that failed. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">host_eh_scheduled</span><span class="p">;</span>    <span class="cm">/* EH scheduled without command */</span>
    
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">host_no</span><span class="p">;</span>  <span class="cm">/* Used for IOCTL_GET_IDLUN, /proc/scsi et al. */</span>
	<span class="kt">int</span> <span class="n">resetting</span><span class="p">;</span> <span class="cm">/* if set, it means that last_reset is a valid value */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_reset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * These three parameters can be used to allow for wide scsi,</span>
<span class="cm">	 * and for host adapters that support multiple busses</span>
<span class="cm">	 * The first two should be set to 1 more than the actual max id</span>
<span class="cm">	 * or lun (i.e. 8 for normal systems).</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_lun</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_channel</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a unique identifier that must be assigned so that we</span>
<span class="cm">	 * have some way of identifying each detected host adapter properly</span>
<span class="cm">	 * and uniquely.  For hosts that do not support more than one card</span>
<span class="cm">	 * in the system at one time, this does not need to be set.  It is</span>
<span class="cm">	 * initialized to 0 in scsi_register.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unique_id</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The maximum length of SCSI commands that this host can accept.</span>
<span class="cm">	 * Probably 12 for most host adapters, but could be 16 for others.</span>
<span class="cm">	 * or 260 if the driver supports variable length cdbs.</span>
<span class="cm">	 * For drivers that don&#39;t set this field, a value of 12 is</span>
<span class="cm">	 * assumed.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">max_cmd_len</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">this_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">can_queue</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">cmd_per_lun</span><span class="p">;</span>
	<span class="kt">short</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_tablesize</span><span class="p">;</span>
	<span class="kt">short</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_prot_tablesize</span><span class="p">;</span>
	<span class="kt">short</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_sectors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dma_boundary</span><span class="p">;</span>
	<span class="cm">/* </span>
<span class="cm">	 * Used to assign serial numbers to the cmds.</span>
<span class="cm">	 * Protected by the host lock.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cmd_serial_number</span><span class="p">;</span>
	
	<span class="kt">unsigned</span> <span class="n">active_mode</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">unchecked_isa_dma</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">use_clustering</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">use_blk_tcq</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Host has requested that no further requests come through for the</span>
<span class="cm">	 * time being.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="n">host_self_blocked</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    
	<span class="cm">/*</span>
<span class="cm">	 * Host uses correct SCSI ordering not PC ordering. The bit is</span>
<span class="cm">	 * set for the minority of drivers whose authors actually read</span>
<span class="cm">	 * the spec ;).</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="n">reverse_ordering</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ordered write support</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="n">ordered_tag</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Task mgmt function in progress */</span>
	<span class="kt">unsigned</span> <span class="n">tmf_in_progress</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Asynchronous scan in progress */</span>
	<span class="kt">unsigned</span> <span class="n">async_scan</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t resume host in EH */</span>
	<span class="kt">unsigned</span> <span class="n">eh_noresume</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Optional work queue to be utilized by the transport</span>
<span class="cm">	 */</span>
	<span class="kt">char</span> <span class="n">work_q_name</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">work_q</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Host has rejected a command because it was busy.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">host_blocked</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Value host_blocked counts down from</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_host_blocked</span><span class="p">;</span>

	<span class="cm">/* Protection Information */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prot_capabilities</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">prot_guard_type</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * q used for scsi_tgt msgs, async events or any other requests that</span>
<span class="cm">	 * need to be processed in userspace</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">uspace_req_q</span><span class="p">;</span>

	<span class="cm">/* legacy crap */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">n_io_port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dma_channel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">irq</span><span class="p">;</span>
	

	<span class="k">enum</span> <span class="n">scsi_host_state</span> <span class="n">shost_state</span><span class="p">;</span>

	<span class="cm">/* ldm bits */</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="n">shost_gendev</span><span class="p">,</span> <span class="n">shost_dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * List of hosts per template.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is only for use by scsi_module.c for legacy templates.</span>
<span class="cm">	 * For these access to it is synchronized implicitly by</span>
<span class="cm">	 * module_init/module_exit.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">sht_legacy_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Points to the transport data (if any) which is allocated</span>
<span class="cm">	 * separately</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">shost_data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Points to the physical bus device we&#39;d use to do DMA</span>
<span class="cm">	 * Needed just in case we have virtual hosts.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dma_dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We should ensure that this is aligned, both for better performance</span>
<span class="cm">	 * and also because some compilers (m68k) don&#39;t automatically force</span>
<span class="cm">	 * alignment to a long boundary.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hostdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="cm">/* Used for storage of host specific stuff */</span>
		<span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))));</span>
<span class="p">};</span>

<span class="cp">#define		class_to_shost(d)	\</span>
<span class="cp">	container_of(d, struct Scsi_Host, shost_dev)</span>

<span class="cp">#define shost_printk(prefix, shost, fmt, a...)	\</span>
<span class="cp">	dev_printk(prefix, &amp;(shost)-&gt;shost_gendev, fmt, ##a)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">shost_priv</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">scsi_is_host_device</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="nf">dev_to_shost</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_is_host_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Scsi_Host</span><span class="p">,</span> <span class="n">shost_gendev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_host_in_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_state</span> <span class="o">==</span> <span class="n">SHOST_RECOVERY</span> <span class="o">||</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_state</span> <span class="o">==</span> <span class="n">SHOST_CANCEL_RECOVERY</span> <span class="o">||</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_state</span> <span class="o">==</span> <span class="n">SHOST_DEL_RECOVERY</span> <span class="o">||</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">tmf_in_progress</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_flush_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">scsi_host_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">scsi_add_host_with_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_scan_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_rescan_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_remove_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">scsi_host_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_host_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">scsi_host_lookup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scsi_host_state_name</span><span class="p">(</span><span class="k">enum</span> <span class="n">scsi_host_state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_cmd_get_serial</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">u64</span> <span class="n">scsi_calculate_bounce_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">scsi_add_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">scsi_add_host_with_dma</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">scsi_get_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_gendev</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_host_scan_allowed - Is scanning of this host allowed</span>
<span class="cm"> * @shost:	Pointer to Scsi_Host.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_host_scan_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_state</span> <span class="o">==</span> <span class="n">SHOST_RUNNING</span> <span class="o">||</span>
	       <span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_state</span> <span class="o">==</span> <span class="n">SHOST_RECOVERY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_unblock_requests</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_block_requests</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">class_container</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">__scsi_alloc_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span>
						<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">));</span>
<span class="cm">/*</span>
<span class="cm"> * These two functions are used to allocate and free a pseudo device</span>
<span class="cm"> * which will connect to the host adapter itself rather than any</span>
<span class="cm"> * physical device.  You must deallocate when you are done with the</span>
<span class="cm"> * thing.  This physical pseudo-device isn&#39;t real and won&#39;t be available</span>
<span class="cm"> * from any high-level drivers.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_free_host_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsi_get_host_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * DIF defines the exchange of protection information between</span>
<span class="cm"> * initiator and SBC block device.</span>
<span class="cm"> *</span>
<span class="cm"> * DIX defines the exchange of protection information between OS and</span>
<span class="cm"> * initiator.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">scsi_host_prot_capabilities</span> <span class="p">{</span>
	<span class="n">SHOST_DIF_TYPE1_PROTECTION</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* T10 DIF Type 1 */</span>
	<span class="n">SHOST_DIF_TYPE2_PROTECTION</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/* T10 DIF Type 2 */</span>
	<span class="n">SHOST_DIF_TYPE3_PROTECTION</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="cm">/* T10 DIF Type 3 */</span>

	<span class="n">SHOST_DIX_TYPE0_PROTECTION</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span> <span class="cm">/* DIX between OS and HBA only */</span>
	<span class="n">SHOST_DIX_TYPE1_PROTECTION</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span> <span class="cm">/* DIX with DIF Type 1 */</span>
	<span class="n">SHOST_DIX_TYPE2_PROTECTION</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">,</span> <span class="cm">/* DIX with DIF Type 2 */</span>
	<span class="n">SHOST_DIX_TYPE3_PROTECTION</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">,</span> <span class="cm">/* DIX with DIF Type 3 */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * SCSI hosts which support the Data Integrity Extensions must</span>
<span class="cm"> * indicate their capabilities by setting the prot_capabilities using</span>
<span class="cm"> * this call.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">scsi_host_set_prot</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">prot_capabilities</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">scsi_host_get_prot</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">prot_capabilities</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_host_prot_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">prot_capabilities</span> <span class="o">&gt;=</span> <span class="n">SHOST_DIX_TYPE0_PROTECTION</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">scsi_host_dif_capable</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">target_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cap</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span>
				       <span class="n">SHOST_DIF_TYPE1_PROTECTION</span><span class="p">,</span>
				       <span class="n">SHOST_DIF_TYPE2_PROTECTION</span><span class="p">,</span>
				       <span class="n">SHOST_DIF_TYPE3_PROTECTION</span> <span class="p">};</span>

	<span class="k">return</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">prot_capabilities</span> <span class="o">&amp;</span> <span class="n">cap</span><span class="p">[</span><span class="n">target_type</span><span class="p">]</span> <span class="o">?</span> <span class="n">target_type</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">scsi_host_dix_capable</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">target_type</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_BLK_DEV_INTEGRITY)</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cap</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">SHOST_DIX_TYPE0_PROTECTION</span><span class="p">,</span>
				       <span class="n">SHOST_DIX_TYPE1_PROTECTION</span><span class="p">,</span>
				       <span class="n">SHOST_DIX_TYPE2_PROTECTION</span><span class="p">,</span>
				       <span class="n">SHOST_DIX_TYPE3_PROTECTION</span> <span class="p">};</span>

	<span class="k">return</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">prot_capabilities</span> <span class="o">&amp;</span> <span class="n">cap</span><span class="p">[</span><span class="n">target_type</span><span class="p">];</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * All DIX-capable initiators must support the T10-mandated CRC</span>
<span class="cm"> * checksum.  Controllers can optionally implement the IP checksum</span>
<span class="cm"> * scheme which has much lower impact on system performance.  Note</span>
<span class="cm"> * that the main rationale for the checksum is to match integrity</span>
<span class="cm"> * metadata with data.  Detecting bit errors are a job for ECC memory</span>
<span class="cm"> * and buses.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">scsi_host_guard_type</span> <span class="p">{</span>
	<span class="n">SHOST_DIX_GUARD_CRC</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SHOST_DIX_GUARD_IP</span>  <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">scsi_host_set_guard</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">prot_guard_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">scsi_host_get_guard</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">prot_guard_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* legacy interfaces */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">scsi_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_host_set_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">scsi_host_state</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _SCSI_SCSI_HOST_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
