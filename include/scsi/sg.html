<!DOCTYPE html>
<html><head><title>joekychen/linux » include › scsi › sg.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sg.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _SCSI_GENERIC_H</span>
<span class="cp">#define _SCSI_GENERIC_H</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>

<span class="cm">/*</span>
<span class="cm">   History:</span>
<span class="cm">    Started: Aug 9 by Lawrence Foard (entropy@world.std.com), to allow user</span>
<span class="cm">     process control of SCSI devices.</span>
<span class="cm">    Development Sponsored by Killy Corp. NY NY</span>
<span class="cm">Original driver (sg.h):</span>
<span class="cm">*       Copyright (C) 1992 Lawrence Foard</span>
<span class="cm">Version 2 and 3 extensions to driver:</span>
<span class="cm">*       Copyright (C) 1998 - 2006 Douglas Gilbert</span>

<span class="cm">    Version: 3.5.34 (20060920)</span>
<span class="cm">    This version is for 2.6 series kernels.</span>

<span class="cm">    For a full changelog see http://www.torque.net/sg</span>

<span class="cm">Map of SG verions to the Linux kernels in which they appear:</span>
<span class="cm">       ----------        ----------------------------------</span>
<span class="cm">       original          all kernels &lt; 2.2.6</span>
<span class="cm">       2.1.40            2.2.20</span>
<span class="cm">       3.0.x             optional version 3 sg driver for 2.2 series</span>
<span class="cm">       3.1.17++          2.4.0++</span>
<span class="cm">       3.5.30++          2.6.0++</span>

<span class="cm">Major new features in SG 3.x driver (cf SG 2.x drivers)</span>
<span class="cm">	- SG_IO ioctl() combines function if write() and read()</span>
<span class="cm">	- new interface (sg_io_hdr_t) but still supports old interface</span>
<span class="cm">	- scatter/gather in user space, direct IO, and mmap supported</span>

<span class="cm"> The normal action of this driver is to use the adapter (HBA) driver to DMA</span>
<span class="cm"> data into kernel buffers and then use the CPU to copy the data into the </span>
<span class="cm"> user space (vice versa for writes). That is called &quot;indirect&quot; IO due to </span>
<span class="cm"> the double handling of data. There are two methods offered to remove the</span>
<span class="cm"> redundant copy: 1) direct IO and 2) using the mmap() system call to map</span>
<span class="cm"> the reserve buffer (this driver has one reserve buffer per fd) into the</span>
<span class="cm"> user space. Both have their advantages.</span>
<span class="cm"> In terms of absolute speed mmap() is faster. If speed is not a concern, </span>
<span class="cm"> indirect IO should be fine. Read the documentation for more information.</span>

<span class="cm"> ** N.B. To use direct IO &#39;echo 1 &gt; /proc/scsi/sg/allow_dio&#39; or</span>
<span class="cm">         &#39;echo 1 &gt; /sys/module/sg/parameters/allow_dio&#39; is needed.</span>
<span class="cm">         That attribute is 0 by default. **</span>
<span class="cm"> </span>
<span class="cm"> Historical note: this SCSI pass-through driver has been known as &quot;sg&quot; for </span>
<span class="cm"> a decade. In broader kernel discussions &quot;sg&quot; is used to refer to scatter</span>
<span class="cm"> gather techniques. The context should clarify which &quot;sg&quot; is referred to.</span>

<span class="cm"> Documentation</span>
<span class="cm"> =============</span>
<span class="cm"> A web site for the SG device driver can be found at:</span>
<span class="cm">	http://www.torque.net/sg  [alternatively check the MAINTAINERS file]</span>
<span class="cm"> The documentation for the sg version 3 driver can be found at:</span>
<span class="cm"> 	http://www.torque.net/sg/p/sg_v3_ho.html</span>
<span class="cm"> This is a rendering from DocBook source [change the extension to &quot;sgml&quot;</span>
<span class="cm"> or &quot;xml&quot;]. There are renderings in &quot;ps&quot;, &quot;pdf&quot;, &quot;rtf&quot; and &quot;txt&quot; (soon).</span>
<span class="cm"> The SG_IO ioctl is now found in other parts kernel (e.g. the block layer).</span>
<span class="cm"> For more information see http://www.torque.net/sg/sg_io.html</span>

<span class="cm"> The older, version 2 documents discuss the original sg interface in detail:</span>
<span class="cm">	http://www.torque.net/sg/p/scsi-generic.txt</span>
<span class="cm">	http://www.torque.net/sg/p/scsi-generic_long.txt</span>
<span class="cm"> Also available: &lt;kernel_source&gt;/Documentation/scsi/scsi-generic.txt</span>

<span class="cm"> Utility and test programs are available at the sg web site. They are </span>
<span class="cm"> packaged as sg3_utils (for the lk 2.4 and 2.6 series) and sg_utils</span>
<span class="cm"> (for the lk 2.2 series).</span>
<span class="cm">*/</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sg_big_buff</span><span class="p">;</span> <span class="cm">/* for sysctl */</span>
<span class="cp">#endif</span>

<span class="cm">/* New interface introduced in the 3.x SG drivers follows */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sg_iovec</span> <span class="cm">/* same structure as used by readv() Linux system */</span>
<span class="p">{</span>                       <span class="cm">/* call. It defines one scatter-gather element. */</span>
    <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">iov_base</span><span class="p">;</span>      <span class="cm">/* Starting address  */</span>
    <span class="kt">size_t</span> <span class="n">iov_len</span><span class="p">;</span>             <span class="cm">/* Length in bytes  */</span>
<span class="p">}</span> <span class="n">sg_iovec_t</span><span class="p">;</span>


<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sg_io_hdr</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">interface_id</span><span class="p">;</span>           <span class="cm">/* [i] &#39;S&#39; for SCSI generic (required) */</span>
    <span class="kt">int</span> <span class="n">dxfer_direction</span><span class="p">;</span>        <span class="cm">/* [i] data transfer direction  */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd_len</span><span class="p">;</span>      <span class="cm">/* [i] SCSI command length ( &lt;= 16 bytes) */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mx_sb_len</span><span class="p">;</span>    <span class="cm">/* [i] max length to write to sbp */</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">iovec_count</span><span class="p">;</span> <span class="cm">/* [i] 0 implies no scatter gather */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dxfer_len</span><span class="p">;</span>     <span class="cm">/* [i] byte count of data transfer */</span>
    <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">dxferp</span><span class="p">;</span>	<span class="cm">/* [i], [*io] points to data transfer memory</span>
<span class="cm">					      or scatter gather list */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">cmdp</span><span class="p">;</span> <span class="cm">/* [i], [*i] points to command to perform */</span>
    <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">sbp</span><span class="p">;</span>		<span class="cm">/* [i], [*o] points to sense_buffer memory */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>       <span class="cm">/* [i] MAX_UINT-&gt;no timeout (unit: millisec) */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>         <span class="cm">/* [i] 0 -&gt; default, see SG_FLAG... */</span>
    <span class="kt">int</span> <span class="n">pack_id</span><span class="p">;</span>                <span class="cm">/* [i-&gt;o] unused internally (normally) */</span>
    <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">usr_ptr</span><span class="p">;</span>      <span class="cm">/* [i-&gt;o] unused internally */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">;</span>       <span class="cm">/* [o] scsi status */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">masked_status</span><span class="p">;</span><span class="cm">/* [o] shifted, masked scsi status */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msg_status</span><span class="p">;</span>   <span class="cm">/* [o] messaging level data (optional) */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sb_len_wr</span><span class="p">;</span>    <span class="cm">/* [o] byte count actually written to sbp */</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">host_status</span><span class="p">;</span> <span class="cm">/* [o] errors from host adapter */</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">driver_status</span><span class="p">;</span><span class="cm">/* [o] errors from software driver */</span>
    <span class="kt">int</span> <span class="n">resid</span><span class="p">;</span>                  <span class="cm">/* [o] dxfer_len - actual_transferred */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">duration</span><span class="p">;</span>      <span class="cm">/* [o] time taken by cmd (unit: millisec) */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">info</span><span class="p">;</span>          <span class="cm">/* [o] auxiliary information */</span>
<span class="p">}</span> <span class="n">sg_io_hdr_t</span><span class="p">;</span>  <span class="cm">/* 64 bytes long (on i386) */</span>

<span class="cp">#define SG_INTERFACE_ID_ORIG &#39;S&#39;</span>

<span class="cm">/* Use negative values to flag difference from original sg_header structure */</span>
<span class="cp">#define SG_DXFER_NONE (-1)      </span><span class="cm">/* e.g. a SCSI Test Unit Ready command */</span><span class="cp"></span>
<span class="cp">#define SG_DXFER_TO_DEV (-2)    </span><span class="cm">/* e.g. a SCSI WRITE command */</span><span class="cp"></span>
<span class="cp">#define SG_DXFER_FROM_DEV (-3)  </span><span class="cm">/* e.g. a SCSI READ command */</span><span class="cp"></span>
<span class="cp">#define SG_DXFER_TO_FROM_DEV (-4) </span><span class="cm">/* treated like SG_DXFER_FROM_DEV with the</span>
<span class="cm">				   additional property than during indirect</span>
<span class="cm">				   IO the user buffer is copied into the</span>
<span class="cm">				   kernel buffers before the transfer */</span><span class="cp"></span>
<span class="cp">#define SG_DXFER_UNKNOWN (-5)   </span><span class="cm">/* Unknown data direction */</span><span class="cp"></span>

<span class="cm">/* following flag values can be &quot;or&quot;-ed together */</span>
<span class="cp">#define SG_FLAG_DIRECT_IO 1     </span><span class="cm">/* default is indirect IO */</span><span class="cp"></span>
<span class="cp">#define SG_FLAG_UNUSED_LUN_INHIBIT 2   </span><span class="cm">/* default is overwrite lun in SCSI */</span><span class="cp"></span>
				<span class="cm">/* command block (when &lt;= SCSI_2) */</span>
<span class="cp">#define SG_FLAG_MMAP_IO 4       </span><span class="cm">/* request memory mapped IO */</span><span class="cp"></span>
<span class="cp">#define SG_FLAG_NO_DXFER 0x10000 </span><span class="cm">/* no transfer of kernel buffers to/from */</span><span class="cp"></span>
				<span class="cm">/* user space (debug indirect IO) */</span>

<span class="cm">/* following &#39;info&#39; values are &quot;or&quot;-ed together */</span>
<span class="cp">#define SG_INFO_OK_MASK 0x1</span>
<span class="cp">#define SG_INFO_OK 0x0          </span><span class="cm">/* no sense, host nor driver &quot;noise&quot; */</span><span class="cp"></span>
<span class="cp">#define SG_INFO_CHECK 0x1       </span><span class="cm">/* something abnormal happened */</span><span class="cp"></span>

<span class="cp">#define SG_INFO_DIRECT_IO_MASK 0x6</span>
<span class="cp">#define SG_INFO_INDIRECT_IO 0x0 </span><span class="cm">/* data xfer via kernel buffers (or no xfer) */</span><span class="cp"></span>
<span class="cp">#define SG_INFO_DIRECT_IO 0x2   </span><span class="cm">/* direct IO requested and performed */</span><span class="cp"></span>
<span class="cp">#define SG_INFO_MIXED_IO 0x4    </span><span class="cm">/* part direct, part indirect IO */</span><span class="cp"></span>


<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sg_scsi_id</span> <span class="p">{</span> <span class="cm">/* used by SG_GET_SCSI_ID ioctl() */</span>
    <span class="kt">int</span> <span class="n">host_no</span><span class="p">;</span>        <span class="cm">/* as in &quot;scsi&lt;n&gt;&quot; where &#39;n&#39; is one of 0, 1, 2 etc */</span>
    <span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">scsi_id</span><span class="p">;</span>        <span class="cm">/* scsi id of target device */</span>
    <span class="kt">int</span> <span class="n">lun</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">scsi_type</span><span class="p">;</span>      <span class="cm">/* TYPE_... defined in scsi/scsi.h */</span>
    <span class="kt">short</span> <span class="n">h_cmd_per_lun</span><span class="p">;</span><span class="cm">/* host (adapter) maximum commands per lun */</span>
    <span class="kt">short</span> <span class="n">d_queue_depth</span><span class="p">;</span><span class="cm">/* device (or adapter) maximum queue length */</span>
    <span class="kt">int</span> <span class="n">unused</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>      <span class="cm">/* probably find a good use, set 0 for now */</span>
<span class="p">}</span> <span class="n">sg_scsi_id_t</span><span class="p">;</span> <span class="cm">/* 32 bytes long on i386 */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sg_req_info</span> <span class="p">{</span> <span class="cm">/* used by SG_GET_REQUEST_TABLE ioctl() */</span>
    <span class="kt">char</span> <span class="n">req_state</span><span class="p">;</span>     <span class="cm">/* 0 -&gt; not used, 1 -&gt; written, 2 -&gt; ready to read */</span>
    <span class="kt">char</span> <span class="n">orphan</span><span class="p">;</span>        <span class="cm">/* 0 -&gt; normal request, 1 -&gt; from interruped SG_IO */</span>
    <span class="kt">char</span> <span class="n">sg_io_owned</span><span class="p">;</span>   <span class="cm">/* 0 -&gt; complete with read(), 1 -&gt; owned by SG_IO */</span>
    <span class="kt">char</span> <span class="n">problem</span><span class="p">;</span>       <span class="cm">/* 0 -&gt; no problem detected, 1 -&gt; error to report */</span>
    <span class="kt">int</span> <span class="n">pack_id</span><span class="p">;</span>        <span class="cm">/* pack_id associated with request */</span>
    <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">usr_ptr</span><span class="p">;</span>     <span class="cm">/* user provided pointer (in new interface) */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">duration</span><span class="p">;</span> <span class="cm">/* millisecs elapsed since written (req_state==1)</span>
<span class="cm">			      or request duration (req_state==2) */</span>
    <span class="kt">int</span> <span class="n">unused</span><span class="p">;</span>
<span class="p">}</span> <span class="n">sg_req_info_t</span><span class="p">;</span> <span class="cm">/* 20 bytes long on i386 */</span>


<span class="cm">/* IOCTLs: Those ioctls that are relevant to the SG 3.x drivers follow.</span>
<span class="cm"> [Those that only apply to the SG 2.x drivers are at the end of the file.]</span>
<span class="cm"> (_GET_s yield result via &#39;int *&#39; 3rd argument unless otherwise indicated) */</span>

<span class="cp">#define SG_EMULATED_HOST 0x2203 </span><span class="cm">/* true for emulated host adapter (ATAPI) */</span><span class="cp"></span>

<span class="cm">/* Used to configure SCSI command transformation layer for ATAPI devices */</span>
<span class="cm">/* Only supported by the ide-scsi driver */</span>
<span class="cp">#define SG_SET_TRANSFORM 0x2204 </span><span class="cm">/* N.B. 3rd arg is not pointer but value: */</span><span class="cp"></span>
		      <span class="cm">/* 3rd arg = 0 to disable transform, 1 to enable it */</span>
<span class="cp">#define SG_GET_TRANSFORM 0x2205</span>

<span class="cp">#define SG_SET_RESERVED_SIZE 0x2275  </span><span class="cm">/* request a new reserved buffer size */</span><span class="cp"></span>
<span class="cp">#define SG_GET_RESERVED_SIZE 0x2272  </span><span class="cm">/* actual size of reserved buffer */</span><span class="cp"></span>

<span class="cm">/* The following ioctl has a &#39;sg_scsi_id_t *&#39; object as its 3rd argument. */</span>
<span class="cp">#define SG_GET_SCSI_ID 0x2276   </span><span class="cm">/* Yields fd&#39;s bus, chan, dev, lun + type */</span><span class="cp"></span>
<span class="cm">/* SCSI id information can also be obtained from SCSI_IOCTL_GET_IDLUN */</span>

<span class="cm">/* Override host setting and always DMA using low memory ( &lt;16MB on i386) */</span>
<span class="cp">#define SG_SET_FORCE_LOW_DMA 0x2279  </span><span class="cm">/* 0-&gt; use adapter setting, 1-&gt; force */</span><span class="cp"></span>
<span class="cp">#define SG_GET_LOW_DMA 0x227a   </span><span class="cm">/* 0-&gt; use all ram for dma; 1-&gt; low dma ram */</span><span class="cp"></span>

<span class="cm">/* When SG_SET_FORCE_PACK_ID set to 1, pack_id is input to read() which</span>
<span class="cm">   tries to fetch a packet with a matching pack_id, waits, or returns EAGAIN.</span>
<span class="cm">   If pack_id is -1 then read oldest waiting. When ...FORCE_PACK_ID set to 0</span>
<span class="cm">   then pack_id ignored by read() and oldest readable fetched. */</span>
<span class="cp">#define SG_SET_FORCE_PACK_ID 0x227b</span>
<span class="cp">#define SG_GET_PACK_ID 0x227c </span><span class="cm">/* Yields oldest readable pack_id (or -1) */</span><span class="cp"></span>

<span class="cp">#define SG_GET_NUM_WAITING 0x227d </span><span class="cm">/* Number of commands awaiting read() */</span><span class="cp"></span>

<span class="cm">/* Yields max scatter gather tablesize allowed by current host adapter */</span>
<span class="cp">#define SG_GET_SG_TABLESIZE 0x227F  </span><span class="cm">/* 0 implies can&#39;t do scatter gather */</span><span class="cp"></span>

<span class="cp">#define SG_GET_VERSION_NUM 0x2282 </span><span class="cm">/* Example: version 2.1.34 yields 20134 */</span><span class="cp"></span>

<span class="cm">/* Returns -EBUSY if occupied. 3rd argument pointer to int (see next) */</span>
<span class="cp">#define SG_SCSI_RESET 0x2284</span>
<span class="cm">/* Associated values that can be given to SG_SCSI_RESET follow */</span>
<span class="cp">#define		SG_SCSI_RESET_NOTHING	0</span>
<span class="cp">#define		SG_SCSI_RESET_DEVICE	1</span>
<span class="cp">#define		SG_SCSI_RESET_BUS	2</span>
<span class="cp">#define		SG_SCSI_RESET_HOST	3</span>
<span class="cp">#define		SG_SCSI_RESET_TARGET	4</span>

<span class="cm">/* synchronous SCSI command ioctl, (only in version 3 interface) */</span>
<span class="cp">#define SG_IO 0x2285   </span><span class="cm">/* similar effect as write() followed by read() */</span><span class="cp"></span>

<span class="cp">#define SG_GET_REQUEST_TABLE 0x2286   </span><span class="cm">/* yields table of active requests */</span><span class="cp"></span>

<span class="cm">/* How to treat EINTR during SG_IO ioctl(), only in SG 3.x series */</span>
<span class="cp">#define SG_SET_KEEP_ORPHAN 0x2287 </span><span class="cm">/* 1 -&gt; hold for read(), 0 -&gt; drop (def) */</span><span class="cp"></span>
<span class="cp">#define SG_GET_KEEP_ORPHAN 0x2288</span>

<span class="cm">/* yields scsi midlevel&#39;s access_count for this SCSI device */</span>
<span class="cp">#define SG_GET_ACCESS_COUNT 0x2289  </span>


<span class="cp">#define SG_SCATTER_SZ (8 * 4096)</span>
<span class="cm">/* Largest size (in bytes) a single scatter-gather list element can have.</span>
<span class="cm">   The value used by the driver is &#39;max(SG_SCATTER_SZ, PAGE_SIZE)&#39;.</span>
<span class="cm">   This value should be a power of 2 (and may be rounded up internally).</span>
<span class="cm">   If scatter-gather is not supported by adapter then this value is the</span>
<span class="cm">   largest data block that can be read/written by a single scsi command. */</span>

<span class="cp">#define SG_DEFAULT_RETRIES 0</span>

<span class="cm">/* Defaults, commented if they differ from original sg driver */</span>
<span class="cp">#define SG_DEF_FORCE_LOW_DMA 0  </span><span class="cm">/* was 1 -&gt; memory below 16MB on i386 */</span><span class="cp"></span>
<span class="cp">#define SG_DEF_FORCE_PACK_ID 0</span>
<span class="cp">#define SG_DEF_KEEP_ORPHAN 0</span>
<span class="cp">#define SG_DEF_RESERVED_SIZE SG_SCATTER_SZ </span><span class="cm">/* load time option */</span><span class="cp"></span>

<span class="cm">/* maximum outstanding requests, write() yields EDOM if exceeded */</span>
<span class="cp">#define SG_MAX_QUEUE 16</span>

<span class="cp">#define SG_BIG_BUFF SG_DEF_RESERVED_SIZE    </span><span class="cm">/* for backward compatibility */</span><span class="cp"></span>

<span class="cm">/* Alternate style type names, &quot;..._t&quot; variants preferred */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sg_io_hdr</span> <span class="n">Sg_io_hdr</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sg_io_vec</span> <span class="n">Sg_io_vec</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sg_scsi_id</span> <span class="n">Sg_scsi_id</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sg_req_info</span> <span class="n">Sg_req_info</span><span class="p">;</span>


<span class="cm">/* vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv */</span>
<span class="cm">/*   The older SG interface based on the &#39;sg_header&#39; structure follows.   */</span>
<span class="cm">/* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */</span>

<span class="cp">#define SG_MAX_SENSE 16   </span><span class="cm">/* this only applies to the sg_header interface */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">sg_header</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">pack_len</span><span class="p">;</span>    <span class="cm">/* [o] reply_len (ie useless), ignored as input */</span>
    <span class="kt">int</span> <span class="n">reply_len</span><span class="p">;</span>   <span class="cm">/* [i] max length of expected reply (inc. sg_header) */</span>
    <span class="kt">int</span> <span class="n">pack_id</span><span class="p">;</span>     <span class="cm">/* [io] id number of packet (use ints &gt;= 0) */</span>
    <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>      <span class="cm">/* [o] 0==ok, else (+ve) Unix errno (best ignored) */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">twelve_byte</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* [i] Force 12 byte command length for group 6 &amp; 7 commands  */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">target_status</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>   <span class="cm">/* [o] scsi status from target */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">host_status</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>     <span class="cm">/* [o] host status (see &quot;DID&quot; codes) */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">driver_status</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>   <span class="cm">/* [o] driver status+suggestion */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">other_flags</span><span class="o">:</span><span class="mi">10</span><span class="p">;</span>    <span class="cm">/* unused */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sense_buffer</span><span class="p">[</span><span class="n">SG_MAX_SENSE</span><span class="p">];</span> <span class="cm">/* [o] Output in 3 cases:</span>
<span class="cm">	   when target_status is CHECK_CONDITION or</span>
<span class="cm">	   when target_status is COMMAND_TERMINATED or</span>
<span class="cm">	   when (driver_status &amp; DRIVER_SENSE) is true. */</span>
<span class="p">};</span>      <span class="cm">/* This structure is 36 bytes long on i386 */</span>


<span class="cm">/* IOCTLs: The following are not required (or ignored) when the sg_io_hdr_t</span>
<span class="cm">	   interface is used. They are kept for backward compatibility with</span>
<span class="cm">	   the original and version 2 drivers. */</span>

<span class="cp">#define SG_SET_TIMEOUT 0x2201  </span><span class="cm">/* unit: jiffies (10ms on i386) */</span><span class="cp"></span>
<span class="cp">#define SG_GET_TIMEOUT 0x2202  </span><span class="cm">/* yield timeout as _return_ value */</span><span class="cp"></span>

<span class="cm">/* Get/set command queuing state per fd (default is SG_DEF_COMMAND_Q.</span>
<span class="cm">   Each time a sg_io_hdr_t object is seen on this file descriptor, this</span>
<span class="cm">   command queuing flag is set on (overriding the previous setting). */</span>
<span class="cp">#define SG_GET_COMMAND_Q 0x2270   </span><span class="cm">/* Yields 0 (queuing off) or 1 (on) */</span><span class="cp"></span>
<span class="cp">#define SG_SET_COMMAND_Q 0x2271   </span><span class="cm">/* Change queuing state with 0 or 1 */</span><span class="cp"></span>

<span class="cm">/* Turn on/off error sense trace (1 and 0 respectively, default is off).</span>
<span class="cm">   Try using: &quot;# cat /proc/scsi/sg/debug&quot; instead in the v3 driver */</span>
<span class="cp">#define SG_SET_DEBUG 0x227e    </span><span class="cm">/* 0 -&gt; turn off debug */</span><span class="cp"></span>

<span class="cp">#define SG_NEXT_CMD_LEN 0x2283  </span><span class="cm">/* override SCSI command length with given</span>
<span class="cm">		   number on the next write() on this file descriptor */</span><span class="cp"></span>


<span class="cm">/* Defaults, commented if they differ from original sg driver */</span>
<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#define SG_DEFAULT_TIMEOUT_USER	(60*USER_HZ) </span><span class="cm">/* HZ == &#39;jiffies in 1 second&#39; */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define SG_DEFAULT_TIMEOUT	(60*HZ)	     </span><span class="cm">/* HZ == &#39;jiffies in 1 second&#39; */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#define SG_DEF_COMMAND_Q 0     </span><span class="cm">/* command queuing is always on when</span>
<span class="cm">				  the new interface is used */</span><span class="cp"></span>
<span class="cp">#define SG_DEF_UNDERRUN_FLAG 0</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
