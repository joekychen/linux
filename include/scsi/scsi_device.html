<!DOCTYPE html>
<html><head><title>joekychen/linux » include › scsi › scsi_device.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>scsi_device.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _SCSI_SCSI_DEVICE_H</span>
<span class="cp">#define _SCSI_SCSI_DEVICE_H</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">request_queue</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">scsi_cmnd</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">scsi_lun</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">scsi_sense_hdr</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">scsi_mode_data</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">length</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">block_descriptor_length</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">medium_type</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">device_specific</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">header_length</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">longlba</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * sdev state: If you alter this, you also need to alter scsi_sysfs.c</span>
<span class="cm"> * (for the ascii descriptions) and the state model enforcer:</span>
<span class="cm"> * scsi_lib:scsi_device_set_state().</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">scsi_device_state</span> <span class="p">{</span>
	<span class="n">SDEV_CREATED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* device created but not added to sysfs</span>
<span class="cm">				 * Only internal commands allowed (for inq) */</span>
	<span class="n">SDEV_RUNNING</span><span class="p">,</span>		<span class="cm">/* device properly configured</span>
<span class="cm">				 * All commands allowed */</span>
	<span class="n">SDEV_CANCEL</span><span class="p">,</span>		<span class="cm">/* beginning to delete device</span>
<span class="cm">				 * Only error handler commands allowed */</span>
	<span class="n">SDEV_DEL</span><span class="p">,</span>		<span class="cm">/* device deleted </span>
<span class="cm">				 * no commands allowed */</span>
	<span class="n">SDEV_QUIESCE</span><span class="p">,</span>		<span class="cm">/* Device quiescent.  No block commands</span>
<span class="cm">				 * will be accepted, only specials (which</span>
<span class="cm">				 * originate in the mid-layer) */</span>
	<span class="n">SDEV_OFFLINE</span><span class="p">,</span>		<span class="cm">/* Device offlined (by error handling or</span>
<span class="cm">				 * user request */</span>
	<span class="n">SDEV_BLOCK</span><span class="p">,</span>		<span class="cm">/* Device blocked by scsi lld.  No</span>
<span class="cm">				 * scsi commands from user or midlayer</span>
<span class="cm">				 * should be issued to the scsi</span>
<span class="cm">				 * lld. */</span>
	<span class="n">SDEV_CREATED_BLOCK</span><span class="p">,</span>	<span class="cm">/* same as above but for created devices */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">scsi_device_event</span> <span class="p">{</span>
	<span class="n">SDEV_EVT_MEDIA_CHANGE</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* media has changed */</span>

	<span class="n">SDEV_EVT_LAST</span>		<span class="o">=</span> <span class="n">SDEV_EVT_MEDIA_CHANGE</span><span class="p">,</span>
	<span class="n">SDEV_EVT_MAXBITS</span>	<span class="o">=</span> <span class="n">SDEV_EVT_LAST</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">scsi_event</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">scsi_device_event</span>	<span class="n">evt_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">node</span><span class="p">;</span>

	<span class="cm">/* put union of data structures, for non-simple event types,</span>
<span class="cm">	 * here</span>
<span class="cm">	 */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">scsi_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">request_queue</span><span class="p">;</span>

	<span class="cm">/* the next two are protected by the host-&gt;host_lock */</span>
	<span class="k">struct</span> <span class="n">list_head</span>    <span class="n">siblings</span><span class="p">;</span>   <span class="cm">/* list of all devices on this host */</span>
	<span class="k">struct</span> <span class="n">list_head</span>    <span class="n">same_target_siblings</span><span class="p">;</span> <span class="cm">/* just the devices sharing same target id */</span>

	<span class="cm">/* this is now protected by the request_queue-&gt;queue_lock */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device_busy</span><span class="p">;</span>	<span class="cm">/* commands actually active on</span>
<span class="cm">					 * low-level. protected by queue_lock. */</span>
	<span class="n">spinlock_t</span> <span class="n">list_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cmd_list</span><span class="p">;</span>	<span class="cm">/* queue of in use SCSI Command structures */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">starved_entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">current_cmnd</span><span class="p">;</span>	<span class="cm">/* currently active command */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">queue_depth</span><span class="p">;</span>	<span class="cm">/* How deep of a queue we want */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">max_queue_depth</span><span class="p">;</span>	<span class="cm">/* max queue depth */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">last_queue_full_depth</span><span class="p">;</span> <span class="cm">/* These two are used by */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">last_queue_full_count</span><span class="p">;</span> <span class="cm">/* scsi_track_queue_full() */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_queue_full_time</span><span class="p">;</span>	<span class="cm">/* last queue full time */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">queue_ramp_up_period</span><span class="p">;</span>	<span class="cm">/* ramp up period in jiffies */</span>
<span class="cp">#define SCSI_DEFAULT_RAMP_UP_PERIOD	(120 * HZ)</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_queue_ramp_up</span><span class="p">;</span>	<span class="cm">/* last queue ramp up time */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">channel</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">manufacturer</span><span class="p">;</span>	<span class="cm">/* Manufacturer of device, for using </span>
<span class="cm">					 * vendor-specific cmd&#39;s */</span>
	<span class="kt">unsigned</span> <span class="n">sector_size</span><span class="p">;</span>	<span class="cm">/* size in bytes */</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">hostdata</span><span class="p">;</span>		<span class="cm">/* available to low-level driver */</span>
	<span class="kt">char</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">scsi_level</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">inq_periph_qual</span><span class="p">;</span>	<span class="cm">/* PQ from INQUIRY data */</span>	
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">inquiry_len</span><span class="p">;</span>	<span class="cm">/* valid bytes in &#39;inquiry&#39; */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">inquiry</span><span class="p">;</span>	<span class="cm">/* INQUIRY response data */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">vendor</span><span class="p">;</span>		<span class="cm">/* [back_compat] point into &#39;inquiry&#39; ... */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">model</span><span class="p">;</span>		<span class="cm">/* ... after scan; point to static string */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">rev</span><span class="p">;</span>		<span class="cm">/* ... &quot;nullnullnullnull&quot; before scan */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">current_tag</span><span class="p">;</span>	<span class="cm">/* current tag */</span>
	<span class="k">struct</span> <span class="n">scsi_target</span>      <span class="o">*</span><span class="n">sdev_target</span><span class="p">;</span>   <span class="cm">/* used only for single_lun */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">sdev_bflags</span><span class="p">;</span> <span class="cm">/* black/white flags as also found in</span>
<span class="cm">				 * scsi_devinfo.[hc]. For now used only to</span>
<span class="cm">				 * pass settings from slave_alloc to scsi</span>
<span class="cm">				 * core. */</span>
	<span class="kt">unsigned</span> <span class="n">writeable</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">removable</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">changed</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Data invalid due to media change */</span>
	<span class="kt">unsigned</span> <span class="n">busy</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Used to prevent races */</span>
	<span class="kt">unsigned</span> <span class="n">lockable</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Able to prevent media removal */</span>
	<span class="kt">unsigned</span> <span class="n">locked</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>      <span class="cm">/* Media removal disabled */</span>
	<span class="kt">unsigned</span> <span class="n">borken</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Tell the Seagate driver to be </span>
<span class="cm">				 * painfully slow on this device */</span>
	<span class="kt">unsigned</span> <span class="n">disconnect</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* can disconnect */</span>
	<span class="kt">unsigned</span> <span class="n">soft_reset</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Uses soft reset option */</span>
	<span class="kt">unsigned</span> <span class="n">sdtr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Device supports SDTR messages */</span>
	<span class="kt">unsigned</span> <span class="n">wdtr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Device supports WDTR messages */</span>
	<span class="kt">unsigned</span> <span class="n">ppr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Device supports PPR messages */</span>
	<span class="kt">unsigned</span> <span class="n">tagged_supported</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Supports SCSI-II tagged queuing */</span>
	<span class="kt">unsigned</span> <span class="n">simple_tags</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* simple queue tag messages are enabled */</span>
	<span class="kt">unsigned</span> <span class="n">ordered_tags</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span><span class="cm">/* ordered queue tag messages are enabled */</span>
	<span class="kt">unsigned</span> <span class="n">was_reset</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* There was a bus reset on the bus for </span>
<span class="cm">				 * this device */</span>
	<span class="kt">unsigned</span> <span class="n">expecting_cc_ua</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Expecting a CHECK_CONDITION/UNIT_ATTN</span>
<span class="cm">				     * because we did a bus reset. */</span>
	<span class="kt">unsigned</span> <span class="n">use_10_for_rw</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* first try 10-byte read / write */</span>
	<span class="kt">unsigned</span> <span class="n">use_10_for_ms</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* first try 10-byte mode sense/select */</span>
	<span class="kt">unsigned</span> <span class="n">skip_ms_page_8</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* do not use MODE SENSE page 0x08 */</span>
	<span class="kt">unsigned</span> <span class="n">skip_ms_page_3f</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* do not use MODE SENSE page 0x3f */</span>
	<span class="kt">unsigned</span> <span class="n">skip_vpd_pages</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* do not read VPD pages */</span>
	<span class="kt">unsigned</span> <span class="n">use_192_bytes_for_3f</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* ask for 192 bytes from page 0x3f */</span>
	<span class="kt">unsigned</span> <span class="n">no_start_on_add</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* do not issue start on add */</span>
	<span class="kt">unsigned</span> <span class="n">allow_restart</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* issue START_UNIT in error handler */</span>
	<span class="kt">unsigned</span> <span class="n">manage_start_stop</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Let HLD (sd) manage start/stop */</span>
	<span class="kt">unsigned</span> <span class="n">start_stop_pwr_cond</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Set power cond. in START_STOP_UNIT */</span>
	<span class="kt">unsigned</span> <span class="n">no_uld_attach</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* disable connecting to upper level drivers */</span>
	<span class="kt">unsigned</span> <span class="n">select_no_atn</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">fix_capacity</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* READ_CAPACITY is too high by 1 */</span>
	<span class="kt">unsigned</span> <span class="n">guess_capacity</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* READ_CAPACITY might be too high by 1 */</span>
	<span class="kt">unsigned</span> <span class="n">retry_hwerror</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Retry HARDWARE_ERROR */</span>
	<span class="kt">unsigned</span> <span class="n">last_sector_bug</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* do not use multisector accesses on</span>
<span class="cm">					   SD_LAST_BUGGY_SECTORS */</span>
	<span class="kt">unsigned</span> <span class="n">no_read_disc_info</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Avoid READ_DISC_INFO cmds */</span>
	<span class="kt">unsigned</span> <span class="n">no_read_capacity_16</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Avoid READ_CAPACITY_16 cmds */</span>
	<span class="kt">unsigned</span> <span class="n">try_rc_10_first</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Try READ_CAPACACITY_10 first */</span>
	<span class="kt">unsigned</span> <span class="n">is_visible</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* is the device visible in sysfs */</span>

	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">supported_events</span><span class="p">,</span> <span class="n">SDEV_EVT_MAXBITS</span><span class="p">);</span> <span class="cm">/* supported events */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">event_list</span><span class="p">;</span>	<span class="cm">/* asserted events */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">event_work</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device_blocked</span><span class="p">;</span>	<span class="cm">/* Device returned QUEUE_FULL. */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_device_blocked</span><span class="p">;</span> <span class="cm">/* what device_blocked counts down from  */</span>
<span class="cp">#define SCSI_DEFAULT_DEVICE_BLOCKED	3</span>

	<span class="n">atomic_t</span> <span class="n">iorequest_cnt</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">iodone_cnt</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">ioerr_cnt</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device</span>		<span class="n">sdev_gendev</span><span class="p">,</span>
				<span class="n">sdev_dev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">execute_work</span>	<span class="n">ew</span><span class="p">;</span> <span class="cm">/* used to get process context on put */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">requeue_work</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">scsi_dh_data</span>	<span class="o">*</span><span class="n">scsi_dh_data</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">scsi_device_state</span> <span class="n">sdev_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">sdev_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))));</span>

<span class="k">struct</span> <span class="n">scsi_dh_devlist</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">vendor</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">model</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">activate_complete</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">scsi_device_handler</span> <span class="p">{</span>
	<span class="cm">/* Used by the infrastructure */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span> <span class="cm">/* list of scsi_device_handlers */</span>

	<span class="cm">/* Filled by the hardware handler */</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">scsi_dh_devlist</span> <span class="o">*</span><span class="n">devlist</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_sense</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">attach</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">detach</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">activate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">activate_complete</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">prep_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_params</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">scsi_dh_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device_handler</span> <span class="o">*</span><span class="n">scsi_dh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">kref</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define	to_scsi_device(d)	\</span>
<span class="cp">	container_of(d, struct scsi_device, sdev_gendev)</span>
<span class="cp">#define	class_to_sdev(d)	\</span>
<span class="cp">	container_of(d, struct scsi_device, sdev_dev)</span>
<span class="cp">#define transport_class_to_sdev(class_dev) \</span>
<span class="cp">	to_scsi_device(class_dev-&gt;parent)</span>

<span class="cp">#define sdev_printk(prefix, sdev, fmt, a...)	\</span>
<span class="cp">	dev_printk(prefix, &amp;(sdev)-&gt;sdev_gendev, fmt, ##a)</span>

<span class="cp">#define scmd_printk(prefix, scmd, fmt, a...)				\</span>
<span class="cp">        (scmd)-&gt;request-&gt;rq_disk ?					\</span>
<span class="cp">	sdev_printk(prefix, (scmd)-&gt;device, &quot;[%s] &quot; fmt,		\</span>
<span class="cp">		    (scmd)-&gt;request-&gt;rq_disk-&gt;disk_name, ##a) :		\</span>
<span class="cp">	sdev_printk(prefix, (scmd)-&gt;device, fmt, ##a)</span>

<span class="k">enum</span> <span class="n">scsi_target_state</span> <span class="p">{</span>
	<span class="n">STARGET_CREATED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">STARGET_RUNNING</span><span class="p">,</span>
	<span class="n">STARGET_DEL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * scsi_target: representation of a scsi target, for now, this is only</span>
<span class="cm"> * used for single_lun devices. If no one has active IO to the target,</span>
<span class="cm"> * starget_sdev_user is NULL, else it points to the active sdev.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">scsi_target</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span>	<span class="o">*</span><span class="n">starget_sdev_user</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">siblings</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">devices</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">reap_ref</span><span class="p">;</span> <span class="cm">/* protected by the host lock */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">channel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">id</span><span class="p">;</span> <span class="cm">/* target id ... replace</span>
<span class="cm">				     * scsi_device.id eventually */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">create</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* signal that it needs to be added */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">single_lun</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Indicates we should only</span>
<span class="cm">						 * allow I/O to one of the luns</span>
<span class="cm">						 * for the device at a time. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pdt_1f_for_no_lun</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* PDT = 0x1f</span>
<span class="cm">						 * means no lun present. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">no_report_luns</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Don&#39;t use</span>
<span class="cm">						 * REPORT LUNS for scanning. */</span>
	<span class="cm">/* commands actually active on LLD. protected by host lock. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">target_busy</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * LLDs should set this in the slave_alloc host template callout.</span>
<span class="cm">	 * If set to zero then there is not limit.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">can_queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">target_blocked</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">max_target_blocked</span><span class="p">;</span>
<span class="cp">#define SCSI_DEFAULT_TARGET_BLOCKED	3</span>

	<span class="kt">char</span>			<span class="n">scsi_level</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">execute_work</span>	<span class="n">ew</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">scsi_target_state</span>	<span class="n">state</span><span class="p">;</span>
	<span class="kt">void</span> 			<span class="o">*</span><span class="n">hostdata</span><span class="p">;</span> <span class="cm">/* available to low-level driver */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">starget_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* for the transport */</span>
	<span class="cm">/* starget_data must be the last element!!!! */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))));</span>

<span class="cp">#define to_scsi_target(d)	container_of(d, struct scsi_target, dev)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="nf">scsi_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">to_scsi_target</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define transport_class_to_starget(class_dev) \</span>
<span class="cp">	to_scsi_target(class_dev-&gt;parent)</span>

<span class="cp">#define starget_printk(prefix, starget, fmt, a...)	\</span>
<span class="cp">	dev_printk(prefix, &amp;(starget)-&gt;dev, fmt, ##a)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">__scsi_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span>
		<span class="n">uint</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hostdata</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="n">uint</span> <span class="n">channel</span><span class="p">,</span>
			   <span class="n">uint</span> <span class="n">target</span><span class="p">,</span> <span class="n">uint</span> <span class="n">lun</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_register_device_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device_handler</span> <span class="o">*</span><span class="n">scsi_dh</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_remove_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_unregister_device_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device_handler</span> <span class="o">*</span><span class="n">scsi_dh</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_device_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_device_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsi_device_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span>
					      <span class="n">uint</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">uint</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">__scsi_device_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span>
						<span class="n">uint</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">uint</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsi_device_lookup_by_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="p">,</span>
							<span class="n">uint</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">__scsi_device_lookup_by_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="p">,</span>
							  <span class="n">uint</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">starget_for_each_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__starget_for_each_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span>
						 <span class="kt">void</span> <span class="o">*</span><span class="p">));</span>

<span class="cm">/* only exposed to implement shost_for_each_device */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">__scsi_iterate_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * shost_for_each_device - iterate over all devices of a host</span>
<span class="cm"> * @sdev: the &amp;struct scsi_device to use as a cursor</span>
<span class="cm"> * @shost: the &amp;struct scsi_host to iterate over</span>
<span class="cm"> *</span>
<span class="cm"> * Iterator that returns each device attached to @shost.  This loop</span>
<span class="cm"> * takes a reference on each device and releases it at the end.  If</span>
<span class="cm"> * you break out of the loop, you must call scsi_device_put(sdev).</span>
<span class="cm"> */</span>
<span class="cp">#define shost_for_each_device(sdev, shost) \</span>
<span class="cp">	for ((sdev) = __scsi_iterate_devices((shost), NULL); \</span>
<span class="cp">	     (sdev); \</span>
<span class="cp">	     (sdev) = __scsi_iterate_devices((shost), (sdev)))</span>

<span class="cm">/**</span>
<span class="cm"> * __shost_for_each_device - iterate over all devices of a host (UNLOCKED)</span>
<span class="cm"> * @sdev: the &amp;struct scsi_device to use as a cursor</span>
<span class="cm"> * @shost: the &amp;struct scsi_host to iterate over</span>
<span class="cm"> *</span>
<span class="cm"> * Iterator that returns each device attached to @shost.  It does _not_</span>
<span class="cm"> * take a reference on the scsi_device, so the whole loop must be</span>
<span class="cm"> * protected by shost-&gt;host_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: The only reason to use this is because you need to access the</span>
<span class="cm"> * device list in interrupt context.  Otherwise you really want to use</span>
<span class="cm"> * shost_for_each_device instead.</span>
<span class="cm"> */</span>
<span class="cp">#define __shost_for_each_device(sdev, shost) \</span>
<span class="cp">	list_for_each_entry((sdev), &amp;((shost)-&gt;__devices), siblings)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_track_queue_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_set_medium_removal</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_mode_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dbd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">modepage</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">retries</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_mode_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_mode_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sp</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">modepage</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="n">retries</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">scsi_mode_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_test_unit_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">retries</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="n">sshdr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_get_vpd_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">buf_len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_device_set_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">scsi_device_state</span> <span class="n">state</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">scsi_event</span> <span class="o">*</span><span class="n">sdev_evt_alloc</span><span class="p">(</span><span class="k">enum</span> <span class="n">scsi_device_event</span> <span class="n">evt_type</span><span class="p">,</span>
					  <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sdev_evt_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_event</span> <span class="o">*</span><span class="n">evt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sdev_evt_send_simple</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">scsi_device_event</span> <span class="n">evt_type</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_device_quiesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_device_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_target_quiesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_target_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_scan_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rescan</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_target_reap</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_target_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_target_unblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_remove_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">int_to_scsilun</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_lun</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsilun_to_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_lun</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scsi_device_state_name</span><span class="p">(</span><span class="k">enum</span> <span class="n">scsi_device_state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_is_sdev_device</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_is_target_device</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_execute</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">data_direction</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">bufflen</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sense</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="n">retries</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">flag</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">resid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_execute_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">data_direction</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">bufflen</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="n">retries</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="o">*</span><span class="n">resid</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM_RUNTIME</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scsi_autopm_get_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scsi_autopm_put_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_autopm_get_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">scsi_autopm_put_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM_RUNTIME */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">scsi_device_reprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">device_reprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sdev_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sdev_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define scmd_id(scmd) sdev_id((scmd)-&gt;device)</span>
<span class="cp">#define scmd_channel(scmd) sdev_channel((scmd)-&gt;device)</span>

<span class="cm">/*</span>
<span class="cm"> * checks for positions of the SCSI state machine</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_device_online</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">!=</span> <span class="n">SDEV_OFFLINE</span> <span class="o">&amp;&amp;</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">!=</span> <span class="n">SDEV_DEL</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_device_blocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">==</span> <span class="n">SDEV_BLOCK</span> <span class="o">||</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">==</span> <span class="n">SDEV_CREATED_BLOCK</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_device_created</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">==</span> <span class="n">SDEV_CREATED</span> <span class="o">||</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">==</span> <span class="n">SDEV_CREATED_BLOCK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* accessor functions for the SCSI parameters */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_device_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdtr</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_device_wide</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">wdtr</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_device_dt</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ppr</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_device_dt_only</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span> <span class="o">&lt;</span> <span class="mi">57</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry</span><span class="p">[</span><span class="mi">56</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0c</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x04</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_device_ius</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span> <span class="o">&lt;</span> <span class="mi">57</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry</span><span class="p">[</span><span class="mi">56</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_device_qas</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry_len</span> <span class="o">&lt;</span> <span class="mi">57</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry</span><span class="p">[</span><span class="mi">56</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_device_enclosure</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry</span> <span class="o">?</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">))</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_device_protection</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">&gt;</span> <span class="n">SCSI_2</span> <span class="o">&amp;&amp;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi_device_tpgs</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry</span> <span class="o">?</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">inquiry</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define MODULE_ALIAS_SCSI_DEVICE(type) \</span>
<span class="cp">	MODULE_ALIAS(&quot;scsi:t-&quot; __stringify(type) &quot;*&quot;)</span>
<span class="cp">#define SCSI_DEVICE_MODALIAS_FMT &quot;scsi:t-0x%02x&quot;</span>

<span class="cp">#endif </span><span class="cm">/* _SCSI_SCSI_DEVICE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
