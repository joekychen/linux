<!DOCTYPE html>
<html><head><title>joekychen/linux » include › scsi › osd_initiator.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>osd_initiator.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * osd_initiator.h - OSD initiator API definition</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008 Panasas Inc.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:</span>
<span class="cm"> *   Boaz Harrosh &lt;bharrosh@panasas.com&gt;</span>
<span class="cm"> *   Benny Halevy &lt;bhalevy@panasas.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __OSD_INITIATOR_H__</span>
<span class="cp">#define __OSD_INITIATOR_H__</span>

<span class="cp">#include &quot;osd_protocol.h&quot;</span>
<span class="cp">#include &quot;osd_types.h&quot;</span>

<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>

<span class="cm">/* Note: &quot;NI&quot; in comments below means &quot;Not Implemented yet&quot; */</span>

<span class="cm">/* Configure of code:</span>
<span class="cm"> * #undef if you *don&#39;t* want OSD v1 support in runtime.</span>
<span class="cm"> * If #defined the initiator will dynamically configure to encode OSD v1</span>
<span class="cm"> * CDB&#39;s if the target is detected to be OSD v1 only.</span>
<span class="cm"> * OSD v2 only commands, options, and attributes will be ignored if target</span>
<span class="cm"> * is v1 only.</span>
<span class="cm"> * If #defined will result in bigger/slower code (OK Slower maybe not)</span>
<span class="cm"> * Q: Should this be CONFIG_SCSI_OSD_VER1_SUPPORT and set from Kconfig?</span>
<span class="cm"> */</span>
<span class="cp">#define OSD_VER1_SUPPORT y</span>

<span class="k">enum</span> <span class="n">osd_std_version</span> <span class="p">{</span>
	<span class="n">OSD_VER_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">OSD_VER1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">OSD_VER2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Object-based Storage Device.</span>
<span class="cm"> * This object represents an OSD device.</span>
<span class="cm"> * It is not a full linux device in any way. It is only</span>
<span class="cm"> * a place to hang resources associated with a Linux</span>
<span class="cm"> * request Q and some default properties.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">osd_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsi_device</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">def_timeout</span><span class="p">;</span>

<span class="cp">#ifdef OSD_VER1_SUPPORT</span>
	<span class="k">enum</span> <span class="n">osd_std_version</span> <span class="n">version</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* Unique Identification of an OSD device */</span>
<span class="k">struct</span> <span class="n">osd_dev_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">systemid_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">systemid</span><span class="p">[</span><span class="n">OSD_SYSTEMID_LEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">osdname_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">osdname</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Retrieve/return osd_dev(s) for use by Kernel clients</span>
<span class="cm"> * Use IS_ERR/ERR_PTR on returned &quot;osd_dev *&quot;.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">osd_dev</span> <span class="o">*</span><span class="n">osduld_path_lookup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">osd_dev</span> <span class="o">*</span><span class="n">osduld_info_lookup</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">osd_dev_info</span> <span class="o">*</span><span class="n">odi</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">osduld_put_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_dev</span> <span class="o">*</span><span class="n">od</span><span class="p">);</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_dev_info</span> <span class="o">*</span><span class="n">osduld_device_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_dev</span> <span class="o">*</span><span class="n">od</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">osduld_device_same</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_dev</span> <span class="o">*</span><span class="n">od</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">osd_dev_info</span> <span class="o">*</span><span class="n">odi</span><span class="p">);</span>

<span class="cm">/* Add/remove test ioctls from external modules */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="n">do_test_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">osd_dev</span> <span class="o">*</span><span class="n">od</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">osduld_register_test</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ioctl</span><span class="p">,</span> <span class="n">do_test_fn</span> <span class="o">*</span><span class="n">do_test</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">osduld_unregister_test</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ioctl</span><span class="p">);</span>

<span class="cm">/* These are called by uld at probe time */</span>
<span class="kt">void</span> <span class="n">osd_dev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_dev</span> <span class="o">*</span><span class="n">od</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsi_device</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">osd_dev_fini</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_dev</span> <span class="o">*</span><span class="n">od</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * osd_auto_detect_ver - Detect the OSD version, return Unique Identification</span>
<span class="cm"> *</span>
<span class="cm"> * @od:     OSD target lun handle</span>
<span class="cm"> * @caps:   Capabilities authorizing OSD root read attributes access</span>
<span class="cm"> * @odi:    Retrieved information uniquely identifying the osd target lun</span>
<span class="cm"> *          Note: odi-&gt;osdname must be kfreed by caller.</span>
<span class="cm"> *</span>
<span class="cm"> * Auto detects the OSD version of the OSD target and sets the @od</span>
<span class="cm"> * accordingly. Meanwhile also returns the &quot;system id&quot; and &quot;osd name&quot; root</span>
<span class="cm"> * attributes which uniquely identify the OSD target. This member is usually</span>
<span class="cm"> * called by the ULD. ULD users should call osduld_device_info().</span>
<span class="cm"> * This rutine allocates osd requests and memory at GFP_KERNEL level and might</span>
<span class="cm"> * sleep.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">osd_auto_detect_ver</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_dev</span> <span class="o">*</span><span class="n">od</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">caps</span><span class="p">,</span> <span class="k">struct</span> <span class="n">osd_dev_info</span> <span class="o">*</span><span class="n">odi</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="nf">osd_request_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_dev</span> <span class="o">*</span><span class="n">od</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">scsi_device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* we might want to use function vector in the future */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">osd_dev_set_ver</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_dev</span> <span class="o">*</span><span class="n">od</span><span class="p">,</span> <span class="k">enum</span> <span class="n">osd_std_version</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef OSD_VER1_SUPPORT</span>
	<span class="n">od</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">osd_dev_is_ver1</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_dev</span> <span class="o">*</span><span class="n">od</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef OSD_VER1_SUPPORT</span>
	<span class="k">return</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">==</span> <span class="n">OSD_VER1</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">osd_request</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">osd_req_done_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">osd_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">osd_cdb</span> <span class="n">cdb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">osd_data_out_integrity_info</span> <span class="n">out_data_integ</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">osd_data_in_integrity_info</span> <span class="n">in_data_integ</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">osd_dev</span> <span class="o">*</span><span class="n">osd_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">request</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">_osd_req_data_segment</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">alloc_size</span><span class="p">;</span> <span class="cm">/* 0 here means: don&#39;t call kfree */</span>
		<span class="kt">unsigned</span> <span class="n">total_bytes</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">cdb_cont</span><span class="p">,</span> <span class="n">set_attr</span><span class="p">,</span> <span class="n">enc_get_attr</span><span class="p">,</span> <span class="n">get_attr</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">_osd_io_info</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">total_bytes</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">residual</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">_osd_req_data_segment</span> <span class="o">*</span><span class="n">last_seg</span><span class="p">;</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">pad_buff</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">out</span><span class="p">,</span> <span class="n">in</span><span class="p">;</span>

	<span class="n">gfp_t</span> <span class="n">alloc_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">retries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">sense_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sense</span><span class="p">[</span><span class="n">OSD_MAX_SENSE_LEN</span><span class="p">];</span>
	<span class="k">enum</span> <span class="n">osd_attributes_mode</span> <span class="n">attributes_mode</span><span class="p">;</span>

	<span class="n">osd_req_done_fn</span> <span class="o">*</span><span class="n">async_done</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">async_private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">async_error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">req_errors</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">osd_req_is_ver1</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">osd_dev_is_ver1</span><span class="p">(</span><span class="n">or</span><span class="o">-&gt;</span><span class="n">osd_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * How to use the osd library:</span>
<span class="cm"> *</span>
<span class="cm"> * osd_start_request</span>
<span class="cm"> *	Allocates a request.</span>
<span class="cm"> *</span>
<span class="cm"> * osd_req_*</span>
<span class="cm"> *	Call one of, to encode the desired operation.</span>
<span class="cm"> *</span>
<span class="cm"> * osd_add_{get,set}_attr</span>
<span class="cm"> *	Optionally add attributes to the CDB, list or page mode.</span>
<span class="cm"> *</span>
<span class="cm"> * osd_finalize_request</span>
<span class="cm"> *	Computes final data out/in offsets and signs the request,</span>
<span class="cm"> *	making it ready for execution.</span>
<span class="cm"> *</span>
<span class="cm"> * osd_execute_request</span>
<span class="cm"> *	May be called to execute it through the block layer. Other wise submit</span>
<span class="cm"> *	the associated block request in some other way.</span>
<span class="cm"> *</span>
<span class="cm"> * After execution:</span>
<span class="cm"> * osd_req_decode_sense</span>
<span class="cm"> *	Decodes sense information to verify execution results.</span>
<span class="cm"> *</span>
<span class="cm"> * osd_req_decode_get_attr</span>
<span class="cm"> *	Retrieve osd_add_get_attr_list() values if used.</span>
<span class="cm"> *</span>
<span class="cm"> * osd_end_request</span>
<span class="cm"> *	Must be called to deallocate the request.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * osd_start_request - Allocate and initialize an osd_request</span>
<span class="cm"> *</span>
<span class="cm"> * @osd_dev:    OSD device that holds the scsi-device and default values</span>
<span class="cm"> *              that the request is associated with.</span>
<span class="cm"> * @gfp:        The allocation flags to use for request allocation, and all</span>
<span class="cm"> *              subsequent allocations. This will be stored at</span>
<span class="cm"> *              osd_request-&gt;alloc_flags, can be changed by user later</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate osd_request and initialize all members to the</span>
<span class="cm"> * default/initial state.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">osd_start_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_dev</span> <span class="o">*</span><span class="n">od</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">osd_req_options</span> <span class="p">{</span>
	<span class="n">OSD_REQ_FUA</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>	<span class="cm">/* Force Unit Access */</span>
	<span class="n">OSD_REQ_DPO</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>	<span class="cm">/* Disable Page Out */</span>

	<span class="n">OSD_REQ_BYPASS_TIMESTAMPS</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * osd_finalize_request - Sign request and prepare request for execution</span>
<span class="cm"> *</span>
<span class="cm"> * @or:		osd_request to prepare</span>
<span class="cm"> * @options:	combination of osd_req_options bit flags or 0.</span>
<span class="cm"> * @cap:	A Pointer to an OSD_CAP_LEN bytes buffer that is received from</span>
<span class="cm"> *              The security manager as capabilities for this cdb.</span>
<span class="cm"> * @cap_key:	The cryptographic key used to sign the cdb/data. Can be null</span>
<span class="cm"> *              if NOSEC is used.</span>
<span class="cm"> *</span>
<span class="cm"> * The actual request and bios are only allocated here, so are the get_attr</span>
<span class="cm"> * buffers that will receive the returned attributes. Copy&#39;s @cap to cdb.</span>
<span class="cm"> * Sign the cdb/data with @cap_key.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">osd_finalize_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">options</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cap</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">cap_key</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * osd_execute_request - Execute the request synchronously through block-layer</span>
<span class="cm"> *</span>
<span class="cm"> * @or:		osd_request to Executed</span>
<span class="cm"> *</span>
<span class="cm"> * Calls blk_execute_rq to q the command and waits for completion.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">osd_execute_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * osd_execute_request_async - Execute the request without waitting.</span>
<span class="cm"> *</span>
<span class="cm"> * @or:                      - osd_request to Executed</span>
<span class="cm"> * @done: (Optional)         - Called at end of execution</span>
<span class="cm"> * @private:                 - Will be passed to @done function</span>
<span class="cm"> *</span>
<span class="cm"> * Calls blk_execute_rq_nowait to queue the command. When execution is done</span>
<span class="cm"> * optionally calls @done with @private as parameter. @or-&gt;async_error will</span>
<span class="cm"> * have the return code</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">osd_execute_request_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="n">osd_req_done_fn</span> <span class="o">*</span><span class="n">done</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * osd_req_decode_sense_full - Decode sense information after execution.</span>
<span class="cm"> *</span>
<span class="cm"> * @or:           - osd_request to examine</span>
<span class="cm"> * @osi           - Receives a more detailed error report information (optional).</span>
<span class="cm"> * @silent        - Do not print to dmsg (Even if enabled)</span>
<span class="cm"> * @bad_obj_list  - Some commands act on multiple objects. Failed objects will</span>
<span class="cm"> *                  be received here (optional)</span>
<span class="cm"> * @max_obj       - Size of @bad_obj_list.</span>
<span class="cm"> * @bad_attr_list - List of failing attributes (optional)</span>
<span class="cm"> * @max_attr      - Size of @bad_attr_list.</span>
<span class="cm"> *</span>
<span class="cm"> * After execution, osd_request results are analyzed using this function. The</span>
<span class="cm"> * return code is the final disposition on the error. So it is possible that a</span>
<span class="cm"> * CHECK_CONDITION was returned from target but this will return NO_ERROR, for</span>
<span class="cm"> * example on recovered errors. All parameters are optional if caller does</span>
<span class="cm"> * not need any returned information.</span>
<span class="cm"> * Note: This function will also dump the error to dmsg according to settings</span>
<span class="cm"> * of the SCSI_OSD_DPRINT_SENSE Kconfig value. Set @silent if you know the</span>
<span class="cm"> * command would routinely fail, to not spam the dmsg file.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * osd_err_priority - osd categorized return codes in ascending severity.</span>
<span class="cm"> *</span>
<span class="cm"> * The categories are borrowed from the pnfs_osd_errno enum.</span>
<span class="cm"> * See comments for translated Linux codes returned by osd_req_decode_sense.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">osd_err_priority</span> <span class="p">{</span>
	<span class="n">OSD_ERR_PRI_NO_ERROR</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="cm">/* Recoverable, caller should clear_highpage() all pages */</span>
	<span class="n">OSD_ERR_PRI_CLEAR_PAGES</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/* -EFAULT */</span>
	<span class="n">OSD_ERR_PRI_RESOURCE</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="cm">/* -ENOMEM */</span>
	<span class="n">OSD_ERR_PRI_BAD_CRED</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="cm">/* -EINVAL */</span>
	<span class="n">OSD_ERR_PRI_NO_ACCESS</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="cm">/* -EACCES */</span>
	<span class="n">OSD_ERR_PRI_UNREACHABLE</span>	<span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="cm">/* any other */</span>
	<span class="n">OSD_ERR_PRI_NOT_FOUND</span>	<span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="cm">/* -ENOENT */</span>
	<span class="n">OSD_ERR_PRI_NO_SPACE</span>	<span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="cm">/* -ENOSPC */</span>
	<span class="n">OSD_ERR_PRI_EIO</span>		<span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="cm">/* -EIO    */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">osd_sense_info</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">osd_err_priority</span> <span class="n">osd_err_pri</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">key</span><span class="p">;</span>		<span class="cm">/* one of enum scsi_sense_keys */</span>
	<span class="kt">int</span> <span class="n">additional_code</span> <span class="p">;</span>	<span class="cm">/* enum osd_additional_sense_codes */</span>
	<span class="k">union</span> <span class="p">{</span> <span class="cm">/* Sense specific information */</span>
		<span class="n">u16</span> <span class="n">sense_info</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">cdb_field_offset</span><span class="p">;</span> 	<span class="cm">/* scsi_invalid_field_in_cdb */</span>
	<span class="p">};</span>
	<span class="k">union</span> <span class="p">{</span> <span class="cm">/* Command specific information */</span>
		<span class="n">u64</span> <span class="n">command_info</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="n">u32</span> <span class="n">not_initiated_command_functions</span><span class="p">;</span> <span class="cm">/* osd_command_functions_bits */</span>
	<span class="n">u32</span> <span class="n">completed_command_functions</span><span class="p">;</span> <span class="cm">/* osd_command_functions_bits */</span>
	<span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="n">obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">osd_attr</span> <span class="n">attr</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">osd_req_decode_sense_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">osd_sense_info</span> <span class="o">*</span><span class="n">osi</span><span class="p">,</span> <span class="n">bool</span> <span class="n">silent</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="n">bad_obj_list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_obj</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">osd_attr</span> <span class="o">*</span><span class="n">bad_attr_list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_attr</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">osd_req_decode_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">osd_sense_info</span> <span class="o">*</span><span class="n">osi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">osd_req_decode_sense_full</span><span class="p">(</span><span class="n">or</span><span class="p">,</span> <span class="n">osi</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * osd_end_request - return osd_request to free store</span>
<span class="cm"> *</span>
<span class="cm"> * @or:		osd_request to free</span>
<span class="cm"> *</span>
<span class="cm"> * Deallocate all osd_request resources (struct req&#39;s, BIOs, buffers, etc.)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">osd_end_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * CDB Encoding</span>
<span class="cm"> *</span>
<span class="cm"> * Note: call only one of the following methods.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Device commands</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">osd_req_set_master_seed_xchg</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span> <span class="p">...);</span><span class="cm">/* NI */</span>
<span class="kt">void</span> <span class="n">osd_req_set_master_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span> <span class="p">...);</span><span class="cm">/* NI */</span>

<span class="kt">void</span> <span class="n">osd_req_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span> <span class="n">u64</span> <span class="n">tot_capacity</span><span class="p">);</span>

<span class="cm">/* list all partitions</span>
<span class="cm"> * @list header must be initialized to zero on first run.</span>
<span class="cm"> *</span>
<span class="cm"> * Call osd_is_obj_list_done() to find if we got the complete list.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">osd_req_list_dev_partitions</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="n">osd_id</span> <span class="n">initial_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">osd_obj_id_list</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nelem</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">osd_req_flush_obsd</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">osd_options_flush_scope_values</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">osd_req_perform_scsi_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">cdb</span><span class="p">,</span> <span class="p">...);</span><span class="cm">/* NI */</span>
<span class="kt">void</span> <span class="n">osd_req_task_management</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span> <span class="p">...);</span><span class="cm">/* NI */</span>

<span class="cm">/*</span>
<span class="cm"> * Partition commands</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">osd_req_create_partition</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span> <span class="n">osd_id</span> <span class="n">partition</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">osd_req_remove_partition</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span> <span class="n">osd_id</span> <span class="n">partition</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">osd_req_set_partition_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="n">osd_id</span> <span class="n">partition</span><span class="p">,</span> <span class="n">u8</span> <span class="n">new_key_id</span><span class="p">[</span><span class="n">OSD_CRYPTO_KEYID_SIZE</span><span class="p">],</span>
	<span class="n">u8</span> <span class="n">seed</span><span class="p">[</span><span class="n">OSD_CRYPTO_SEED_SIZE</span><span class="p">]);</span><span class="cm">/* NI */</span>

<span class="cm">/* list all collections in the partition</span>
<span class="cm"> * @list header must be init to zero on first run.</span>
<span class="cm"> *</span>
<span class="cm"> * Call osd_is_obj_list_done() to find if we got the complete list.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">osd_req_list_partition_collections</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="n">osd_id</span> <span class="n">partition</span><span class="p">,</span> <span class="n">osd_id</span> <span class="n">initial_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">osd_obj_id_list</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="n">nelem</span><span class="p">);</span>

<span class="cm">/* list all objects in the partition</span>
<span class="cm"> * @list header must be init to zero on first run.</span>
<span class="cm"> *</span>
<span class="cm"> * Call osd_is_obj_list_done() to find if we got the complete list.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">osd_req_list_partition_objects</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="n">osd_id</span> <span class="n">partition</span><span class="p">,</span> <span class="n">osd_id</span> <span class="n">initial_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">osd_obj_id_list</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="n">nelem</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">osd_req_flush_partition</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="n">osd_id</span> <span class="n">partition</span><span class="p">,</span> <span class="k">enum</span> <span class="n">osd_options_flush_scope_values</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Collection commands</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">osd_req_create_collection</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="p">);</span><span class="cm">/* NI */</span>
<span class="kt">void</span> <span class="n">osd_req_remove_collection</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="p">);</span><span class="cm">/* NI */</span>

<span class="cm">/* list all objects in the collection */</span>
<span class="kt">int</span> <span class="n">osd_req_list_collection_objects</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="p">,</span> <span class="n">osd_id</span> <span class="n">initial_id</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">osd_obj_id_list</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nelem</span><span class="p">);</span>

<span class="cm">/* V2 only filtered list of objects in the collection */</span>
<span class="kt">void</span> <span class="n">osd_req_query</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span> <span class="p">...);</span><span class="cm">/* NI */</span>

<span class="kt">void</span> <span class="n">osd_req_flush_collection</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">osd_options_flush_scope_values</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">osd_req_get_member_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span> <span class="p">...);</span><span class="cm">/* V2-only NI */</span>
<span class="kt">void</span> <span class="n">osd_req_set_member_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span> <span class="p">...);</span><span class="cm">/* V2-only NI */</span>

<span class="cm">/*</span>
<span class="cm"> * Object commands</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">osd_req_create_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">osd_req_remove_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">osd_req_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">osd_req_write_kern</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">osd_req_append</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">data_out</span><span class="p">);</span><span class="cm">/* NI */</span>
<span class="kt">void</span> <span class="n">osd_req_create_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">data_out</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">);</span><span class="cm">/* NI */</span>
<span class="kt">void</span> <span class="n">osd_req_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">);</span><span class="cm">/* NI */</span>
<span class="kt">void</span> <span class="n">osd_req_punch</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">);</span><span class="cm">/* V2-only NI */</span>

<span class="kt">void</span> <span class="n">osd_req_flush_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">osd_options_flush_scope_values</span><span class="p">,</span>
	<span class="cm">/*V2*/</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="cm">/*V2*/</span> <span class="n">u64</span> <span class="n">len</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">osd_req_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">osd_req_read_kern</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* Scatter/Gather write/read commands */</span>
<span class="kt">int</span> <span class="n">osd_req_write_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_sg_entry</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">numentries</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">osd_req_read_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_sg_entry</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">numentries</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">osd_req_write_sg_kern</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">buff</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_sg_entry</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">numentries</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">osd_req_read_sg_kern</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">buff</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_sg_entry</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">numentries</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Root/Partition/Collection/Object Attributes commands</span>
<span class="cm"> */</span>

<span class="cm">/* get before set */</span>
<span class="kt">void</span> <span class="n">osd_req_get_attributes</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* set before get */</span>
<span class="kt">void</span> <span class="n">osd_req_set_attributes</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">osd_obj_id</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Attributes appended to most commands</span>
<span class="cm"> */</span>

<span class="cm">/* Attributes List mode (or V2 CDB) */</span>
  <span class="cm">/*</span>
<span class="cm">   * TODO: In ver2 if at finalize time only one attr was set and no gets,</span>
<span class="cm">   * then the Attributes CDB mode is used automatically to save IO.</span>
<span class="cm">   */</span>

<span class="cm">/* set a list of attributes. */</span>
<span class="kt">int</span> <span class="n">osd_req_add_set_attr_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_attr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nelem</span><span class="p">);</span>

<span class="cm">/* get a list of attributes */</span>
<span class="kt">int</span> <span class="n">osd_req_add_get_attr_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_attr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nelem</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Attributes list decoding</span>
<span class="cm"> * Must be called after osd_request.request was executed</span>
<span class="cm"> * It is called in a loop to decode the returned get_attr</span>
<span class="cm"> * (see osd_add_get_attr)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">osd_req_decode_get_attr_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">osd_attr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nelem</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">iterator</span><span class="p">);</span>

<span class="cm">/* Attributes Page mode */</span>

<span class="cm">/*</span>
<span class="cm"> * Read an attribute page and optionally set one attribute</span>
<span class="cm"> *</span>
<span class="cm"> * Retrieves the attribute page directly to a user buffer.</span>
<span class="cm"> * @attr_page_data shall stay valid until end of execution.</span>
<span class="cm"> * See osd_attributes.h for common page structures</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">osd_req_add_get_attr_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">osd_request</span> <span class="o">*</span><span class="n">or</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">page_id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">attr_page_data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">max_page_len</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">osd_attr</span> <span class="o">*</span><span class="n">set_one</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __OSD_LIB_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
