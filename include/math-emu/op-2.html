<!DOCTYPE html>
<html><head><title>joekychen/linux » include › math-emu › op-2.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>op-2.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Software floating-point emulation.</span>
<span class="cm">   Basic two-word fraction declaration and manipulation.</span>
<span class="cm">   Copyright (C) 1997,1998,1999 Free Software Foundation, Inc.</span>
<span class="cm">   This file is part of the GNU C Library.</span>
<span class="cm">   Contributed by Richard Henderson (rth@cygnus.com),</span>
<span class="cm">		  Jakub Jelinek (jj@ultra.linux.cz),</span>
<span class="cm">		  David S. Miller (davem@redhat.com) and</span>
<span class="cm">		  Peter Maydell (pmaydell@chiark.greenend.org.uk).</span>

<span class="cm">   The GNU C Library is free software; you can redistribute it and/or</span>
<span class="cm">   modify it under the terms of the GNU Library General Public License as</span>
<span class="cm">   published by the Free Software Foundation; either version 2 of the</span>
<span class="cm">   License, or (at your option) any later version.</span>

<span class="cm">   The GNU C Library is distributed in the hope that it will be useful,</span>
<span class="cm">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm">   Library General Public License for more details.</span>

<span class="cm">   You should have received a copy of the GNU Library General Public</span>
<span class="cm">   License along with the GNU C Library; see the file COPYING.LIB.  If</span>
<span class="cm">   not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */</span>

<span class="cp">#ifndef __MATH_EMU_OP_2_H__</span>
<span class="cp">#define __MATH_EMU_OP_2_H__</span>

<span class="cp">#define _FP_FRAC_DECL_2(X)	_FP_W_TYPE X##_f0 = 0, X##_f1 = 0</span>
<span class="cp">#define _FP_FRAC_COPY_2(D,S)	(D##_f0 = S##_f0, D##_f1 = S##_f1)</span>
<span class="cp">#define _FP_FRAC_SET_2(X,I)	__FP_FRAC_SET_2(X, I)</span>
<span class="cp">#define _FP_FRAC_HIGH_2(X)	(X##_f1)</span>
<span class="cp">#define _FP_FRAC_LOW_2(X)	(X##_f0)</span>
<span class="cp">#define _FP_FRAC_WORD_2(X,w)	(X##_f##w)</span>

<span class="cp">#define _FP_FRAC_SLL_2(X,N)						\</span>
<span class="cp">  do {									\</span>
<span class="cp">    if ((N) &lt; _FP_W_TYPE_SIZE)						\</span>
<span class="cp">      {									\</span>
<span class="cp">	if (__builtin_constant_p(N) &amp;&amp; (N) == 1) 			\</span>
<span class="cp">	  {								\</span>
<span class="cp">	    X##_f1 = X##_f1 + X##_f1 + (((_FP_WS_TYPE)(X##_f0)) &lt; 0);	\</span>
<span class="cp">	    X##_f0 += X##_f0;						\</span>
<span class="cp">	  }								\</span>
<span class="cp">	else								\</span>
<span class="cp">	  {								\</span>
<span class="cp">	    X##_f1 = X##_f1 &lt;&lt; (N) | X##_f0 &gt;&gt; (_FP_W_TYPE_SIZE - (N));	\</span>
<span class="cp">	    X##_f0 &lt;&lt;= (N);						\</span>
<span class="cp">	  }								\</span>
<span class="cp">      }									\</span>
<span class="cp">    else								\</span>
<span class="cp">      {									\</span>
<span class="cp">	X##_f1 = X##_f0 &lt;&lt; ((N) - _FP_W_TYPE_SIZE);			\</span>
<span class="cp">	X##_f0 = 0;							\</span>
<span class="cp">      }									\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_FRAC_SRL_2(X,N)						\</span>
<span class="cp">  do {									\</span>
<span class="cp">    if ((N) &lt; _FP_W_TYPE_SIZE)						\</span>
<span class="cp">      {									\</span>
<span class="cp">	X##_f0 = X##_f0 &gt;&gt; (N) | X##_f1 &lt;&lt; (_FP_W_TYPE_SIZE - (N));	\</span>
<span class="cp">	X##_f1 &gt;&gt;= (N);							\</span>
<span class="cp">      }									\</span>
<span class="cp">    else								\</span>
<span class="cp">      {									\</span>
<span class="cp">	X##_f0 = X##_f1 &gt;&gt; ((N) - _FP_W_TYPE_SIZE);			\</span>
<span class="cp">	X##_f1 = 0;							\</span>
<span class="cp">      }									\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/* Right shift with sticky-lsb.  */</span>
<span class="cp">#define _FP_FRAC_SRS_2(X,N,sz)						\</span>
<span class="cp">  do {									\</span>
<span class="cp">    if ((N) &lt; _FP_W_TYPE_SIZE)						\</span>
<span class="cp">      {									\</span>
<span class="cp">	X##_f0 = (X##_f1 &lt;&lt; (_FP_W_TYPE_SIZE - (N)) | X##_f0 &gt;&gt; (N) |	\</span>
<span class="cp">		  (__builtin_constant_p(N) &amp;&amp; (N) == 1			\</span>
<span class="cp">		   ? X##_f0 &amp; 1						\</span>
<span class="cp">		   : (X##_f0 &lt;&lt; (_FP_W_TYPE_SIZE - (N))) != 0));	\</span>
<span class="cp">	X##_f1 &gt;&gt;= (N);							\</span>
<span class="cp">      }									\</span>
<span class="cp">    else								\</span>
<span class="cp">      {									\</span>
<span class="cp">	X##_f0 = (X##_f1 &gt;&gt; ((N) - _FP_W_TYPE_SIZE) |			\</span>
<span class="cp">		(((X##_f1 &lt;&lt; (2*_FP_W_TYPE_SIZE - (N))) | X##_f0) != 0)); \</span>
<span class="cp">	X##_f1 = 0;							\</span>
<span class="cp">      }									\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_FRAC_ADDI_2(X,I)	\</span>
<span class="cp">  __FP_FRAC_ADDI_2(X##_f1, X##_f0, I)</span>

<span class="cp">#define _FP_FRAC_ADD_2(R,X,Y)	\</span>
<span class="cp">  __FP_FRAC_ADD_2(R##_f1, R##_f0, X##_f1, X##_f0, Y##_f1, Y##_f0)</span>

<span class="cp">#define _FP_FRAC_SUB_2(R,X,Y)	\</span>
<span class="cp">  __FP_FRAC_SUB_2(R##_f1, R##_f0, X##_f1, X##_f0, Y##_f1, Y##_f0)</span>

<span class="cp">#define _FP_FRAC_DEC_2(X,Y)	\</span>
<span class="cp">  __FP_FRAC_DEC_2(X##_f1, X##_f0, Y##_f1, Y##_f0)</span>

<span class="cp">#define _FP_FRAC_CLZ_2(R,X)	\</span>
<span class="cp">  do {				\</span>
<span class="cp">    if (X##_f1)			\</span>
<span class="cp">      __FP_CLZ(R,X##_f1);	\</span>
<span class="cp">    else 			\</span>
<span class="cp">    {				\</span>
<span class="cp">      __FP_CLZ(R,X##_f0);	\</span>
<span class="cp">      R += _FP_W_TYPE_SIZE;	\</span>
<span class="cp">    }				\</span>
<span class="cp">  } while(0)</span>

<span class="cm">/* Predicates */</span>
<span class="cp">#define _FP_FRAC_NEGP_2(X)	((_FP_WS_TYPE)X##_f1 &lt; 0)</span>
<span class="cp">#define _FP_FRAC_ZEROP_2(X)	((X##_f1 | X##_f0) == 0)</span>
<span class="cp">#define _FP_FRAC_OVERP_2(fs,X)	(_FP_FRAC_HIGH_##fs(X) &amp; _FP_OVERFLOW_##fs)</span>
<span class="cp">#define _FP_FRAC_CLEAR_OVERP_2(fs,X)	(_FP_FRAC_HIGH_##fs(X) &amp;= ~_FP_OVERFLOW_##fs)</span>
<span class="cp">#define _FP_FRAC_EQ_2(X, Y)	(X##_f1 == Y##_f1 &amp;&amp; X##_f0 == Y##_f0)</span>
<span class="cp">#define _FP_FRAC_GT_2(X, Y)	\</span>
<span class="cp">  (X##_f1 &gt; Y##_f1 || (X##_f1 == Y##_f1 &amp;&amp; X##_f0 &gt; Y##_f0))</span>
<span class="cp">#define _FP_FRAC_GE_2(X, Y)	\</span>
<span class="cp">  (X##_f1 &gt; Y##_f1 || (X##_f1 == Y##_f1 &amp;&amp; X##_f0 &gt;= Y##_f0))</span>

<span class="cp">#define _FP_ZEROFRAC_2		0, 0</span>
<span class="cp">#define _FP_MINFRAC_2		0, 1</span>
<span class="cp">#define _FP_MAXFRAC_2		(~(_FP_WS_TYPE)0), (~(_FP_WS_TYPE)0)</span>

<span class="cm">/*</span>
<span class="cm"> * Internals </span>
<span class="cm"> */</span>

<span class="cp">#define __FP_FRAC_SET_2(X,I1,I0)	(X##_f0 = I0, X##_f1 = I1)</span>

<span class="cp">#define __FP_CLZ_2(R, xh, xl)	\</span>
<span class="cp">  do {				\</span>
<span class="cp">    if (xh)			\</span>
<span class="cp">      __FP_CLZ(R,xh);		\</span>
<span class="cp">    else 			\</span>
<span class="cp">    {				\</span>
<span class="cp">      __FP_CLZ(R,xl);		\</span>
<span class="cp">      R += _FP_W_TYPE_SIZE;	\</span>
<span class="cp">    }				\</span>
<span class="cp">  } while(0)</span>

<span class="cp">#if 0</span><span class="c"></span>

<span class="cp">#ifndef __FP_FRAC_ADDI_2</span>
<span class="c">#define __FP_FRAC_ADDI_2(xh, xl, i)	\</span>
<span class="c">  (xh += ((xl += i) &lt; i))</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef __FP_FRAC_ADD_2</span>
<span class="c">#define __FP_FRAC_ADD_2(rh, rl, xh, xl, yh, yl)	\</span>
<span class="c">  (rh = xh + yh + ((rl = xl + yl) &lt; xl))</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef __FP_FRAC_SUB_2</span>
<span class="c">#define __FP_FRAC_SUB_2(rh, rl, xh, xl, yh, yl)	\</span>
<span class="c">  (rh = xh - yh - ((rl = xl - yl) &gt; xl))</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef __FP_FRAC_DEC_2</span>
<span class="c">#define __FP_FRAC_DEC_2(xh, xl, yh, yl)	\</span>
<span class="c">  do {					\</span>
<span class="c">    UWtype _t = xl;			\</span>
<span class="c">    xh -= yh + ((xl -= yl) &gt; _t);	\</span>
<span class="c">  } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#else</span>

<span class="cp">#undef __FP_FRAC_ADDI_2</span>
<span class="cp">#define __FP_FRAC_ADDI_2(xh, xl, i)	add_ssaaaa(xh, xl, xh, xl, 0, i)</span>
<span class="cp">#undef __FP_FRAC_ADD_2</span>
<span class="cp">#define __FP_FRAC_ADD_2			add_ssaaaa</span>
<span class="cp">#undef __FP_FRAC_SUB_2</span>
<span class="cp">#define __FP_FRAC_SUB_2			sub_ddmmss</span>
<span class="cp">#undef __FP_FRAC_DEC_2</span>
<span class="cp">#define __FP_FRAC_DEC_2(xh, xl, yh, yl)	sub_ddmmss(xh, xl, xh, xl, yh, yl)</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Unpack the raw bits of a native fp value.  Do not classify or</span>
<span class="cm"> * normalize the data.</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_UNPACK_RAW_2(fs, X, val)			\</span>
<span class="cp">  do {							\</span>
<span class="cp">    union _FP_UNION_##fs _flo; _flo.flt = (val);	\</span>
<span class="cp">							\</span>
<span class="cp">    X##_f0 = _flo.bits.frac0;				\</span>
<span class="cp">    X##_f1 = _flo.bits.frac1;				\</span>
<span class="cp">    X##_e  = _flo.bits.exp;				\</span>
<span class="cp">    X##_s  = _flo.bits.sign;				\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_UNPACK_RAW_2_P(fs, X, val)			\</span>
<span class="cp">  do {							\</span>
<span class="cp">    union _FP_UNION_##fs *_flo =			\</span>
<span class="cp">      (union _FP_UNION_##fs *)(val);			\</span>
<span class="cp">							\</span>
<span class="cp">    X##_f0 = _flo-&gt;bits.frac0;				\</span>
<span class="cp">    X##_f1 = _flo-&gt;bits.frac1;				\</span>
<span class="cp">    X##_e  = _flo-&gt;bits.exp;				\</span>
<span class="cp">    X##_s  = _flo-&gt;bits.sign;				\</span>
<span class="cp">  } while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * Repack the raw bits of a native fp value.</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_PACK_RAW_2(fs, val, X)			\</span>
<span class="cp">  do {							\</span>
<span class="cp">    union _FP_UNION_##fs _flo;				\</span>
<span class="cp">							\</span>
<span class="cp">    _flo.bits.frac0 = X##_f0;				\</span>
<span class="cp">    _flo.bits.frac1 = X##_f1;				\</span>
<span class="cp">    _flo.bits.exp   = X##_e;				\</span>
<span class="cp">    _flo.bits.sign  = X##_s;				\</span>
<span class="cp">							\</span>
<span class="cp">    (val) = _flo.flt;					\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_PACK_RAW_2_P(fs, val, X)			\</span>
<span class="cp">  do {							\</span>
<span class="cp">    union _FP_UNION_##fs *_flo =			\</span>
<span class="cp">      (union _FP_UNION_##fs *)(val);			\</span>
<span class="cp">							\</span>
<span class="cp">    _flo-&gt;bits.frac0 = X##_f0;				\</span>
<span class="cp">    _flo-&gt;bits.frac1 = X##_f1;				\</span>
<span class="cp">    _flo-&gt;bits.exp   = X##_e;				\</span>
<span class="cp">    _flo-&gt;bits.sign  = X##_s;				\</span>
<span class="cp">  } while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * Multiplication algorithms:</span>
<span class="cm"> */</span>

<span class="cm">/* Given a 1W * 1W =&gt; 2W primitive, do the extended multiplication.  */</span>

<span class="cp">#define _FP_MUL_MEAT_2_wide(wfracbits, R, X, Y, doit)			\</span>
<span class="cp">  do {									\</span>
<span class="cp">    _FP_FRAC_DECL_4(_z); _FP_FRAC_DECL_2(_b); _FP_FRAC_DECL_2(_c);	\</span>
<span class="cp">									\</span>
<span class="cp">    doit(_FP_FRAC_WORD_4(_z,1), _FP_FRAC_WORD_4(_z,0), X##_f0, Y##_f0);	\</span>
<span class="cp">    doit(_b_f1, _b_f0, X##_f0, Y##_f1);					\</span>
<span class="cp">    doit(_c_f1, _c_f0, X##_f1, Y##_f0);					\</span>
<span class="cp">    doit(_FP_FRAC_WORD_4(_z,3), _FP_FRAC_WORD_4(_z,2), X##_f1, Y##_f1);	\</span>
<span class="cp">									\</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),	\</span>
<span class="cp">		    _FP_FRAC_WORD_4(_z,1), 0, _b_f1, _b_f0,		\</span>
<span class="cp">		    _FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),	\</span>
<span class="cp">		    _FP_FRAC_WORD_4(_z,1));				\</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),	\</span>
<span class="cp">		    _FP_FRAC_WORD_4(_z,1), 0, _c_f1, _c_f0,		\</span>
<span class="cp">		    _FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),	\</span>
<span class="cp">		    _FP_FRAC_WORD_4(_z,1));				\</span>
<span class="cp">									\</span>
<span class="cp">    </span><span class="cm">/* Normalize since we know where the msb of the multiplicands	\</span>
<span class="cm">       were (bit B), we know that the msb of the of the product is	\</span>
<span class="cm">       at either 2B or 2B-1.  */</span><span class="cp">					\</span>
<span class="cp">    _FP_FRAC_SRS_4(_z, wfracbits-1, 2*wfracbits);			\</span>
<span class="cp">    R##_f0 = _FP_FRAC_WORD_4(_z,0);					\</span>
<span class="cp">    R##_f1 = _FP_FRAC_WORD_4(_z,1);					\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/* Given a 1W * 1W =&gt; 2W primitive, do the extended multiplication.</span>
<span class="cm">   Do only 3 multiplications instead of four. This one is for machines</span>
<span class="cm">   where multiplication is much more expensive than subtraction.  */</span>

<span class="cp">#define _FP_MUL_MEAT_2_wide_3mul(wfracbits, R, X, Y, doit)		\</span>
<span class="cp">  do {									\</span>
<span class="cp">    _FP_FRAC_DECL_4(_z); _FP_FRAC_DECL_2(_b); _FP_FRAC_DECL_2(_c);	\</span>
<span class="cp">    _FP_W_TYPE _d;							\</span>
<span class="cp">    int _c1, _c2;							\</span>
<span class="cp">									\</span>
<span class="cp">    _b_f0 = X##_f0 + X##_f1;						\</span>
<span class="cp">    _c1 = _b_f0 &lt; X##_f0;						\</span>
<span class="cp">    _b_f1 = Y##_f0 + Y##_f1;						\</span>
<span class="cp">    _c2 = _b_f1 &lt; Y##_f0;						\</span>
<span class="cp">    doit(_d, _FP_FRAC_WORD_4(_z,0), X##_f0, Y##_f0);			\</span>
<span class="cp">    doit(_FP_FRAC_WORD_4(_z,2), _FP_FRAC_WORD_4(_z,1), _b_f0, _b_f1);	\</span>
<span class="cp">    doit(_c_f1, _c_f0, X##_f1, Y##_f1);					\</span>
<span class="cp">									\</span>
<span class="cp">    _b_f0 &amp;= -_c2;							\</span>
<span class="cp">    _b_f1 &amp;= -_c1;							\</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),	\</span>
<span class="cp">		    _FP_FRAC_WORD_4(_z,1), (_c1 &amp; _c2), 0, _d,		\</span>
<span class="cp">		    0, _FP_FRAC_WORD_4(_z,2), _FP_FRAC_WORD_4(_z,1));	\</span>
<span class="cp">    __FP_FRAC_ADDI_2(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),	\</span>
<span class="cp">		     _b_f0);						\</span>
<span class="cp">    __FP_FRAC_ADDI_2(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),	\</span>
<span class="cp">		     _b_f1);						\</span>
<span class="cp">    __FP_FRAC_DEC_3(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),	\</span>
<span class="cp">		    _FP_FRAC_WORD_4(_z,1),				\</span>
<span class="cp">		    0, _d, _FP_FRAC_WORD_4(_z,0));			\</span>
<span class="cp">    __FP_FRAC_DEC_3(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),	\</span>
<span class="cp">		    _FP_FRAC_WORD_4(_z,1), 0, _c_f1, _c_f0);		\</span>
<span class="cp">    __FP_FRAC_ADD_2(_FP_FRAC_WORD_4(_z,3), _FP_FRAC_WORD_4(_z,2),	\</span>
<span class="cp">		    _c_f1, _c_f0,					\</span>
<span class="cp">		    _FP_FRAC_WORD_4(_z,3), _FP_FRAC_WORD_4(_z,2));	\</span>
<span class="cp">									\</span>
<span class="cp">    </span><span class="cm">/* Normalize since we know where the msb of the multiplicands	\</span>
<span class="cm">       were (bit B), we know that the msb of the of the product is	\</span>
<span class="cm">       at either 2B or 2B-1.  */</span><span class="cp">					\</span>
<span class="cp">    _FP_FRAC_SRS_4(_z, wfracbits-1, 2*wfracbits);			\</span>
<span class="cp">    R##_f0 = _FP_FRAC_WORD_4(_z,0);					\</span>
<span class="cp">    R##_f1 = _FP_FRAC_WORD_4(_z,1);					\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_MUL_MEAT_2_gmp(wfracbits, R, X, Y)				\</span>
<span class="cp">  do {									\</span>
<span class="cp">    _FP_FRAC_DECL_4(_z);						\</span>
<span class="cp">    _FP_W_TYPE _x[2], _y[2];						\</span>
<span class="cp">    _x[0] = X##_f0; _x[1] = X##_f1;					\</span>
<span class="cp">    _y[0] = Y##_f0; _y[1] = Y##_f1;					\</span>
<span class="cp">									\</span>
<span class="cp">    mpn_mul_n(_z_f, _x, _y, 2);						\</span>
<span class="cp">									\</span>
<span class="cp">    </span><span class="cm">/* Normalize since we know where the msb of the multiplicands	\</span>
<span class="cm">       were (bit B), we know that the msb of the of the product is	\</span>
<span class="cm">       at either 2B or 2B-1.  */</span><span class="cp">					\</span>
<span class="cp">    _FP_FRAC_SRS_4(_z, wfracbits-1, 2*wfracbits);			\</span>
<span class="cp">    R##_f0 = _z_f[0];							\</span>
<span class="cp">    R##_f1 = _z_f[1];							\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/* Do at most 120x120=240 bits multiplication using double floating</span>
<span class="cm">   point multiplication.  This is useful if floating point</span>
<span class="cm">   multiplication has much bigger throughput than integer multiply.</span>
<span class="cm">   It is supposed to work for _FP_W_TYPE_SIZE 64 and wfracbits</span>
<span class="cm">   between 106 and 120 only.  </span>
<span class="cm">   Caller guarantees that X and Y has (1LLL &lt;&lt; (wfracbits - 1)) set.</span>
<span class="cm">   SETFETZ is a macro which will disable all FPU exceptions and set rounding</span>
<span class="cm">   towards zero,  RESETFE should optionally reset it back.  */</span>

<span class="cp">#define _FP_MUL_MEAT_2_120_240_double(wfracbits, R, X, Y, setfetz, resetfe)	\</span>
<span class="cp">  do {										\</span>
<span class="cp">    static const double _const[] = {						\</span>
<span class="cp">      </span><span class="cm">/* 2^-24 */</span><span class="cp"> 5.9604644775390625e-08,					\</span>
<span class="cp">      </span><span class="cm">/* 2^-48 */</span><span class="cp"> 3.5527136788005009e-15,					\</span>
<span class="cp">      </span><span class="cm">/* 2^-72 */</span><span class="cp"> 2.1175823681357508e-22,					\</span>
<span class="cp">      </span><span class="cm">/* 2^-96 */</span><span class="cp"> 1.2621774483536189e-29,					\</span>
<span class="cp">      </span><span class="cm">/* 2^28 */</span><span class="cp"> 2.68435456e+08,						\</span>
<span class="cp">      </span><span class="cm">/* 2^4 */</span><span class="cp"> 1.600000e+01,							\</span>
<span class="cp">      </span><span class="cm">/* 2^-20 */</span><span class="cp"> 9.5367431640625e-07,						\</span>
<span class="cp">      </span><span class="cm">/* 2^-44 */</span><span class="cp"> 5.6843418860808015e-14,					\</span>
<span class="cp">      </span><span class="cm">/* 2^-68 */</span><span class="cp"> 3.3881317890172014e-21,					\</span>
<span class="cp">      </span><span class="cm">/* 2^-92 */</span><span class="cp"> 2.0194839173657902e-28,					\</span>
<span class="cp">      </span><span class="cm">/* 2^-116 */</span><span class="cp"> 1.2037062152420224e-35};					\</span>
<span class="cp">    double _a240, _b240, _c240, _d240, _e240, _f240, 				\</span>
<span class="cp">	   _g240, _h240, _i240, _j240, _k240;					\</span>
<span class="cp">    union { double d; UDItype i; } _l240, _m240, _n240, _o240,			\</span>
<span class="cp">				   _p240, _q240, _r240, _s240;			\</span>
<span class="cp">    UDItype _t240, _u240, _v240, _w240, _x240, _y240 = 0;			\</span>
<span class="cp">										\</span>
<span class="cp">    if (wfracbits &lt; 106 || wfracbits &gt; 120)					\</span>
<span class="cp">      abort();									\</span>
<span class="cp">										\</span>
<span class="cp">    setfetz;									\</span>
<span class="cp">										\</span>
<span class="cp">    _e240 = (double)(long)(X##_f0 &amp; 0xffffff);					\</span>
<span class="cp">    _j240 = (double)(long)(Y##_f0 &amp; 0xffffff);					\</span>
<span class="cp">    _d240 = (double)(long)((X##_f0 &gt;&gt; 24) &amp; 0xffffff);				\</span>
<span class="cp">    _i240 = (double)(long)((Y##_f0 &gt;&gt; 24) &amp; 0xffffff);				\</span>
<span class="cp">    _c240 = (double)(long)(((X##_f1 &lt;&lt; 16) &amp; 0xffffff) | (X##_f0 &gt;&gt; 48));	\</span>
<span class="cp">    _h240 = (double)(long)(((Y##_f1 &lt;&lt; 16) &amp; 0xffffff) | (Y##_f0 &gt;&gt; 48));	\</span>
<span class="cp">    _b240 = (double)(long)((X##_f1 &gt;&gt; 8) &amp; 0xffffff);				\</span>
<span class="cp">    _g240 = (double)(long)((Y##_f1 &gt;&gt; 8) &amp; 0xffffff);				\</span>
<span class="cp">    _a240 = (double)(long)(X##_f1 &gt;&gt; 32);					\</span>
<span class="cp">    _f240 = (double)(long)(Y##_f1 &gt;&gt; 32);					\</span>
<span class="cp">    _e240 *= _const[3];								\</span>
<span class="cp">    _j240 *= _const[3];								\</span>
<span class="cp">    _d240 *= _const[2];								\</span>
<span class="cp">    _i240 *= _const[2];								\</span>
<span class="cp">    _c240 *= _const[1];								\</span>
<span class="cp">    _h240 *= _const[1];								\</span>
<span class="cp">    _b240 *= _const[0];								\</span>
<span class="cp">    _g240 *= _const[0];								\</span>
<span class="cp">    _s240.d =							      _e240*_j240;\</span>
<span class="cp">    _r240.d =						_d240*_j240 + _e240*_i240;\</span>
<span class="cp">    _q240.d =				  _c240*_j240 + _d240*_i240 + _e240*_h240;\</span>
<span class="cp">    _p240.d =		    _b240*_j240 + _c240*_i240 + _d240*_h240 + _e240*_g240;\</span>
<span class="cp">    _o240.d = _a240*_j240 + _b240*_i240 + _c240*_h240 + _d240*_g240 + _e240*_f240;\</span>
<span class="cp">    _n240.d = _a240*_i240 + _b240*_h240 + _c240*_g240 + _d240*_f240;		\</span>
<span class="cp">    _m240.d = _a240*_h240 + _b240*_g240 + _c240*_f240;				\</span>
<span class="cp">    _l240.d = _a240*_g240 + _b240*_f240;					\</span>
<span class="cp">    _k240 =   _a240*_f240;							\</span>
<span class="cp">    _r240.d += _s240.d;								\</span>
<span class="cp">    _q240.d += _r240.d;								\</span>
<span class="cp">    _p240.d += _q240.d;								\</span>
<span class="cp">    _o240.d += _p240.d;								\</span>
<span class="cp">    _n240.d += _o240.d;								\</span>
<span class="cp">    _m240.d += _n240.d;								\</span>
<span class="cp">    _l240.d += _m240.d;								\</span>
<span class="cp">    _k240 += _l240.d;								\</span>
<span class="cp">    _s240.d -= ((_const[10]+_s240.d)-_const[10]);				\</span>
<span class="cp">    _r240.d -= ((_const[9]+_r240.d)-_const[9]);					\</span>
<span class="cp">    _q240.d -= ((_const[8]+_q240.d)-_const[8]);					\</span>
<span class="cp">    _p240.d -= ((_const[7]+_p240.d)-_const[7]);					\</span>
<span class="cp">    _o240.d += _const[7];							\</span>
<span class="cp">    _n240.d += _const[6];							\</span>
<span class="cp">    _m240.d += _const[5];							\</span>
<span class="cp">    _l240.d += _const[4];							\</span>
<span class="cp">    if (_s240.d != 0.0) _y240 = 1;						\</span>
<span class="cp">    if (_r240.d != 0.0) _y240 = 1;						\</span>
<span class="cp">    if (_q240.d != 0.0) _y240 = 1;						\</span>
<span class="cp">    if (_p240.d != 0.0) _y240 = 1;						\</span>
<span class="cp">    _t240 = (DItype)_k240;							\</span>
<span class="cp">    _u240 = _l240.i;								\</span>
<span class="cp">    _v240 = _m240.i;								\</span>
<span class="cp">    _w240 = _n240.i;								\</span>
<span class="cp">    _x240 = _o240.i;								\</span>
<span class="cp">    R##_f1 = (_t240 &lt;&lt; (128 - (wfracbits - 1)))					\</span>
<span class="cp">	     | ((_u240 &amp; 0xffffff) &gt;&gt; ((wfracbits - 1) - 104));			\</span>
<span class="cp">    R##_f0 = ((_u240 &amp; 0xffffff) &lt;&lt; (168 - (wfracbits - 1)))			\</span>
<span class="cp">    	     | ((_v240 &amp; 0xffffff) &lt;&lt; (144 - (wfracbits - 1)))			\</span>
<span class="cp">    	     | ((_w240 &amp; 0xffffff) &lt;&lt; (120 - (wfracbits - 1)))			\</span>
<span class="cp">    	     | ((_x240 &amp; 0xffffff) &gt;&gt; ((wfracbits - 1) - 96))			\</span>
<span class="cp">    	     | _y240;								\</span>
<span class="cp">    resetfe;									\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Division algorithms:</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_DIV_MEAT_2_udiv(fs, R, X, Y)				\</span>
<span class="cp">  do {									\</span>
<span class="cp">    _FP_W_TYPE _n_f2, _n_f1, _n_f0, _r_f1, _r_f0, _m_f1, _m_f0;		\</span>
<span class="cp">    if (_FP_FRAC_GT_2(X, Y))						\</span>
<span class="cp">      {									\</span>
<span class="cp">	_n_f2 = X##_f1 &gt;&gt; 1;						\</span>
<span class="cp">	_n_f1 = X##_f1 &lt;&lt; (_FP_W_TYPE_SIZE - 1) | X##_f0 &gt;&gt; 1;		\</span>
<span class="cp">	_n_f0 = X##_f0 &lt;&lt; (_FP_W_TYPE_SIZE - 1);			\</span>
<span class="cp">      }									\</span>
<span class="cp">    else								\</span>
<span class="cp">      {									\</span>
<span class="cp">	R##_e--;							\</span>
<span class="cp">	_n_f2 = X##_f1;							\</span>
<span class="cp">	_n_f1 = X##_f0;							\</span>
<span class="cp">	_n_f0 = 0;							\</span>
<span class="cp">      }									\</span>
<span class="cp">									\</span>
<span class="cp">    </span><span class="cm">/* Normalize, i.e. make the most significant bit of the 		\</span>
<span class="cm">       denominator set. */</span><span class="cp">						\</span>
<span class="cp">    _FP_FRAC_SLL_2(Y, _FP_WFRACXBITS_##fs);				\</span>
<span class="cp">									\</span>
<span class="cp">    udiv_qrnnd(R##_f1, _r_f1, _n_f2, _n_f1, Y##_f1);			\</span>
<span class="cp">    umul_ppmm(_m_f1, _m_f0, R##_f1, Y##_f0);				\</span>
<span class="cp">    _r_f0 = _n_f0;							\</span>
<span class="cp">    if (_FP_FRAC_GT_2(_m, _r))						\</span>
<span class="cp">      {									\</span>
<span class="cp">	R##_f1--;							\</span>
<span class="cp">	_FP_FRAC_ADD_2(_r, Y, _r);					\</span>
<span class="cp">	if (_FP_FRAC_GE_2(_r, Y) &amp;&amp; _FP_FRAC_GT_2(_m, _r))		\</span>
<span class="cp">	  {								\</span>
<span class="cp">	    R##_f1--;							\</span>
<span class="cp">	    _FP_FRAC_ADD_2(_r, Y, _r);					\</span>
<span class="cp">	  }								\</span>
<span class="cp">      }									\</span>
<span class="cp">    _FP_FRAC_DEC_2(_r, _m);						\</span>
<span class="cp">									\</span>
<span class="cp">    if (_r_f1 == Y##_f1)						\</span>
<span class="cp">      {									\</span>
<span class="cp">	</span><span class="cm">/* This is a special case, not an optimization			\</span>
<span class="cm">	   (_r/Y##_f1 would not fit into UWtype).			\</span>
<span class="cm">	   As _r is guaranteed to be &lt; Y,  R##_f0 can be either		\</span>
<span class="cm">	   (UWtype)-1 or (UWtype)-2.  But as we know what kind		\</span>
<span class="cm">	   of bits it is (sticky, guard, round),  we don&#39;t care.	\</span>
<span class="cm">	   We also don&#39;t care what the reminder is,  because the	\</span>
<span class="cm">	   guard bit will be set anyway.  -jj */</span><span class="cp">			\</span>
<span class="cp">	R##_f0 = -1;							\</span>
<span class="cp">      }									\</span>
<span class="cp">    else								\</span>
<span class="cp">      {									\</span>
<span class="cp">	udiv_qrnnd(R##_f0, _r_f1, _r_f1, _r_f0, Y##_f1);		\</span>
<span class="cp">	umul_ppmm(_m_f1, _m_f0, R##_f0, Y##_f0);			\</span>
<span class="cp">	_r_f0 = 0;							\</span>
<span class="cp">	if (_FP_FRAC_GT_2(_m, _r))					\</span>
<span class="cp">	  {								\</span>
<span class="cp">	    R##_f0--;							\</span>
<span class="cp">	    _FP_FRAC_ADD_2(_r, Y, _r);					\</span>
<span class="cp">	    if (_FP_FRAC_GE_2(_r, Y) &amp;&amp; _FP_FRAC_GT_2(_m, _r))		\</span>
<span class="cp">	      {								\</span>
<span class="cp">		R##_f0--;						\</span>
<span class="cp">		_FP_FRAC_ADD_2(_r, Y, _r);				\</span>
<span class="cp">	      }								\</span>
<span class="cp">	  }								\</span>
<span class="cp">	if (!_FP_FRAC_EQ_2(_r, _m))					\</span>
<span class="cp">	  R##_f0 |= _FP_WORK_STICKY;					\</span>
<span class="cp">      }									\</span>
<span class="cp">  } while (0)</span>


<span class="cp">#define _FP_DIV_MEAT_2_gmp(fs, R, X, Y)					\</span>
<span class="cp">  do {									\</span>
<span class="cp">    _FP_W_TYPE _x[4], _y[2], _z[4];					\</span>
<span class="cp">    _y[0] = Y##_f0; _y[1] = Y##_f1;					\</span>
<span class="cp">    _x[0] = _x[3] = 0;							\</span>
<span class="cp">    if (_FP_FRAC_GT_2(X, Y))						\</span>
<span class="cp">      {									\</span>
<span class="cp">	R##_e++;							\</span>
<span class="cp">	_x[1] = (X##_f0 &lt;&lt; (_FP_WFRACBITS_##fs-1 - _FP_W_TYPE_SIZE) |	\</span>
<span class="cp">		 X##_f1 &gt;&gt; (_FP_W_TYPE_SIZE -				\</span>
<span class="cp">			    (_FP_WFRACBITS_##fs-1 - _FP_W_TYPE_SIZE)));	\</span>
<span class="cp">	_x[2] = X##_f1 &lt;&lt; (_FP_WFRACBITS_##fs-1 - _FP_W_TYPE_SIZE);	\</span>
<span class="cp">      }									\</span>
<span class="cp">    else								\</span>
<span class="cp">      {									\</span>
<span class="cp">	_x[1] = (X##_f0 &lt;&lt; (_FP_WFRACBITS_##fs - _FP_W_TYPE_SIZE) |	\</span>
<span class="cp">		 X##_f1 &gt;&gt; (_FP_W_TYPE_SIZE -				\</span>
<span class="cp">			    (_FP_WFRACBITS_##fs - _FP_W_TYPE_SIZE)));	\</span>
<span class="cp">	_x[2] = X##_f1 &lt;&lt; (_FP_WFRACBITS_##fs - _FP_W_TYPE_SIZE);	\</span>
<span class="cp">      }									\</span>
<span class="cp">									\</span>
<span class="cp">    (void) mpn_divrem (_z, 0, _x, 4, _y, 2);				\</span>
<span class="cp">    R##_f1 = _z[1];							\</span>
<span class="cp">    R##_f0 = _z[0] | ((_x[0] | _x[1]) != 0);				\</span>
<span class="cp">  } while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * Square root algorithms:</span>
<span class="cm"> * We have just one right now, maybe Newton approximation</span>
<span class="cm"> * should be added for those machines where division is fast.</span>
<span class="cm"> */</span>
 
<span class="cp">#define _FP_SQRT_MEAT_2(R, S, T, X, q)			\</span>
<span class="cp">  do {							\</span>
<span class="cp">    while (q)						\</span>
<span class="cp">      {							\</span>
<span class="cp">	T##_f1 = S##_f1 + q;				\</span>
<span class="cp">	if (T##_f1 &lt;= X##_f1)				\</span>
<span class="cp">	  {						\</span>
<span class="cp">	    S##_f1 = T##_f1 + q;			\</span>
<span class="cp">	    X##_f1 -= T##_f1;				\</span>
<span class="cp">	    R##_f1 += q;				\</span>
<span class="cp">	  }						\</span>
<span class="cp">	_FP_FRAC_SLL_2(X, 1);				\</span>
<span class="cp">	q &gt;&gt;= 1;					\</span>
<span class="cp">      }							\</span>
<span class="cp">    q = (_FP_W_TYPE)1 &lt;&lt; (_FP_W_TYPE_SIZE - 1);		\</span>
<span class="cp">    while (q != _FP_WORK_ROUND)				\</span>
<span class="cp">      {							\</span>
<span class="cp">	T##_f0 = S##_f0 + q;				\</span>
<span class="cp">	T##_f1 = S##_f1;				\</span>
<span class="cp">	if (T##_f1 &lt; X##_f1 || 				\</span>
<span class="cp">	    (T##_f1 == X##_f1 &amp;&amp; T##_f0 &lt;= X##_f0))	\</span>
<span class="cp">	  {						\</span>
<span class="cp">	    S##_f0 = T##_f0 + q;			\</span>
<span class="cp">	    S##_f1 += (T##_f0 &gt; S##_f0);		\</span>
<span class="cp">	    _FP_FRAC_DEC_2(X, T);			\</span>
<span class="cp">	    R##_f0 += q;				\</span>
<span class="cp">	  }						\</span>
<span class="cp">	_FP_FRAC_SLL_2(X, 1);				\</span>
<span class="cp">	q &gt;&gt;= 1;					\</span>
<span class="cp">      }							\</span>
<span class="cp">    if (X##_f0 | X##_f1)				\</span>
<span class="cp">      {							\</span>
<span class="cp">	if (S##_f1 &lt; X##_f1 || 				\</span>
<span class="cp">	    (S##_f1 == X##_f1 &amp;&amp; S##_f0 &lt; X##_f0))	\</span>
<span class="cp">	  R##_f0 |= _FP_WORK_ROUND;			\</span>
<span class="cp">	R##_f0 |= _FP_WORK_STICKY;			\</span>
<span class="cp">      }							\</span>
<span class="cp">  } while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * Assembly/disassembly for converting to/from integral types.  </span>
<span class="cm"> * No shifting or overflow handled here.</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_FRAC_ASSEMBLE_2(r, X, rsize)	\</span>
<span class="cp">  do {						\</span>
<span class="cp">    if (rsize &lt;= _FP_W_TYPE_SIZE)		\</span>
<span class="cp">      r = X##_f0;				\</span>
<span class="cp">    else					\</span>
<span class="cp">      {						\</span>
<span class="cp">	r = X##_f1;				\</span>
<span class="cp">	r &lt;&lt;= _FP_W_TYPE_SIZE;			\</span>
<span class="cp">	r += X##_f0;				\</span>
<span class="cp">      }						\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_FRAC_DISASSEMBLE_2(X, r, rsize)				\</span>
<span class="cp">  do {									\</span>
<span class="cp">    X##_f0 = r;								\</span>
<span class="cp">    X##_f1 = (rsize &lt;= _FP_W_TYPE_SIZE ? 0 : r &gt;&gt; _FP_W_TYPE_SIZE);	\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Convert FP values between word sizes</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_FRAC_CONV_1_2(dfs, sfs, D, S)				\</span>
<span class="cp">  do {									\</span>
<span class="cp">    if (S##_c != FP_CLS_NAN)						\</span>
<span class="cp">      _FP_FRAC_SRS_2(S, (_FP_WFRACBITS_##sfs - _FP_WFRACBITS_##dfs),	\</span>
<span class="cp">		     _FP_WFRACBITS_##sfs);				\</span>
<span class="cp">    else								\</span>
<span class="cp">      _FP_FRAC_SRL_2(S, (_FP_WFRACBITS_##sfs - _FP_WFRACBITS_##dfs));	\</span>
<span class="cp">    D##_f = S##_f0;							\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_FRAC_CONV_2_1(dfs, sfs, D, S)				\</span>
<span class="cp">  do {									\</span>
<span class="cp">    D##_f0 = S##_f;							\</span>
<span class="cp">    D##_f1 = 0;								\</span>
<span class="cp">    _FP_FRAC_SLL_2(D, (_FP_WFRACBITS_##dfs - _FP_WFRACBITS_##sfs));	\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
