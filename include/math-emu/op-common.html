<!DOCTYPE html>
<html><head><title>joekychen/linux » include › math-emu › op-common.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>op-common.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Software floating-point emulation. Common operations.</span>
<span class="cm">   Copyright (C) 1997,1998,1999 Free Software Foundation, Inc.</span>
<span class="cm">   This file is part of the GNU C Library.</span>
<span class="cm">   Contributed by Richard Henderson (rth@cygnus.com),</span>
<span class="cm">		  Jakub Jelinek (jj@ultra.linux.cz),</span>
<span class="cm">		  David S. Miller (davem@redhat.com) and</span>
<span class="cm">		  Peter Maydell (pmaydell@chiark.greenend.org.uk).</span>

<span class="cm">   The GNU C Library is free software; you can redistribute it and/or</span>
<span class="cm">   modify it under the terms of the GNU Library General Public License as</span>
<span class="cm">   published by the Free Software Foundation; either version 2 of the</span>
<span class="cm">   License, or (at your option) any later version.</span>

<span class="cm">   The GNU C Library is distributed in the hope that it will be useful,</span>
<span class="cm">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm">   Library General Public License for more details.</span>

<span class="cm">   You should have received a copy of the GNU Library General Public</span>
<span class="cm">   License along with the GNU C Library; see the file COPYING.LIB.  If</span>
<span class="cm">   not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */</span>

<span class="cp">#ifndef __MATH_EMU_OP_COMMON_H__</span>
<span class="cp">#define __MATH_EMU_OP_COMMON_H__</span>

<span class="cp">#define _FP_DECL(wc, X)			\</span>
<span class="cp">  _FP_I_TYPE X##_c=0, X##_s=0, X##_e=0;	\</span>
<span class="cp">  _FP_FRAC_DECL_##wc(X)</span>

<span class="cm">/*</span>
<span class="cm"> * Finish truly unpacking a native fp value by classifying the kind</span>
<span class="cm"> * of fp value and normalizing both the exponent and the fraction.</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_UNPACK_CANONICAL(fs, wc, X)					\</span>
<span class="cp">do {									\</span>
<span class="cp">  switch (X##_e)							\</span>
<span class="cp">  {									\</span>
<span class="cp">  default:								\</span>
<span class="cp">    _FP_FRAC_HIGH_RAW_##fs(X) |= _FP_IMPLBIT_##fs;			\</span>
<span class="cp">    _FP_FRAC_SLL_##wc(X, _FP_WORKBITS);					\</span>
<span class="cp">    X##_e -= _FP_EXPBIAS_##fs;						\</span>
<span class="cp">    X##_c = FP_CLS_NORMAL;						\</span>
<span class="cp">    break;								\</span>
<span class="cp">									\</span>
<span class="cp">  case 0:								\</span>
<span class="cp">    if (_FP_FRAC_ZEROP_##wc(X))						\</span>
<span class="cp">      X##_c = FP_CLS_ZERO;						\</span>
<span class="cp">    else								\</span>
<span class="cp">      {									\</span>
<span class="cp">	</span><span class="cm">/* a denormalized number */</span><span class="cp">					\</span>
<span class="cp">	_FP_I_TYPE _shift;						\</span>
<span class="cp">	_FP_FRAC_CLZ_##wc(_shift, X);					\</span>
<span class="cp">	_shift -= _FP_FRACXBITS_##fs;					\</span>
<span class="cp">	_FP_FRAC_SLL_##wc(X, (_shift+_FP_WORKBITS));			\</span>
<span class="cp">	X##_e -= _FP_EXPBIAS_##fs - 1 + _shift;				\</span>
<span class="cp">	X##_c = FP_CLS_NORMAL;						\</span>
<span class="cp">	FP_SET_EXCEPTION(FP_EX_DENORM);					\</span>
<span class="cp">	if (FP_DENORM_ZERO)						\</span>
<span class="cp">	  {								\</span>
<span class="cp">	    FP_SET_EXCEPTION(FP_EX_INEXACT);				\</span>
<span class="cp">	    X##_c = FP_CLS_ZERO;					\</span>
<span class="cp">	  }								\</span>
<span class="cp">      }									\</span>
<span class="cp">    break;								\</span>
<span class="cp">									\</span>
<span class="cp">  case _FP_EXPMAX_##fs:							\</span>
<span class="cp">    if (_FP_FRAC_ZEROP_##wc(X))						\</span>
<span class="cp">      X##_c = FP_CLS_INF;						\</span>
<span class="cp">    else								\</span>
<span class="cp">      {									\</span>
<span class="cp">	X##_c = FP_CLS_NAN;						\</span>
<span class="cp">	</span><span class="cm">/* Check for signaling NaN */</span><span class="cp">					\</span>
<span class="cp">	if (!(_FP_FRAC_HIGH_RAW_##fs(X) &amp; _FP_QNANBIT_##fs))		\</span>
<span class="cp">	  FP_SET_EXCEPTION(FP_EX_INVALID | FP_EX_INVALID_SNAN);		\</span>
<span class="cp">      }									\</span>
<span class="cp">    break;								\</span>
<span class="cp">  }									\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Before packing the bits back into the native fp result, take care</span>
<span class="cm"> * of such mundane things as rounding and overflow.  Also, for some</span>
<span class="cm"> * kinds of fp values, the original parts may not have been fully</span>
<span class="cm"> * extracted -- but that is ok, we can regenerate them now.</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_PACK_CANONICAL(fs, wc, X)				\</span>
<span class="cp">do {								\</span>
<span class="cp">  switch (X##_c)						\</span>
<span class="cp">  {								\</span>
<span class="cp">  case FP_CLS_NORMAL:						\</span>
<span class="cp">    X##_e += _FP_EXPBIAS_##fs;					\</span>
<span class="cp">    if (X##_e &gt; 0)						\</span>
<span class="cp">      {								\</span>
<span class="cp">	_FP_ROUND(wc, X);					\</span>
<span class="cp">	if (_FP_FRAC_OVERP_##wc(fs, X))				\</span>
<span class="cp">	  {							\</span>
<span class="cp">	    _FP_FRAC_CLEAR_OVERP_##wc(fs, X);			\</span>
<span class="cp">	    X##_e++;						\</span>
<span class="cp">	  }							\</span>
<span class="cp">	_FP_FRAC_SRL_##wc(X, _FP_WORKBITS);			\</span>
<span class="cp">	if (X##_e &gt;= _FP_EXPMAX_##fs)				\</span>
<span class="cp">	  {							\</span>
<span class="cp">	    </span><span class="cm">/* overflow */</span><span class="cp">					\</span>
<span class="cp">	    switch (FP_ROUNDMODE)				\</span>
<span class="cp">	      {							\</span>
<span class="cp">	      case FP_RND_NEAREST:				\</span>
<span class="cp">		X##_c = FP_CLS_INF;				\</span>
<span class="cp">		break;						\</span>
<span class="cp">	      case FP_RND_PINF:					\</span>
<span class="cp">		if (!X##_s) X##_c = FP_CLS_INF;			\</span>
<span class="cp">		break;						\</span>
<span class="cp">	      case FP_RND_MINF:					\</span>
<span class="cp">		if (X##_s) X##_c = FP_CLS_INF;			\</span>
<span class="cp">		break;						\</span>
<span class="cp">	      }							\</span>
<span class="cp">	    if (X##_c == FP_CLS_INF)				\</span>
<span class="cp">	      {							\</span>
<span class="cp">		</span><span class="cm">/* Overflow to infinity */</span><span class="cp">			\</span>
<span class="cp">		X##_e = _FP_EXPMAX_##fs;			\</span>
<span class="cp">		_FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);	\</span>
<span class="cp">	      }							\</span>
<span class="cp">	    else						\</span>
<span class="cp">	      {							\</span>
<span class="cp">		</span><span class="cm">/* Overflow to maximum normal */</span><span class="cp">		\</span>
<span class="cp">		X##_e = _FP_EXPMAX_##fs - 1;			\</span>
<span class="cp">		_FP_FRAC_SET_##wc(X, _FP_MAXFRAC_##wc);		\</span>
<span class="cp">	      }							\</span>
<span class="cp">	    FP_SET_EXCEPTION(FP_EX_OVERFLOW);			\</span>
<span class="cp">            FP_SET_EXCEPTION(FP_EX_INEXACT);			\</span>
<span class="cp">	  }							\</span>
<span class="cp">      }								\</span>
<span class="cp">    else							\</span>
<span class="cp">      {								\</span>
<span class="cp">	</span><span class="cm">/* we&#39;ve got a denormalized number */</span><span class="cp">			\</span>
<span class="cp">	X##_e = -X##_e + 1;					\</span>
<span class="cp">	if (X##_e &lt;= _FP_WFRACBITS_##fs)			\</span>
<span class="cp">	  {							\</span>
<span class="cp">	    _FP_FRAC_SRS_##wc(X, X##_e, _FP_WFRACBITS_##fs);	\</span>
<span class="cp">	    if (_FP_FRAC_HIGH_##fs(X)				\</span>
<span class="cp">		&amp; (_FP_OVERFLOW_##fs &gt;&gt; 1))			\</span>
<span class="cp">	      {							\</span>
<span class="cp">	        X##_e = 1;					\</span>
<span class="cp">	        _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);	\</span>
<span class="cp">	      }							\</span>
<span class="cp">	    else						\</span>
<span class="cp">	      {							\</span>
<span class="cp">		_FP_ROUND(wc, X);				\</span>
<span class="cp">		if (_FP_FRAC_HIGH_##fs(X)			\</span>
<span class="cp">		   &amp; (_FP_OVERFLOW_##fs &gt;&gt; 1))			\</span>
<span class="cp">		  {						\</span>
<span class="cp">		    X##_e = 1;					\</span>
<span class="cp">		    _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);	\</span>
<span class="cp">		    FP_SET_EXCEPTION(FP_EX_INEXACT);		\</span>
<span class="cp">		  }						\</span>
<span class="cp">		else						\</span>
<span class="cp">		  {						\</span>
<span class="cp">		    X##_e = 0;					\</span>
<span class="cp">		    _FP_FRAC_SRL_##wc(X, _FP_WORKBITS);		\</span>
<span class="cp">		  }						\</span>
<span class="cp">	      }							\</span>
<span class="cp">	    if ((FP_CUR_EXCEPTIONS &amp; FP_EX_INEXACT) ||		\</span>
<span class="cp">		(FP_TRAPPING_EXCEPTIONS &amp; FP_EX_UNDERFLOW))	\</span>
<span class="cp">		FP_SET_EXCEPTION(FP_EX_UNDERFLOW);		\</span>
<span class="cp">	  }							\</span>
<span class="cp">	else							\</span>
<span class="cp">	  {							\</span>
<span class="cp">	    </span><span class="cm">/* underflow to zero */</span><span class="cp">				\</span>
<span class="cp">	    X##_e = 0;						\</span>
<span class="cp">	    if (!_FP_FRAC_ZEROP_##wc(X))			\</span>
<span class="cp">	      {							\</span>
<span class="cp">	        _FP_FRAC_SET_##wc(X, _FP_MINFRAC_##wc);		\</span>
<span class="cp">	        _FP_ROUND(wc, X);				\</span>
<span class="cp">	        _FP_FRAC_LOW_##wc(X) &gt;&gt;= (_FP_WORKBITS);	\</span>
<span class="cp">	      }							\</span>
<span class="cp">	    FP_SET_EXCEPTION(FP_EX_UNDERFLOW);			\</span>
<span class="cp">	  }							\</span>
<span class="cp">      }								\</span>
<span class="cp">    break;							\</span>
<span class="cp">								\</span>
<span class="cp">  case FP_CLS_ZERO:						\</span>
<span class="cp">    X##_e = 0;							\</span>
<span class="cp">    _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);			\</span>
<span class="cp">    break;							\</span>
<span class="cp">								\</span>
<span class="cp">  case FP_CLS_INF:						\</span>
<span class="cp">    X##_e = _FP_EXPMAX_##fs;					\</span>
<span class="cp">    _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);			\</span>
<span class="cp">    break;							\</span>
<span class="cp">								\</span>
<span class="cp">  case FP_CLS_NAN:						\</span>
<span class="cp">    X##_e = _FP_EXPMAX_##fs;					\</span>
<span class="cp">    if (!_FP_KEEPNANFRACP)					\</span>
<span class="cp">      {								\</span>
<span class="cp">	_FP_FRAC_SET_##wc(X, _FP_NANFRAC_##fs);			\</span>
<span class="cp">	X##_s = _FP_NANSIGN_##fs;				\</span>
<span class="cp">      }								\</span>
<span class="cp">    else							\</span>
<span class="cp">      _FP_FRAC_HIGH_RAW_##fs(X) |= _FP_QNANBIT_##fs;		\</span>
<span class="cp">    break;							\</span>
<span class="cp">  }								\</span>
<span class="cp">} while (0)</span>

<span class="cm">/* This one accepts raw argument and not cooked,  returns</span>
<span class="cm"> * 1 if X is a signaling NaN.</span>
<span class="cm"> */</span>
<span class="cp">#define _FP_ISSIGNAN(fs, wc, X)					\</span>
<span class="cp">({								\</span>
<span class="cp">  int __ret = 0;						\</span>
<span class="cp">  if (X##_e == _FP_EXPMAX_##fs)					\</span>
<span class="cp">    {								\</span>
<span class="cp">      if (!_FP_FRAC_ZEROP_##wc(X)				\</span>
<span class="cp">	  &amp;&amp; !(_FP_FRAC_HIGH_RAW_##fs(X) &amp; _FP_QNANBIT_##fs))	\</span>
<span class="cp">	__ret = 1;						\</span>
<span class="cp">    }								\</span>
<span class="cp">  __ret;							\</span>
<span class="cp">})</span>





<span class="cm">/*</span>
<span class="cm"> * Main addition routine.  The input values should be cooked.</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_ADD_INTERNAL(fs, wc, R, X, Y, OP)				     \</span>
<span class="cp">do {									     \</span>
<span class="cp">  switch (_FP_CLS_COMBINE(X##_c, Y##_c))				     \</span>
<span class="cp">  {									     \</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NORMAL):			     \</span>
<span class="cp">    {									     \</span>
<span class="cp">      </span><span class="cm">/* shift the smaller number so that its exponent matches the larger */</span><span class="cp"> \</span>
<span class="cp">      _FP_I_TYPE diff = X##_e - Y##_e;					     \</span>
<span class="cp">									     \</span>
<span class="cp">      if (diff &lt; 0)							     \</span>
<span class="cp">	{								     \</span>
<span class="cp">	  diff = -diff;							     \</span>
<span class="cp">	  if (diff &lt;= _FP_WFRACBITS_##fs)				     \</span>
<span class="cp">	    _FP_FRAC_SRS_##wc(X, diff, _FP_WFRACBITS_##fs);		     \</span>
<span class="cp">	  else if (!_FP_FRAC_ZEROP_##wc(X))				     \</span>
<span class="cp">	    _FP_FRAC_SET_##wc(X, _FP_MINFRAC_##wc);			     \</span>
<span class="cp">	  R##_e = Y##_e;						     \</span>
<span class="cp">	}								     \</span>
<span class="cp">      else								     \</span>
<span class="cp">	{								     \</span>
<span class="cp">	  if (diff &gt; 0)							     \</span>
<span class="cp">	    {								     \</span>
<span class="cp">	      if (diff &lt;= _FP_WFRACBITS_##fs)				     \</span>
<span class="cp">	        _FP_FRAC_SRS_##wc(Y, diff, _FP_WFRACBITS_##fs);		     \</span>
<span class="cp">	      else if (!_FP_FRAC_ZEROP_##wc(Y))				     \</span>
<span class="cp">	        _FP_FRAC_SET_##wc(Y, _FP_MINFRAC_##wc);			     \</span>
<span class="cp">	    }								     \</span>
<span class="cp">	  R##_e = X##_e;						     \</span>
<span class="cp">	}								     \</span>
<span class="cp">									     \</span>
<span class="cp">      R##_c = FP_CLS_NORMAL;						     \</span>
<span class="cp">									     \</span>
<span class="cp">      if (X##_s == Y##_s)						     \</span>
<span class="cp">	{								     \</span>
<span class="cp">	  R##_s = X##_s;						     \</span>
<span class="cp">	  _FP_FRAC_ADD_##wc(R, X, Y);					     \</span>
<span class="cp">	  if (_FP_FRAC_OVERP_##wc(fs, R))				     \</span>
<span class="cp">	    {								     \</span>
<span class="cp">	      _FP_FRAC_SRS_##wc(R, 1, _FP_WFRACBITS_##fs);		     \</span>
<span class="cp">	      R##_e++;							     \</span>
<span class="cp">	    }								     \</span>
<span class="cp">	}								     \</span>
<span class="cp">      else								     \</span>
<span class="cp">	{								     \</span>
<span class="cp">	  R##_s = X##_s;						     \</span>
<span class="cp">	  _FP_FRAC_SUB_##wc(R, X, Y);					     \</span>
<span class="cp">	  if (_FP_FRAC_ZEROP_##wc(R))					     \</span>
<span class="cp">	    {								     \</span>
<span class="cp">	      </span><span class="cm">/* return an exact zero */</span><span class="cp">				     \</span>
<span class="cp">	      if (FP_ROUNDMODE == FP_RND_MINF)				     \</span>
<span class="cp">		R##_s |= Y##_s;						     \</span>
<span class="cp">	      else							     \</span>
<span class="cp">		R##_s &amp;= Y##_s;						     \</span>
<span class="cp">	      R##_c = FP_CLS_ZERO;					     \</span>
<span class="cp">	    }								     \</span>
<span class="cp">	  else								     \</span>
<span class="cp">	    {								     \</span>
<span class="cp">	      if (_FP_FRAC_NEGP_##wc(R))				     \</span>
<span class="cp">		{							     \</span>
<span class="cp">		  _FP_FRAC_SUB_##wc(R, Y, X);				     \</span>
<span class="cp">		  R##_s = Y##_s;					     \</span>
<span class="cp">		}							     \</span>
<span class="cp">									     \</span>
<span class="cp">	      </span><span class="cm">/* renormalize after subtraction */</span><span class="cp">			     \</span>
<span class="cp">	      _FP_FRAC_CLZ_##wc(diff, R);				     \</span>
<span class="cp">	      diff -= _FP_WFRACXBITS_##fs;				     \</span>
<span class="cp">	      if (diff)							     \</span>
<span class="cp">		{							     \</span>
<span class="cp">		  R##_e -= diff;					     \</span>
<span class="cp">		  _FP_FRAC_SLL_##wc(R, diff);				     \</span>
<span class="cp">		}							     \</span>
<span class="cp">	    }								     \</span>
<span class="cp">	}								     \</span>
<span class="cp">      break;								     \</span>
<span class="cp">    }									     \</span>
<span class="cp">									     \</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NAN):				     \</span>
<span class="cp">    _FP_CHOOSENAN(fs, wc, R, X, Y, OP);					     \</span>
<span class="cp">    break;								     \</span>
<span class="cp">									     \</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_ZERO):			     \</span>
<span class="cp">    R##_e = X##_e;							     \</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NORMAL):			     \</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_INF):				     \</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_ZERO):				     \</span>
<span class="cp">    _FP_FRAC_COPY_##wc(R, X);						     \</span>
<span class="cp">    R##_s = X##_s;							     \</span>
<span class="cp">    R##_c = X##_c;							     \</span>
<span class="cp">    break;								     \</span>
<span class="cp">									     \</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NORMAL):			     \</span>
<span class="cp">    R##_e = Y##_e;							     \</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NAN):			     \</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NAN):				     \</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NAN):				     \</span>
<span class="cp">    _FP_FRAC_COPY_##wc(R, Y);						     \</span>
<span class="cp">    R##_s = Y##_s;							     \</span>
<span class="cp">    R##_c = Y##_c;							     \</span>
<span class="cp">    break;								     \</span>
<span class="cp">									     \</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_INF):				     \</span>
<span class="cp">    if (X##_s != Y##_s)							     \</span>
<span class="cp">      {									     \</span>
<span class="cp">	</span><span class="cm">/* +INF + -INF =&gt; NAN */</span><span class="cp">					     \</span>
<span class="cp">	_FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);				     \</span>
<span class="cp">	R##_s = _FP_NANSIGN_##fs;					     \</span>
<span class="cp">	R##_c = FP_CLS_NAN;						     \</span>
<span class="cp">	FP_SET_EXCEPTION(FP_EX_INVALID | FP_EX_INVALID_ISI);		     \</span>
<span class="cp">	break;								     \</span>
<span class="cp">      }									     \</span>
<span class="cp">    </span><span class="cm">/* FALLTHRU */</span><span class="cp">							     \</span>
<span class="cp">									     \</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NORMAL):			     \</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_ZERO):				     \</span>
<span class="cp">    R##_s = X##_s;							     \</span>
<span class="cp">    R##_c = FP_CLS_INF;							     \</span>
<span class="cp">    break;								     \</span>
<span class="cp">									     \</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_INF):			     \</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_INF):				     \</span>
<span class="cp">    R##_s = Y##_s;							     \</span>
<span class="cp">    R##_c = FP_CLS_INF;							     \</span>
<span class="cp">    break;								     \</span>
<span class="cp">									     \</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_ZERO):			     \</span>
<span class="cp">    </span><span class="cm">/* make sure the sign is correct */</span><span class="cp">					     \</span>
<span class="cp">    if (FP_ROUNDMODE == FP_RND_MINF)					     \</span>
<span class="cp">      R##_s = X##_s | Y##_s;						     \</span>
<span class="cp">    else								     \</span>
<span class="cp">      R##_s = X##_s &amp; Y##_s;						     \</span>
<span class="cp">    R##_c = FP_CLS_ZERO;						     \</span>
<span class="cp">    break;								     \</span>
<span class="cp">									     \</span>
<span class="cp">  default:								     \</span>
<span class="cp">    abort();								     \</span>
<span class="cp">  }									     \</span>
<span class="cp">} while (0)</span>

<span class="cp">#define _FP_ADD(fs, wc, R, X, Y) _FP_ADD_INTERNAL(fs, wc, R, X, Y, &#39;+&#39;)</span>
<span class="cp">#define _FP_SUB(fs, wc, R, X, Y)					     \</span>
<span class="cp">  do {									     \</span>
<span class="cp">    if (Y##_c != FP_CLS_NAN) Y##_s ^= 1;				     \</span>
<span class="cp">    _FP_ADD_INTERNAL(fs, wc, R, X, Y, &#39;-&#39;);				     \</span>
<span class="cp">  } while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * Main negation routine.  FIXME -- when we care about setting exception</span>
<span class="cm"> * bits reliably, this will not do.  We should examine all of the fp classes.</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_NEG(fs, wc, R, X)		\</span>
<span class="cp">  do {					\</span>
<span class="cp">    _FP_FRAC_COPY_##wc(R, X);		\</span>
<span class="cp">    R##_c = X##_c;			\</span>
<span class="cp">    R##_e = X##_e;			\</span>
<span class="cp">    R##_s = 1 ^ X##_s;			\</span>
<span class="cp">  } while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * Main multiplication routine.  The input values should be cooked.</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_MUL(fs, wc, R, X, Y)			\</span>
<span class="cp">do {							\</span>
<span class="cp">  R##_s = X##_s ^ Y##_s;				\</span>
<span class="cp">  switch (_FP_CLS_COMBINE(X##_c, Y##_c))		\</span>
<span class="cp">  {							\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NORMAL):	\</span>
<span class="cp">    R##_c = FP_CLS_NORMAL;				\</span>
<span class="cp">    R##_e = X##_e + Y##_e + 1;				\</span>
<span class="cp">							\</span>
<span class="cp">    _FP_MUL_MEAT_##fs(R,X,Y);				\</span>
<span class="cp">							\</span>
<span class="cp">    if (_FP_FRAC_OVERP_##wc(fs, R))			\</span>
<span class="cp">      _FP_FRAC_SRS_##wc(R, 1, _FP_WFRACBITS_##fs);	\</span>
<span class="cp">    else						\</span>
<span class="cp">      R##_e--;						\</span>
<span class="cp">    break;						\</span>
<span class="cp">							\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NAN):		\</span>
<span class="cp">    _FP_CHOOSENAN(fs, wc, R, X, Y, &#39;*&#39;);		\</span>
<span class="cp">    break;						\</span>
<span class="cp">							\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NORMAL):	\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_INF):		\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_ZERO):		\</span>
<span class="cp">    R##_s = X##_s;					\</span>
<span class="cp">							\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_INF):		\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NORMAL):	\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NORMAL):	\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_ZERO):	\</span>
<span class="cp">    _FP_FRAC_COPY_##wc(R, X);				\</span>
<span class="cp">    R##_c = X##_c;					\</span>
<span class="cp">    break;						\</span>
<span class="cp">							\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NAN):	\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NAN):		\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NAN):		\</span>
<span class="cp">    R##_s = Y##_s;					\</span>
<span class="cp">							\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_INF):	\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_ZERO):	\</span>
<span class="cp">    _FP_FRAC_COPY_##wc(R, Y);				\</span>
<span class="cp">    R##_c = Y##_c;					\</span>
<span class="cp">    break;						\</span>
<span class="cp">							\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_ZERO):		\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_INF):		\</span>
<span class="cp">    R##_s = _FP_NANSIGN_##fs;				\</span>
<span class="cp">    R##_c = FP_CLS_NAN;					\</span>
<span class="cp">    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);		\</span>
<span class="cp">    FP_SET_EXCEPTION(FP_EX_INVALID | FP_EX_INVALID_IMZ);\</span>
<span class="cp">    break;						\</span>
<span class="cp">							\</span>
<span class="cp">  default:						\</span>
<span class="cp">    abort();						\</span>
<span class="cp">  }							\</span>
<span class="cp">} while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * Main division routine.  The input values should be cooked.</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_DIV(fs, wc, R, X, Y)			\</span>
<span class="cp">do {							\</span>
<span class="cp">  R##_s = X##_s ^ Y##_s;				\</span>
<span class="cp">  switch (_FP_CLS_COMBINE(X##_c, Y##_c))		\</span>
<span class="cp">  {							\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NORMAL):	\</span>
<span class="cp">    R##_c = FP_CLS_NORMAL;				\</span>
<span class="cp">    R##_e = X##_e - Y##_e;				\</span>
<span class="cp">							\</span>
<span class="cp">    _FP_DIV_MEAT_##fs(R,X,Y);				\</span>
<span class="cp">    break;						\</span>
<span class="cp">							\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NAN):		\</span>
<span class="cp">    _FP_CHOOSENAN(fs, wc, R, X, Y, &#39;/&#39;);		\</span>
<span class="cp">    break;						\</span>
<span class="cp">							\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NORMAL):	\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_INF):		\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_ZERO):		\</span>
<span class="cp">    R##_s = X##_s;					\</span>
<span class="cp">    _FP_FRAC_COPY_##wc(R, X);				\</span>
<span class="cp">    R##_c = X##_c;					\</span>
<span class="cp">    break;						\</span>
<span class="cp">							\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NAN):	\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NAN):		\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NAN):		\</span>
<span class="cp">    R##_s = Y##_s;					\</span>
<span class="cp">    _FP_FRAC_COPY_##wc(R, Y);				\</span>
<span class="cp">    R##_c = Y##_c;					\</span>
<span class="cp">    break;						\</span>
<span class="cp">							\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_INF):	\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_INF):		\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NORMAL):	\</span>
<span class="cp">    R##_c = FP_CLS_ZERO;				\</span>
<span class="cp">    break;						\</span>
<span class="cp">							\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_ZERO):	\</span>
<span class="cp">    FP_SET_EXCEPTION(FP_EX_DIVZERO);			\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_ZERO):		\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NORMAL):	\</span>
<span class="cp">    R##_c = FP_CLS_INF;					\</span>
<span class="cp">    break;						\</span>
<span class="cp">							\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_INF):		\</span>
<span class="cp">    R##_s = _FP_NANSIGN_##fs;				\</span>
<span class="cp">    R##_c = FP_CLS_NAN;					\</span>
<span class="cp">    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);		\</span>
<span class="cp">    FP_SET_EXCEPTION(FP_EX_INVALID | FP_EX_INVALID_IDI);\</span>
<span class="cp">    break;						\</span>
<span class="cp">							\</span>
<span class="cp">  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_ZERO):	\</span>
<span class="cp">    R##_s = _FP_NANSIGN_##fs;				\</span>
<span class="cp">    R##_c = FP_CLS_NAN;					\</span>
<span class="cp">    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);		\</span>
<span class="cp">    FP_SET_EXCEPTION(FP_EX_INVALID | FP_EX_INVALID_ZDZ);\</span>
<span class="cp">    break;						\</span>
<span class="cp">							\</span>
<span class="cp">  default:						\</span>
<span class="cp">    abort();						\</span>
<span class="cp">  }							\</span>
<span class="cp">} while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * Main differential comparison routine.  The inputs should be raw not</span>
<span class="cm"> * cooked.  The return is -1,0,1 for normal values, 2 otherwise.</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_CMP(fs, wc, ret, X, Y, un)					\</span>
<span class="cp">  do {									\</span>
<span class="cp">    </span><span class="cm">/* NANs are unordered */</span><span class="cp">						\</span>
<span class="cp">    if ((X##_e == _FP_EXPMAX_##fs &amp;&amp; !_FP_FRAC_ZEROP_##wc(X))		\</span>
<span class="cp">	|| (Y##_e == _FP_EXPMAX_##fs &amp;&amp; !_FP_FRAC_ZEROP_##wc(Y)))	\</span>
<span class="cp">      {									\</span>
<span class="cp">	ret = un;							\</span>
<span class="cp">      }									\</span>
<span class="cp">    else								\</span>
<span class="cp">      {									\</span>
<span class="cp">	int __is_zero_x;						\</span>
<span class="cp">	int __is_zero_y;						\</span>
<span class="cp">									\</span>
<span class="cp">	__is_zero_x = (!X##_e &amp;&amp; _FP_FRAC_ZEROP_##wc(X)) ? 1 : 0;	\</span>
<span class="cp">	__is_zero_y = (!Y##_e &amp;&amp; _FP_FRAC_ZEROP_##wc(Y)) ? 1 : 0;	\</span>
<span class="cp">									\</span>
<span class="cp">	if (__is_zero_x &amp;&amp; __is_zero_y)					\</span>
<span class="cp">		ret = 0;						\</span>
<span class="cp">	else if (__is_zero_x)						\</span>
<span class="cp">		ret = Y##_s ? 1 : -1;					\</span>
<span class="cp">	else if (__is_zero_y)						\</span>
<span class="cp">		ret = X##_s ? -1 : 1;					\</span>
<span class="cp">	else if (X##_s != Y##_s)					\</span>
<span class="cp">	  ret = X##_s ? -1 : 1;						\</span>
<span class="cp">	else if (X##_e &gt; Y##_e)						\</span>
<span class="cp">	  ret = X##_s ? -1 : 1;						\</span>
<span class="cp">	else if (X##_e &lt; Y##_e)						\</span>
<span class="cp">	  ret = X##_s ? 1 : -1;						\</span>
<span class="cp">	else if (_FP_FRAC_GT_##wc(X, Y))				\</span>
<span class="cp">	  ret = X##_s ? -1 : 1;						\</span>
<span class="cp">	else if (_FP_FRAC_GT_##wc(Y, X))				\</span>
<span class="cp">	  ret = X##_s ? 1 : -1;						\</span>
<span class="cp">	else								\</span>
<span class="cp">	  ret = 0;							\</span>
<span class="cp">      }									\</span>
<span class="cp">  } while (0)</span>


<span class="cm">/* Simplification for strict equality.  */</span>

<span class="cp">#define _FP_CMP_EQ(fs, wc, ret, X, Y)					  \</span>
<span class="cp">  do {									  \</span>
<span class="cp">    </span><span class="cm">/* NANs are unordered */</span><span class="cp">						  \</span>
<span class="cp">    if ((X##_e == _FP_EXPMAX_##fs &amp;&amp; !_FP_FRAC_ZEROP_##wc(X))		  \</span>
<span class="cp">	|| (Y##_e == _FP_EXPMAX_##fs &amp;&amp; !_FP_FRAC_ZEROP_##wc(Y)))	  \</span>
<span class="cp">      {									  \</span>
<span class="cp">	ret = 1;							  \</span>
<span class="cp">      }									  \</span>
<span class="cp">    else								  \</span>
<span class="cp">      {									  \</span>
<span class="cp">	ret = !(X##_e == Y##_e						  \</span>
<span class="cp">		&amp;&amp; _FP_FRAC_EQ_##wc(X, Y)				  \</span>
<span class="cp">		&amp;&amp; (X##_s == Y##_s || !X##_e &amp;&amp; _FP_FRAC_ZEROP_##wc(X))); \</span>
<span class="cp">      }									  \</span>
<span class="cp">  } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Main square root routine.  The input value should be cooked.</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_SQRT(fs, wc, R, X)						\</span>
<span class="cp">do {									\</span>
<span class="cp">    _FP_FRAC_DECL_##wc(T); _FP_FRAC_DECL_##wc(S);			\</span>
<span class="cp">    _FP_W_TYPE q;							\</span>
<span class="cp">    switch (X##_c)							\</span>
<span class="cp">    {									\</span>
<span class="cp">    case FP_CLS_NAN:							\</span>
<span class="cp">	_FP_FRAC_COPY_##wc(R, X);					\</span>
<span class="cp">	R##_s = X##_s;							\</span>
<span class="cp">    	R##_c = FP_CLS_NAN;						\</span>
<span class="cp">    	break;								\</span>
<span class="cp">    case FP_CLS_INF:							\</span>
<span class="cp">    	if (X##_s)							\</span>
<span class="cp">    	  {								\</span>
<span class="cp">    	    R##_s = _FP_NANSIGN_##fs;					\</span>
<span class="cp">	    R##_c = FP_CLS_NAN; </span><span class="cm">/* NAN */</span><span class="cp">				\</span>
<span class="cp">	    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);			\</span>
<span class="cp">	    FP_SET_EXCEPTION(FP_EX_INVALID);				\</span>
<span class="cp">    	  }								\</span>
<span class="cp">    	else								\</span>
<span class="cp">    	  {								\</span>
<span class="cp">    	    R##_s = 0;							\</span>
<span class="cp">    	    R##_c = FP_CLS_INF; </span><span class="cm">/* sqrt(+inf) = +inf */</span><span class="cp">			\</span>
<span class="cp">    	  }								\</span>
<span class="cp">    	break;								\</span>
<span class="cp">    case FP_CLS_ZERO:							\</span>
<span class="cp">	R##_s = X##_s;							\</span>
<span class="cp">	R##_c = FP_CLS_ZERO; </span><span class="cm">/* sqrt(+-0) = +-0 */</span><span class="cp">			\</span>
<span class="cp">	break;								\</span>
<span class="cp">    case FP_CLS_NORMAL:							\</span>
<span class="cp">    	R##_s = 0;							\</span>
<span class="cp">        if (X##_s)							\</span>
<span class="cp">          {								\</span>
<span class="cp">	    R##_c = FP_CLS_NAN; </span><span class="cm">/* sNAN */</span><span class="cp">				\</span>
<span class="cp">	    R##_s = _FP_NANSIGN_##fs;					\</span>
<span class="cp">	    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);			\</span>
<span class="cp">	    FP_SET_EXCEPTION(FP_EX_INVALID);				\</span>
<span class="cp">	    break;							\</span>
<span class="cp">          }								\</span>
<span class="cp">    	R##_c = FP_CLS_NORMAL;						\</span>
<span class="cp">        if (X##_e &amp; 1)							\</span>
<span class="cp">          _FP_FRAC_SLL_##wc(X, 1);					\</span>
<span class="cp">        R##_e = X##_e &gt;&gt; 1;						\</span>
<span class="cp">        _FP_FRAC_SET_##wc(S, _FP_ZEROFRAC_##wc);			\</span>
<span class="cp">        _FP_FRAC_SET_##wc(R, _FP_ZEROFRAC_##wc);			\</span>
<span class="cp">        q = _FP_OVERFLOW_##fs &gt;&gt; 1;					\</span>
<span class="cp">        _FP_SQRT_MEAT_##wc(R, S, T, X, q);				\</span>
<span class="cp">    }									\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Convert from FP to integer</span>
<span class="cm"> */</span>

<span class="cm">/* RSIGNED can have following values:</span>
<span class="cm"> * 0:  the number is required to be 0..(2^rsize)-1, if not, NV is set plus</span>
<span class="cm"> *     the result is either 0 or (2^rsize)-1 depending on the sign in such case.</span>
<span class="cm"> * 1:  the number is required to be -(2^(rsize-1))..(2^(rsize-1))-1, if not, NV is</span>
<span class="cm"> *     set plus the result is either -(2^(rsize-1)) or (2^(rsize-1))-1 depending</span>
<span class="cm"> *     on the sign in such case.</span>
<span class="cm"> * 2:  the number is required to be -(2^(rsize-1))..(2^(rsize-1))-1, if not, NV is</span>
<span class="cm"> *     set plus the result is truncated to fit into destination.</span>
<span class="cm"> * -1: the number is required to be -(2^(rsize-1))..(2^rsize)-1, if not, NV is</span>
<span class="cm"> *     set plus the result is either -(2^(rsize-1)) or (2^(rsize-1))-1 depending</span>
<span class="cm"> *     on the sign in such case.</span>
<span class="cm"> */</span>
<span class="cp">#define _FP_TO_INT(fs, wc, r, X, rsize, rsigned)				\</span>
<span class="cp">  do {										\</span>
<span class="cp">    switch (X##_c)								\</span>
<span class="cp">      {										\</span>
<span class="cp">      case FP_CLS_NORMAL:							\</span>
<span class="cp">	if (X##_e &lt; 0)								\</span>
<span class="cp">	  {									\</span>
<span class="cp">	    FP_SET_EXCEPTION(FP_EX_INEXACT);					\</span>
<span class="cp">	  case FP_CLS_ZERO:							\</span>
<span class="cp">	    r = 0;								\</span>
<span class="cp">	  }									\</span>
<span class="cp">	else if (X##_e &gt;= rsize - (rsigned &gt; 0 || X##_s)			\</span>
<span class="cp">		 || (!rsigned &amp;&amp; X##_s))					\</span>
<span class="cp">	  {	</span><span class="cm">/* overflow */</span><span class="cp">							\</span>
<span class="cp">	  case FP_CLS_NAN:                                                      \</span>
<span class="cp">	  case FP_CLS_INF:							\</span>
<span class="cp">	    if (rsigned == 2)							\</span>
<span class="cp">	      {									\</span>
<span class="cp">		if (X##_c != FP_CLS_NORMAL					\</span>
<span class="cp">		    || X##_e &gt;= rsize - 1 + _FP_WFRACBITS_##fs)			\</span>
<span class="cp">		  r = 0;							\</span>
<span class="cp">		else								\</span>
<span class="cp">		  {								\</span>
<span class="cp">		    _FP_FRAC_SLL_##wc(X, (X##_e - _FP_WFRACBITS_##fs + 1));	\</span>
<span class="cp">		    _FP_FRAC_ASSEMBLE_##wc(r, X, rsize);			\</span>
<span class="cp">		  }								\</span>
<span class="cp">	      }									\</span>
<span class="cp">	    else if (rsigned)							\</span>
<span class="cp">	      {									\</span>
<span class="cp">		r = 1;								\</span>
<span class="cp">		r &lt;&lt;= rsize - 1;						\</span>
<span class="cp">		r -= 1 - X##_s;							\</span>
<span class="cp">	      }									\</span>
<span class="cp">	    else								\</span>
<span class="cp">	      {									\</span>
<span class="cp">		r = 0;								\</span>
<span class="cp">		if (X##_s)							\</span>
<span class="cp">		  r = ~r;							\</span>
<span class="cp">	      }									\</span>
<span class="cp">	    FP_SET_EXCEPTION(FP_EX_INVALID);					\</span>
<span class="cp">	  }									\</span>
<span class="cp">	else									\</span>
<span class="cp">	  {									\</span>
<span class="cp">	    if (_FP_W_TYPE_SIZE*wc &lt; rsize)					\</span>
<span class="cp">	      {									\</span>
<span class="cp">		_FP_FRAC_ASSEMBLE_##wc(r, X, rsize);				\</span>
<span class="cp">		r &lt;&lt;= X##_e - _FP_WFRACBITS_##fs;				\</span>
<span class="cp">	      }									\</span>
<span class="cp">	    else								\</span>
<span class="cp">	      {									\</span>
<span class="cp">		if (X##_e &gt;= _FP_WFRACBITS_##fs)				\</span>
<span class="cp">		  _FP_FRAC_SLL_##wc(X, (X##_e - _FP_WFRACBITS_##fs + 1));	\</span>
<span class="cp">		else if (X##_e &lt; _FP_WFRACBITS_##fs - 1)			\</span>
<span class="cp">		  {								\</span>
<span class="cp">		    _FP_FRAC_SRS_##wc(X, (_FP_WFRACBITS_##fs - X##_e - 2),	\</span>
<span class="cp">				      _FP_WFRACBITS_##fs);			\</span>
<span class="cp">		    if (_FP_FRAC_LOW_##wc(X) &amp; 1)				\</span>
<span class="cp">		      FP_SET_EXCEPTION(FP_EX_INEXACT);				\</span>
<span class="cp">		    _FP_FRAC_SRL_##wc(X, 1);					\</span>
<span class="cp">		  }								\</span>
<span class="cp">		_FP_FRAC_ASSEMBLE_##wc(r, X, rsize);				\</span>
<span class="cp">	      }									\</span>
<span class="cp">	    if (rsigned &amp;&amp; X##_s)						\</span>
<span class="cp">	      r = -r;								\</span>
<span class="cp">	  }									\</span>
<span class="cp">	break;									\</span>
<span class="cp">      }										\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_TO_INT_ROUND(fs, wc, r, X, rsize, rsigned)				\</span>
<span class="cp">  do {										\</span>
<span class="cp">    r = 0;									\</span>
<span class="cp">    switch (X##_c)								\</span>
<span class="cp">      {										\</span>
<span class="cp">      case FP_CLS_NORMAL:							\</span>
<span class="cp">	if (X##_e &gt;= _FP_FRACBITS_##fs - 1)					\</span>
<span class="cp">	  {									\</span>
<span class="cp">	    if (X##_e &lt; rsize - 1 + _FP_WFRACBITS_##fs)				\</span>
<span class="cp">	      {									\</span>
<span class="cp">		if (X##_e &gt;= _FP_WFRACBITS_##fs - 1)				\</span>
<span class="cp">		  {								\</span>
<span class="cp">		    _FP_FRAC_ASSEMBLE_##wc(r, X, rsize);			\</span>
<span class="cp">		    r &lt;&lt;= X##_e - _FP_WFRACBITS_##fs + 1;			\</span>
<span class="cp">		  }								\</span>
<span class="cp">		else								\</span>
<span class="cp">		  {								\</span>
<span class="cp">		    _FP_FRAC_SRL_##wc(X, _FP_WORKBITS - X##_e			\</span>
<span class="cp">				      + _FP_FRACBITS_##fs - 1);			\</span>
<span class="cp">		    _FP_FRAC_ASSEMBLE_##wc(r, X, rsize);			\</span>
<span class="cp">		  }								\</span>
<span class="cp">	      }									\</span>
<span class="cp">	  }									\</span>
<span class="cp">	else									\</span>
<span class="cp">	  {									\</span>
<span class="cp">	    if (X##_e &lt;= -_FP_WORKBITS - 1)					\</span>
<span class="cp">	      _FP_FRAC_SET_##wc(X, _FP_MINFRAC_##wc);				\</span>
<span class="cp">	    else								\</span>
<span class="cp">	      _FP_FRAC_SRS_##wc(X, _FP_FRACBITS_##fs - 1 - X##_e,		\</span>
<span class="cp">				_FP_WFRACBITS_##fs);				\</span>
<span class="cp">	    _FP_ROUND(wc, X);							\</span>
<span class="cp">	    _FP_FRAC_SRL_##wc(X, _FP_WORKBITS);					\</span>
<span class="cp">	    _FP_FRAC_ASSEMBLE_##wc(r, X, rsize);				\</span>
<span class="cp">	  }									\</span>
<span class="cp">	if (rsigned &amp;&amp; X##_s)							\</span>
<span class="cp">	  r = -r;								\</span>
<span class="cp">	if (X##_e &gt;= rsize - (rsigned &gt; 0 || X##_s)				\</span>
<span class="cp">	    || (!rsigned &amp;&amp; X##_s))						\</span>
<span class="cp">	  {	</span><span class="cm">/* overflow */</span><span class="cp">							\</span>
<span class="cp">	  case FP_CLS_NAN:                                                      \</span>
<span class="cp">	  case FP_CLS_INF:							\</span>
<span class="cp">	    if (!rsigned)							\</span>
<span class="cp">	      {									\</span>
<span class="cp">		r = 0;								\</span>
<span class="cp">		if (X##_s)							\</span>
<span class="cp">		  r = ~r;							\</span>
<span class="cp">	      }									\</span>
<span class="cp">	    else if (rsigned != 2)						\</span>
<span class="cp">	      {									\</span>
<span class="cp">		r = 1;								\</span>
<span class="cp">		r &lt;&lt;= rsize - 1;						\</span>
<span class="cp">		r -= 1 - X##_s;							\</span>
<span class="cp">	      }									\</span>
<span class="cp">	    FP_SET_EXCEPTION(FP_EX_INVALID);					\</span>
<span class="cp">	  }									\</span>
<span class="cp">	break;									\</span>
<span class="cp">      case FP_CLS_ZERO:								\</span>
<span class="cp">        break;									\</span>
<span class="cp">      }										\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_FROM_INT(fs, wc, X, r, rsize, rtype)			\</span>
<span class="cp">  do {									\</span>
<span class="cp">    if (r)								\</span>
<span class="cp">      {									\</span>
<span class="cp">        unsigned rtype ur_;						\</span>
<span class="cp">	X##_c = FP_CLS_NORMAL;						\</span>
<span class="cp">									\</span>
<span class="cp">	if ((X##_s = (r &lt; 0)))						\</span>
<span class="cp">	  ur_ = (unsigned rtype) -r;					\</span>
<span class="cp">	else								\</span>
<span class="cp">	  ur_ = (unsigned rtype) r;					\</span>
<span class="cp">	if (rsize &lt;= _FP_W_TYPE_SIZE)					\</span>
<span class="cp">	  __FP_CLZ(X##_e, ur_);						\</span>
<span class="cp">	else								\</span>
<span class="cp">	  __FP_CLZ_2(X##_e, (_FP_W_TYPE)(ur_ &gt;&gt; _FP_W_TYPE_SIZE), 	\</span>
<span class="cp">		     (_FP_W_TYPE)ur_);					\</span>
<span class="cp">	if (rsize &lt; _FP_W_TYPE_SIZE)					\</span>
<span class="cp">		X##_e -= (_FP_W_TYPE_SIZE - rsize);			\</span>
<span class="cp">	X##_e = rsize - X##_e - 1;					\</span>
<span class="cp">									\</span>
<span class="cp">	if (_FP_FRACBITS_##fs &lt; rsize &amp;&amp; _FP_WFRACBITS_##fs &lt;= X##_e)	\</span>
<span class="cp">	  __FP_FRAC_SRS_1(ur_, (X##_e - _FP_WFRACBITS_##fs + 1), rsize);\</span>
<span class="cp">	_FP_FRAC_DISASSEMBLE_##wc(X, ur_, rsize);			\</span>
<span class="cp">	if ((_FP_WFRACBITS_##fs - X##_e - 1) &gt; 0)			\</span>
<span class="cp">	  _FP_FRAC_SLL_##wc(X, (_FP_WFRACBITS_##fs - X##_e - 1));	\</span>
<span class="cp">      }									\</span>
<span class="cp">    else								\</span>
<span class="cp">      {									\</span>
<span class="cp">	X##_c = FP_CLS_ZERO, X##_s = 0;					\</span>
<span class="cp">      }									\</span>
<span class="cp">  } while (0)</span>


<span class="cp">#define FP_CONV(dfs,sfs,dwc,swc,D,S)			\</span>
<span class="cp">  do {							\</span>
<span class="cp">    _FP_FRAC_CONV_##dwc##_##swc(dfs, sfs, D, S);	\</span>
<span class="cp">    D##_e = S##_e;					\</span>
<span class="cp">    D##_c = S##_c;					\</span>
<span class="cp">    D##_s = S##_s;					\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Helper primitives.</span>
<span class="cm"> */</span>

<span class="cm">/* Count leading zeros in a word.  */</span>

<span class="cp">#ifndef __FP_CLZ</span>
<span class="cp">#if _FP_W_TYPE_SIZE &lt; 64</span>
<span class="cm">/* this is just to shut the compiler up about shifts &gt; word length -- PMM 02/1998 */</span>
<span class="cp">#define __FP_CLZ(r, x)				\</span>
<span class="cp">  do {						\</span>
<span class="cp">    _FP_W_TYPE _t = (x);			\</span>
<span class="cp">    r = _FP_W_TYPE_SIZE - 1;			\</span>
<span class="cp">    if (_t &gt; 0xffff) r -= 16;			\</span>
<span class="cp">    if (_t &gt; 0xffff) _t &gt;&gt;= 16;			\</span>
<span class="cp">    if (_t &gt; 0xff) r -= 8;			\</span>
<span class="cp">    if (_t &gt; 0xff) _t &gt;&gt;= 8;			\</span>
<span class="cp">    if (_t &amp; 0xf0) r -= 4;			\</span>
<span class="cp">    if (_t &amp; 0xf0) _t &gt;&gt;= 4;			\</span>
<span class="cp">    if (_t &amp; 0xc) r -= 2;			\</span>
<span class="cp">    if (_t &amp; 0xc) _t &gt;&gt;= 2;			\</span>
<span class="cp">    if (_t &amp; 0x2) r -= 1;			\</span>
<span class="cp">  } while (0)</span>
<span class="cp">#else </span><span class="cm">/* not _FP_W_TYPE_SIZE &lt; 64 */</span><span class="cp"></span>
<span class="cp">#define __FP_CLZ(r, x)				\</span>
<span class="cp">  do {						\</span>
<span class="cp">    _FP_W_TYPE _t = (x);			\</span>
<span class="cp">    r = _FP_W_TYPE_SIZE - 1;			\</span>
<span class="cp">    if (_t &gt; 0xffffffff) r -= 32;		\</span>
<span class="cp">    if (_t &gt; 0xffffffff) _t &gt;&gt;= 32;		\</span>
<span class="cp">    if (_t &gt; 0xffff) r -= 16;			\</span>
<span class="cp">    if (_t &gt; 0xffff) _t &gt;&gt;= 16;			\</span>
<span class="cp">    if (_t &gt; 0xff) r -= 8;			\</span>
<span class="cp">    if (_t &gt; 0xff) _t &gt;&gt;= 8;			\</span>
<span class="cp">    if (_t &amp; 0xf0) r -= 4;			\</span>
<span class="cp">    if (_t &amp; 0xf0) _t &gt;&gt;= 4;			\</span>
<span class="cp">    if (_t &amp; 0xc) r -= 2;			\</span>
<span class="cp">    if (_t &amp; 0xc) _t &gt;&gt;= 2;			\</span>
<span class="cp">    if (_t &amp; 0x2) r -= 1;			\</span>
<span class="cp">  } while (0)</span>
<span class="cp">#endif </span><span class="cm">/* not _FP_W_TYPE_SIZE &lt; 64 */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* ndef __FP_CLZ */</span><span class="cp"></span>

<span class="cp">#define _FP_DIV_HELP_imm(q, r, n, d)		\</span>
<span class="cp">  do {						\</span>
<span class="cp">    q = n / d, r = n % d;			\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#endif </span><span class="cm">/* __MATH_EMU_OP_COMMON_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
