<!DOCTYPE html>
<html><head><title>joekychen/linux » include › math-emu › op-4.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>op-4.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Software floating-point emulation.</span>
<span class="cm">   Basic four-word fraction declaration and manipulation.</span>
<span class="cm">   Copyright (C) 1997,1998,1999 Free Software Foundation, Inc.</span>
<span class="cm">   This file is part of the GNU C Library.</span>
<span class="cm">   Contributed by Richard Henderson (rth@cygnus.com),</span>
<span class="cm">		  Jakub Jelinek (jj@ultra.linux.cz),</span>
<span class="cm">		  David S. Miller (davem@redhat.com) and</span>
<span class="cm">		  Peter Maydell (pmaydell@chiark.greenend.org.uk).</span>

<span class="cm">   The GNU C Library is free software; you can redistribute it and/or</span>
<span class="cm">   modify it under the terms of the GNU Library General Public License as</span>
<span class="cm">   published by the Free Software Foundation; either version 2 of the</span>
<span class="cm">   License, or (at your option) any later version.</span>

<span class="cm">   The GNU C Library is distributed in the hope that it will be useful,</span>
<span class="cm">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm">   Library General Public License for more details.</span>

<span class="cm">   You should have received a copy of the GNU Library General Public</span>
<span class="cm">   License along with the GNU C Library; see the file COPYING.LIB.  If</span>
<span class="cm">   not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */</span>

<span class="cp">#ifndef __MATH_EMU_OP_4_H__</span>
<span class="cp">#define __MATH_EMU_OP_4_H__</span>

<span class="cp">#define _FP_FRAC_DECL_4(X)	_FP_W_TYPE X##_f[4]</span>
<span class="cp">#define _FP_FRAC_COPY_4(D,S)			\</span>
<span class="cp">  (D##_f[0] = S##_f[0], D##_f[1] = S##_f[1],	\</span>
<span class="cp">   D##_f[2] = S##_f[2], D##_f[3] = S##_f[3])</span>
<span class="cp">#define _FP_FRAC_SET_4(X,I)	__FP_FRAC_SET_4(X, I)</span>
<span class="cp">#define _FP_FRAC_HIGH_4(X)	(X##_f[3])</span>
<span class="cp">#define _FP_FRAC_LOW_4(X)	(X##_f[0])</span>
<span class="cp">#define _FP_FRAC_WORD_4(X,w)	(X##_f[w])</span>

<span class="cp">#define _FP_FRAC_SLL_4(X,N)						\</span>
<span class="cp">  do {									\</span>
<span class="cp">    _FP_I_TYPE _up, _down, _skip, _i;					\</span>
<span class="cp">    _skip = (N) / _FP_W_TYPE_SIZE;					\</span>
<span class="cp">    _up = (N) % _FP_W_TYPE_SIZE;					\</span>
<span class="cp">    _down = _FP_W_TYPE_SIZE - _up;					\</span>
<span class="cp">    if (!_up)								\</span>
<span class="cp">      for (_i = 3; _i &gt;= _skip; --_i)					\</span>
<span class="cp">	X##_f[_i] = X##_f[_i-_skip];					\</span>
<span class="cp">    else								\</span>
<span class="cp">      {									\</span>
<span class="cp">	for (_i = 3; _i &gt; _skip; --_i)					\</span>
<span class="cp">	  X##_f[_i] = X##_f[_i-_skip] &lt;&lt; _up				\</span>
<span class="cp">		      | X##_f[_i-_skip-1] &gt;&gt; _down;			\</span>
<span class="cp">	X##_f[_i--] = X##_f[0] &lt;&lt; _up; 					\</span>
<span class="cp">      }									\</span>
<span class="cp">    for (; _i &gt;= 0; --_i)						\</span>
<span class="cp">      X##_f[_i] = 0;							\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/* This one was broken too */</span>
<span class="cp">#define _FP_FRAC_SRL_4(X,N)						\</span>
<span class="cp">  do {									\</span>
<span class="cp">    _FP_I_TYPE _up, _down, _skip, _i;					\</span>
<span class="cp">    _skip = (N) / _FP_W_TYPE_SIZE;					\</span>
<span class="cp">    _down = (N) % _FP_W_TYPE_SIZE;					\</span>
<span class="cp">    _up = _FP_W_TYPE_SIZE - _down;					\</span>
<span class="cp">    if (!_down)								\</span>
<span class="cp">      for (_i = 0; _i &lt;= 3-_skip; ++_i)					\</span>
<span class="cp">	X##_f[_i] = X##_f[_i+_skip];					\</span>
<span class="cp">    else								\</span>
<span class="cp">      {									\</span>
<span class="cp">	for (_i = 0; _i &lt; 3-_skip; ++_i)				\</span>
<span class="cp">	  X##_f[_i] = X##_f[_i+_skip] &gt;&gt; _down				\</span>
<span class="cp">		      | X##_f[_i+_skip+1] &lt;&lt; _up;			\</span>
<span class="cp">	X##_f[_i++] = X##_f[3] &gt;&gt; _down;				\</span>
<span class="cp">      }									\</span>
<span class="cp">    for (; _i &lt; 4; ++_i)						\</span>
<span class="cp">      X##_f[_i] = 0;							\</span>
<span class="cp">  } while (0)</span>


<span class="cm">/* Right shift with sticky-lsb. </span>
<span class="cm"> * What this actually means is that we do a standard right-shift,</span>
<span class="cm"> * but that if any of the bits that fall off the right hand side</span>
<span class="cm"> * were one then we always set the LSbit.</span>
<span class="cm"> */</span>
<span class="cp">#define _FP_FRAC_SRS_4(X,N,size)					\</span>
<span class="cp">  do {									\</span>
<span class="cp">    _FP_I_TYPE _up, _down, _skip, _i;					\</span>
<span class="cp">    _FP_W_TYPE _s;							\</span>
<span class="cp">    _skip = (N) / _FP_W_TYPE_SIZE;					\</span>
<span class="cp">    _down = (N) % _FP_W_TYPE_SIZE;					\</span>
<span class="cp">    _up = _FP_W_TYPE_SIZE - _down;					\</span>
<span class="cp">    for (_s = _i = 0; _i &lt; _skip; ++_i)					\</span>
<span class="cp">      _s |= X##_f[_i];							\</span>
<span class="cp">    _s |= X##_f[_i] &lt;&lt; _up;						\</span>
<span class="cm">/* s is now != 0 if we want to set the LSbit */</span><span class="cp">				\</span>
<span class="cp">    if (!_down)								\</span>
<span class="cp">      for (_i = 0; _i &lt;= 3-_skip; ++_i)					\</span>
<span class="cp">	X##_f[_i] = X##_f[_i+_skip];					\</span>
<span class="cp">    else								\</span>
<span class="cp">      {									\</span>
<span class="cp">	for (_i = 0; _i &lt; 3-_skip; ++_i)				\</span>
<span class="cp">	  X##_f[_i] = X##_f[_i+_skip] &gt;&gt; _down				\</span>
<span class="cp">		      | X##_f[_i+_skip+1] &lt;&lt; _up;			\</span>
<span class="cp">	X##_f[_i++] = X##_f[3] &gt;&gt; _down;				\</span>
<span class="cp">      }									\</span>
<span class="cp">    for (; _i &lt; 4; ++_i)						\</span>
<span class="cp">      X##_f[_i] = 0;							\</span>
<span class="cp">    </span><span class="cm">/* don&#39;t fix the LSB until the very end when we&#39;re sure f[0] is stable */</span><span class="cp">	\</span>
<span class="cp">    X##_f[0] |= (_s != 0);						\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_FRAC_ADD_4(R,X,Y)						\</span>
<span class="cp">  __FP_FRAC_ADD_4(R##_f[3], R##_f[2], R##_f[1], R##_f[0],		\</span>
<span class="cp">		  X##_f[3], X##_f[2], X##_f[1], X##_f[0],		\</span>
<span class="cp">		  Y##_f[3], Y##_f[2], Y##_f[1], Y##_f[0])</span>

<span class="cp">#define _FP_FRAC_SUB_4(R,X,Y)						\</span>
<span class="cp">  __FP_FRAC_SUB_4(R##_f[3], R##_f[2], R##_f[1], R##_f[0],		\</span>
<span class="cp">		  X##_f[3], X##_f[2], X##_f[1], X##_f[0],		\</span>
<span class="cp">		  Y##_f[3], Y##_f[2], Y##_f[1], Y##_f[0])</span>

<span class="cp">#define _FP_FRAC_DEC_4(X,Y)						\</span>
<span class="cp">  __FP_FRAC_DEC_4(X##_f[3], X##_f[2], X##_f[1], X##_f[0],		\</span>
<span class="cp">		  Y##_f[3], Y##_f[2], Y##_f[1], Y##_f[0])</span>

<span class="cp">#define _FP_FRAC_ADDI_4(X,I)						\</span>
<span class="cp">  __FP_FRAC_ADDI_4(X##_f[3], X##_f[2], X##_f[1], X##_f[0], I)</span>

<span class="cp">#define _FP_ZEROFRAC_4  0,0,0,0</span>
<span class="cp">#define _FP_MINFRAC_4   0,0,0,1</span>
<span class="cp">#define _FP_MAXFRAC_4	(~(_FP_WS_TYPE)0), (~(_FP_WS_TYPE)0), (~(_FP_WS_TYPE)0), (~(_FP_WS_TYPE)0)</span>

<span class="cp">#define _FP_FRAC_ZEROP_4(X)     ((X##_f[0] | X##_f[1] | X##_f[2] | X##_f[3]) == 0)</span>
<span class="cp">#define _FP_FRAC_NEGP_4(X)      ((_FP_WS_TYPE)X##_f[3] &lt; 0)</span>
<span class="cp">#define _FP_FRAC_OVERP_4(fs,X)  (_FP_FRAC_HIGH_##fs(X) &amp; _FP_OVERFLOW_##fs)</span>
<span class="cp">#define _FP_FRAC_CLEAR_OVERP_4(fs,X)  (_FP_FRAC_HIGH_##fs(X) &amp;= ~_FP_OVERFLOW_##fs)</span>

<span class="cp">#define _FP_FRAC_EQ_4(X,Y)				\</span>
<span class="cp"> (X##_f[0] == Y##_f[0] &amp;&amp; X##_f[1] == Y##_f[1]		\</span>
<span class="cp">  &amp;&amp; X##_f[2] == Y##_f[2] &amp;&amp; X##_f[3] == Y##_f[3])</span>

<span class="cp">#define _FP_FRAC_GT_4(X,Y)				\</span>
<span class="cp"> (X##_f[3] &gt; Y##_f[3] ||				\</span>
<span class="cp">  (X##_f[3] == Y##_f[3] &amp;&amp; (X##_f[2] &gt; Y##_f[2] ||	\</span>
<span class="cp">   (X##_f[2] == Y##_f[2] &amp;&amp; (X##_f[1] &gt; Y##_f[1] ||	\</span>
<span class="cp">    (X##_f[1] == Y##_f[1] &amp;&amp; X##_f[0] &gt; Y##_f[0])	\</span>
<span class="cp">   ))							\</span>
<span class="cp">  ))							\</span>
<span class="cp"> )</span>

<span class="cp">#define _FP_FRAC_GE_4(X,Y)				\</span>
<span class="cp"> (X##_f[3] &gt; Y##_f[3] ||				\</span>
<span class="cp">  (X##_f[3] == Y##_f[3] &amp;&amp; (X##_f[2] &gt; Y##_f[2] ||	\</span>
<span class="cp">   (X##_f[2] == Y##_f[2] &amp;&amp; (X##_f[1] &gt; Y##_f[1] ||	\</span>
<span class="cp">    (X##_f[1] == Y##_f[1] &amp;&amp; X##_f[0] &gt;= Y##_f[0])	\</span>
<span class="cp">   ))							\</span>
<span class="cp">  ))							\</span>
<span class="cp"> )</span>


<span class="cp">#define _FP_FRAC_CLZ_4(R,X)		\</span>
<span class="cp">  do {					\</span>
<span class="cp">    if (X##_f[3])			\</span>
<span class="cp">    {					\</span>
<span class="cp">	__FP_CLZ(R,X##_f[3]);		\</span>
<span class="cp">    }					\</span>
<span class="cp">    else if (X##_f[2])			\</span>
<span class="cp">    {					\</span>
<span class="cp">	__FP_CLZ(R,X##_f[2]);		\</span>
<span class="cp">	R += _FP_W_TYPE_SIZE;		\</span>
<span class="cp">    }					\</span>
<span class="cp">    else if (X##_f[1])			\</span>
<span class="cp">    {					\</span>
<span class="cp">	__FP_CLZ(R,X##_f[2]);		\</span>
<span class="cp">	R += _FP_W_TYPE_SIZE*2;		\</span>
<span class="cp">    }					\</span>
<span class="cp">    else				\</span>
<span class="cp">    {					\</span>
<span class="cp">	__FP_CLZ(R,X##_f[0]);		\</span>
<span class="cp">	R += _FP_W_TYPE_SIZE*3;		\</span>
<span class="cp">    }					\</span>
<span class="cp">  } while(0)</span>


<span class="cp">#define _FP_UNPACK_RAW_4(fs, X, val)				\</span>
<span class="cp">  do {								\</span>
<span class="cp">    union _FP_UNION_##fs _flo; _flo.flt = (val);		\</span>
<span class="cp">    X##_f[0] = _flo.bits.frac0;					\</span>
<span class="cp">    X##_f[1] = _flo.bits.frac1;					\</span>
<span class="cp">    X##_f[2] = _flo.bits.frac2;					\</span>
<span class="cp">    X##_f[3] = _flo.bits.frac3;					\</span>
<span class="cp">    X##_e  = _flo.bits.exp;					\</span>
<span class="cp">    X##_s  = _flo.bits.sign;					\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_UNPACK_RAW_4_P(fs, X, val)				\</span>
<span class="cp">  do {								\</span>
<span class="cp">    union _FP_UNION_##fs *_flo =				\</span>
<span class="cp">      (union _FP_UNION_##fs *)(val);				\</span>
<span class="cp">								\</span>
<span class="cp">    X##_f[0] = _flo-&gt;bits.frac0;				\</span>
<span class="cp">    X##_f[1] = _flo-&gt;bits.frac1;				\</span>
<span class="cp">    X##_f[2] = _flo-&gt;bits.frac2;				\</span>
<span class="cp">    X##_f[3] = _flo-&gt;bits.frac3;				\</span>
<span class="cp">    X##_e  = _flo-&gt;bits.exp;					\</span>
<span class="cp">    X##_s  = _flo-&gt;bits.sign;					\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_PACK_RAW_4(fs, val, X)				\</span>
<span class="cp">  do {								\</span>
<span class="cp">    union _FP_UNION_##fs _flo;					\</span>
<span class="cp">    _flo.bits.frac0 = X##_f[0];					\</span>
<span class="cp">    _flo.bits.frac1 = X##_f[1];					\</span>
<span class="cp">    _flo.bits.frac2 = X##_f[2];					\</span>
<span class="cp">    _flo.bits.frac3 = X##_f[3];					\</span>
<span class="cp">    _flo.bits.exp   = X##_e;					\</span>
<span class="cp">    _flo.bits.sign  = X##_s;					\</span>
<span class="cp">    (val) = _flo.flt;				   		\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_PACK_RAW_4_P(fs, val, X)				\</span>
<span class="cp">  do {								\</span>
<span class="cp">    union _FP_UNION_##fs *_flo =				\</span>
<span class="cp">      (union _FP_UNION_##fs *)(val);				\</span>
<span class="cp">								\</span>
<span class="cp">    _flo-&gt;bits.frac0 = X##_f[0];				\</span>
<span class="cp">    _flo-&gt;bits.frac1 = X##_f[1];				\</span>
<span class="cp">    _flo-&gt;bits.frac2 = X##_f[2];				\</span>
<span class="cp">    _flo-&gt;bits.frac3 = X##_f[3];				\</span>
<span class="cp">    _flo-&gt;bits.exp   = X##_e;					\</span>
<span class="cp">    _flo-&gt;bits.sign  = X##_s;					\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Multiplication algorithms:</span>
<span class="cm"> */</span>

<span class="cm">/* Given a 1W * 1W =&gt; 2W primitive, do the extended multiplication.  */</span>

<span class="cp">#define _FP_MUL_MEAT_4_wide(wfracbits, R, X, Y, doit)			    \</span>
<span class="cp">  do {									    \</span>
<span class="cp">    _FP_FRAC_DECL_8(_z); _FP_FRAC_DECL_2(_b); _FP_FRAC_DECL_2(_c);	    \</span>
<span class="cp">    _FP_FRAC_DECL_2(_d); _FP_FRAC_DECL_2(_e); _FP_FRAC_DECL_2(_f);	    \</span>
<span class="cp">									    \</span>
<span class="cp">    doit(_FP_FRAC_WORD_8(_z,1), _FP_FRAC_WORD_8(_z,0), X##_f[0], Y##_f[0]); \</span>
<span class="cp">    doit(_b_f1, _b_f0, X##_f[0], Y##_f[1]);				    \</span>
<span class="cp">    doit(_c_f1, _c_f0, X##_f[1], Y##_f[0]);				    \</span>
<span class="cp">    doit(_d_f1, _d_f0, X##_f[1], Y##_f[1]);				    \</span>
<span class="cp">    doit(_e_f1, _e_f0, X##_f[0], Y##_f[2]);				    \</span>
<span class="cp">    doit(_f_f1, _f_f0, X##_f[2], Y##_f[0]);				    \</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,3),_FP_FRAC_WORD_8(_z,2),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,1), 0,_b_f1,_b_f0,		    \</span>
<span class="cp">		    0,0,_FP_FRAC_WORD_8(_z,1));				    \</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,3),_FP_FRAC_WORD_8(_z,2),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,1), 0,_c_f1,_c_f0,		    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,3),_FP_FRAC_WORD_8(_z,2),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,1));				    \</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,2), 0,_d_f1,_d_f0,		    \</span>
<span class="cp">		    0,_FP_FRAC_WORD_8(_z,3),_FP_FRAC_WORD_8(_z,2));	    \</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,2), 0,_e_f1,_e_f0,		    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,2));				    \</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,2), 0,_f_f1,_f_f0,		    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,2));				    \</span>
<span class="cp">    doit(_b_f1, _b_f0, X##_f[0], Y##_f[3]);				    \</span>
<span class="cp">    doit(_c_f1, _c_f0, X##_f[3], Y##_f[0]);				    \</span>
<span class="cp">    doit(_d_f1, _d_f0, X##_f[1], Y##_f[2]);				    \</span>
<span class="cp">    doit(_e_f1, _e_f0, X##_f[2], Y##_f[1]);				    \</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,3), 0,_b_f1,_b_f0,		    \</span>
<span class="cp">		    0,_FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3));	    \</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,3), 0,_c_f1,_c_f0,		    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,3));				    \</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,3), 0,_d_f1,_d_f0,		    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,3));				    \</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,3), 0,_e_f1,_e_f0,		    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,3));				    \</span>
<span class="cp">    doit(_b_f1, _b_f0, X##_f[2], Y##_f[2]);				    \</span>
<span class="cp">    doit(_c_f1, _c_f0, X##_f[1], Y##_f[3]);				    \</span>
<span class="cp">    doit(_d_f1, _d_f0, X##_f[3], Y##_f[1]);				    \</span>
<span class="cp">    doit(_e_f1, _e_f0, X##_f[2], Y##_f[3]);				    \</span>
<span class="cp">    doit(_f_f1, _f_f0, X##_f[3], Y##_f[2]);				    \</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,4), 0,_b_f1,_b_f0,		    \</span>
<span class="cp">		    0,_FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4));	    \</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,4), 0,_c_f1,_c_f0,		    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,4));				    \</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,4), 0,_d_f1,_d_f0,		    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,4));				    \</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,7),_FP_FRAC_WORD_8(_z,6),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,5), 0,_e_f1,_e_f0,		    \</span>
<span class="cp">		    0,_FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5));	    \</span>
<span class="cp">    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,7),_FP_FRAC_WORD_8(_z,6),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,5), 0,_f_f1,_f_f0,		    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,7),_FP_FRAC_WORD_8(_z,6),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,5));				    \</span>
<span class="cp">    doit(_b_f1, _b_f0, X##_f[3], Y##_f[3]);				    \</span>
<span class="cp">    __FP_FRAC_ADD_2(_FP_FRAC_WORD_8(_z,7),_FP_FRAC_WORD_8(_z,6),	    \</span>
<span class="cp">		    _b_f1,_b_f0,					    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,7),_FP_FRAC_WORD_8(_z,6));	    \</span>
<span class="cp">									    \</span>
<span class="cp">    </span><span class="cm">/* Normalize since we know where the msb of the multiplicands	    \</span>
<span class="cm">       were (bit B), we know that the msb of the of the product is	    \</span>
<span class="cm">       at either 2B or 2B-1.  */</span><span class="cp">					    \</span>
<span class="cp">    _FP_FRAC_SRS_8(_z, wfracbits-1, 2*wfracbits);			    \</span>
<span class="cp">    __FP_FRAC_SET_4(R, _FP_FRAC_WORD_8(_z,3), _FP_FRAC_WORD_8(_z,2),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,1), _FP_FRAC_WORD_8(_z,0));	    \</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_MUL_MEAT_4_gmp(wfracbits, R, X, Y)				    \</span>
<span class="cp">  do {									    \</span>
<span class="cp">    _FP_FRAC_DECL_8(_z);						    \</span>
<span class="cp">									    \</span>
<span class="cp">    mpn_mul_n(_z_f, _x_f, _y_f, 4);					    \</span>
<span class="cp">									    \</span>
<span class="cp">    </span><span class="cm">/* Normalize since we know where the msb of the multiplicands	    \</span>
<span class="cm">       were (bit B), we know that the msb of the of the product is	    \</span>
<span class="cm">       at either 2B or 2B-1.  */</span><span class="cp">					    \</span>
<span class="cp">    _FP_FRAC_SRS_8(_z, wfracbits-1, 2*wfracbits);	 		    \</span>
<span class="cp">    __FP_FRAC_SET_4(R, _FP_FRAC_WORD_8(_z,3), _FP_FRAC_WORD_8(_z,2),	    \</span>
<span class="cp">		    _FP_FRAC_WORD_8(_z,1), _FP_FRAC_WORD_8(_z,0));	    \</span>
<span class="cp">  } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Helper utility for _FP_DIV_MEAT_4_udiv:</span>
<span class="cm"> * pppp = m * nnn</span>
<span class="cm"> */</span>
<span class="cp">#define umul_ppppmnnn(p3,p2,p1,p0,m,n2,n1,n0)				    \</span>
<span class="cp">  do {									    \</span>
<span class="cp">    UWtype _t;								    \</span>
<span class="cp">    umul_ppmm(p1,p0,m,n0);						    \</span>
<span class="cp">    umul_ppmm(p2,_t,m,n1);						    \</span>
<span class="cp">    __FP_FRAC_ADDI_2(p2,p1,_t);						    \</span>
<span class="cp">    umul_ppmm(p3,_t,m,n2);						    \</span>
<span class="cp">    __FP_FRAC_ADDI_2(p3,p2,_t);						    \</span>
<span class="cp">  } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Division algorithms:</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_DIV_MEAT_4_udiv(fs, R, X, Y)				    \</span>
<span class="cp">  do {									    \</span>
<span class="cp">    int _i;								    \</span>
<span class="cp">    _FP_FRAC_DECL_4(_n); _FP_FRAC_DECL_4(_m);				    \</span>
<span class="cp">    _FP_FRAC_SET_4(_n, _FP_ZEROFRAC_4);					    \</span>
<span class="cp">    if (_FP_FRAC_GT_4(X, Y))						    \</span>
<span class="cp">      {									    \</span>
<span class="cp">	_n_f[3] = X##_f[0] &lt;&lt; (_FP_W_TYPE_SIZE - 1);			    \</span>
<span class="cp">	_FP_FRAC_SRL_4(X, 1);						    \</span>
<span class="cp">      }									    \</span>
<span class="cp">    else								    \</span>
<span class="cp">      R##_e--;								    \</span>
<span class="cp">									    \</span>
<span class="cp">    </span><span class="cm">/* Normalize, i.e. make the most significant bit of the 		    \</span>
<span class="cm">       denominator set. */</span><span class="cp">						    \</span>
<span class="cp">    _FP_FRAC_SLL_4(Y, _FP_WFRACXBITS_##fs);				    \</span>
<span class="cp">									    \</span>
<span class="cp">    for (_i = 3; ; _i--)						    \</span>
<span class="cp">      {									    \</span>
<span class="cp">        if (X##_f[3] == Y##_f[3])					    \</span>
<span class="cp">          {								    \</span>
<span class="cp">            </span><span class="cm">/* This is a special case, not an optimization		    \</span>
<span class="cm">               (X##_f[3]/Y##_f[3] would not fit into UWtype).		    \</span>
<span class="cm">               As X## is guaranteed to be &lt; Y,  R##_f[_i] can be either	    \</span>
<span class="cm">               (UWtype)-1 or (UWtype)-2.  */</span><span class="cp">				    \</span>
<span class="cp">            R##_f[_i] = -1;						    \</span>
<span class="cp">            if (!_i)							    \</span>
<span class="cp">	      break;							    \</span>
<span class="cp">            __FP_FRAC_SUB_4(X##_f[3], X##_f[2], X##_f[1], X##_f[0],	    \</span>
<span class="cp">			    Y##_f[2], Y##_f[1], Y##_f[0], 0,		    \</span>
<span class="cp">			    X##_f[2], X##_f[1], X##_f[0], _n_f[_i]);	    \</span>
<span class="cp">            _FP_FRAC_SUB_4(X, Y, X);					    \</span>
<span class="cp">            if (X##_f[3] &gt; Y##_f[3])					    \</span>
<span class="cp">              {								    \</span>
<span class="cp">                R##_f[_i] = -2;						    \</span>
<span class="cp">                _FP_FRAC_ADD_4(X, Y, X);				    \</span>
<span class="cp">              }								    \</span>
<span class="cp">          }								    \</span>
<span class="cp">        else								    \</span>
<span class="cp">          {								    \</span>
<span class="cp">            udiv_qrnnd(R##_f[_i], X##_f[3], X##_f[3], X##_f[2], Y##_f[3]);  \</span>
<span class="cp">            umul_ppppmnnn(_m_f[3], _m_f[2], _m_f[1], _m_f[0],		    \</span>
<span class="cp">			  R##_f[_i], Y##_f[2], Y##_f[1], Y##_f[0]);	    \</span>
<span class="cp">            X##_f[2] = X##_f[1];					    \</span>
<span class="cp">            X##_f[1] = X##_f[0];					    \</span>
<span class="cp">            X##_f[0] = _n_f[_i];					    \</span>
<span class="cp">            if (_FP_FRAC_GT_4(_m, X))					    \</span>
<span class="cp">              {								    \</span>
<span class="cp">                R##_f[_i]--;						    \</span>
<span class="cp">                _FP_FRAC_ADD_4(X, Y, X);				    \</span>
<span class="cp">                if (_FP_FRAC_GE_4(X, Y) &amp;&amp; _FP_FRAC_GT_4(_m, X))	    \</span>
<span class="cp">                  {							    \</span>
<span class="cp">		    R##_f[_i]--;					    \</span>
<span class="cp">		    _FP_FRAC_ADD_4(X, Y, X);				    \</span>
<span class="cp">                  }							    \</span>
<span class="cp">              }								    \</span>
<span class="cp">            _FP_FRAC_DEC_4(X, _m);					    \</span>
<span class="cp">            if (!_i)							    \</span>
<span class="cp">	      {								    \</span>
<span class="cp">		if (!_FP_FRAC_EQ_4(X, _m))				    \</span>
<span class="cp">		  R##_f[0] |= _FP_WORK_STICKY;				    \</span>
<span class="cp">		break;							    \</span>
<span class="cp">	      }								    \</span>
<span class="cp">          }								    \</span>
<span class="cp">      }									    \</span>
<span class="cp">  } while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * Square root algorithms:</span>
<span class="cm"> * We have just one right now, maybe Newton approximation</span>
<span class="cm"> * should be added for those machines where division is fast.</span>
<span class="cm"> */</span>
 
<span class="cp">#define _FP_SQRT_MEAT_4(R, S, T, X, q)				\</span>
<span class="cp">  do {								\</span>
<span class="cp">    while (q)							\</span>
<span class="cp">      {								\</span>
<span class="cp">	T##_f[3] = S##_f[3] + q;				\</span>
<span class="cp">	if (T##_f[3] &lt;= X##_f[3])				\</span>
<span class="cp">	  {							\</span>
<span class="cp">	    S##_f[3] = T##_f[3] + q;				\</span>
<span class="cp">	    X##_f[3] -= T##_f[3];				\</span>
<span class="cp">	    R##_f[3] += q;					\</span>
<span class="cp">	  }							\</span>
<span class="cp">	_FP_FRAC_SLL_4(X, 1);					\</span>
<span class="cp">	q &gt;&gt;= 1;						\</span>
<span class="cp">      }								\</span>
<span class="cp">    q = (_FP_W_TYPE)1 &lt;&lt; (_FP_W_TYPE_SIZE - 1);			\</span>
<span class="cp">    while (q)							\</span>
<span class="cp">      {								\</span>
<span class="cp">	T##_f[2] = S##_f[2] + q;				\</span>
<span class="cp">	T##_f[3] = S##_f[3];					\</span>
<span class="cp">	if (T##_f[3] &lt; X##_f[3] || 				\</span>
<span class="cp">	    (T##_f[3] == X##_f[3] &amp;&amp; T##_f[2] &lt;= X##_f[2]))	\</span>
<span class="cp">	  {							\</span>
<span class="cp">	    S##_f[2] = T##_f[2] + q;				\</span>
<span class="cp">	    S##_f[3] += (T##_f[2] &gt; S##_f[2]);			\</span>
<span class="cp">	    __FP_FRAC_DEC_2(X##_f[3], X##_f[2],			\</span>
<span class="cp">			    T##_f[3], T##_f[2]);		\</span>
<span class="cp">	    R##_f[2] += q;					\</span>
<span class="cp">	  }							\</span>
<span class="cp">	_FP_FRAC_SLL_4(X, 1);					\</span>
<span class="cp">	q &gt;&gt;= 1;						\</span>
<span class="cp">      }								\</span>
<span class="cp">    q = (_FP_W_TYPE)1 &lt;&lt; (_FP_W_TYPE_SIZE - 1);			\</span>
<span class="cp">    while (q)							\</span>
<span class="cp">      {								\</span>
<span class="cp">	T##_f[1] = S##_f[1] + q;				\</span>
<span class="cp">	T##_f[2] = S##_f[2];					\</span>
<span class="cp">	T##_f[3] = S##_f[3];					\</span>
<span class="cp">	if (T##_f[3] &lt; X##_f[3] || 				\</span>
<span class="cp">	    (T##_f[3] == X##_f[3] &amp;&amp; (T##_f[2] &lt; X##_f[2] ||	\</span>
<span class="cp">	     (T##_f[2] == X##_f[2] &amp;&amp; T##_f[1] &lt;= X##_f[1]))))	\</span>
<span class="cp">	  {							\</span>
<span class="cp">	    S##_f[1] = T##_f[1] + q;				\</span>
<span class="cp">	    S##_f[2] += (T##_f[1] &gt; S##_f[1]);			\</span>
<span class="cp">	    S##_f[3] += (T##_f[2] &gt; S##_f[2]);			\</span>
<span class="cp">	    __FP_FRAC_DEC_3(X##_f[3], X##_f[2], X##_f[1],	\</span>
<span class="cp">	    		    T##_f[3], T##_f[2], T##_f[1]);	\</span>
<span class="cp">	    R##_f[1] += q;					\</span>
<span class="cp">	  }							\</span>
<span class="cp">	_FP_FRAC_SLL_4(X, 1);					\</span>
<span class="cp">	q &gt;&gt;= 1;						\</span>
<span class="cp">      }								\</span>
<span class="cp">    q = (_FP_W_TYPE)1 &lt;&lt; (_FP_W_TYPE_SIZE - 1);			\</span>
<span class="cp">    while (q != _FP_WORK_ROUND)					\</span>
<span class="cp">      {								\</span>
<span class="cp">	T##_f[0] = S##_f[0] + q;				\</span>
<span class="cp">	T##_f[1] = S##_f[1];					\</span>
<span class="cp">	T##_f[2] = S##_f[2];					\</span>
<span class="cp">	T##_f[3] = S##_f[3];					\</span>
<span class="cp">	if (_FP_FRAC_GE_4(X,T))					\</span>
<span class="cp">	  {							\</span>
<span class="cp">	    S##_f[0] = T##_f[0] + q;				\</span>
<span class="cp">	    S##_f[1] += (T##_f[0] &gt; S##_f[0]);			\</span>
<span class="cp">	    S##_f[2] += (T##_f[1] &gt; S##_f[1]);			\</span>
<span class="cp">	    S##_f[3] += (T##_f[2] &gt; S##_f[2]);			\</span>
<span class="cp">	    _FP_FRAC_DEC_4(X, T);				\</span>
<span class="cp">	    R##_f[0] += q;					\</span>
<span class="cp">	  }							\</span>
<span class="cp">	_FP_FRAC_SLL_4(X, 1);					\</span>
<span class="cp">	q &gt;&gt;= 1;						\</span>
<span class="cp">      }								\</span>
<span class="cp">    if (!_FP_FRAC_ZEROP_4(X))					\</span>
<span class="cp">      {								\</span>
<span class="cp">	if (_FP_FRAC_GT_4(X,S))					\</span>
<span class="cp">	  R##_f[0] |= _FP_WORK_ROUND;				\</span>
<span class="cp">	R##_f[0] |= _FP_WORK_STICKY;				\</span>
<span class="cp">      }								\</span>
<span class="cp">  } while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * Internals </span>
<span class="cm"> */</span>

<span class="cp">#define __FP_FRAC_SET_4(X,I3,I2,I1,I0)					\</span>
<span class="cp">  (X##_f[3] = I3, X##_f[2] = I2, X##_f[1] = I1, X##_f[0] = I0)</span>

<span class="cp">#ifndef __FP_FRAC_ADD_3</span>
<span class="cp">#define __FP_FRAC_ADD_3(r2,r1,r0,x2,x1,x0,y2,y1,y0)		\</span>
<span class="cp">  do {								\</span>
<span class="cp">    int _c1, _c2;							\</span>
<span class="cp">    r0 = x0 + y0;						\</span>
<span class="cp">    _c1 = r0 &lt; x0;						\</span>
<span class="cp">    r1 = x1 + y1;						\</span>
<span class="cp">    _c2 = r1 &lt; x1;						\</span>
<span class="cp">    r1 += _c1;							\</span>
<span class="cp">    _c2 |= r1 &lt; _c1;						\</span>
<span class="cp">    r2 = x2 + y2 + _c2;						\</span>
<span class="cp">  } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __FP_FRAC_ADD_4</span>
<span class="cp">#define __FP_FRAC_ADD_4(r3,r2,r1,r0,x3,x2,x1,x0,y3,y2,y1,y0)	\</span>
<span class="cp">  do {								\</span>
<span class="cp">    int _c1, _c2, _c3;						\</span>
<span class="cp">    r0 = x0 + y0;						\</span>
<span class="cp">    _c1 = r0 &lt; x0;						\</span>
<span class="cp">    r1 = x1 + y1;						\</span>
<span class="cp">    _c2 = r1 &lt; x1;						\</span>
<span class="cp">    r1 += _c1;							\</span>
<span class="cp">    _c2 |= r1 &lt; _c1;						\</span>
<span class="cp">    r2 = x2 + y2;						\</span>
<span class="cp">    _c3 = r2 &lt; x2;						\</span>
<span class="cp">    r2 += _c2;							\</span>
<span class="cp">    _c3 |= r2 &lt; _c2;						\</span>
<span class="cp">    r3 = x3 + y3 + _c3;						\</span>
<span class="cp">  } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __FP_FRAC_SUB_3</span>
<span class="cp">#define __FP_FRAC_SUB_3(r2,r1,r0,x2,x1,x0,y2,y1,y0)		\</span>
<span class="cp">  do {								\</span>
<span class="cp">    int _c1, _c2;							\</span>
<span class="cp">    r0 = x0 - y0;						\</span>
<span class="cp">    _c1 = r0 &gt; x0;						\</span>
<span class="cp">    r1 = x1 - y1;						\</span>
<span class="cp">    _c2 = r1 &gt; x1;						\</span>
<span class="cp">    r1 -= _c1;							\</span>
<span class="cp">    _c2 |= r1 &gt; _c1;						\</span>
<span class="cp">    r2 = x2 - y2 - _c2;						\</span>
<span class="cp">  } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __FP_FRAC_SUB_4</span>
<span class="cp">#define __FP_FRAC_SUB_4(r3,r2,r1,r0,x3,x2,x1,x0,y3,y2,y1,y0)	\</span>
<span class="cp">  do {								\</span>
<span class="cp">    int _c1, _c2, _c3;						\</span>
<span class="cp">    r0 = x0 - y0;						\</span>
<span class="cp">    _c1 = r0 &gt; x0;						\</span>
<span class="cp">    r1 = x1 - y1;						\</span>
<span class="cp">    _c2 = r1 &gt; x1;						\</span>
<span class="cp">    r1 -= _c1;							\</span>
<span class="cp">    _c2 |= r1 &gt; _c1;						\</span>
<span class="cp">    r2 = x2 - y2;						\</span>
<span class="cp">    _c3 = r2 &gt; x2;						\</span>
<span class="cp">    r2 -= _c2;							\</span>
<span class="cp">    _c3 |= r2 &gt; _c2;						\</span>
<span class="cp">    r3 = x3 - y3 - _c3;						\</span>
<span class="cp">  } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __FP_FRAC_DEC_3</span>
<span class="cp">#define __FP_FRAC_DEC_3(x2,x1,x0,y2,y1,y0)				\</span>
<span class="cp">  do {									\</span>
<span class="cp">    UWtype _t0, _t1, _t2;						\</span>
<span class="cp">    _t0 = x0, _t1 = x1, _t2 = x2;					\</span>
<span class="cp">    __FP_FRAC_SUB_3 (x2, x1, x0, _t2, _t1, _t0, y2, y1, y0);		\</span>
<span class="cp">  } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __FP_FRAC_DEC_4</span>
<span class="cp">#define __FP_FRAC_DEC_4(x3,x2,x1,x0,y3,y2,y1,y0)			\</span>
<span class="cp">  do {									\</span>
<span class="cp">    UWtype _t0, _t1, _t2, _t3;						\</span>
<span class="cp">    _t0 = x0, _t1 = x1, _t2 = x2, _t3 = x3;				\</span>
<span class="cp">    __FP_FRAC_SUB_4 (x3,x2,x1,x0,_t3,_t2,_t1,_t0, y3,y2,y1,y0);		\</span>
<span class="cp">  } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __FP_FRAC_ADDI_4</span>
<span class="cp">#define __FP_FRAC_ADDI_4(x3,x2,x1,x0,i)					\</span>
<span class="cp">  do {									\</span>
<span class="cp">    UWtype _t;								\</span>
<span class="cp">    _t = ((x0 += i) &lt; i);						\</span>
<span class="cp">    x1 += _t; _t = (x1 &lt; _t);						\</span>
<span class="cp">    x2 += _t; _t = (x2 &lt; _t);						\</span>
<span class="cp">    x3 += _t;								\</span>
<span class="cp">  } while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/* Convert FP values between word sizes. This appears to be more</span>
<span class="cm"> * complicated than I&#39;d have expected it to be, so these might be</span>
<span class="cm"> * wrong... These macros are in any case somewhat bogus because they</span>
<span class="cm"> * use information about what various FRAC_n variables look like </span>
<span class="cm"> * internally [eg, that 2 word vars are X_f0 and x_f1]. But so do</span>
<span class="cm"> * the ones in op-2.h and op-1.h. </span>
<span class="cm"> */</span>
<span class="cp">#define _FP_FRAC_CONV_1_4(dfs, sfs, D, S)				\</span>
<span class="cp">   do {									\</span>
<span class="cp">     if (S##_c != FP_CLS_NAN)						\</span>
<span class="cp">       _FP_FRAC_SRS_4(S, (_FP_WFRACBITS_##sfs - _FP_WFRACBITS_##dfs),	\</span>
<span class="cp">			  _FP_WFRACBITS_##sfs);				\</span>
<span class="cp">     else								\</span>
<span class="cp">       _FP_FRAC_SRL_4(S, (_FP_WFRACBITS_##sfs - _FP_WFRACBITS_##dfs));	\</span>
<span class="cp">     D##_f = S##_f[0];							\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_FRAC_CONV_2_4(dfs, sfs, D, S)				\</span>
<span class="cp">   do {									\</span>
<span class="cp">     if (S##_c != FP_CLS_NAN)						\</span>
<span class="cp">       _FP_FRAC_SRS_4(S, (_FP_WFRACBITS_##sfs - _FP_WFRACBITS_##dfs),	\</span>
<span class="cp">		      _FP_WFRACBITS_##sfs);				\</span>
<span class="cp">     else								\</span>
<span class="cp">       _FP_FRAC_SRL_4(S, (_FP_WFRACBITS_##sfs - _FP_WFRACBITS_##dfs));	\</span>
<span class="cp">     D##_f0 = S##_f[0];							\</span>
<span class="cp">     D##_f1 = S##_f[1];							\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/* Assembly/disassembly for converting to/from integral types.  </span>
<span class="cm"> * No shifting or overflow handled here.</span>
<span class="cm"> */</span>
<span class="cm">/* Put the FP value X into r, which is an integer of size rsize. */</span>
<span class="cp">#define _FP_FRAC_ASSEMBLE_4(r, X, rsize)				\</span>
<span class="cp">  do {									\</span>
<span class="cp">    if (rsize &lt;= _FP_W_TYPE_SIZE)					\</span>
<span class="cp">      r = X##_f[0];							\</span>
<span class="cp">    else if (rsize &lt;= 2*_FP_W_TYPE_SIZE)				\</span>
<span class="cp">    {									\</span>
<span class="cp">      r = X##_f[1];							\</span>
<span class="cp">      r &lt;&lt;= _FP_W_TYPE_SIZE;						\</span>
<span class="cp">      r += X##_f[0];							\</span>
<span class="cp">    }									\</span>
<span class="cp">    else								\</span>
<span class="cp">    {									\</span>
<span class="cp">      </span><span class="cm">/* I&#39;m feeling lazy so we deal with int == 3words (implausible)*/</span><span class="cp">	\</span>
<span class="cp">      </span><span class="cm">/* and int == 4words as a single case.			 */</span><span class="cp">	\</span>
<span class="cp">      r = X##_f[3];							\</span>
<span class="cp">      r &lt;&lt;= _FP_W_TYPE_SIZE;						\</span>
<span class="cp">      r += X##_f[2];							\</span>
<span class="cp">      r &lt;&lt;= _FP_W_TYPE_SIZE;						\</span>
<span class="cp">      r += X##_f[1];							\</span>
<span class="cp">      r &lt;&lt;= _FP_W_TYPE_SIZE;						\</span>
<span class="cp">      r += X##_f[0];							\</span>
<span class="cp">    }									\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/* &quot;No disassemble Number Five!&quot; */</span>
<span class="cm">/* move an integer of size rsize into X&#39;s fractional part. We rely on</span>
<span class="cm"> * the _f[] array consisting of words of size _FP_W_TYPE_SIZE to avoid</span>
<span class="cm"> * having to mask the values we store into it.</span>
<span class="cm"> */</span>
<span class="cp">#define _FP_FRAC_DISASSEMBLE_4(X, r, rsize)				\</span>
<span class="cp">  do {									\</span>
<span class="cp">    X##_f[0] = r;							\</span>
<span class="cp">    X##_f[1] = (rsize &lt;= _FP_W_TYPE_SIZE ? 0 : r &gt;&gt; _FP_W_TYPE_SIZE);	\</span>
<span class="cp">    X##_f[2] = (rsize &lt;= 2*_FP_W_TYPE_SIZE ? 0 : r &gt;&gt; 2*_FP_W_TYPE_SIZE); \</span>
<span class="cp">    X##_f[3] = (rsize &lt;= 3*_FP_W_TYPE_SIZE ? 0 : r &gt;&gt; 3*_FP_W_TYPE_SIZE); \</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_FRAC_CONV_4_1(dfs, sfs, D, S)				\</span>
<span class="cp">   do {									\</span>
<span class="cp">     D##_f[0] = S##_f;							\</span>
<span class="cp">     D##_f[1] = D##_f[2] = D##_f[3] = 0;				\</span>
<span class="cp">     _FP_FRAC_SLL_4(D, (_FP_WFRACBITS_##dfs - _FP_WFRACBITS_##sfs));	\</span>
<span class="cp">   } while (0)</span>

<span class="cp">#define _FP_FRAC_CONV_4_2(dfs, sfs, D, S)				\</span>
<span class="cp">   do {									\</span>
<span class="cp">     D##_f[0] = S##_f0;							\</span>
<span class="cp">     D##_f[1] = S##_f1;							\</span>
<span class="cp">     D##_f[2] = D##_f[3] = 0;						\</span>
<span class="cp">     _FP_FRAC_SLL_4(D, (_FP_WFRACBITS_##dfs - _FP_WFRACBITS_##sfs));	\</span>
<span class="cp">   } while (0)</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
