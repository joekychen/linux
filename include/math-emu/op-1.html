<!DOCTYPE html>
<html><head><title>joekychen/linux » include › math-emu › op-1.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>op-1.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Software floating-point emulation.</span>
<span class="cm">   Basic one-word fraction declaration and manipulation.</span>
<span class="cm">   Copyright (C) 1997,1998,1999 Free Software Foundation, Inc.</span>
<span class="cm">   This file is part of the GNU C Library.</span>
<span class="cm">   Contributed by Richard Henderson (rth@cygnus.com),</span>
<span class="cm">		  Jakub Jelinek (jj@ultra.linux.cz),</span>
<span class="cm">		  David S. Miller (davem@redhat.com) and</span>
<span class="cm">		  Peter Maydell (pmaydell@chiark.greenend.org.uk).</span>

<span class="cm">   The GNU C Library is free software; you can redistribute it and/or</span>
<span class="cm">   modify it under the terms of the GNU Library General Public License as</span>
<span class="cm">   published by the Free Software Foundation; either version 2 of the</span>
<span class="cm">   License, or (at your option) any later version.</span>

<span class="cm">   The GNU C Library is distributed in the hope that it will be useful,</span>
<span class="cm">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm">   Library General Public License for more details.</span>

<span class="cm">   You should have received a copy of the GNU Library General Public</span>
<span class="cm">   License along with the GNU C Library; see the file COPYING.LIB.  If</span>
<span class="cm">   not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */</span>

<span class="cp">#ifndef    __MATH_EMU_OP_1_H__</span>
<span class="cp">#define    __MATH_EMU_OP_1_H__</span>

<span class="cp">#define _FP_FRAC_DECL_1(X)	_FP_W_TYPE X##_f=0</span>
<span class="cp">#define _FP_FRAC_COPY_1(D,S)	(D##_f = S##_f)</span>
<span class="cp">#define _FP_FRAC_SET_1(X,I)	(X##_f = I)</span>
<span class="cp">#define _FP_FRAC_HIGH_1(X)	(X##_f)</span>
<span class="cp">#define _FP_FRAC_LOW_1(X)	(X##_f)</span>
<span class="cp">#define _FP_FRAC_WORD_1(X,w)	(X##_f)</span>

<span class="cp">#define _FP_FRAC_ADDI_1(X,I)	(X##_f += I)</span>
<span class="cp">#define _FP_FRAC_SLL_1(X,N)			\</span>
<span class="cp">  do {						\</span>
<span class="cp">    if (__builtin_constant_p(N) &amp;&amp; (N) == 1)	\</span>
<span class="cp">      X##_f += X##_f;				\</span>
<span class="cp">    else					\</span>
<span class="cp">      X##_f &lt;&lt;= (N);				\</span>
<span class="cp">  } while (0)</span>
<span class="cp">#define _FP_FRAC_SRL_1(X,N)	(X##_f &gt;&gt;= N)</span>

<span class="cm">/* Right shift with sticky-lsb.  */</span>
<span class="cp">#define _FP_FRAC_SRS_1(X,N,sz)	__FP_FRAC_SRS_1(X##_f, N, sz)</span>

<span class="cp">#define __FP_FRAC_SRS_1(X,N,sz)						\</span>
<span class="cp">   (X = (X &gt;&gt; (N) | (__builtin_constant_p(N) &amp;&amp; (N) == 1		\</span>
<span class="cp">		     ? X &amp; 1 : (X &lt;&lt; (_FP_W_TYPE_SIZE - (N))) != 0)))</span>

<span class="cp">#define _FP_FRAC_ADD_1(R,X,Y)	(R##_f = X##_f + Y##_f)</span>
<span class="cp">#define _FP_FRAC_SUB_1(R,X,Y)	(R##_f = X##_f - Y##_f)</span>
<span class="cp">#define _FP_FRAC_DEC_1(X,Y)	(X##_f -= Y##_f)</span>
<span class="cp">#define _FP_FRAC_CLZ_1(z, X)	__FP_CLZ(z, X##_f)</span>

<span class="cm">/* Predicates */</span>
<span class="cp">#define _FP_FRAC_NEGP_1(X)	((_FP_WS_TYPE)X##_f &lt; 0)</span>
<span class="cp">#define _FP_FRAC_ZEROP_1(X)	(X##_f == 0)</span>
<span class="cp">#define _FP_FRAC_OVERP_1(fs,X)	(X##_f &amp; _FP_OVERFLOW_##fs)</span>
<span class="cp">#define _FP_FRAC_CLEAR_OVERP_1(fs,X)	(X##_f &amp;= ~_FP_OVERFLOW_##fs)</span>
<span class="cp">#define _FP_FRAC_EQ_1(X, Y)	(X##_f == Y##_f)</span>
<span class="cp">#define _FP_FRAC_GE_1(X, Y)	(X##_f &gt;= Y##_f)</span>
<span class="cp">#define _FP_FRAC_GT_1(X, Y)	(X##_f &gt; Y##_f)</span>

<span class="cp">#define _FP_ZEROFRAC_1		0</span>
<span class="cp">#define _FP_MINFRAC_1		1</span>
<span class="cp">#define _FP_MAXFRAC_1		(~(_FP_WS_TYPE)0)</span>

<span class="cm">/*</span>
<span class="cm"> * Unpack the raw bits of a native fp value.  Do not classify or</span>
<span class="cm"> * normalize the data.</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_UNPACK_RAW_1(fs, X, val)				\</span>
<span class="cp">  do {								\</span>
<span class="cp">    union _FP_UNION_##fs _flo; _flo.flt = (val);		\</span>
<span class="cp">								\</span>
<span class="cp">    X##_f = _flo.bits.frac;					\</span>
<span class="cp">    X##_e = _flo.bits.exp;					\</span>
<span class="cp">    X##_s = _flo.bits.sign;					\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_UNPACK_RAW_1_P(fs, X, val)				\</span>
<span class="cp">  do {								\</span>
<span class="cp">    union _FP_UNION_##fs *_flo =				\</span>
<span class="cp">      (union _FP_UNION_##fs *)(val);				\</span>
<span class="cp">								\</span>
<span class="cp">    X##_f = _flo-&gt;bits.frac;					\</span>
<span class="cp">    X##_e = _flo-&gt;bits.exp;					\</span>
<span class="cp">    X##_s = _flo-&gt;bits.sign;					\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Repack the raw bits of a native fp value.</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_PACK_RAW_1(fs, val, X)				\</span>
<span class="cp">  do {								\</span>
<span class="cp">    union _FP_UNION_##fs _flo;					\</span>
<span class="cp">								\</span>
<span class="cp">    _flo.bits.frac = X##_f;					\</span>
<span class="cp">    _flo.bits.exp  = X##_e;					\</span>
<span class="cp">    _flo.bits.sign = X##_s;					\</span>
<span class="cp">								\</span>
<span class="cp">    (val) = _flo.flt;						\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_PACK_RAW_1_P(fs, val, X)				\</span>
<span class="cp">  do {								\</span>
<span class="cp">    union _FP_UNION_##fs *_flo =				\</span>
<span class="cp">      (union _FP_UNION_##fs *)(val);				\</span>
<span class="cp">								\</span>
<span class="cp">    _flo-&gt;bits.frac = X##_f;					\</span>
<span class="cp">    _flo-&gt;bits.exp  = X##_e;					\</span>
<span class="cp">    _flo-&gt;bits.sign = X##_s;					\</span>
<span class="cp">  } while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * Multiplication algorithms:</span>
<span class="cm"> */</span>

<span class="cm">/* Basic.  Assuming the host word size is &gt;= 2*FRACBITS, we can do the</span>
<span class="cm">   multiplication immediately.  */</span>

<span class="cp">#define _FP_MUL_MEAT_1_imm(wfracbits, R, X, Y)				\</span>
<span class="cp">  do {									\</span>
<span class="cp">    R##_f = X##_f * Y##_f;						\</span>
<span class="cp">    </span><span class="cm">/* Normalize since we know where the msb of the multiplicands	\</span>
<span class="cm">       were (bit B), we know that the msb of the of the product is	\</span>
<span class="cm">       at either 2B or 2B-1.  */</span><span class="cp">					\</span>
<span class="cp">    _FP_FRAC_SRS_1(R, wfracbits-1, 2*wfracbits);			\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/* Given a 1W * 1W =&gt; 2W primitive, do the extended multiplication.  */</span>

<span class="cp">#define _FP_MUL_MEAT_1_wide(wfracbits, R, X, Y, doit)			\</span>
<span class="cp">  do {									\</span>
<span class="cp">    _FP_W_TYPE _Z_f0, _Z_f1;						\</span>
<span class="cp">    doit(_Z_f1, _Z_f0, X##_f, Y##_f);					\</span>
<span class="cp">    </span><span class="cm">/* Normalize since we know where the msb of the multiplicands	\</span>
<span class="cm">       were (bit B), we know that the msb of the of the product is	\</span>
<span class="cm">       at either 2B or 2B-1.  */</span><span class="cp">					\</span>
<span class="cp">    _FP_FRAC_SRS_2(_Z, wfracbits-1, 2*wfracbits);			\</span>
<span class="cp">    R##_f = _Z_f0;							\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/* Finally, a simple widening multiply algorithm.  What fun!  */</span>

<span class="cp">#define _FP_MUL_MEAT_1_hard(wfracbits, R, X, Y)				\</span>
<span class="cp">  do {									\</span>
<span class="cp">    _FP_W_TYPE _xh, _xl, _yh, _yl, _z_f0, _z_f1, _a_f0, _a_f1;		\</span>
<span class="cp">									\</span>
<span class="cp">    </span><span class="cm">/* split the words in half */</span><span class="cp">					\</span>
<span class="cp">    _xh = X##_f &gt;&gt; (_FP_W_TYPE_SIZE/2);					\</span>
<span class="cp">    _xl = X##_f &amp; (((_FP_W_TYPE)1 &lt;&lt; (_FP_W_TYPE_SIZE/2)) - 1);		\</span>
<span class="cp">    _yh = Y##_f &gt;&gt; (_FP_W_TYPE_SIZE/2);					\</span>
<span class="cp">    _yl = Y##_f &amp; (((_FP_W_TYPE)1 &lt;&lt; (_FP_W_TYPE_SIZE/2)) - 1);		\</span>
<span class="cp">									\</span>
<span class="cp">    </span><span class="cm">/* multiply the pieces */</span><span class="cp">						\</span>
<span class="cp">    _z_f0 = _xl * _yl;							\</span>
<span class="cp">    _a_f0 = _xh * _yl;							\</span>
<span class="cp">    _a_f1 = _xl * _yh;							\</span>
<span class="cp">    _z_f1 = _xh * _yh;							\</span>
<span class="cp">									\</span>
<span class="cp">    </span><span class="cm">/* reassemble into two full words */</span><span class="cp">				\</span>
<span class="cp">    if ((_a_f0 += _a_f1) &lt; _a_f1)					\</span>
<span class="cp">      _z_f1 += (_FP_W_TYPE)1 &lt;&lt; (_FP_W_TYPE_SIZE/2);			\</span>
<span class="cp">    _a_f1 = _a_f0 &gt;&gt; (_FP_W_TYPE_SIZE/2);				\</span>
<span class="cp">    _a_f0 = _a_f0 &lt;&lt; (_FP_W_TYPE_SIZE/2);				\</span>
<span class="cp">    _FP_FRAC_ADD_2(_z, _z, _a);						\</span>
<span class="cp">									\</span>
<span class="cp">    </span><span class="cm">/* normalize */</span><span class="cp">							\</span>
<span class="cp">    _FP_FRAC_SRS_2(_z, wfracbits - 1, 2*wfracbits);			\</span>
<span class="cp">    R##_f = _z_f0;							\</span>
<span class="cp">  } while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * Division algorithms:</span>
<span class="cm"> */</span>

<span class="cm">/* Basic.  Assuming the host word size is &gt;= 2*FRACBITS, we can do the</span>
<span class="cm">   division immediately.  Give this macro either _FP_DIV_HELP_imm for</span>
<span class="cm">   C primitives or _FP_DIV_HELP_ldiv for the ISO function.  Which you</span>
<span class="cm">   choose will depend on what the compiler does with divrem4.  */</span>

<span class="cp">#define _FP_DIV_MEAT_1_imm(fs, R, X, Y, doit)		\</span>
<span class="cp">  do {							\</span>
<span class="cp">    _FP_W_TYPE _q, _r;					\</span>
<span class="cp">    X##_f &lt;&lt;= (X##_f &lt; Y##_f				\</span>
<span class="cp">	       ? R##_e--, _FP_WFRACBITS_##fs		\</span>
<span class="cp">	       : _FP_WFRACBITS_##fs - 1);		\</span>
<span class="cp">    doit(_q, _r, X##_f, Y##_f);				\</span>
<span class="cp">    R##_f = _q | (_r != 0);				\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/* GCC&#39;s longlong.h defines a 2W / 1W =&gt; (1W,1W) primitive udiv_qrnnd</span>
<span class="cm">   that may be useful in this situation.  This first is for a primitive</span>
<span class="cm">   that requires normalization, the second for one that does not.  Look</span>
<span class="cm">   for UDIV_NEEDS_NORMALIZATION to tell which your machine needs.  */</span>

<span class="cp">#define _FP_DIV_MEAT_1_udiv_norm(fs, R, X, Y)				\</span>
<span class="cp">  do {									\</span>
<span class="cp">    _FP_W_TYPE _nh, _nl, _q, _r, _y;					\</span>
<span class="cp">									\</span>
<span class="cp">    </span><span class="cm">/* Normalize Y -- i.e. make the most significant bit set.  */</span><span class="cp">	\</span>
<span class="cp">    _y = Y##_f &lt;&lt; _FP_WFRACXBITS_##fs;					\</span>
<span class="cp">									\</span>
<span class="cp">    </span><span class="cm">/* Shift X op correspondingly high, that is, up one full word.  */</span><span class="cp">	\</span>
<span class="cp">    if (X##_f &lt; Y##_f)							\</span>
<span class="cp">      {									\</span>
<span class="cp">	R##_e--;							\</span>
<span class="cp">	_nl = 0;							\</span>
<span class="cp">	_nh = X##_f;							\</span>
<span class="cp">      }									\</span>
<span class="cp">    else								\</span>
<span class="cp">      {									\</span>
<span class="cp">	_nl = X##_f &lt;&lt; (_FP_W_TYPE_SIZE - 1);				\</span>
<span class="cp">	_nh = X##_f &gt;&gt; 1;						\</span>
<span class="cp">      }									\</span>
<span class="cp">    									\</span>
<span class="cp">    udiv_qrnnd(_q, _r, _nh, _nl, _y);					\</span>
<span class="cp">    R##_f = _q | (_r != 0);						\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define _FP_DIV_MEAT_1_udiv(fs, R, X, Y)		\</span>
<span class="cp">  do {							\</span>
<span class="cp">    _FP_W_TYPE _nh, _nl, _q, _r;			\</span>
<span class="cp">    if (X##_f &lt; Y##_f)					\</span>
<span class="cp">      {							\</span>
<span class="cp">	R##_e--;					\</span>
<span class="cp">	_nl = X##_f &lt;&lt; _FP_WFRACBITS_##fs;		\</span>
<span class="cp">	_nh = X##_f &gt;&gt; _FP_WFRACXBITS_##fs;		\</span>
<span class="cp">      }							\</span>
<span class="cp">    else						\</span>
<span class="cp">      {							\</span>
<span class="cp">	_nl = X##_f &lt;&lt; (_FP_WFRACBITS_##fs - 1);	\</span>
<span class="cp">	_nh = X##_f &gt;&gt; (_FP_WFRACXBITS_##fs + 1);	\</span>
<span class="cp">      }							\</span>
<span class="cp">    udiv_qrnnd(_q, _r, _nh, _nl, Y##_f);		\</span>
<span class="cp">    R##_f = _q | (_r != 0);				\</span>
<span class="cp">  } while (0)</span>
  
  
<span class="cm">/*</span>
<span class="cm"> * Square root algorithms:</span>
<span class="cm"> * We have just one right now, maybe Newton approximation</span>
<span class="cm"> * should be added for those machines where division is fast.</span>
<span class="cm"> */</span>
 
<span class="cp">#define _FP_SQRT_MEAT_1(R, S, T, X, q)			\</span>
<span class="cp">  do {							\</span>
<span class="cp">    while (q != _FP_WORK_ROUND)				\</span>
<span class="cp">      {							\</span>
<span class="cp">        T##_f = S##_f + q;				\</span>
<span class="cp">        if (T##_f &lt;= X##_f)				\</span>
<span class="cp">          {						\</span>
<span class="cp">            S##_f = T##_f + q;				\</span>
<span class="cp">            X##_f -= T##_f;				\</span>
<span class="cp">            R##_f += q;					\</span>
<span class="cp">          }						\</span>
<span class="cp">        _FP_FRAC_SLL_1(X, 1);				\</span>
<span class="cp">        q &gt;&gt;= 1;					\</span>
<span class="cp">      }							\</span>
<span class="cp">    if (X##_f)						\</span>
<span class="cp">      {							\</span>
<span class="cp">	if (S##_f &lt; X##_f)				\</span>
<span class="cp">	  R##_f |= _FP_WORK_ROUND;			\</span>
<span class="cp">	R##_f |= _FP_WORK_STICKY;			\</span>
<span class="cp">      }							\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Assembly/disassembly for converting to/from integral types.  </span>
<span class="cm"> * No shifting or overflow handled here.</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_FRAC_ASSEMBLE_1(r, X, rsize)	(r = X##_f)</span>
<span class="cp">#define _FP_FRAC_DISASSEMBLE_1(X, r, rsize)	(X##_f = r)</span>


<span class="cm">/*</span>
<span class="cm"> * Convert FP values between word sizes</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_FRAC_CONV_1_1(dfs, sfs, D, S)				\</span>
<span class="cp">  do {									\</span>
<span class="cp">    D##_f = S##_f;							\</span>
<span class="cp">    if (_FP_WFRACBITS_##sfs &gt; _FP_WFRACBITS_##dfs)			\</span>
<span class="cp">      {									\</span>
<span class="cp">	if (S##_c != FP_CLS_NAN)					\</span>
<span class="cp">	  _FP_FRAC_SRS_1(D, (_FP_WFRACBITS_##sfs-_FP_WFRACBITS_##dfs),	\</span>
<span class="cp">			 _FP_WFRACBITS_##sfs);				\</span>
<span class="cp">	else								\</span>
<span class="cp">	  _FP_FRAC_SRL_1(D, (_FP_WFRACBITS_##sfs-_FP_WFRACBITS_##dfs));	\</span>
<span class="cp">      }									\</span>
<span class="cp">    else								\</span>
<span class="cp">      D##_f &lt;&lt;= _FP_WFRACBITS_##dfs - _FP_WFRACBITS_##sfs;		\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#endif </span><span class="cm">/* __MATH_EMU_OP_1_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
