<!DOCTYPE html>
<html><head><title>joekychen/linux » include › asm-generic › pgtable.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pgtable.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_GENERIC_PGTABLE_H</span>
<span class="cp">#define _ASM_GENERIC_PGTABLE_H</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cp">#ifdef CONFIG_MMU</span>

<span class="cp">#include &lt;linux/mm_types.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>

<span class="cp">#ifndef __HAVE_ARCH_PTEP_SET_ACCESS_FLAGS</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ptep_set_access_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span>
				 <span class="n">pte_t</span> <span class="n">entry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PMDP_SET_ACCESS_FLAGS</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pmdp_set_access_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">,</span>
				 <span class="n">pmd_t</span> <span class="n">entry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PTEP_TEST_AND_CLEAR_YOUNG</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ptep_test_and_clear_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
					    <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_young</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">set_pte_at</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">pte_mkold</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PMDP_TEST_AND_CLEAR_YOUNG</span>
<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmdp_test_and_clear_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
					    <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="n">pmd</span> <span class="o">=</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_young</span><span class="p">(</span><span class="n">pmd</span><span class="p">))</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">set_pmd_at</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmdp</span><span class="p">,</span> <span class="n">pmd_mkold</span><span class="p">(</span><span class="n">pmd</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_TRANSPARENT_HUGEPAGE */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmdp_test_and_clear_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
					    <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TRANSPARENT_HUGEPAGE */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PTEP_CLEAR_YOUNG_FLUSH</span>
<span class="kt">int</span> <span class="n">ptep_clear_flush_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PMDP_CLEAR_YOUNG_FLUSH</span>
<span class="kt">int</span> <span class="n">pmdp_clear_flush_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PTEP_GET_AND_CLEAR</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">ptep_get_and_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
				       <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="n">pte_clear</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PMDP_GET_AND_CLEAR</span>
<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pmd_t</span> <span class="nf">pmdp_get_and_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
				       <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="n">pmd</span> <span class="o">=</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">;</span>
	<span class="n">pmd_clear</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmdp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pmd</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TRANSPARENT_HUGEPAGE */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PTEP_GET_AND_CLEAR_FULL</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">ptep_get_and_clear_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">full</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">ptep_get_and_clear</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Some architectures may be able to avoid expensive synchronization</span>
<span class="cm"> * primitives when modifications are made to PTE&#39;s which are already</span>
<span class="cm"> * not present, or in the process of an address space destruction.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __HAVE_ARCH_PTE_CLEAR_NOT_PRESENT_FULL</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pte_clear_not_present_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
					      <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">full</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_clear</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PTEP_CLEAR_FLUSH</span>
<span class="k">extern</span> <span class="n">pte_t</span> <span class="n">ptep_clear_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
			      <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PMDP_CLEAR_FLUSH</span>
<span class="k">extern</span> <span class="n">pmd_t</span> <span class="n">pmdp_clear_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
			      <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PTEP_SET_WRPROTECT</span>
<span class="k">struct</span> <span class="n">mm_struct</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ptep_set_wrprotect</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">old_pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">pte_wrprotect</span><span class="p">(</span><span class="n">old_pte</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PMDP_SET_WRPROTECT</span>
<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pmdp_set_wrprotect</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="n">old_pmd</span> <span class="o">=</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">;</span>
	<span class="n">set_pmd_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmdp</span><span class="p">,</span> <span class="n">pmd_wrprotect</span><span class="p">(</span><span class="n">old_pmd</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_TRANSPARENT_HUGEPAGE */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pmdp_set_wrprotect</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TRANSPARENT_HUGEPAGE */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PMDP_SPLITTING_FLUSH</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pmdp_splitting_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PTE_SAME</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_same</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte_a</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte_b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte_a</span><span class="p">)</span> <span class="o">==</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte_b</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PMD_SAME</span>
<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_same</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd_a</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="n">pmd_b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd_a</span><span class="p">)</span> <span class="o">==</span> <span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd_b</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_TRANSPARENT_HUGEPAGE */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_same</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd_a</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="n">pmd_b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TRANSPARENT_HUGEPAGE */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PAGE_TEST_AND_CLEAR_DIRTY</span>
<span class="cp">#define page_test_and_clear_dirty(pfn, mapped)	(0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PAGE_TEST_AND_CLEAR_DIRTY</span>
<span class="cp">#define pte_maybe_dirty(pte)		pte_dirty(pte)</span>
<span class="cp">#else</span>
<span class="cp">#define pte_maybe_dirty(pte)		(1)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PAGE_TEST_AND_CLEAR_YOUNG</span>
<span class="cp">#define page_test_and_clear_young(pfn) (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_PGD_OFFSET_GATE</span>
<span class="cp">#define pgd_offset_gate(mm, addr)	pgd_offset(mm, addr)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_ARCH_MOVE_PTE</span>
<span class="cp">#define move_pte(pte, prot, old_addr, new_addr)	(pte)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef flush_tlb_fix_spurious_fault</span>
<span class="cp">#define flush_tlb_fix_spurious_fault(vma, address) flush_tlb_page(vma, address)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef pgprot_noncached</span>
<span class="cp">#define pgprot_noncached(prot)	(prot)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef pgprot_writecombine</span>
<span class="cp">#define pgprot_writecombine pgprot_noncached</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * When walking page tables, get the address of the next boundary,</span>
<span class="cm"> * or the end address of the range if that comes earlier.  Although no</span>
<span class="cm"> * vma end wraps to 0, rounded up __boundary may wrap to 0 throughout.</span>
<span class="cm"> */</span>

<span class="cp">#define pgd_addr_end(addr, end)						\</span>
<span class="cp">({	unsigned long __boundary = ((addr) + PGDIR_SIZE) &amp; PGDIR_MASK;	\</span>
<span class="cp">	(__boundary - 1 &lt; (end) - 1)? __boundary: (end);		\</span>
<span class="cp">})</span>

<span class="cp">#ifndef pud_addr_end</span>
<span class="cp">#define pud_addr_end(addr, end)						\</span>
<span class="cp">({	unsigned long __boundary = ((addr) + PUD_SIZE) &amp; PUD_MASK;	\</span>
<span class="cp">	(__boundary - 1 &lt; (end) - 1)? __boundary: (end);		\</span>
<span class="cp">})</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef pmd_addr_end</span>
<span class="cp">#define pmd_addr_end(addr, end)						\</span>
<span class="cp">({	unsigned long __boundary = ((addr) + PMD_SIZE) &amp; PMD_MASK;	\</span>
<span class="cp">	(__boundary - 1 &lt; (end) - 1)? __boundary: (end);		\</span>
<span class="cp">})</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * When walking page tables, we usually want to skip any p?d_none entries;</span>
<span class="cm"> * and any p?d_bad entries - reporting the error before resetting to none.</span>
<span class="cm"> * Do the tests inline, but report and clear the bad entry in mm/memory.c.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">pgd_clear_bad</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pud_clear_bad</span><span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pmd_clear_bad</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pgd_none_or_clear_bad</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pgd_bad</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pgd_clear_bad</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pud_none_or_clear_bad</span><span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pud_bad</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pud_clear_bad</span><span class="p">(</span><span class="n">pud</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_none_or_clear_bad</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pmd_bad</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pmd_clear_bad</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">__ptep_modify_prot_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
					     <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the current pte state, but zero it out to make it</span>
<span class="cm">	 * non-present, preventing the hardware from asynchronously</span>
<span class="cm">	 * updating it.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">ptep_get_and_clear</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__ptep_modify_prot_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
					     <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The pte is non-present, so there&#39;s no hardware state to</span>
<span class="cm">	 * preserve.</span>
<span class="cm">	 */</span>
	<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef __HAVE_ARCH_PTEP_MODIFY_PROT_TRANSACTION</span>
<span class="cm">/*</span>
<span class="cm"> * Start a pte protection read-modify-write transaction, which</span>
<span class="cm"> * protects against asynchronous hardware modifications to the pte.</span>
<span class="cm"> * The intention is not to prevent the hardware from making pte</span>
<span class="cm"> * updates, but to prevent any updates it may make from being lost.</span>
<span class="cm"> *</span>
<span class="cm"> * This does not protect against other software modifications of the</span>
<span class="cm"> * pte; the appropriate pte lock must be held over the transation.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this interface is intended to be batchable, meaning that</span>
<span class="cm"> * ptep_modify_prot_commit may not actually update the pte, but merely</span>
<span class="cm"> * queue the update to be done at some later time.  The update must be</span>
<span class="cm"> * actually committed before the pte lock is released, however.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">ptep_modify_prot_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
					   <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__ptep_modify_prot_start</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Commit an update to a pte, leaving any hardware-controlled bits in</span>
<span class="cm"> * the PTE unmodified.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ptep_modify_prot_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
					   <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__ptep_modify_prot_commit</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __HAVE_ARCH_PTEP_MODIFY_PROT_TRANSACTION */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MMU */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * A facility to provide lazy MMU batching.  This allows PTE updates and</span>
<span class="cm"> * page invalidations to be delayed until a call to leave lazy MMU mode</span>
<span class="cm"> * is issued.  Some architectures may benefit from doing this, and it is</span>
<span class="cm"> * beneficial for both shadow and direct mode hypervisors, which may batch</span>
<span class="cm"> * the PTE updates which happen during this window.  Note that using this</span>
<span class="cm"> * interface requires that read hazards be removed from the code.  A read</span>
<span class="cm"> * hazard could result in the direct mode hypervisor case, since the actual</span>
<span class="cm"> * write to the page tables may not yet have taken place, so reads though</span>
<span class="cm"> * a raw PTE pointer after it has been modified are not guaranteed to be</span>
<span class="cm"> * up to date.  This mode can only be entered and left under the protection of</span>
<span class="cm"> * the page table locks for all page tables which may be modified.  In the UP</span>
<span class="cm"> * case, this is required so that preemption is disabled, and in the SMP case,</span>
<span class="cm"> * it must synchronize the delayed page table writes properly on other CPUs.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __HAVE_ARCH_ENTER_LAZY_MMU_MODE</span>
<span class="cp">#define arch_enter_lazy_mmu_mode()	do {} while (0)</span>
<span class="cp">#define arch_leave_lazy_mmu_mode()	do {} while (0)</span>
<span class="cp">#define arch_flush_lazy_mmu_mode()	do {} while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * A facility to provide batching of the reload of page tables and</span>
<span class="cm"> * other process state with the actual context switch code for</span>
<span class="cm"> * paravirtualized guests.  By convention, only one of the batched</span>
<span class="cm"> * update (lazy) modes (CPU, MMU) should be active at any given time,</span>
<span class="cm"> * entry should never be nested, and entry and exits should always be</span>
<span class="cm"> * paired.  This is for sanity of maintaining and reasoning about the</span>
<span class="cm"> * kernel code.  In this case, the exit (end of the context switch) is</span>
<span class="cm"> * in architecture-specific code, and so doesn&#39;t need a generic</span>
<span class="cm"> * definition.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __HAVE_ARCH_START_CONTEXT_SWITCH</span>
<span class="cp">#define arch_start_context_switch(prev)	do {} while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_PFNMAP_TRACKING</span>
<span class="cm">/*</span>
<span class="cm"> * Interface that can be used by architecture code to keep track of</span>
<span class="cm"> * memory type of pfn mappings (remap_pfn_range, vm_insert_pfn)</span>
<span class="cm"> *</span>
<span class="cm"> * track_pfn_vma_new is called when a _new_ pfn mapping is being established</span>
<span class="cm"> * for physical range indicated by pfn and size.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">track_pfn_vma_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="o">*</span><span class="n">prot</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Interface that can be used by architecture code to keep track of</span>
<span class="cm"> * memory type of pfn mappings (remap_pfn_range, vm_insert_pfn)</span>
<span class="cm"> *</span>
<span class="cm"> * track_pfn_vma_copy is called when vma that is covering the pfnmap gets</span>
<span class="cm"> * copied through copy_page_range().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">track_pfn_vma_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Interface that can be used by architecture code to keep track of</span>
<span class="cm"> * memory type of pfn mappings (remap_pfn_range, vm_insert_pfn)</span>
<span class="cm"> *</span>
<span class="cm"> * untrack_pfn_vma is called while unmapping a pfnmap for a region.</span>
<span class="cm"> * untrack can be called for a specific region indicated by pfn and size or</span>
<span class="cm"> * can be for the entire vma (in which case size can be zero).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">untrack_pfn_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">track_pfn_vma_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="o">*</span><span class="n">prot</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">track_pfn_vma_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">untrack_pfn_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MMU</span>

<span class="cp">#ifndef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_trans_huge</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_trans_splitting</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#ifndef __HAVE_ARCH_PMD_WRITE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_write</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __HAVE_ARCH_PMD_WRITE */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TRANSPARENT_HUGEPAGE */</span><span class="cp"></span>

<span class="cp">#ifndef pmd_read_atomic</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pmd_t</span> <span class="nf">pmd_read_atomic</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Depend on compiler for an atomic pmd read. NOTE: this is</span>
<span class="cm">	 * only going to work, if the pmdval_t isn&#39;t larger than</span>
<span class="cm">	 * an unsigned long.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * This function is meant to be used by sites walking pagetables with</span>
<span class="cm"> * the mmap_sem hold in read mode to protect against MADV_DONTNEED and</span>
<span class="cm"> * transhuge page faults. MADV_DONTNEED can convert a transhuge pmd</span>
<span class="cm"> * into a null pmd and the transhuge page fault can convert a null pmd</span>
<span class="cm"> * into an hugepmd or into a regular pmd (if the hugepage allocation</span>
<span class="cm"> * fails). While holding the mmap_sem in read mode the pmd becomes</span>
<span class="cm"> * stable and stops changing under us only if it&#39;s not null and not a</span>
<span class="cm"> * transhuge pmd. When those races occurs and this function makes a</span>
<span class="cm"> * difference vs the standard pmd_none_or_clear_bad, the result is</span>
<span class="cm"> * undefined so behaving like if the pmd was none is safe (because it</span>
<span class="cm"> * can return none anyway). The compiler level barrier() is critically</span>
<span class="cm"> * important to compute the two checks atomically on the same pmdval.</span>
<span class="cm"> *</span>
<span class="cm"> * For 32bit kernels with a 64bit large pmd_t this automatically takes</span>
<span class="cm"> * care of reading the pmd atomically to avoid SMP race conditions</span>
<span class="cm"> * against pmd_populate() when the mmap_sem is hold for reading by the</span>
<span class="cm"> * caller (a special atomic read not done by &quot;gcc&quot; as in the generic</span>
<span class="cm"> * version above, is also needed when THP is disabled because the page</span>
<span class="cm"> * fault can populate the pmd from under us).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_none_or_trans_huge_or_clear_bad</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="n">pmdval</span> <span class="o">=</span> <span class="n">pmd_read_atomic</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The barrier will stabilize the pmdval in a register or on</span>
<span class="cm">	 * the stack so that it will stop changing under the code.</span>
<span class="cm">	 *</span>
<span class="cm">	 * When CONFIG_TRANSPARENT_HUGEPAGE=y on x86 32bit PAE,</span>
<span class="cm">	 * pmd_read_atomic is allowed to return a not atomic pmdval</span>
<span class="cm">	 * (for example pointing to an hugepage that has never been</span>
<span class="cm">	 * mapped in the pmd). The below checks will only care about</span>
<span class="cm">	 * the low part of the pmd with 32bit PAE x86 anyway, with the</span>
<span class="cm">	 * exception of pmd_none(). So the important thing is that if</span>
<span class="cm">	 * the low part of the pmd is found null, the high part will</span>
<span class="cm">	 * be also null or the pmd_none() check below would be</span>
<span class="cm">	 * confused.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
	<span class="n">barrier</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="n">pmdval</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pmd_bad</span><span class="p">(</span><span class="n">pmdval</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="n">pmdval</span><span class="p">))</span>
			<span class="n">pmd_clear_bad</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is a noop if Transparent Hugepage Support is not built into</span>
<span class="cm"> * the kernel. Otherwise it is equivalent to</span>
<span class="cm"> * pmd_none_or_trans_huge_or_clear_bad(), and shall only be called in</span>
<span class="cm"> * places that already verified the pmd is not none and they want to</span>
<span class="cm"> * walk ptes while holding the mmap sem in read mode (write mode don&#39;t</span>
<span class="cm"> * need this). If THP is not enabled, the pmd can&#39;t go away under the</span>
<span class="cm"> * code even if MADV_DONTNEED runs, but if THP is enabled we need to</span>
<span class="cm"> * run a pmd_trans_unstable before walking the ptes after</span>
<span class="cm"> * split_huge_page_pmd returns (because it may have run when the pmd</span>
<span class="cm"> * become null, but then a page fault can map in a THP and not a</span>
<span class="cm"> * regular page).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_trans_unstable</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
	<span class="k">return</span> <span class="n">pmd_none_or_trans_huge_or_clear_bad</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_MMU */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_GENERIC_PGTABLE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
