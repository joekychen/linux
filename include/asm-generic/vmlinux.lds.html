<!DOCTYPE html>
<html><head><title>joekychen/linux » include › asm-generic › vmlinux.lds.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>vmlinux.lds.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Helper macros to support writing architecture specific</span>
<span class="cm"> * linker scripts.</span>
<span class="cm"> *</span>
<span class="cm"> * A minimal linker scripts has following content:</span>
<span class="cm"> * [This is a sample, architectures may have special requiriements]</span>
<span class="cm"> *</span>
<span class="cm"> * OUTPUT_FORMAT(...)</span>
<span class="cm"> * OUTPUT_ARCH(...)</span>
<span class="cm"> * ENTRY(...)</span>
<span class="cm"> * SECTIONS</span>
<span class="cm"> * {</span>
<span class="cm"> *	. = START;</span>
<span class="cm"> *	__init_begin = .;</span>
<span class="cm"> *	HEAD_TEXT_SECTION</span>
<span class="cm"> *	INIT_TEXT_SECTION(PAGE_SIZE)</span>
<span class="cm"> *	INIT_DATA_SECTION(...)</span>
<span class="cm"> *	PERCPU_SECTION(CACHELINE_SIZE)</span>
<span class="cm"> *	__init_end = .;</span>
<span class="cm"> *</span>
<span class="cm"> *	_stext = .;</span>
<span class="cm"> *	TEXT_SECTION = 0</span>
<span class="cm"> *	_etext = .;</span>
<span class="cm"> *</span>
<span class="cm"> *      _sdata = .;</span>
<span class="cm"> *	RO_DATA_SECTION(PAGE_SIZE)</span>
<span class="cm"> *	RW_DATA_SECTION(...)</span>
<span class="cm"> *	_edata = .;</span>
<span class="cm"> *</span>
<span class="cm"> *	EXCEPTION_TABLE(...)</span>
<span class="cm"> *	NOTES</span>
<span class="cm"> *</span>
<span class="cm"> *	BSS_SECTION(0, 0, 0)</span>
<span class="cm"> *	_end = .;</span>
<span class="cm"> *</span>
<span class="cm"> *	STABS_DEBUG</span>
<span class="cm"> *	DWARF_DEBUG</span>
<span class="cm"> *</span>
<span class="cm"> *	DISCARDS		// must be the last</span>
<span class="cm"> * }</span>
<span class="cm"> *</span>
<span class="cm"> * [__init_begin, __init_end] is the init section that may be freed after init</span>
<span class="cm"> * [_stext, _etext] is the text section</span>
<span class="cm"> * [_sdata, _edata] is the data section</span>
<span class="cm"> *</span>
<span class="cm"> * Some of the included output section have their own set of constants.</span>
<span class="cm"> * Examples are: [__initramfs_start, __initramfs_end] for initramfs and</span>
<span class="cm"> *               [__nosave_begin, __nosave_end] for the nosave data</span>
<span class="cm"> */</span>

<span class="cp">#ifndef LOAD_OFFSET</span>
<span class="cp">#define LOAD_OFFSET 0</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef SYMBOL_PREFIX</span>
<span class="cp">#define VMLINUX_SYMBOL(sym) sym</span>
<span class="cp">#else</span>
<span class="cp">#define PASTE2(x,y) x##y</span>
<span class="cp">#define PASTE(x,y) PASTE2(x,y)</span>
<span class="cp">#define VMLINUX_SYMBOL(sym) PASTE(SYMBOL_PREFIX, sym)</span>
<span class="cp">#endif</span>

<span class="cm">/* Align . to a 8 byte boundary equals to maximum function alignment. */</span>
<span class="cp">#define ALIGN_FUNCTION()  . = ALIGN(8)</span>

<span class="cm">/*</span>
<span class="cm"> * Align to a 32 byte boundary equal to the</span>
<span class="cm"> * alignment gcc 4.5 uses for a struct</span>
<span class="cm"> */</span>
<span class="cp">#define STRUCT_ALIGNMENT 32</span>
<span class="cp">#define STRUCT_ALIGN() . = ALIGN(STRUCT_ALIGNMENT)</span>

<span class="cm">/* The actual configuration determine if the init/exit sections</span>
<span class="cm"> * are handled as text/data or they can be discarded (which</span>
<span class="cm"> * often happens at runtime)</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_HOTPLUG</span>
<span class="cp">#define DEV_KEEP(sec)    *(.dev##sec)</span>
<span class="cp">#define DEV_DISCARD(sec)</span>
<span class="cp">#else</span>
<span class="cp">#define DEV_KEEP(sec)</span>
<span class="cp">#define DEV_DISCARD(sec) *(.dev##sec)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="cp">#define CPU_KEEP(sec)    *(.cpu##sec)</span>
<span class="cp">#define CPU_DISCARD(sec)</span>
<span class="cp">#else</span>
<span class="cp">#define CPU_KEEP(sec)</span>
<span class="cp">#define CPU_DISCARD(sec) *(.cpu##sec)</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_MEMORY_HOTPLUG)</span>
<span class="cp">#define MEM_KEEP(sec)    *(.mem##sec)</span>
<span class="cp">#define MEM_DISCARD(sec)</span>
<span class="cp">#else</span>
<span class="cp">#define MEM_KEEP(sec)</span>
<span class="cp">#define MEM_DISCARD(sec) *(.mem##sec)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_FTRACE_MCOUNT_RECORD</span>
<span class="cp">#define MCOUNT_REC()	. = ALIGN(8);				\</span>
<span class="cp">			VMLINUX_SYMBOL(__start_mcount_loc) = .; \</span>
<span class="cp">			*(__mcount_loc)				\</span>
<span class="cp">			VMLINUX_SYMBOL(__stop_mcount_loc) = .;</span>
<span class="cp">#else</span>
<span class="cp">#define MCOUNT_REC()</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_TRACE_BRANCH_PROFILING</span>
<span class="cp">#define LIKELY_PROFILE()	VMLINUX_SYMBOL(__start_annotated_branch_profile) = .; \</span>
<span class="cp">				*(_ftrace_annotated_branch)			      \</span>
<span class="cp">				VMLINUX_SYMBOL(__stop_annotated_branch_profile) = .;</span>
<span class="cp">#else</span>
<span class="cp">#define LIKELY_PROFILE()</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PROFILE_ALL_BRANCHES</span>
<span class="cp">#define BRANCH_PROFILE()	VMLINUX_SYMBOL(__start_branch_profile) = .;   \</span>
<span class="cp">				*(_ftrace_branch)			      \</span>
<span class="cp">				VMLINUX_SYMBOL(__stop_branch_profile) = .;</span>
<span class="cp">#else</span>
<span class="cp">#define BRANCH_PROFILE()</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_EVENT_TRACING</span>
<span class="cp">#define FTRACE_EVENTS()	. = ALIGN(8);					\</span>
<span class="cp">			VMLINUX_SYMBOL(__start_ftrace_events) = .;	\</span>
<span class="cp">			*(_ftrace_events)				\</span>
<span class="cp">			VMLINUX_SYMBOL(__stop_ftrace_events) = .;</span>
<span class="cp">#else</span>
<span class="cp">#define FTRACE_EVENTS()</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_TRACING</span>
<span class="cp">#define TRACE_PRINTKS() VMLINUX_SYMBOL(__start___trace_bprintk_fmt) = .;      \</span>
<span class="cp">			 *(__trace_printk_fmt) </span><span class="cm">/* Trace_printk fmt&#39; pointer */</span><span class="cp"> \</span>
<span class="cp">			 VMLINUX_SYMBOL(__stop___trace_bprintk_fmt) = .;</span>
<span class="cp">#else</span>
<span class="cp">#define TRACE_PRINTKS()</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_FTRACE_SYSCALLS</span>
<span class="cp">#define TRACE_SYSCALLS() . = ALIGN(8);					\</span>
<span class="cp">			 VMLINUX_SYMBOL(__start_syscalls_metadata) = .;	\</span>
<span class="cp">			 *(__syscalls_metadata)				\</span>
<span class="cp">			 VMLINUX_SYMBOL(__stop_syscalls_metadata) = .;</span>
<span class="cp">#else</span>
<span class="cp">#define TRACE_SYSCALLS()</span>
<span class="cp">#endif</span>


<span class="cp">#define KERNEL_DTB()							\</span>
<span class="cp">	STRUCT_ALIGN();							\</span>
<span class="cp">	VMLINUX_SYMBOL(__dtb_start) = .;				\</span>
<span class="cp">	*(.dtb.init.rodata)						\</span>
<span class="cp">	VMLINUX_SYMBOL(__dtb_end) = .;</span>

<span class="cm">/* .data section */</span>
<span class="cp">#define DATA_DATA							\</span>
<span class="cp">	*(.data)							\</span>
<span class="cp">	*(.ref.data)							\</span>
<span class="cp">	*(.data..shared_aligned) </span><span class="cm">/* percpu related */</span><span class="cp">			\</span>
<span class="cp">	DEV_KEEP(init.data)						\</span>
<span class="cp">	DEV_KEEP(exit.data)						\</span>
<span class="cp">	CPU_KEEP(init.data)						\</span>
<span class="cp">	CPU_KEEP(exit.data)						\</span>
<span class="cp">	MEM_KEEP(init.data)						\</span>
<span class="cp">	MEM_KEEP(exit.data)						\</span>
<span class="cp">	*(.data.unlikely)						\</span>
<span class="cp">	STRUCT_ALIGN();							\</span>
<span class="cp">	*(__tracepoints)						\</span>
<span class="cp">	</span><span class="cm">/* implement dynamic printk debug */</span><span class="cp">				\</span>
<span class="cp">	. = ALIGN(8);                                                   \</span>
<span class="cp">	VMLINUX_SYMBOL(__start___jump_table) = .;                       \</span>
<span class="cp">	*(__jump_table)                                                 \</span>
<span class="cp">	VMLINUX_SYMBOL(__stop___jump_table) = .;                        \</span>
<span class="cp">	. = ALIGN(8);							\</span>
<span class="cp">	VMLINUX_SYMBOL(__start___verbose) = .;                          \</span>
<span class="cp">	*(__verbose)                                                    \</span>
<span class="cp">	VMLINUX_SYMBOL(__stop___verbose) = .;				\</span>
<span class="cp">	LIKELY_PROFILE()		       				\</span>
<span class="cp">	BRANCH_PROFILE()						\</span>
<span class="cp">	TRACE_PRINTKS()</span>

<span class="cm">/*</span>
<span class="cm"> * Data section helpers</span>
<span class="cm"> */</span>
<span class="cp">#define NOSAVE_DATA							\</span>
<span class="cp">	. = ALIGN(PAGE_SIZE);						\</span>
<span class="cp">	VMLINUX_SYMBOL(__nosave_begin) = .;				\</span>
<span class="cp">	*(.data..nosave)						\</span>
<span class="cp">	. = ALIGN(PAGE_SIZE);						\</span>
<span class="cp">	VMLINUX_SYMBOL(__nosave_end) = .;</span>

<span class="cp">#define PAGE_ALIGNED_DATA(page_align)					\</span>
<span class="cp">	. = ALIGN(page_align);						\</span>
<span class="cp">	*(.data..page_aligned)</span>

<span class="cp">#define READ_MOSTLY_DATA(align)						\</span>
<span class="cp">	. = ALIGN(align);						\</span>
<span class="cp">	*(.data..read_mostly)						\</span>
<span class="cp">	. = ALIGN(align);</span>

<span class="cp">#define CACHELINE_ALIGNED_DATA(align)					\</span>
<span class="cp">	. = ALIGN(align);						\</span>
<span class="cp">	*(.data..cacheline_aligned)</span>

<span class="cp">#define INIT_TASK_DATA(align)						\</span>
<span class="cp">	. = ALIGN(align);						\</span>
<span class="cp">	*(.data..init_task)</span>

<span class="cm">/*</span>
<span class="cm"> * Read only Data</span>
<span class="cm"> */</span>
<span class="cp">#define RO_DATA_SECTION(align)						\</span>
<span class="cp">	. = ALIGN((align));						\</span>
<span class="cp">	.rodata           : AT(ADDR(.rodata) - LOAD_OFFSET) {		\</span>
<span class="cp">		VMLINUX_SYMBOL(__start_rodata) = .;			\</span>
<span class="cp">		*(.rodata) *(.rodata.*)					\</span>
<span class="cp">		*(__vermagic)		</span><span class="cm">/* Kernel version magic */</span><span class="cp">	\</span>
<span class="cp">		. = ALIGN(8);						\</span>
<span class="cp">		VMLINUX_SYMBOL(__start___tracepoints_ptrs) = .;		\</span>
<span class="cp">		*(__tracepoints_ptrs)	</span><span class="cm">/* Tracepoints: pointer array */</span><span class="cp">\</span>
<span class="cp">		VMLINUX_SYMBOL(__stop___tracepoints_ptrs) = .;		\</span>
<span class="cp">		*(__tracepoints_strings)</span><span class="cm">/* Tracepoints: strings */</span><span class="cp">	\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	.rodata1          : AT(ADDR(.rodata1) - LOAD_OFFSET) {		\</span>
<span class="cp">		*(.rodata1)						\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	BUG_TABLE							\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* PCI quirks */</span><span class="cp">						\</span>
<span class="cp">	.pci_fixup        : AT(ADDR(.pci_fixup) - LOAD_OFFSET) {	\</span>
<span class="cp">		VMLINUX_SYMBOL(__start_pci_fixups_early) = .;		\</span>
<span class="cp">		*(.pci_fixup_early)					\</span>
<span class="cp">		VMLINUX_SYMBOL(__end_pci_fixups_early) = .;		\</span>
<span class="cp">		VMLINUX_SYMBOL(__start_pci_fixups_header) = .;		\</span>
<span class="cp">		*(.pci_fixup_header)					\</span>
<span class="cp">		VMLINUX_SYMBOL(__end_pci_fixups_header) = .;		\</span>
<span class="cp">		VMLINUX_SYMBOL(__start_pci_fixups_final) = .;		\</span>
<span class="cp">		*(.pci_fixup_final)					\</span>
<span class="cp">		VMLINUX_SYMBOL(__end_pci_fixups_final) = .;		\</span>
<span class="cp">		VMLINUX_SYMBOL(__start_pci_fixups_enable) = .;		\</span>
<span class="cp">		*(.pci_fixup_enable)					\</span>
<span class="cp">		VMLINUX_SYMBOL(__end_pci_fixups_enable) = .;		\</span>
<span class="cp">		VMLINUX_SYMBOL(__start_pci_fixups_resume) = .;		\</span>
<span class="cp">		*(.pci_fixup_resume)					\</span>
<span class="cp">		VMLINUX_SYMBOL(__end_pci_fixups_resume) = .;		\</span>
<span class="cp">		VMLINUX_SYMBOL(__start_pci_fixups_resume_early) = .;	\</span>
<span class="cp">		*(.pci_fixup_resume_early)				\</span>
<span class="cp">		VMLINUX_SYMBOL(__end_pci_fixups_resume_early) = .;	\</span>
<span class="cp">		VMLINUX_SYMBOL(__start_pci_fixups_suspend) = .;		\</span>
<span class="cp">		*(.pci_fixup_suspend)					\</span>
<span class="cp">		VMLINUX_SYMBOL(__end_pci_fixups_suspend) = .;		\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* Built-in firmware blobs */</span><span class="cp">					\</span>
<span class="cp">	.builtin_fw        : AT(ADDR(.builtin_fw) - LOAD_OFFSET) {	\</span>
<span class="cp">		VMLINUX_SYMBOL(__start_builtin_fw) = .;			\</span>
<span class="cp">		*(.builtin_fw)						\</span>
<span class="cp">		VMLINUX_SYMBOL(__end_builtin_fw) = .;			\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* RapidIO route ops */</span><span class="cp">						\</span>
<span class="cp">	.rio_ops        : AT(ADDR(.rio_ops) - LOAD_OFFSET) {		\</span>
<span class="cp">		VMLINUX_SYMBOL(__start_rio_switch_ops) = .;		\</span>
<span class="cp">		*(.rio_switch_ops)					\</span>
<span class="cp">		VMLINUX_SYMBOL(__end_rio_switch_ops) = .;		\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	TRACEDATA							\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* Kernel symbol table: Normal symbols */</span><span class="cp">			\</span>
<span class="cp">	__ksymtab         : AT(ADDR(__ksymtab) - LOAD_OFFSET) {		\</span>
<span class="cp">		VMLINUX_SYMBOL(__start___ksymtab) = .;			\</span>
<span class="cp">		*(SORT(___ksymtab+*))					\</span>
<span class="cp">		VMLINUX_SYMBOL(__stop___ksymtab) = .;			\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* Kernel symbol table: GPL-only symbols */</span><span class="cp">			\</span>
<span class="cp">	__ksymtab_gpl     : AT(ADDR(__ksymtab_gpl) - LOAD_OFFSET) {	\</span>
<span class="cp">		VMLINUX_SYMBOL(__start___ksymtab_gpl) = .;		\</span>
<span class="cp">		*(SORT(___ksymtab_gpl+*))				\</span>
<span class="cp">		VMLINUX_SYMBOL(__stop___ksymtab_gpl) = .;		\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* Kernel symbol table: Normal unused symbols */</span><span class="cp">		\</span>
<span class="cp">	__ksymtab_unused  : AT(ADDR(__ksymtab_unused) - LOAD_OFFSET) {	\</span>
<span class="cp">		VMLINUX_SYMBOL(__start___ksymtab_unused) = .;		\</span>
<span class="cp">		*(SORT(___ksymtab_unused+*))				\</span>
<span class="cp">		VMLINUX_SYMBOL(__stop___ksymtab_unused) = .;		\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* Kernel symbol table: GPL-only unused symbols */</span><span class="cp">		\</span>
<span class="cp">	__ksymtab_unused_gpl : AT(ADDR(__ksymtab_unused_gpl) - LOAD_OFFSET) { \</span>
<span class="cp">		VMLINUX_SYMBOL(__start___ksymtab_unused_gpl) = .;	\</span>
<span class="cp">		*(SORT(___ksymtab_unused_gpl+*))			\</span>
<span class="cp">		VMLINUX_SYMBOL(__stop___ksymtab_unused_gpl) = .;	\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* Kernel symbol table: GPL-future-only symbols */</span><span class="cp">		\</span>
<span class="cp">	__ksymtab_gpl_future : AT(ADDR(__ksymtab_gpl_future) - LOAD_OFFSET) { \</span>
<span class="cp">		VMLINUX_SYMBOL(__start___ksymtab_gpl_future) = .;	\</span>
<span class="cp">		*(SORT(___ksymtab_gpl_future+*))			\</span>
<span class="cp">		VMLINUX_SYMBOL(__stop___ksymtab_gpl_future) = .;	\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* Kernel symbol table: Normal symbols */</span><span class="cp">			\</span>
<span class="cp">	__kcrctab         : AT(ADDR(__kcrctab) - LOAD_OFFSET) {		\</span>
<span class="cp">		VMLINUX_SYMBOL(__start___kcrctab) = .;			\</span>
<span class="cp">		*(SORT(___kcrctab+*))					\</span>
<span class="cp">		VMLINUX_SYMBOL(__stop___kcrctab) = .;			\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* Kernel symbol table: GPL-only symbols */</span><span class="cp">			\</span>
<span class="cp">	__kcrctab_gpl     : AT(ADDR(__kcrctab_gpl) - LOAD_OFFSET) {	\</span>
<span class="cp">		VMLINUX_SYMBOL(__start___kcrctab_gpl) = .;		\</span>
<span class="cp">		*(SORT(___kcrctab_gpl+*))				\</span>
<span class="cp">		VMLINUX_SYMBOL(__stop___kcrctab_gpl) = .;		\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* Kernel symbol table: Normal unused symbols */</span><span class="cp">		\</span>
<span class="cp">	__kcrctab_unused  : AT(ADDR(__kcrctab_unused) - LOAD_OFFSET) {	\</span>
<span class="cp">		VMLINUX_SYMBOL(__start___kcrctab_unused) = .;		\</span>
<span class="cp">		*(SORT(___kcrctab_unused+*))				\</span>
<span class="cp">		VMLINUX_SYMBOL(__stop___kcrctab_unused) = .;		\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* Kernel symbol table: GPL-only unused symbols */</span><span class="cp">		\</span>
<span class="cp">	__kcrctab_unused_gpl : AT(ADDR(__kcrctab_unused_gpl) - LOAD_OFFSET) { \</span>
<span class="cp">		VMLINUX_SYMBOL(__start___kcrctab_unused_gpl) = .;	\</span>
<span class="cp">		*(SORT(___kcrctab_unused_gpl+*))			\</span>
<span class="cp">		VMLINUX_SYMBOL(__stop___kcrctab_unused_gpl) = .;	\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* Kernel symbol table: GPL-future-only symbols */</span><span class="cp">		\</span>
<span class="cp">	__kcrctab_gpl_future : AT(ADDR(__kcrctab_gpl_future) - LOAD_OFFSET) { \</span>
<span class="cp">		VMLINUX_SYMBOL(__start___kcrctab_gpl_future) = .;	\</span>
<span class="cp">		*(SORT(___kcrctab_gpl_future+*))			\</span>
<span class="cp">		VMLINUX_SYMBOL(__stop___kcrctab_gpl_future) = .;	\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* Kernel symbol table: strings */</span><span class="cp">				\</span>
<span class="cp">        __ksymtab_strings : AT(ADDR(__ksymtab_strings) - LOAD_OFFSET) {	\</span>
<span class="cp">		*(__ksymtab_strings)					\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* __*init sections */</span><span class="cp">						\</span>
<span class="cp">	__init_rodata : AT(ADDR(__init_rodata) - LOAD_OFFSET) {		\</span>
<span class="cp">		*(.ref.rodata)						\</span>
<span class="cp">		DEV_KEEP(init.rodata)					\</span>
<span class="cp">		DEV_KEEP(exit.rodata)					\</span>
<span class="cp">		CPU_KEEP(init.rodata)					\</span>
<span class="cp">		CPU_KEEP(exit.rodata)					\</span>
<span class="cp">		MEM_KEEP(init.rodata)					\</span>
<span class="cp">		MEM_KEEP(exit.rodata)					\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* Built-in module parameters. */</span><span class="cp">				\</span>
<span class="cp">	__param : AT(ADDR(__param) - LOAD_OFFSET) {			\</span>
<span class="cp">		VMLINUX_SYMBOL(__start___param) = .;			\</span>
<span class="cp">		*(__param)						\</span>
<span class="cp">		VMLINUX_SYMBOL(__stop___param) = .;			\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* Built-in module versions. */</span><span class="cp">					\</span>
<span class="cp">	__modver : AT(ADDR(__modver) - LOAD_OFFSET) {			\</span>
<span class="cp">		VMLINUX_SYMBOL(__start___modver) = .;			\</span>
<span class="cp">		*(__modver)						\</span>
<span class="cp">		VMLINUX_SYMBOL(__stop___modver) = .;			\</span>
<span class="cp">		. = ALIGN((align));					\</span>
<span class="cp">		VMLINUX_SYMBOL(__end_rodata) = .;			\</span>
<span class="cp">	}								\</span>
<span class="cp">	. = ALIGN((align));</span>

<span class="cm">/* RODATA &amp; RO_DATA provided for backward compatibility.</span>
<span class="cm"> * All archs are supposed to use RO_DATA() */</span>
<span class="cp">#define RODATA          RO_DATA_SECTION(4096)</span>
<span class="cp">#define RO_DATA(align)  RO_DATA_SECTION(align)</span>

<span class="cp">#define SECURITY_INIT							\</span>
<span class="cp">	.security_initcall.init : AT(ADDR(.security_initcall.init) - LOAD_OFFSET) { \</span>
<span class="cp">		VMLINUX_SYMBOL(__security_initcall_start) = .;		\</span>
<span class="cp">		*(.security_initcall.init) 				\</span>
<span class="cp">		VMLINUX_SYMBOL(__security_initcall_end) = .;		\</span>
<span class="cp">	}</span>

<span class="cm">/* .text section. Map to function alignment to avoid address changes</span>
<span class="cm"> * during second ld run in second ld pass when generating System.map */</span>
<span class="cp">#define TEXT_TEXT							\</span>
<span class="cp">		ALIGN_FUNCTION();					\</span>
<span class="cp">		*(.text.hot)						\</span>
<span class="cp">		*(.text)						\</span>
<span class="cp">		*(.ref.text)						\</span>
<span class="cp">	DEV_KEEP(init.text)						\</span>
<span class="cp">	DEV_KEEP(exit.text)						\</span>
<span class="cp">	CPU_KEEP(init.text)						\</span>
<span class="cp">	CPU_KEEP(exit.text)						\</span>
<span class="cp">	MEM_KEEP(init.text)						\</span>
<span class="cp">	MEM_KEEP(exit.text)						\</span>
<span class="cp">		*(.text.unlikely)</span>


<span class="cm">/* sched.text is aling to function alignment to secure we have same</span>
<span class="cm"> * address even at second ld pass when generating System.map */</span>
<span class="cp">#define SCHED_TEXT							\</span>
<span class="cp">		ALIGN_FUNCTION();					\</span>
<span class="cp">		VMLINUX_SYMBOL(__sched_text_start) = .;			\</span>
<span class="cp">		*(.sched.text)						\</span>
<span class="cp">		VMLINUX_SYMBOL(__sched_text_end) = .;</span>

<span class="cm">/* spinlock.text is aling to function alignment to secure we have same</span>
<span class="cm"> * address even at second ld pass when generating System.map */</span>
<span class="cp">#define LOCK_TEXT							\</span>
<span class="cp">		ALIGN_FUNCTION();					\</span>
<span class="cp">		VMLINUX_SYMBOL(__lock_text_start) = .;			\</span>
<span class="cp">		*(.spinlock.text)					\</span>
<span class="cp">		VMLINUX_SYMBOL(__lock_text_end) = .;</span>

<span class="cp">#define KPROBES_TEXT							\</span>
<span class="cp">		ALIGN_FUNCTION();					\</span>
<span class="cp">		VMLINUX_SYMBOL(__kprobes_text_start) = .;		\</span>
<span class="cp">		*(.kprobes.text)					\</span>
<span class="cp">		VMLINUX_SYMBOL(__kprobes_text_end) = .;</span>

<span class="cp">#define ENTRY_TEXT							\</span>
<span class="cp">		ALIGN_FUNCTION();					\</span>
<span class="cp">		VMLINUX_SYMBOL(__entry_text_start) = .;			\</span>
<span class="cp">		*(.entry.text)						\</span>
<span class="cp">		VMLINUX_SYMBOL(__entry_text_end) = .;</span>

<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
<span class="cp">#define IRQENTRY_TEXT							\</span>
<span class="cp">		ALIGN_FUNCTION();					\</span>
<span class="cp">		VMLINUX_SYMBOL(__irqentry_text_start) = .;		\</span>
<span class="cp">		*(.irqentry.text)					\</span>
<span class="cp">		VMLINUX_SYMBOL(__irqentry_text_end) = .;</span>
<span class="cp">#else</span>
<span class="cp">#define IRQENTRY_TEXT</span>
<span class="cp">#endif</span>

<span class="cm">/* Section used for early init (in .S files) */</span>
<span class="cp">#define HEAD_TEXT  *(.head.text)</span>

<span class="cp">#define HEAD_TEXT_SECTION							\</span>
<span class="cp">	.head.text : AT(ADDR(.head.text) - LOAD_OFFSET) {		\</span>
<span class="cp">		HEAD_TEXT						\</span>
<span class="cp">	}</span>

<span class="cm">/*</span>
<span class="cm"> * Exception table</span>
<span class="cm"> */</span>
<span class="cp">#define EXCEPTION_TABLE(align)						\</span>
<span class="cp">	. = ALIGN(align);						\</span>
<span class="cp">	__ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) {		\</span>
<span class="cp">		VMLINUX_SYMBOL(__start___ex_table) = .;			\</span>
<span class="cp">		*(__ex_table)						\</span>
<span class="cp">		VMLINUX_SYMBOL(__stop___ex_table) = .;			\</span>
<span class="cp">	}</span>

<span class="cm">/*</span>
<span class="cm"> * Init task</span>
<span class="cm"> */</span>
<span class="cp">#define INIT_TASK_DATA_SECTION(align)					\</span>
<span class="cp">	. = ALIGN(align);						\</span>
<span class="cp">	.data..init_task :  AT(ADDR(.data..init_task) - LOAD_OFFSET) {	\</span>
<span class="cp">		INIT_TASK_DATA(align)					\</span>
<span class="cp">	}</span>

<span class="cp">#ifdef CONFIG_CONSTRUCTORS</span>
<span class="cp">#define KERNEL_CTORS()	. = ALIGN(8);			   \</span>
<span class="cp">			VMLINUX_SYMBOL(__ctors_start) = .; \</span>
<span class="cp">			*(.ctors)			   \</span>
<span class="cp">			VMLINUX_SYMBOL(__ctors_end) = .;</span>
<span class="cp">#else</span>
<span class="cp">#define KERNEL_CTORS()</span>
<span class="cp">#endif</span>

<span class="cm">/* init and exit section handling */</span>
<span class="cp">#define INIT_DATA							\</span>
<span class="cp">	*(.init.data)							\</span>
<span class="cp">	DEV_DISCARD(init.data)						\</span>
<span class="cp">	CPU_DISCARD(init.data)						\</span>
<span class="cp">	MEM_DISCARD(init.data)						\</span>
<span class="cp">	KERNEL_CTORS()							\</span>
<span class="cp">	MCOUNT_REC()							\</span>
<span class="cp">	*(.init.rodata)							\</span>
<span class="cp">	FTRACE_EVENTS()							\</span>
<span class="cp">	TRACE_SYSCALLS()						\</span>
<span class="cp">	DEV_DISCARD(init.rodata)					\</span>
<span class="cp">	CPU_DISCARD(init.rodata)					\</span>
<span class="cp">	MEM_DISCARD(init.rodata)					\</span>
<span class="cp">	KERNEL_DTB()</span>

<span class="cp">#define INIT_TEXT							\</span>
<span class="cp">	*(.init.text)							\</span>
<span class="cp">	DEV_DISCARD(init.text)						\</span>
<span class="cp">	CPU_DISCARD(init.text)						\</span>
<span class="cp">	MEM_DISCARD(init.text)</span>

<span class="cp">#define EXIT_DATA							\</span>
<span class="cp">	*(.exit.data)							\</span>
<span class="cp">	DEV_DISCARD(exit.data)						\</span>
<span class="cp">	DEV_DISCARD(exit.rodata)					\</span>
<span class="cp">	CPU_DISCARD(exit.data)						\</span>
<span class="cp">	CPU_DISCARD(exit.rodata)					\</span>
<span class="cp">	MEM_DISCARD(exit.data)						\</span>
<span class="cp">	MEM_DISCARD(exit.rodata)</span>

<span class="cp">#define EXIT_TEXT							\</span>
<span class="cp">	*(.exit.text)							\</span>
<span class="cp">	DEV_DISCARD(exit.text)						\</span>
<span class="cp">	CPU_DISCARD(exit.text)						\</span>
<span class="cp">	MEM_DISCARD(exit.text)</span>

<span class="cp">#define EXIT_CALL							\</span>
<span class="cp">	*(.exitcall.exit)</span>

<span class="cm">/*</span>
<span class="cm"> * bss (Block Started by Symbol) - uninitialized data</span>
<span class="cm"> * zeroed during startup</span>
<span class="cm"> */</span>
<span class="cp">#define SBSS(sbss_align)						\</span>
<span class="cp">	. = ALIGN(sbss_align);						\</span>
<span class="cp">	.sbss : AT(ADDR(.sbss) - LOAD_OFFSET) {				\</span>
<span class="cp">		*(.sbss)						\</span>
<span class="cp">		*(.scommon)						\</span>
<span class="cp">	}</span>

<span class="cp">#define BSS(bss_align)							\</span>
<span class="cp">	. = ALIGN(bss_align);						\</span>
<span class="cp">	.bss : AT(ADDR(.bss) - LOAD_OFFSET) {				\</span>
<span class="cp">		*(.bss..page_aligned)					\</span>
<span class="cp">		*(.dynbss)						\</span>
<span class="cp">		*(.bss)							\</span>
<span class="cp">		*(COMMON)						\</span>
<span class="cp">	}</span>

<span class="cm">/*</span>
<span class="cm"> * DWARF debug sections.</span>
<span class="cm"> * Symbols in the DWARF debugging sections are relative to</span>
<span class="cm"> * the beginning of the section so we begin them at 0.</span>
<span class="cm"> */</span>
<span class="cp">#define DWARF_DEBUG							\</span>
<span class="cp">		</span><span class="cm">/* DWARF 1 */</span><span class="cp">						\</span>
<span class="cp">		.debug          0 : { *(.debug) }			\</span>
<span class="cp">		.line           0 : { *(.line) }			\</span>
<span class="cp">		</span><span class="cm">/* GNU DWARF 1 extensions */</span><span class="cp">				\</span>
<span class="cp">		.debug_srcinfo  0 : { *(.debug_srcinfo) }		\</span>
<span class="cp">		.debug_sfnames  0 : { *(.debug_sfnames) }		\</span>
<span class="cp">		</span><span class="cm">/* DWARF 1.1 and DWARF 2 */</span><span class="cp">				\</span>
<span class="cp">		.debug_aranges  0 : { *(.debug_aranges) }		\</span>
<span class="cp">		.debug_pubnames 0 : { *(.debug_pubnames) }		\</span>
<span class="cp">		</span><span class="cm">/* DWARF 2 */</span><span class="cp">						\</span>
<span class="cp">		.debug_info     0 : { *(.debug_info			\</span>
<span class="cp">				.gnu.linkonce.wi.*) }			\</span>
<span class="cp">		.debug_abbrev   0 : { *(.debug_abbrev) }		\</span>
<span class="cp">		.debug_line     0 : { *(.debug_line) }			\</span>
<span class="cp">		.debug_frame    0 : { *(.debug_frame) }			\</span>
<span class="cp">		.debug_str      0 : { *(.debug_str) }			\</span>
<span class="cp">		.debug_loc      0 : { *(.debug_loc) }			\</span>
<span class="cp">		.debug_macinfo  0 : { *(.debug_macinfo) }		\</span>
<span class="cp">		</span><span class="cm">/* SGI/MIPS DWARF 2 extensions */</span><span class="cp">			\</span>
<span class="cp">		.debug_weaknames 0 : { *(.debug_weaknames) }		\</span>
<span class="cp">		.debug_funcnames 0 : { *(.debug_funcnames) }		\</span>
<span class="cp">		.debug_typenames 0 : { *(.debug_typenames) }		\</span>
<span class="cp">		.debug_varnames  0 : { *(.debug_varnames) }		\</span>

		<span class="cm">/* Stabs debugging sections.  */</span>
<span class="cp">#define STABS_DEBUG							\</span>
<span class="cp">		.stab 0 : { *(.stab) }					\</span>
<span class="cp">		.stabstr 0 : { *(.stabstr) }				\</span>
<span class="cp">		.stab.excl 0 : { *(.stab.excl) }			\</span>
<span class="cp">		.stab.exclstr 0 : { *(.stab.exclstr) }			\</span>
<span class="cp">		.stab.index 0 : { *(.stab.index) }			\</span>
<span class="cp">		.stab.indexstr 0 : { *(.stab.indexstr) }		\</span>
<span class="cp">		.comment 0 : { *(.comment) }</span>

<span class="cp">#ifdef CONFIG_GENERIC_BUG</span>
<span class="cp">#define BUG_TABLE							\</span>
<span class="cp">	. = ALIGN(8);							\</span>
<span class="cp">	__bug_table : AT(ADDR(__bug_table) - LOAD_OFFSET) {		\</span>
<span class="cp">		VMLINUX_SYMBOL(__start___bug_table) = .;		\</span>
<span class="cp">		*(__bug_table)						\</span>
<span class="cp">		VMLINUX_SYMBOL(__stop___bug_table) = .;			\</span>
<span class="cp">	}</span>
<span class="cp">#else</span>
<span class="cp">#define BUG_TABLE</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PM_TRACE</span>
<span class="cp">#define TRACEDATA							\</span>
<span class="cp">	. = ALIGN(4);							\</span>
<span class="cp">	.tracedata : AT(ADDR(.tracedata) - LOAD_OFFSET) {		\</span>
<span class="cp">		VMLINUX_SYMBOL(__tracedata_start) = .;			\</span>
<span class="cp">		*(.tracedata)						\</span>
<span class="cp">		VMLINUX_SYMBOL(__tracedata_end) = .;			\</span>
<span class="cp">	}</span>
<span class="cp">#else</span>
<span class="cp">#define TRACEDATA</span>
<span class="cp">#endif</span>

<span class="cp">#define NOTES								\</span>
<span class="cp">	.notes : AT(ADDR(.notes) - LOAD_OFFSET) {			\</span>
<span class="cp">		VMLINUX_SYMBOL(__start_notes) = .;			\</span>
<span class="cp">		*(.note.*)						\</span>
<span class="cp">		VMLINUX_SYMBOL(__stop_notes) = .;			\</span>
<span class="cp">	}</span>

<span class="cp">#define INIT_SETUP(initsetup_align)					\</span>
<span class="cp">		. = ALIGN(initsetup_align);				\</span>
<span class="cp">		VMLINUX_SYMBOL(__setup_start) = .;			\</span>
<span class="cp">		*(.init.setup)						\</span>
<span class="cp">		VMLINUX_SYMBOL(__setup_end) = .;</span>

<span class="cp">#define INIT_CALLS_LEVEL(level)						\</span>
<span class="cp">		VMLINUX_SYMBOL(__initcall##level##_start) = .;		\</span>
<span class="cp">		*(.initcall##level##.init)				\</span>
<span class="cp">		*(.initcall##level##s.init)				\</span>

<span class="cp">#define INIT_CALLS							\</span>
<span class="cp">		VMLINUX_SYMBOL(__initcall_start) = .;			\</span>
<span class="cp">		*(.initcallearly.init)					\</span>
<span class="cp">		INIT_CALLS_LEVEL(0)					\</span>
<span class="cp">		INIT_CALLS_LEVEL(1)					\</span>
<span class="cp">		INIT_CALLS_LEVEL(2)					\</span>
<span class="cp">		INIT_CALLS_LEVEL(3)					\</span>
<span class="cp">		INIT_CALLS_LEVEL(4)					\</span>
<span class="cp">		INIT_CALLS_LEVEL(5)					\</span>
<span class="cp">		INIT_CALLS_LEVEL(rootfs)				\</span>
<span class="cp">		INIT_CALLS_LEVEL(6)					\</span>
<span class="cp">		INIT_CALLS_LEVEL(7)					\</span>
<span class="cp">		VMLINUX_SYMBOL(__initcall_end) = .;</span>

<span class="cp">#define CON_INITCALL							\</span>
<span class="cp">		VMLINUX_SYMBOL(__con_initcall_start) = .;		\</span>
<span class="cp">		*(.con_initcall.init)					\</span>
<span class="cp">		VMLINUX_SYMBOL(__con_initcall_end) = .;</span>

<span class="cp">#define SECURITY_INITCALL						\</span>
<span class="cp">		VMLINUX_SYMBOL(__security_initcall_start) = .;		\</span>
<span class="cp">		*(.security_initcall.init)				\</span>
<span class="cp">		VMLINUX_SYMBOL(__security_initcall_end) = .;</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="cp">#define INIT_RAM_FS							\</span>
<span class="cp">	. = ALIGN(4);							\</span>
<span class="cp">	VMLINUX_SYMBOL(__initramfs_start) = .;				\</span>
<span class="cp">	*(.init.ramfs)							\</span>
<span class="cp">	. = ALIGN(8);							\</span>
<span class="cp">	*(.init.ramfs.info)</span>
<span class="cp">#else</span>
<span class="cp">#define INIT_RAM_FS</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Default discarded sections.</span>
<span class="cm"> *</span>
<span class="cm"> * Some archs want to discard exit text/data at runtime rather than</span>
<span class="cm"> * link time due to cross-section references such as alt instructions,</span>
<span class="cm"> * bug table, eh_frame, etc.  DISCARDS must be the last of output</span>
<span class="cm"> * section definitions so that such archs put those in earlier section</span>
<span class="cm"> * definitions.</span>
<span class="cm"> */</span>
<span class="cp">#define DISCARDS							\</span>
<span class="cp">	/DISCARD/ : {							\</span>
<span class="cp">	EXIT_TEXT							\</span>
<span class="cp">	EXIT_DATA							\</span>
<span class="cp">	EXIT_CALL							\</span>
<span class="cp">	*(.discard)							\</span>
<span class="cp">	*(.discard.*)							\</span>
<span class="cp">	}</span>

<span class="cm">/**</span>
<span class="cm"> * PERCPU_INPUT - the percpu input sections</span>
<span class="cm"> * @cacheline: cacheline size</span>
<span class="cm"> *</span>
<span class="cm"> * The core percpu section names and core symbols which do not rely</span>
<span class="cm"> * directly upon load addresses.</span>
<span class="cm"> *</span>
<span class="cm"> * @cacheline is used to align subsections to avoid false cacheline</span>
<span class="cm"> * sharing between subsections for different purposes.</span>
<span class="cm"> */</span>
<span class="cp">#define PERCPU_INPUT(cacheline)						\</span>
<span class="cp">	VMLINUX_SYMBOL(__per_cpu_start) = .;				\</span>
<span class="cp">	*(.data..percpu..first)						\</span>
<span class="cp">	. = ALIGN(PAGE_SIZE);						\</span>
<span class="cp">	*(.data..percpu..page_aligned)					\</span>
<span class="cp">	. = ALIGN(cacheline);						\</span>
<span class="cp">	*(.data..percpu..readmostly)					\</span>
<span class="cp">	. = ALIGN(cacheline);						\</span>
<span class="cp">	*(.data..percpu)						\</span>
<span class="cp">	*(.data..percpu..shared_aligned)				\</span>
<span class="cp">	VMLINUX_SYMBOL(__per_cpu_end) = .;</span>

<span class="cm">/**</span>
<span class="cm"> * PERCPU_VADDR - define output section for percpu area</span>
<span class="cm"> * @cacheline: cacheline size</span>
<span class="cm"> * @vaddr: explicit base address (optional)</span>
<span class="cm"> * @phdr: destination PHDR (optional)</span>
<span class="cm"> *</span>
<span class="cm"> * Macro which expands to output section for percpu area.</span>
<span class="cm"> *</span>
<span class="cm"> * @cacheline is used to align subsections to avoid false cacheline</span>
<span class="cm"> * sharing between subsections for different purposes.</span>
<span class="cm"> *</span>
<span class="cm"> * If @vaddr is not blank, it specifies explicit base address and all</span>
<span class="cm"> * percpu symbols will be offset from the given address.  If blank,</span>
<span class="cm"> * @vaddr always equals @laddr + LOAD_OFFSET.</span>
<span class="cm"> *</span>
<span class="cm"> * @phdr defines the output PHDR to use if not blank.  Be warned that</span>
<span class="cm"> * output PHDR is sticky.  If @phdr is specified, the next output</span>
<span class="cm"> * section in the linker script will go there too.  @phdr should have</span>
<span class="cm"> * a leading colon.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this macros defines __per_cpu_load as an absolute symbol.</span>
<span class="cm"> * If there is no need to put the percpu section at a predetermined</span>
<span class="cm"> * address, use PERCPU_SECTION.</span>
<span class="cm"> */</span>
<span class="cp">#define PERCPU_VADDR(cacheline, vaddr, phdr)				\</span>
<span class="cp">	VMLINUX_SYMBOL(__per_cpu_load) = .;				\</span>
<span class="cp">	.data..percpu vaddr : AT(VMLINUX_SYMBOL(__per_cpu_load)		\</span>
<span class="cp">				- LOAD_OFFSET) {			\</span>
<span class="cp">		PERCPU_INPUT(cacheline)					\</span>
<span class="cp">	} phdr								\</span>
<span class="cp">	. = VMLINUX_SYMBOL(__per_cpu_load) + SIZEOF(.data..percpu);</span>

<span class="cm">/**</span>
<span class="cm"> * PERCPU_SECTION - define output section for percpu area, simple version</span>
<span class="cm"> * @cacheline: cacheline size</span>
<span class="cm"> *</span>
<span class="cm"> * Align to PAGE_SIZE and outputs output section for percpu area.  This</span>
<span class="cm"> * macro doesn&#39;t manipulate @vaddr or @phdr and __per_cpu_load and</span>
<span class="cm"> * __per_cpu_start will be identical.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro is equivalent to ALIGN(PAGE_SIZE); PERCPU_VADDR(@cacheline,,)</span>
<span class="cm"> * except that __per_cpu_load is defined as a relative symbol against</span>
<span class="cm"> * .data..percpu which is required for relocatable x86_32 configuration.</span>
<span class="cm"> */</span>
<span class="cp">#define PERCPU_SECTION(cacheline)					\</span>
<span class="cp">	. = ALIGN(PAGE_SIZE);						\</span>
<span class="cp">	.data..percpu	: AT(ADDR(.data..percpu) - LOAD_OFFSET) {	\</span>
<span class="cp">		VMLINUX_SYMBOL(__per_cpu_load) = .;			\</span>
<span class="cp">		PERCPU_INPUT(cacheline)					\</span>
<span class="cp">	}</span>


<span class="cm">/*</span>
<span class="cm"> * Definition of the high level *_SECTION macros</span>
<span class="cm"> * They will fit only a subset of the architectures</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * Writeable data.</span>
<span class="cm"> * All sections are combined in a single .data section.</span>
<span class="cm"> * The sections following CONSTRUCTORS are arranged so their</span>
<span class="cm"> * typical alignment matches.</span>
<span class="cm"> * A cacheline is typical/always less than a PAGE_SIZE so</span>
<span class="cm"> * the sections that has this restriction (or similar)</span>
<span class="cm"> * is located before the ones requiring PAGE_SIZE alignment.</span>
<span class="cm"> * NOSAVE_DATA starts and ends with a PAGE_SIZE alignment which</span>
<span class="cm"> * matches the requirement of PAGE_ALIGNED_DATA.</span>
<span class="cm"> *</span>
<span class="cm"> * use 0 as page_align if page_aligned data is not used */</span>
<span class="cp">#define RW_DATA_SECTION(cacheline, pagealigned, inittask)		\</span>
<span class="cp">	. = ALIGN(PAGE_SIZE);						\</span>
<span class="cp">	.data : AT(ADDR(.data) - LOAD_OFFSET) {				\</span>
<span class="cp">		INIT_TASK_DATA(inittask)				\</span>
<span class="cp">		NOSAVE_DATA						\</span>
<span class="cp">		PAGE_ALIGNED_DATA(pagealigned)				\</span>
<span class="cp">		CACHELINE_ALIGNED_DATA(cacheline)			\</span>
<span class="cp">		READ_MOSTLY_DATA(cacheline)				\</span>
<span class="cp">		DATA_DATA						\</span>
<span class="cp">		CONSTRUCTORS						\</span>
<span class="cp">	}</span>

<span class="cp">#define INIT_TEXT_SECTION(inittext_align)				\</span>
<span class="cp">	. = ALIGN(inittext_align);					\</span>
<span class="cp">	.init.text : AT(ADDR(.init.text) - LOAD_OFFSET) {		\</span>
<span class="cp">		VMLINUX_SYMBOL(_sinittext) = .;				\</span>
<span class="cp">		INIT_TEXT						\</span>
<span class="cp">		VMLINUX_SYMBOL(_einittext) = .;				\</span>
<span class="cp">	}</span>

<span class="cp">#define INIT_DATA_SECTION(initsetup_align)				\</span>
<span class="cp">	.init.data : AT(ADDR(.init.data) - LOAD_OFFSET) {		\</span>
<span class="cp">		INIT_DATA						\</span>
<span class="cp">		INIT_SETUP(initsetup_align)				\</span>
<span class="cp">		INIT_CALLS						\</span>
<span class="cp">		CON_INITCALL						\</span>
<span class="cp">		SECURITY_INITCALL					\</span>
<span class="cp">		INIT_RAM_FS						\</span>
<span class="cp">	}</span>

<span class="cp">#define BSS_SECTION(sbss_align, bss_align, stop_align)			\</span>
<span class="cp">	. = ALIGN(sbss_align);						\</span>
<span class="cp">	VMLINUX_SYMBOL(__bss_start) = .;				\</span>
<span class="cp">	SBSS(sbss_align)						\</span>
<span class="cp">	BSS(bss_align)							\</span>
<span class="cp">	. = ALIGN(stop_align);						\</span>
<span class="cp">	VMLINUX_SYMBOL(__bss_stop) = .;</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
