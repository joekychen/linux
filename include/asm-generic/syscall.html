<!DOCTYPE html>
<html><head><title>joekychen/linux » include › asm-generic › syscall.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>syscall.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Access to user system call parameters and results</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008-2009 Red Hat, Inc.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This copyrighted material is made available to anyone wishing to use,</span>
<span class="cm"> * modify, copy, or redistribute it subject to the terms and conditions</span>
<span class="cm"> * of the GNU General Public License v.2.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is a stub providing documentation for what functions</span>
<span class="cm"> * asm-ARCH/syscall.h files need to define.  Most arch definitions</span>
<span class="cm"> * will be simple inlines.</span>
<span class="cm"> *</span>
<span class="cm"> * All of these functions expect to be called with no locks,</span>
<span class="cm"> * and only when the caller is sure that the task of interest</span>
<span class="cm"> * cannot return to user mode while we are looking at it.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_SYSCALL_H</span>
<span class="cp">#define _ASM_SYSCALL_H	1</span>

<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pt_regs</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * syscall_get_nr - find what system call a task is executing</span>
<span class="cm"> * @task:	task of interest, must be blocked</span>
<span class="cm"> * @regs:	task_pt_regs() of @task</span>
<span class="cm"> *</span>
<span class="cm"> * If @task is executing a system call or is at system call</span>
<span class="cm"> * tracing about to attempt one, returns the system call number.</span>
<span class="cm"> * If @task is not executing a system call, i.e. it&#39;s blocked</span>
<span class="cm"> * inside the kernel for a fault or signal, returns -1.</span>
<span class="cm"> *</span>
<span class="cm"> * Note this returns int even on 64-bit machines.  Only 32 bits of</span>
<span class="cm"> * system call number can be meaningful.  If the actual arch value</span>
<span class="cm"> * is 64 bits, this truncates to 32 bits so 0xffffffff means -1.</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s only valid to call this when @task is known to be blocked.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">syscall_get_nr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * syscall_rollback - roll back registers after an aborted system call</span>
<span class="cm"> * @task:	task of interest, must be in system call exit tracing</span>
<span class="cm"> * @regs:	task_pt_regs() of @task</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s only valid to call this when @task is stopped for system</span>
<span class="cm"> * call exit tracing (due to TIF_SYSCALL_TRACE or TIF_SYSCALL_AUDIT),</span>
<span class="cm"> * after tracehook_report_syscall_entry() returned nonzero to prevent</span>
<span class="cm"> * the system call from taking place.</span>
<span class="cm"> *</span>
<span class="cm"> * This rolls back the register state in @regs so it&#39;s as if the</span>
<span class="cm"> * system call instruction was a no-op.  The registers containing</span>
<span class="cm"> * the system call number and arguments are as they were before the</span>
<span class="cm"> * system call instruction.  This may not be the same as what the</span>
<span class="cm"> * register state looked like at system call entry tracing.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">syscall_rollback</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * syscall_get_error - check result of traced system call</span>
<span class="cm"> * @task:	task of interest, must be blocked</span>
<span class="cm"> * @regs:	task_pt_regs() of @task</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if the system call succeeded, or -ERRORCODE if it failed.</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s only valid to call this when @task is stopped for tracing on exit</span>
<span class="cm"> * from a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">syscall_get_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * syscall_get_return_value - get the return value of a traced system call</span>
<span class="cm"> * @task:	task of interest, must be blocked</span>
<span class="cm"> * @regs:	task_pt_regs() of @task</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the return value of the successful system call.</span>
<span class="cm"> * This value is meaningless if syscall_get_error() returned nonzero.</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s only valid to call this when @task is stopped for tracing on exit</span>
<span class="cm"> * from a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">syscall_get_return_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * syscall_set_return_value - change the return value of a traced system call</span>
<span class="cm"> * @task:	task of interest, must be blocked</span>
<span class="cm"> * @regs:	task_pt_regs() of @task</span>
<span class="cm"> * @error:	negative error code, or zero to indicate success</span>
<span class="cm"> * @val:	user return value if @error is zero</span>
<span class="cm"> *</span>
<span class="cm"> * This changes the results of the system call that user mode will see.</span>
<span class="cm"> * If @error is zero, the user sees a successful system call with a</span>
<span class="cm"> * return value of @val.  If @error is nonzero, it&#39;s a negated errno</span>
<span class="cm"> * code; the user sees a failed system call with this errno code.</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s only valid to call this when @task is stopped for tracing on exit</span>
<span class="cm"> * from a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">syscall_set_return_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="kt">long</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * syscall_get_arguments - extract system call parameter values</span>
<span class="cm"> * @task:	task of interest, must be blocked</span>
<span class="cm"> * @regs:	task_pt_regs() of @task</span>
<span class="cm"> * @i:		argument index [0,5]</span>
<span class="cm"> * @n:		number of arguments; n+i must be [1,6].</span>
<span class="cm"> * @args:	array filled with argument values</span>
<span class="cm"> *</span>
<span class="cm"> * Fetches @n arguments to the system call starting with the @i&#39;th argument</span>
<span class="cm"> * (from 0 through 5).  Argument @i is stored in @args[0], and so on.</span>
<span class="cm"> * An arch inline version is probably optimal when @i and @n are constants.</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s only valid to call this when @task is stopped for tracing on</span>
<span class="cm"> * entry to a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.</span>
<span class="cm"> * It&#39;s invalid to call this with @i + @n &gt; 6; we only support system calls</span>
<span class="cm"> * taking up to 6 arguments.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">syscall_get_arguments</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * syscall_set_arguments - change system call parameter value</span>
<span class="cm"> * @task:	task of interest, must be in system call entry tracing</span>
<span class="cm"> * @regs:	task_pt_regs() of @task</span>
<span class="cm"> * @i:		argument index [0,5]</span>
<span class="cm"> * @n:		number of arguments; n+i must be [1,6].</span>
<span class="cm"> * @args:	array of argument values to store</span>
<span class="cm"> *</span>
<span class="cm"> * Changes @n arguments to the system call starting with the @i&#39;th argument.</span>
<span class="cm"> * Argument @i gets value @args[0], and so on.</span>
<span class="cm"> * An arch inline version is probably optimal when @i and @n are constants.</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s only valid to call this when @task is stopped for tracing on</span>
<span class="cm"> * entry to a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.</span>
<span class="cm"> * It&#39;s invalid to call this with @i + @n &gt; 6; we only support system calls</span>
<span class="cm"> * taking up to 6 arguments.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">syscall_set_arguments</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * syscall_get_arch - return the AUDIT_ARCH for the current system call</span>
<span class="cm"> * @task:	task of interest, must be in system call entry tracing</span>
<span class="cm"> * @regs:	task_pt_regs() of @task</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the AUDIT_ARCH_* based on the system call convention in use.</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s only valid to call this when @task is stopped on entry to a system</span>
<span class="cm"> * call, due to %TIF_SYSCALL_TRACE, %TIF_SYSCALL_AUDIT, or %TIF_SECCOMP.</span>
<span class="cm"> *</span>
<span class="cm"> * Architectures which permit CONFIG_HAVE_ARCH_SECCOMP_FILTER must</span>
<span class="cm"> * provide an implementation of this.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">syscall_get_arch</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* _ASM_SYSCALL_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
