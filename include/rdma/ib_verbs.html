<!DOCTYPE html>
<html><head><title>joekychen/linux » include › rdma › ib_verbs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ib_verbs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2004 Mellanox Technologies Ltd.  All rights reserved.</span>
<span class="cm"> * Copyright (c) 2004 Infinicon Corporation.  All rights reserved.</span>
<span class="cm"> * Copyright (c) 2004 Intel Corporation.  All rights reserved.</span>
<span class="cm"> * Copyright (c) 2004 Topspin Corporation.  All rights reserved.</span>
<span class="cm"> * Copyright (c) 2004 Voltaire Corporation.  All rights reserved.</span>
<span class="cm"> * Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.</span>
<span class="cm"> * Copyright (c) 2005, 2006, 2007 Cisco Systems.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is available to you under a choice of one of two</span>
<span class="cm"> * licenses.  You may choose to be licensed under the terms of the GNU</span>
<span class="cm"> * General Public License (GPL) Version 2, available from the file</span>
<span class="cm"> * COPYING in the main directory of this source tree, or the</span>
<span class="cm"> * OpenIB.org BSD license below:</span>
<span class="cm"> *</span>
<span class="cm"> *     Redistribution and use in source and binary forms, with or</span>
<span class="cm"> *     without modification, are permitted provided that the following</span>
<span class="cm"> *     conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions of source code must retain the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions in binary form must reproduce the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer in the documentation and/or other materials</span>
<span class="cm"> *        provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cp">#if !defined(IB_VERBS_H)</span>
<span class="cp">#define IB_VERBS_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">ib_wq</span><span class="p">;</span>

<span class="k">union</span> <span class="n">ib_gid</span> <span class="p">{</span>
	<span class="n">u8</span>	<span class="n">raw</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">__be64</span>	<span class="n">subnet_prefix</span><span class="p">;</span>
		<span class="n">__be64</span>	<span class="n">interface_id</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">global</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">rdma_node_type</span> <span class="p">{</span>
	<span class="cm">/* IB values map to NodeInfo:NodeType. */</span>
	<span class="n">RDMA_NODE_IB_CA</span> 	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">RDMA_NODE_IB_SWITCH</span><span class="p">,</span>
	<span class="n">RDMA_NODE_IB_ROUTER</span><span class="p">,</span>
	<span class="n">RDMA_NODE_RNIC</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">rdma_transport_type</span> <span class="p">{</span>
	<span class="n">RDMA_TRANSPORT_IB</span><span class="p">,</span>
	<span class="n">RDMA_TRANSPORT_IWARP</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">rdma_transport_type</span>
<span class="n">rdma_node_get_transport</span><span class="p">(</span><span class="k">enum</span> <span class="n">rdma_node_type</span> <span class="n">node_type</span><span class="p">)</span> <span class="n">__attribute_const__</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">rdma_link_layer</span> <span class="p">{</span>
	<span class="n">IB_LINK_LAYER_UNSPECIFIED</span><span class="p">,</span>
	<span class="n">IB_LINK_LAYER_INFINIBAND</span><span class="p">,</span>
	<span class="n">IB_LINK_LAYER_ETHERNET</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_device_cap_flags</span> <span class="p">{</span>
	<span class="n">IB_DEVICE_RESIZE_MAX_WR</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IB_DEVICE_BAD_PKEY_CNTR</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IB_DEVICE_BAD_QKEY_CNTR</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">IB_DEVICE_RAW_MULTI</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">IB_DEVICE_AUTO_PATH_MIG</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span>
	<span class="n">IB_DEVICE_CHANGE_PHY_PORT</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">),</span>
	<span class="n">IB_DEVICE_UD_AV_PORT_ENFORCE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">),</span>
	<span class="n">IB_DEVICE_CURR_QP_STATE_MOD</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span>
	<span class="n">IB_DEVICE_SHUTDOWN_PORT</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">),</span>
	<span class="n">IB_DEVICE_INIT_TYPE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">),</span>
	<span class="n">IB_DEVICE_PORT_ACTIVE_EVENT</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">),</span>
	<span class="n">IB_DEVICE_SYS_IMAGE_GUID</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">11</span><span class="p">),</span>
	<span class="n">IB_DEVICE_RC_RNR_NAK_GEN</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">12</span><span class="p">),</span>
	<span class="n">IB_DEVICE_SRQ_RESIZE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">13</span><span class="p">),</span>
	<span class="n">IB_DEVICE_N_NOTIFY_CQ</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">14</span><span class="p">),</span>
	<span class="n">IB_DEVICE_LOCAL_DMA_LKEY</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">15</span><span class="p">),</span>
	<span class="n">IB_DEVICE_RESERVED</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">),</span> <span class="cm">/* old SEND_W_INV */</span>
	<span class="n">IB_DEVICE_MEM_WINDOW</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">17</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 * Devices should set IB_DEVICE_UD_IP_SUM if they support</span>
<span class="cm">	 * insertion of UDP and TCP checksum on outgoing UD IPoIB</span>
<span class="cm">	 * messages and can verify the validity of checksum for</span>
<span class="cm">	 * incoming messages.  Setting this flag implies that the</span>
<span class="cm">	 * IPoIB driver may set NETIF_F_IP_CSUM for datagram mode.</span>
<span class="cm">	 */</span>
	<span class="n">IB_DEVICE_UD_IP_CSUM</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">18</span><span class="p">),</span>
	<span class="n">IB_DEVICE_UD_TSO</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">19</span><span class="p">),</span>
	<span class="n">IB_DEVICE_XRC</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">),</span>
	<span class="n">IB_DEVICE_MEM_MGT_EXTENSIONS</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">21</span><span class="p">),</span>
	<span class="n">IB_DEVICE_BLOCK_MULTICAST_LOOPBACK</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">22</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_atomic_cap</span> <span class="p">{</span>
	<span class="n">IB_ATOMIC_NONE</span><span class="p">,</span>
	<span class="n">IB_ATOMIC_HCA</span><span class="p">,</span>
	<span class="n">IB_ATOMIC_GLOB</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_device_attr</span> <span class="p">{</span>
	<span class="n">u64</span>			<span class="n">fw_ver</span><span class="p">;</span>
	<span class="n">__be64</span>			<span class="n">sys_image_guid</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">max_mr_size</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">page_size_cap</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">vendor_id</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">vendor_part_id</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">hw_ver</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_qp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_qp_wr</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">device_cap_flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_sge</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_sge_rd</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_cq</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_cqe</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_mr</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_pd</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_qp_rd_atom</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_ee_rd_atom</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_res_rd_atom</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_qp_init_rd_atom</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_ee_init_rd_atom</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_atomic_cap</span>	<span class="n">atomic_cap</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_atomic_cap</span>	<span class="n">masked_atomic_cap</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_ee</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_rdd</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_mw</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_raw_ipv6_qp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_raw_ethy_qp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_mcast_grp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_mcast_qp_attach</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_total_mcast_qp_attach</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_ah</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_fmr</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_map_per_fmr</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_srq</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_srq_wr</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_srq_sge</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">max_fast_reg_page_list_len</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">max_pkeys</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">local_ca_ack_delay</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_mtu</span> <span class="p">{</span>
	<span class="n">IB_MTU_256</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IB_MTU_512</span>  <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">IB_MTU_1024</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">IB_MTU_2048</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">IB_MTU_4096</span> <span class="o">=</span> <span class="mi">5</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ib_mtu_enum_to_int</span><span class="p">(</span><span class="k">enum</span> <span class="n">ib_mtu</span> <span class="n">mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mtu</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IB_MTU_256</span>:  <span class="k">return</span>  <span class="mi">256</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_MTU_512</span>:  <span class="k">return</span>  <span class="mi">512</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_MTU_1024</span>: <span class="k">return</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_MTU_2048</span>: <span class="k">return</span> <span class="mi">2048</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_MTU_4096</span>: <span class="k">return</span> <span class="mi">4096</span><span class="p">;</span>
	<span class="nl">default:</span> 	  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">ib_port_state</span> <span class="p">{</span>
	<span class="n">IB_PORT_NOP</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IB_PORT_DOWN</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IB_PORT_INIT</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">IB_PORT_ARMED</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">IB_PORT_ACTIVE</span>		<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">IB_PORT_ACTIVE_DEFER</span>	<span class="o">=</span> <span class="mi">5</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_port_cap_flags</span> <span class="p">{</span>
	<span class="n">IB_PORT_SM</span>				<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">1</span><span class="p">,</span>
	<span class="n">IB_PORT_NOTICE_SUP</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">2</span><span class="p">,</span>
	<span class="n">IB_PORT_TRAP_SUP</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">3</span><span class="p">,</span>
	<span class="n">IB_PORT_OPT_IPD_SUP</span>                     <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">4</span><span class="p">,</span>
	<span class="n">IB_PORT_AUTO_MIGR_SUP</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">5</span><span class="p">,</span>
	<span class="n">IB_PORT_SL_MAP_SUP</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">6</span><span class="p">,</span>
	<span class="n">IB_PORT_MKEY_NVRAM</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">7</span><span class="p">,</span>
	<span class="n">IB_PORT_PKEY_NVRAM</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">8</span><span class="p">,</span>
	<span class="n">IB_PORT_LED_INFO_SUP</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">9</span><span class="p">,</span>
	<span class="n">IB_PORT_SM_DISABLED</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">IB_PORT_SYS_IMAGE_GUID_SUP</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">IB_PORT_PKEY_SW_EXT_PORT_TRAP_SUP</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">,</span>
	<span class="n">IB_PORT_EXTENDED_SPEEDS_SUP</span>             <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">,</span>
	<span class="n">IB_PORT_CM_SUP</span>				<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">,</span>
	<span class="n">IB_PORT_SNMP_TUNNEL_SUP</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">,</span>
	<span class="n">IB_PORT_REINIT_SUP</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">,</span>
	<span class="n">IB_PORT_DEVICE_MGMT_SUP</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">,</span>
	<span class="n">IB_PORT_VENDOR_CLASS_SUP</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>
	<span class="n">IB_PORT_DR_NOTICE_SUP</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">,</span>
	<span class="n">IB_PORT_CAP_MASK_NOTICE_SUP</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">,</span>
	<span class="n">IB_PORT_BOOT_MGMT_SUP</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">,</span>
	<span class="n">IB_PORT_LINK_LATENCY_SUP</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">,</span>
	<span class="n">IB_PORT_CLIENT_REG_SUP</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">25</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_port_width</span> <span class="p">{</span>
	<span class="n">IB_WIDTH_1X</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IB_WIDTH_4X</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">IB_WIDTH_8X</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">IB_WIDTH_12X</span>	<span class="o">=</span> <span class="mi">8</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ib_width_enum_to_int</span><span class="p">(</span><span class="k">enum</span> <span class="n">ib_port_width</span> <span class="n">width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IB_WIDTH_1X</span>:  <span class="k">return</span>  <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_WIDTH_4X</span>:  <span class="k">return</span>  <span class="mi">4</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_WIDTH_8X</span>:  <span class="k">return</span>  <span class="mi">8</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_WIDTH_12X</span>: <span class="k">return</span> <span class="mi">12</span><span class="p">;</span>
	<span class="nl">default:</span> 	  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">ib_port_speed</span> <span class="p">{</span>
	<span class="n">IB_SPEED_SDR</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IB_SPEED_DDR</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">IB_SPEED_QDR</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">IB_SPEED_FDR10</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">IB_SPEED_FDR</span>	<span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	<span class="n">IB_SPEED_EDR</span>	<span class="o">=</span> <span class="mi">32</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_protocol_stats</span> <span class="p">{</span>
	<span class="cm">/* TBD... */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iw_protocol_stats</span> <span class="p">{</span>
	<span class="n">u64</span>	<span class="n">ipInReceives</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipInHdrErrors</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipInTooBigErrors</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipInNoRoutes</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipInAddrErrors</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipInUnknownProtos</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipInTruncatedPkts</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipInDiscards</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipInDelivers</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipOutForwDatagrams</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipOutRequests</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipOutDiscards</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipOutNoRoutes</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipReasmTimeout</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipReasmReqds</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipReasmOKs</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipReasmFails</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipFragOKs</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipFragFails</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipFragCreates</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipInMcastPkts</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipOutMcastPkts</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipInBcastPkts</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ipOutBcastPkts</span><span class="p">;</span>

	<span class="n">u64</span>	<span class="n">tcpRtoAlgorithm</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tcpRtoMin</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tcpRtoMax</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tcpMaxConn</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tcpActiveOpens</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tcpPassiveOpens</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tcpAttemptFails</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tcpEstabResets</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tcpCurrEstab</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tcpInSegs</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tcpOutSegs</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tcpRetransSegs</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tcpInErrs</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">tcpOutRsts</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">rdma_protocol_stats</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_protocol_stats</span>	<span class="n">ib</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iw_protocol_stats</span>	<span class="n">iw</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_port_attr</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">ib_port_state</span>	<span class="n">state</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_mtu</span>		<span class="n">max_mtu</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_mtu</span>		<span class="n">active_mtu</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">gid_tbl_len</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">port_cap_flags</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">max_msg_sz</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">bad_pkey_cntr</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">qkey_viol_cntr</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">pkey_tbl_len</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">lid</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">sm_lid</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">lmc</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">max_vl_num</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">sm_sl</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">subnet_timeout</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">init_type_reply</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">active_width</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">active_speed</span><span class="p">;</span>
	<span class="n">u8</span>                      <span class="n">phys_state</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_device_modify_flags</span> <span class="p">{</span>
	<span class="n">IB_DEVICE_MODIFY_SYS_IMAGE_GUID</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IB_DEVICE_MODIFY_NODE_DESC</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_device_modify</span> <span class="p">{</span>
	<span class="n">u64</span>	<span class="n">sys_image_guid</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">node_desc</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_port_modify_flags</span> <span class="p">{</span>
	<span class="n">IB_PORT_SHUTDOWN</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IB_PORT_INIT_TYPE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">IB_PORT_RESET_QKEY_CNTR</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_port_modify</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">set_port_cap_mask</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">clr_port_cap_mask</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">init_type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_event_type</span> <span class="p">{</span>
	<span class="n">IB_EVENT_CQ_ERR</span><span class="p">,</span>
	<span class="n">IB_EVENT_QP_FATAL</span><span class="p">,</span>
	<span class="n">IB_EVENT_QP_REQ_ERR</span><span class="p">,</span>
	<span class="n">IB_EVENT_QP_ACCESS_ERR</span><span class="p">,</span>
	<span class="n">IB_EVENT_COMM_EST</span><span class="p">,</span>
	<span class="n">IB_EVENT_SQ_DRAINED</span><span class="p">,</span>
	<span class="n">IB_EVENT_PATH_MIG</span><span class="p">,</span>
	<span class="n">IB_EVENT_PATH_MIG_ERR</span><span class="p">,</span>
	<span class="n">IB_EVENT_DEVICE_FATAL</span><span class="p">,</span>
	<span class="n">IB_EVENT_PORT_ACTIVE</span><span class="p">,</span>
	<span class="n">IB_EVENT_PORT_ERR</span><span class="p">,</span>
	<span class="n">IB_EVENT_LID_CHANGE</span><span class="p">,</span>
	<span class="n">IB_EVENT_PKEY_CHANGE</span><span class="p">,</span>
	<span class="n">IB_EVENT_SM_CHANGE</span><span class="p">,</span>
	<span class="n">IB_EVENT_SRQ_ERR</span><span class="p">,</span>
	<span class="n">IB_EVENT_SRQ_LIMIT_REACHED</span><span class="p">,</span>
	<span class="n">IB_EVENT_QP_LAST_WQE_REACHED</span><span class="p">,</span>
	<span class="n">IB_EVENT_CLIENT_REREGISTER</span><span class="p">,</span>
	<span class="n">IB_EVENT_GID_CHANGE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_event</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_device</span>	<span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ib_cq</span>	<span class="o">*</span><span class="n">cq</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ib_qp</span>	<span class="o">*</span><span class="n">qp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ib_srq</span>	<span class="o">*</span><span class="n">srq</span><span class="p">;</span>
		<span class="n">u8</span>		<span class="n">port_num</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">element</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_event_type</span>	<span class="n">event</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_event_handler</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">void</span>            <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_event_handler</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_event</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span>  <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define INIT_IB_EVENT_HANDLER(_ptr, _device, _handler)		\</span>
<span class="cp">	do {							\</span>
<span class="cp">		(_ptr)-&gt;device  = _device;			\</span>
<span class="cp">		(_ptr)-&gt;handler = _handler;			\</span>
<span class="cp">		INIT_LIST_HEAD(&amp;(_ptr)-&gt;list);			\</span>
<span class="cp">	} while (0)</span>

<span class="k">struct</span> <span class="n">ib_global_route</span> <span class="p">{</span>
	<span class="k">union</span> <span class="n">ib_gid</span>	<span class="n">dgid</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">flow_label</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">sgid_index</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">hop_limit</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">traffic_class</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_grh</span> <span class="p">{</span>
	<span class="n">__be32</span>		<span class="n">version_tclass_flow</span><span class="p">;</span>
	<span class="n">__be16</span>		<span class="n">paylen</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">next_hdr</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">hop_limit</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ib_gid</span>	<span class="n">sgid</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ib_gid</span>	<span class="n">dgid</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IB_MULTICAST_QPN</span> <span class="o">=</span> <span class="mh">0xffffff</span>
<span class="p">};</span>

<span class="cp">#define IB_LID_PERMISSIVE	cpu_to_be16(0xFFFF)</span>

<span class="k">enum</span> <span class="n">ib_ah_flags</span> <span class="p">{</span>
	<span class="n">IB_AH_GRH</span>	<span class="o">=</span> <span class="mi">1</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_rate</span> <span class="p">{</span>
	<span class="n">IB_RATE_PORT_CURRENT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IB_RATE_2_5_GBPS</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">IB_RATE_5_GBPS</span>   <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">IB_RATE_10_GBPS</span>  <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">IB_RATE_20_GBPS</span>  <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">IB_RATE_30_GBPS</span>  <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">IB_RATE_40_GBPS</span>  <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">IB_RATE_60_GBPS</span>  <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">IB_RATE_80_GBPS</span>  <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
	<span class="n">IB_RATE_120_GBPS</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">IB_RATE_14_GBPS</span>  <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">IB_RATE_56_GBPS</span>  <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	<span class="n">IB_RATE_112_GBPS</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
	<span class="n">IB_RATE_168_GBPS</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
	<span class="n">IB_RATE_25_GBPS</span>  <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
	<span class="n">IB_RATE_100_GBPS</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	<span class="n">IB_RATE_200_GBPS</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>
	<span class="n">IB_RATE_300_GBPS</span> <span class="o">=</span> <span class="mi">18</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ib_rate_to_mult - Convert the IB rate enum to a multiple of the</span>
<span class="cm"> * base rate of 2.5 Gbit/sec.  For example, IB_RATE_5_GBPS will be</span>
<span class="cm"> * converted to 2, since 5 Gbit/sec is 2 * 2.5 Gbit/sec.</span>
<span class="cm"> * @rate: rate to convert.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_rate_to_mult</span><span class="p">(</span><span class="k">enum</span> <span class="n">ib_rate</span> <span class="n">rate</span><span class="p">)</span> <span class="n">__attribute_const__</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * ib_rate_to_mbps - Convert the IB rate enum to Mbps.</span>
<span class="cm"> * For example, IB_RATE_2_5_GBPS will be converted to 2500.</span>
<span class="cm"> * @rate: rate to convert.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_rate_to_mbps</span><span class="p">(</span><span class="k">enum</span> <span class="n">ib_rate</span> <span class="n">rate</span><span class="p">)</span> <span class="n">__attribute_const__</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * mult_to_ib_rate - Convert a multiple of 2.5 Gbit/sec to an IB rate</span>
<span class="cm"> * enum.</span>
<span class="cm"> * @mult: multiple to convert.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ib_rate</span> <span class="n">mult_to_ib_rate</span><span class="p">(</span><span class="kt">int</span> <span class="n">mult</span><span class="p">)</span> <span class="n">__attribute_const__</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ib_ah_attr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_global_route</span>	<span class="n">grh</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">dlid</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">sl</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">src_path_bits</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">static_rate</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">ah_flags</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">port_num</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_wc_status</span> <span class="p">{</span>
	<span class="n">IB_WC_SUCCESS</span><span class="p">,</span>
	<span class="n">IB_WC_LOC_LEN_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_LOC_QP_OP_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_LOC_EEC_OP_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_LOC_PROT_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_WR_FLUSH_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_MW_BIND_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_BAD_RESP_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_LOC_ACCESS_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_REM_INV_REQ_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_REM_ACCESS_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_REM_OP_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_RETRY_EXC_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_RNR_RETRY_EXC_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_LOC_RDD_VIOL_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_REM_INV_RD_REQ_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_REM_ABORT_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_INV_EECN_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_INV_EEC_STATE_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_FATAL_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_RESP_TIMEOUT_ERR</span><span class="p">,</span>
	<span class="n">IB_WC_GENERAL_ERR</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_wc_opcode</span> <span class="p">{</span>
	<span class="n">IB_WC_SEND</span><span class="p">,</span>
	<span class="n">IB_WC_RDMA_WRITE</span><span class="p">,</span>
	<span class="n">IB_WC_RDMA_READ</span><span class="p">,</span>
	<span class="n">IB_WC_COMP_SWAP</span><span class="p">,</span>
	<span class="n">IB_WC_FETCH_ADD</span><span class="p">,</span>
	<span class="n">IB_WC_BIND_MW</span><span class="p">,</span>
	<span class="n">IB_WC_LSO</span><span class="p">,</span>
	<span class="n">IB_WC_LOCAL_INV</span><span class="p">,</span>
	<span class="n">IB_WC_FAST_REG_MR</span><span class="p">,</span>
	<span class="n">IB_WC_MASKED_COMP_SWAP</span><span class="p">,</span>
	<span class="n">IB_WC_MASKED_FETCH_ADD</span><span class="p">,</span>
<span class="cm">/*</span>
<span class="cm"> * Set value of IB_WC_RECV so consumers can test if a completion is a</span>
<span class="cm"> * receive by testing (opcode &amp; IB_WC_RECV).</span>
<span class="cm"> */</span>
	<span class="n">IB_WC_RECV</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">IB_WC_RECV_RDMA_WITH_IMM</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_wc_flags</span> <span class="p">{</span>
	<span class="n">IB_WC_GRH</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IB_WC_WITH_IMM</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IB_WC_WITH_INVALIDATE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">IB_WC_IP_CSUM_OK</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_wc</span> <span class="p">{</span>
	<span class="n">u64</span>			<span class="n">wr_id</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_wc_status</span>	<span class="n">status</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_wc_opcode</span>	<span class="n">opcode</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">vendor_err</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">byte_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_qp</span>	       <span class="o">*</span><span class="n">qp</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__be32</span>		<span class="n">imm_data</span><span class="p">;</span>
		<span class="n">u32</span>		<span class="n">invalidate_rkey</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ex</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">src_qp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">wc_flags</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">pkey_index</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">slid</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">sl</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">dlid_path_bits</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">port_num</span><span class="p">;</span>	<span class="cm">/* valid only for DR SMPs on switches */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_cq_notify_flags</span> <span class="p">{</span>
	<span class="n">IB_CQ_SOLICITED</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IB_CQ_NEXT_COMP</span>			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IB_CQ_SOLICITED_MASK</span>		<span class="o">=</span> <span class="n">IB_CQ_SOLICITED</span> <span class="o">|</span> <span class="n">IB_CQ_NEXT_COMP</span><span class="p">,</span>
	<span class="n">IB_CQ_REPORT_MISSED_EVENTS</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_srq_type</span> <span class="p">{</span>
	<span class="n">IB_SRQT_BASIC</span><span class="p">,</span>
	<span class="n">IB_SRQT_XRC</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_srq_attr_mask</span> <span class="p">{</span>
	<span class="n">IB_SRQ_MAX_WR</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IB_SRQ_LIMIT</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_srq_attr</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">max_wr</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">max_sge</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">srq_limit</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_srq_init_attr</span> <span class="p">{</span>
	<span class="kt">void</span>		      <span class="p">(</span><span class="o">*</span><span class="n">event_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_event</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		       <span class="o">*</span><span class="n">srq_context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_srq_attr</span>	<span class="n">attr</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_srq_type</span>	<span class="n">srq_type</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ib_xrcd</span> <span class="o">*</span><span class="n">xrcd</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">ib_cq</span>   <span class="o">*</span><span class="n">cq</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">xrc</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ext</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_qp_cap</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">max_send_wr</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">max_recv_wr</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">max_send_sge</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">max_recv_sge</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">max_inline_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_sig_type</span> <span class="p">{</span>
	<span class="n">IB_SIGNAL_ALL_WR</span><span class="p">,</span>
	<span class="n">IB_SIGNAL_REQ_WR</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_qp_type</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * IB_QPT_SMI and IB_QPT_GSI have to be the first two entries</span>
<span class="cm">	 * here (and in that order) since the MAD layer uses them as</span>
<span class="cm">	 * indices into a 2-entry table.</span>
<span class="cm">	 */</span>
	<span class="n">IB_QPT_SMI</span><span class="p">,</span>
	<span class="n">IB_QPT_GSI</span><span class="p">,</span>

	<span class="n">IB_QPT_RC</span><span class="p">,</span>
	<span class="n">IB_QPT_UC</span><span class="p">,</span>
	<span class="n">IB_QPT_UD</span><span class="p">,</span>
	<span class="n">IB_QPT_RAW_IPV6</span><span class="p">,</span>
	<span class="n">IB_QPT_RAW_ETHERTYPE</span><span class="p">,</span>
	<span class="n">IB_QPT_RAW_PACKET</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">IB_QPT_XRC_INI</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
	<span class="n">IB_QPT_XRC_TGT</span><span class="p">,</span>
	<span class="n">IB_QPT_MAX</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_qp_create_flags</span> <span class="p">{</span>
	<span class="n">IB_QP_CREATE_IPOIB_UD_LSO</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_qp_init_attr</span> <span class="p">{</span>
	<span class="kt">void</span>                  <span class="p">(</span><span class="o">*</span><span class="n">event_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_event</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		       <span class="o">*</span><span class="n">qp_context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_cq</span>	       <span class="o">*</span><span class="n">send_cq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_cq</span>	       <span class="o">*</span><span class="n">recv_cq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_srq</span>	       <span class="o">*</span><span class="n">srq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_xrcd</span>	       <span class="o">*</span><span class="n">xrcd</span><span class="p">;</span>     <span class="cm">/* XRC TGT QPs only */</span>
	<span class="k">struct</span> <span class="n">ib_qp_cap</span>	<span class="n">cap</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_sig_type</span>	<span class="n">sq_sig_type</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_qp_type</span>		<span class="n">qp_type</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_qp_create_flags</span>	<span class="n">create_flags</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">port_num</span><span class="p">;</span> <span class="cm">/* special QP types only */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_qp_open_attr</span> <span class="p">{</span>
	<span class="kt">void</span>                  <span class="p">(</span><span class="o">*</span><span class="n">event_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_event</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		       <span class="o">*</span><span class="n">qp_context</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">qp_num</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_qp_type</span>		<span class="n">qp_type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_rnr_timeout</span> <span class="p">{</span>
	<span class="n">IB_RNR_TIMER_655_36</span> <span class="o">=</span>  <span class="mi">0</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_000_01</span> <span class="o">=</span>  <span class="mi">1</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_000_02</span> <span class="o">=</span>  <span class="mi">2</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_000_03</span> <span class="o">=</span>  <span class="mi">3</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_000_04</span> <span class="o">=</span>  <span class="mi">4</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_000_06</span> <span class="o">=</span>  <span class="mi">5</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_000_08</span> <span class="o">=</span>  <span class="mi">6</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_000_12</span> <span class="o">=</span>  <span class="mi">7</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_000_16</span> <span class="o">=</span>  <span class="mi">8</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_000_24</span> <span class="o">=</span>  <span class="mi">9</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_000_32</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_000_48</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_000_64</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_000_96</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_001_28</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_001_92</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_002_56</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_003_84</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_005_12</span> <span class="o">=</span> <span class="mi">18</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_007_68</span> <span class="o">=</span> <span class="mi">19</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_010_24</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_015_36</span> <span class="o">=</span> <span class="mi">21</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_020_48</span> <span class="o">=</span> <span class="mi">22</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_030_72</span> <span class="o">=</span> <span class="mi">23</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_040_96</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_061_44</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_081_92</span> <span class="o">=</span> <span class="mi">26</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_122_88</span> <span class="o">=</span> <span class="mi">27</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_163_84</span> <span class="o">=</span> <span class="mi">28</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_245_76</span> <span class="o">=</span> <span class="mi">29</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_327_68</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
	<span class="n">IB_RNR_TIMER_491_52</span> <span class="o">=</span> <span class="mi">31</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_qp_attr_mask</span> <span class="p">{</span>
	<span class="n">IB_QP_STATE</span>			<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IB_QP_CUR_STATE</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IB_QP_EN_SQD_ASYNC_NOTIFY</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">IB_QP_ACCESS_FLAGS</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">IB_QP_PKEY_INDEX</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span>
	<span class="n">IB_QP_PORT</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">),</span>
	<span class="n">IB_QP_QKEY</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">),</span>
	<span class="n">IB_QP_AV</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span>
	<span class="n">IB_QP_PATH_MTU</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">),</span>
	<span class="n">IB_QP_TIMEOUT</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">),</span>
	<span class="n">IB_QP_RETRY_CNT</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">),</span>
	<span class="n">IB_QP_RNR_RETRY</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">11</span><span class="p">),</span>
	<span class="n">IB_QP_RQ_PSN</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">12</span><span class="p">),</span>
	<span class="n">IB_QP_MAX_QP_RD_ATOMIC</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">13</span><span class="p">),</span>
	<span class="n">IB_QP_ALT_PATH</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">14</span><span class="p">),</span>
	<span class="n">IB_QP_MIN_RNR_TIMER</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">15</span><span class="p">),</span>
	<span class="n">IB_QP_SQ_PSN</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">),</span>
	<span class="n">IB_QP_MAX_DEST_RD_ATOMIC</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">17</span><span class="p">),</span>
	<span class="n">IB_QP_PATH_MIG_STATE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">18</span><span class="p">),</span>
	<span class="n">IB_QP_CAP</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">19</span><span class="p">),</span>
	<span class="n">IB_QP_DEST_QPN</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_qp_state</span> <span class="p">{</span>
	<span class="n">IB_QPS_RESET</span><span class="p">,</span>
	<span class="n">IB_QPS_INIT</span><span class="p">,</span>
	<span class="n">IB_QPS_RTR</span><span class="p">,</span>
	<span class="n">IB_QPS_RTS</span><span class="p">,</span>
	<span class="n">IB_QPS_SQD</span><span class="p">,</span>
	<span class="n">IB_QPS_SQE</span><span class="p">,</span>
	<span class="n">IB_QPS_ERR</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_mig_state</span> <span class="p">{</span>
	<span class="n">IB_MIG_MIGRATED</span><span class="p">,</span>
	<span class="n">IB_MIG_REARM</span><span class="p">,</span>
	<span class="n">IB_MIG_ARMED</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_qp_attr</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">ib_qp_state</span>	<span class="n">qp_state</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_qp_state</span>	<span class="n">cur_qp_state</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_mtu</span>		<span class="n">path_mtu</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_mig_state</span>	<span class="n">path_mig_state</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">qkey</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">rq_psn</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">sq_psn</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">dest_qp_num</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">qp_access_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_qp_cap</span>	<span class="n">cap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_ah_attr</span>	<span class="n">ah_attr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_ah_attr</span>	<span class="n">alt_ah_attr</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">pkey_index</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">alt_pkey_index</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">en_sqd_async_notify</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">sq_draining</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">max_rd_atomic</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">max_dest_rd_atomic</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">min_rnr_timer</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">port_num</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">timeout</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">retry_cnt</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">rnr_retry</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">alt_port_num</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">alt_timeout</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_wr_opcode</span> <span class="p">{</span>
	<span class="n">IB_WR_RDMA_WRITE</span><span class="p">,</span>
	<span class="n">IB_WR_RDMA_WRITE_WITH_IMM</span><span class="p">,</span>
	<span class="n">IB_WR_SEND</span><span class="p">,</span>
	<span class="n">IB_WR_SEND_WITH_IMM</span><span class="p">,</span>
	<span class="n">IB_WR_RDMA_READ</span><span class="p">,</span>
	<span class="n">IB_WR_ATOMIC_CMP_AND_SWP</span><span class="p">,</span>
	<span class="n">IB_WR_ATOMIC_FETCH_AND_ADD</span><span class="p">,</span>
	<span class="n">IB_WR_LSO</span><span class="p">,</span>
	<span class="n">IB_WR_SEND_WITH_INV</span><span class="p">,</span>
	<span class="n">IB_WR_RDMA_READ_WITH_INV</span><span class="p">,</span>
	<span class="n">IB_WR_LOCAL_INV</span><span class="p">,</span>
	<span class="n">IB_WR_FAST_REG_MR</span><span class="p">,</span>
	<span class="n">IB_WR_MASKED_ATOMIC_CMP_AND_SWP</span><span class="p">,</span>
	<span class="n">IB_WR_MASKED_ATOMIC_FETCH_AND_ADD</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_send_flags</span> <span class="p">{</span>
	<span class="n">IB_SEND_FENCE</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IB_SEND_SIGNALED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IB_SEND_SOLICITED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">IB_SEND_INLINE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">IB_SEND_IP_CSUM</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_sge</span> <span class="p">{</span>
	<span class="n">u64</span>	<span class="n">addr</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">length</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">lkey</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_fast_reg_page_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_device</span>       <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="n">u64</span>		       <span class="o">*</span><span class="n">page_list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">max_page_list_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_send_wr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_send_wr</span>      <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">wr_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_sge</span>	       <span class="o">*</span><span class="n">sg_list</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">num_sge</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_wr_opcode</span>	<span class="n">opcode</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">send_flags</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__be32</span>		<span class="n">imm_data</span><span class="p">;</span>
		<span class="n">u32</span>		<span class="n">invalidate_rkey</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ex</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u64</span>	<span class="n">remote_addr</span><span class="p">;</span>
			<span class="n">u32</span>	<span class="n">rkey</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">rdma</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u64</span>	<span class="n">remote_addr</span><span class="p">;</span>
			<span class="n">u64</span>	<span class="n">compare_add</span><span class="p">;</span>
			<span class="n">u64</span>	<span class="n">swap</span><span class="p">;</span>
			<span class="n">u64</span>	<span class="n">compare_add_mask</span><span class="p">;</span>
			<span class="n">u64</span>	<span class="n">swap_mask</span><span class="p">;</span>
			<span class="n">u32</span>	<span class="n">rkey</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">atomic</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ib_ah</span> <span class="o">*</span><span class="n">ah</span><span class="p">;</span>
			<span class="kt">void</span>   <span class="o">*</span><span class="n">header</span><span class="p">;</span>
			<span class="kt">int</span>     <span class="n">hlen</span><span class="p">;</span>
			<span class="kt">int</span>     <span class="n">mss</span><span class="p">;</span>
			<span class="n">u32</span>	<span class="n">remote_qpn</span><span class="p">;</span>
			<span class="n">u32</span>	<span class="n">remote_qkey</span><span class="p">;</span>
			<span class="n">u16</span>	<span class="n">pkey_index</span><span class="p">;</span> <span class="cm">/* valid for GSI only */</span>
			<span class="n">u8</span>	<span class="n">port_num</span><span class="p">;</span>   <span class="cm">/* valid for DR SMPs on switch only */</span>
		<span class="p">}</span> <span class="n">ud</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u64</span>				<span class="n">iova_start</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">ib_fast_reg_page_list</span>   <span class="o">*</span><span class="n">page_list</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">page_shift</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">page_list_len</span><span class="p">;</span>
			<span class="n">u32</span>				<span class="n">length</span><span class="p">;</span>
			<span class="kt">int</span>				<span class="n">access_flags</span><span class="p">;</span>
			<span class="n">u32</span>				<span class="n">rkey</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">fast_reg</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">wr</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">xrc_remote_srq_num</span><span class="p">;</span>	<span class="cm">/* XRC TGT QPs only */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_recv_wr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_recv_wr</span>      <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">wr_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_sge</span>	       <span class="o">*</span><span class="n">sg_list</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">num_sge</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_access_flags</span> <span class="p">{</span>
	<span class="n">IB_ACCESS_LOCAL_WRITE</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IB_ACCESS_REMOTE_WRITE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IB_ACCESS_REMOTE_READ</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">IB_ACCESS_REMOTE_ATOMIC</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">IB_ACCESS_MW_BIND</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_phys_buf</span> <span class="p">{</span>
	<span class="n">u64</span>      <span class="n">addr</span><span class="p">;</span>
	<span class="n">u64</span>      <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_mr_attr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_pd</span>	<span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">device_virt_addr</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">mr_access_flags</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">lkey</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">rkey</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_mr_rereg_flags</span> <span class="p">{</span>
	<span class="n">IB_MR_REREG_TRANS</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IB_MR_REREG_PD</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IB_MR_REREG_ACCESS</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_mw_bind</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_mr</span>   <span class="o">*</span><span class="n">mr</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">wr_id</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">addr</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">send_flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">mw_access_flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_fmr_attr</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">max_pages</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">max_maps</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">page_shift</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_ucontext</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_device</span>       <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">pd_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">mr_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">mw_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">cq_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">qp_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">srq_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ah_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">xrcd_list</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">closing</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_uobject</span> <span class="p">{</span>
	<span class="n">u64</span>			<span class="n">user_handle</span><span class="p">;</span>	<span class="cm">/* handle given to us by userspace */</span>
	<span class="k">struct</span> <span class="n">ib_ucontext</span>     <span class="o">*</span><span class="n">context</span><span class="p">;</span>	<span class="cm">/* associated user context */</span>
	<span class="kt">void</span>		       <span class="o">*</span><span class="n">object</span><span class="p">;</span>		<span class="cm">/* containing object */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>		<span class="cm">/* link to context&#39;s list */</span>
	<span class="kt">int</span>			<span class="n">id</span><span class="p">;</span>		<span class="cm">/* index into kernel idr */</span>
	<span class="k">struct</span> <span class="n">kref</span>		<span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>	<span class="n">mutex</span><span class="p">;</span>		<span class="cm">/* protects .live */</span>
	<span class="kt">int</span>			<span class="n">live</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_udata</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">inbuf</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">outbuf</span><span class="p">;</span>
	<span class="kt">size_t</span>       <span class="n">inlen</span><span class="p">;</span>
	<span class="kt">size_t</span>       <span class="n">outlen</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_pd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_device</span>       <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_uobject</span>      <span class="o">*</span><span class="n">uobject</span><span class="p">;</span>
	<span class="n">atomic_t</span>          	<span class="n">usecnt</span><span class="p">;</span> <span class="cm">/* count all resources */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_xrcd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_device</span>       <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">usecnt</span><span class="p">;</span> <span class="cm">/* count all exposed resources */</span>
	<span class="k">struct</span> <span class="n">inode</span>	       <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">tgt_qp_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">tgt_qp_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_ah</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_device</span>	<span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_pd</span>		<span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_uobject</span>	<span class="o">*</span><span class="n">uobject</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ib_comp_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cq_context</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ib_cq</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_device</span>       <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_uobject</span>      <span class="o">*</span><span class="n">uobject</span><span class="p">;</span>
	<span class="n">ib_comp_handler</span>   	<span class="n">comp_handler</span><span class="p">;</span>
	<span class="kt">void</span>                  <span class="p">(</span><span class="o">*</span><span class="n">event_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_event</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>                   <span class="o">*</span><span class="n">cq_context</span><span class="p">;</span>
	<span class="kt">int</span>               	<span class="n">cqe</span><span class="p">;</span>
	<span class="n">atomic_t</span>          	<span class="n">usecnt</span><span class="p">;</span> <span class="cm">/* count number of work queues */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_srq</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_device</span>       <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_pd</span>	       <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_uobject</span>      <span class="o">*</span><span class="n">uobject</span><span class="p">;</span>
	<span class="kt">void</span>		      <span class="p">(</span><span class="o">*</span><span class="n">event_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_event</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		       <span class="o">*</span><span class="n">srq_context</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_srq_type</span>	<span class="n">srq_type</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">usecnt</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ib_xrcd</span> <span class="o">*</span><span class="n">xrcd</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">ib_cq</span>   <span class="o">*</span><span class="n">cq</span><span class="p">;</span>
			<span class="n">u32</span>		<span class="n">srq_num</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">xrc</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ext</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_qp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_device</span>       <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_pd</span>	       <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_cq</span>	       <span class="o">*</span><span class="n">send_cq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_cq</span>	       <span class="o">*</span><span class="n">recv_cq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_srq</span>	       <span class="o">*</span><span class="n">srq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_xrcd</span>	       <span class="o">*</span><span class="n">xrcd</span><span class="p">;</span> <span class="cm">/* XRC TGT QPs only */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">xrcd_list</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">usecnt</span><span class="p">;</span> <span class="cm">/* count times opened, mcast attaches */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">open_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_qp</span>           <span class="o">*</span><span class="n">real_qp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_uobject</span>      <span class="o">*</span><span class="n">uobject</span><span class="p">;</span>
	<span class="kt">void</span>                  <span class="p">(</span><span class="o">*</span><span class="n">event_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_event</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		       <span class="o">*</span><span class="n">qp_context</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">qp_num</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_qp_type</span>		<span class="n">qp_type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_mr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_device</span>  <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_pd</span>	  <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_uobject</span> <span class="o">*</span><span class="n">uobject</span><span class="p">;</span>
	<span class="n">u32</span>		   <span class="n">lkey</span><span class="p">;</span>
	<span class="n">u32</span>		   <span class="n">rkey</span><span class="p">;</span>
	<span class="n">atomic_t</span>	   <span class="n">usecnt</span><span class="p">;</span> <span class="cm">/* count number of MWs */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_mw</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_device</span>	<span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_pd</span>		<span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_uobject</span>	<span class="o">*</span><span class="n">uobject</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">rkey</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_fmr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_device</span>	<span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_pd</span>		<span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">lkey</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">rkey</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_mad</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ib_grh</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">ib_process_mad_flags</span> <span class="p">{</span>
	<span class="n">IB_MAD_IGNORE_MKEY</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IB_MAD_IGNORE_BKEY</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">IB_MAD_IGNORE_ALL</span>	<span class="o">=</span> <span class="n">IB_MAD_IGNORE_MKEY</span> <span class="o">|</span> <span class="n">IB_MAD_IGNORE_BKEY</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ib_mad_result</span> <span class="p">{</span>
	<span class="n">IB_MAD_RESULT_FAILURE</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>      <span class="cm">/* (!SUCCESS is the important flag) */</span>
	<span class="n">IB_MAD_RESULT_SUCCESS</span>  <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* MAD was successfully processed   */</span>
	<span class="n">IB_MAD_RESULT_REPLY</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/* Reply packet needs to be sent    */</span>
	<span class="n">IB_MAD_RESULT_CONSUMED</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>  <span class="cm">/* Packet consumed: stop processing */</span>
<span class="p">};</span>

<span class="cp">#define IB_DEVICE_NAME_MAX 64</span>

<span class="k">struct</span> <span class="n">ib_cache</span> <span class="p">{</span>
	<span class="n">rwlock_t</span>                <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_event_handler</span> <span class="n">event_handler</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_pkey_cache</span>  <span class="o">**</span><span class="n">pkey_cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_gid_cache</span>   <span class="o">**</span><span class="n">gid_cache</span><span class="p">;</span>
	<span class="n">u8</span>                     <span class="o">*</span><span class="n">lmc_cache</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_dma_mapping_ops</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">mapping_error</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="n">u64</span> <span class="n">dma_addr</span><span class="p">);</span>
	<span class="n">u64</span>		<span class="p">(</span><span class="o">*</span><span class="n">map_single</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				      <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">unmap_single</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">);</span>
	<span class="n">u64</span>		<span class="p">(</span><span class="o">*</span><span class="n">map_page</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				    <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">unmap_page</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				      <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">map_sg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
				  <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">unmap_sg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
				    <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">);</span>
	<span class="n">u64</span>		<span class="p">(</span><span class="o">*</span><span class="n">dma_address</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">dma_len</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">sync_single_for_cpu</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					       <span class="n">u64</span> <span class="n">dma_handle</span><span class="p">,</span>
					       <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					       <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">sync_single_for_device</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						  <span class="n">u64</span> <span class="n">dma_handle</span><span class="p">,</span>
						  <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
						  <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc_coherent</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					   <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					   <span class="n">u64</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">,</span>
					   <span class="n">gfp_t</span> <span class="n">flag</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">free_coherent</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span><span class="p">,</span>
					 <span class="n">u64</span> <span class="n">dma_handle</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iw_cm_verbs</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ib_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span>                <span class="o">*</span><span class="n">dma_device</span><span class="p">;</span>

	<span class="kt">char</span>                          <span class="n">name</span><span class="p">[</span><span class="n">IB_DEVICE_NAME_MAX</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">list_head</span>              <span class="n">event_handler_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span>                    <span class="n">event_handler_lock</span><span class="p">;</span>

	<span class="n">spinlock_t</span>                    <span class="n">client_data_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>              <span class="n">core_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>              <span class="n">client_data_list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ib_cache</span>               <span class="n">cache</span><span class="p">;</span>
	<span class="kt">int</span>                          <span class="o">*</span><span class="n">pkey_tbl_len</span><span class="p">;</span>
	<span class="kt">int</span>                          <span class="o">*</span><span class="n">gid_tbl_len</span><span class="p">;</span>

	<span class="kt">int</span>			      <span class="n">num_comp_vectors</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">iw_cm_verbs</span>	     <span class="o">*</span><span class="n">iwcm</span><span class="p">;</span>

	<span class="kt">int</span>		           <span class="p">(</span><span class="o">*</span><span class="n">get_protocol_stats</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
							 <span class="k">union</span> <span class="n">rdma_protocol_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">);</span>
	<span class="kt">int</span>		           <span class="p">(</span><span class="o">*</span><span class="n">query_device</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">ib_device_attr</span> <span class="o">*</span><span class="n">device_attr</span><span class="p">);</span>
	<span class="kt">int</span>		           <span class="p">(</span><span class="o">*</span><span class="n">query_port</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
						 <span class="n">u8</span> <span class="n">port_num</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">ib_port_attr</span> <span class="o">*</span><span class="n">port_attr</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">rdma_link_layer</span>	   <span class="p">(</span><span class="o">*</span><span class="n">get_link_layer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
						     <span class="n">u8</span> <span class="n">port_num</span><span class="p">);</span>
	<span class="kt">int</span>		           <span class="p">(</span><span class="o">*</span><span class="n">query_gid</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
						<span class="n">u8</span> <span class="n">port_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
						<span class="k">union</span> <span class="n">ib_gid</span> <span class="o">*</span><span class="n">gid</span><span class="p">);</span>
	<span class="kt">int</span>		           <span class="p">(</span><span class="o">*</span><span class="n">query_pkey</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
						 <span class="n">u8</span> <span class="n">port_num</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pkey</span><span class="p">);</span>
	<span class="kt">int</span>		           <span class="p">(</span><span class="o">*</span><span class="n">modify_device</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
						    <span class="kt">int</span> <span class="n">device_modify_mask</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">ib_device_modify</span> <span class="o">*</span><span class="n">device_modify</span><span class="p">);</span>
	<span class="kt">int</span>		           <span class="p">(</span><span class="o">*</span><span class="n">modify_port</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
						  <span class="n">u8</span> <span class="n">port_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port_modify_mask</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">ib_port_modify</span> <span class="o">*</span><span class="n">port_modify</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ib_ucontext</span> <span class="o">*</span>       <span class="p">(</span><span class="o">*</span><span class="n">alloc_ucontext</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">dealloc_ucontext</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_ucontext</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">mmap</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_ucontext</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span>             <span class="p">(</span><span class="o">*</span><span class="n">alloc_pd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ib_ucontext</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">dealloc_pd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ib_ah</span> <span class="o">*</span>             <span class="p">(</span><span class="o">*</span><span class="n">create_ah</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ib_ah_attr</span> <span class="o">*</span><span class="n">ah_attr</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">modify_ah</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_ah</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ib_ah_attr</span> <span class="o">*</span><span class="n">ah_attr</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">query_ah</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_ah</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ib_ah_attr</span> <span class="o">*</span><span class="n">ah_attr</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">destroy_ah</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_ah</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ib_srq</span> <span class="o">*</span>            <span class="p">(</span><span class="o">*</span><span class="n">create_srq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">ib_srq_init_attr</span> <span class="o">*</span><span class="n">srq_init_attr</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">modify_srq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_srq</span> <span class="o">*</span><span class="n">srq</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">ib_srq_attr</span> <span class="o">*</span><span class="n">srq_attr</span><span class="p">,</span>
						 <span class="k">enum</span> <span class="n">ib_srq_attr_mask</span> <span class="n">srq_attr_mask</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">query_srq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_srq</span> <span class="o">*</span><span class="n">srq</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ib_srq_attr</span> <span class="o">*</span><span class="n">srq_attr</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">destroy_srq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_srq</span> <span class="o">*</span><span class="n">srq</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">post_srq_recv</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_srq</span> <span class="o">*</span><span class="n">srq</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">ib_recv_wr</span> <span class="o">*</span><span class="n">recv_wr</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">ib_recv_wr</span> <span class="o">**</span><span class="n">bad_recv_wr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span>             <span class="p">(</span><span class="o">*</span><span class="n">create_qp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ib_qp_init_attr</span> <span class="o">*</span><span class="n">qp_init_attr</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">modify_qp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ib_qp_attr</span> <span class="o">*</span><span class="n">qp_attr</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">qp_attr_mask</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">query_qp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ib_qp_attr</span> <span class="o">*</span><span class="n">qp_attr</span><span class="p">,</span>
					       <span class="kt">int</span> <span class="n">qp_attr_mask</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ib_qp_init_attr</span> <span class="o">*</span><span class="n">qp_init_attr</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">destroy_qp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">post_send</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ib_send_wr</span> <span class="o">*</span><span class="n">send_wr</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ib_send_wr</span> <span class="o">**</span><span class="n">bad_send_wr</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">post_recv</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ib_recv_wr</span> <span class="o">*</span><span class="n">recv_wr</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ib_recv_wr</span> <span class="o">**</span><span class="n">bad_recv_wr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span>             <span class="p">(</span><span class="o">*</span><span class="n">create_cq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cqe</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">comp_vector</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ib_ucontext</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">modify_cq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="n">u16</span> <span class="n">cq_count</span><span class="p">,</span>
						<span class="n">u16</span> <span class="n">cq_period</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">destroy_cq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">resize_cq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cqe</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">poll_cq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_entries</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">ib_wc</span> <span class="o">*</span><span class="n">wc</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">peek_cq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wc_cnt</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">req_notify_cq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span>
						    <span class="k">enum</span> <span class="n">ib_cq_notify_flags</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">req_ncomp_notif</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span>
						      <span class="kt">int</span> <span class="n">wc_cnt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span>             <span class="p">(</span><span class="o">*</span><span class="n">get_dma_mr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
						 <span class="kt">int</span> <span class="n">mr_access_flags</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span>             <span class="p">(</span><span class="o">*</span><span class="n">reg_phys_mr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">ib_phys_buf</span> <span class="o">*</span><span class="n">phys_buf_array</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">num_phys_buf</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">mr_access_flags</span><span class="p">,</span>
						  <span class="n">u64</span> <span class="o">*</span><span class="n">iova_start</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span>             <span class="p">(</span><span class="o">*</span><span class="n">reg_user_mr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
						  <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">length</span><span class="p">,</span>
						  <span class="n">u64</span> <span class="n">virt_addr</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">mr_access_flags</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">query_mr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span><span class="n">mr</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ib_mr_attr</span> <span class="o">*</span><span class="n">mr_attr</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">dereg_mr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span><span class="n">mr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span>		   <span class="p">(</span><span class="o">*</span><span class="n">alloc_fast_reg_mr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
					       <span class="kt">int</span> <span class="n">max_page_list_len</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ib_fast_reg_page_list</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">alloc_fast_reg_page_list</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
								   <span class="kt">int</span> <span class="n">page_list_len</span><span class="p">);</span>
	<span class="kt">void</span>			   <span class="p">(</span><span class="o">*</span><span class="n">free_fast_reg_page_list</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_fast_reg_page_list</span> <span class="o">*</span><span class="n">page_list</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">rereg_phys_mr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span><span class="n">mr</span><span class="p">,</span>
						    <span class="kt">int</span> <span class="n">mr_rereg_mask</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">ib_phys_buf</span> <span class="o">*</span><span class="n">phys_buf_array</span><span class="p">,</span>
						    <span class="kt">int</span> <span class="n">num_phys_buf</span><span class="p">,</span>
						    <span class="kt">int</span> <span class="n">mr_access_flags</span><span class="p">,</span>
						    <span class="n">u64</span> <span class="o">*</span><span class="n">iova_start</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ib_mw</span> <span class="o">*</span>             <span class="p">(</span><span class="o">*</span><span class="n">alloc_mw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">bind_mw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">ib_mw</span> <span class="o">*</span><span class="n">mw</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">ib_mw_bind</span> <span class="o">*</span><span class="n">mw_bind</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">dealloc_mw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_mw</span> <span class="o">*</span><span class="n">mw</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ib_fmr</span> <span class="o">*</span>	           <span class="p">(</span><span class="o">*</span><span class="n">alloc_fmr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">mr_access_flags</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ib_fmr_attr</span> <span class="o">*</span><span class="n">fmr_attr</span><span class="p">);</span>
	<span class="kt">int</span>		           <span class="p">(</span><span class="o">*</span><span class="n">map_phys_fmr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_fmr</span> <span class="o">*</span><span class="n">fmr</span><span class="p">,</span>
						   <span class="n">u64</span> <span class="o">*</span><span class="n">page_list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">list_len</span><span class="p">,</span>
						   <span class="n">u64</span> <span class="n">iova</span><span class="p">);</span>
	<span class="kt">int</span>		           <span class="p">(</span><span class="o">*</span><span class="n">unmap_fmr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">fmr_list</span><span class="p">);</span>
	<span class="kt">int</span>		           <span class="p">(</span><span class="o">*</span><span class="n">dealloc_fmr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_fmr</span> <span class="o">*</span><span class="n">fmr</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">attach_mcast</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span>
						   <span class="k">union</span> <span class="n">ib_gid</span> <span class="o">*</span><span class="n">gid</span><span class="p">,</span>
						   <span class="n">u16</span> <span class="n">lid</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">detach_mcast</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span>
						   <span class="k">union</span> <span class="n">ib_gid</span> <span class="o">*</span><span class="n">gid</span><span class="p">,</span>
						   <span class="n">u16</span> <span class="n">lid</span><span class="p">);</span>
	<span class="kt">int</span>                        <span class="p">(</span><span class="o">*</span><span class="n">process_mad</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">process_mad_flags</span><span class="p">,</span>
						  <span class="n">u8</span> <span class="n">port_num</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">ib_wc</span> <span class="o">*</span><span class="n">in_wc</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">ib_grh</span> <span class="o">*</span><span class="n">in_grh</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">ib_mad</span> <span class="o">*</span><span class="n">in_mad</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">ib_mad</span> <span class="o">*</span><span class="n">out_mad</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ib_xrcd</span> <span class="o">*</span>	   <span class="p">(</span><span class="o">*</span><span class="n">alloc_xrcd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">ib_ucontext</span> <span class="o">*</span><span class="n">ucontext</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">);</span>
	<span class="kt">int</span>			   <span class="p">(</span><span class="o">*</span><span class="n">dealloc_xrcd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_xrcd</span> <span class="o">*</span><span class="n">xrcd</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">ib_dma_mapping_ops</span>   <span class="o">*</span><span class="n">dma_ops</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">module</span>               <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>                <span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span>               <span class="o">*</span><span class="n">ports_parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>             <span class="n">port_list</span><span class="p">;</span>

	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">IB_DEV_UNINITIALIZED</span><span class="p">,</span>
		<span class="n">IB_DEV_REGISTERED</span><span class="p">,</span>
		<span class="n">IB_DEV_UNREGISTERED</span>
	<span class="p">}</span>                            <span class="n">reg_state</span><span class="p">;</span>

	<span class="kt">int</span>			     <span class="n">uverbs_abi_ver</span><span class="p">;</span>
	<span class="n">u64</span>			     <span class="n">uverbs_cmd_mask</span><span class="p">;</span>

	<span class="kt">char</span>			     <span class="n">node_desc</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="n">__be64</span>			     <span class="n">node_guid</span><span class="p">;</span>
	<span class="n">u32</span>			     <span class="n">local_dma_lkey</span><span class="p">;</span>
	<span class="n">u8</span>                           <span class="n">node_type</span><span class="p">;</span>
	<span class="n">u8</span>                           <span class="n">phys_port_cnt</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_client</span> <span class="p">{</span>
	<span class="kt">char</span>  <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">add</span><span class="p">)</span>   <span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">ib_alloc_device</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ib_dealloc_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ib_register_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">port_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="p">,</span>
					    <span class="n">u8</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">void</span> <span class="n">ib_unregister_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ib_register_client</span>   <span class="p">(</span><span class="k">struct</span> <span class="n">ib_client</span> <span class="o">*</span><span class="n">client</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ib_unregister_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_client</span> <span class="o">*</span><span class="n">client</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">ib_get_client_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_client</span> <span class="o">*</span><span class="n">client</span><span class="p">);</span>
<span class="kt">void</span>  <span class="n">ib_set_client_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ib_copy_from_udata</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">udata</span><span class="o">-&gt;</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ib_copy_to_udata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">udata</span><span class="o">-&gt;</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_modify_qp_is_ok - Check that the supplied attribute mask</span>
<span class="cm"> * contains all required attributes and no attributes not allowed for</span>
<span class="cm"> * the given QP state transition.</span>
<span class="cm"> * @cur_state: Current QP state</span>
<span class="cm"> * @next_state: Next QP state</span>
<span class="cm"> * @type: QP type</span>
<span class="cm"> * @mask: Mask of supplied QP attributes</span>
<span class="cm"> *</span>
<span class="cm"> * This function is a helper function that a low-level driver&#39;s</span>
<span class="cm"> * modify_qp method can use to validate the consumer&#39;s input.  It</span>
<span class="cm"> * checks that cur_state and next_state are valid QP states, that a</span>
<span class="cm"> * transition from cur_state to next_state is allowed by the IB spec,</span>
<span class="cm"> * and that the attribute mask supplied is allowed for the transition.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_modify_qp_is_ok</span><span class="p">(</span><span class="k">enum</span> <span class="n">ib_qp_state</span> <span class="n">cur_state</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ib_qp_state</span> <span class="n">next_state</span><span class="p">,</span>
		       <span class="k">enum</span> <span class="n">ib_qp_type</span> <span class="n">type</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ib_qp_attr_mask</span> <span class="n">mask</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ib_register_event_handler</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">ib_event_handler</span> <span class="o">*</span><span class="n">event_handler</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ib_unregister_event_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_event_handler</span> <span class="o">*</span><span class="n">event_handler</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ib_dispatch_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ib_query_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">ib_device_attr</span> <span class="o">*</span><span class="n">device_attr</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ib_query_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
		  <span class="n">u8</span> <span class="n">port_num</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_port_attr</span> <span class="o">*</span><span class="n">port_attr</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">rdma_link_layer</span> <span class="n">rdma_port_get_link_layer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
					       <span class="n">u8</span> <span class="n">port_num</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ib_query_gid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
		 <span class="n">u8</span> <span class="n">port_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">union</span> <span class="n">ib_gid</span> <span class="o">*</span><span class="n">gid</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ib_query_pkey</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
		  <span class="n">u8</span> <span class="n">port_num</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pkey</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ib_modify_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">device_modify_mask</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ib_device_modify</span> <span class="o">*</span><span class="n">device_modify</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ib_modify_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
		   <span class="n">u8</span> <span class="n">port_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port_modify_mask</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">ib_port_modify</span> <span class="o">*</span><span class="n">port_modify</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ib_find_gid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="k">union</span> <span class="n">ib_gid</span> <span class="o">*</span><span class="n">gid</span><span class="p">,</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">port_num</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">index</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ib_find_pkey</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
		 <span class="n">u8</span> <span class="n">port_num</span><span class="p">,</span> <span class="n">u16</span> <span class="n">pkey</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">index</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_alloc_pd - Allocates an unused protection domain.</span>
<span class="cm"> * @device: The device on which to allocate the protection domain.</span>
<span class="cm"> *</span>
<span class="cm"> * A protection domain object provides an association between QPs, shared</span>
<span class="cm"> * receive queues, address handles, memory regions, and memory windows.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">ib_alloc_pd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_dealloc_pd - Deallocates a protection domain.</span>
<span class="cm"> * @pd: The protection domain to deallocate.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_dealloc_pd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_create_ah - Creates an address handle for the given address vector.</span>
<span class="cm"> * @pd: The protection domain associated with the address handle.</span>
<span class="cm"> * @ah_attr: The attributes of the address vector.</span>
<span class="cm"> *</span>
<span class="cm"> * The address handle is used to reference a local or global destination</span>
<span class="cm"> * in all UD QP post sends.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ib_ah</span> <span class="o">*</span><span class="n">ib_create_ah</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_ah_attr</span> <span class="o">*</span><span class="n">ah_attr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_init_ah_from_wc - Initializes address handle attributes from a</span>
<span class="cm"> *   work completion.</span>
<span class="cm"> * @device: Device on which the received message arrived.</span>
<span class="cm"> * @port_num: Port on which the received message arrived.</span>
<span class="cm"> * @wc: Work completion associated with the received message.</span>
<span class="cm"> * @grh: References the received global route header.  This parameter is</span>
<span class="cm"> *   ignored unless the work completion indicates that the GRH is valid.</span>
<span class="cm"> * @ah_attr: Returned attributes that can be used when creating an address</span>
<span class="cm"> *   handle for replying to the message.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_init_ah_from_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port_num</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_wc</span> <span class="o">*</span><span class="n">wc</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ib_grh</span> <span class="o">*</span><span class="n">grh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_ah_attr</span> <span class="o">*</span><span class="n">ah_attr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_create_ah_from_wc - Creates an address handle associated with the</span>
<span class="cm"> *   sender of the specified work completion.</span>
<span class="cm"> * @pd: The protection domain associated with the address handle.</span>
<span class="cm"> * @wc: Work completion information associated with a received message.</span>
<span class="cm"> * @grh: References the received global route header.  This parameter is</span>
<span class="cm"> *   ignored unless the work completion indicates that the GRH is valid.</span>
<span class="cm"> * @port_num: The outbound port number to associate with the address.</span>
<span class="cm"> *</span>
<span class="cm"> * The address handle is used to reference a local or global destination</span>
<span class="cm"> * in all UD QP post sends.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ib_ah</span> <span class="o">*</span><span class="n">ib_create_ah_from_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_wc</span> <span class="o">*</span><span class="n">wc</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ib_grh</span> <span class="o">*</span><span class="n">grh</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port_num</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_modify_ah - Modifies the address vector associated with an address</span>
<span class="cm"> *   handle.</span>
<span class="cm"> * @ah: The address handle to modify.</span>
<span class="cm"> * @ah_attr: The new address vector attributes to associate with the</span>
<span class="cm"> *   address handle.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_modify_ah</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_ah</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_ah_attr</span> <span class="o">*</span><span class="n">ah_attr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_query_ah - Queries the address vector associated with an address</span>
<span class="cm"> *   handle.</span>
<span class="cm"> * @ah: The address handle to query.</span>
<span class="cm"> * @ah_attr: The address vector attributes associated with the address</span>
<span class="cm"> *   handle.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_query_ah</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_ah</span> <span class="o">*</span><span class="n">ah</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_ah_attr</span> <span class="o">*</span><span class="n">ah_attr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_destroy_ah - Destroys an address handle.</span>
<span class="cm"> * @ah: The address handle to destroy.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_destroy_ah</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_ah</span> <span class="o">*</span><span class="n">ah</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_create_srq - Creates a SRQ associated with the specified protection</span>
<span class="cm"> *   domain.</span>
<span class="cm"> * @pd: The protection domain associated with the SRQ.</span>
<span class="cm"> * @srq_init_attr: A list of initial attributes required to create the</span>
<span class="cm"> *   SRQ.  If SRQ creation succeeds, then the attributes are updated to</span>
<span class="cm"> *   the actual capabilities of the created SRQ.</span>
<span class="cm"> *</span>
<span class="cm"> * srq_attr-&gt;max_wr and srq_attr-&gt;max_sge are read the determine the</span>
<span class="cm"> * requested size of the SRQ, and set to the actual values allocated</span>
<span class="cm"> * on return.  If ib_create_srq() succeeds, then max_wr and max_sge</span>
<span class="cm"> * will always be at least as large as the requested values.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ib_srq</span> <span class="o">*</span><span class="n">ib_create_srq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ib_srq_init_attr</span> <span class="o">*</span><span class="n">srq_init_attr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_modify_srq - Modifies the attributes for the specified SRQ.</span>
<span class="cm"> * @srq: The SRQ to modify.</span>
<span class="cm"> * @srq_attr: On input, specifies the SRQ attributes to modify.  On output,</span>
<span class="cm"> *   the current values of selected SRQ attributes are returned.</span>
<span class="cm"> * @srq_attr_mask: A bit-mask used to specify which attributes of the SRQ</span>
<span class="cm"> *   are being modified.</span>
<span class="cm"> *</span>
<span class="cm"> * The mask may contain IB_SRQ_MAX_WR to resize the SRQ and/or</span>
<span class="cm"> * IB_SRQ_LIMIT to set the SRQ&#39;s limit and request notification when</span>
<span class="cm"> * the number of receives queued drops below the limit.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_modify_srq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_srq</span> <span class="o">*</span><span class="n">srq</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">ib_srq_attr</span> <span class="o">*</span><span class="n">srq_attr</span><span class="p">,</span>
		  <span class="k">enum</span> <span class="n">ib_srq_attr_mask</span> <span class="n">srq_attr_mask</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_query_srq - Returns the attribute list and current values for the</span>
<span class="cm"> *   specified SRQ.</span>
<span class="cm"> * @srq: The SRQ to query.</span>
<span class="cm"> * @srq_attr: The attributes of the specified SRQ.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_query_srq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_srq</span> <span class="o">*</span><span class="n">srq</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">ib_srq_attr</span> <span class="o">*</span><span class="n">srq_attr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_destroy_srq - Destroys the specified SRQ.</span>
<span class="cm"> * @srq: The SRQ to destroy.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_destroy_srq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_srq</span> <span class="o">*</span><span class="n">srq</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_post_srq_recv - Posts a list of work requests to the specified SRQ.</span>
<span class="cm"> * @srq: The SRQ to post the work request on.</span>
<span class="cm"> * @recv_wr: A list of work requests to post on the receive queue.</span>
<span class="cm"> * @bad_recv_wr: On an immediate failure, this parameter will reference</span>
<span class="cm"> *   the work request that failed to be posted on the QP.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ib_post_srq_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_srq</span> <span class="o">*</span><span class="n">srq</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ib_recv_wr</span> <span class="o">*</span><span class="n">recv_wr</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ib_recv_wr</span> <span class="o">**</span><span class="n">bad_recv_wr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">srq</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">post_srq_recv</span><span class="p">(</span><span class="n">srq</span><span class="p">,</span> <span class="n">recv_wr</span><span class="p">,</span> <span class="n">bad_recv_wr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_create_qp - Creates a QP associated with the specified protection</span>
<span class="cm"> *   domain.</span>
<span class="cm"> * @pd: The protection domain associated with the QP.</span>
<span class="cm"> * @qp_init_attr: A list of initial attributes required to create the</span>
<span class="cm"> *   QP.  If QP creation succeeds, then the attributes are updated to</span>
<span class="cm"> *   the actual capabilities of the created QP.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">ib_create_qp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ib_qp_init_attr</span> <span class="o">*</span><span class="n">qp_init_attr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_modify_qp - Modifies the attributes for the specified QP and then</span>
<span class="cm"> *   transitions the QP to the given state.</span>
<span class="cm"> * @qp: The QP to modify.</span>
<span class="cm"> * @qp_attr: On input, specifies the QP attributes to modify.  On output,</span>
<span class="cm"> *   the current values of selected QP attributes are returned.</span>
<span class="cm"> * @qp_attr_mask: A bit-mask used to specify which attributes of the QP</span>
<span class="cm"> *   are being modified.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_modify_qp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">ib_qp_attr</span> <span class="o">*</span><span class="n">qp_attr</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">qp_attr_mask</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_query_qp - Returns the attribute list and current values for the</span>
<span class="cm"> *   specified QP.</span>
<span class="cm"> * @qp: The QP to query.</span>
<span class="cm"> * @qp_attr: The attributes of the specified QP.</span>
<span class="cm"> * @qp_attr_mask: A bit-mask used to select specific attributes to query.</span>
<span class="cm"> * @qp_init_attr: Additional attributes of the selected QP.</span>
<span class="cm"> *</span>
<span class="cm"> * The qp_attr_mask may be used to limit the query to gathering only the</span>
<span class="cm"> * selected attributes.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_query_qp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ib_qp_attr</span> <span class="o">*</span><span class="n">qp_attr</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">qp_attr_mask</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ib_qp_init_attr</span> <span class="o">*</span><span class="n">qp_init_attr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_destroy_qp - Destroys the specified QP.</span>
<span class="cm"> * @qp: The QP to destroy.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_destroy_qp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_open_qp - Obtain a reference to an existing sharable QP.</span>
<span class="cm"> * @xrcd - XRC domain</span>
<span class="cm"> * @qp_open_attr: Attributes identifying the QP to open.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a reference to a sharable QP.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">ib_open_qp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_xrcd</span> <span class="o">*</span><span class="n">xrcd</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ib_qp_open_attr</span> <span class="o">*</span><span class="n">qp_open_attr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_close_qp - Release an external reference to a QP.</span>
<span class="cm"> * @qp: The QP handle to release</span>
<span class="cm"> *</span>
<span class="cm"> * The opened QP handle is released by the caller.  The underlying</span>
<span class="cm"> * shared QP is not destroyed until all internal references are released.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_close_qp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_post_send - Posts a list of work requests to the send queue of</span>
<span class="cm"> *   the specified QP.</span>
<span class="cm"> * @qp: The QP to post the work request on.</span>
<span class="cm"> * @send_wr: A list of work requests to post on the send queue.</span>
<span class="cm"> * @bad_send_wr: On an immediate failure, this parameter will reference</span>
<span class="cm"> *   the work request that failed to be posted on the QP.</span>
<span class="cm"> *</span>
<span class="cm"> * While IBA Vol. 1 section 11.4.1.1 specifies that if an immediate</span>
<span class="cm"> * error is returned, the QP state shall not be affected,</span>
<span class="cm"> * ib_post_send() will return an immediate error after queueing any</span>
<span class="cm"> * earlier work requests in the list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ib_post_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ib_send_wr</span> <span class="o">*</span><span class="n">send_wr</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ib_send_wr</span> <span class="o">**</span><span class="n">bad_send_wr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">qp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">post_send</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="n">send_wr</span><span class="p">,</span> <span class="n">bad_send_wr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_post_recv - Posts a list of work requests to the receive queue of</span>
<span class="cm"> *   the specified QP.</span>
<span class="cm"> * @qp: The QP to post the work request on.</span>
<span class="cm"> * @recv_wr: A list of work requests to post on the receive queue.</span>
<span class="cm"> * @bad_recv_wr: On an immediate failure, this parameter will reference</span>
<span class="cm"> *   the work request that failed to be posted on the QP.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ib_post_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ib_recv_wr</span> <span class="o">*</span><span class="n">recv_wr</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ib_recv_wr</span> <span class="o">**</span><span class="n">bad_recv_wr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">qp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">post_recv</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="n">recv_wr</span><span class="p">,</span> <span class="n">bad_recv_wr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_create_cq - Creates a CQ on the specified device.</span>
<span class="cm"> * @device: The device on which to create the CQ.</span>
<span class="cm"> * @comp_handler: A user-specified callback that is invoked when a</span>
<span class="cm"> *   completion event occurs on the CQ.</span>
<span class="cm"> * @event_handler: A user-specified callback that is invoked when an</span>
<span class="cm"> *   asynchronous event not associated with a completion occurs on the CQ.</span>
<span class="cm"> * @cq_context: Context associated with the CQ returned to the user via</span>
<span class="cm"> *   the associated completion and event handlers.</span>
<span class="cm"> * @cqe: The minimum size of the CQ.</span>
<span class="cm"> * @comp_vector - Completion vector used to signal completion events.</span>
<span class="cm"> *     Must be &gt;= 0 and &lt; context-&gt;num_comp_vectors.</span>
<span class="cm"> *</span>
<span class="cm"> * Users can examine the cq structure to determine the actual CQ size.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">ib_create_cq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
			   <span class="n">ib_comp_handler</span> <span class="n">comp_handler</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">event_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ib_event</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">cq_context</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cqe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">comp_vector</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_resize_cq - Modifies the capacity of the CQ.</span>
<span class="cm"> * @cq: The CQ to resize.</span>
<span class="cm"> * @cqe: The minimum size of the CQ.</span>
<span class="cm"> *</span>
<span class="cm"> * Users can examine the cq structure to determine the actual CQ size.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_resize_cq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cqe</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_modify_cq - Modifies moderation params of the CQ</span>
<span class="cm"> * @cq: The CQ to modify.</span>
<span class="cm"> * @cq_count: number of CQEs that will trigger an event</span>
<span class="cm"> * @cq_period: max period of time in usec before triggering an event</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_modify_cq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="n">u16</span> <span class="n">cq_count</span><span class="p">,</span> <span class="n">u16</span> <span class="n">cq_period</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_destroy_cq - Destroys the specified CQ.</span>
<span class="cm"> * @cq: The CQ to destroy.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_destroy_cq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_poll_cq - poll a CQ for completion(s)</span>
<span class="cm"> * @cq:the CQ being polled</span>
<span class="cm"> * @num_entries:maximum number of completions to return</span>
<span class="cm"> * @wc:array of at least @num_entries &amp;struct ib_wc where completions</span>
<span class="cm"> *   will be returned</span>
<span class="cm"> *</span>
<span class="cm"> * Poll a CQ for (possibly multiple) completions.  If the return value</span>
<span class="cm"> * is &lt; 0, an error occurred.  If the return value is &gt;= 0, it is the</span>
<span class="cm"> * number of completions returned.  If the return value is</span>
<span class="cm"> * non-negative and &lt; num_entries, then the CQ was emptied.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ib_poll_cq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_entries</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ib_wc</span> <span class="o">*</span><span class="n">wc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">poll_cq</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span> <span class="n">num_entries</span><span class="p">,</span> <span class="n">wc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_peek_cq - Returns the number of unreaped completions currently</span>
<span class="cm"> *   on the specified CQ.</span>
<span class="cm"> * @cq: The CQ to peek.</span>
<span class="cm"> * @wc_cnt: A minimum number of unreaped completions to check for.</span>
<span class="cm"> *</span>
<span class="cm"> * If the number of unreaped completions is greater than or equal to wc_cnt,</span>
<span class="cm"> * this function returns wc_cnt, otherwise, it returns the actual number of</span>
<span class="cm"> * unreaped completions.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_peek_cq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wc_cnt</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_req_notify_cq - Request completion notification on a CQ.</span>
<span class="cm"> * @cq: The CQ to generate an event for.</span>
<span class="cm"> * @flags:</span>
<span class="cm"> *   Must contain exactly one of %IB_CQ_SOLICITED or %IB_CQ_NEXT_COMP</span>
<span class="cm"> *   to request an event on the next solicited event or next work</span>
<span class="cm"> *   completion at any type, respectively. %IB_CQ_REPORT_MISSED_EVENTS</span>
<span class="cm"> *   may also be |ed in to request a hint about missed events, as</span>
<span class="cm"> *   described below.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *    &lt; 0 means an error occurred while requesting notification</span>
<span class="cm"> *   == 0 means notification was requested successfully, and if</span>
<span class="cm"> *        IB_CQ_REPORT_MISSED_EVENTS was passed in, then no events</span>
<span class="cm"> *        were missed and it is safe to wait for another event.  In</span>
<span class="cm"> *        this case is it guaranteed that any work completions added</span>
<span class="cm"> *        to the CQ since the last CQ poll will trigger a completion</span>
<span class="cm"> *        notification event.</span>
<span class="cm"> *    &gt; 0 is only returned if IB_CQ_REPORT_MISSED_EVENTS was passed</span>
<span class="cm"> *        in.  It means that the consumer must poll the CQ again to</span>
<span class="cm"> *        make sure it is empty to avoid missing an event because of a</span>
<span class="cm"> *        race between requesting notification and an entry being</span>
<span class="cm"> *        added to the CQ.  This return value means it is possible</span>
<span class="cm"> *        (but not guaranteed) that a work completion has been added</span>
<span class="cm"> *        to the CQ since the last poll without triggering a</span>
<span class="cm"> *        completion notification event.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ib_req_notify_cq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">ib_cq_notify_flags</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">req_notify_cq</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_req_ncomp_notif - Request completion notification when there are</span>
<span class="cm"> *   at least the specified number of unreaped completions on the CQ.</span>
<span class="cm"> * @cq: The CQ to generate an event for.</span>
<span class="cm"> * @wc_cnt: The number of unreaped completions that should be on the</span>
<span class="cm"> *   CQ before an event is generated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ib_req_ncomp_notif</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wc_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">req_ncomp_notif</span> <span class="o">?</span>
		<span class="n">cq</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">req_ncomp_notif</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span> <span class="n">wc_cnt</span><span class="p">)</span> <span class="o">:</span>
		<span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_get_dma_mr - Returns a memory region for system memory that is</span>
<span class="cm"> *   usable for DMA.</span>
<span class="cm"> * @pd: The protection domain associated with the memory region.</span>
<span class="cm"> * @mr_access_flags: Specifies the memory access rights.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the ib_dma_*() functions defined below must be used</span>
<span class="cm"> * to create/destroy addresses used with the Lkey or Rkey returned</span>
<span class="cm"> * by ib_get_dma_mr().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span><span class="n">ib_get_dma_mr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mr_access_flags</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_dma_mapping_error - check a DMA addr for error</span>
<span class="cm"> * @dev: The device for which the dma_addr was created</span>
<span class="cm"> * @dma_addr: The DMA address to check</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ib_dma_mapping_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">dma_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">mapping_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_device</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_dma_map_single - Map a kernel virtual address to DMA address</span>
<span class="cm"> * @dev: The device for which the dma_addr is to be created</span>
<span class="cm"> * @cpu_addr: The kernel virtual address</span>
<span class="cm"> * @size: The size of the region in bytes</span>
<span class="cm"> * @direction: The direction of the DMA</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">ib_dma_map_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				    <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cpu_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_device</span><span class="p">,</span> <span class="n">cpu_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_dma_unmap_single - Destroy a mapping created by ib_dma_map_single()</span>
<span class="cm"> * @dev: The device for which the DMA address was created</span>
<span class="cm"> * @addr: The DMA address</span>
<span class="cm"> * @size: The size of the region in bytes</span>
<span class="cm"> * @direction: The direction of the DMA</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ib_dma_unmap_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				       <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				       <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_device</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">ib_dma_map_single_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					  <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dma_map_single_attrs</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_device</span><span class="p">,</span> <span class="n">cpu_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
				    <span class="n">direction</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ib_dma_unmap_single_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					     <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					     <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dma_unmap_single_attrs</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_device</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
				      <span class="n">direction</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_dma_map_page - Map a physical page to DMA address</span>
<span class="cm"> * @dev: The device for which the dma_addr is to be created</span>
<span class="cm"> * @page: The page to be mapped</span>
<span class="cm"> * @offset: The offset within the page</span>
<span class="cm"> * @size: The size of the region in bytes</span>
<span class="cm"> * @direction: The direction of the DMA</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">ib_dma_map_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					 <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">map_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dma_map_page</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_device</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_dma_unmap_page - Destroy a mapping created by ib_dma_map_page()</span>
<span class="cm"> * @dev: The device for which the DMA address was created</span>
<span class="cm"> * @addr: The DMA address</span>
<span class="cm"> * @size: The size of the region in bytes</span>
<span class="cm"> * @direction: The direction of the DMA</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ib_dma_unmap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">unmap_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dma_unmap_page</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_device</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_dma_map_sg - Map a scatter/gather list to DMA addresses</span>
<span class="cm"> * @dev: The device for which the DMA addresses are to be created</span>
<span class="cm"> * @sg: The array of scatter/gather entries</span>
<span class="cm"> * @nents: The number of scatter/gather entries</span>
<span class="cm"> * @direction: The direction of the DMA</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ib_dma_map_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">map_sg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dma_map_sg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_device</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_dma_unmap_sg - Unmap a scatter/gather list of DMA addresses</span>
<span class="cm"> * @dev: The device for which the DMA addresses were created</span>
<span class="cm"> * @sg: The array of scatter/gather entries</span>
<span class="cm"> * @nents: The number of scatter/gather entries</span>
<span class="cm"> * @direction: The direction of the DMA</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ib_dma_unmap_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">unmap_sg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_device</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ib_dma_map_sg_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
				      <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dma_map_sg_attrs</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_device</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ib_dma_unmap_sg_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
					 <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_unmap_sg_attrs</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_device</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * ib_sg_dma_address - Return the DMA address from a scatter/gather entry</span>
<span class="cm"> * @dev: The device for which the DMA addresses were created</span>
<span class="cm"> * @sg: The scatter/gather entry</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">ib_sg_dma_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">dma_address</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_sg_dma_len - Return the DMA length from a scatter/gather entry</span>
<span class="cm"> * @dev: The device for which the DMA addresses were created</span>
<span class="cm"> * @sg: The scatter/gather entry</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ib_sg_dma_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">dma_len</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_dma_sync_single_for_cpu - Prepare DMA region to be accessed by CPU</span>
<span class="cm"> * @dev: The device for which the DMA address was created</span>
<span class="cm"> * @addr: The DMA address</span>
<span class="cm"> * @size: The size of the region in bytes</span>
<span class="cm"> * @dir: The direction of the DMA</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ib_dma_sync_single_for_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					      <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span>
					      <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					      <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">sync_single_for_cpu</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_device</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_dma_sync_single_for_device - Prepare DMA region to be accessed by device</span>
<span class="cm"> * @dev: The device for which the DMA address was created</span>
<span class="cm"> * @addr: The DMA address</span>
<span class="cm"> * @size: The size of the region in bytes</span>
<span class="cm"> * @dir: The direction of the DMA</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ib_dma_sync_single_for_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						 <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span>
						 <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
						 <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">sync_single_for_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_device</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_dma_alloc_coherent - Allocate memory and map it for DMA</span>
<span class="cm"> * @dev: The device for which the DMA address is requested</span>
<span class="cm"> * @size: The size of the region to allocate in bytes</span>
<span class="cm"> * @dma_handle: A pointer for returning the DMA address of the region</span>
<span class="cm"> * @flag: memory allocator flags</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">ib_dma_alloc_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					   <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					   <span class="n">u64</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">,</span>
					   <span class="n">gfp_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">handle</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_device</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dma_handle</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_dma_free_coherent - Free memory allocated by ib_dma_alloc_coherent()</span>
<span class="cm"> * @dev: The device for which the DMA addresses were allocated</span>
<span class="cm"> * @size: The size of the region</span>
<span class="cm"> * @cpu_addr: the address returned by ib_dma_alloc_coherent()</span>
<span class="cm"> * @dma_handle: the DMA address returned by ib_dma_alloc_coherent()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ib_dma_free_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span><span class="p">,</span>
					<span class="n">u64</span> <span class="n">dma_handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">free_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cpu_addr</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_device</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cpu_addr</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_reg_phys_mr - Prepares a virtually addressed memory region for use</span>
<span class="cm"> *   by an HCA.</span>
<span class="cm"> * @pd: The protection domain associated assigned to the registered region.</span>
<span class="cm"> * @phys_buf_array: Specifies a list of physical buffers to use in the</span>
<span class="cm"> *   memory region.</span>
<span class="cm"> * @num_phys_buf: Specifies the size of the phys_buf_array.</span>
<span class="cm"> * @mr_access_flags: Specifies the memory access rights.</span>
<span class="cm"> * @iova_start: The offset of the region&#39;s starting I/O virtual address.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span><span class="n">ib_reg_phys_mr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ib_phys_buf</span> <span class="o">*</span><span class="n">phys_buf_array</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">num_phys_buf</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">mr_access_flags</span><span class="p">,</span>
			     <span class="n">u64</span> <span class="o">*</span><span class="n">iova_start</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_rereg_phys_mr - Modifies the attributes of an existing memory region.</span>
<span class="cm"> *   Conceptually, this call performs the functions deregister memory region</span>
<span class="cm"> *   followed by register physical memory region.  Where possible,</span>
<span class="cm"> *   resources are reused instead of deallocated and reallocated.</span>
<span class="cm"> * @mr: The memory region to modify.</span>
<span class="cm"> * @mr_rereg_mask: A bit-mask used to indicate which of the following</span>
<span class="cm"> *   properties of the memory region are being modified.</span>
<span class="cm"> * @pd: If %IB_MR_REREG_PD is set in mr_rereg_mask, this field specifies</span>
<span class="cm"> *   the new protection domain to associated with the memory region,</span>
<span class="cm"> *   otherwise, this parameter is ignored.</span>
<span class="cm"> * @phys_buf_array: If %IB_MR_REREG_TRANS is set in mr_rereg_mask, this</span>
<span class="cm"> *   field specifies a list of physical buffers to use in the new</span>
<span class="cm"> *   translation, otherwise, this parameter is ignored.</span>
<span class="cm"> * @num_phys_buf: If %IB_MR_REREG_TRANS is set in mr_rereg_mask, this</span>
<span class="cm"> *   field specifies the size of the phys_buf_array, otherwise, this</span>
<span class="cm"> *   parameter is ignored.</span>
<span class="cm"> * @mr_access_flags: If %IB_MR_REREG_ACCESS is set in mr_rereg_mask, this</span>
<span class="cm"> *   field specifies the new memory access rights, otherwise, this</span>
<span class="cm"> *   parameter is ignored.</span>
<span class="cm"> * @iova_start: The offset of the region&#39;s starting I/O virtual address.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_rereg_phys_mr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span><span class="n">mr</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">mr_rereg_mask</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ib_phys_buf</span> <span class="o">*</span><span class="n">phys_buf_array</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">num_phys_buf</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">mr_access_flags</span><span class="p">,</span>
		     <span class="n">u64</span> <span class="o">*</span><span class="n">iova_start</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_query_mr - Retrieves information about a specific memory region.</span>
<span class="cm"> * @mr: The memory region to retrieve information about.</span>
<span class="cm"> * @mr_attr: The attributes of the specified memory region.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_query_mr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span><span class="n">mr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_mr_attr</span> <span class="o">*</span><span class="n">mr_attr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_dereg_mr - Deregisters a memory region and removes it from the</span>
<span class="cm"> *   HCA translation table.</span>
<span class="cm"> * @mr: The memory region to deregister.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_dereg_mr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span><span class="n">mr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_alloc_fast_reg_mr - Allocates memory region usable with the</span>
<span class="cm"> *   IB_WR_FAST_REG_MR send work request.</span>
<span class="cm"> * @pd: The protection domain associated with the region.</span>
<span class="cm"> * @max_page_list_len: requested max physical buffer list length to be</span>
<span class="cm"> *   used with fast register work requests for this MR.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span><span class="n">ib_alloc_fast_reg_mr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_page_list_len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_alloc_fast_reg_page_list - Allocates a page list array</span>
<span class="cm"> * @device - ib device pointer.</span>
<span class="cm"> * @page_list_len - size of the page list array to be allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * This allocates and returns a struct ib_fast_reg_page_list * and a</span>
<span class="cm"> * page_list array that is at least page_list_len in size.  The actual</span>
<span class="cm"> * size is returned in max_page_list_len.  The caller is responsible</span>
<span class="cm"> * for initializing the contents of the page_list array before posting</span>
<span class="cm"> * a send work request with the IB_WC_FAST_REG_MR opcode.</span>
<span class="cm"> *</span>
<span class="cm"> * The page_list array entries must be translated using one of the</span>
<span class="cm"> * ib_dma_*() functions just like the addresses passed to</span>
<span class="cm"> * ib_map_phys_fmr().  Once the ib_post_send() is issued, the struct</span>
<span class="cm"> * ib_fast_reg_page_list must not be modified by the caller until the</span>
<span class="cm"> * IB_WC_FAST_REG_MR work request completes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ib_fast_reg_page_list</span> <span class="o">*</span><span class="n">ib_alloc_fast_reg_page_list</span><span class="p">(</span>
				<span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page_list_len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_free_fast_reg_page_list - Deallocates a previously allocated</span>
<span class="cm"> *   page list array.</span>
<span class="cm"> * @page_list - struct ib_fast_reg_page_list pointer to be deallocated.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ib_free_fast_reg_page_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_fast_reg_page_list</span> <span class="o">*</span><span class="n">page_list</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_update_fast_reg_key - updates the key portion of the fast_reg MR</span>
<span class="cm"> *   R_Key and L_Key.</span>
<span class="cm"> * @mr - struct ib_mr pointer to be updated.</span>
<span class="cm"> * @newkey - new key to be used.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ib_update_fast_reg_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_mr</span> <span class="o">*</span><span class="n">mr</span><span class="p">,</span> <span class="n">u8</span> <span class="n">newkey</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mr</span><span class="o">-&gt;</span><span class="n">lkey</span> <span class="o">=</span> <span class="p">(</span><span class="n">mr</span><span class="o">-&gt;</span><span class="n">lkey</span> <span class="o">&amp;</span> <span class="mh">0xffffff00</span><span class="p">)</span> <span class="o">|</span> <span class="n">newkey</span><span class="p">;</span>
	<span class="n">mr</span><span class="o">-&gt;</span><span class="n">rkey</span> <span class="o">=</span> <span class="p">(</span><span class="n">mr</span><span class="o">-&gt;</span><span class="n">rkey</span> <span class="o">&amp;</span> <span class="mh">0xffffff00</span><span class="p">)</span> <span class="o">|</span> <span class="n">newkey</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_alloc_mw - Allocates a memory window.</span>
<span class="cm"> * @pd: The protection domain associated with the memory window.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ib_mw</span> <span class="o">*</span><span class="n">ib_alloc_mw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_bind_mw - Posts a work request to the send queue of the specified</span>
<span class="cm"> *   QP, which binds the memory window to the given address range and</span>
<span class="cm"> *   remote access attributes.</span>
<span class="cm"> * @qp: QP to post the bind work request on.</span>
<span class="cm"> * @mw: The memory window to bind.</span>
<span class="cm"> * @mw_bind: Specifies information about the memory window, including</span>
<span class="cm"> *   its address range, remote access rights, and associated memory region.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ib_bind_mw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ib_mw</span> <span class="o">*</span><span class="n">mw</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ib_mw_bind</span> <span class="o">*</span><span class="n">mw_bind</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* XXX reference counting in corresponding MR? */</span>
	<span class="k">return</span> <span class="n">mw</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">bind_mw</span> <span class="o">?</span>
		<span class="n">mw</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">bind_mw</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="n">mw</span><span class="p">,</span> <span class="n">mw_bind</span><span class="p">)</span> <span class="o">:</span>
		<span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_dealloc_mw - Deallocates a memory window.</span>
<span class="cm"> * @mw: The memory window to deallocate.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_dealloc_mw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_mw</span> <span class="o">*</span><span class="n">mw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_alloc_fmr - Allocates a unmapped fast memory region.</span>
<span class="cm"> * @pd: The protection domain associated with the unmapped region.</span>
<span class="cm"> * @mr_access_flags: Specifies the memory access rights.</span>
<span class="cm"> * @fmr_attr: Attributes of the unmapped region.</span>
<span class="cm"> *</span>
<span class="cm"> * A fast memory region must be mapped before it can be used as part of</span>
<span class="cm"> * a work request.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ib_fmr</span> <span class="o">*</span><span class="n">ib_alloc_fmr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">mr_access_flags</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ib_fmr_attr</span> <span class="o">*</span><span class="n">fmr_attr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_map_phys_fmr - Maps a list of physical pages to a fast memory region.</span>
<span class="cm"> * @fmr: The fast memory region to associate with the pages.</span>
<span class="cm"> * @page_list: An array of physical pages to map to the fast memory region.</span>
<span class="cm"> * @list_len: The number of pages in page_list.</span>
<span class="cm"> * @iova: The I/O virtual address to use with the mapped region.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ib_map_phys_fmr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_fmr</span> <span class="o">*</span><span class="n">fmr</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="o">*</span><span class="n">page_list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">list_len</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="n">iova</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">fmr</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">map_phys_fmr</span><span class="p">(</span><span class="n">fmr</span><span class="p">,</span> <span class="n">page_list</span><span class="p">,</span> <span class="n">list_len</span><span class="p">,</span> <span class="n">iova</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ib_unmap_fmr - Removes the mapping from a list of fast memory regions.</span>
<span class="cm"> * @fmr_list: A linked list of fast memory regions to unmap.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_unmap_fmr</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">fmr_list</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_dealloc_fmr - Deallocates a fast memory region.</span>
<span class="cm"> * @fmr: The fast memory region to deallocate.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_dealloc_fmr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_fmr</span> <span class="o">*</span><span class="n">fmr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_attach_mcast - Attaches the specified QP to a multicast group.</span>
<span class="cm"> * @qp: QP to attach to the multicast group.  The QP must be type</span>
<span class="cm"> *   IB_QPT_UD.</span>
<span class="cm"> * @gid: Multicast group GID.</span>
<span class="cm"> * @lid: Multicast group LID in host byte order.</span>
<span class="cm"> *</span>
<span class="cm"> * In order to send and receive multicast packets, subnet</span>
<span class="cm"> * administration must have created the multicast group and configured</span>
<span class="cm"> * the fabric appropriately.  The port associated with the specified</span>
<span class="cm"> * QP must also be a member of the multicast group.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_attach_mcast</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span> <span class="k">union</span> <span class="n">ib_gid</span> <span class="o">*</span><span class="n">gid</span><span class="p">,</span> <span class="n">u16</span> <span class="n">lid</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_detach_mcast - Detaches the specified QP from a multicast group.</span>
<span class="cm"> * @qp: QP to detach from the multicast group.</span>
<span class="cm"> * @gid: Multicast group GID.</span>
<span class="cm"> * @lid: Multicast group LID in host byte order.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_detach_mcast</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span> <span class="k">union</span> <span class="n">ib_gid</span> <span class="o">*</span><span class="n">gid</span><span class="p">,</span> <span class="n">u16</span> <span class="n">lid</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_alloc_xrcd - Allocates an XRC domain.</span>
<span class="cm"> * @device: The device on which to allocate the XRC domain.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ib_xrcd</span> <span class="o">*</span><span class="n">ib_alloc_xrcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ib_dealloc_xrcd - Deallocates an XRC domain.</span>
<span class="cm"> * @xrcd: The XRC domain to deallocate.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ib_dealloc_xrcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_xrcd</span> <span class="o">*</span><span class="n">xrcd</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* IB_VERBS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
