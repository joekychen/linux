<!DOCTYPE html>
<html><head><title>joekychen/linux » include › media › videobuf2-core.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>videobuf2-core.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * videobuf2-core.h - V4L2 driver helper framework</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2010 Samsung Electronics</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Pawel Osciak &lt;pawel@osciak.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _MEDIA_VIDEOBUF2_CORE_H</span>
<span class="cp">#define _MEDIA_VIDEOBUF2_CORE_H</span>

<span class="cp">#include &lt;linux/mm_types.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/videodev2.h&gt;</span>

<span class="k">struct</span> <span class="n">vb2_alloc_ctx</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">vb2_fileio_data</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct vb2_mem_ops - memory handling/memory allocator operations</span>
<span class="cm"> * @alloc:	allocate video memory and, optionally, allocator private data,</span>
<span class="cm"> *		return NULL on failure or a pointer to allocator private,</span>
<span class="cm"> *		per-buffer data on success; the returned private structure</span>
<span class="cm"> *		will then be passed as buf_priv argument to other ops in this</span>
<span class="cm"> *		structure</span>
<span class="cm"> * @put:	inform the allocator that the buffer will no longer be used;</span>
<span class="cm"> *		usually will result in the allocator freeing the buffer (if</span>
<span class="cm"> *		no other users of this buffer are present); the buf_priv</span>
<span class="cm"> *		argument is the allocator private per-buffer structure</span>
<span class="cm"> *		previously returned from the alloc callback</span>
<span class="cm"> * @get_userptr: acquire userspace memory for a hardware operation; used for</span>
<span class="cm"> *		 USERPTR memory types; vaddr is the address passed to the</span>
<span class="cm"> *		 videobuf layer when queuing a video buffer of USERPTR type;</span>
<span class="cm"> *		 should return an allocator private per-buffer structure</span>
<span class="cm"> *		 associated with the buffer on success, NULL on failure;</span>
<span class="cm"> *		 the returned private structure will then be passed as buf_priv</span>
<span class="cm"> *		 argument to other ops in this structure</span>
<span class="cm"> * @put_userptr: inform the allocator that a USERPTR buffer will no longer</span>
<span class="cm"> *		 be used</span>
<span class="cm"> * @vaddr:	return a kernel virtual address to a given memory buffer</span>
<span class="cm"> *		associated with the passed private structure or NULL if no</span>
<span class="cm"> *		such mapping exists</span>
<span class="cm"> * @cookie:	return allocator specific cookie for a given memory buffer</span>
<span class="cm"> *		associated with the passed private structure or NULL if not</span>
<span class="cm"> *		available</span>
<span class="cm"> * @num_users:	return the current number of users of a memory buffer;</span>
<span class="cm"> *		return 1 if the videobuf layer (or actually the driver using</span>
<span class="cm"> *		it) is the only user</span>
<span class="cm"> * @mmap:	setup a userspace mapping for a given memory buffer under</span>
<span class="cm"> *		the provided virtual memory region</span>
<span class="cm"> *</span>
<span class="cm"> * Required ops for USERPTR types: get_userptr, put_userptr.</span>
<span class="cm"> * Required ops for MMAP types: alloc, put, num_users, mmap.</span>
<span class="cm"> * Required ops for read/write access types: alloc, put, num_users, vaddr</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vb2_mem_ops</span> <span class="p">{</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">alloc_ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">put</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf_priv</span><span class="p">);</span>

	<span class="kt">void</span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_userptr</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">alloc_ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">put_userptr</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf_priv</span><span class="p">);</span>

	<span class="kt">void</span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">vaddr</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf_priv</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">cookie</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf_priv</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">num_users</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf_priv</span><span class="p">);</span>

	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">mmap</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf_priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vb2_plane</span> <span class="p">{</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">mem_priv</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum vb2_io_modes - queue access methods</span>
<span class="cm"> * @VB2_MMAP:		driver supports MMAP with streaming API</span>
<span class="cm"> * @VB2_USERPTR:	driver supports USERPTR with streaming API</span>
<span class="cm"> * @VB2_READ:		driver supports read() style access</span>
<span class="cm"> * @VB2_WRITE:		driver supports write() style access</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">vb2_io_modes</span> <span class="p">{</span>
	<span class="n">VB2_MMAP</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">VB2_USERPTR</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">VB2_READ</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">VB2_WRITE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum vb2_fileio_flags - flags for selecting a mode of the file io emulator,</span>
<span class="cm"> * by default the &#39;streaming&#39; style is used by the file io emulator</span>
<span class="cm"> * @VB2_FILEIO_READ_ONCE:	report EOF after reading the first buffer</span>
<span class="cm"> * @VB2_FILEIO_WRITE_IMMEDIATELY:	queue buffer after each write() call</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">vb2_fileio_flags</span> <span class="p">{</span>
	<span class="n">VB2_FILEIO_READ_ONCE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">VB2_FILEIO_WRITE_IMMEDIATELY</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum vb2_buffer_state - current video buffer state</span>
<span class="cm"> * @VB2_BUF_STATE_DEQUEUED:	buffer under userspace control</span>
<span class="cm"> * @VB2_BUF_STATE_PREPARED:	buffer prepared in videobuf and by the driver</span>
<span class="cm"> * @VB2_BUF_STATE_QUEUED:	buffer queued in videobuf, but not in driver</span>
<span class="cm"> * @VB2_BUF_STATE_ACTIVE:	buffer queued in driver and possibly used</span>
<span class="cm"> *				in a hardware operation</span>
<span class="cm"> * @VB2_BUF_STATE_DONE:		buffer returned from driver to videobuf, but</span>
<span class="cm"> *				not yet dequeued to userspace</span>
<span class="cm"> * @VB2_BUF_STATE_ERROR:	same as above, but the operation on the buffer</span>
<span class="cm"> *				has ended with an error, which will be reported</span>
<span class="cm"> *				to the userspace when it is dequeued</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">vb2_buffer_state</span> <span class="p">{</span>
	<span class="n">VB2_BUF_STATE_DEQUEUED</span><span class="p">,</span>
	<span class="n">VB2_BUF_STATE_PREPARED</span><span class="p">,</span>
	<span class="n">VB2_BUF_STATE_QUEUED</span><span class="p">,</span>
	<span class="n">VB2_BUF_STATE_ACTIVE</span><span class="p">,</span>
	<span class="n">VB2_BUF_STATE_DONE</span><span class="p">,</span>
	<span class="n">VB2_BUF_STATE_ERROR</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vb2_queue</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct vb2_buffer - represents a video buffer</span>
<span class="cm"> * @v4l2_buf:		struct v4l2_buffer associated with this buffer; can</span>
<span class="cm"> *			be read by the driver and relevant entries can be</span>
<span class="cm"> *			changed by the driver in case of CAPTURE types</span>
<span class="cm"> *			(such as timestamp)</span>
<span class="cm"> * @v4l2_planes:	struct v4l2_planes associated with this buffer; can</span>
<span class="cm"> *			be read by the driver and relevant entries can be</span>
<span class="cm"> *			changed by the driver in case of CAPTURE types</span>
<span class="cm"> *			(such as bytesused); NOTE that even for single-planar</span>
<span class="cm"> *			types, the v4l2_planes[0] struct should be used</span>
<span class="cm"> *			instead of v4l2_buf for filling bytesused - drivers</span>
<span class="cm"> *			should use the vb2_set_plane_payload() function for that</span>
<span class="cm"> * @vb2_queue:		the queue to which this driver belongs</span>
<span class="cm"> * @num_planes:		number of planes in the buffer</span>
<span class="cm"> *			on an internal driver queue</span>
<span class="cm"> * @state:		current buffer state; do not change</span>
<span class="cm"> * @queued_entry:	entry on the queued buffers list, which holds all</span>
<span class="cm"> *			buffers queued from userspace</span>
<span class="cm"> * @done_entry:		entry on the list that stores all buffers ready to</span>
<span class="cm"> *			be dequeued to userspace</span>
<span class="cm"> * @planes:		private per-plane information; do not change</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_buffer</span>	<span class="n">v4l2_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_plane</span>	<span class="n">v4l2_planes</span><span class="p">[</span><span class="n">VIDEO_MAX_PLANES</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">vb2_queue</span>	<span class="o">*</span><span class="n">vb2_queue</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">num_planes</span><span class="p">;</span>

<span class="cm">/* Private: internal use only */</span>
	<span class="k">enum</span> <span class="n">vb2_buffer_state</span>	<span class="n">state</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">queued_entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">done_entry</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">vb2_plane</span>	<span class="n">planes</span><span class="p">[</span><span class="n">VIDEO_MAX_PLANES</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vb2_ops - driver-specific callbacks</span>
<span class="cm"> *</span>
<span class="cm"> * @queue_setup:	called from VIDIOC_REQBUFS and VIDIOC_CREATE_BUFS</span>
<span class="cm"> *			handlers before memory allocation, or, if</span>
<span class="cm"> *			*num_planes != 0, after the allocation to verify a</span>
<span class="cm"> *			smaller number of buffers. Driver should return</span>
<span class="cm"> *			the required number of buffers in *num_buffers, the</span>
<span class="cm"> *			required number of planes per buffer in *num_planes; the</span>
<span class="cm"> *			size of each plane should be set in the sizes[] array</span>
<span class="cm"> *			and optional per-plane allocator specific context in the</span>
<span class="cm"> *			alloc_ctxs[] array. When called from VIDIOC_REQBUFS,</span>
<span class="cm"> *			fmt == NULL, the driver has to use the currently</span>
<span class="cm"> *			configured format and *num_buffers is the total number</span>
<span class="cm"> *			of buffers, that are being allocated. When called from</span>
<span class="cm"> *			VIDIOC_CREATE_BUFS, fmt != NULL and it describes the</span>
<span class="cm"> *			target frame format. In this case *num_buffers are being</span>
<span class="cm"> *			allocated additionally to q-&gt;num_buffers.</span>
<span class="cm"> * @wait_prepare:	release any locks taken while calling vb2 functions;</span>
<span class="cm"> *			it is called before an ioctl needs to wait for a new</span>
<span class="cm"> *			buffer to arrive; required to avoid a deadlock in</span>
<span class="cm"> *			blocking access type</span>
<span class="cm"> * @wait_finish:	reacquire all locks released in the previous callback;</span>
<span class="cm"> *			required to continue operation after sleeping while</span>
<span class="cm"> *			waiting for a new buffer to arrive</span>
<span class="cm"> * @buf_init:		called once after allocating a buffer (in MMAP case)</span>
<span class="cm"> *			or after acquiring a new USERPTR buffer; drivers may</span>
<span class="cm"> *			perform additional buffer-related initialization;</span>
<span class="cm"> *			initialization failure (return != 0) will prevent</span>
<span class="cm"> *			queue setup from completing successfully; optional</span>
<span class="cm"> * @buf_prepare:	called every time the buffer is queued from userspace</span>
<span class="cm"> *			and from the VIDIOC_PREPARE_BUF ioctl; drivers may</span>
<span class="cm"> *			perform any initialization required before each hardware</span>
<span class="cm"> *			operation in this callback; if an error is returned, the</span>
<span class="cm"> *			buffer will not be queued in driver; optional</span>
<span class="cm"> * @buf_finish:		called before every dequeue of the buffer back to</span>
<span class="cm"> *			userspace; drivers may perform any operations required</span>
<span class="cm"> *			before userspace accesses the buffer; optional</span>
<span class="cm"> * @buf_cleanup:	called once before the buffer is freed; drivers may</span>
<span class="cm"> *			perform any additional cleanup; optional</span>
<span class="cm"> * @start_streaming:	called once to enter &#39;streaming&#39; state; the driver may</span>
<span class="cm"> *			receive buffers with @buf_queue callback before</span>
<span class="cm"> *			@start_streaming is called; the driver gets the number</span>
<span class="cm"> *			of already queued buffers in count parameter; driver</span>
<span class="cm"> *			can return an error if hardware fails or not enough</span>
<span class="cm"> *			buffers has been queued, in such case all buffers that</span>
<span class="cm"> *			have been already given by the @buf_queue callback are</span>
<span class="cm"> *			invalidated.</span>
<span class="cm"> * @stop_streaming:	called when &#39;streaming&#39; state must be disabled; driver</span>
<span class="cm"> *			should stop any DMA transactions or wait until they</span>
<span class="cm"> *			finish and give back all buffers it got from buf_queue()</span>
<span class="cm"> *			callback; may use vb2_wait_for_all_buffers() function</span>
<span class="cm"> * @buf_queue:		passes buffer vb to the driver; driver may start</span>
<span class="cm"> *			hardware operation on this buffer; driver should give</span>
<span class="cm"> *			the buffer back by calling vb2_buffer_done() function;</span>
<span class="cm"> *			it is allways called after calling STREAMON ioctl;</span>
<span class="cm"> *			might be called before start_streaming callback if user</span>
<span class="cm"> *			pre-queued buffers before calling STREAMON</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vb2_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">queue_setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">num_buffers</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">num_planes</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sizes</span><span class="p">[],</span> <span class="kt">void</span> <span class="o">*</span><span class="n">alloc_ctxs</span><span class="p">[]);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">wait_prepare</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">wait_finish</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">buf_init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">buf_prepare</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">buf_finish</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">buf_cleanup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">start_streaming</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">stop_streaming</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">buf_queue</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vb2_queue - a videobuf queue</span>
<span class="cm"> *</span>
<span class="cm"> * @type:	queue type (see V4L2_BUF_TYPE_* in linux/videodev2.h</span>
<span class="cm"> * @io_modes:	supported io methods (see vb2_io_modes enum)</span>
<span class="cm"> * @io_flags:	additional io flags (see vb2_fileio_flags enum)</span>
<span class="cm"> * @ops:	driver-specific callbacks</span>
<span class="cm"> * @mem_ops:	memory allocator specific callbacks</span>
<span class="cm"> * @drv_priv:	driver private data</span>
<span class="cm"> * @buf_struct_size: size of the driver-specific buffer structure;</span>
<span class="cm"> *		&quot;0&quot; indicates the driver doesn&#39;t want to use a custom buffer</span>
<span class="cm"> *		structure type, so sizeof(struct vb2_buffer) will is used</span>
<span class="cm"> *</span>
<span class="cm"> * @memory:	current memory type used</span>
<span class="cm"> * @bufs:	videobuf buffer structures</span>
<span class="cm"> * @num_buffers: number of allocated/used buffers</span>
<span class="cm"> * @queued_list: list of buffers currently queued from userspace</span>
<span class="cm"> * @queued_count: number of buffers owned by the driver</span>
<span class="cm"> * @done_list:	list of buffers ready to be dequeued to userspace</span>
<span class="cm"> * @done_lock:	lock to protect done_list list</span>
<span class="cm"> * @done_wq:	waitqueue for processes waiting for buffers ready to be dequeued</span>
<span class="cm"> * @alloc_ctx:	memory type/allocator-specific contexts for each plane</span>
<span class="cm"> * @streaming:	current streaming state</span>
<span class="cm"> * @fileio:	file io emulator internal data, used only if emulator is active</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vb2_queue</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">v4l2_buf_type</span>		<span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">io_modes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">io_flags</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">vb2_ops</span>		<span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">vb2_mem_ops</span>	<span class="o">*</span><span class="n">mem_ops</span><span class="p">;</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">drv_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">buf_struct_size</span><span class="p">;</span>

<span class="cm">/* private: internal use only */</span>
	<span class="k">enum</span> <span class="n">v4l2_memory</span>		<span class="n">memory</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vb2_buffer</span>		<span class="o">*</span><span class="n">bufs</span><span class="p">[</span><span class="n">VIDEO_MAX_FRAME</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">num_buffers</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">queued_list</span><span class="p">;</span>

	<span class="n">atomic_t</span>			<span class="n">queued_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">done_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span>			<span class="n">done_lock</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>		<span class="n">done_wq</span><span class="p">;</span>

	<span class="kt">void</span>				<span class="o">*</span><span class="n">alloc_ctx</span><span class="p">[</span><span class="n">VIDEO_MAX_PLANES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">plane_sizes</span><span class="p">[</span><span class="n">VIDEO_MAX_PLANES</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">streaming</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">vb2_fileio_data</span>		<span class="o">*</span><span class="n">fileio</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">vb2_plane_vaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plane_no</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">vb2_plane_cookie</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plane_no</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vb2_buffer_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span> <span class="k">enum</span> <span class="n">vb2_buffer_state</span> <span class="n">state</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vb2_wait_for_all_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">vb2_querybuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vb2_reqbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_requestbuffers</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">vb2_create_bufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_create_buffers</span> <span class="o">*</span><span class="n">create</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vb2_prepare_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">vb2_queue_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">vb2_queue_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">vb2_qbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vb2_dqbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">bool</span> <span class="n">nonblocking</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">vb2_streamon</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">enum</span> <span class="n">v4l2_buf_type</span> <span class="n">type</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vb2_streamoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">enum</span> <span class="n">v4l2_buf_type</span> <span class="n">type</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">vb2_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_MMU</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vb2_get_unmapped_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vb2_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="n">vb2_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblock</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="n">vb2_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_is_streaming() - return streaming status of the queue</span>
<span class="cm"> * @q:		videobuf queue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">vb2_is_streaming</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_is_busy() - return busy status of the queue</span>
<span class="cm"> * @q:		videobuf queue</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks if queue has any buffers allocated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">vb2_is_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_get_drv_priv() - return driver private data associated with the queue</span>
<span class="cm"> * @q:		videobuf queue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">vb2_get_drv_priv</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">drv_priv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_set_plane_payload() - set bytesused for the plane plane_no</span>
<span class="cm"> * @vb:		buffer for which plane payload should be set</span>
<span class="cm"> * @plane_no:	plane number for which payload should be set</span>
<span class="cm"> * @size:	payload in bytes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vb2_set_plane_payload</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plane_no</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">plane_no</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">)</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane_no</span><span class="p">].</span><span class="n">bytesused</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_get_plane_payload() - get bytesused for the plane plane_no</span>
<span class="cm"> * @vb:		buffer for which plane payload should be set</span>
<span class="cm"> * @plane_no:	plane number for which payload should be set</span>
<span class="cm"> * @size:	payload in bytes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">vb2_get_plane_payload</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plane_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">plane_no</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane_no</span><span class="p">].</span><span class="n">bytesused</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vb2_plane_size() - return plane size in bytes</span>
<span class="cm"> * @vb:		buffer for which plane size should be returned</span>
<span class="cm"> * @plane_no:	plane number for which size should be returned</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">vb2_plane_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plane_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">plane_no</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">v4l2_planes</span><span class="p">[</span><span class="n">plane_no</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* _MEDIA_VIDEOBUF2_CORE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
