<!DOCTYPE html>
<html><head><title>joekychen/linux » include › media › v4l2-subdev.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>v4l2-subdev.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">    V4L2 sub-device support header.</span>

<span class="cm">    Copyright (C) 2008  Hans Verkuil &lt;hverkuil@xs4all.nl&gt;</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _V4L2_SUBDEV_H</span>
<span class="cp">#define _V4L2_SUBDEV_H</span>

<span class="cp">#include &lt;linux/v4l2-subdev.h&gt;</span>
<span class="cp">#include &lt;media/media-entity.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-common.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-dev.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-fh.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-mediabus.h&gt;</span>

<span class="cm">/* generic v4l2_device notify callback notification values */</span>
<span class="cp">#define V4L2_SUBDEV_IR_RX_NOTIFY		_IOW(&#39;v&#39;, 0, u32)</span>
<span class="cp">#define V4L2_SUBDEV_IR_RX_FIFO_SERVICE_REQ	0x00000001</span>
<span class="cp">#define V4L2_SUBDEV_IR_RX_END_OF_RX_DETECTED	0x00000002</span>
<span class="cp">#define V4L2_SUBDEV_IR_RX_HW_FIFO_OVERRUN	0x00000004</span>
<span class="cp">#define V4L2_SUBDEV_IR_RX_SW_FIFO_OVERRUN	0x00000008</span>

<span class="cp">#define V4L2_SUBDEV_IR_TX_NOTIFY		_IOW(&#39;v&#39;, 1, u32)</span>
<span class="cp">#define V4L2_SUBDEV_IR_TX_FIFO_SERVICE_REQ	0x00000001</span>

<span class="k">struct</span> <span class="n">v4l2_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">v4l2_event_subscription</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">v4l2_fh</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">v4l2_subdev</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">v4l2_subdev_fh</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">tuner_setup</span><span class="p">;</span>

<span class="cm">/* decode_vbi_line */</span>
<span class="k">struct</span> <span class="n">v4l2_decode_vbi_line</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">is_second_field</span><span class="p">;</span>	<span class="cm">/* Set to 0 for the first (odd) field,</span>
<span class="cm">				   set to 1 for the second (even) field. */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> 			<span class="cm">/* Pointer to the sliced VBI data from the decoder.</span>
<span class="cm">				   On exit points to the start of the payload. */</span>
	<span class="n">u32</span> <span class="n">line</span><span class="p">;</span>		<span class="cm">/* Line number of the sliced VBI data (1-23) */</span>
	<span class="n">u32</span> <span class="n">type</span><span class="p">;</span>		<span class="cm">/* VBI service type (V4L2_SLICED_*). 0 if no service found */</span>
<span class="p">};</span>

<span class="cm">/* Sub-devices are devices that are connected somehow to the main bridge</span>
<span class="cm">   device. These devices are usually audio/video muxers/encoders/decoders or</span>
<span class="cm">   sensors and webcam controllers.</span>

<span class="cm">   Usually these devices are controlled through an i2c bus, but other busses</span>
<span class="cm">   may also be used.</span>

<span class="cm">   The v4l2_subdev struct provides a way of accessing these devices in a</span>
<span class="cm">   generic manner. Most operations that these sub-devices support fall in</span>
<span class="cm">   a few categories: core ops, audio ops, video ops and tuner ops.</span>

<span class="cm">   More categories can be added if needed, although this should remain a</span>
<span class="cm">   limited set (no more than approx. 8 categories).</span>

<span class="cm">   Each category has its own set of ops that subdev drivers can implement.</span>

<span class="cm">   A subdev driver can leave the pointer to the category ops NULL if</span>
<span class="cm">   it does not implement them (e.g. an audio subdev will generally not</span>
<span class="cm">   implement the video category ops). The exception is the core category:</span>
<span class="cm">   this must always be present.</span>

<span class="cm">   These ops are all used internally so it is no problem to change, remove</span>
<span class="cm">   or add ops or move ops from one to another category. Currently these</span>
<span class="cm">   ops are based on the original ioctls, but since ops are not limited to</span>
<span class="cm">   one argument there is room for improvement here once all i2c subdev</span>
<span class="cm">   drivers are converted to use these ops.</span>
<span class="cm"> */</span>

<span class="cm">/* Core ops: it is highly recommended to implement at least these ops:</span>

<span class="cm">   g_chip_ident</span>
<span class="cm">   log_status</span>
<span class="cm">   g_register</span>
<span class="cm">   s_register</span>

<span class="cm">   This provides basic debugging support.</span>

<span class="cm">   The ioctl ops is meant for generic ioctl-like commands. Depending on</span>
<span class="cm">   the use-case it might be better to use subdev-specific ops (currently</span>
<span class="cm">   not yet implemented) since ops provide proper type-checking.</span>
<span class="cm"> */</span>

<span class="cm">/* Subdevice external IO pin configuration */</span>
<span class="cp">#define V4L2_SUBDEV_IO_PIN_DISABLE	(1 &lt;&lt; 0) </span><span class="cm">/* ENABLE assumed */</span><span class="cp"></span>
<span class="cp">#define V4L2_SUBDEV_IO_PIN_OUTPUT	(1 &lt;&lt; 1)</span>
<span class="cp">#define V4L2_SUBDEV_IO_PIN_INPUT	(1 &lt;&lt; 2)</span>
<span class="cp">#define V4L2_SUBDEV_IO_PIN_SET_VALUE	(1 &lt;&lt; 3) </span><span class="cm">/* Set output value */</span><span class="cp"></span>
<span class="cp">#define V4L2_SUBDEV_IO_PIN_ACTIVE_LOW	(1 &lt;&lt; 4) </span><span class="cm">/* ACTIVE HIGH assumed */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">v4l2_subdev_io_pin_config</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* V4L2_SUBDEV_IO_PIN_* flags for this pin&#39;s config */</span>
	<span class="n">u8</span> <span class="n">pin</span><span class="p">;</span>		<span class="cm">/* Chip external IO pin to configure */</span>
	<span class="n">u8</span> <span class="n">function</span><span class="p">;</span>	<span class="cm">/* Internal signal pad/function to route to IO pin */</span>
	<span class="n">u8</span> <span class="n">value</span><span class="p">;</span>	<span class="cm">/* Initial value for pin - e.g. GPIO output value */</span>
	<span class="n">u8</span> <span class="n">strength</span><span class="p">;</span>	<span class="cm">/* Pin drive strength */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">   s_io_pin_config: configure one or more chip I/O pins for chips that</span>
<span class="cm">	multiplex different internal signal pads out to IO pins.  This function</span>
<span class="cm">	takes a pointer to an array of &#39;n&#39; pin configuration entries, one for</span>
<span class="cm">	each pin being configured.  This function could be called at times</span>
<span class="cm">	other than just subdevice initialization.</span>

<span class="cm">   init: initialize the sensor registors to some sort of reasonable default</span>
<span class="cm">	values. Do not use for new drivers and should be removed in existing</span>
<span class="cm">	drivers.</span>

<span class="cm">   load_fw: load firmware.</span>

<span class="cm">   reset: generic reset command. The argument selects which subsystems to</span>
<span class="cm">	reset. Passing 0 will always reset the whole chip. Do not use for new</span>
<span class="cm">	drivers without discussing this first on the linux-media mailinglist.</span>
<span class="cm">	There should be no reason normally to reset a device.</span>

<span class="cm">   s_gpio: set GPIO pins. Very simple right now, might need to be extended with</span>
<span class="cm">	a direction argument if needed.</span>

<span class="cm">   s_power: puts subdevice in power saving mode (on == 0) or normal operation</span>
<span class="cm">	mode (on == 1).</span>

<span class="cm">   interrupt_service_routine: Called by the bridge chip&#39;s interrupt service</span>
<span class="cm">	handler, when an interrupt status has be raised due to this subdev,</span>
<span class="cm">	so that this subdev can handle the details.  It may schedule work to be</span>
<span class="cm">	performed later.  It must not sleep.  *Called from an IRQ context*.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">v4l2_subdev_core_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_chip_ident</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_dbg_chip_ident</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">log_status</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_io_pin_config</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">v4l2_subdev_io_pin_config</span> <span class="o">*</span><span class="n">pincfg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">load_fw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_gpio</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">queryctrl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_queryctrl</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_ctrl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_ctrl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_ext_ctrls</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_ext_controls</span> <span class="o">*</span><span class="n">ctrls</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_ext_ctrls</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_ext_controls</span> <span class="o">*</span><span class="n">ctrls</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">try_ext_ctrls</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_ext_controls</span> <span class="o">*</span><span class="n">ctrls</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">querymenu</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_querymenu</span> <span class="o">*</span><span class="n">qm</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_std</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">v4l2_std_id</span> <span class="o">*</span><span class="n">norm</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_std</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">v4l2_std_id</span> <span class="n">norm</span><span class="p">);</span>
	<span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_VIDEO_ADV_DEBUG</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_register</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_dbg_register</span> <span class="o">*</span><span class="n">reg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_register</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_dbg_register</span> <span class="o">*</span><span class="n">reg</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_power</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">interrupt_service_routine</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
						<span class="n">u32</span> <span class="n">status</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">handled</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">subscribe_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">v4l2_event_subscription</span> <span class="o">*</span><span class="n">sub</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">unsubscribe_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">v4l2_event_subscription</span> <span class="o">*</span><span class="n">sub</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* s_radio: v4l device was opened in radio mode.</span>

<span class="cm">   g_frequency: freq-&gt;type must be filled in. Normally done by video_ioctl2</span>
<span class="cm">	or the bridge driver.</span>

<span class="cm">   g_tuner:</span>
<span class="cm">   s_tuner: vt-&gt;type must be filled in. Normally done by video_ioctl2 or the</span>
<span class="cm">	bridge driver.</span>

<span class="cm">   s_type_addr: sets tuner type and its I2C addr.</span>

<span class="cm">   s_config: sets tda9887 specific stuff, like port1, port2 and qss</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">v4l2_subdev_tuner_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_radio</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_frequency</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_frequency</span> <span class="o">*</span><span class="n">freq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_frequency</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_frequency</span> <span class="o">*</span><span class="n">freq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_tuner</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_tuner</span> <span class="o">*</span><span class="n">vt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_tuner</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_tuner</span> <span class="o">*</span><span class="n">vt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_modulator</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_modulator</span> <span class="o">*</span><span class="n">vm</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_modulator</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_modulator</span> <span class="o">*</span><span class="n">vm</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_type_addr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tuner_setup</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_config</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_priv_tun_config</span> <span class="o">*</span><span class="n">config</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* s_clock_freq: set the frequency (in Hz) of the audio clock output.</span>
<span class="cm">	Used to slave an audio processor to the video decoder, ensuring that</span>
<span class="cm">	audio and video remain synchronized. Usual values for the frequency</span>
<span class="cm">	are 48000, 44100 or 32000 Hz. If the frequency is not supported, then</span>
<span class="cm">	-EINVAL is returned.</span>

<span class="cm">   s_i2s_clock_freq: sets I2S speed in bps. This is used to provide a standard</span>
<span class="cm">	way to select I2S clock used by driving digital audio streams at some</span>
<span class="cm">	board designs. Usual values for the frequency are 1024000 and 2048000.</span>
<span class="cm">	If the frequency is not supported, then -EINVAL is returned.</span>

<span class="cm">   s_routing: used to define the input and/or output pins of an audio chip,</span>
<span class="cm">	and any additional configuration data.</span>
<span class="cm">	Never attempt to use user-level input IDs (e.g. Composite, S-Video,</span>
<span class="cm">	Tuner) at this level. An i2c device shouldn&#39;t know about whether an</span>
<span class="cm">	input pin is connected to a Composite connector, become on another</span>
<span class="cm">	board or platform it might be connected to something else entirely.</span>
<span class="cm">	The calling driver is responsible for mapping a user-level input to</span>
<span class="cm">	the right pins on the i2c device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">v4l2_subdev_audio_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_clock_freq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">freq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_i2s_clock_freq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">freq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_routing</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">input</span><span class="p">,</span> <span class="n">u32</span> <span class="n">output</span><span class="p">,</span> <span class="n">u32</span> <span class="n">config</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_stream</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">   s_std_output: set v4l2_std_id for video OUTPUT devices. This is ignored by</span>
<span class="cm">	video input devices.</span>

<span class="cm">   g_std_output: get current standard for video OUTPUT devices. This is ignored</span>
<span class="cm">	by video input devices.</span>

<span class="cm">   g_tvnorms_output: get v4l2_std_id with all standards supported by video</span>
<span class="cm">	OUTPUT device. This is ignored by video input devices.</span>

<span class="cm">   s_crystal_freq: sets the frequency of the crystal used to generate the</span>
<span class="cm">	clocks in Hz. An extra flags field allows device specific configuration</span>
<span class="cm">	regarding clock frequency dividers, etc. If not used, then set flags</span>
<span class="cm">	to 0. If the frequency is not supported, then -EINVAL is returned.</span>

<span class="cm">   g_input_status: get input status. Same as the status field in the v4l2_input</span>
<span class="cm">	struct.</span>

<span class="cm">   s_routing: see s_routing in audio_ops, except this version is for video</span>
<span class="cm">	devices.</span>

<span class="cm">   s_dv_preset: set dv (Digital Video) preset in the sub device. Similar to</span>
<span class="cm">	s_std()</span>

<span class="cm">   g_dv_preset: get current dv (Digital Video) preset in the sub device.</span>

<span class="cm">   query_dv_preset: query dv preset in the sub device. This is similar to</span>
<span class="cm">	querystd()</span>

<span class="cm">   s_dv_timings(): Set custom dv timings in the sub device. This is used</span>
<span class="cm">	when sub device is capable of setting detailed timing information</span>
<span class="cm">	in the hardware to generate/detect the video signal.</span>

<span class="cm">   g_dv_timings(): Get custom dv timings in the sub device.</span>

<span class="cm">   enum_mbus_fmt: enumerate pixel formats, provided by a video data source</span>

<span class="cm">   g_mbus_fmt: get the current pixel format, provided by a video data source</span>

<span class="cm">   try_mbus_fmt: try to set a pixel format on a video data source</span>

<span class="cm">   s_mbus_fmt: set a pixel format on a video data source</span>

<span class="cm">   g_mbus_config: get supported mediabus configurations</span>

<span class="cm">   s_mbus_config: set a certain mediabus configuration. This operation is added</span>
<span class="cm">	for compatibility with soc-camera drivers and should not be used by new</span>
<span class="cm">	software.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">v4l2_subdev_video_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_routing</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">input</span><span class="p">,</span> <span class="n">u32</span> <span class="n">output</span><span class="p">,</span> <span class="n">u32</span> <span class="n">config</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_crystal_freq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">freq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_std_output</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">v4l2_std_id</span> <span class="n">std</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_std_output</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">v4l2_std_id</span> <span class="o">*</span><span class="n">std</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">querystd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">v4l2_std_id</span> <span class="o">*</span><span class="n">std</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_tvnorms_output</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">v4l2_std_id</span> <span class="o">*</span><span class="n">std</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_input_status</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">status</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_stream</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cropcap</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_cropcap</span> <span class="o">*</span><span class="n">cc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_crop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_crop</span> <span class="o">*</span><span class="n">crop</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_crop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_crop</span> <span class="o">*</span><span class="n">crop</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_parm</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_streamparm</span> <span class="o">*</span><span class="n">param</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_parm</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_streamparm</span> <span class="o">*</span><span class="n">param</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_frame_interval</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">v4l2_subdev_frame_interval</span> <span class="o">*</span><span class="n">interval</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_frame_interval</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">v4l2_subdev_frame_interval</span> <span class="o">*</span><span class="n">interval</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enum_framesizes</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_frmsizeenum</span> <span class="o">*</span><span class="n">fsize</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enum_frameintervals</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_frmivalenum</span> <span class="o">*</span><span class="n">fival</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enum_dv_presets</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">v4l2_dv_enum_preset</span> <span class="o">*</span><span class="n">preset</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_dv_preset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">v4l2_dv_preset</span> <span class="o">*</span><span class="n">preset</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_dv_preset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">v4l2_dv_preset</span> <span class="o">*</span><span class="n">preset</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">query_dv_preset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">v4l2_dv_preset</span> <span class="o">*</span><span class="n">preset</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_dv_timings</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">v4l2_dv_timings</span> <span class="o">*</span><span class="n">timings</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_dv_timings</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">v4l2_dv_timings</span> <span class="o">*</span><span class="n">timings</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enum_dv_timings</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">v4l2_enum_dv_timings</span> <span class="o">*</span><span class="n">timings</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">query_dv_timings</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">v4l2_dv_timings</span> <span class="o">*</span><span class="n">timings</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dv_timings_cap</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">v4l2_dv_timings_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enum_mbus_fmt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">v4l2_mbus_pixelcode</span> <span class="o">*</span><span class="n">code</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enum_mbus_fsizes</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">v4l2_frmsizeenum</span> <span class="o">*</span><span class="n">fsize</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_mbus_fmt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">v4l2_mbus_framefmt</span> <span class="o">*</span><span class="n">fmt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">try_mbus_fmt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">v4l2_mbus_framefmt</span> <span class="o">*</span><span class="n">fmt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_mbus_fmt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">v4l2_mbus_framefmt</span> <span class="o">*</span><span class="n">fmt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_mbus_config</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">v4l2_mbus_config</span> <span class="o">*</span><span class="n">cfg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_mbus_config</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_mbus_config</span> <span class="o">*</span><span class="n">cfg</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">   decode_vbi_line: video decoders that support sliced VBI need to implement</span>
<span class="cm">	this ioctl. Field p of the v4l2_sliced_vbi_line struct is set to the</span>
<span class="cm">	start of the VBI data that was generated by the decoder. The driver</span>
<span class="cm">	then parses the sliced VBI data and sets the other fields in the</span>
<span class="cm">	struct accordingly. The pointer p is updated to point to the start of</span>
<span class="cm">	the payload which can be copied verbatim into the data field of the</span>
<span class="cm">	v4l2_sliced_vbi_data struct. If no valid VBI data was found, then the</span>
<span class="cm">	type field is set to 0 on return.</span>

<span class="cm">   s_vbi_data: used to generate VBI signals on a video signal.</span>
<span class="cm">	v4l2_sliced_vbi_data is filled with the data packets that should be</span>
<span class="cm">	output. Note that if you set the line field to 0, then that VBI signal</span>
<span class="cm">	is disabled. If no valid VBI data was found, then the type field is</span>
<span class="cm">	set to 0 on return.</span>

<span class="cm">   g_vbi_data: used to obtain the sliced VBI packet from a readback register.</span>
<span class="cm">	Not all video decoders support this. If no data is available because</span>
<span class="cm">	the readback register contains invalid or erroneous data -EIO is</span>
<span class="cm">	returned. Note that you must fill in the &#39;id&#39; member and the &#39;field&#39;</span>
<span class="cm">	member (to determine whether CC data from the first or second field</span>
<span class="cm">	should be obtained).</span>

<span class="cm">   s_raw_fmt: setup the video encoder/decoder for raw VBI.</span>

<span class="cm">   g_sliced_fmt: retrieve the current sliced VBI settings.</span>

<span class="cm">   s_sliced_fmt: setup the sliced VBI settings.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">v4l2_subdev_vbi_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">decode_vbi_line</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_decode_vbi_line</span> <span class="o">*</span><span class="n">vbi_line</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_vbi_data</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_sliced_vbi_data</span> <span class="o">*</span><span class="n">vbi_data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_vbi_data</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_sliced_vbi_data</span> <span class="o">*</span><span class="n">vbi_data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_sliced_vbi_cap</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_sliced_vbi_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_raw_fmt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_vbi_format</span> <span class="o">*</span><span class="n">fmt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_sliced_fmt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_sliced_vbi_format</span> <span class="o">*</span><span class="n">fmt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_sliced_fmt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_sliced_vbi_format</span> <span class="o">*</span><span class="n">fmt</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct v4l2_subdev_sensor_ops - v4l2-subdev sensor operations</span>
<span class="cm"> * @g_skip_top_lines: number of lines at the top of the image to be skipped.</span>
<span class="cm"> *		      This is needed for some sensors, which always corrupt</span>
<span class="cm"> *		      several top lines of the output image, or which send their</span>
<span class="cm"> *		      metadata in them.</span>
<span class="cm"> * @g_skip_frames: number of frames to skip at stream start. This is needed for</span>
<span class="cm"> *		   buggy sensors that generate faulty frames when they are</span>
<span class="cm"> *		   turned on.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">v4l2_subdev_sensor_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_skip_top_lines</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">lines</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_skip_frames</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">frames</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">   [rt]x_g_parameters: Get the current operating parameters and state of the</span>
<span class="cm">	the IR receiver or transmitter.</span>

<span class="cm">   [rt]x_s_parameters: Set the current operating parameters and state of the</span>
<span class="cm">	the IR receiver or transmitter.  It is recommended to call</span>
<span class="cm">	[rt]x_g_parameters first to fill out the current state, and only change</span>
<span class="cm">	the fields that need to be changed.  Upon return, the actual device</span>
<span class="cm">	operating parameters and state will be returned.  Note that hardware</span>
<span class="cm">	limitations may prevent the actual settings from matching the requested</span>
<span class="cm">	settings - e.g. an actual carrier setting of 35,904 Hz when 36,000 Hz</span>
<span class="cm">	was requested.  An exception is when the shutdown parameter is true.</span>
<span class="cm">	The last used operational parameters will be returned, but the actual</span>
<span class="cm">	state of the hardware be different to minimize power consumption and</span>
<span class="cm">	processing when shutdown is true.</span>

<span class="cm">   rx_read: Reads received codes or pulse width data.</span>
<span class="cm">	The semantics are similar to a non-blocking read() call.</span>

<span class="cm">   tx_write: Writes codes or pulse width data for transmission.</span>
<span class="cm">	The semantics are similar to a non-blocking write() call.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">v4l2_subdev_ir_mode</span> <span class="p">{</span>
	<span class="n">V4L2_SUBDEV_IR_MODE_PULSE_WIDTH</span><span class="p">,</span> <span class="cm">/* uses struct ir_raw_event records */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">v4l2_subdev_ir_parameters</span> <span class="p">{</span>
	<span class="cm">/* Either Rx or Tx */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes_per_data_element</span><span class="p">;</span> <span class="cm">/* of data in read or write call */</span>
	<span class="k">enum</span> <span class="n">v4l2_subdev_ir_mode</span> <span class="n">mode</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">enable</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">interrupt_enable</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">shutdown</span><span class="p">;</span> <span class="cm">/* true: set hardware to low/no power, false: normal */</span>

	<span class="n">bool</span> <span class="n">modulation</span><span class="p">;</span>           <span class="cm">/* true: uses carrier, false: baseband */</span>
	<span class="n">u32</span> <span class="n">max_pulse_width</span><span class="p">;</span>       <span class="cm">/* ns,      valid only for baseband signal */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">carrier_freq</span><span class="p">;</span> <span class="cm">/* Hz,      valid only for modulated signal*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">duty_cycle</span><span class="p">;</span>   <span class="cm">/* percent, valid only for modulated signal*/</span>
	<span class="n">bool</span> <span class="n">invert_level</span><span class="p">;</span>	   <span class="cm">/* invert signal level */</span>

	<span class="cm">/* Tx only */</span>
	<span class="n">bool</span> <span class="n">invert_carrier_sense</span><span class="p">;</span> <span class="cm">/* Send 0/space as a carrier burst */</span>

	<span class="cm">/* Rx only */</span>
	<span class="n">u32</span> <span class="n">noise_filter_min_width</span><span class="p">;</span>       <span class="cm">/* ns, min time of a valid pulse */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">carrier_range_lower</span><span class="p">;</span> <span class="cm">/* Hz, valid only for modulated sig */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">carrier_range_upper</span><span class="p">;</span> <span class="cm">/* Hz, valid only for modulated sig */</span>
	<span class="n">u32</span> <span class="n">resolution</span><span class="p">;</span>                   <span class="cm">/* ns */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">v4l2_subdev_ir_ops</span> <span class="p">{</span>
	<span class="cm">/* Receiver */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rx_read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
				<span class="kt">ssize_t</span> <span class="o">*</span><span class="n">num</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rx_g_parameters</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">v4l2_subdev_ir_parameters</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rx_s_parameters</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">v4l2_subdev_ir_parameters</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>

	<span class="cm">/* Transmitter */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">tx_write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
				<span class="kt">ssize_t</span> <span class="o">*</span><span class="n">num</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">tx_g_parameters</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">v4l2_subdev_ir_parameters</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">tx_s_parameters</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">v4l2_subdev_ir_parameters</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">v4l2_subdev_pad_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enum_mbus_code</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_subdev_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">v4l2_subdev_mbus_code_enum</span> <span class="o">*</span><span class="n">code</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enum_frame_size</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">v4l2_subdev_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">v4l2_subdev_frame_size_enum</span> <span class="o">*</span><span class="n">fse</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enum_frame_interval</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">v4l2_subdev_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">v4l2_subdev_frame_interval_enum</span> <span class="o">*</span><span class="n">fie</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_fmt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_subdev_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">v4l2_subdev_format</span> <span class="o">*</span><span class="n">format</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_fmt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_subdev_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">v4l2_subdev_format</span> <span class="o">*</span><span class="n">format</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_crop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_subdev_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">v4l2_subdev_crop</span> <span class="o">*</span><span class="n">crop</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_crop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_subdev_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">v4l2_subdev_crop</span> <span class="o">*</span><span class="n">crop</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_selection</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_subdev_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">v4l2_subdev_selection</span> <span class="o">*</span><span class="n">sel</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_selection</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_subdev_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">v4l2_subdev_selection</span> <span class="o">*</span><span class="n">sel</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_MEDIA_CONTROLLER</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">link_validate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">media_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">v4l2_subdev_format</span> <span class="o">*</span><span class="n">source_fmt</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">v4l2_subdev_format</span> <span class="o">*</span><span class="n">sink_fmt</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MEDIA_CONTROLLER */</span><span class="cp"></span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">v4l2_subdev_ops</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_subdev_core_ops</span>	<span class="o">*</span><span class="n">core</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_subdev_tuner_ops</span>	<span class="o">*</span><span class="n">tuner</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_subdev_audio_ops</span>	<span class="o">*</span><span class="n">audio</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_subdev_video_ops</span>	<span class="o">*</span><span class="n">video</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_subdev_vbi_ops</span>	<span class="o">*</span><span class="n">vbi</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_subdev_ir_ops</span>		<span class="o">*</span><span class="n">ir</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_subdev_sensor_ops</span>	<span class="o">*</span><span class="n">sensor</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_subdev_pad_ops</span>	<span class="o">*</span><span class="n">pad</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Internal ops. Never call this from drivers, only the v4l2 framework can call</span>
<span class="cm"> * these ops.</span>
<span class="cm"> *</span>
<span class="cm"> * registered: called when this subdev is registered. When called the v4l2_dev</span>
<span class="cm"> *	field is set to the correct v4l2_device.</span>
<span class="cm"> *</span>
<span class="cm"> * unregistered: called when this subdev is unregistered. When called the</span>
<span class="cm"> *	v4l2_dev field is still set to the correct v4l2_device.</span>
<span class="cm"> *</span>
<span class="cm"> * open: called when the subdev device node is opened by an application.</span>
<span class="cm"> *</span>
<span class="cm"> * close: called when the subdev device node is closed.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">v4l2_subdev_internal_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">registered</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">unregistered</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_subdev_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_subdev_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define V4L2_SUBDEV_NAME_SIZE 32</span>

<span class="cm">/* Set this flag if this subdev is a i2c device. */</span>
<span class="cp">#define V4L2_SUBDEV_FL_IS_I2C			(1U &lt;&lt; 0)</span>
<span class="cm">/* Set this flag if this subdev is a spi device. */</span>
<span class="cp">#define V4L2_SUBDEV_FL_IS_SPI			(1U &lt;&lt; 1)</span>
<span class="cm">/* Set this flag if this subdev needs a device node. */</span>
<span class="cp">#define V4L2_SUBDEV_FL_HAS_DEVNODE		(1U &lt;&lt; 2)</span>
<span class="cm">/* Set this flag if this subdev generates events. */</span>
<span class="cp">#define V4L2_SUBDEV_FL_HAS_EVENTS		(1U &lt;&lt; 3)</span>

<span class="cm">/* Each instance of a subdev driver should create this struct, either</span>
<span class="cm">   stand-alone or embedded in a larger struct.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="p">{</span>
<span class="cp">#if defined(CONFIG_MEDIA_CONTROLLER)</span>
	<span class="k">struct</span> <span class="n">media_entity</span> <span class="n">entity</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_subdev_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="cm">/* Never call these internal ops from within a driver! */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_subdev_internal_ops</span> <span class="o">*</span><span class="n">internal_ops</span><span class="p">;</span>
	<span class="cm">/* The control handler of this subdev. May be NULL. */</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">ctrl_handler</span><span class="p">;</span>
	<span class="cm">/* name must be unique */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">V4L2_SUBDEV_NAME_SIZE</span><span class="p">];</span>
	<span class="cm">/* can be used to group similar subdevs, value is driver-specific */</span>
	<span class="n">u32</span> <span class="n">grp_id</span><span class="p">;</span>
	<span class="cm">/* pointer to private data */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dev_priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">host_priv</span><span class="p">;</span>
	<span class="cm">/* subdev device node */</span>
	<span class="k">struct</span> <span class="n">video_device</span> <span class="o">*</span><span class="n">devnode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define media_entity_to_v4l2_subdev(ent) \</span>
<span class="cp">	container_of(ent, struct v4l2_subdev, entity)</span>
<span class="cp">#define vdev_to_v4l2_subdev(vdev) \</span>
<span class="cp">	((struct v4l2_subdev *)video_get_drvdata(vdev))</span>

<span class="cm">/*</span>
<span class="cm"> * Used for storing subdev information per file handle</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">v4l2_subdev_fh</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_fh</span> <span class="n">vfh</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">v4l2_mbus_framefmt</span> <span class="n">try_fmt</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">v4l2_rect</span> <span class="n">try_crop</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">v4l2_rect</span> <span class="n">try_compose</span><span class="p">;</span>
	<span class="p">}</span> <span class="o">*</span><span class="n">pad</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#define to_v4l2_subdev_fh(fh)	\</span>
<span class="cp">	container_of(fh, struct v4l2_subdev_fh, vfh)</span>

<span class="cp">#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)</span>
<span class="cp">#define __V4L2_SUBDEV_MK_GET_TRY(rtype, fun_name, field_name)		\</span>
<span class="cp">	static inline struct rtype *					\</span>
<span class="cp">	v4l2_subdev_get_try_##fun_name(struct v4l2_subdev_fh *fh,	\</span>
<span class="cp">				       unsigned int pad)		\</span>
<span class="cp">	{								\</span>
<span class="cp">		BUG_ON(unlikely(pad &gt;= vdev_to_v4l2_subdev(		\</span>
<span class="cp">					fh-&gt;vfh.vdev)-&gt;entity.num_pads)); \</span>
<span class="cp">		return &amp;fh-&gt;pad[pad].field_name;			\</span>
<span class="cp">	}</span>

<span class="n">__V4L2_SUBDEV_MK_GET_TRY</span><span class="p">(</span><span class="n">v4l2_mbus_framefmt</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">try_fmt</span><span class="p">)</span>
<span class="n">__V4L2_SUBDEV_MK_GET_TRY</span><span class="p">(</span><span class="n">v4l2_rect</span><span class="p">,</span> <span class="n">crop</span><span class="p">,</span> <span class="n">try_compose</span><span class="p">)</span>
<span class="n">__V4L2_SUBDEV_MK_GET_TRY</span><span class="p">(</span><span class="n">v4l2_rect</span><span class="p">,</span> <span class="n">compose</span><span class="p">,</span> <span class="n">try_compose</span><span class="p">)</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_file_operations</span> <span class="n">v4l2_subdev_fops</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">v4l2_set_subdevdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">v4l2_get_subdevdata</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">dev_priv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">v4l2_set_subdev_hostdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">host_priv</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">v4l2_get_subdev_hostdata</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">host_priv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MEDIA_CONTROLLER</span>
<span class="kt">int</span> <span class="n">v4l2_subdev_link_validate_default</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">media_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">v4l2_subdev_format</span> <span class="o">*</span><span class="n">source_fmt</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">v4l2_subdev_format</span> <span class="o">*</span><span class="n">sink_fmt</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">v4l2_subdev_link_validate</span><span class="p">(</span><span class="k">struct</span> <span class="n">media_link</span> <span class="o">*</span><span class="n">link</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MEDIA_CONTROLLER */</span><span class="cp"></span>
<span class="kt">void</span> <span class="n">v4l2_subdev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_subdev_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>

<span class="cm">/* Call an ops of a v4l2_subdev, doing the right checks against</span>
<span class="cm">   NULL pointers.</span>

<span class="cm">   Example: err = v4l2_subdev_call(sd, core, g_chip_ident, &amp;chip);</span>
<span class="cm"> */</span>
<span class="cp">#define v4l2_subdev_call(sd, o, f, args...)				\</span>
<span class="cp">	(!(sd) ? -ENODEV : (((sd)-&gt;ops-&gt;o &amp;&amp; (sd)-&gt;ops-&gt;o-&gt;f) ?	\</span>
<span class="cp">		(sd)-&gt;ops-&gt;o-&gt;f((sd) , ##args) : -ENOIOCTLCMD))</span>

<span class="cm">/* Send a notification to v4l2_device. */</span>
<span class="cp">#define v4l2_subdev_notify(sd, notification, arg)			   \</span>
<span class="cp">	((!(sd) || !(sd)-&gt;v4l2_dev || !(sd)-&gt;v4l2_dev-&gt;notify) ? -ENODEV : \</span>
<span class="cp">	 (sd)-&gt;v4l2_dev-&gt;notify((sd), (notification), (arg)))</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
