<!DOCTYPE html>
<html><head><title>joekychen/linux » include › media › v4l2-device.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>v4l2-device.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">    V4L2 device support header.</span>

<span class="cm">    Copyright (C) 2008  Hans Verkuil &lt;hverkuil@xs4all.nl&gt;</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _V4L2_DEVICE_H</span>
<span class="cp">#define _V4L2_DEVICE_H</span>

<span class="cp">#include &lt;media/media-device.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-subdev.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-dev.h&gt;</span>

<span class="cm">/* Each instance of a V4L2 device should create the v4l2_device struct,</span>
<span class="cm">   either stand-alone or embedded in a larger struct.</span>

<span class="cm">   It allows easy access to sub-devices (see v4l2-subdev.h) and provides</span>
<span class="cm">   basic V4L2 device-level support.</span>
<span class="cm"> */</span>

<span class="cp">#define V4L2_DEVICE_NAME_SIZE (20 + 16)</span>

<span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">v4l2_device</span> <span class="p">{</span>
	<span class="cm">/* dev-&gt;driver_data points to this struct.</span>
<span class="cm">	   Note: dev might be NULL if there is no parent device</span>
<span class="cm">	   as is the case with e.g. ISA devices. */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_MEDIA_CONTROLLER)</span>
	<span class="k">struct</span> <span class="n">media_device</span> <span class="o">*</span><span class="n">mdev</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* used to keep track of the registered subdevs */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">subdevs</span><span class="p">;</span>
	<span class="cm">/* lock this struct; can be used by the driver as well if this</span>
<span class="cm">	   struct is embedded into a larger struct. */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="cm">/* unique device name, by default the driver name + bus ID */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">V4L2_DEVICE_NAME_SIZE</span><span class="p">];</span>
	<span class="cm">/* notify callback called by some sub-devices. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">notify</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">notification</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
	<span class="cm">/* The control handler. May be NULL. */</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">ctrl_handler</span><span class="p">;</span>
	<span class="cm">/* Device&#39;s priority state */</span>
	<span class="k">struct</span> <span class="n">v4l2_prio_state</span> <span class="n">prio</span><span class="p">;</span>
	<span class="cm">/* BKL replacement mutex. Temporary solution only. */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">ioctl_lock</span><span class="p">;</span>
	<span class="cm">/* Keep track of the references to this struct. */</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">ref</span><span class="p">;</span>
	<span class="cm">/* Release function that is called when the ref count goes to 0. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">v4l2_device_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v4l2_dev</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">v4l2_device_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span><span class="p">);</span>

<span class="cm">/* Initialize v4l2_dev and make dev-&gt;driver_data point to v4l2_dev.</span>
<span class="cm">   dev may be NULL in rare cases (ISA devices). In that case you</span>
<span class="cm">   must fill in the v4l2_dev-&gt;name field before calling this function. */</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">v4l2_device_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span><span class="p">);</span>

<span class="cm">/* Optional function to initialize the name field of struct v4l2_device using</span>
<span class="cm">   the driver name and a driver-global atomic_t instance.</span>
<span class="cm">   This function will increment the instance counter and returns the instance</span>
<span class="cm">   value used in the name.</span>

<span class="cm">   Example:</span>

<span class="cm">   static atomic_t drv_instance = ATOMIC_INIT(0);</span>

<span class="cm">   ...</span>

<span class="cm">   instance = v4l2_device_set_name(&amp;v4l2_dev, &quot;foo&quot;, &amp;drv_instance);</span>

<span class="cm">   The first time this is called the name field will be set to foo0 and</span>
<span class="cm">   this function returns 0. If the name ends with a digit (e.g. cx18),</span>
<span class="cm">   then the name will be set to cx18-0 since cx180 looks really odd. */</span>
<span class="kt">int</span> <span class="n">v4l2_device_set_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">basename</span><span class="p">,</span>
						<span class="n">atomic_t</span> <span class="o">*</span><span class="n">instance</span><span class="p">);</span>

<span class="cm">/* Set v4l2_dev-&gt;dev to NULL. Call when the USB parent disconnects.</span>
<span class="cm">   Since the parent disappears this ensures that v4l2_dev doesn&#39;t have an</span>
<span class="cm">   invalid parent pointer. */</span>
<span class="kt">void</span> <span class="n">v4l2_device_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span><span class="p">);</span>

<span class="cm">/* Unregister all sub-devices and any other resources related to v4l2_dev. */</span>
<span class="kt">void</span> <span class="n">v4l2_device_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span><span class="p">);</span>

<span class="cm">/* Register a subdev with a v4l2 device. While registered the subdev module</span>
<span class="cm">   is marked as in-use. An error is returned if the module is no longer</span>
<span class="cm">   loaded when you attempt to register it. */</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">v4l2_device_register_subdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">);</span>
<span class="cm">/* Unregister a subdev with a v4l2 device. Can also be called if the subdev</span>
<span class="cm">   wasn&#39;t registered. In that case it will do nothing. */</span>
<span class="kt">void</span> <span class="n">v4l2_device_unregister_subdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">);</span>

<span class="cm">/* Register device nodes for all subdev of the v4l2 device that are marked with</span>
<span class="cm"> * the V4L2_SUBDEV_FL_HAS_DEVNODE flag.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__must_check</span>
<span class="n">v4l2_device_register_subdev_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span><span class="p">);</span>

<span class="cm">/* Iterate over all subdevs. */</span>
<span class="cp">#define v4l2_device_for_each_subdev(sd, v4l2_dev)			\</span>
<span class="cp">	list_for_each_entry(sd, &amp;(v4l2_dev)-&gt;subdevs, list)</span>

<span class="cm">/* Call the specified callback for all subdevs matching the condition.</span>
<span class="cm">   Ignore any errors. Note that you cannot add or delete a subdev</span>
<span class="cm">   while walking the subdevs list. */</span>
<span class="cp">#define __v4l2_device_call_subdevs_p(v4l2_dev, sd, cond, o, f, args...)	\</span>
<span class="cp">	do { 								\</span>
<span class="cp">		list_for_each_entry((sd), &amp;(v4l2_dev)-&gt;subdevs, list)	\</span>
<span class="cp">			if ((cond) &amp;&amp; (sd)-&gt;ops-&gt;o &amp;&amp; (sd)-&gt;ops-&gt;o-&gt;f)	\</span>
<span class="cp">				(sd)-&gt;ops-&gt;o-&gt;f((sd) , ##args);		\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define __v4l2_device_call_subdevs(v4l2_dev, cond, o, f, args...)	\</span>
<span class="cp">	do {								\</span>
<span class="cp">		struct v4l2_subdev *__sd;				\</span>
<span class="cp">									\</span>
<span class="cp">		__v4l2_device_call_subdevs_p(v4l2_dev, __sd, cond, o,	\</span>
<span class="cp">						f , ##args);		\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/* Call the specified callback for all subdevs matching the condition.</span>
<span class="cm">   If the callback returns an error other than 0 or -ENOIOCTLCMD, then</span>
<span class="cm">   return with that error code. Note that you cannot add or delete a</span>
<span class="cm">   subdev while walking the subdevs list. */</span>
<span class="cp">#define __v4l2_device_call_subdevs_until_err_p(v4l2_dev, sd, cond, o, f, args...) \</span>
<span class="cp">({ 									\</span>
<span class="cp">	long __err = 0;							\</span>
<span class="cp">									\</span>
<span class="cp">	list_for_each_entry((sd), &amp;(v4l2_dev)-&gt;subdevs, list) {		\</span>
<span class="cp">		if ((cond) &amp;&amp; (sd)-&gt;ops-&gt;o &amp;&amp; (sd)-&gt;ops-&gt;o-&gt;f)		\</span>
<span class="cp">			__err = (sd)-&gt;ops-&gt;o-&gt;f((sd) , ##args);		\</span>
<span class="cp">		if (__err &amp;&amp; __err != -ENOIOCTLCMD)			\</span>
<span class="cp">			break; 						\</span>
<span class="cp">	} 								\</span>
<span class="cp">	(__err == -ENOIOCTLCMD) ? 0 : __err;				\</span>
<span class="cp">})</span>

<span class="cp">#define __v4l2_device_call_subdevs_until_err(v4l2_dev, cond, o, f, args...) \</span>
<span class="cp">({									\</span>
<span class="cp">	struct v4l2_subdev *__sd;					\</span>
<span class="cp">	__v4l2_device_call_subdevs_until_err_p(v4l2_dev, __sd, cond, o,	\</span>
<span class="cp">						f , ##args);		\</span>
<span class="cp">})</span>

<span class="cm">/* Call the specified callback for all subdevs matching grp_id (if 0, then</span>
<span class="cm">   match them all). Ignore any errors. Note that you cannot add or delete</span>
<span class="cm">   a subdev while walking the subdevs list. */</span>
<span class="cp">#define v4l2_device_call_all(v4l2_dev, grpid, o, f, args...)		\</span>
<span class="cp">	do {								\</span>
<span class="cp">		struct v4l2_subdev *__sd;				\</span>
<span class="cp">									\</span>
<span class="cp">		__v4l2_device_call_subdevs_p(v4l2_dev, __sd,		\</span>
<span class="cp">			!(grpid) || __sd-&gt;grp_id == (grpid), o, f ,	\</span>
<span class="cp">			##args);					\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/* Call the specified callback for all subdevs matching grp_id (if 0, then</span>
<span class="cm">   match them all). If the callback returns an error other than 0 or</span>
<span class="cm">   -ENOIOCTLCMD, then return with that error code. Note that you cannot</span>
<span class="cm">   add or delete a subdev while walking the subdevs list. */</span>
<span class="cp">#define v4l2_device_call_until_err(v4l2_dev, grpid, o, f, args...) 	\</span>
<span class="cp">({									\</span>
<span class="cp">	struct v4l2_subdev *__sd;					\</span>
<span class="cp">	__v4l2_device_call_subdevs_until_err_p(v4l2_dev, __sd,		\</span>
<span class="cp">			!(grpid) || __sd-&gt;grp_id == (grpid), o, f ,	\</span>
<span class="cp">			##args);					\</span>
<span class="cp">})</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
