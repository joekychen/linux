<!DOCTYPE html>
<html><head><title>joekychen/linux » include › media › v4l2-ctrls.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>v4l2-ctrls.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">    V4L2 controls support header.</span>

<span class="cm">    Copyright (C) 2010  Hans Verkuil &lt;hverkuil@xs4all.nl&gt;</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _V4L2_CTRLS_H</span>
<span class="cp">#define _V4L2_CTRLS_H</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/videodev2.h&gt;</span>

<span class="cm">/* forward references */</span>
<span class="k">struct</span> <span class="n">file</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">v4l2_ctrl_helper</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">v4l2_ctrl</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">video_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">v4l2_subdev</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">v4l2_subscribed_event</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">v4l2_fh</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">poll_table_struct</span><span class="p">;</span>

<span class="cm">/** struct v4l2_ctrl_ops - The control operations that the driver has to provide.</span>
<span class="cm">  * @g_volatile_ctrl: Get a new value for this control. Generally only relevant</span>
<span class="cm">  *		for volatile (and usually read-only) controls such as a control</span>
<span class="cm">  *		that returns the current signal strength which changes</span>
<span class="cm">  *		continuously.</span>
<span class="cm">  *		If not set, then the currently cached value will be returned.</span>
<span class="cm">  * @try_ctrl:	Test whether the control&#39;s value is valid. Only relevant when</span>
<span class="cm">  *		the usual min/max/step checks are not sufficient.</span>
<span class="cm">  * @s_ctrl:	Actually set the new control value. s_ctrl is compulsory. The</span>
<span class="cm">  *		ctrl-&gt;handler-&gt;lock is held when these ops are called, so no</span>
<span class="cm">  *		one else can access controls owned by that handler.</span>
<span class="cm">  */</span>
<span class="k">struct</span> <span class="n">v4l2_ctrl_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">g_volatile_ctrl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">try_ctrl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">s_ctrl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/** struct v4l2_ctrl - The control structure.</span>
<span class="cm">  * @node:	The list node.</span>
<span class="cm">  * @ev_subs:	The list of control event subscriptions.</span>
<span class="cm">  * @handler:	The handler that owns the control.</span>
<span class="cm">  * @cluster:	Point to start of cluster array.</span>
<span class="cm">  * @ncontrols:	Number of controls in cluster array.</span>
<span class="cm">  * @done:	Internal flag: set for each processed control.</span>
<span class="cm">  * @is_new:	Set when the user specified a new value for this control. It</span>
<span class="cm">  *		is also set when called from v4l2_ctrl_handler_setup. Drivers</span>
<span class="cm">  *		should never set this flag.</span>
<span class="cm">  * @is_private: If set, then this control is private to its handler and it</span>
<span class="cm">  *		will not be added to any other handlers. Drivers can set</span>
<span class="cm">  *		this flag.</span>
<span class="cm">  * @is_auto:   If set, then this control selects whether the other cluster</span>
<span class="cm">  *		members are in &#39;automatic&#39; mode or &#39;manual&#39; mode. This is</span>
<span class="cm">  *		used for autogain/gain type clusters. Drivers should never</span>
<span class="cm">  *		set this flag directly.</span>
<span class="cm">  * @has_volatiles: If set, then one or more members of the cluster are volatile.</span>
<span class="cm">  *		Drivers should never touch this flag.</span>
<span class="cm">  * @manual_mode_value: If the is_auto flag is set, then this is the value</span>
<span class="cm">  *		of the auto control that determines if that control is in</span>
<span class="cm">  *		manual mode. So if the value of the auto control equals this</span>
<span class="cm">  *		value, then the whole cluster is in manual mode. Drivers should</span>
<span class="cm">  *		never set this flag directly.</span>
<span class="cm">  * @ops:	The control ops.</span>
<span class="cm">  * @id:	The control ID.</span>
<span class="cm">  * @name:	The control name.</span>
<span class="cm">  * @type:	The control type.</span>
<span class="cm">  * @minimum:	The control&#39;s minimum value.</span>
<span class="cm">  * @maximum:	The control&#39;s maximum value.</span>
<span class="cm">  * @default_value: The control&#39;s default value.</span>
<span class="cm">  * @step:	The control&#39;s step value for non-menu controls.</span>
<span class="cm">  * @menu_skip_mask: The control&#39;s skip mask for menu controls. This makes it</span>
<span class="cm">  *		easy to skip menu items that are not valid. If bit X is set,</span>
<span class="cm">  *		then menu item X is skipped. Of course, this only works for</span>
<span class="cm">  *		menus with &lt;= 32 menu items. There are no menus that come</span>
<span class="cm">  *		close to that number, so this is OK. Should we ever need more,</span>
<span class="cm">  *		then this will have to be extended to a u64 or a bit array.</span>
<span class="cm">  * @qmenu:	A const char * array for all menu items. Array entries that are</span>
<span class="cm">  *		empty strings (&quot;&quot;) correspond to non-existing menu items (this</span>
<span class="cm">  *		is in addition to the menu_skip_mask above). The last entry</span>
<span class="cm">  *		must be NULL.</span>
<span class="cm">  * @flags:	The control&#39;s flags.</span>
<span class="cm">  * @cur:	The control&#39;s current value.</span>
<span class="cm">  * @val:	The control&#39;s new s32 value.</span>
<span class="cm">  * @val64:	The control&#39;s new s64 value.</span>
<span class="cm">  * @string:	The control&#39;s new string value.</span>
<span class="cm">  * @priv:	The control&#39;s private pointer. For use by the driver. It is</span>
<span class="cm">  *		untouched by the control framework. Note that this pointer is</span>
<span class="cm">  *		not freed when the control is deleted. Should this be needed</span>
<span class="cm">  *		then a new internal bitfield can be added to tell the framework</span>
<span class="cm">  *		to free this pointer.</span>
<span class="cm">  */</span>
<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="p">{</span>
	<span class="cm">/* Administrative fields */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ev_subs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">**</span><span class="n">cluster</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ncontrols</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">done</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_new</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_private</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_auto</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">has_volatiles</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">manual_mode_value</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_ctrl_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">v4l2_ctrl_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span><span class="p">,</span> <span class="n">default_value</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">step</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">menu_skip_mask</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">qmenu</span><span class="p">;</span>
		<span class="k">const</span> <span class="n">s64</span> <span class="o">*</span><span class="n">qmenu_int</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">s32</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">s64</span> <span class="n">val64</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">cur</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">s32</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">s64</span> <span class="n">val64</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** struct v4l2_ctrl_ref - The control reference.</span>
<span class="cm">  * @node:	List node for the sorted list.</span>
<span class="cm">  * @next:	Single-link list node for the hash.</span>
<span class="cm">  * @ctrl:	The actual control information.</span>
<span class="cm">  * @helper:	Pointer to helper struct. Used internally in prepare_ext_ctrls().</span>
<span class="cm">  *</span>
<span class="cm">  * Each control handler has a list of these refs. The list_head is used to</span>
<span class="cm">  * keep a sorted-by-control-ID list of all controls, while the next pointer</span>
<span class="cm">  * is used to link the control in the hash&#39;s bucket.</span>
<span class="cm">  */</span>
<span class="k">struct</span> <span class="n">v4l2_ctrl_ref</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl_ref</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl_helper</span> <span class="o">*</span><span class="n">helper</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** struct v4l2_ctrl_handler - The control handler keeps track of all the</span>
<span class="cm">  * controls: both the controls owned by the handler and those inherited</span>
<span class="cm">  * from other handlers.</span>
<span class="cm">  * @_lock:	Default for &quot;lock&quot;.</span>
<span class="cm">  * @lock:	Lock to control access to this handler and its controls.</span>
<span class="cm">  *		May be replaced by the user right after init.</span>
<span class="cm">  * @ctrls:	The list of controls owned by this handler.</span>
<span class="cm">  * @ctrl_refs:	The list of control references.</span>
<span class="cm">  * @cached:	The last found control reference. It is common that the same</span>
<span class="cm">  *		control is needed multiple times, so this is a simple</span>
<span class="cm">  *		optimization.</span>
<span class="cm">  * @buckets:	Buckets for the hashing. Allows for quick control lookup.</span>
<span class="cm">  * @nr_of_buckets: Total number of buckets in the array.</span>
<span class="cm">  * @error:	The error code of the first failed control addition.</span>
<span class="cm">  */</span>
<span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ctrls</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ctrl_refs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl_ref</span> <span class="o">*</span><span class="n">cached</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl_ref</span> <span class="o">**</span><span class="n">buckets</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">nr_of_buckets</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** struct v4l2_ctrl_config - Control configuration structure.</span>
<span class="cm">  * @ops:	The control ops.</span>
<span class="cm">  * @id:	The control ID.</span>
<span class="cm">  * @name:	The control name.</span>
<span class="cm">  * @type:	The control type.</span>
<span class="cm">  * @min:	The control&#39;s minimum value.</span>
<span class="cm">  * @max:	The control&#39;s maximum value.</span>
<span class="cm">  * @step:	The control&#39;s step value for non-menu controls.</span>
<span class="cm">  * @def: 	The control&#39;s default value.</span>
<span class="cm">  * @flags:	The control&#39;s flags.</span>
<span class="cm">  * @menu_skip_mask: The control&#39;s skip mask for menu controls. This makes it</span>
<span class="cm">  *		easy to skip menu items that are not valid. If bit X is set,</span>
<span class="cm">  *		then menu item X is skipped. Of course, this only works for</span>
<span class="cm">  *		menus with &lt;= 32 menu items. There are no menus that come</span>
<span class="cm">  *		close to that number, so this is OK. Should we ever need more,</span>
<span class="cm">  *		then this will have to be extended to a u64 or a bit array.</span>
<span class="cm">  * @qmenu:	A const char * array for all menu items. Array entries that are</span>
<span class="cm">  *		empty strings (&quot;&quot;) correspond to non-existing menu items (this</span>
<span class="cm">  *		is in addition to the menu_skip_mask above). The last entry</span>
<span class="cm">  *		must be NULL.</span>
<span class="cm">  * @is_private: If set, then this control is private to its handler and it</span>
<span class="cm">  *		will not be added to any other handlers.</span>
<span class="cm">  */</span>
<span class="k">struct</span> <span class="n">v4l2_ctrl_config</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_ctrl_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">v4l2_ctrl_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">min</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">max</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">step</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">def</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">menu_skip_mask</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">qmenu</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">s64</span> <span class="o">*</span><span class="n">qmenu_int</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_private</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** v4l2_ctrl_fill() - Fill in the control fields based on the control ID.</span>
<span class="cm">  *</span>
<span class="cm">  * This works for all standard V4L2 controls.</span>
<span class="cm">  * For non-standard controls it will only fill in the given arguments</span>
<span class="cm">  * and @name will be NULL.</span>
<span class="cm">  *</span>
<span class="cm">  * This function will overwrite the contents of @name, @type and @flags.</span>
<span class="cm">  * The contents of @min, @max, @step and @def may be modified depending on</span>
<span class="cm">  * the type.</span>
<span class="cm">  *</span>
<span class="cm">  * Do not use in drivers! It is used internally for backwards compatibility</span>
<span class="cm">  * control handling only. Once all drivers are converted to use the new</span>
<span class="cm">  * control framework this function will no longer be exported.</span>
<span class="cm">  */</span>
<span class="kt">void</span> <span class="n">v4l2_ctrl_fill</span><span class="p">(</span><span class="n">u32</span> <span class="n">id</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">name</span><span class="p">,</span> <span class="k">enum</span> <span class="n">v4l2_ctrl_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
		    <span class="n">s32</span> <span class="o">*</span><span class="n">min</span><span class="p">,</span> <span class="n">s32</span> <span class="o">*</span><span class="n">max</span><span class="p">,</span> <span class="n">s32</span> <span class="o">*</span><span class="n">step</span><span class="p">,</span> <span class="n">s32</span> <span class="o">*</span><span class="n">def</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>


<span class="cm">/** v4l2_ctrl_handler_init() - Initialize the control handler.</span>
<span class="cm">  * @hdl:	The control handler.</span>
<span class="cm">  * @nr_of_controls_hint: A hint of how many controls this handler is</span>
<span class="cm">  *		expected to refer to. This is the total number, so including</span>
<span class="cm">  *		any inherited controls. It doesn&#39;t have to be precise, but if</span>
<span class="cm">  *		it is way off, then you either waste memory (too many buckets</span>
<span class="cm">  *		are allocated) or the control lookup becomes slower (not enough</span>
<span class="cm">  *		buckets are allocated, so there are more slow list lookups).</span>
<span class="cm">  *		It will always work, though.</span>
<span class="cm">  *</span>
<span class="cm">  * Returns an error if the buckets could not be allocated. This error will</span>
<span class="cm">  * also be stored in @hdl-&gt;error.</span>
<span class="cm">  */</span>
<span class="kt">int</span> <span class="n">v4l2_ctrl_handler_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="n">nr_of_controls_hint</span><span class="p">);</span>

<span class="cm">/** v4l2_ctrl_handler_free() - Free all controls owned by the handler and free</span>
<span class="cm">  * the control list.</span>
<span class="cm">  * @hdl:	The control handler.</span>
<span class="cm">  *</span>
<span class="cm">  * Does nothing if @hdl == NULL.</span>
<span class="cm">  */</span>
<span class="kt">void</span> <span class="n">v4l2_ctrl_handler_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">);</span>

<span class="cm">/** v4l2_ctrl_handler_setup() - Call the s_ctrl op for all controls belonging</span>
<span class="cm">  * to the handler to initialize the hardware to the current control values.</span>
<span class="cm">  * @hdl:	The control handler.</span>
<span class="cm">  *</span>
<span class="cm">  * Button controls will be skipped, as are read-only controls.</span>
<span class="cm">  *</span>
<span class="cm">  * If @hdl == NULL, then this just returns 0.</span>
<span class="cm">  */</span>
<span class="kt">int</span> <span class="n">v4l2_ctrl_handler_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">);</span>

<span class="cm">/** v4l2_ctrl_handler_log_status() - Log all controls owned by the handler.</span>
<span class="cm">  * @hdl:	The control handler.</span>
<span class="cm">  * @prefix:	The prefix to use when logging the control values. If the</span>
<span class="cm">  *		prefix does not end with a space, then &quot;: &quot; will be added</span>
<span class="cm">  *		after the prefix. If @prefix == NULL, then no prefix will be</span>
<span class="cm">  *		used.</span>
<span class="cm">  *</span>
<span class="cm">  * For use with VIDIOC_LOG_STATUS.</span>
<span class="cm">  *</span>
<span class="cm">  * Does nothing if @hdl == NULL.</span>
<span class="cm">  */</span>
<span class="kt">void</span> <span class="n">v4l2_ctrl_handler_log_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">);</span>

<span class="cm">/** v4l2_ctrl_new_custom() - Allocate and initialize a new custom V4L2</span>
<span class="cm">  * control.</span>
<span class="cm">  * @hdl:	The control handler.</span>
<span class="cm">  * @cfg:	The control&#39;s configuration data.</span>
<span class="cm">  * @priv:	The control&#39;s driver-specific private data.</span>
<span class="cm">  *</span>
<span class="cm">  * If the &amp;v4l2_ctrl struct could not be allocated then NULL is returned</span>
<span class="cm">  * and @hdl-&gt;error is set to the error code (if it wasn&#39;t set already).</span>
<span class="cm">  */</span>
<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">v4l2_ctrl_new_custom</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_ctrl_config</span> <span class="o">*</span><span class="n">cfg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>

<span class="cm">/** v4l2_ctrl_new_std() - Allocate and initialize a new standard V4L2 non-menu control.</span>
<span class="cm">  * @hdl:	The control handler.</span>
<span class="cm">  * @ops:	The control ops.</span>
<span class="cm">  * @id:	The control ID.</span>
<span class="cm">  * @min:	The control&#39;s minimum value.</span>
<span class="cm">  * @max:	The control&#39;s maximum value.</span>
<span class="cm">  * @step:	The control&#39;s step value</span>
<span class="cm">  * @def: 	The control&#39;s default value.</span>
<span class="cm">  *</span>
<span class="cm">  * If the &amp;v4l2_ctrl struct could not be allocated, or the control</span>
<span class="cm">  * ID is not known, then NULL is returned and @hdl-&gt;error is set to the</span>
<span class="cm">  * appropriate error code (if it wasn&#39;t set already).</span>
<span class="cm">  *</span>
<span class="cm">  * If @id refers to a menu control, then this function will return NULL.</span>
<span class="cm">  *</span>
<span class="cm">  * Use v4l2_ctrl_new_std_menu() when adding menu controls.</span>
<span class="cm">  */</span>
<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">v4l2_ctrl_new_std</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_ctrl_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">id</span><span class="p">,</span> <span class="n">s32</span> <span class="n">min</span><span class="p">,</span> <span class="n">s32</span> <span class="n">max</span><span class="p">,</span> <span class="n">u32</span> <span class="n">step</span><span class="p">,</span> <span class="n">s32</span> <span class="n">def</span><span class="p">);</span>

<span class="cm">/** v4l2_ctrl_new_std_menu() - Allocate and initialize a new standard V4L2 menu control.</span>
<span class="cm">  * @hdl:	The control handler.</span>
<span class="cm">  * @ops:	The control ops.</span>
<span class="cm">  * @id:	The control ID.</span>
<span class="cm">  * @max:	The control&#39;s maximum value.</span>
<span class="cm">  * @mask: 	The control&#39;s skip mask for menu controls. This makes it</span>
<span class="cm">  *		easy to skip menu items that are not valid. If bit X is set,</span>
<span class="cm">  *		then menu item X is skipped. Of course, this only works for</span>
<span class="cm">  *		menus with &lt;= 32 menu items. There are no menus that come</span>
<span class="cm">  *		close to that number, so this is OK. Should we ever need more,</span>
<span class="cm">  *		then this will have to be extended to a u64 or a bit array.</span>
<span class="cm">  * @def: 	The control&#39;s default value.</span>
<span class="cm">  *</span>
<span class="cm">  * Same as v4l2_ctrl_new_std(), but @min is set to 0 and the @mask value</span>
<span class="cm">  * determines which menu items are to be skipped.</span>
<span class="cm">  *</span>
<span class="cm">  * If @id refers to a non-menu control, then this function will return NULL.</span>
<span class="cm">  */</span>
<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">v4l2_ctrl_new_std_menu</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_ctrl_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">id</span><span class="p">,</span> <span class="n">s32</span> <span class="n">max</span><span class="p">,</span> <span class="n">s32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">s32</span> <span class="n">def</span><span class="p">);</span>

<span class="cm">/** v4l2_ctrl_new_int_menu() - Create a new standard V4L2 integer menu control.</span>
<span class="cm">  * @hdl:	The control handler.</span>
<span class="cm">  * @ops:	The control ops.</span>
<span class="cm">  * @id:	The control ID.</span>
<span class="cm">  * @max:	The control&#39;s maximum value.</span>
<span class="cm">  * @def:	The control&#39;s default value.</span>
<span class="cm">  * @qmenu_int:	The control&#39;s menu entries.</span>
<span class="cm">  *</span>
<span class="cm">  * Same as v4l2_ctrl_new_std_menu(), but @mask is set to 0 and it additionaly</span>
<span class="cm">  * takes as an argument an array of integers determining the menu items.</span>
<span class="cm">  *</span>
<span class="cm">  * If @id refers to a non-integer-menu control, then this function will return NULL.</span>
<span class="cm">  */</span>
<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">v4l2_ctrl_new_int_menu</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_ctrl_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">id</span><span class="p">,</span> <span class="n">s32</span> <span class="n">max</span><span class="p">,</span> <span class="n">s32</span> <span class="n">def</span><span class="p">,</span> <span class="k">const</span> <span class="n">s64</span> <span class="o">*</span><span class="n">qmenu_int</span><span class="p">);</span>

<span class="cm">/** v4l2_ctrl_add_ctrl() - Add a control from another handler to this handler.</span>
<span class="cm">  * @hdl:	The control handler.</span>
<span class="cm">  * @ctrl:	The control to add.</span>
<span class="cm">  *</span>
<span class="cm">  * It will return NULL if it was unable to add the control reference.</span>
<span class="cm">  * If the control already belonged to the handler, then it will do</span>
<span class="cm">  * nothing and just return @ctrl.</span>
<span class="cm">  */</span>
<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">v4l2_ctrl_add_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>

<span class="cm">/** v4l2_ctrl_add_handler() - Add all controls from handler @add to</span>
<span class="cm">  * handler @hdl.</span>
<span class="cm">  * @hdl:	The control handler.</span>
<span class="cm">  * @add:	The control handler whose controls you want to add to</span>
<span class="cm">  *		the @hdl control handler.</span>
<span class="cm">  *</span>
<span class="cm">  * Does nothing if either of the two is a NULL pointer.</span>
<span class="cm">  * In case of an error @hdl-&gt;error will be set to the error code (if it</span>
<span class="cm">  * wasn&#39;t set already).</span>
<span class="cm">  */</span>
<span class="kt">int</span> <span class="n">v4l2_ctrl_add_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">add</span><span class="p">);</span>


<span class="cm">/** v4l2_ctrl_cluster() - Mark all controls in the cluster as belonging to that cluster.</span>
<span class="cm">  * @ncontrols:	The number of controls in this cluster.</span>
<span class="cm">  * @controls: 	The cluster control array of size @ncontrols.</span>
<span class="cm">  */</span>
<span class="kt">void</span> <span class="n">v4l2_ctrl_cluster</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ncontrols</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">**</span><span class="n">controls</span><span class="p">);</span>


<span class="cm">/** v4l2_ctrl_auto_cluster() - Mark all controls in the cluster as belonging to</span>
<span class="cm">  * that cluster and set it up for autofoo/foo-type handling.</span>
<span class="cm">  * @ncontrols:	The number of controls in this cluster.</span>
<span class="cm">  * @controls:	The cluster control array of size @ncontrols. The first control</span>
<span class="cm">  *		must be the &#39;auto&#39; control (e.g. autogain, autoexposure, etc.)</span>
<span class="cm">  * @manual_val: The value for the first control in the cluster that equals the</span>
<span class="cm">  *		manual setting.</span>
<span class="cm">  * @set_volatile: If true, then all controls except the first auto control will</span>
<span class="cm">  *		be volatile.</span>
<span class="cm">  *</span>
<span class="cm">  * Use for control groups where one control selects some automatic feature and</span>
<span class="cm">  * the other controls are only active whenever the automatic feature is turned</span>
<span class="cm">  * off (manual mode). Typical examples: autogain vs gain, auto-whitebalance vs</span>
<span class="cm">  * red and blue balance, etc.</span>
<span class="cm">  *</span>
<span class="cm">  * The behavior of such controls is as follows:</span>
<span class="cm">  *</span>
<span class="cm">  * When the autofoo control is set to automatic, then any manual controls</span>
<span class="cm">  * are set to inactive and any reads will call g_volatile_ctrl (if the control</span>
<span class="cm">  * was marked volatile).</span>
<span class="cm">  *</span>
<span class="cm">  * When the autofoo control is set to manual, then any manual controls will</span>
<span class="cm">  * be marked active, and any reads will just return the current value without</span>
<span class="cm">  * going through g_volatile_ctrl.</span>
<span class="cm">  *</span>
<span class="cm">  * In addition, this function will set the V4L2_CTRL_FLAG_UPDATE flag</span>
<span class="cm">  * on the autofoo control and V4L2_CTRL_FLAG_INACTIVE on the foo control(s)</span>
<span class="cm">  * if autofoo is in auto mode.</span>
<span class="cm">  */</span>
<span class="kt">void</span> <span class="n">v4l2_ctrl_auto_cluster</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ncontrols</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">**</span><span class="n">controls</span><span class="p">,</span>
			<span class="n">u8</span> <span class="n">manual_val</span><span class="p">,</span> <span class="n">bool</span> <span class="n">set_volatile</span><span class="p">);</span>


<span class="cm">/** v4l2_ctrl_find() - Find a control with the given ID.</span>
<span class="cm">  * @hdl:	The control handler.</span>
<span class="cm">  * @id:	The control ID to find.</span>
<span class="cm">  *</span>
<span class="cm">  * If @hdl == NULL this will return NULL as well. Will lock the handler so</span>
<span class="cm">  * do not use from inside &amp;v4l2_ctrl_ops.</span>
<span class="cm">  */</span>
<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">v4l2_ctrl_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">);</span>

<span class="cm">/** v4l2_ctrl_activate() - Make the control active or inactive.</span>
<span class="cm">  * @ctrl:	The control to (de)activate.</span>
<span class="cm">  * @active:	True if the control should become active.</span>
<span class="cm">  *</span>
<span class="cm">  * This sets or clears the V4L2_CTRL_FLAG_INACTIVE flag atomically.</span>
<span class="cm">  * Does nothing if @ctrl == NULL.</span>
<span class="cm">  * This will usually be called from within the s_ctrl op.</span>
<span class="cm">  * The V4L2_EVENT_CTRL event will be generated afterwards.</span>
<span class="cm">  *</span>
<span class="cm">  * This function assumes that the control handler is locked.</span>
<span class="cm">  */</span>
<span class="kt">void</span> <span class="n">v4l2_ctrl_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">,</span> <span class="n">bool</span> <span class="n">active</span><span class="p">);</span>

<span class="cm">/** v4l2_ctrl_grab() - Mark the control as grabbed or not grabbed.</span>
<span class="cm">  * @ctrl:	The control to (de)activate.</span>
<span class="cm">  * @grabbed:	True if the control should become grabbed.</span>
<span class="cm">  *</span>
<span class="cm">  * This sets or clears the V4L2_CTRL_FLAG_GRABBED flag atomically.</span>
<span class="cm">  * Does nothing if @ctrl == NULL.</span>
<span class="cm">  * The V4L2_EVENT_CTRL event will be generated afterwards.</span>
<span class="cm">  * This will usually be called when starting or stopping streaming in the</span>
<span class="cm">  * driver.</span>
<span class="cm">  *</span>
<span class="cm">  * This function assumes that the control handler is not locked and will</span>
<span class="cm">  * take the lock itself.</span>
<span class="cm">  */</span>
<span class="kt">void</span> <span class="n">v4l2_ctrl_grab</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">,</span> <span class="n">bool</span> <span class="n">grabbed</span><span class="p">);</span>

<span class="cm">/** v4l2_ctrl_lock() - Helper function to lock the handler</span>
<span class="cm">  * associated with the control.</span>
<span class="cm">  * @ctrl:	The control to lock.</span>
<span class="cm">  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">v4l2_ctrl_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/** v4l2_ctrl_lock() - Helper function to unlock the handler</span>
<span class="cm">  * associated with the control.</span>
<span class="cm">  * @ctrl:	The control to unlock.</span>
<span class="cm">  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">v4l2_ctrl_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/** v4l2_ctrl_g_ctrl() - Helper function to get the control&#39;s value from within a driver.</span>
<span class="cm">  * @ctrl:	The control.</span>
<span class="cm">  *</span>
<span class="cm">  * This returns the control&#39;s value safely by going through the control</span>
<span class="cm">  * framework. This function will lock the control&#39;s handler, so it cannot be</span>
<span class="cm">  * used from within the &amp;v4l2_ctrl_ops functions.</span>
<span class="cm">  *</span>
<span class="cm">  * This function is for integer type controls only.</span>
<span class="cm">  */</span>
<span class="n">s32</span> <span class="n">v4l2_ctrl_g_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>

<span class="cm">/** v4l2_ctrl_s_ctrl() - Helper function to set the control&#39;s value from within a driver.</span>
<span class="cm">  * @ctrl:	The control.</span>
<span class="cm">  * @val:	The new value.</span>
<span class="cm">  *</span>
<span class="cm">  * This set the control&#39;s new value safely by going through the control</span>
<span class="cm">  * framework. This function will lock the control&#39;s handler, so it cannot be</span>
<span class="cm">  * used from within the &amp;v4l2_ctrl_ops functions.</span>
<span class="cm">  *</span>
<span class="cm">  * This function is for integer type controls only.</span>
<span class="cm">  */</span>
<span class="kt">int</span> <span class="n">v4l2_ctrl_s_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">,</span> <span class="n">s32</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/* Internal helper functions that deal with control events. */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_subscribed_event_ops</span> <span class="n">v4l2_ctrl_sub_ev_ops</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">v4l2_ctrl_replace</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_event</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_event</span> <span class="o">*</span><span class="n">new</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">v4l2_ctrl_merge</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_event</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_event</span> <span class="o">*</span><span class="n">new</span><span class="p">);</span>

<span class="cm">/* Can be used as a vidioc_log_status function that just dumps all controls</span>
<span class="cm">   associated with the filehandle. */</span>
<span class="kt">int</span> <span class="n">v4l2_ctrl_log_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fh</span><span class="p">);</span>

<span class="cm">/* Can be used as a vidioc_subscribe_event function that just subscribes</span>
<span class="cm">   control events. */</span>
<span class="kt">int</span> <span class="n">v4l2_ctrl_subscribe_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">v4l2_event_subscription</span> <span class="o">*</span><span class="n">sub</span><span class="p">);</span>

<span class="cm">/* Can be used as a poll function that just polls for control events. */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">v4l2_ctrl_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="n">wait</span><span class="p">);</span>

<span class="cm">/* Helpers for ioctl_ops. If hdl == NULL then they will all return -EINVAL. */</span>
<span class="kt">int</span> <span class="n">v4l2_queryctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_queryctrl</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">v4l2_querymenu</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_querymenu</span> <span class="o">*</span><span class="n">qm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">v4l2_g_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">v4l2_s_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">v4l2_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">v4l2_g_ext_ctrls</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_ext_controls</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">v4l2_try_ext_ctrls</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_ext_controls</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">v4l2_s_ext_ctrls</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="o">*</span><span class="n">hdl</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">v4l2_ext_controls</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="cm">/* Helpers for subdevices. If the associated ctrl_handler == NULL then they</span>
<span class="cm">   will all return -EINVAL. */</span>
<span class="kt">int</span> <span class="n">v4l2_subdev_queryctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_queryctrl</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">v4l2_subdev_querymenu</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_querymenu</span> <span class="o">*</span><span class="n">qm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">v4l2_subdev_g_ext_ctrls</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_ext_controls</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">v4l2_subdev_try_ext_ctrls</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_ext_controls</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">v4l2_subdev_s_ext_ctrls</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_ext_controls</span> <span class="o">*</span><span class="n">cs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">v4l2_subdev_g_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">v4l2_subdev_s_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
