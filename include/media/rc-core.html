<!DOCTYPE html>
<html><head><title>joekychen/linux » include › media › rc-core.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>rc-core.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Remote Controller core header</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009-2010 by Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation version 2 of the License.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _RC_CORE</span>
<span class="cp">#define _RC_CORE</span>

<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/kfifo.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;media/rc-map.h&gt;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">rc_core_debug</span><span class="p">;</span>
<span class="cp">#define IR_dprintk(level, fmt, ...)				\</span>
<span class="cp">do {								\</span>
<span class="cp">	if (rc_core_debug &gt;= level)				\</span>
<span class="cp">		pr_debug(&quot;%s: &quot; fmt, __func__, ##__VA_ARGS__);	\</span>
<span class="cp">} while (0)</span>

<span class="k">enum</span> <span class="n">rc_driver_type</span> <span class="p">{</span>
	<span class="n">RC_DRIVER_SCANCODE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* Driver or hardware generates a scancode */</span>
	<span class="n">RC_DRIVER_IR_RAW</span><span class="p">,</span>	<span class="cm">/* Needs a Infra-Red pulse/space decoder */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct rc_dev - represents a remote control device</span>
<span class="cm"> * @dev: driver model&#39;s view of this device</span>
<span class="cm"> * @input_name: name of the input child device</span>
<span class="cm"> * @input_phys: physical path to the input child device</span>
<span class="cm"> * @input_id: id of the input child device (struct input_id)</span>
<span class="cm"> * @driver_name: name of the hardware driver which registered this device</span>
<span class="cm"> * @map_name: name of the default keymap</span>
<span class="cm"> * @rc_map: current scan/key table</span>
<span class="cm"> * @lock: used to ensure we&#39;ve filled in all protocol details before</span>
<span class="cm"> *	anyone can call show_protocols or store_protocols</span>
<span class="cm"> * @devno: unique remote control device number</span>
<span class="cm"> * @raw: additional data for raw pulse/space devices</span>
<span class="cm"> * @input_dev: the input child device used to communicate events to userspace</span>
<span class="cm"> * @driver_type: specifies if protocol decoding is done in hardware or software</span>
<span class="cm"> * @idle: used to keep track of RX state</span>
<span class="cm"> * @allowed_protos: bitmask with the supported RC_TYPE_* protocols</span>
<span class="cm"> * @scanmask: some hardware decoders are not capable of providing the full</span>
<span class="cm"> *	scancode to the application. As this is a hardware limit, we can&#39;t do</span>
<span class="cm"> *	anything with it. Yet, as the same keycode table can be used with other</span>
<span class="cm"> *	devices, a mask is provided to allow its usage. Drivers should generally</span>
<span class="cm"> *	leave this field in blank</span>
<span class="cm"> * @priv: driver-specific data</span>
<span class="cm"> * @keylock: protects the remaining members of the struct</span>
<span class="cm"> * @keypressed: whether a key is currently pressed</span>
<span class="cm"> * @keyup_jiffies: time (in jiffies) when the current keypress should be released</span>
<span class="cm"> * @timer_keyup: timer for releasing a keypress</span>
<span class="cm"> * @last_keycode: keycode of last keypress</span>
<span class="cm"> * @last_scancode: scancode of last keypress</span>
<span class="cm"> * @last_toggle: toggle value of last command</span>
<span class="cm"> * @timeout: optional time after which device stops sending data</span>
<span class="cm"> * @min_timeout: minimum timeout supported by device</span>
<span class="cm"> * @max_timeout: maximum timeout supported by device</span>
<span class="cm"> * @rx_resolution : resolution (in ns) of input sampler</span>
<span class="cm"> * @tx_resolution: resolution (in ns) of output sampler</span>
<span class="cm"> * @change_protocol: allow changing the protocol used on hardware decoders</span>
<span class="cm"> * @open: callback to allow drivers to enable polling/irq when IR input device</span>
<span class="cm"> *	is opened.</span>
<span class="cm"> * @close: callback to allow drivers to disable polling/irq when IR input device</span>
<span class="cm"> *	is opened.</span>
<span class="cm"> * @s_tx_mask: set transmitter mask (for devices with multiple tx outputs)</span>
<span class="cm"> * @s_tx_carrier: set transmit carrier frequency</span>
<span class="cm"> * @s_tx_duty_cycle: set transmit duty cycle (0% - 100%)</span>
<span class="cm"> * @s_rx_carrier: inform driver about carrier it is expected to handle</span>
<span class="cm"> * @tx_ir: transmit IR</span>
<span class="cm"> * @s_idle: enable/disable hardware idle mode, upon which,</span>
<span class="cm"> *	device doesn&#39;t interrupt host until it sees IR pulses</span>
<span class="cm"> * @s_learning_mode: enable wide band receiver used for learning</span>
<span class="cm"> * @s_carrier_report: enable carrier reports</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rc_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span>			<span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>			<span class="o">*</span><span class="n">input_name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>			<span class="o">*</span><span class="n">input_phys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">input_id</span>			<span class="n">input_id</span><span class="p">;</span>
	<span class="kt">char</span>				<span class="o">*</span><span class="n">driver_name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>			<span class="o">*</span><span class="n">map_name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rc_map</span>			<span class="n">rc_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>			<span class="n">lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">devno</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ir_raw_event_ctrl</span>	<span class="o">*</span><span class="n">raw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">input_dev</span>		<span class="o">*</span><span class="n">input_dev</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">rc_driver_type</span>		<span class="n">driver_type</span><span class="p">;</span>
	<span class="n">bool</span>				<span class="n">idle</span><span class="p">;</span>
	<span class="n">u64</span>				<span class="n">allowed_protos</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">scanmask</span><span class="p">;</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="n">spinlock_t</span>			<span class="n">keylock</span><span class="p">;</span>
	<span class="n">bool</span>				<span class="n">keypressed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">keyup_jiffies</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span>		<span class="n">timer_keyup</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">last_keycode</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">last_scancode</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">last_toggle</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">timeout</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">min_timeout</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">max_timeout</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">rx_resolution</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">tx_resolution</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="p">(</span><span class="o">*</span><span class="n">change_protocol</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">rc_type</span><span class="p">);</span>
	<span class="kt">int</span>				<span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span>				<span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>				<span class="p">(</span><span class="o">*</span><span class="n">s_tx_mask</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">);</span>
	<span class="kt">int</span>				<span class="p">(</span><span class="o">*</span><span class="n">s_tx_carrier</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">carrier</span><span class="p">);</span>
	<span class="kt">int</span>				<span class="p">(</span><span class="o">*</span><span class="n">s_tx_duty_cycle</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">duty_cycle</span><span class="p">);</span>
	<span class="kt">int</span>				<span class="p">(</span><span class="o">*</span><span class="n">s_rx_carrier_range</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">min</span><span class="p">,</span> <span class="n">u32</span> <span class="n">max</span><span class="p">);</span>
	<span class="kt">int</span>				<span class="p">(</span><span class="o">*</span><span class="n">tx_ir</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">txbuf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n</span><span class="p">);</span>
	<span class="kt">void</span>				<span class="p">(</span><span class="o">*</span><span class="n">s_idle</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">);</span>
	<span class="kt">int</span>				<span class="p">(</span><span class="o">*</span><span class="n">s_learning_mode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>
	<span class="kt">int</span>				<span class="p">(</span><span class="o">*</span><span class="n">s_carrier_report</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define to_rc_dev(d) container_of(d, struct rc_dev, dev)</span>

<span class="cm">/*</span>
<span class="cm"> * From rc-main.c</span>
<span class="cm"> * Those functions can be used on any type of Remote Controller. They</span>
<span class="cm"> * basically creates an input_dev and properly reports the device as a</span>
<span class="cm"> * Remote Controller, at sys/class/rc.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">rc_allocate_device</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rc_free_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rc_register_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rc_unregister_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">rc_repeat</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rc_keydown</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">scancode</span><span class="p">,</span> <span class="n">u8</span> <span class="n">toggle</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rc_keydown_notimeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">scancode</span><span class="p">,</span> <span class="n">u8</span> <span class="n">toggle</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rc_keyup</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">rc_g_keycode_from_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">scancode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * From rc-raw.c</span>
<span class="cm"> * The Raw interface is specific to InfraRed. It may be a good idea to</span>
<span class="cm"> * split it later into a separate header.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">raw_event_type</span> <span class="p">{</span>
	<span class="n">IR_SPACE</span>        <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">IR_PULSE</span>        <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">IR_START_EVENT</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">IR_STOP_EVENT</span>   <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ir_raw_event</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u32</span>             <span class="n">duration</span><span class="p">;</span>

		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u32</span>     <span class="n">carrier</span><span class="p">;</span>
			<span class="n">u8</span>      <span class="n">duty_cycle</span><span class="p">;</span>
		<span class="p">};</span>
	<span class="p">};</span>

	<span class="kt">unsigned</span>                <span class="n">pulse</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>                <span class="n">reset</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>                <span class="n">timeout</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>                <span class="n">carrier_report</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DEFINE_IR_RAW_EVENT(event) \</span>
<span class="cp">	struct ir_raw_event event = { \</span>
<span class="cp">		{ .duration = 0 } , \</span>
<span class="cp">		.pulse = 0, \</span>
<span class="cp">		.reset = 0, \</span>
<span class="cp">		.timeout = 0, \</span>
<span class="cp">		.carrier_report = 0 }</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_ir_raw_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">ir_raw_event</span> <span class="o">*</span><span class="n">ev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ev</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define IR_MAX_DURATION         0xFFFFFFFF      </span><span class="cm">/* a bit more than 4 seconds */</span><span class="cp"></span>
<span class="cp">#define US_TO_NS(usec)		((usec) * 1000)</span>
<span class="cp">#define MS_TO_US(msec)		((msec) * 1000)</span>
<span class="cp">#define MS_TO_NS(msec)		((msec) * 1000 * 1000)</span>

<span class="kt">void</span> <span class="n">ir_raw_event_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ir_raw_event_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ir_raw_event</span> <span class="o">*</span><span class="n">ev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ir_raw_event_store_edge</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">raw_event_type</span> <span class="n">type</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ir_raw_event_store_with_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ir_raw_event</span> <span class="o">*</span><span class="n">ev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ir_raw_event_set_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">idle</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ir_raw_event_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_IR_RAW_EVENT</span><span class="p">(</span><span class="n">ev</span><span class="p">);</span>
	<span class="n">ev</span><span class="p">.</span><span class="n">reset</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">ir_raw_event_store</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>
	<span class="n">ir_raw_event_handle</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* extract mask bits out of data and pack them into the result */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ir_extract_bits</span><span class="p">(</span><span class="n">u32</span> <span class="n">data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">vbit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">value</span> <span class="o">|=</span> <span class="n">vbit</span><span class="p">;</span>
			<span class="n">vbit</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">data</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* _RC_CORE */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
