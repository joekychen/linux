<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › iucv › iucv.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>iucv.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  drivers/s390/net/iucv.h</span>
<span class="cm"> *    IUCV base support.</span>
<span class="cm"> *</span>
<span class="cm"> *  S390 version</span>
<span class="cm"> *    Copyright 2000, 2006 IBM Corporation</span>
<span class="cm"> *    Author(s):Alan Altmark (Alan_Altmark@us.ibm.com)</span>
<span class="cm"> *		Xenia Tkatschow (xenia@us.ibm.com)</span>
<span class="cm"> *    Rewritten for af_iucv:</span>
<span class="cm"> *	Martin Schwidefsky &lt;schwidefsky@de.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Functionality:</span>
<span class="cm"> * To explore any of the IUCV functions, one must first register their</span>
<span class="cm"> * program using iucv_register(). Once your program has successfully</span>
<span class="cm"> * completed a register, it can exploit the other functions.</span>
<span class="cm"> * For furthur reference on all IUCV functionality, refer to the</span>
<span class="cm"> * CP Programming Services book, also available on the web thru</span>
<span class="cm"> * www.vm.ibm.com/pubs, manual # SC24-6084</span>
<span class="cm"> *</span>
<span class="cm"> * Definition of Return Codes</span>
<span class="cm"> * - All positive return codes including zero are reflected back</span>
<span class="cm"> *   from CP. The definition of each return code can be found in</span>
<span class="cm"> *   CP Programming Services book.</span>
<span class="cm"> * - Return Code of:</span>
<span class="cm"> *   -EINVAL: Invalid value</span>
<span class="cm"> *   -ENOMEM: storage allocation failed</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/debug.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * IUCV option flags usable by device drivers:</span>
<span class="cm"> *</span>
<span class="cm"> * IUCV_IPRMDATA  Indicates that your program can handle a message in the</span>
<span class="cm"> *		  parameter list / a message is sent in the parameter list.</span>
<span class="cm"> *		  Used for iucv_path_accept, iucv_path_connect,</span>
<span class="cm"> *		  iucv_message_reply, iucv_message_send, iucv_message_send2way.</span>
<span class="cm"> * IUCV_IPQUSCE	  Indicates that you do not want to receive messages on this</span>
<span class="cm"> *		  path until an iucv_path_resume is issued.</span>
<span class="cm"> *		  Used for iucv_path_accept, iucv_path_connect.</span>
<span class="cm"> * IUCV_IPBUFLST  Indicates that an address list is used for the message data.</span>
<span class="cm"> *		  Used for iucv_message_receive, iucv_message_send,</span>
<span class="cm"> *		  iucv_message_send2way.</span>
<span class="cm"> * IUCV_IPPRTY	  Specifies that you want to send priority messages.</span>
<span class="cm"> *		  Used for iucv_path_accept, iucv_path_connect,</span>
<span class="cm"> *		  iucv_message_reply, iucv_message_send, iucv_message_send2way.</span>
<span class="cm"> * IUCV_IPSYNC	  Indicates a synchronous send request.</span>
<span class="cm"> *		  Used for iucv_message_send, iucv_message_send2way.</span>
<span class="cm"> * IUCV_IPANSLST  Indicates that an address list is used for the reply data.</span>
<span class="cm"> *		  Used for iucv_message_reply, iucv_message_send2way.</span>
<span class="cm"> * IUCV_IPLOCAL	  Specifies that the communication partner has to be on the</span>
<span class="cm"> *		  local system. If local is specified no target class can be</span>
<span class="cm"> *		  specified.</span>
<span class="cm"> *		  Used for iucv_path_connect.</span>
<span class="cm"> *</span>
<span class="cm"> * All flags are defined in the input field IPFLAGS1 of each function</span>
<span class="cm"> * and can be found in CP Programming Services.</span>
<span class="cm"> */</span>
<span class="cp">#define IUCV_IPRMDATA	0x80</span>
<span class="cp">#define IUCV_IPQUSCE	0x40</span>
<span class="cp">#define IUCV_IPBUFLST	0x40</span>
<span class="cp">#define IUCV_IPPRTY	0x20</span>
<span class="cp">#define IUCV_IPANSLST	0x08</span>
<span class="cp">#define IUCV_IPSYNC	0x04</span>
<span class="cp">#define IUCV_IPLOCAL	0x01</span>

<span class="cm">/*</span>
<span class="cm"> * iucv_array : Defines buffer array.</span>
<span class="cm"> * Inside the array may be 31- bit addresses and 31-bit lengths.</span>
<span class="cm"> * Use a pointer to an iucv_array as the buffer, reply or answer</span>
<span class="cm"> * parameter on iucv_message_send, iucv_message_send2way, iucv_message_receive</span>
<span class="cm"> * and iucv_message_reply if IUCV_IPBUFLST or IUCV_IPANSLST are used.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iucv_array</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">address</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="mi">8</span><span class="p">)));</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">iucv_bus</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">iucv_root</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * struct iucv_path</span>
<span class="cm"> * pathid: 16 bit path identification</span>
<span class="cm"> * msglim: 16 bit message limit</span>
<span class="cm"> * flags: properties of the path: IPRMDATA, IPQUSCE, IPPRTY</span>
<span class="cm"> * handler:  address of iucv handler structure</span>
<span class="cm"> * private: private information of the handler associated with the path</span>
<span class="cm"> * list: list_head for the iucv_handler path list.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iucv_path</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">pathid</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">msglim</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">flags</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct iucv_message</span>
<span class="cm"> * id: 32 bit message id</span>
<span class="cm"> * audit: 32 bit error information of purged or replied messages</span>
<span class="cm"> * class: 32 bit target class of a message (source class for replies)</span>
<span class="cm"> * tag: 32 bit tag to be associated with the message</span>
<span class="cm"> * length: 32 bit length of the message / reply</span>
<span class="cm"> * reply_size: 32 bit maximum allowed length of the reply</span>
<span class="cm"> * rmmsg: 8 byte inline message</span>
<span class="cm"> * flags: message properties (IUCV_IPPRTY)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iucv_message</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">audit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">class</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tag</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reply_size</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">rmmsg</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u8</span>  <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * struct iucv_handler</span>
<span class="cm"> *</span>
<span class="cm"> * A vector of functions that handle IUCV interrupts. Each functions gets</span>
<span class="cm"> * a parameter area as defined by the CP Programming Services and private</span>
<span class="cm"> * pointer that is provided by the user of the interface.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iucv_handler</span> <span class="p">{</span>
	 <span class="cm">/*</span>
<span class="cm">	  * The path_pending function is called after an iucv interrupt</span>
<span class="cm">	  * type 0x01 has been received. The base code allocates a path</span>
<span class="cm">	  * structure and &quot;asks&quot; the handler if this path belongs to the</span>
<span class="cm">	  * handler. To accept the path the path_pending function needs</span>
<span class="cm">	  * to call iucv_path_accept and return 0. If the callback returns</span>
<span class="cm">	  * a value != 0 the iucv base code will continue with the next</span>
<span class="cm">	  * handler. The order in which the path_pending functions are</span>
<span class="cm">	  * called is the order of the registration of the iucv handlers</span>
<span class="cm">	  * to the base code.</span>
<span class="cm">	  */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">path_pending</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ipvmid</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">u8</span> <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The path_complete function is called after an iucv interrupt</span>
<span class="cm">	 * type 0x02 has been received for a path that has been established</span>
<span class="cm">	 * for this handler with iucv_path_connect and got accepted by the</span>
<span class="cm">	 * peer with iucv_path_accept.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">path_complete</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>
	 <span class="cm">/*</span>
<span class="cm">	  * The path_severed function is called after an iucv interrupt</span>
<span class="cm">	  * type 0x03 has been received. The communication peer shutdown</span>
<span class="cm">	  * his end of the communication path. The path still exists and</span>
<span class="cm">	  * remaining messages can be received until a iucv_path_sever</span>
<span class="cm">	  * shuts down the other end of the path as well.</span>
<span class="cm">	  */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">path_severed</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The path_quiesced function is called after an icuv interrupt</span>
<span class="cm">	 * type 0x04 has been received. The communication peer has quiesced</span>
<span class="cm">	 * the path. Delivery of messages is stopped until iucv_path_resume</span>
<span class="cm">	 * has been called.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">path_quiesced</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The path_resumed function is called after an icuv interrupt</span>
<span class="cm">	 * type 0x05 has been received. The communication peer has resumed</span>
<span class="cm">	 * the path.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">path_resumed</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The message_pending function is called after an icuv interrupt</span>
<span class="cm">	 * type 0x06 or type 0x07 has been received. A new message is</span>
<span class="cm">	 * available and can be received with iucv_message_receive.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">message_pending</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The message_complete function is called after an icuv interrupt</span>
<span class="cm">	 * type 0x08 or type 0x09 has been received. A message send with</span>
<span class="cm">	 * iucv_message_send2way has been replied to. The reply can be</span>
<span class="cm">	 * received with iucv_message_receive.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">message_complete</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">paths</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_register:</span>
<span class="cm"> * @handler: address of iucv handler structure</span>
<span class="cm"> * @smp: != 0 indicates that the handler can deal with out of order messages</span>
<span class="cm"> *</span>
<span class="cm"> * Registers a driver with IUCV.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -ENOMEM if the memory allocation for the pathid</span>
<span class="cm"> * table failed, or -EIO if IUCV_DECLARE_BUFFER failed on all cpus.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">iucv_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span> <span class="kt">int</span> <span class="n">smp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_unregister</span>
<span class="cm"> * @handler:  address of iucv handler structure</span>
<span class="cm"> * @smp: != 0 indicates that the handler can deal with out of order messages</span>
<span class="cm"> *</span>
<span class="cm"> * Unregister driver from IUCV.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">iucv_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_handler</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">smp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_alloc</span>
<span class="cm"> * @msglim: initial message limit</span>
<span class="cm"> * @flags: initial flags</span>
<span class="cm"> * @gfp: kmalloc allocation flag</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate a new path structure for use with iucv_connect.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns NULL if the memory allocation failed or a pointer to the</span>
<span class="cm"> * path structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="nf">iucv_path_alloc</span><span class="p">(</span><span class="n">u16</span> <span class="n">msglim</span><span class="p">,</span> <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span><span class="p">),</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">msglim</span> <span class="o">=</span> <span class="n">msglim</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">path</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_free</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> *</span>
<span class="cm"> * Frees a path structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iucv_path_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_accept</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @handler: address of iucv handler structure</span>
<span class="cm"> * @userdata: 16 bytes of data reflected to the communication partner</span>
<span class="cm"> * @private: private data passed to interrupt handlers for this path</span>
<span class="cm"> *</span>
<span class="cm"> * This function is issued after the user received a connection pending</span>
<span class="cm"> * external interrupt and now wishes to complete the IUCV communication path.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result of the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">iucv_path_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span>
		     <span class="n">u8</span> <span class="n">userdata</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_connect</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @handler: address of iucv handler structure</span>
<span class="cm"> * @userid: 8-byte user identification</span>
<span class="cm"> * @system: 8-byte target system identification</span>
<span class="cm"> * @userdata: 16 bytes of data reflected to the communication partner</span>
<span class="cm"> * @private: private data passed to interrupt handlers for this path</span>
<span class="cm"> *</span>
<span class="cm"> * This function establishes an IUCV path. Although the connect may complete</span>
<span class="cm"> * successfully, you are not able to use the path until you receive an IUCV</span>
<span class="cm"> * Connection Complete external interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result of the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">iucv_path_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span>
		      <span class="n">u8</span> <span class="n">userid</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">u8</span> <span class="n">system</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">u8</span> <span class="n">userdata</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_quiesce:</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @userdata: 16 bytes of data reflected to the communication partner</span>
<span class="cm"> *</span>
<span class="cm"> * This function temporarily suspends incoming messages on an IUCV path.</span>
<span class="cm"> * You can later reactivate the path by invoking the iucv_resume function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">iucv_path_quiesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">u8</span> <span class="n">userdata</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_resume:</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @userdata: 16 bytes of data reflected to the communication partner</span>
<span class="cm"> *</span>
<span class="cm"> * This function resumes incoming messages on an IUCV path that has</span>
<span class="cm"> * been stopped with iucv_path_quiesce.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">iucv_path_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">u8</span> <span class="n">userdata</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_sever</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @userdata: 16 bytes of data reflected to the communication partner</span>
<span class="cm"> *</span>
<span class="cm"> * This function terminates an IUCV path.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">iucv_path_sever</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">u8</span> <span class="n">userdata</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_message_purge</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> * @srccls: source class of message</span>
<span class="cm"> *</span>
<span class="cm"> * Cancels a message you have sent.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">iucv_message_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		       <span class="n">u32</span> <span class="n">srccls</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_message_receive</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> * @flags: flags that affect how the message is received (IUCV_IPBUFLST)</span>
<span class="cm"> * @buffer: address of data buffer or address of struct iucv_array</span>
<span class="cm"> * @size: length of data buffer</span>
<span class="cm"> * @residual:</span>
<span class="cm"> *</span>
<span class="cm"> * This function receives messages that are being sent to you over</span>
<span class="cm"> * established paths. This function will deal with RMDATA messages</span>
<span class="cm"> * embedded in struct iucv_message as well.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking:	local_bh_enable/local_bh_disable</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">iucv_message_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			 <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">residual</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __iucv_message_receive</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> * @flags: flags that affect how the message is received (IUCV_IPBUFLST)</span>
<span class="cm"> * @buffer: address of data buffer or address of struct iucv_array</span>
<span class="cm"> * @size: length of data buffer</span>
<span class="cm"> * @residual:</span>
<span class="cm"> *</span>
<span class="cm"> * This function receives messages that are being sent to you over</span>
<span class="cm"> * established paths. This function will deal with RMDATA messages</span>
<span class="cm"> * embedded in struct iucv_message as well.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking:	no locking.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__iucv_message_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			   <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="o">*</span><span class="n">residual</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_message_reject</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> *</span>
<span class="cm"> * The reject function refuses a specified message. Between the time you</span>
<span class="cm"> * are notified of a message and the time that you complete the message,</span>
<span class="cm"> * the message may be rejected.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">iucv_message_reject</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_message_reply</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> * @flags: how the reply is sent (IUCV_IPRMDATA, IUCV_IPPRTY, IUCV_IPBUFLST)</span>
<span class="cm"> * @reply: address of data buffer or address of struct iucv_array</span>
<span class="cm"> * @size: length of reply data buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This function responds to the two-way messages that you receive. You</span>
<span class="cm"> * must identify completely the message to which you wish to reply. ie,</span>
<span class="cm"> * pathid, msgid, and trgcls. Prmmsg signifies the data is moved into</span>
<span class="cm"> * the parameter list.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">iucv_message_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		       <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">reply</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_message_send</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> * @flags: how the message is sent (IUCV_IPRMDATA, IUCV_IPPRTY, IUCV_IPBUFLST)</span>
<span class="cm"> * @srccls: source class of message</span>
<span class="cm"> * @buffer: address of data buffer or address of struct iucv_array</span>
<span class="cm"> * @size: length of send buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This function transmits data to another application. Data to be</span>
<span class="cm"> * transmitted is in a buffer and this is a one-way message and the</span>
<span class="cm"> * receiver will not reply to the message.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking:	local_bh_enable/local_bh_disable</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">iucv_message_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		      <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u32</span> <span class="n">srccls</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __iucv_message_send</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> * @flags: how the message is sent (IUCV_IPRMDATA, IUCV_IPPRTY, IUCV_IPBUFLST)</span>
<span class="cm"> * @srccls: source class of message</span>
<span class="cm"> * @buffer: address of data buffer or address of struct iucv_array</span>
<span class="cm"> * @size: length of send buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This function transmits data to another application. Data to be</span>
<span class="cm"> * transmitted is in a buffer and this is a one-way message and the</span>
<span class="cm"> * receiver will not reply to the message.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking:	no locking.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__iucv_message_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			<span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u32</span> <span class="n">srccls</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_message_send2way</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> * @flags: how the message is sent and the reply is received</span>
<span class="cm"> *	   (IUCV_IPRMDATA, IUCV_IPBUFLST, IUCV_IPPRTY, IUCV_ANSLST)</span>
<span class="cm"> * @srccls: source class of message</span>
<span class="cm"> * @buffer: address of data buffer or address of struct iucv_array</span>
<span class="cm"> * @size: length of send buffer</span>
<span class="cm"> * @ansbuf: address of answer buffer or address of struct iucv_array</span>
<span class="cm"> * @asize: size of reply buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This function transmits data to another application. Data to be</span>
<span class="cm"> * transmitted is in a buffer. The receiver of the send is expected to</span>
<span class="cm"> * reply to the message and a buffer is provided into which IUCV moves</span>
<span class="cm"> * the reply to this message.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">iucv_message_send2way</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			  <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u32</span> <span class="n">srccls</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="o">*</span><span class="n">answer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">asize</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">residual</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">iucv_interface</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">message_receive</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		<span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">residual</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">__message_receive</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="o">*</span><span class="n">residual</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">message_reply</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		<span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">reply</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">message_reject</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">message_send</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		<span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u32</span> <span class="n">srccls</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">__message_send</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		<span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u32</span> <span class="n">srccls</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">message_send2way</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u32</span> <span class="n">srccls</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">answer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">asize</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">residual</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">message_purge</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">srccls</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">path_accept</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span>
		<span class="n">u8</span> <span class="n">userdata</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">path_connect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">iucv_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span>
		<span class="n">u8</span> <span class="n">userid</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">u8</span> <span class="n">system</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">u8</span> <span class="n">userdata</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">path_quiesce</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">u8</span> <span class="n">userdata</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">path_resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">u8</span> <span class="n">userdata</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">path_sever</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">u8</span> <span class="n">userdata</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">iucv_register</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span> <span class="kt">int</span> <span class="n">smp</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">iucv_unregister</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iucv_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span> <span class="kt">int</span> <span class="n">smp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">iucv_interface</span> <span class="n">iucv_if</span><span class="p">;</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
