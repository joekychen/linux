f | structs.h | s | 64K | 1726 | Neil Horman | nhorman@tuxdriver.com | 1341121475 |  | sctp: be more restrictive in transport selection on bundled sacks  It was noticed recently that when we send data on a transport, its possible that we might bundle a sack that arrived on a different transport.  While this isn't a major problem, it does go against the SHOULD requirement in section 6.4 of RFC 2960:   An endpoint SHOULD transmit reply chunks (e.g., SACK, HEARTBEAT ACK,    etc.) to the same destination transport address from which it    received the DATA or control chunk to which it is replying.  This    rule should also be followed if the endpoint is bundling DATA chunks    together with the reply chunk.  This patch seeks to correct that.  It restricts the bundling of sack operations to only those transports which have moved the ctsn of the association forward since the last sack.  By doing this we guarantee that we only bundle outbound saks on a transport that has received a chunk since the last sack.  This brings us into stricter compliance with the RFC.  Vlad had initially suggested that we strictly allow only sack bundling on the transport that last moved the ctsn forward.  While this makes sense, I was concerned that doing so prevented us from bundling in the case where we had received chunks that moved the ctsn on multiple transports.  In those cases, the RFC allows us to select any of the transports having received chunks to bundle the sack on.  so I've modified the approach to allow for that, by adding a state variable to each transport that tracks weather it has moved the ctsn since the last sack.  This I think keeps our behavior (and performance), close enough to our current profile that I think we can do this without a sysctl knob to enable/disable it.  Signed-off-by: Neil Horman <nhorman@tuxdriver.com> CC: Vlad Yaseivch <vyasevich@gmail.com> CC: David S. Miller <davem@davemloft.net> CC: linux-sctp@vger.kernel.org Reported-by: Michele Baldessari <michele@redhat.com> Reported-by: sorin serban <sserban@redhat.com> Acked-by: Vlad Yasevich <vyasevich@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | sm.h | s | 15K | 404 | Wei Yongjun | yjwei@cn.fujitsu.com | 1303407344 |  | sctp: implement event notification SCTP_SENDER_DRY_EVENT  This patch implement event notification SCTP_SENDER_DRY_EVENT. SCTP Socket API Extensions:    6.1.9. SCTP_SENDER_DRY_EVENT    When the SCTP stack has no more user data to send or retransmit, this   notification is given to the user. Also, at the time when a user app   subscribes to this event, if there is no data to be sent or   retransmit, the stack will immediately send up this notification.  Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com> Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | ulpevent.h | s | 5.0K | 145 | Thomas Graf | tgraf@infradead.org | 1310143988 |  | sctp: ABORT if receive, reassmbly, or reodering queue is not empty while closing socket  Trigger user ABORT if application closes a socket which has data queued on the socket receive queue or chunks waiting on the reassembly or ordering queue as this would imply data being lost which defeats the point of a graceful shutdown.  This behavior is already practiced in TCP.  We do not check the input queue because that would mean to parse all chunks on it to look for unacknowledged data which seems too much of an effort. Control chunks or duplicated chunks may also be in the input queue and should not be stopping a graceful shutdown.  Signed-off-by: Thomas Graf <tgraf@infradead.org> Acked-by: Vlad Yasevich <vladislav.yasevich@hp.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | ulpqueue.h | s | 3.1K | 76 | Vlad Yasevich | vladislav.yasevich@hp.com | 1202227147 |  | [SCTP]: Stop claiming that this is a "reference implementation"  I was notified by Randy Stewart that lksctp claims to be "the reference implementation".  First of all, "the refrence implementation" was the original implementation of SCTP in usersapce written ty Randy and a few others. Second, after looking at the definiton of 'reference implementation', we don't really meet the requirements.  Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
f | command.h | s | 8.8K | 207 | Max Matveev | makc@redhat.com | 1316207842 |  | sctp: deal with multiple COOKIE_ECHO chunks  Attempt to reduce the number of IP packets emitted in response to single SCTP packet (2e3216cd) introduced a complication - if a packet contains two COOKIE_ECHO chunks and nothing else then SCTP state machine corks the socket while processing first COOKIE_ECHO and then loses the association and forgets to uncork the socket. To deal with the issue add new SCTP command which can be used to set association explictly. Use this new command when processing second COOKIE_ECHO chunk to restore the context for SCTP state machine.  Signed-off-by: Max Matveev <makc@redhat.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | user.h | s | 21K | 686 | Michio Honda | micchie@sfc.wide.ad.jp | 1307005493 |  | sctp: Add socket option operation for Auto-ASCONF.  This patch allows the application to operate Auto-ASCONF on/off behavior via setsockopt() and getsockopt().  Signed-off-by: Michio Honda <micchie@sfc.wide.ad.jp> Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org> Acked-by: Wei Yongjun <yjwei@cn.fujitsu.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | checksum.h | s | 2.6K | 74 | Vlad Yasevich | vladislav.yasevich@hp.com | 1234771390 |  | sctp: Clean up sctp checksumming code  The sctp crc32c checksum is always generated in little endian. So, we clean up the code to treat it as little endian and remove all the __force casts.  Suggested by Herbert Xu.  Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | auth.h | s | 4.3K | 114 | Vlad Yasevich | vladislav.yasevich@hp.com | 1202227147 |  | [SCTP]: Stop claiming that this is a "reference implementation"  I was notified by Randy Stewart that lksctp claims to be "the reference implementation".  First of all, "the refrence implementation" was the original implementation of SCTP in usersapce written ty Randy and a few others. Second, after looking at the definiton of 'reference implementation', we don't really meet the requirements.  Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
f | sctp.h | s | 20K | 612 | Nicolas Dichtel | nicolas.dichtel@6wind.com | 1336706147 |  | sctp: check cached dst before using it  dst_check() will take care of SA (and obsolete field), hence IPsec rekeying scenario is taken into account.  Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com> Acked-by: Vlad Yaseivch <vyasevich@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | constants.h | s | 14K | 375 | Vlad Yasevich | vladislav.yasevich@hp.com | 1303289463 |  | sctp: remove completely unsed EMPTY state  SCTP does not SCTP_STATE_EMPTY and we can never be in that state.  Remove useless code.  Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com> Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | tsnmap.h | s | 5.7K | 154 | Neil Horman | nhorman@tuxdriver.com | 1341121475 |  | sctp: be more restrictive in transport selection on bundled sacks  It was noticed recently that when we send data on a transport, its possible that we might bundle a sack that arrived on a different transport.  While this isn't a major problem, it does go against the SHOULD requirement in section 6.4 of RFC 2960:   An endpoint SHOULD transmit reply chunks (e.g., SACK, HEARTBEAT ACK,    etc.) to the same destination transport address from which it    received the DATA or control chunk to which it is replying.  This    rule should also be followed if the endpoint is bundling DATA chunks    together with the reply chunk.  This patch seeks to correct that.  It restricts the bundling of sack operations to only those transports which have moved the ctsn of the association forward since the last sack.  By doing this we guarantee that we only bundle outbound saks on a transport that has received a chunk since the last sack.  This brings us into stricter compliance with the RFC.  Vlad had initially suggested that we strictly allow only sack bundling on the transport that last moved the ctsn forward.  While this makes sense, I was concerned that doing so prevented us from bundling in the case where we had received chunks that moved the ctsn on multiple transports.  In those cases, the RFC allows us to select any of the transports having received chunks to bundle the sack on.  so I've modified the approach to allow for that, by adding a state variable to each transport that tracks weather it has moved the ctsn since the last sack.  This I think keeps our behavior (and performance), close enough to our current profile that I think we can do this without a sysctl knob to enable/disable it.  Signed-off-by: Neil Horman <nhorman@tuxdriver.com> CC: Vlad Yaseivch <vyasevich@gmail.com> CC: David S. Miller <davem@davemloft.net> CC: linux-sctp@vger.kernel.org Reported-by: Michele Baldessari <michele@redhat.com> Reported-by: sorin serban <sserban@redhat.com> Acked-by: Vlad Yasevich <vyasevich@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
