<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › sctp › user.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>user.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* SCTP kernel implementation</span>
<span class="cm"> * (C) Copyright IBM Corp. 2001, 2004</span>
<span class="cm"> * Copyright (c) 1999-2000 Cisco, Inc.</span>
<span class="cm"> * Copyright (c) 1999-2001 Motorola, Inc.</span>
<span class="cm"> * Copyright (c) 2002 Intel Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the SCTP kernel implementation</span>
<span class="cm"> *</span>
<span class="cm"> * This header represents the structures and constants needed to support</span>
<span class="cm"> * the SCTP Extension to the Sockets API.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is free software;</span>
<span class="cm"> * you can redistribute it and/or modify it under the terms of</span>
<span class="cm"> * the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is distributed in the hope that it</span>
<span class="cm"> * will be useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="cm"> *                 ************************</span>
<span class="cm"> * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with GNU CC; see the file COPYING.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Please send any bug reports or fixes you make to the</span>
<span class="cm"> * email address(es):</span>
<span class="cm"> *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Or submit a bug report through the following website:</span>
<span class="cm"> *    http://www.sf.net/projects/lksctp</span>
<span class="cm"> *</span>
<span class="cm"> * Written or modified by:</span>
<span class="cm"> *    La Monte H.P. Yarroll    &lt;piggy@acm.org&gt;</span>
<span class="cm"> *    R. Stewart               &lt;randall@sctp.chicago.il.us&gt;</span>
<span class="cm"> *    K. Morneau               &lt;kmorneau@cisco.com&gt;</span>
<span class="cm"> *    Q. Xie                   &lt;qxie1@email.mot.com&gt;</span>
<span class="cm"> *    Karl Knutson             &lt;karl@athena.chicago.il.us&gt;</span>
<span class="cm"> *    Jon Grimm                &lt;jgrimm@us.ibm.com&gt;</span>
<span class="cm"> *    Daisy Chang              &lt;daisyc@us.ibm.com&gt;</span>
<span class="cm"> *    Ryan Layer               &lt;rmlayer@us.ibm.com&gt;</span>
<span class="cm"> *    Ardelle Fan	       &lt;ardelle.fan@intel.com&gt;</span>
<span class="cm"> *    Sridhar Samudrala        &lt;sri@us.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Any bugs reported given to us we will try to fix... any fixes shared will</span>
<span class="cm"> * be incorporated into the next SCTP release.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __net_sctp_user_h__</span>
<span class="cp">#define __net_sctp_user_h__</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>

<span class="k">typedef</span> <span class="n">__s32</span> <span class="n">sctp_assoc_t</span><span class="p">;</span>

<span class="cm">/* The following symbols come from the Sockets API Extensions for</span>
<span class="cm"> * SCTP &lt;draft-ietf-tsvwg-sctpsocket-07.txt&gt;.</span>
<span class="cm"> */</span>
<span class="cp">#define SCTP_RTOINFO	0</span>
<span class="cp">#define SCTP_ASSOCINFO  1</span>
<span class="cp">#define SCTP_INITMSG	2</span>
<span class="cp">#define SCTP_NODELAY	3		</span><span class="cm">/* Get/set nodelay option. */</span><span class="cp"></span>
<span class="cp">#define SCTP_AUTOCLOSE	4</span>
<span class="cp">#define SCTP_SET_PEER_PRIMARY_ADDR 5</span>
<span class="cp">#define SCTP_PRIMARY_ADDR	6</span>
<span class="cp">#define SCTP_ADAPTATION_LAYER	7</span>
<span class="cp">#define SCTP_DISABLE_FRAGMENTS	8</span>
<span class="cp">#define SCTP_PEER_ADDR_PARAMS	9</span>
<span class="cp">#define SCTP_DEFAULT_SEND_PARAM	10</span>
<span class="cp">#define SCTP_EVENTS	11</span>
<span class="cp">#define SCTP_I_WANT_MAPPED_V4_ADDR 12	</span><span class="cm">/* Turn on/off mapped v4 addresses  */</span><span class="cp"></span>
<span class="cp">#define SCTP_MAXSEG	13		</span><span class="cm">/* Get/set maximum fragment. */</span><span class="cp"></span>
<span class="cp">#define SCTP_STATUS	14</span>
<span class="cp">#define SCTP_GET_PEER_ADDR_INFO	15</span>
<span class="cp">#define SCTP_DELAYED_ACK_TIME	16</span>
<span class="cp">#define SCTP_DELAYED_ACK SCTP_DELAYED_ACK_TIME</span>
<span class="cp">#define SCTP_DELAYED_SACK SCTP_DELAYED_ACK_TIME</span>
<span class="cp">#define SCTP_CONTEXT	17</span>
<span class="cp">#define SCTP_FRAGMENT_INTERLEAVE	18</span>
<span class="cp">#define SCTP_PARTIAL_DELIVERY_POINT	19 </span><span class="cm">/* Set/Get partial delivery point */</span><span class="cp"></span>
<span class="cp">#define SCTP_MAX_BURST	20		</span><span class="cm">/* Set/Get max burst */</span><span class="cp"></span>
<span class="cp">#define SCTP_AUTH_CHUNK	21	</span><span class="cm">/* Set only: add a chunk type to authenticate */</span><span class="cp"></span>
<span class="cp">#define SCTP_HMAC_IDENT	22</span>
<span class="cp">#define SCTP_AUTH_KEY	23</span>
<span class="cp">#define SCTP_AUTH_ACTIVE_KEY	24</span>
<span class="cp">#define SCTP_AUTH_DELETE_KEY	25</span>
<span class="cp">#define SCTP_PEER_AUTH_CHUNKS	26	</span><span class="cm">/* Read only */</span><span class="cp"></span>
<span class="cp">#define SCTP_LOCAL_AUTH_CHUNKS	27	</span><span class="cm">/* Read only */</span><span class="cp"></span>
<span class="cp">#define SCTP_GET_ASSOC_NUMBER	28	</span><span class="cm">/* Read only */</span><span class="cp"></span>
<span class="cp">#define SCTP_GET_ASSOC_ID_LIST	29	</span><span class="cm">/* Read only */</span><span class="cp"></span>
<span class="cp">#define SCTP_AUTO_ASCONF       30</span>

<span class="cm">/* Internal Socket Options. Some of the sctp library functions are</span>
<span class="cm"> * implemented using these socket options.</span>
<span class="cm"> */</span>
<span class="cp">#define SCTP_SOCKOPT_BINDX_ADD	100	</span><span class="cm">/* BINDX requests for adding addrs */</span><span class="cp"></span>
<span class="cp">#define SCTP_SOCKOPT_BINDX_REM	101	</span><span class="cm">/* BINDX requests for removing addrs. */</span><span class="cp"></span>
<span class="cp">#define SCTP_SOCKOPT_PEELOFF	102	</span><span class="cm">/* peel off association. */</span><span class="cp"></span>
<span class="cm">/* Options 104-106 are deprecated and removed. Do not use this space */</span>
<span class="cp">#define SCTP_SOCKOPT_CONNECTX_OLD	107	</span><span class="cm">/* CONNECTX old requests. */</span><span class="cp"></span>
<span class="cp">#define SCTP_GET_PEER_ADDRS	108		</span><span class="cm">/* Get all peer address. */</span><span class="cp"></span>
<span class="cp">#define SCTP_GET_LOCAL_ADDRS	109		</span><span class="cm">/* Get all local address. */</span><span class="cp"></span>
<span class="cp">#define SCTP_SOCKOPT_CONNECTX	110		</span><span class="cm">/* CONNECTX requests. */</span><span class="cp"></span>
<span class="cp">#define SCTP_SOCKOPT_CONNECTX3	111	</span><span class="cm">/* CONNECTX requests (updated) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * 5.2.1 SCTP Initiation Structure (SCTP_INIT)</span>
<span class="cm"> *</span>
<span class="cm"> *   This cmsghdr structure provides information for initializing new</span>
<span class="cm"> *   SCTP associations with sendmsg().  The SCTP_INITMSG socket option</span>
<span class="cm"> *   uses this same data structure.  This structure is not used for</span>
<span class="cm"> *   recvmsg().</span>
<span class="cm"> *</span>
<span class="cm"> *   cmsg_level    cmsg_type      cmsg_data[]</span>
<span class="cm"> *   ------------  ------------   ----------------------</span>
<span class="cm"> *   IPPROTO_SCTP  SCTP_INIT      struct sctp_initmsg</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_initmsg</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">sinit_num_ostreams</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sinit_max_instreams</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sinit_max_attempts</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sinit_max_init_timeo</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 5.2.2 SCTP Header Information Structure (SCTP_SNDRCV)</span>
<span class="cm"> *</span>
<span class="cm"> *   This cmsghdr structure specifies SCTP options for sendmsg() and</span>
<span class="cm"> *   describes SCTP header information about a received message through</span>
<span class="cm"> *   recvmsg().</span>
<span class="cm"> *</span>
<span class="cm"> *   cmsg_level    cmsg_type      cmsg_data[]</span>
<span class="cm"> *   ------------  ------------   ----------------------</span>
<span class="cm"> *   IPPROTO_SCTP  SCTP_SNDRCV    struct sctp_sndrcvinfo</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">sinfo_stream</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sinfo_ssn</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sinfo_flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sinfo_ppid</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sinfo_context</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sinfo_timetolive</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sinfo_tsn</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sinfo_cumtsn</span><span class="p">;</span>
	<span class="n">sctp_assoc_t</span> <span class="n">sinfo_assoc_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  sinfo_flags: 16 bits (unsigned integer)</span>
<span class="cm"> *</span>
<span class="cm"> *   This field may contain any of the following flags and is composed of</span>
<span class="cm"> *   a bitwise OR of these values.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">sctp_sinfo_flags</span> <span class="p">{</span>
	<span class="n">SCTP_UNORDERED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="cm">/* Send/receive message unordered. */</span>
	<span class="n">SCTP_ADDR_OVER</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>  <span class="cm">/* Override the primary destination. */</span>
	<span class="n">SCTP_ABORT</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>        <span class="cm">/* Send an ABORT message to the peer. */</span>
	<span class="n">SCTP_SACK_IMMEDIATELY</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>	<span class="cm">/* SACK should be sent without delay */</span>
	<span class="n">SCTP_EOF</span><span class="o">=</span><span class="n">MSG_FIN</span><span class="p">,</span>    <span class="cm">/* Initiate graceful shutdown process. */</span>	
<span class="p">};</span>


<span class="cm">/* These are cmsg_types.  */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">sctp_cmsg_type</span> <span class="p">{</span>
	<span class="n">SCTP_INIT</span><span class="p">,</span>              <span class="cm">/* 5.2.1 SCTP Initiation Structure */</span>
	<span class="n">SCTP_SNDRCV</span><span class="p">,</span>            <span class="cm">/* 5.2.2 SCTP Header Information Structure */</span>
<span class="p">}</span> <span class="n">sctp_cmsg_t</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * 5.3.1.1 SCTP_ASSOC_CHANGE</span>
<span class="cm"> *</span>
<span class="cm"> *   Communication notifications inform the ULP that an SCTP association</span>
<span class="cm"> *   has either begun or ended. The identifier for a new association is</span>
<span class="cm"> *   provided by this notificaion. The notification information has the</span>
<span class="cm"> *   following format:</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_assoc_change</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">sac_type</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sac_flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sac_length</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sac_state</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sac_error</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sac_outbound_streams</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sac_inbound_streams</span><span class="p">;</span>
	<span class="n">sctp_assoc_t</span> <span class="n">sac_assoc_id</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">sac_info</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *   sac_state: 32 bits (signed integer)</span>
<span class="cm"> *</span>
<span class="cm"> *   This field holds one of a number of values that communicate the</span>
<span class="cm"> *   event that happened to the association.  They include:</span>
<span class="cm"> *</span>
<span class="cm"> *   Note:  The following state names deviate from the API draft as</span>
<span class="cm"> *   the names clash too easily with other kernel symbols.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">sctp_sac_state</span> <span class="p">{</span>
	<span class="n">SCTP_COMM_UP</span><span class="p">,</span>
	<span class="n">SCTP_COMM_LOST</span><span class="p">,</span>
	<span class="n">SCTP_RESTART</span><span class="p">,</span>
	<span class="n">SCTP_SHUTDOWN_COMP</span><span class="p">,</span>
	<span class="n">SCTP_CANT_STR_ASSOC</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 5.3.1.2 SCTP_PEER_ADDR_CHANGE</span>
<span class="cm"> *</span>
<span class="cm"> *   When a destination address on a multi-homed peer encounters a change</span>
<span class="cm"> *   an interface details event is sent.  The information has the</span>
<span class="cm"> *   following structure:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_paddr_change</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">spc_type</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">spc_flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">spc_length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">spc_aaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">spc_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">spc_error</span><span class="p">;</span>
	<span class="n">sctp_assoc_t</span> <span class="n">spc_assoc_id</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">,</span> <span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span>

<span class="cm">/*</span>
<span class="cm"> *    spc_state:  32 bits (signed integer)</span>
<span class="cm"> *</span>
<span class="cm"> *   This field holds one of a number of values that communicate the</span>
<span class="cm"> *   event that happened to the address.  They include:</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">sctp_spc_state</span> <span class="p">{</span>
	<span class="n">SCTP_ADDR_AVAILABLE</span><span class="p">,</span>
	<span class="n">SCTP_ADDR_UNREACHABLE</span><span class="p">,</span>
	<span class="n">SCTP_ADDR_REMOVED</span><span class="p">,</span>
	<span class="n">SCTP_ADDR_ADDED</span><span class="p">,</span>
	<span class="n">SCTP_ADDR_MADE_PRIM</span><span class="p">,</span>
	<span class="n">SCTP_ADDR_CONFIRMED</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * 5.3.1.3 SCTP_REMOTE_ERROR</span>
<span class="cm"> *</span>
<span class="cm"> *   A remote peer may send an Operational Error message to its peer.</span>
<span class="cm"> *   This message indicates a variety of error conditions on an</span>
<span class="cm"> *   association. The entire error TLV as it appears on the wire is</span>
<span class="cm"> *   included in a SCTP_REMOTE_ERROR event.  Please refer to the SCTP</span>
<span class="cm"> *   specification [SCTP] and any extensions for a list of possible</span>
<span class="cm"> *   error formats. SCTP error TLVs have the format:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_remote_error</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">sre_type</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sre_flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sre_length</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sre_error</span><span class="p">;</span>
	<span class="n">sctp_assoc_t</span> <span class="n">sre_assoc_id</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">sre_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * 5.3.1.4 SCTP_SEND_FAILED</span>
<span class="cm"> *</span>
<span class="cm"> *   If SCTP cannot deliver a message it may return the message as a</span>
<span class="cm"> *   notification.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_send_failed</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">ssf_type</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ssf_flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ssf_length</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ssf_error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span> <span class="n">ssf_info</span><span class="p">;</span>
	<span class="n">sctp_assoc_t</span> <span class="n">ssf_assoc_id</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">ssf_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *   ssf_flags: 16 bits (unsigned integer)</span>
<span class="cm"> *</span>
<span class="cm"> *   The flag value will take one of the following values</span>
<span class="cm"> *</span>
<span class="cm"> *   SCTP_DATA_UNSENT  - Indicates that the data was never put on</span>
<span class="cm"> *                       the wire.</span>
<span class="cm"> *</span>
<span class="cm"> *   SCTP_DATA_SENT    - Indicates that the data was put on the wire.</span>
<span class="cm"> *                       Note that this does not necessarily mean that the</span>
<span class="cm"> *                       data was (or was not) successfully delivered.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">sctp_ssf_flags</span> <span class="p">{</span>
	<span class="n">SCTP_DATA_UNSENT</span><span class="p">,</span>
	<span class="n">SCTP_DATA_SENT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 5.3.1.5 SCTP_SHUTDOWN_EVENT</span>
<span class="cm"> *</span>
<span class="cm"> *   When a peer sends a SHUTDOWN, SCTP delivers this notification to</span>
<span class="cm"> *   inform the application that it should cease sending data.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_shutdown_event</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">sse_type</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sse_flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sse_length</span><span class="p">;</span>
	<span class="n">sctp_assoc_t</span> <span class="n">sse_assoc_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 5.3.1.6 SCTP_ADAPTATION_INDICATION</span>
<span class="cm"> *</span>
<span class="cm"> *   When a peer sends a Adaptation Layer Indication parameter , SCTP</span>
<span class="cm"> *   delivers this notification to inform the application</span>
<span class="cm"> *   that of the peers requested adaptation layer.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_adaptation_event</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">sai_type</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sai_flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sai_length</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sai_adaptation_ind</span><span class="p">;</span>
	<span class="n">sctp_assoc_t</span> <span class="n">sai_assoc_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 5.3.1.7 SCTP_PARTIAL_DELIVERY_EVENT</span>
<span class="cm"> *</span>
<span class="cm"> *   When a receiver is engaged in a partial delivery of a</span>
<span class="cm"> *   message this notification will be used to indicate</span>
<span class="cm"> *   various events.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_pdapi_event</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">pdapi_type</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">pdapi_flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pdapi_length</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pdapi_indication</span><span class="p">;</span>
	<span class="n">sctp_assoc_t</span> <span class="n">pdapi_assoc_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span> <span class="n">SCTP_PARTIAL_DELIVERY_ABORTED</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="p">};</span>

<span class="k">struct</span> <span class="n">sctp_authkey_event</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">auth_type</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">auth_flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">auth_length</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">auth_keynumber</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">auth_altkeynumber</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">auth_indication</span><span class="p">;</span>
	<span class="n">sctp_assoc_t</span> <span class="n">auth_assoc_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span> <span class="n">SCTP_AUTH_NEWKEY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 6.1.9. SCTP_SENDER_DRY_EVENT</span>
<span class="cm"> *</span>
<span class="cm"> * When the SCTP stack has no more user data to send or retransmit, this</span>
<span class="cm"> * notification is given to the user. Also, at the time when a user app</span>
<span class="cm"> * subscribes to this event, if there is no data to be sent or</span>
<span class="cm"> * retransmit, the stack will immediately send up this notification.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_sender_dry_event</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">sender_dry_type</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sender_dry_flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sender_dry_length</span><span class="p">;</span>
	<span class="n">sctp_assoc_t</span> <span class="n">sender_dry_assoc_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Described in Section 7.3</span>
<span class="cm"> *   Ancillary Data and Notification Interest Options</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_event_subscribe</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="n">sctp_data_io_event</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">sctp_association_event</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">sctp_address_event</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">sctp_send_failure_event</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">sctp_peer_error_event</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">sctp_shutdown_event</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">sctp_partial_delivery_event</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">sctp_adaptation_layer_event</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">sctp_authentication_event</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">sctp_sender_dry_event</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 5.3.1 SCTP Notification Structure</span>
<span class="cm"> *</span>
<span class="cm"> *   The notification structure is defined as the union of all</span>
<span class="cm"> *   notification types.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">sctp_notification</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">__u16</span> <span class="n">sn_type</span><span class="p">;</span>             <span class="cm">/* Notification type. */</span>
		<span class="n">__u16</span> <span class="n">sn_flags</span><span class="p">;</span>
		<span class="n">__u32</span> <span class="n">sn_length</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">sn_header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_assoc_change</span> <span class="n">sn_assoc_change</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_paddr_change</span> <span class="n">sn_paddr_change</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_remote_error</span> <span class="n">sn_remote_error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_send_failed</span> <span class="n">sn_send_failed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_shutdown_event</span> <span class="n">sn_shutdown_event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_adaptation_event</span> <span class="n">sn_adaptation_event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_pdapi_event</span> <span class="n">sn_pdapi_event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_authkey_event</span> <span class="n">sn_authkey_event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sender_dry_event</span> <span class="n">sn_sender_dry_event</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Section 5.3.1</span>
<span class="cm"> * All standard values for sn_type flags are greater than 2^15.</span>
<span class="cm"> * Values from 2^15 and down are reserved.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">sctp_sn_type</span> <span class="p">{</span>
	<span class="n">SCTP_SN_TYPE_BASE</span>     <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">15</span><span class="p">),</span>
	<span class="n">SCTP_ASSOC_CHANGE</span><span class="p">,</span>
	<span class="n">SCTP_PEER_ADDR_CHANGE</span><span class="p">,</span>
	<span class="n">SCTP_SEND_FAILED</span><span class="p">,</span>
	<span class="n">SCTP_REMOTE_ERROR</span><span class="p">,</span>
	<span class="n">SCTP_SHUTDOWN_EVENT</span><span class="p">,</span>
	<span class="n">SCTP_PARTIAL_DELIVERY_EVENT</span><span class="p">,</span>
	<span class="n">SCTP_ADAPTATION_INDICATION</span><span class="p">,</span>
	<span class="n">SCTP_AUTHENTICATION_EVENT</span><span class="p">,</span>
<span class="cp">#define SCTP_AUTHENTICATION_INDICATION	SCTP_AUTHENTICATION_EVENT</span>
	<span class="n">SCTP_SENDER_DRY_EVENT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Notification error codes used to fill up the error fields in some</span>
<span class="cm"> * notifications.</span>
<span class="cm"> * SCTP_PEER_ADDRESS_CHAGE 	: spc_error</span>
<span class="cm"> * SCTP_ASSOC_CHANGE		: sac_error</span>
<span class="cm"> * These names should be potentially included in the draft 04 of the SCTP</span>
<span class="cm"> * sockets API specification.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">sctp_sn_error</span> <span class="p">{</span>
	<span class="n">SCTP_FAILED_THRESHOLD</span><span class="p">,</span>
	<span class="n">SCTP_RECEIVED_SACK</span><span class="p">,</span>
	<span class="n">SCTP_HEARTBEAT_SUCCESS</span><span class="p">,</span>
	<span class="n">SCTP_RESPONSE_TO_USER_REQ</span><span class="p">,</span>
	<span class="n">SCTP_INTERNAL_ERROR</span><span class="p">,</span>
	<span class="n">SCTP_SHUTDOWN_GUARD_EXPIRES</span><span class="p">,</span>
	<span class="n">SCTP_PEER_FAULTY</span><span class="p">,</span>
<span class="p">}</span> <span class="n">sctp_sn_error_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.1 Retransmission Timeout Parameters (SCTP_RTOINFO)</span>
<span class="cm"> *</span>
<span class="cm"> *   The protocol parameters used to initialize and bound retransmission</span>
<span class="cm"> *   timeout (RTO) are tunable.  See [SCTP] for more information on how</span>
<span class="cm"> *   these parameters are used in RTO calculation. </span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_rtoinfo</span> <span class="p">{</span>
	<span class="n">sctp_assoc_t</span>	<span class="n">srto_assoc_id</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">srto_initial</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">srto_max</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">srto_min</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.2 Association Parameters (SCTP_ASSOCINFO)</span>
<span class="cm"> *</span>
<span class="cm"> *   This option is used to both examine and set various association and</span>
<span class="cm"> *   endpoint parameters.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_assocparams</span> <span class="p">{</span>
	<span class="n">sctp_assoc_t</span>	<span class="n">sasoc_assoc_id</span><span class="p">;</span>
	<span class="n">__u16</span>		<span class="n">sasoc_asocmaxrxt</span><span class="p">;</span>
	<span class="n">__u16</span>		<span class="n">sasoc_number_peer_destinations</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">sasoc_peer_rwnd</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">sasoc_local_rwnd</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">sasoc_cookie_life</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.9 Set Peer Primary Address (SCTP_SET_PEER_PRIMARY_ADDR)</span>
<span class="cm"> *</span>
<span class="cm"> *  Requests that the peer mark the enclosed address as the association</span>
<span class="cm"> *  primary. The enclosed address must be one of the association&#39;s</span>
<span class="cm"> *  locally bound addresses. The following structure is used to make a</span>
<span class="cm"> *   set primary request:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_setpeerprim</span> <span class="p">{</span>
	<span class="n">sctp_assoc_t</span>            <span class="n">sspp_assoc_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">sspp_addr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">,</span> <span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.10 Set Primary Address (SCTP_PRIMARY_ADDR)</span>
<span class="cm"> *</span>
<span class="cm"> *  Requests that the local SCTP stack use the enclosed peer address as</span>
<span class="cm"> *  the association primary. The enclosed address must be one of the</span>
<span class="cm"> *  association peer&#39;s addresses. The following structure is used to</span>
<span class="cm"> *  make a set peer primary request:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_prim</span> <span class="p">{</span>
	<span class="n">sctp_assoc_t</span>            <span class="n">ssp_assoc_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">ssp_addr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">,</span> <span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.11 Set Adaptation Layer Indicator (SCTP_ADAPTATION_LAYER)</span>
<span class="cm"> *</span>
<span class="cm"> * Requests that the local endpoint set the specified Adaptation Layer</span>
<span class="cm"> * Indication parameter for all future INIT and INIT-ACK exchanges.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_setadaptation</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">ssb_adaptation_ind</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.13 Peer Address Parameters  (SCTP_PEER_ADDR_PARAMS)</span>
<span class="cm"> *</span>
<span class="cm"> *   Applications can enable or disable heartbeats for any peer address</span>
<span class="cm"> *   of an association, modify an address&#39;s heartbeat interval, force a</span>
<span class="cm"> *   heartbeat to be sent immediately, and adjust the address&#39;s maximum</span>
<span class="cm"> *   number of retransmissions sent before an address is considered</span>
<span class="cm"> *   unreachable. The following structure is used to access and modify an</span>
<span class="cm"> *   address&#39;s parameters:</span>
<span class="cm"> */</span>
<span class="k">enum</span>  <span class="n">sctp_spp_flags</span> <span class="p">{</span>
	<span class="n">SPP_HB_ENABLE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>		<span class="cm">/*Enable heartbeats*/</span>
	<span class="n">SPP_HB_DISABLE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>		<span class="cm">/*Disable heartbeats*/</span>
	<span class="n">SPP_HB</span> <span class="o">=</span> <span class="n">SPP_HB_ENABLE</span> <span class="o">|</span> <span class="n">SPP_HB_DISABLE</span><span class="p">,</span>
	<span class="n">SPP_HB_DEMAND</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span>		<span class="cm">/*Send heartbeat immediately*/</span>
	<span class="n">SPP_PMTUD_ENABLE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span>	<span class="cm">/*Enable PMTU discovery*/</span>
	<span class="n">SPP_PMTUD_DISABLE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">,</span>	<span class="cm">/*Disable PMTU discovery*/</span>
	<span class="n">SPP_PMTUD</span> <span class="o">=</span> <span class="n">SPP_PMTUD_ENABLE</span> <span class="o">|</span> <span class="n">SPP_PMTUD_DISABLE</span><span class="p">,</span>
	<span class="n">SPP_SACKDELAY_ENABLE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">,</span>	<span class="cm">/*Enable SACK*/</span>
	<span class="n">SPP_SACKDELAY_DISABLE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">,</span>	<span class="cm">/*Disable SACK*/</span>
	<span class="n">SPP_SACKDELAY</span> <span class="o">=</span> <span class="n">SPP_SACKDELAY_ENABLE</span> <span class="o">|</span> <span class="n">SPP_SACKDELAY_DISABLE</span><span class="p">,</span>
	<span class="n">SPP_HB_TIME_IS_ZERO</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">,</span>	<span class="cm">/* Set HB delay to 0 */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sctp_paddrparams</span> <span class="p">{</span>
	<span class="n">sctp_assoc_t</span>		<span class="n">spp_assoc_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span>	<span class="n">spp_address</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">spp_hbinterval</span><span class="p">;</span>
	<span class="n">__u16</span>			<span class="n">spp_pathmaxrxt</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">spp_pathmtu</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">spp_sackdelay</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">spp_flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">,</span> <span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.18.  Add a chunk that must be authenticated (SCTP_AUTH_CHUNK)</span>
<span class="cm"> *</span>
<span class="cm"> * This set option adds a chunk type that the user is requesting to be</span>
<span class="cm"> * received only in an authenticated way.  Changes to the list of chunks</span>
<span class="cm"> * will only effect future associations on the socket.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_authchunk</span> <span class="p">{</span>
	<span class="n">__u8</span>		<span class="n">sauth_chunk</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.19.  Get or set the list of supported HMAC Identifiers (SCTP_HMAC_IDENT)</span>
<span class="cm"> *</span>
<span class="cm"> * This option gets or sets the list of HMAC algorithms that the local</span>
<span class="cm"> * endpoint requires the peer to use.</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">sctp_hmacalgo</span> <span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">shmac_num_idents</span><span class="p">;</span>
	<span class="n">__u16</span>		<span class="n">shmac_idents</span><span class="p">[];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.20.  Set a shared key (SCTP_AUTH_KEY)</span>
<span class="cm"> *</span>
<span class="cm"> * This option will set a shared secret key which is used to build an</span>
<span class="cm"> * association shared key.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_authkey</span> <span class="p">{</span>
	<span class="n">sctp_assoc_t</span>	<span class="n">sca_assoc_id</span><span class="p">;</span>
	<span class="n">__u16</span>		<span class="n">sca_keynumber</span><span class="p">;</span>
	<span class="n">__u16</span>		<span class="n">sca_keylength</span><span class="p">;</span>
	<span class="n">__u8</span>		<span class="n">sca_key</span><span class="p">[];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 7.1.21.  Get or set the active shared key (SCTP_AUTH_ACTIVE_KEY)</span>
<span class="cm"> *</span>
<span class="cm"> * This option will get or set the active shared key to be used to build</span>
<span class="cm"> * the association shared key.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sctp_authkeyid</span> <span class="p">{</span>
	<span class="n">sctp_assoc_t</span>	<span class="n">scact_assoc_id</span><span class="p">;</span>
	<span class="n">__u16</span>		<span class="n">scact_keynumber</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * 7.1.23.  Get or set delayed ack timer (SCTP_DELAYED_SACK)</span>
<span class="cm"> *</span>
<span class="cm"> * This option will effect the way delayed acks are performed.  This</span>
<span class="cm"> * option allows you to get or set the delayed ack time, in</span>
<span class="cm"> * milliseconds.  It also allows changing the delayed ack frequency.</span>
<span class="cm"> * Changing the frequency to 1 disables the delayed sack algorithm.  If</span>
<span class="cm"> * the assoc_id is 0, then this sets or gets the endpoints default</span>
<span class="cm"> * values.  If the assoc_id field is non-zero, then the set or get</span>
<span class="cm"> * effects the specified association for the one to many model (the</span>
<span class="cm"> * assoc_id field is ignored by the one to one model).  Note that if</span>
<span class="cm"> * sack_delay or sack_freq are 0 when setting this option, then the</span>
<span class="cm"> * current values will remain unchanged.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_sack_info</span> <span class="p">{</span>
	<span class="n">sctp_assoc_t</span>	<span class="n">sack_assoc_id</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">sack_delay</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">sack_freq</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sctp_assoc_value</span> <span class="p">{</span>
    <span class="n">sctp_assoc_t</span>            <span class="n">assoc_id</span><span class="p">;</span>
    <span class="kt">uint32_t</span>                <span class="n">assoc_value</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 7.2.2 Peer Address Information</span>
<span class="cm"> *</span>
<span class="cm"> *   Applications can retrieve information about a specific peer address</span>
<span class="cm"> *   of an association, including its reachability state, congestion</span>
<span class="cm"> *   window, and retransmission timer values.  This information is</span>
<span class="cm"> *   read-only. The following structure is used to access this</span>
<span class="cm"> *   information:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_paddrinfo</span> <span class="p">{</span>
	<span class="n">sctp_assoc_t</span>		<span class="n">spinfo_assoc_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span>	<span class="n">spinfo_address</span><span class="p">;</span>
	<span class="n">__s32</span>			<span class="n">spinfo_state</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">spinfo_cwnd</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">spinfo_srtt</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">spinfo_rto</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">spinfo_mtu</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">,</span> <span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span>

<span class="cm">/* Peer addresses&#39;s state. */</span>
<span class="cm">/* UNKNOWN: Peer address passed by the upper layer in sendmsg or connect[x]</span>
<span class="cm"> * calls.</span>
<span class="cm"> * UNCONFIRMED: Peer address received in INIT/INIT-ACK address parameters.</span>
<span class="cm"> *              Not yet confirmed by a heartbeat and not available for data</span>
<span class="cm"> *		transfers.</span>
<span class="cm"> * ACTIVE : Peer address confirmed, active and available for data transfers.</span>
<span class="cm"> * INACTIVE: Peer address inactive and not available for data transfers.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">sctp_spinfo_state</span> <span class="p">{</span>
	<span class="n">SCTP_INACTIVE</span><span class="p">,</span>
	<span class="n">SCTP_ACTIVE</span><span class="p">,</span>
	<span class="n">SCTP_UNCONFIRMED</span><span class="p">,</span>
	<span class="n">SCTP_UNKNOWN</span> <span class="o">=</span> <span class="mh">0xffff</span>  <span class="cm">/* Value used for transport state unknown */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 7.2.1 Association Status (SCTP_STATUS)</span>
<span class="cm"> *</span>
<span class="cm"> *   Applications can retrieve current status information about an</span>
<span class="cm"> *   association, including association state, peer receiver window size,</span>
<span class="cm"> *   number of unacked data chunks, and number of data chunks pending</span>
<span class="cm"> *   receipt.  This information is read-only.  The following structure is</span>
<span class="cm"> *   used to access this information:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_status</span> <span class="p">{</span>
	<span class="n">sctp_assoc_t</span>		<span class="n">sstat_assoc_id</span><span class="p">;</span>
	<span class="n">__s32</span>			<span class="n">sstat_state</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">sstat_rwnd</span><span class="p">;</span>
	<span class="n">__u16</span>			<span class="n">sstat_unackdata</span><span class="p">;</span>
	<span class="n">__u16</span>			<span class="n">sstat_penddata</span><span class="p">;</span>
	<span class="n">__u16</span>			<span class="n">sstat_instrms</span><span class="p">;</span>
	<span class="n">__u16</span>			<span class="n">sstat_outstrms</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">sstat_fragmentation_point</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_paddrinfo</span>	<span class="n">sstat_primary</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 7.2.3.  Get the list of chunks the peer requires to be authenticated</span>
<span class="cm"> *         (SCTP_PEER_AUTH_CHUNKS)</span>
<span class="cm"> *</span>
<span class="cm"> * This option gets a list of chunks for a specified association that</span>
<span class="cm"> * the peer requires to be received authenticated only.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_authchunks</span> <span class="p">{</span>
	<span class="n">sctp_assoc_t</span>	<span class="n">gauth_assoc_id</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">gauth_number_of_chunks</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">gauth_chunks</span><span class="p">[];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 8.2.6. Get the Current Identifiers of Associations</span>
<span class="cm"> *        (SCTP_GET_ASSOC_ID_LIST)</span>
<span class="cm"> *</span>
<span class="cm"> * This option gets the current list of SCTP association identifiers of</span>
<span class="cm"> * the SCTP associations handled by a one-to-many style socket.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_assoc_ids</span> <span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">gaids_number_of_ids</span><span class="p">;</span>
	<span class="n">sctp_assoc_t</span>	<span class="n">gaids_assoc_id</span><span class="p">[];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 8.3, 8.5 get all peer/local addresses in an association.</span>
<span class="cm"> * This parameter struct is used by SCTP_GET_PEER_ADDRS and </span>
<span class="cm"> * SCTP_GET_LOCAL_ADDRS socket options used internally to implement</span>
<span class="cm"> * sctp_getpaddrs() and sctp_getladdrs() API. </span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_getaddrs_old</span> <span class="p">{</span>
	<span class="n">sctp_assoc_t</span>            <span class="n">assoc_id</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">addr_num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span>		<span class="n">__user</span> <span class="o">*</span><span class="n">addrs</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">sctp_getaddrs</span> <span class="p">{</span>
	<span class="n">sctp_assoc_t</span>		<span class="n">assoc_id</span><span class="p">;</span> <span class="cm">/*input*/</span>
	<span class="n">__u32</span>			<span class="n">addr_num</span><span class="p">;</span> <span class="cm">/*output*/</span>
	<span class="n">__u8</span>			<span class="n">addrs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/*output, variable size*/</span>
<span class="p">};</span>

<span class="cm">/* These are bit fields for msghdr-&gt;msg_flags.  See section 5.1.  */</span>
<span class="cm">/* On user space Linux, these live in &lt;bits/socket.h&gt; as an enum.  */</span>
<span class="k">enum</span> <span class="n">sctp_msg_flags</span> <span class="p">{</span>
	<span class="n">MSG_NOTIFICATION</span> <span class="o">=</span> <span class="mh">0x8000</span><span class="p">,</span>
<span class="cp">#define MSG_NOTIFICATION MSG_NOTIFICATION</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * 8.1 sctp_bindx()</span>
<span class="cm"> *</span>
<span class="cm"> * The flags parameter is formed from the bitwise OR of zero or more of the</span>
<span class="cm"> * following currently defined flags:</span>
<span class="cm"> */</span>
<span class="cp">#define SCTP_BINDX_ADD_ADDR 0x01</span>
<span class="cp">#define SCTP_BINDX_REM_ADDR 0x02</span>

<span class="cm">/* This is the structure that is passed as an argument(optval) to</span>
<span class="cm"> * getsockopt(SCTP_SOCKOPT_PEELOFF).</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">sctp_assoc_t</span> <span class="n">associd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sd</span><span class="p">;</span>
<span class="p">}</span> <span class="n">sctp_peeloff_arg_t</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* __net_sctp_user_h__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
