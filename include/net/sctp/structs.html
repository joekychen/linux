<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › sctp › structs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>structs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* SCTP kernel implementation</span>
<span class="cm"> * (C) Copyright IBM Corp. 2001, 2004</span>
<span class="cm"> * Copyright (c) 1999-2000 Cisco, Inc.</span>
<span class="cm"> * Copyright (c) 1999-2001 Motorola, Inc.</span>
<span class="cm"> * Copyright (c) 2001 Intel Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the SCTP kernel implementation</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is free software;</span>
<span class="cm"> * you can redistribute it and/or modify it under the terms of</span>
<span class="cm"> * the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This SCTP implementation is distributed in the hope that it</span>
<span class="cm"> * will be useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="cm"> *		   ************************</span>
<span class="cm"> * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with GNU CC; see the file COPYING.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Please send any bug reports or fixes you make to the</span>
<span class="cm"> * email addresses:</span>
<span class="cm"> *    lksctp developers &lt;lksctp-developers@lists.sourceforge.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Or submit a bug report through the following website:</span>
<span class="cm"> *    http://www.sf.net/projects/lksctp</span>
<span class="cm"> *</span>
<span class="cm"> * Written or modified by:</span>
<span class="cm"> *    Randall Stewart	    &lt;randall@sctp.chicago.il.us&gt;</span>
<span class="cm"> *    Ken Morneau	    &lt;kmorneau@cisco.com&gt;</span>
<span class="cm"> *    Qiaobing Xie	    &lt;qxie1@email.mot.com&gt;</span>
<span class="cm"> *    La Monte H.P. Yarroll &lt;piggy@acm.org&gt;</span>
<span class="cm"> *    Karl Knutson	    &lt;karl@athena.chicago.il.us&gt;</span>
<span class="cm"> *    Jon Grimm		    &lt;jgrimm@us.ibm.com&gt;</span>
<span class="cm"> *    Xingang Guo	    &lt;xingang.guo@intel.com&gt;</span>
<span class="cm"> *    Hui Huang		    &lt;hui.huang@nokia.com&gt;</span>
<span class="cm"> *    Sridhar Samudrala	    &lt;sri@us.ibm.com&gt;</span>
<span class="cm"> *    Daisy Chang	    &lt;daisyc@us.ibm.com&gt;</span>
<span class="cm"> *    Dajiang Zhang	    &lt;dajiang.zhang@nokia.com&gt;</span>
<span class="cm"> *    Ardelle Fan	    &lt;ardelle.fan@intel.com&gt;</span>
<span class="cm"> *    Ryan Layer	    &lt;rmlayer@us.ibm.com&gt;</span>
<span class="cm"> *    Anup Pemmaiah	    &lt;pemmaiah@cc.usu.edu&gt;</span>
<span class="cm"> *    Kevin Gao             &lt;kevin.gao@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Any bugs reported given to us we will try to fix... any fixes shared will</span>
<span class="cm"> * be incorporated into the next SCTP release.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __sctp_structs_h__</span>
<span class="cp">#define __sctp_structs_h__</span>

<span class="cp">#include &lt;linux/time.h&gt;		</span><span class="cm">/* We get struct timespec.    */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/socket.h&gt;	</span><span class="cm">/* linux/in.h needs this!!    */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/in.h&gt;		</span><span class="cm">/* We get struct sockaddr_in. */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/in6.h&gt;		</span><span class="cm">/* We get struct in6_addr     */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/ipv6.h&gt;</span>
<span class="cp">#include &lt;asm/param.h&gt;		</span><span class="cm">/* We get MAXHOSTNAMELEN.     */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/atomic.h&gt;		</span><span class="cm">/* This gets us atomic counters.  */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/skbuff.h&gt;	</span><span class="cm">/* We need sk_buff_head. */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/workqueue.h&gt;	</span><span class="cm">/* We need tq_struct.	 */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/sctp.h&gt;		</span><span class="cm">/* We need sctp* header structs.  */</span><span class="cp"></span>
<span class="cp">#include &lt;net/sctp/auth.h&gt;	</span><span class="cm">/* We need auth specific structs */</span><span class="cp"></span>

<span class="cm">/* A convenience structure for handling sockaddr structures.</span>
<span class="cm"> * We should wean ourselves off this.</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">sctp_addr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">v4</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="n">v6</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">sa</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Forward declarations for data structures. */</span>
<span class="k">struct</span> <span class="n">sctp_globals</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sctp_endpoint</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sctp_association</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sctp_transport</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sctp_packet</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sctp_inq</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sctp_outq</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sctp_bind_addr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sctp_ulpq</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sctp_ep_common</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sctp_ssnmap</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">crypto_hash</span><span class="p">;</span>


<span class="cp">#include &lt;net/sctp/tsnmap.h&gt;</span>
<span class="cp">#include &lt;net/sctp/ulpevent.h&gt;</span>
<span class="cp">#include &lt;net/sctp/ulpqueue.h&gt;</span>

<span class="cm">/* Structures useful for managing bind/connect. */</span>

<span class="k">struct</span> <span class="n">sctp_bind_bucket</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">fastreuse</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="n">owner</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sctp_bind_hashbucket</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>	<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="n">chain</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Used for hashing all associations.  */</span>
<span class="k">struct</span> <span class="n">sctp_hashbucket</span> <span class="p">{</span>
	<span class="n">rwlock_t</span>	<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="n">chain</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>


<span class="cm">/* The SCTP globals structure. */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sctp_globals</span> <span class="p">{</span>
	<span class="cm">/* RFC2960 Section 14. Suggested SCTP Protocol Parameter Values</span>
<span class="cm">	 *</span>
<span class="cm">	 * The following protocol parameters are RECOMMENDED:</span>
<span class="cm">	 *</span>
<span class="cm">	 * RTO.Initial		    - 3	 seconds</span>
<span class="cm">	 * RTO.Min		    - 1	 second</span>
<span class="cm">	 * RTO.Max		   -  60 seconds</span>
<span class="cm">	 * RTO.Alpha		    - 1/8  (3 when converted to right shifts.)</span>
<span class="cm">	 * RTO.Beta		    - 1/4  (2 when converted to right shifts.)</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rto_initial</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rto_min</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rto_max</span><span class="p">;</span>

	<span class="cm">/* Note: rto_alpha and rto_beta are really defined as inverse</span>
<span class="cm">	 * powers of two to facilitate integer operations.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">rto_alpha</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rto_beta</span><span class="p">;</span>

	<span class="cm">/* Max.Burst		    - 4 */</span>
	<span class="kt">int</span> <span class="n">max_burst</span><span class="p">;</span>

	<span class="cm">/* Whether Cookie Preservative is enabled(1) or not(0) */</span>
	<span class="kt">int</span> <span class="n">cookie_preserve_enable</span><span class="p">;</span>

	<span class="cm">/* Valid.Cookie.Life	    - 60  seconds  */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">valid_cookie_life</span><span class="p">;</span>

	<span class="cm">/* Delayed SACK timeout  200ms default*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sack_timeout</span><span class="p">;</span>

	<span class="cm">/* HB.interval		    - 30 seconds  */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hb_interval</span><span class="p">;</span>

	<span class="cm">/* Association.Max.Retrans  - 10 attempts</span>
<span class="cm">	 * Path.Max.Retrans	    - 5	 attempts (per destination address)</span>
<span class="cm">	 * Max.Init.Retransmits	    - 8	 attempts</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">max_retrans_association</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_retrans_path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_retrans_init</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Policy for preforming sctp/socket accounting</span>
<span class="cm">	 * 0   - do socket level accounting, all assocs share sk_sndbuf</span>
<span class="cm">	 * 1   - do sctp accounting, each asoc may use sk_sndbuf bytes</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">sndbuf_policy</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Policy for preforming sctp/socket accounting</span>
<span class="cm">	 * 0   - do socket level accounting, all assocs share sk_rcvbuf</span>
<span class="cm">	 * 1   - do sctp accounting, each asoc may use sk_rcvbuf bytes</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">rcvbuf_policy</span><span class="p">;</span>

	<span class="cm">/* The following variables are implementation specific.	 */</span>

	<span class="cm">/* Default initialization values to be applied to new associations. */</span>
	<span class="n">__u16</span> <span class="n">max_instreams</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">max_outstreams</span><span class="p">;</span>

	<span class="cm">/* This is a list of groups of functions for each address</span>
<span class="cm">	 * family that we support.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">address_families</span><span class="p">;</span>

	<span class="cm">/* This is the hash of all endpoints. */</span>
	<span class="kt">int</span> <span class="n">ep_hashsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_hashbucket</span> <span class="o">*</span><span class="n">ep_hashtable</span><span class="p">;</span>

	<span class="cm">/* This is the hash of all associations. */</span>
	<span class="kt">int</span> <span class="n">assoc_hashsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_hashbucket</span> <span class="o">*</span><span class="n">assoc_hashtable</span><span class="p">;</span>

	<span class="cm">/* This is the sctp port control hash.	*/</span>
	<span class="kt">int</span> <span class="n">port_hashsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_bind_hashbucket</span> <span class="o">*</span><span class="n">port_hashtable</span><span class="p">;</span>

	<span class="cm">/* This is the global local address list.</span>
<span class="cm">	 * We actively maintain this complete list of addresses on</span>
<span class="cm">	 * the system by catching address add/delete events.</span>
<span class="cm">	 *</span>
<span class="cm">	 * It is a list of sctp_sockaddr_entry.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">local_addr_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">default_auto_asconf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">addr_waitq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">addr_wq_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">auto_asconf_splist</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">addr_wq_lock</span><span class="p">;</span>

	<span class="cm">/* Lock that protects the local_addr_list writers */</span>
	<span class="n">spinlock_t</span> <span class="n">addr_list_lock</span><span class="p">;</span>
	
	<span class="cm">/* Flag to indicate if addip is enabled. */</span>
	<span class="kt">int</span> <span class="n">addip_enable</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addip_noauth_enable</span><span class="p">;</span>

	<span class="cm">/* Flag to indicate if PR-SCTP is enabled. */</span>
	<span class="kt">int</span> <span class="n">prsctp_enable</span><span class="p">;</span>

	<span class="cm">/* Flag to idicate if SCTP-AUTH is enabled */</span>
	<span class="kt">int</span> <span class="n">auth_enable</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Policy to control SCTP IPv4 address scoping</span>
<span class="cm">	 * 0   - Disable IPv4 address scoping</span>
<span class="cm">	 * 1   - Enable IPv4 address scoping</span>
<span class="cm">	 * 2   - Selectively allow only IPv4 private addresses</span>
<span class="cm">	 * 3   - Selectively allow only IPv4 link local address</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">ipv4_scope_policy</span><span class="p">;</span>

	<span class="cm">/* Flag to indicate whether computing and verifying checksum</span>
<span class="cm">	 * is disabled. */</span>
        <span class="n">bool</span> <span class="n">checksum_disable</span><span class="p">;</span>

	<span class="cm">/* Threshold for rwnd update SACKS.  Receive buffer shifted this many</span>
<span class="cm">	 * bits is an indicator of when to send and window update SACK.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">rwnd_update_shift</span><span class="p">;</span>

	<span class="cm">/* Threshold for autoclose timeout, in seconds. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_autoclose</span><span class="p">;</span>
<span class="p">}</span> <span class="n">sctp_globals</span><span class="p">;</span>

<span class="cp">#define sctp_rto_initial		(sctp_globals.rto_initial)</span>
<span class="cp">#define sctp_rto_min			(sctp_globals.rto_min)</span>
<span class="cp">#define sctp_rto_max			(sctp_globals.rto_max)</span>
<span class="cp">#define sctp_rto_alpha			(sctp_globals.rto_alpha)</span>
<span class="cp">#define sctp_rto_beta			(sctp_globals.rto_beta)</span>
<span class="cp">#define sctp_max_burst			(sctp_globals.max_burst)</span>
<span class="cp">#define sctp_valid_cookie_life		(sctp_globals.valid_cookie_life)</span>
<span class="cp">#define sctp_cookie_preserve_enable	(sctp_globals.cookie_preserve_enable)</span>
<span class="cp">#define sctp_max_retrans_association	(sctp_globals.max_retrans_association)</span>
<span class="cp">#define sctp_sndbuf_policy	 	(sctp_globals.sndbuf_policy)</span>
<span class="cp">#define sctp_rcvbuf_policy	 	(sctp_globals.rcvbuf_policy)</span>
<span class="cp">#define sctp_max_retrans_path		(sctp_globals.max_retrans_path)</span>
<span class="cp">#define sctp_max_retrans_init		(sctp_globals.max_retrans_init)</span>
<span class="cp">#define sctp_sack_timeout		(sctp_globals.sack_timeout)</span>
<span class="cp">#define sctp_hb_interval		(sctp_globals.hb_interval)</span>
<span class="cp">#define sctp_max_instreams		(sctp_globals.max_instreams)</span>
<span class="cp">#define sctp_max_outstreams		(sctp_globals.max_outstreams)</span>
<span class="cp">#define sctp_address_families		(sctp_globals.address_families)</span>
<span class="cp">#define sctp_ep_hashsize		(sctp_globals.ep_hashsize)</span>
<span class="cp">#define sctp_ep_hashtable		(sctp_globals.ep_hashtable)</span>
<span class="cp">#define sctp_assoc_hashsize		(sctp_globals.assoc_hashsize)</span>
<span class="cp">#define sctp_assoc_hashtable		(sctp_globals.assoc_hashtable)</span>
<span class="cp">#define sctp_port_hashsize		(sctp_globals.port_hashsize)</span>
<span class="cp">#define sctp_port_hashtable		(sctp_globals.port_hashtable)</span>
<span class="cp">#define sctp_local_addr_list		(sctp_globals.local_addr_list)</span>
<span class="cp">#define sctp_local_addr_lock		(sctp_globals.addr_list_lock)</span>
<span class="cp">#define sctp_auto_asconf_splist		(sctp_globals.auto_asconf_splist)</span>
<span class="cp">#define sctp_addr_waitq			(sctp_globals.addr_waitq)</span>
<span class="cp">#define sctp_addr_wq_timer		(sctp_globals.addr_wq_timer)</span>
<span class="cp">#define sctp_addr_wq_lock		(sctp_globals.addr_wq_lock)</span>
<span class="cp">#define sctp_default_auto_asconf	(sctp_globals.default_auto_asconf)</span>
<span class="cp">#define sctp_scope_policy		(sctp_globals.ipv4_scope_policy)</span>
<span class="cp">#define sctp_addip_enable		(sctp_globals.addip_enable)</span>
<span class="cp">#define sctp_addip_noauth		(sctp_globals.addip_noauth_enable)</span>
<span class="cp">#define sctp_prsctp_enable		(sctp_globals.prsctp_enable)</span>
<span class="cp">#define sctp_auth_enable		(sctp_globals.auth_enable)</span>
<span class="cp">#define sctp_checksum_disable		(sctp_globals.checksum_disable)</span>
<span class="cp">#define sctp_rwnd_upd_shift		(sctp_globals.rwnd_update_shift)</span>
<span class="cp">#define sctp_max_autoclose		(sctp_globals.max_autoclose)</span>

<span class="cm">/* SCTP Socket type: UDP or TCP style. */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">SCTP_SOCKET_UDP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SCTP_SOCKET_UDP_HIGH_BANDWIDTH</span><span class="p">,</span>
	<span class="n">SCTP_SOCKET_TCP</span>
<span class="p">}</span> <span class="n">sctp_socket_type_t</span><span class="p">;</span>

<span class="cm">/* Per socket SCTP information. */</span>
<span class="k">struct</span> <span class="n">sctp_sock</span> <span class="p">{</span>
	<span class="cm">/* inet_sock has to be the first member of sctp_sock */</span>
	<span class="k">struct</span> <span class="n">inet_sock</span> <span class="n">inet</span><span class="p">;</span>
	<span class="cm">/* What kind of a socket is this? */</span>
	<span class="n">sctp_socket_type_t</span> <span class="n">type</span><span class="p">;</span>

	<span class="cm">/* PF_ family specific functions.  */</span>
	<span class="k">struct</span> <span class="n">sctp_pf</span> <span class="o">*</span><span class="n">pf</span><span class="p">;</span>

	<span class="cm">/* Access to HMAC transform. */</span>
	<span class="k">struct</span> <span class="n">crypto_hash</span> <span class="o">*</span><span class="n">hmac</span><span class="p">;</span>

	<span class="cm">/* What is our base endpointer? */</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sctp_bind_bucket</span> <span class="o">*</span><span class="n">bind_hash</span><span class="p">;</span>
	<span class="cm">/* Various Socket Options.  */</span>
	<span class="n">__u16</span> <span class="n">default_stream</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">default_ppid</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">default_flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">default_context</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">default_timetolive</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">default_rcv_context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_burst</span><span class="p">;</span>

	<span class="cm">/* Heartbeat interval: The endpoint sends out a Heartbeat chunk to</span>
<span class="cm">	 * the destination address every heartbeat interval. This value</span>
<span class="cm">	 * will be inherited by all new associations.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">hbinterval</span><span class="p">;</span>

	<span class="cm">/* This is the max_retrans value for new associations. */</span>
	<span class="n">__u16</span> <span class="n">pathmaxrxt</span><span class="p">;</span>

	<span class="cm">/* The initial Path MTU to use for new associations. */</span>
	<span class="n">__u32</span> <span class="n">pathmtu</span><span class="p">;</span>

	<span class="cm">/* The default SACK delay timeout for new associations. */</span>
	<span class="n">__u32</span> <span class="n">sackdelay</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sackfreq</span><span class="p">;</span>

	<span class="cm">/* Flags controlling Heartbeat, SACK delay, and Path MTU Discovery. */</span>
	<span class="n">__u32</span> <span class="n">param_flags</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sctp_initmsg</span> <span class="n">initmsg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_rtoinfo</span> <span class="n">rtoinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_paddrparams</span> <span class="n">paddrparam</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_event_subscribe</span> <span class="n">subscribe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_assocparams</span> <span class="n">assocparams</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">user_frag</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">autoclose</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">nodelay</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">disable_fragments</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">v4mapped</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">frag_interleave</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">adaptation_ind</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pd_point</span><span class="p">;</span>

	<span class="n">atomic_t</span> <span class="n">pd_mode</span><span class="p">;</span>
	<span class="cm">/* Receive to here while partial delivery is in effect. */</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">pd_lobby</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">auto_asconf_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_auto_asconf</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="nf">sctp_sk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
       <span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="p">)</span><span class="n">sk</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">sctp_opt2sk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
       <span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">)</span><span class="n">sp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
<span class="k">struct</span> <span class="n">sctp6_sock</span> <span class="p">{</span>
       <span class="k">struct</span> <span class="n">sctp_sock</span>  <span class="n">sctp</span><span class="p">;</span>
       <span class="k">struct</span> <span class="n">ipv6_pinfo</span> <span class="n">inet6</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IPV6 */</span><span class="cp"></span>


<span class="cm">/* This is our APPLICATION-SPECIFIC state cookie.</span>
<span class="cm"> * THIS IS NOT DICTATED BY THE SPECIFICATION.</span>
<span class="cm"> */</span>
<span class="cm">/* These are the parts of an association which we send in the cookie.</span>
<span class="cm"> * Most of these are straight out of:</span>
<span class="cm"> * RFC2960 12.2 Parameters necessary per association (i.e. the TCB)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sctp_cookie</span> <span class="p">{</span>

	<span class="cm">/* My	       : Tag expected in every inbound packet and sent</span>
<span class="cm">	 * Verification: in the INIT or INIT ACK chunk.</span>
<span class="cm">	 * Tag	       :</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">my_vtag</span><span class="p">;</span>

	<span class="cm">/* Peer&#39;s      : Tag expected in every outbound packet except</span>
<span class="cm">	 * Verification: in the INIT chunk.</span>
<span class="cm">	 * Tag	       :</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">peer_vtag</span><span class="p">;</span>

	<span class="cm">/* The rest of these are not from the spec, but really need to</span>
<span class="cm">	 * be in the cookie.</span>
<span class="cm">	 */</span>

	<span class="cm">/* My Tie Tag  : Assist in discovering a restarting association. */</span>
	<span class="n">__u32</span> <span class="n">my_ttag</span><span class="p">;</span>

	<span class="cm">/* Peer&#39;s Tie Tag: Assist in discovering a restarting association. */</span>
	<span class="n">__u32</span> <span class="n">peer_ttag</span><span class="p">;</span>

	<span class="cm">/* When does this cookie expire? */</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">expiration</span><span class="p">;</span>

	<span class="cm">/* Number of inbound/outbound streams which are set</span>
<span class="cm">	 * and negotiated during the INIT process.</span>
<span class="cm">	 */</span>
	<span class="n">__u16</span> <span class="n">sinit_num_ostreams</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">sinit_max_instreams</span><span class="p">;</span>

	<span class="cm">/* This is the first sequence number I used.  */</span>
	<span class="n">__u32</span> <span class="n">initial_tsn</span><span class="p">;</span>

	<span class="cm">/* This holds the originating address of the INIT packet.  */</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">peer_addr</span><span class="p">;</span>

	<span class="cm">/* IG Section 2.35.3 </span>
<span class="cm">	 * Include the source port of the INIT-ACK</span>
<span class="cm">	 */</span>
	<span class="n">__u16</span>		<span class="n">my_port</span><span class="p">;</span>

	<span class="n">__u8</span> <span class="n">prsctp_capable</span><span class="p">;</span>

	<span class="cm">/* Padding for future use */</span>
	<span class="n">__u8</span> <span class="n">padding</span><span class="p">;</span>  		

	<span class="n">__u32</span> <span class="n">adaptation_ind</span><span class="p">;</span>

	<span class="n">__u8</span> <span class="n">auth_random</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">SCTP_AUTH_RANDOM_LENGTH</span><span class="p">];</span>
	<span class="n">__u8</span> <span class="n">auth_hmacs</span><span class="p">[</span><span class="n">SCTP_AUTH_NUM_HMACS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u16</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
	<span class="n">__u8</span> <span class="n">auth_chunks</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sctp_paramhdr_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">SCTP_AUTH_MAX_CHUNKS</span><span class="p">];</span>

	<span class="cm">/* This is a shim for my peer&#39;s INIT packet, followed by</span>
<span class="cm">	 * a copy of the raw address list of the association.</span>
<span class="cm">	 * The length of the raw address list is saved in the</span>
<span class="cm">	 * raw_addr_list_len field, which will be used at the time when</span>
<span class="cm">	 * the association TCB is re-constructed from the cookie.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">raw_addr_list_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_init_chunk</span> <span class="n">peer_init</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>


<span class="cm">/* The format of our cookie that we send to our peer. */</span>
<span class="k">struct</span> <span class="n">sctp_signed_cookie</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="n">signature</span><span class="p">[</span><span class="n">SCTP_SECRET_SIZE</span><span class="p">];</span>
	<span class="n">__u32</span> <span class="n">__pad</span><span class="p">;</span>		<span class="cm">/* force sctp_cookie alignment to 64 bits */</span>
	<span class="k">struct</span> <span class="n">sctp_cookie</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* This is another convenience type to allocate memory for address</span>
<span class="cm"> * params for the maximum size and pass such structures around</span>
<span class="cm"> * internally.</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_paramhdr</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ipv4addr_param</span> <span class="n">v4</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ipv6addr_param</span> <span class="n">v6</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* A convenience type to allow walking through the various</span>
<span class="cm"> * parameters and avoid casting all over the place.</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">sctp_params</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_paramhdr</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_cookie_preserve_param</span> <span class="o">*</span><span class="n">life</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_hostname_param</span> <span class="o">*</span><span class="n">dns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_cookie_param</span> <span class="o">*</span><span class="n">cookie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_supported_addrs_param</span> <span class="o">*</span><span class="n">sat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ipv4addr_param</span> <span class="o">*</span><span class="n">v4</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_ipv6addr_param</span> <span class="o">*</span><span class="n">v6</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_adaptation_ind_param</span> <span class="o">*</span><span class="n">aind</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_supported_ext_param</span> <span class="o">*</span><span class="n">ext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_random_param</span> <span class="o">*</span><span class="n">random</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_chunks_param</span> <span class="o">*</span><span class="n">chunks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_hmac_algo_param</span> <span class="o">*</span><span class="n">hmac_algo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_addip_param</span> <span class="o">*</span><span class="n">addip</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* RFC 2960.  Section 3.3.5 Heartbeat.</span>
<span class="cm"> *    Heartbeat Information: variable length</span>
<span class="cm"> *    The Sender-specific Heartbeat Info field should normally include</span>
<span class="cm"> *    information about the sender&#39;s current time when this HEARTBEAT</span>
<span class="cm"> *    chunk is sent and the destination transport address to which this</span>
<span class="cm"> *    HEARTBEAT is sent (see Section 8.3).</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sctp_sender_hb_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_paramhdr</span> <span class="n">param_hdr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">daddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sent_at</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">hb_nonce</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span> <span class="n">sctp_sender_hb_info_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *  RFC 2960 1.3.2 Sequenced Delivery within Streams</span>
<span class="cm"> *</span>
<span class="cm"> *  The term &quot;stream&quot; is used in SCTP to refer to a sequence of user</span>
<span class="cm"> *  messages that are to be delivered to the upper-layer protocol in</span>
<span class="cm"> *  order with respect to other messages within the same stream.  This is</span>
<span class="cm"> *  in contrast to its usage in TCP, where it refers to a sequence of</span>
<span class="cm"> *  bytes (in this document a byte is assumed to be eight bits).</span>
<span class="cm"> *  ...</span>
<span class="cm"> *</span>
<span class="cm"> *  This is the structure we use to track both our outbound and inbound</span>
<span class="cm"> *  SSN, or Stream Sequence Numbers.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sctp_stream</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="o">*</span><span class="n">ssn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sctp_ssnmap</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_stream</span> <span class="n">in</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_stream</span> <span class="n">out</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">malloced</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sctp_ssnmap</span> <span class="o">*</span><span class="n">sctp_ssnmap_new</span><span class="p">(</span><span class="n">__u16</span> <span class="n">in</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">out</span><span class="p">,</span>
				    <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_ssnmap_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ssnmap</span> <span class="o">*</span><span class="n">map</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_ssnmap_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ssnmap</span> <span class="o">*</span><span class="n">map</span><span class="p">);</span>

<span class="cm">/* What is the current SSN number for this stream? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u16</span> <span class="nf">sctp_ssn_peek</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">ssn</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* Return the next SSN number for this stream.	*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u16</span> <span class="nf">sctp_ssn_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">ssn</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Skip over this ssn and all below. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sctp_ssn_skip</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">id</span><span class="p">,</span> 
				 <span class="n">__u16</span> <span class="n">ssn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">ssn</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssn</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
              
<span class="cm">/*</span>
<span class="cm"> * Pointers to address related SCTP functions.</span>
<span class="cm"> * (i.e. things that depend on the address family.)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_af</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">sctp_xmit</span><span class="p">)</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">setsockopt</span><span class="p">)</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
					 <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">getsockopt</span><span class="p">)</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
					 <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">compat_setsockopt</span><span class="p">)</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
					 <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">compat_getsockopt</span><span class="p">)</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
					 <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">get_dst</span><span class="p">)</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
					 <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">get_saddr</span><span class="p">)</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">copy_addrlist</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">cmp_addr</span><span class="p">)</span>	<span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr1</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr2</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">addr_copy</span><span class="p">)</span>	<span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
					 <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">src</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">from_skb</span><span class="p">)</span>	<span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">saddr</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">from_sk</span><span class="p">)</span>	<span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">to_sk_saddr</span><span class="p">)</span>	<span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">to_sk_daddr</span><span class="p">)</span>	<span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">from_addr_param</span><span class="p">)</span> <span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
					    <span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="o">*</span><span class="p">,</span>
					    <span class="n">__be16</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iif</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">to_addr_param</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
					  <span class="k">union</span> <span class="n">sctp_addr_param</span> <span class="o">*</span><span class="p">);</span> 
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">addr_valid</span><span class="p">)</span>	<span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">sctp_scope_t</span>	<span class="p">(</span><span class="o">*</span><span class="n">scope</span><span class="p">)</span> <span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">inaddr_any</span><span class="p">)</span>	<span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span> <span class="n">__be16</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">is_any</span><span class="p">)</span>	<span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">available</span><span class="p">)</span>	<span class="p">(</span><span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">skb_iif</span><span class="p">)</span>	<span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">is_ce</span><span class="p">)</span>	<span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">seq_dump_addr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span>
					 <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">ecn_capable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">__u16</span>		<span class="n">net_header_len</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">sockaddr_len</span><span class="p">;</span>
	<span class="n">sa_family_t</span>	<span class="n">sa_family</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">sctp_get_af_specific</span><span class="p">(</span><span class="n">sa_family_t</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_register_af</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Protocol family functions. */</span>
<span class="k">struct</span> <span class="n">sctp_pf</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">event_msgname</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sctp_ulpevent</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">skb_msgname</span><span class="p">)</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">af_supported</span><span class="p">)</span> <span class="p">(</span><span class="n">sa_family_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">cmp_addr</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">bind_verify</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">send_verify</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">supported_addrs</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="p">,</span> <span class="n">__be16</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">create_accept_sk</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">addr_v4map</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* Structure to track chunk fragments that have been acked, but peer</span>
<span class="cm"> * fragments of the same message have not.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_datamsg</span> <span class="p">{</span>
	<span class="cm">/* Chunks waiting to be submitted to lower layer. */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">chunks</span><span class="p">;</span>
	<span class="cm">/* Reference counting. */</span>
	<span class="n">atomic_t</span> <span class="n">refcnt</span><span class="p">;</span>
	<span class="cm">/* When is this message no longer interesting to the peer? */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires_at</span><span class="p">;</span>
	<span class="cm">/* Did the messenge fail to send? */</span>
	<span class="kt">int</span> <span class="n">send_error</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">send_failed</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
	   <span class="nl">can_abandon:</span><span class="mi">1</span><span class="p">,</span>   <span class="cm">/* can chunks from this message can be abandoned. */</span>
	   <span class="n">can_delay</span><span class="p">;</span>	    <span class="cm">/* should this message be Nagle delayed */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sctp_datamsg</span> <span class="o">*</span><span class="n">sctp_datamsg_from_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span> <span class="o">*</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_datamsg_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_datamsg</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_datamsg_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_datamsg</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_chunk_fail</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_chunk_abandoned</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* RFC2960 1.4 Key Terms</span>
<span class="cm"> *</span>
<span class="cm"> * o Chunk: A unit of information within an SCTP packet, consisting of</span>
<span class="cm"> * a chunk header and chunk-specific content.</span>
<span class="cm"> *</span>
<span class="cm"> * As a matter of convenience, we remember the SCTP common header for</span>
<span class="cm"> * each chunk as well as a few other header pointers...</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="n">atomic_t</span> <span class="n">refcnt</span><span class="p">;</span>

	<span class="cm">/* This is our link to the per-transport transmitted list.  */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">transmitted_list</span><span class="p">;</span>

	<span class="cm">/* This field is used by chunks that hold fragmented data.</span>
<span class="cm">	 * For the first fragment this is the list that holds the rest of</span>
<span class="cm">	 * fragments. For the remaining fragments, this is the link to the</span>
<span class="cm">	 * frag_list maintained in the first fragment.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">frag_list</span><span class="p">;</span>

	<span class="cm">/* This points to the sk_buff containing the actual data.  */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* These are the SCTP headers by reverse order in a packet.</span>
<span class="cm">	 * Note that some of these may happen more than once.  In that</span>
<span class="cm">	 * case, we point at the &quot;current&quot; one, whatever that means</span>
<span class="cm">	 * for that level of header.</span>
<span class="cm">	 */</span>

	<span class="cm">/* We point this at the FIRST TLV parameter to chunk_hdr.  */</span>
	<span class="k">union</span> <span class="n">sctp_params</span> <span class="n">param_hdr</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__u8</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sctp_datahdr</span> <span class="o">*</span><span class="n">data_hdr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sctp_inithdr</span> <span class="o">*</span><span class="n">init_hdr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sctp_sackhdr</span> <span class="o">*</span><span class="n">sack_hdr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sctp_heartbeathdr</span> <span class="o">*</span><span class="n">hb_hdr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sctp_sender_hb_info</span> <span class="o">*</span><span class="n">hbs_hdr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sctp_shutdownhdr</span> <span class="o">*</span><span class="n">shutdown_hdr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sctp_signed_cookie</span> <span class="o">*</span><span class="n">cookie_hdr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sctp_ecnehdr</span> <span class="o">*</span><span class="n">ecne_hdr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sctp_cwrhdr</span> <span class="o">*</span><span class="n">ecn_cwr_hdr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sctp_errhdr</span> <span class="o">*</span><span class="n">err_hdr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sctp_addiphdr</span> <span class="o">*</span><span class="n">addip_hdr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sctp_fwdtsn_hdr</span> <span class="o">*</span><span class="n">fwdtsn_hdr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sctp_authhdr</span> <span class="o">*</span><span class="n">auth_hdr</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">subh</span><span class="p">;</span>

	<span class="n">__u8</span> <span class="o">*</span><span class="n">chunk_end</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sctp_chunkhdr</span> <span class="o">*</span><span class="n">chunk_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctphdr</span> <span class="o">*</span><span class="n">sctp_hdr</span><span class="p">;</span>

	<span class="cm">/* This needs to be recoverable for SCTP_SEND_FAILED events. */</span>
	<span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span> <span class="n">sinfo</span><span class="p">;</span>

	<span class="cm">/* Which association does this belong to?  */</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="cm">/* What endpoint received this chunk? */</span>
	<span class="k">struct</span> <span class="n">sctp_ep_common</span> <span class="o">*</span><span class="n">rcvr</span><span class="p">;</span>

	<span class="cm">/* We fill this in if we are calculating RTT. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sent_at</span><span class="p">;</span>

	<span class="cm">/* What is the origin IP address for this chunk?  */</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">source</span><span class="p">;</span>
	<span class="cm">/* Destination address for this chunk. */</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">dest</span><span class="p">;</span>

	<span class="cm">/* For outbound message, track all fragments for SEND_FAILED. */</span>
	<span class="k">struct</span> <span class="n">sctp_datamsg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

	<span class="cm">/* For an inbound chunk, this tells us where it came from.</span>
<span class="cm">	 * For an outbound chunk, it tells us where we&#39;d like it to</span>
<span class="cm">	 * go.	It is NULL if we have no preference.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>

	<span class="cm">/* SCTP-AUTH:  For the special case inbound processing of COOKIE-ECHO</span>
<span class="cm">	 * we need save a pointer to the AUTH chunk, since the SCTP-AUTH</span>
<span class="cm">	 * spec violates the principle premis that all chunks are processed</span>
<span class="cm">	 * in order.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">auth_chunk</span><span class="p">;</span>

<span class="cp">#define SCTP_CAN_FRTX 0x0</span>
<span class="cp">#define SCTP_NEED_FRTX 0x1</span>
<span class="cp">#define SCTP_DONT_FRTX 0x2</span>
	<span class="n">__u16</span>	<span class="n">rtt_in_progress</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* This chunk used for RTT calc? */</span>
		<span class="nl">has_tsn:</span><span class="mi">1</span><span class="p">,</span>		<span class="cm">/* Does this chunk have a TSN yet? */</span>
		<span class="nl">has_ssn:</span><span class="mi">1</span><span class="p">,</span>		<span class="cm">/* Does this chunk have a SSN yet? */</span>
		<span class="nl">singleton:</span><span class="mi">1</span><span class="p">,</span>		<span class="cm">/* Only chunk in the packet? */</span>
		<span class="nl">end_of_packet:</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* Last chunk in the packet? */</span>
		<span class="nl">ecn_ce_done:</span><span class="mi">1</span><span class="p">,</span>		<span class="cm">/* Have we processed the ECN CE bit? */</span>
		<span class="nl">pdiscard:</span><span class="mi">1</span><span class="p">,</span>		<span class="cm">/* Discard the whole packet now? */</span>
		<span class="nl">tsn_gap_acked:</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* Is this chunk acked by a GAP ACK? */</span>
		<span class="nl">data_accepted:</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* At least 1 chunk accepted */</span>
		<span class="nl">auth:</span><span class="mi">1</span><span class="p">,</span>			<span class="cm">/* IN: was auth&#39;ed | OUT: needs auth */</span>
		<span class="nl">has_asconf:</span><span class="mi">1</span><span class="p">,</span>		<span class="cm">/* IN: have seen an asconf before */</span>
		<span class="nl">tsn_missing_report:</span><span class="mi">2</span><span class="p">,</span>	<span class="cm">/* Data chunk missing counter. */</span>
		<span class="nl">fast_retransmit:</span><span class="mi">2</span><span class="p">;</span>	<span class="cm">/* Is this chunk fast retransmitted? */</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">sctp_chunk_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_chunk_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_user_addto_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_chunk_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>  <span class="o">*</span><span class="n">sctp_addto_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">void</span>  <span class="o">*</span><span class="n">sctp_addto_chunk_fixed</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">sctp_chunkify</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_init_addrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
		     <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">sctp_source</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">);</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SCTP_ADDR_NEW</span><span class="p">,</span>		<span class="cm">/* new address added to assoc/ep */</span>
	<span class="n">SCTP_ADDR_SRC</span><span class="p">,</span>		<span class="cm">/* address can be used as source */</span>
	<span class="n">SCTP_ADDR_DEL</span><span class="p">,</span>		<span class="cm">/* address about to be deleted */</span>
<span class="p">};</span>

<span class="cm">/* This is a structure for holding either an IPv6 or an IPv4 address.  */</span>
<span class="k">struct</span> <span class="n">sctp_sockaddr_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span>	<span class="n">rcu</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">valid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define SCTP_ADDRESS_TICK_DELAY	500</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="p">(</span><span class="n">sctp_packet_phandler_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* This structure holds lists of chunks as we are assembling for</span>
<span class="cm"> * transmission.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="p">{</span>
	<span class="cm">/* These are the SCTP header values (host order) for the packet. */</span>
	<span class="n">__u16</span> <span class="n">source_port</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">destination_port</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">vtag</span><span class="p">;</span>

	<span class="cm">/* This contains the payload chunks.  */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">chunk_list</span><span class="p">;</span>

	<span class="cm">/* This is the overhead of the sctp and ip headers. */</span>
	<span class="kt">size_t</span> <span class="n">overhead</span><span class="p">;</span>
	<span class="cm">/* This is the total size of all chunks INCLUDING padding.  */</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* The packet is destined for this transport address.</span>
<span class="cm">	 * The function we finally use to pass down to the next lower</span>
<span class="cm">	 * layer lives in the transport structure.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">;</span>

	<span class="cm">/* pointer to the auth chunk for this packet */</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">auth</span><span class="p">;</span>

	<span class="n">u8</span>  <span class="n">has_cookie_echo</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* This packet contains a COOKIE-ECHO chunk. */</span>
	    <span class="nl">has_sack:</span><span class="mi">1</span><span class="p">,</span>		<span class="cm">/* This packet contains a SACK chunk. */</span>
	    <span class="nl">has_auth:</span><span class="mi">1</span><span class="p">,</span>		<span class="cm">/* This packet contains an AUTH chunk */</span>
	    <span class="nl">has_data:</span><span class="mi">1</span><span class="p">,</span>		<span class="cm">/* This packet contains at least 1 DATA chunk */</span>
	    <span class="nl">ipfragok:</span><span class="mi">1</span><span class="p">,</span>		<span class="cm">/* So let ip fragment this packet */</span>
	    <span class="nl">malloced:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Is it malloced? */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">sctp_packet_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">,</span>
				     <span class="n">__u16</span> <span class="n">sport</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">dport</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">sctp_packet_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">vtag</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">sctp_xmit_t</span> <span class="n">sctp_packet_transmit_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="p">,</span>
                                       <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">sctp_xmit_t</span> <span class="n">sctp_packet_append_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="p">,</span>
                                     <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_packet_transmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_packet_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sctp_packet_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">overhead</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This represents a remote transport address.</span>
<span class="cm"> * For local transport addresses, we just use union sctp_addr.</span>
<span class="cm"> *</span>
<span class="cm"> * RFC2960 Section 1.4 Key Terms</span>
<span class="cm"> *</span>
<span class="cm"> *   o	Transport address:  A Transport Address is traditionally defined</span>
<span class="cm"> *	by Network Layer address, Transport Layer protocol and Transport</span>
<span class="cm"> *	Layer port number.  In the case of SCTP running over IP, a</span>
<span class="cm"> *	transport address is defined by the combination of an IP address</span>
<span class="cm"> *	and an SCTP port number (where SCTP is the Transport protocol).</span>
<span class="cm"> *</span>
<span class="cm"> * RFC2960 Section 7.1 SCTP Differences from TCP Congestion control</span>
<span class="cm"> *</span>
<span class="cm"> *   o	The sender keeps a separate congestion control parameter set for</span>
<span class="cm"> *	each of the destination addresses it can send to (not each</span>
<span class="cm"> *	source-destination pair but for each destination).  The parameters</span>
<span class="cm"> *	should decay if the address is not used for a long enough time</span>
<span class="cm"> *	period.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="p">{</span>
	<span class="cm">/* A list of transports. */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">transports</span><span class="p">;</span>

	<span class="cm">/* Reference counting. */</span>
	<span class="n">atomic_t</span> <span class="n">refcnt</span><span class="p">;</span>
	<span class="n">__u32</span>	 <span class="n">dead</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
		<span class="cm">/* RTO-Pending : A flag used to track if one of the DATA</span>
<span class="cm">		 *		chunks sent to this address is currently being</span>
<span class="cm">		 *		used to compute a RTT. If this flag is 0,</span>
<span class="cm">		 *		the next DATA chunk sent to this destination</span>
<span class="cm">		 *		should be used to compute a RTT and this flag</span>
<span class="cm">		 *		should be set. Every time the RTT</span>
<span class="cm">		 *		calculation completes (i.e. the DATA chunk</span>
<span class="cm">		 *		is SACK&#39;d) clear this flag.</span>
<span class="cm">		 */</span>
		 <span class="nl">rto_pending:</span><span class="mi">1</span><span class="p">,</span>

		<span class="cm">/*</span>
<span class="cm">		 * hb_sent : a flag that signals that we have a pending</span>
<span class="cm">		 * heartbeat.</span>
<span class="cm">		 */</span>
		<span class="nl">hb_sent:</span><span class="mi">1</span><span class="p">,</span>

		<span class="cm">/* Is the Path MTU update pending on this tranport */</span>
		<span class="nl">pmtu_pending:</span><span class="mi">1</span><span class="p">,</span>

		<span class="cm">/* Is this structure kfree()able? */</span>
		<span class="nl">malloced:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Has this transport moved the ctsn since we last sacked */</span>
	<span class="n">__u32</span> <span class="n">sack_generation</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">flowi</span> <span class="n">fl</span><span class="p">;</span>

	<span class="cm">/* This is the peer&#39;s IP address and port. */</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">ipaddr</span><span class="p">;</span>

	<span class="cm">/* These are the functions we call to handle LLP stuff.	 */</span>
	<span class="k">struct</span> <span class="n">sctp_af</span> <span class="o">*</span><span class="n">af_specific</span><span class="p">;</span>

	<span class="cm">/* Which association do we belong to?  */</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="cm">/* RFC2960</span>
<span class="cm">	 *</span>
<span class="cm">	 * 12.3 Per Transport Address Data</span>
<span class="cm">	 *</span>
<span class="cm">	 * For each destination transport address in the peer&#39;s</span>
<span class="cm">	 * address list derived from the INIT or INIT ACK chunk, a</span>
<span class="cm">	 * number of data elements needs to be maintained including:</span>
<span class="cm">	 */</span>
	<span class="cm">/* RTO	       : The current retransmission timeout value.  */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rto</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">rtt</span><span class="p">;</span>		<span class="cm">/* This is the most recent RTT.	 */</span>

	<span class="cm">/* RTTVAR      : The current RTT variation.  */</span>
	<span class="n">__u32</span> <span class="n">rttvar</span><span class="p">;</span>

	<span class="cm">/* SRTT	       : The current smoothed round trip time.	*/</span>
	<span class="n">__u32</span> <span class="n">srtt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * These are the congestion stats.</span>
<span class="cm">	 */</span>
	<span class="cm">/* cwnd	       : The current congestion window.	 */</span>
	<span class="n">__u32</span> <span class="n">cwnd</span><span class="p">;</span>		  <span class="cm">/* This is the actual cwnd.  */</span>

	<span class="cm">/* ssthresh    : The current slow start threshold value.  */</span>
	<span class="n">__u32</span> <span class="n">ssthresh</span><span class="p">;</span>

	<span class="cm">/* partial     : The tracking method for increase of cwnd when in</span>
<span class="cm">	 * bytes acked : congestion avoidance mode (see Section 6.2.2)</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">partial_bytes_acked</span><span class="p">;</span>

	<span class="cm">/* Data that has been sent, but not acknowledged. */</span>
	<span class="n">__u32</span> <span class="n">flight_size</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">burst_limited</span><span class="p">;</span>	<span class="cm">/* Holds old cwnd when max.burst is applied */</span>

	<span class="cm">/* Destination */</span>
	<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>
	<span class="cm">/* Source address. */</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">saddr</span><span class="p">;</span>

	<span class="cm">/* Heartbeat interval: The endpoint sends out a Heartbeat chunk to</span>
<span class="cm">	 * the destination address every heartbeat interval.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hbinterval</span><span class="p">;</span>

	<span class="cm">/* SACK delay timeout */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sackdelay</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sackfreq</span><span class="p">;</span>

	<span class="cm">/* When was the last time (in jiffies) that we heard from this</span>
<span class="cm">	 * transport?  We use this to pick new active and retran paths.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_time_heard</span><span class="p">;</span>

	<span class="cm">/* Last time(in jiffies) when cwnd is reduced due to the congestion</span>
<span class="cm">	 * indication based on ECNE chunk.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_time_ecne_reduced</span><span class="p">;</span>

	<span class="cm">/* This is the max_retrans value for the transport and will</span>
<span class="cm">	 * be initialized from the assocs value.  This can be changed</span>
<span class="cm">	 * using SCTP_SET_PEER_ADDR_PARAMS socket option.</span>
<span class="cm">	 */</span>
	<span class="n">__u16</span> <span class="n">pathmaxrxt</span><span class="p">;</span>

	<span class="cm">/* PMTU	      : The current known path MTU.  */</span>
	<span class="n">__u32</span> <span class="n">pathmtu</span><span class="p">;</span>

	<span class="cm">/* Flags controlling Heartbeat, SACK delay, and Path MTU Discovery. */</span>
	<span class="n">__u32</span> <span class="n">param_flags</span><span class="p">;</span>

	<span class="cm">/* The number of times INIT has been sent on this transport. */</span>
	<span class="kt">int</span> <span class="n">init_sent_count</span><span class="p">;</span>

	<span class="cm">/* state       : The current state of this destination,</span>
<span class="cm">	 *             : i.e. SCTP_ACTIVE, SCTP_INACTIVE, SCTP_UNKNOWN.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/* These are the error stats for this destination.  */</span>

	<span class="cm">/* Error count : The current error count for this destination.	*/</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">error_count</span><span class="p">;</span>

	<span class="cm">/* Per	       : A timer used by each destination.</span>
<span class="cm">	 * Destination :</span>
<span class="cm">	 * Timer       :</span>
<span class="cm">	 *</span>
<span class="cm">	 * [Everywhere else in the text this is called T3-rtx. -ed]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">T3_rtx_timer</span><span class="p">;</span>

	<span class="cm">/* Heartbeat timer is per destination. */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">hb_timer</span><span class="p">;</span>

	<span class="cm">/* Timer to handle ICMP proto unreachable envets */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">proto_unreach_timer</span><span class="p">;</span>

	<span class="cm">/* Since we&#39;re using per-destination retransmission timers</span>
<span class="cm">	 * (see above), we&#39;re also using per-destination &quot;transmitted&quot;</span>
<span class="cm">	 * queues.  This probably ought to be a private struct</span>
<span class="cm">	 * accessible only within the outqueue, but it&#39;s not, yet.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">transmitted</span><span class="p">;</span>

	<span class="cm">/* We build bundle-able packets for this transport here.  */</span>
	<span class="k">struct</span> <span class="n">sctp_packet</span> <span class="n">packet</span><span class="p">;</span>

	<span class="cm">/* This is the list of transports that have chunks to send.  */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">send_ready</span><span class="p">;</span>

	<span class="cm">/* State information saved for SFR_CACC algorithm. The key</span>
<span class="cm">	 * idea in SFR_CACC is to maintain state at the sender on a</span>
<span class="cm">	 * per-destination basis when a changeover happens.</span>
<span class="cm">	 *	char changeover_active;</span>
<span class="cm">	 *	char cycling_changeover;</span>
<span class="cm">	 *	__u32 next_tsn_at_change;</span>
<span class="cm">	 *	char cacc_saw_newack;</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* An unsigned integer, which stores the next TSN to be</span>
<span class="cm">		 * used by the sender, at the moment of changeover.</span>
<span class="cm">		 */</span>
		<span class="n">__u32</span> <span class="n">next_tsn_at_change</span><span class="p">;</span>

		<span class="cm">/* A flag which indicates the occurrence of a changeover */</span>
		<span class="kt">char</span> <span class="n">changeover_active</span><span class="p">;</span>

		<span class="cm">/* A flag which indicates whether the change of primary is</span>
<span class="cm">		 * the first switch to this destination address during an</span>
<span class="cm">		 * active switch.</span>
<span class="cm">		 */</span>
		<span class="kt">char</span> <span class="n">cycling_changeover</span><span class="p">;</span>

		<span class="cm">/* A temporary flag, which is used during the processing of</span>
<span class="cm">		 * a SACK to estimate the causative TSN(s)&#39;s group.</span>
<span class="cm">		 */</span>
		<span class="kt">char</span> <span class="n">cacc_saw_newack</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">cacc</span><span class="p">;</span>

	<span class="cm">/* 64-bit random number sent with heartbeat. */</span>
	<span class="n">__u64</span> <span class="n">hb_nonce</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">sctp_transport_new</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
					  <span class="n">gfp_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_transport_set_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_transport_route</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_transport_pmtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_transport_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_transport_reset_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_transport_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_transport_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_transport_update_rto</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">,</span> <span class="n">__u32</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_transport_raise_cwnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">,</span> <span class="n">__u32</span><span class="p">,</span> <span class="n">__u32</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_transport_lower_cwnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">,</span> <span class="n">sctp_lower_cwnd_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_transport_burst_limited</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_transport_burst_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sctp_transport_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_transport_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_transport_update_pmtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_transport_immediate_rtx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">);</span>


<span class="cm">/* This is the structure we use to queue packets as they come into</span>
<span class="cm"> * SCTP.  We write packets to it and read chunks from it.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_inq</span> <span class="p">{</span>
	<span class="cm">/* This is actually a queue of sctp_chunk each</span>
<span class="cm">	 * containing a partially decoded packet.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">in_chunk_list</span><span class="p">;</span>
	<span class="cm">/* This is the packet which is currently off the in queue and is</span>
<span class="cm">	 * being worked on through the inbound chunk processing.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">in_progress</span><span class="p">;</span>

	<span class="cm">/* This is the delayed task to finish delivering inbound</span>
<span class="cm">	 * messages.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">immediate</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">malloced</span><span class="p">;</span>	     <span class="cm">/* Is this structure kfree()able?	*/</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">sctp_inq_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_inq</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_inq_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_inq</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_inq_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_inq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">packet</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">sctp_inq_pop</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_inq</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sctp_chunkhdr</span> <span class="o">*</span><span class="n">sctp_inq_peek</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_inq</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_inq_set_th_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_inq</span> <span class="o">*</span><span class="p">,</span> <span class="n">work_func_t</span><span class="p">);</span>

<span class="cm">/* This is the structure we use to hold outbound chunks.  You push</span>
<span class="cm"> * chunks in and they automatically pop out the other end as bundled</span>
<span class="cm"> * packets (it calls (*output_handler)()).</span>
<span class="cm"> *</span>
<span class="cm"> * This structure covers sections 6.3, 6.4, 6.7, 6.8, 6.10, 7., 8.1,</span>
<span class="cm"> * and 8.2 of the v13 draft.</span>
<span class="cm"> *</span>
<span class="cm"> * It handles retransmissions.	The connection to the timeout portion</span>
<span class="cm"> * of the state machine is through sctp_..._timeout() and timeout_handler.</span>
<span class="cm"> *</span>
<span class="cm"> * If you feed it SACKs, it will eat them.</span>
<span class="cm"> *</span>
<span class="cm"> * If you give it big chunks, it will fragment them.</span>
<span class="cm"> *</span>
<span class="cm"> * It assigns TSN&#39;s to data chunks.  This happens at the last possible</span>
<span class="cm"> * instant before transmission.</span>
<span class="cm"> *</span>
<span class="cm"> * When free()&#39;d, it empties itself out via output_handler().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sctp_outq</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="cm">/* Data pending that has never been transmitted.  */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">out_chunk_list</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">out_qlen</span><span class="p">;</span>	<span class="cm">/* Total length of queued data chunks. */</span>

	<span class="cm">/* Error of send failed, may used in SCTP_SEND_FAILED event. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* These are control chunks we want to send.  */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">control_chunk_list</span><span class="p">;</span>

	<span class="cm">/* These are chunks that have been sacked but are above the</span>
<span class="cm">	 * CTSN, or cumulative tsn ack point.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">sacked</span><span class="p">;</span>

	<span class="cm">/* Put chunks on this list to schedule them for</span>
<span class="cm">	 * retransmission.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">retransmit</span><span class="p">;</span>

	<span class="cm">/* Put chunks on this list to save them for FWD TSN processing as</span>
<span class="cm">	 * they were abandoned.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">abandoned</span><span class="p">;</span>

	<span class="cm">/* How many unackd bytes do we have in-flight?	*/</span>
	<span class="n">__u32</span> <span class="n">outstanding_bytes</span><span class="p">;</span>

	<span class="cm">/* Are we doing fast-rtx on this queue */</span>
	<span class="kt">char</span> <span class="n">fast_rtx</span><span class="p">;</span>

	<span class="cm">/* Corked? */</span>
	<span class="kt">char</span> <span class="n">cork</span><span class="p">;</span>

	<span class="cm">/* Is this structure empty?  */</span>
	<span class="kt">char</span> <span class="n">empty</span><span class="p">;</span>

	<span class="cm">/* Are we kfree()able? */</span>
	<span class="kt">char</span> <span class="n">malloced</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">sctp_outq_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_outq_teardown</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_outq_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span><span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_outq_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_outq_sack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_sackhdr</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_outq_is_empty</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_outq_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">sctp_retransmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">,</span>
		     <span class="n">sctp_retransmit_reason_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_retransmit_mark</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">,</span> <span class="n">__u8</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_outq_uncork</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="p">);</span>
<span class="cm">/* Uncork and flush an outqueue.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sctp_outq_cork</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_outq</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">cork</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* These bind address data fields common between endpoints and associations */</span>
<span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="p">{</span>

	<span class="cm">/* RFC 2960 12.1 Parameters necessary for the SCTP instance</span>
<span class="cm">	 *</span>
<span class="cm">	 * SCTP Port:	The local SCTP port number the endpoint is</span>
<span class="cm">	 *		bound to.</span>
<span class="cm">	 */</span>
	<span class="n">__u16</span> <span class="n">port</span><span class="p">;</span>

	<span class="cm">/* RFC 2960 12.1 Parameters necessary for the SCTP instance</span>
<span class="cm">	 *</span>
<span class="cm">	 * Address List: The list of IP addresses that this instance</span>
<span class="cm">	 *	has bound.  This information is passed to one&#39;s</span>
<span class="cm">	 *	peer(s) in INIT and INIT ACK chunks.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">address_list</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">malloced</span><span class="p">;</span>	     <span class="cm">/* Are we kfree()able?  */</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">sctp_bind_addr_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">port</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_bind_addr_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_bind_addr_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
			<span class="n">sctp_scope_t</span> <span class="n">scope</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_bind_addr_dup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
			<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_add_bind_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
		       <span class="n">__u8</span> <span class="n">addr_state</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_del_bind_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="p">,</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_bind_addr_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_bind_addr_conflict</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_sock</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_bind_addr_state</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">sctp_find_unmatch_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_addr</span>	<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span>	<span class="o">*</span><span class="n">addrs</span><span class="p">,</span>
					<span class="kt">int</span>			<span class="n">addrcnt</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sctp_sock</span>	<span class="o">*</span><span class="n">opt</span><span class="p">);</span>
<span class="k">union</span> <span class="n">sctp_params</span> <span class="n">sctp_bind_addrs_to_raw</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="o">*</span><span class="n">addrs_len</span><span class="p">,</span>
					 <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_raw_to_bind_addrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">raw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			   <span class="n">__u16</span> <span class="n">port</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="n">sctp_scope_t</span> <span class="n">sctp_scope</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_in_scope</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="n">sctp_scope_t</span> <span class="n">scope</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_is_any</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_addr_is_valid</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_is_ep_boundall</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>


<span class="cm">/* What type of endpoint?  */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">SCTP_EP_TYPE_SOCKET</span><span class="p">,</span>
	<span class="n">SCTP_EP_TYPE_ASSOCIATION</span><span class="p">,</span>
<span class="p">}</span> <span class="n">sctp_endpoint_type_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * A common base class to bridge the implmentation view of a</span>
<span class="cm"> * socket (usually listening) endpoint versus an association&#39;s</span>
<span class="cm"> * local endpoint.</span>
<span class="cm"> * This common structure is useful for several purposes:</span>
<span class="cm"> *   1) Common interface for lookup routines.</span>
<span class="cm"> *	a) Subfunctions work for either endpoint or association</span>
<span class="cm"> *	b) Single interface to lookup allows hiding the lookup lock rather</span>
<span class="cm"> *	   than acquiring it externally.</span>
<span class="cm"> *   2) Common interface for the inbound chunk handling/state machine.</span>
<span class="cm"> *   3) Common object handling routines for reference counting, etc.</span>
<span class="cm"> *   4) Disentangle association lookup from endpoint lookup, where we</span>
<span class="cm"> *	do not have to find our endpoint to find our association.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sctp_ep_common</span> <span class="p">{</span>
	<span class="cm">/* Fields to help us manage our entries in the hash tables. */</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hashent</span><span class="p">;</span>

	<span class="cm">/* Runtime type information.  What kind of endpoint is this? */</span>
	<span class="n">sctp_endpoint_type_t</span> <span class="n">type</span><span class="p">;</span>

	<span class="cm">/* Some fields to help us manage this object.</span>
<span class="cm">	 *   refcnt   - Reference count access to this object.</span>
<span class="cm">	 *   dead     - Do not attempt to use this object.</span>
<span class="cm">	 *   malloced - Do we need to kfree this object?</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span>    <span class="n">refcnt</span><span class="p">;</span>
	<span class="kt">char</span>	    <span class="n">dead</span><span class="p">;</span>
	<span class="kt">char</span>	    <span class="n">malloced</span><span class="p">;</span>

	<span class="cm">/* What socket does this endpoint belong to?  */</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="cm">/* This is where we receive inbound chunks.  */</span>
	<span class="k">struct</span> <span class="n">sctp_inq</span>	  <span class="n">inqueue</span><span class="p">;</span>

	<span class="cm">/* This substructure includes the defining parameters of the</span>
<span class="cm">	 * endpoint:</span>
<span class="cm">	 * bind_addr.port is our shared port number.</span>
<span class="cm">	 * bind_addr.address_list is our set of local IP addresses.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sctp_bind_addr</span> <span class="n">bind_addr</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* RFC Section 1.4 Key Terms</span>
<span class="cm"> *</span>
<span class="cm"> * o SCTP endpoint: The logical sender/receiver of SCTP packets. On a</span>
<span class="cm"> *   multi-homed host, an SCTP endpoint is represented to its peers as a</span>
<span class="cm"> *   combination of a set of eligible destination transport addresses to</span>
<span class="cm"> *   which SCTP packets can be sent and a set of eligible source</span>
<span class="cm"> *   transport addresses from which SCTP packets can be received.</span>
<span class="cm"> *   All transport addresses used by an SCTP endpoint must use the</span>
<span class="cm"> *   same port number, but can use multiple IP addresses. A transport</span>
<span class="cm"> *   address used by an SCTP endpoint must not be used by another</span>
<span class="cm"> *   SCTP endpoint. In other words, a transport address is unique</span>
<span class="cm"> *   to an SCTP endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * From an implementation perspective, each socket has one of these.</span>
<span class="cm"> * A TCP-style socket will have exactly one association on one of</span>
<span class="cm"> * these.  An UDP-style socket will have multiple associations hanging</span>
<span class="cm"> * off one of these.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="p">{</span>
	<span class="cm">/* Common substructure for endpoint and association. */</span>
	<span class="k">struct</span> <span class="n">sctp_ep_common</span> <span class="n">base</span><span class="p">;</span>

	<span class="cm">/* Associations: A list of current associations and mappings</span>
<span class="cm">	 *	      to the data consumers for each association. This</span>
<span class="cm">	 *	      may be in the form of a hash table or other</span>
<span class="cm">	 *	      implementation dependent structure. The data</span>
<span class="cm">	 *	      consumers may be process identification</span>
<span class="cm">	 *	      information such as file descriptors, named pipe</span>
<span class="cm">	 *	      pointer, or table pointers dependent on how SCTP</span>
<span class="cm">	 *	      is implemented.</span>
<span class="cm">	 */</span>
	<span class="cm">/* This is really a list of struct sctp_association entries. */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">asocs</span><span class="p">;</span>

	<span class="cm">/* Secret Key: A secret key used by this endpoint to compute</span>
<span class="cm">	 *	      the MAC.	This SHOULD be a cryptographic quality</span>
<span class="cm">	 *	      random number with a sufficient length.</span>
<span class="cm">	 *	      Discussion in [RFC1750] can be helpful in</span>
<span class="cm">	 *	      selection of the key.</span>
<span class="cm">	 */</span>
	<span class="n">__u8</span> <span class="n">secret_key</span><span class="p">[</span><span class="n">SCTP_HOW_MANY_SECRETS</span><span class="p">][</span><span class="n">SCTP_SECRET_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">current_key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">key_changed_at</span><span class="p">;</span>

 	<span class="cm">/* digest:  This is a digest of the sctp cookie.  This field is</span>
<span class="cm"> 	 * 	    only used on the receive path when we try to validate</span>
<span class="cm"> 	 * 	    that the cookie has not been tampered with.  We put</span>
<span class="cm"> 	 * 	    this here so we pre-allocate this once and can re-use</span>
<span class="cm"> 	 * 	    on every receive.</span>
<span class="cm"> 	 */</span>
 	<span class="n">__u8</span> <span class="o">*</span><span class="n">digest</span><span class="p">;</span>
 
	<span class="cm">/* sendbuf acct. policy.	*/</span>
	<span class="n">__u32</span> <span class="n">sndbuf_policy</span><span class="p">;</span>

	<span class="cm">/* rcvbuf acct. policy.	*/</span>
	<span class="n">__u32</span> <span class="n">rcvbuf_policy</span><span class="p">;</span>

	<span class="cm">/* SCTP AUTH: array of the HMACs that will be allocated</span>
<span class="cm">	 * we need this per association so that we don&#39;t serialize</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">crypto_hash</span> <span class="o">**</span><span class="n">auth_hmacs</span><span class="p">;</span>

	<span class="cm">/* SCTP-AUTH: hmacs for the endpoint encoded into parameter */</span>
	 <span class="k">struct</span> <span class="n">sctp_hmac_algo_param</span> <span class="o">*</span><span class="n">auth_hmacs_list</span><span class="p">;</span>

	<span class="cm">/* SCTP-AUTH: chunks to authenticate encoded into parameter */</span>
	<span class="k">struct</span> <span class="n">sctp_chunks_param</span> <span class="o">*</span><span class="n">auth_chunk_list</span><span class="p">;</span>

	<span class="cm">/* SCTP-AUTH: endpoint shared keys */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">endpoint_shared_keys</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">active_key_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Recover the outter endpoint structure. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="nf">sctp_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ep_common</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ep</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* These are function signatures for manipulating endpoints.  */</span>
<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">sctp_endpoint_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_endpoint_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_endpoint_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_endpoint_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_endpoint_add_asoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">sctp_endpoint_lookup_assoc</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">paddr</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">**</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_endpoint_is_peeled_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">sctp_endpoint_is_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_has_association</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">paddr</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">sctp_verify_init</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span> <span class="n">sctp_cid_t</span><span class="p">,</span>
		     <span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="n">peer_init</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">**</span><span class="n">err_chunk</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_process_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">peer</span><span class="p">,</span>
		      <span class="n">sctp_init_chunk_t</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="n">__u32</span> <span class="n">sctp_generate_tag</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="p">);</span>
<span class="n">__u32</span> <span class="n">sctp_generate_tsn</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">sctp_inithdr_host</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">init_tag</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">a_rwnd</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">num_outbound_streams</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">num_inbound_streams</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">initial_tsn</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* RFC2960</span>
<span class="cm"> *</span>
<span class="cm"> * 12. Recommended Transmission Control Block (TCB) Parameters</span>
<span class="cm"> *</span>
<span class="cm"> * This section details a recommended set of parameters that should</span>
<span class="cm"> * be contained within the TCB for an implementation. This section is</span>
<span class="cm"> * for illustrative purposes and should not be deemed as requirements</span>
<span class="cm"> * on an implementation or as an exhaustive list of all parameters</span>
<span class="cm"> * inside an SCTP TCB. Each implementation may need its own additional</span>
<span class="cm"> * parameters for optimization.</span>
<span class="cm"> */</span>


<span class="cm">/* Here we have information about each individual association. */</span>
<span class="k">struct</span> <span class="n">sctp_association</span> <span class="p">{</span>

	<span class="cm">/* A base structure common to endpoint and association.</span>
<span class="cm">	 * In this context, it represents the associations&#39;s view</span>
<span class="cm">	 * of the local endpoint of the association.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sctp_ep_common</span> <span class="n">base</span><span class="p">;</span>

	<span class="cm">/* Associations on the same socket. */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">asocs</span><span class="p">;</span>

	<span class="cm">/* association id. */</span>
	<span class="n">sctp_assoc_t</span> <span class="n">assoc_id</span><span class="p">;</span>

	<span class="cm">/* This is our parent endpoint.	 */</span>
	<span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="cm">/* These are those association elements needed in the cookie.  */</span>
	<span class="k">struct</span> <span class="n">sctp_cookie</span> <span class="n">c</span><span class="p">;</span>

	<span class="cm">/* This is all information about our peer.  */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* rwnd</span>
<span class="cm">		 *</span>
<span class="cm">		 * Peer Rwnd   : Current calculated value of the peer&#39;s rwnd.</span>
<span class="cm">		 */</span>
		<span class="n">__u32</span> <span class="n">rwnd</span><span class="p">;</span>

		<span class="cm">/* transport_addr_list</span>
<span class="cm">		 *</span>
<span class="cm">		 * Peer	       : A list of SCTP transport addresses that the</span>
<span class="cm">		 * Transport   : peer is bound to. This information is derived</span>
<span class="cm">		 * Address     : from the INIT or INIT ACK and is used to</span>
<span class="cm">		 * List	       : associate an inbound packet with a given</span>
<span class="cm">		 *	       : association. Normally this information is</span>
<span class="cm">		 *	       : hashed or keyed for quick lookup and access</span>
<span class="cm">		 *	       : of the TCB.</span>
<span class="cm">		 *	       : The list is also initialized with the list</span>
<span class="cm">		 *	       : of addresses passed with the sctp_connectx()</span>
<span class="cm">		 *	       : call.</span>
<span class="cm">		 *</span>
<span class="cm">		 * It is a list of SCTP_transport&#39;s.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="n">transport_addr_list</span><span class="p">;</span>

		<span class="cm">/* transport_count</span>
<span class="cm">		 *</span>
<span class="cm">		 * Peer        : A count of the number of peer addresses</span>
<span class="cm">		 * Transport   : in the Peer Transport Address List.</span>
<span class="cm">		 * Address     :</span>
<span class="cm">		 * Count       :</span>
<span class="cm">		 */</span>
		<span class="n">__u16</span> <span class="n">transport_count</span><span class="p">;</span>

		<span class="cm">/* port</span>
<span class="cm">		 *   The transport layer port number.</span>
<span class="cm">		 */</span>
		<span class="n">__u16</span> <span class="n">port</span><span class="p">;</span>

		<span class="cm">/* primary_path</span>
<span class="cm">		 *</span>
<span class="cm">		 * Primary     : This is the current primary destination</span>
<span class="cm">		 * Path	       : transport address of the peer endpoint.  It</span>
<span class="cm">		 *	       : may also specify a source transport address</span>
<span class="cm">		 *	       : on this endpoint.</span>
<span class="cm">		 *</span>
<span class="cm">		 * All of these paths live on transport_addr_list.</span>
<span class="cm">		 *</span>
<span class="cm">		 * At the bakeoffs, we discovered that the intent of</span>
<span class="cm">		 * primaryPath is that it only changes when the ULP</span>
<span class="cm">		 * asks to have it changed.  We add the activePath to</span>
<span class="cm">		 * designate the connection we are currently using to</span>
<span class="cm">		 * transmit new data and most control chunks.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">primary_path</span><span class="p">;</span>

		<span class="cm">/* Cache the primary path address here, when we</span>
<span class="cm">		 * need a an address for msg_name.</span>
<span class="cm">		 */</span>
		<span class="k">union</span> <span class="n">sctp_addr</span> <span class="n">primary_addr</span><span class="p">;</span>

		<span class="cm">/* active_path</span>
<span class="cm">		 *   The path that we are currently using to</span>
<span class="cm">		 *   transmit new data and most control chunks.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">active_path</span><span class="p">;</span>

		<span class="cm">/* retran_path</span>
<span class="cm">		 *</span>
<span class="cm">		 * RFC2960 6.4 Multi-homed SCTP Endpoints</span>
<span class="cm">		 * ...</span>
<span class="cm">		 * Furthermore, when its peer is multi-homed, an</span>
<span class="cm">		 * endpoint SHOULD try to retransmit a chunk to an</span>
<span class="cm">		 * active destination transport address that is</span>
<span class="cm">		 * different from the last destination address to</span>
<span class="cm">		 * which the DATA chunk was sent.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">retran_path</span><span class="p">;</span>

		<span class="cm">/* Pointer to last transport I have sent on.  */</span>
		<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">last_sent_to</span><span class="p">;</span>

		<span class="cm">/* This is the last transport I have received DATA on.	*/</span>
		<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">last_data_from</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Mapping  An array of bits or bytes indicating which out of</span>
<span class="cm">		 * Array    order TSN&#39;s have been received (relative to the</span>
<span class="cm">		 *	    Last Rcvd TSN). If no gaps exist, i.e. no out of</span>
<span class="cm">		 *	    order packets have been received, this array</span>
<span class="cm">		 *	    will be set to all zero. This structure may be</span>
<span class="cm">		 *	    in the form of a circular buffer or bit array.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Last Rcvd   : This is the last TSN received in</span>
<span class="cm">		 * TSN	       : sequence. This value is set initially by</span>
<span class="cm">		 *	       : taking the peer&#39;s Initial TSN, received in</span>
<span class="cm">		 *	       : the INIT or INIT ACK chunk, and subtracting</span>
<span class="cm">		 *	       : one from it.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Throughout most of the specification this is called the</span>
<span class="cm">		 * &quot;Cumulative TSN ACK Point&quot;.	In this case, we</span>
<span class="cm">		 * ignore the advice in 12.2 in favour of the term</span>
<span class="cm">		 * used in the bulk of the text.  This value is hidden</span>
<span class="cm">		 * in tsn_map--we get it by calling sctp_tsnmap_get_ctsn().</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">sctp_tsnmap</span> <span class="n">tsn_map</span><span class="p">;</span>

		<span class="cm">/* Ack State   : This flag indicates if the next received</span>
<span class="cm">		 *             : packet is to be responded to with a</span>
<span class="cm">		 *             : SACK. This is initializedto 0.  When a packet</span>
<span class="cm">		 *             : is received it is incremented. If this value</span>
<span class="cm">		 *             : reaches 2 or more, a SACK is sent and the</span>
<span class="cm">		 *             : value is reset to 0. Note: This is used only</span>
<span class="cm">		 *             : when no DATA chunks are received out of</span>
<span class="cm">		 *             : order.  When DATA chunks are out of order,</span>
<span class="cm">		 *             : SACK&#39;s are not delayed (see Section 6).</span>
<span class="cm">		 */</span>
		<span class="n">__u8</span>    <span class="n">sack_needed</span><span class="p">;</span>     <span class="cm">/* Do we need to sack the peer? */</span>
		<span class="n">__u32</span>	<span class="n">sack_cnt</span><span class="p">;</span>
		<span class="n">__u32</span>	<span class="n">sack_generation</span><span class="p">;</span>

		<span class="cm">/* These are capabilities which our peer advertised.  */</span>
		<span class="n">__u8</span>	<span class="n">ecn_capable</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>	    <span class="cm">/* Can peer do ECN? */</span>
			<span class="nl">ipv4_address:</span><span class="mi">1</span><span class="p">,</span>	    <span class="cm">/* Peer understands IPv4 addresses? */</span>
			<span class="nl">ipv6_address:</span><span class="mi">1</span><span class="p">,</span>	    <span class="cm">/* Peer understands IPv6 addresses? */</span>
			<span class="nl">hostname_address:</span><span class="mi">1</span><span class="p">,</span> <span class="cm">/* Peer understands DNS addresses? */</span>
			<span class="nl">asconf_capable:</span><span class="mi">1</span><span class="p">,</span>   <span class="cm">/* Does peer support ADDIP? */</span>
			<span class="nl">prsctp_capable:</span><span class="mi">1</span><span class="p">,</span>   <span class="cm">/* Can peer do PR-SCTP? */</span>
			<span class="nl">auth_capable:</span><span class="mi">1</span><span class="p">;</span>	    <span class="cm">/* Is peer doing SCTP-AUTH? */</span>

		<span class="n">__u32</span>   <span class="n">adaptation_ind</span><span class="p">;</span>	 <span class="cm">/* Adaptation Code point. */</span>

		<span class="cm">/* This mask is used to disable sending the ASCONF chunk</span>
<span class="cm">		 * with specified parameter to peer.</span>
<span class="cm">		 */</span>
		<span class="n">__be16</span> <span class="n">addip_disabled_mask</span><span class="p">;</span>

		<span class="k">struct</span> <span class="n">sctp_inithdr_host</span> <span class="n">i</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">cookie_len</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">;</span>

		<span class="cm">/* ADDIP Section 4.2 Upon reception of an ASCONF Chunk.</span>
<span class="cm">		 * C1) ... &quot;Peer-Serial-Number&#39;. This value MUST be initialized to the</span>
<span class="cm">		 * Initial TSN Value minus 1</span>
<span class="cm">		 */</span>
		<span class="n">__u32</span> <span class="n">addip_serial</span><span class="p">;</span>

		<span class="cm">/* SCTP-AUTH: We need to know pears random number, hmac list</span>
<span class="cm">		 * and authenticated chunk list.  All that is part of the</span>
<span class="cm">		 * cookie and these are just pointers to those locations</span>
<span class="cm">		 */</span>
		<span class="n">sctp_random_param_t</span> <span class="o">*</span><span class="n">peer_random</span><span class="p">;</span>
		<span class="n">sctp_chunks_param_t</span> <span class="o">*</span><span class="n">peer_chunks</span><span class="p">;</span>
		<span class="n">sctp_hmac_algo_param_t</span> <span class="o">*</span><span class="n">peer_hmacs</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">peer</span><span class="p">;</span>

	<span class="cm">/* State       : A state variable indicating what state the</span>
<span class="cm">	 *	       : association is in, i.e. COOKIE-WAIT,</span>
<span class="cm">	 *	       : COOKIE-ECHOED, ESTABLISHED, SHUTDOWN-PENDING,</span>
<span class="cm">	 *	       : SHUTDOWN-SENT, SHUTDOWN-RECEIVED, SHUTDOWN-ACK-SENT.</span>
<span class="cm">	 *</span>
<span class="cm">	 *		Note: No &quot;CLOSED&quot; state is illustrated since if a</span>
<span class="cm">	 *		association is &quot;CLOSED&quot; its TCB SHOULD be removed.</span>
<span class="cm">	 *</span>
<span class="cm">	 *		In this implementation we DO have a CLOSED</span>
<span class="cm">	 *		state which is used during initiation and shutdown.</span>
<span class="cm">	 *</span>
<span class="cm">	 *		State takes values from SCTP_STATE_*.</span>
<span class="cm">	 */</span>
	<span class="n">sctp_state_t</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/* The cookie life I award for any cookie.  */</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">cookie_life</span><span class="p">;</span>

	<span class="cm">/* Overall     : The overall association error count.</span>
<span class="cm">	 * Error Count : [Clear this any time I get something.]</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">overall_error_count</span><span class="p">;</span>

	<span class="cm">/* These are the association&#39;s initial, max, and min RTO values.</span>
<span class="cm">	 * These values will be initialized by system defaults, but can</span>
<span class="cm">	 * be modified via the SCTP_RTOINFO socket option.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rto_initial</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rto_max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rto_min</span><span class="p">;</span>

	<span class="cm">/* Maximum number of new data packets that can be sent in a burst.  */</span>
	<span class="kt">int</span> <span class="n">max_burst</span><span class="p">;</span>

	<span class="cm">/* This is the max_retrans value for the association.  This value will</span>
<span class="cm">	 * be initialized initialized from system defaults, but can be</span>
<span class="cm">	 * modified by the SCTP_ASSOCINFO socket option.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">max_retrans</span><span class="p">;</span>

	<span class="cm">/* Maximum number of times the endpoint will retransmit INIT  */</span>
	<span class="n">__u16</span> <span class="n">max_init_attempts</span><span class="p">;</span>

	<span class="cm">/* How many times have we resent an INIT? */</span>
	<span class="n">__u16</span> <span class="n">init_retries</span><span class="p">;</span>

	<span class="cm">/* The largest timeout or RTO value to use in attempting an INIT */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_init_timeo</span><span class="p">;</span>

	<span class="cm">/* Heartbeat interval: The endpoint sends out a Heartbeat chunk to</span>
<span class="cm">	 * the destination address every heartbeat interval. This value</span>
<span class="cm">	 * will be inherited by all new transports.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hbinterval</span><span class="p">;</span>

	<span class="cm">/* This is the max_retrans value for new transports in the</span>
<span class="cm">	 * association.</span>
<span class="cm">	 */</span>
	<span class="n">__u16</span> <span class="n">pathmaxrxt</span><span class="p">;</span>

	<span class="cm">/* Flag that path mtu update is pending */</span>
	<span class="n">__u8</span>   <span class="n">pmtu_pending</span><span class="p">;</span>

	<span class="cm">/* Association : The smallest PMTU discovered for all of the</span>
<span class="cm">	 * PMTU	       : peer&#39;s transport addresses.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">pathmtu</span><span class="p">;</span>

	<span class="cm">/* Flags controlling Heartbeat, SACK delay, and Path MTU Discovery. */</span>
	<span class="n">__u32</span> <span class="n">param_flags</span><span class="p">;</span>

	<span class="cm">/* SACK delay timeout */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sackdelay</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sackfreq</span><span class="p">;</span>


	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeouts</span><span class="p">[</span><span class="n">SCTP_NUM_TIMEOUT_TYPES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timers</span><span class="p">[</span><span class="n">SCTP_NUM_TIMEOUT_TYPES</span><span class="p">];</span>

	<span class="cm">/* Transport to which SHUTDOWN chunk was last sent.  */</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">shutdown_last_sent_to</span><span class="p">;</span>

	<span class="cm">/* How many times have we resent a SHUTDOWN */</span>
	<span class="kt">int</span> <span class="n">shutdown_retries</span><span class="p">;</span>

	<span class="cm">/* Transport to which INIT chunk was last sent.  */</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">init_last_sent_to</span><span class="p">;</span>

	<span class="cm">/* Next TSN    : The next TSN number to be assigned to a new</span>
<span class="cm">	 *	       : DATA chunk.  This is sent in the INIT or INIT</span>
<span class="cm">	 *	       : ACK chunk to the peer and incremented each</span>
<span class="cm">	 *	       : time a DATA chunk is assigned a TSN</span>
<span class="cm">	 *	       : (normally just prior to transmit or during</span>
<span class="cm">	 *	       : fragmentation).</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">next_tsn</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Last Rcvd   : This is the last TSN received in sequence.  This value</span>
<span class="cm">	 * TSN	       : is set initially by taking the peer&#39;s Initial TSN,</span>
<span class="cm">	 *	       : received in the INIT or INIT ACK chunk, and</span>
<span class="cm">	 *	       : subtracting one from it.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Most of RFC 2960 refers to this as the Cumulative TSN Ack Point.</span>
<span class="cm">	 */</span>

	<span class="n">__u32</span> <span class="n">ctsn_ack_point</span><span class="p">;</span>

	<span class="cm">/* PR-SCTP Advanced.Peer.Ack.Point */</span>
	<span class="n">__u32</span> <span class="n">adv_peer_ack_point</span><span class="p">;</span>

	<span class="cm">/* Highest TSN that is acknowledged by incoming SACKs. */</span>
	<span class="n">__u32</span> <span class="n">highest_sacked</span><span class="p">;</span>

	<span class="cm">/* TSN marking the fast recovery exit point */</span>
	<span class="n">__u32</span> <span class="n">fast_recovery_exit</span><span class="p">;</span>

	<span class="cm">/* Flag to track the current fast recovery state */</span>
	<span class="n">__u8</span> <span class="n">fast_recovery</span><span class="p">;</span>

	<span class="cm">/* The number of unacknowledged data chunks.  Reported through</span>
<span class="cm">	 * the SCTP_STATUS sockopt.</span>
<span class="cm">	 */</span>
	<span class="n">__u16</span> <span class="n">unack_data</span><span class="p">;</span>

	<span class="cm">/* The total number of data chunks that we&#39;ve had to retransmit</span>
<span class="cm">	 * as the result of a T3 timer expiration</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">rtx_data_chunks</span><span class="p">;</span>

	<span class="cm">/* This is the association&#39;s receive buffer space.  This value is used</span>
<span class="cm">	 * to set a_rwnd field in an INIT or a SACK chunk.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">rwnd</span><span class="p">;</span>

	<span class="cm">/* This is the last advertised value of rwnd over a SACK chunk. */</span>
	<span class="n">__u32</span> <span class="n">a_rwnd</span><span class="p">;</span>

	<span class="cm">/* Number of bytes by which the rwnd has slopped.  The rwnd is allowed</span>
<span class="cm">	 * to slop over a maximum of the association&#39;s frag_point.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">rwnd_over</span><span class="p">;</span>

	<span class="cm">/* Keeps treack of rwnd pressure.  This happens when we have</span>
<span class="cm">	 * a window, but not recevie buffer (i.e small packets).  This one</span>
<span class="cm">	 * is releases slowly (1 PMTU at a time ).</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">rwnd_press</span><span class="p">;</span>

	<span class="cm">/* This is the sndbuf size in use for the association.</span>
<span class="cm">	 * This corresponds to the sndbuf size for the association,</span>
<span class="cm">	 * as specified in the sk-&gt;sndbuf.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">sndbuf_used</span><span class="p">;</span>

	<span class="cm">/* This is the amount of memory that this association has allocated</span>
<span class="cm">	 * in the receive path at any given time.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span> <span class="n">rmem_alloc</span><span class="p">;</span>

	<span class="cm">/* This is the wait queue head for send requests waiting on</span>
<span class="cm">	 * the association sndbuf space.</span>
<span class="cm">	 */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">wait</span><span class="p">;</span>

	<span class="cm">/* The message size at which SCTP fragmentation will occur. */</span>
	<span class="n">__u32</span> <span class="n">frag_point</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">user_frag</span><span class="p">;</span>

	<span class="cm">/* Counter used to count INIT errors. */</span>
	<span class="kt">int</span> <span class="n">init_err_counter</span><span class="p">;</span>

	<span class="cm">/* Count the number of INIT cycles (for doubling timeout). */</span>
	<span class="kt">int</span> <span class="n">init_cycle</span><span class="p">;</span>

	<span class="cm">/* Default send parameters. */</span>
	<span class="n">__u16</span> <span class="n">default_stream</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">default_flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">default_ppid</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">default_context</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">default_timetolive</span><span class="p">;</span>

	<span class="cm">/* Default receive parameters */</span>
	<span class="n">__u32</span> <span class="n">default_rcv_context</span><span class="p">;</span>

	<span class="cm">/* This tracks outbound ssn for a given stream.	 */</span>
	<span class="k">struct</span> <span class="n">sctp_ssnmap</span> <span class="o">*</span><span class="n">ssnmap</span><span class="p">;</span>

	<span class="cm">/* All outbound chunks go through this structure.  */</span>
	<span class="k">struct</span> <span class="n">sctp_outq</span> <span class="n">outqueue</span><span class="p">;</span>

	<span class="cm">/* A smart pipe that will handle reordering and fragmentation,</span>
<span class="cm">	 * as well as handle passing events up to the ULP.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sctp_ulpq</span> <span class="n">ulpq</span><span class="p">;</span>

	<span class="cm">/* Last TSN that caused an ECNE Chunk to be sent.  */</span>
	<span class="n">__u32</span> <span class="n">last_ecne_tsn</span><span class="p">;</span>

	<span class="cm">/* Last TSN that caused a CWR Chunk to be sent.	 */</span>
	<span class="n">__u32</span> <span class="n">last_cwr_tsn</span><span class="p">;</span>

	<span class="cm">/* How many duplicated TSNs have we seen?  */</span>
	<span class="kt">int</span> <span class="n">numduptsns</span><span class="p">;</span>

	<span class="cm">/* Number of seconds of idle time before an association is closed.</span>
<span class="cm">	 * In the association context, this is really used as a boolean</span>
<span class="cm">	 * since the real timeout is stored in the timeouts array</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">autoclose</span><span class="p">;</span>

	<span class="cm">/* These are to support</span>
<span class="cm">	 * &quot;SCTP Extensions for Dynamic Reconfiguration of IP Addresses</span>
<span class="cm">	 *  and Enforcement of Flow and Message Limits&quot;</span>
<span class="cm">	 * &lt;draft-ietf-tsvwg-addip-sctp-02.txt&gt;</span>
<span class="cm">	 * or &quot;ADDIP&quot; for short.</span>
<span class="cm">	 */</span>



	<span class="cm">/* ADDIP Section 4.1.1 Congestion Control of ASCONF Chunks</span>
<span class="cm">	 *</span>
<span class="cm">	 * R1) One and only one ASCONF Chunk MAY be in transit and</span>
<span class="cm">	 * unacknowledged at any one time.  If a sender, after sending</span>
<span class="cm">	 * an ASCONF chunk, decides it needs to transfer another</span>
<span class="cm">	 * ASCONF Chunk, it MUST wait until the ASCONF-ACK Chunk</span>
<span class="cm">	 * returns from the previous ASCONF Chunk before sending a</span>
<span class="cm">	 * subsequent ASCONF. Note this restriction binds each side,</span>
<span class="cm">	 * so at any time two ASCONF may be in-transit on any given</span>
<span class="cm">	 * association (one sent from each endpoint).</span>
<span class="cm">	 *</span>
<span class="cm">	 * [This is our one-and-only-one ASCONF in flight.  If we do</span>
<span class="cm">	 * not have an ASCONF in flight, this is NULL.]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">addip_last_asconf</span><span class="p">;</span>

	<span class="cm">/* ADDIP Section 5.2 Upon reception of an ASCONF Chunk.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is needed to implement itmes E1 - E4 of the updated</span>
<span class="cm">	 * spec.  Here is the justification:</span>
<span class="cm">	 *</span>
<span class="cm">	 * Since the peer may bundle multiple ASCONF chunks toward us,</span>
<span class="cm">	 * we now need the ability to cache multiple ACKs.  The section</span>
<span class="cm">	 * describes in detail how they are cached and cleaned up.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">asconf_ack_list</span><span class="p">;</span>

	<span class="cm">/* These ASCONF chunks are waiting to be sent.</span>
<span class="cm">	 *</span>
<span class="cm">	 * These chunaks can&#39;t be pushed to outqueue until receiving</span>
<span class="cm">	 * ASCONF_ACK for the previous ASCONF indicated by</span>
<span class="cm">	 * addip_last_asconf, so as to guarantee that only one ASCONF</span>
<span class="cm">	 * is in flight at any time.</span>
<span class="cm">	 *</span>
<span class="cm">	 * ADDIP Section 4.1.1 Congestion Control of ASCONF Chunks</span>
<span class="cm">	 *</span>
<span class="cm">	 * In defining the ASCONF Chunk transfer procedures, it is</span>
<span class="cm">	 * essential that these transfers MUST NOT cause congestion</span>
<span class="cm">	 * within the network.	To achieve this, we place these</span>
<span class="cm">	 * restrictions on the transfer of ASCONF Chunks:</span>
<span class="cm">	 *</span>
<span class="cm">	 * R1) One and only one ASCONF Chunk MAY be in transit and</span>
<span class="cm">	 * unacknowledged at any one time.  If a sender, after sending</span>
<span class="cm">	 * an ASCONF chunk, decides it needs to transfer another</span>
<span class="cm">	 * ASCONF Chunk, it MUST wait until the ASCONF-ACK Chunk</span>
<span class="cm">	 * returns from the previous ASCONF Chunk before sending a</span>
<span class="cm">	 * subsequent ASCONF. Note this restriction binds each side,</span>
<span class="cm">	 * so at any time two ASCONF may be in-transit on any given</span>
<span class="cm">	 * association (one sent from each endpoint).</span>
<span class="cm">	 *</span>
<span class="cm">	 *</span>
<span class="cm">	 * [I really think this is EXACTLY the sort of intelligence</span>
<span class="cm">	 *  which already resides in sctp_outq.	 Please move this</span>
<span class="cm">	 *  queue and its supporting logic down there.	--piggy]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">addip_chunk_list</span><span class="p">;</span>

	<span class="cm">/* ADDIP Section 4.1 ASCONF Chunk Procedures</span>
<span class="cm">	 *</span>
<span class="cm">	 * A2) A serial number should be assigned to the Chunk. The</span>
<span class="cm">	 * serial number SHOULD be a monotonically increasing</span>
<span class="cm">	 * number. The serial number SHOULD be initialized at</span>
<span class="cm">	 * the start of the association to the same value as the</span>
<span class="cm">	 * Initial TSN and every time a new ASCONF chunk is created</span>
<span class="cm">	 * it is incremented by one after assigning the serial number</span>
<span class="cm">	 * to the newly created chunk.</span>
<span class="cm">	 *</span>
<span class="cm">	 * ADDIP</span>
<span class="cm">	 * 3.1.1  Address/Stream Configuration Change Chunk (ASCONF)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Serial Number : 32 bits (unsigned integer)</span>
<span class="cm">	 *</span>
<span class="cm">	 * This value represents a Serial Number for the ASCONF</span>
<span class="cm">	 * Chunk. The valid range of Serial Number is from 0 to</span>
<span class="cm">	 * 4294967295 (2^32 - 1).  Serial Numbers wrap back to 0</span>
<span class="cm">	 * after reaching 4294967295.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">addip_serial</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">asconf_addr_del_pending</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">src_out_of_asoc_ok</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">new_transport</span><span class="p">;</span>

	<span class="cm">/* SCTP AUTH: list of the endpoint shared keys.  These</span>
<span class="cm">	 * keys are provided out of band by the user applicaton</span>
<span class="cm">	 * and can&#39;t change during the lifetime of the association</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">endpoint_shared_keys</span><span class="p">;</span>

	<span class="cm">/* SCTP AUTH:</span>
<span class="cm">	 * The current generated assocaition shared key (secret)</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sctp_auth_bytes</span> <span class="o">*</span><span class="n">asoc_shared_key</span><span class="p">;</span>

	<span class="cm">/* SCTP AUTH: hmac id of the first peer requested algorithm</span>
<span class="cm">	 * that we support.</span>
<span class="cm">	 */</span>
	<span class="n">__u16</span> <span class="n">default_hmac_id</span><span class="p">;</span>

	<span class="n">__u16</span> <span class="n">active_key_id</span><span class="p">;</span>

	<span class="n">__u8</span> <span class="n">need_ecne</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* Need to send an ECNE Chunk? */</span>
	     <span class="nl">temp:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Is it a temporary association? */</span>
<span class="p">};</span>


<span class="cm">/* An eyecatcher for determining if we are really looking at an</span>
<span class="cm"> * association data structure.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SCTP_ASSOC_EYECATCHER</span> <span class="o">=</span> <span class="mh">0xa550c123</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Recover the outter association structure. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="nf">sctp_assoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_ep_common</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">;</span>

	<span class="n">asoc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_association</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">asoc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* These are function signatures for manipulating associations.	 */</span>


<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span>
<span class="n">sctp_association_new</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_endpoint</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span>
		     <span class="n">sctp_scope_t</span> <span class="n">scope</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_association_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_association_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_association_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">sctp_assoc_choose_alter_transport</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_assoc_update_retran_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">sctp_assoc_lookup_paddr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_assoc_lookup_laddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">sctp_assoc_add_peer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">int</span> <span class="n">peer_state</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_assoc_del_peer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_assoc_rm_peer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">peer</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_assoc_control_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">,</span>
				  <span class="n">sctp_transport_cmd_t</span><span class="p">,</span> <span class="n">sctp_sn_error_t</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">sctp_assoc_lookup_tsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span> <span class="n">__u32</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="n">sctp_assoc_is_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_assoc_migrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_assoc_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">new</span><span class="p">);</span>

<span class="n">__u32</span> <span class="n">sctp_association_get_next_tsn</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">sctp_assoc_sync_pmtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_assoc_rwnd_increase</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_assoc_rwnd_decrease</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_assoc_set_primary</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_assoc_del_nonprimary_peers</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sctp_transport</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_assoc_set_bind_addr_from_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span>
				     <span class="n">sctp_scope_t</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_assoc_set_bind_addr_from_cookie</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sctp_cookie</span><span class="o">*</span><span class="p">,</span>
					 <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sctp_assoc_set_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_assoc_clean_asconf_ack_cache</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">sctp_assoc_lookup_asconf_ack</span><span class="p">(</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">,</span>
					<span class="n">__be32</span> <span class="n">serial</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sctp_asconf_queue_teardown</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">sctp_cmp_addr_exact</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">ss1</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">union</span> <span class="n">sctp_addr</span> <span class="o">*</span><span class="n">ss2</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sctp_chunk</span> <span class="o">*</span><span class="n">sctp_get_ecne_prepend</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctp_association</span> <span class="o">*</span><span class="n">asoc</span><span class="p">);</span>

<span class="cm">/* A convenience structure to parse out SCTP specific CMSGs. */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sctp_cmsgs</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctp_initmsg</span> <span class="o">*</span><span class="n">init</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctp_sndrcvinfo</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
<span class="p">}</span> <span class="n">sctp_cmsgs_t</span><span class="p">;</span>

<span class="cm">/* Structure for tracking memory objects */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="o">*</span><span class="n">counter</span><span class="p">;</span>
<span class="p">}</span> <span class="n">sctp_dbg_objcnt_entry_t</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* __sctp_structs_h__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
