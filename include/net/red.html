<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › red.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>red.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __NET_SCHED_RED_H</span>
<span class="cp">#define __NET_SCHED_RED_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;net/pkt_sched.h&gt;</span>
<span class="cp">#include &lt;net/inet_ecn.h&gt;</span>
<span class="cp">#include &lt;net/dsfield.h&gt;</span>
<span class="cp">#include &lt;linux/reciprocal_div.h&gt;</span>

<span class="cm">/*	Random Early Detection (RED) algorithm.</span>
<span class="cm">	=======================================</span>

<span class="cm">	Source: Sally Floyd and Van Jacobson, &quot;Random Early Detection Gateways</span>
<span class="cm">	for Congestion Avoidance&quot;, 1993, IEEE/ACM Transactions on Networking.</span>

<span class="cm">	This file codes a &quot;divisionless&quot; version of RED algorithm</span>
<span class="cm">	as written down in Fig.17 of the paper.</span>

<span class="cm">	Short description.</span>
<span class="cm">	------------------</span>

<span class="cm">	When a new packet arrives we calculate the average queue length:</span>

<span class="cm">	avg = (1-W)*avg + W*current_queue_len,</span>

<span class="cm">	W is the filter time constant (chosen as 2^(-Wlog)), it controls</span>
<span class="cm">	the inertia of the algorithm. To allow larger bursts, W should be</span>
<span class="cm">	decreased.</span>

<span class="cm">	if (avg &gt; th_max) -&gt; packet marked (dropped).</span>
<span class="cm">	if (avg &lt; th_min) -&gt; packet passes.</span>
<span class="cm">	if (th_min &lt; avg &lt; th_max) we calculate probability:</span>

<span class="cm">	Pb = max_P * (avg - th_min)/(th_max-th_min)</span>

<span class="cm">	and mark (drop) packet with this probability.</span>
<span class="cm">	Pb changes from 0 (at avg==th_min) to max_P (avg==th_max).</span>
<span class="cm">	max_P should be small (not 1), usually 0.01..0.02 is good value.</span>

<span class="cm">	max_P is chosen as a number, so that max_P/(th_max-th_min)</span>
<span class="cm">	is a negative power of two in order arithmetics to contain</span>
<span class="cm">	only shifts.</span>


<span class="cm">	Parameters, settable by user:</span>
<span class="cm">	-----------------------------</span>

<span class="cm">	qth_min		- bytes (should be &lt; qth_max/2)</span>
<span class="cm">	qth_max		- bytes (should be at least 2*qth_min and less limit)</span>
<span class="cm">	Wlog	       	- bits (&lt;32) log(1/W).</span>
<span class="cm">	Plog	       	- bits (&lt;32)</span>

<span class="cm">	Plog is related to max_P by formula:</span>

<span class="cm">	max_P = (qth_max-qth_min)/2^Plog;</span>

<span class="cm">	F.e. if qth_max=128K and qth_min=32K, then Plog=22</span>
<span class="cm">	corresponds to max_P=0.02</span>

<span class="cm">	Scell_log</span>
<span class="cm">	Stab</span>

<span class="cm">	Lookup table for log((1-W)^(t/t_ave).</span>


<span class="cm">	NOTES:</span>

<span class="cm">	Upper bound on W.</span>
<span class="cm">	-----------------</span>

<span class="cm">	If you want to allow bursts of L packets of size S,</span>
<span class="cm">	you should choose W:</span>

<span class="cm">	L + 1 - th_min/S &lt; (1-(1-W)^L)/W</span>

<span class="cm">	th_min/S = 32         th_min/S = 4</span>

<span class="cm">	log(W)	L</span>
<span class="cm">	-1	33</span>
<span class="cm">	-2	35</span>
<span class="cm">	-3	39</span>
<span class="cm">	-4	46</span>
<span class="cm">	-5	57</span>
<span class="cm">	-6	75</span>
<span class="cm">	-7	101</span>
<span class="cm">	-8	135</span>
<span class="cm">	-9	190</span>
<span class="cm">	etc.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Adaptative RED : An Algorithm for Increasing the Robustness of RED&#39;s AQM</span>
<span class="cm"> * (Sally FLoyd, Ramakrishna Gummadi, and Scott Shenker) August 2001</span>
<span class="cm"> *</span>
<span class="cm"> * Every 500 ms:</span>
<span class="cm"> *  if (avg &gt; target and max_p &lt;= 0.5)</span>
<span class="cm"> *   increase max_p : max_p += alpha;</span>
<span class="cm"> *  else if (avg &lt; target and max_p &gt;= 0.01)</span>
<span class="cm"> *   decrease max_p : max_p *= beta;</span>
<span class="cm"> *</span>
<span class="cm"> * target :[qth_min + 0.4*(qth_min - qth_max),</span>
<span class="cm"> *          qth_min + 0.6*(qth_min - qth_max)].</span>
<span class="cm"> * alpha : min(0.01, max_p / 4)</span>
<span class="cm"> * beta : 0.9</span>
<span class="cm"> * max_P is a Q0.32 fixed point number (with 32 bits mantissa)</span>
<span class="cm"> * max_P between 0.01 and 0.5 (1% - 50%) [ Its no longer a negative power of two ]</span>
<span class="cm"> */</span>
<span class="cp">#define RED_ONE_PERCENT ((u32)DIV_ROUND_CLOSEST(1ULL&lt;&lt;32, 100))</span>

<span class="cp">#define MAX_P_MIN (1 * RED_ONE_PERCENT)</span>
<span class="cp">#define MAX_P_MAX (50 * RED_ONE_PERCENT)</span>
<span class="cp">#define MAX_P_ALPHA(val) min(MAX_P_MIN, val / 4)</span>

<span class="cp">#define RED_STAB_SIZE	256</span>
<span class="cp">#define RED_STAB_MASK	(RED_STAB_SIZE - 1)</span>

<span class="k">struct</span> <span class="n">red_stats</span> <span class="p">{</span>
	<span class="n">u32</span>		<span class="n">prob_drop</span><span class="p">;</span>	<span class="cm">/* Early probability drops */</span>
	<span class="n">u32</span>		<span class="n">prob_mark</span><span class="p">;</span>	<span class="cm">/* Early probability marks */</span>
	<span class="n">u32</span>		<span class="n">forced_drop</span><span class="p">;</span>	<span class="cm">/* Forced drops, qavg &gt; max_thresh */</span>
	<span class="n">u32</span>		<span class="n">forced_mark</span><span class="p">;</span>	<span class="cm">/* Forced marks, qavg &gt; max_thresh */</span>
	<span class="n">u32</span>		<span class="n">pdrop</span><span class="p">;</span>          <span class="cm">/* Drops due to queue limits */</span>
	<span class="n">u32</span>		<span class="n">other</span><span class="p">;</span>          <span class="cm">/* Drops due to drop() calls */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">red_parms</span> <span class="p">{</span>
	<span class="cm">/* Parameters */</span>
	<span class="n">u32</span>		<span class="n">qth_min</span><span class="p">;</span>	<span class="cm">/* Min avg length threshold: Wlog scaled */</span>
	<span class="n">u32</span>		<span class="n">qth_max</span><span class="p">;</span>	<span class="cm">/* Max avg length threshold: Wlog scaled */</span>
	<span class="n">u32</span>		<span class="n">Scell_max</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">max_P</span><span class="p">;</span>		<span class="cm">/* probability, [0 .. 1.0] 32 scaled */</span>
	<span class="n">u32</span>		<span class="n">max_P_reciprocal</span><span class="p">;</span> <span class="cm">/* reciprocal_value(max_P / qth_delta) */</span>
	<span class="n">u32</span>		<span class="n">qth_delta</span><span class="p">;</span>	<span class="cm">/* max_th - min_th */</span>
	<span class="n">u32</span>		<span class="n">target_min</span><span class="p">;</span>	<span class="cm">/* min_th + 0.4*(max_th - min_th) */</span>
	<span class="n">u32</span>		<span class="n">target_max</span><span class="p">;</span>	<span class="cm">/* min_th + 0.6*(max_th - min_th) */</span>
	<span class="n">u8</span>		<span class="n">Scell_log</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">Wlog</span><span class="p">;</span>		<span class="cm">/* log(W)		*/</span>
	<span class="n">u8</span>		<span class="n">Plog</span><span class="p">;</span>		<span class="cm">/* random number bits	*/</span>
	<span class="n">u8</span>		<span class="n">Stab</span><span class="p">[</span><span class="n">RED_STAB_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">red_vars</span> <span class="p">{</span>
	<span class="cm">/* Variables */</span>
	<span class="kt">int</span>		<span class="n">qcount</span><span class="p">;</span>		<span class="cm">/* Number of packets since last random</span>
<span class="cm">					   number generation */</span>
	<span class="n">u32</span>		<span class="n">qR</span><span class="p">;</span>		<span class="cm">/* Cached random number */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">qavg</span><span class="p">;</span>		<span class="cm">/* Average queue length: Wlog scaled */</span>
	<span class="n">ktime_t</span>		<span class="n">qidlestart</span><span class="p">;</span>	<span class="cm">/* Start of current idle period */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">red_maxp</span><span class="p">(</span><span class="n">u8</span> <span class="n">Plog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">Plog</span> <span class="o">&lt;</span> <span class="mi">32</span> <span class="o">?</span> <span class="p">(</span><span class="o">~</span><span class="mi">0U</span> <span class="o">&gt;&gt;</span> <span class="n">Plog</span><span class="p">)</span> <span class="o">:</span> <span class="o">~</span><span class="mi">0U</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">red_set_vars</span><span class="p">(</span><span class="k">struct</span> <span class="n">red_vars</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Reset average queue length, the value is strictly bound</span>
<span class="cm">	 * to the parameters below, reseting hurts a bit but leaving</span>
<span class="cm">	 * it might result in an unreasonable qavg for a while. --TGR</span>
<span class="cm">	 */</span>
	<span class="n">v</span><span class="o">-&gt;</span><span class="n">qavg</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">v</span><span class="o">-&gt;</span><span class="n">qcount</span>	<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">red_set_parms</span><span class="p">(</span><span class="k">struct</span> <span class="n">red_parms</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">qth_min</span><span class="p">,</span> <span class="n">u32</span> <span class="n">qth_max</span><span class="p">,</span> <span class="n">u8</span> <span class="n">Wlog</span><span class="p">,</span> <span class="n">u8</span> <span class="n">Plog</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="n">Scell_log</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">stab</span><span class="p">,</span> <span class="n">u32</span> <span class="n">max_P</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">qth_max</span> <span class="o">-</span> <span class="n">qth_min</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_p_delta</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">qth_min</span>	<span class="o">=</span> <span class="n">qth_min</span> <span class="o">&lt;&lt;</span> <span class="n">Wlog</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">qth_max</span>	<span class="o">=</span> <span class="n">qth_max</span> <span class="o">&lt;&lt;</span> <span class="n">Wlog</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">Wlog</span>		<span class="o">=</span> <span class="n">Wlog</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">Plog</span>		<span class="o">=</span> <span class="n">Plog</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">qth_delta</span>	<span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_P</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">max_P</span> <span class="o">=</span> <span class="n">red_maxp</span><span class="p">(</span><span class="n">Plog</span><span class="p">);</span>
		<span class="n">max_P</span> <span class="o">*=</span> <span class="n">delta</span><span class="p">;</span> <span class="cm">/* max_P = (qth_max - qth_min)/2^Plog */</span>
	<span class="p">}</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">max_P</span> <span class="o">=</span> <span class="n">max_P</span><span class="p">;</span>
	<span class="n">max_p_delta</span> <span class="o">=</span> <span class="n">max_P</span> <span class="o">/</span> <span class="n">delta</span><span class="p">;</span>
	<span class="n">max_p_delta</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_p_delta</span><span class="p">,</span> <span class="mi">1U</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">max_P_reciprocal</span>  <span class="o">=</span> <span class="n">reciprocal_value</span><span class="p">(</span><span class="n">max_p_delta</span><span class="p">);</span>

	<span class="cm">/* RED Adaptative target :</span>
<span class="cm">	 * [min_th + 0.4*(min_th - max_th),</span>
<span class="cm">	 *  min_th + 0.6*(min_th - max_th)].</span>
<span class="cm">	 */</span>
	<span class="n">delta</span> <span class="o">/=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">target_min</span> <span class="o">=</span> <span class="n">qth_min</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">delta</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">target_max</span> <span class="o">=</span> <span class="n">qth_min</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">delta</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">Scell_log</span>	<span class="o">=</span> <span class="n">Scell_log</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">Scell_max</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">255</span> <span class="o">&lt;&lt;</span> <span class="n">Scell_log</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stab</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">Stab</span><span class="p">,</span> <span class="n">stab</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">Stab</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">red_is_idling</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">red_vars</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">qidlestart</span><span class="p">.</span><span class="n">tv64</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">red_start_of_idle_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">red_vars</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">v</span><span class="o">-&gt;</span><span class="n">qidlestart</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">red_end_of_idle_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">red_vars</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">v</span><span class="o">-&gt;</span><span class="n">qidlestart</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">red_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">red_vars</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">red_end_of_idle_period</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
	<span class="n">v</span><span class="o">-&gt;</span><span class="n">qavg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">v</span><span class="o">-&gt;</span><span class="n">qcount</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">red_calc_qavg_from_idle_time</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">red_parms</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
							 <span class="k">const</span> <span class="k">struct</span> <span class="n">red_vars</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">ktime_us_delta</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">(),</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">qidlestart</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">us_idle</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">s64</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">Scell_max</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="n">shift</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The problem: ideally, average length queue recalcultion should</span>
<span class="cm">	 * be done over constant clock intervals. This is too expensive, so</span>
<span class="cm">	 * that the calculation is driven by outgoing packets.</span>
<span class="cm">	 * When the queue is idle we have to model this clock by hand.</span>
<span class="cm">	 *</span>
<span class="cm">	 * SF+VJ proposed to &quot;generate&quot;:</span>
<span class="cm">	 *</span>
<span class="cm">	 *	m = idletime / (average_pkt_size / bandwidth)</span>
<span class="cm">	 *</span>
<span class="cm">	 * dummy packets as a burst after idle time, i.e.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 	v-&gt;qavg *= (1-W)^m</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is an apparently overcomplicated solution (f.e. we have to</span>
<span class="cm">	 * precompute a table to make this calculation in reasonable time)</span>
<span class="cm">	 * I believe that a simpler model may be used here,</span>
<span class="cm">	 * but it is field for experiments.</span>
<span class="cm">	 */</span>

	<span class="n">shift</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">Stab</span><span class="p">[(</span><span class="n">us_idle</span> <span class="o">&gt;&gt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">Scell_log</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RED_STAB_MASK</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shift</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">qavg</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Approximate initial part of exponent with linear function:</span>
<span class="cm">		 *</span>
<span class="cm">		 * 	(1-W)^m ~= 1-mW + ...</span>
<span class="cm">		 *</span>
<span class="cm">		 * Seems, it is the best solution to</span>
<span class="cm">		 * problem of too coarse exponent tabulation.</span>
<span class="cm">		 */</span>
		<span class="n">us_idle</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">qavg</span> <span class="o">*</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">us_idle</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">Scell_log</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">us_idle</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">qavg</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">qavg</span> <span class="o">-</span> <span class="n">us_idle</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">qavg</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">red_calc_qavg_no_idle_time</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">red_parms</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
						       <span class="k">const</span> <span class="k">struct</span> <span class="n">red_vars</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span>
						       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * NOTE: v-&gt;qavg is fixed point number with point at Wlog.</span>
<span class="cm">	 * The formula below is equvalent to floating point</span>
<span class="cm">	 * version:</span>
<span class="cm">	 *</span>
<span class="cm">	 * 	qavg = qavg*(1-W) + backlog*W;</span>
<span class="cm">	 *</span>
<span class="cm">	 * --ANK (980924)</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">qavg</span> <span class="o">+</span> <span class="p">(</span><span class="n">backlog</span> <span class="o">-</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">qavg</span> <span class="o">&gt;&gt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">Wlog</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">red_calc_qavg</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">red_parms</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">red_vars</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">red_is_idling</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">red_calc_qavg_no_idle_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">backlog</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">red_calc_qavg_from_idle_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">red_random</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">red_parms</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">reciprocal_divide</span><span class="p">(</span><span class="n">net_random</span><span class="p">(),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">max_P_reciprocal</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">red_mark_probability</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">red_parms</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">red_vars</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">qavg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The formula used below causes questions.</span>

<span class="cm">	   OK. qR is random number in the interval</span>
<span class="cm">		(0..1/max_P)*(qth_max-qth_min)</span>
<span class="cm">	   i.e. 0..(2^Plog). If we used floating point</span>
<span class="cm">	   arithmetics, it would be: (2^Plog)*rnd_num,</span>
<span class="cm">	   where rnd_num is less 1.</span>

<span class="cm">	   Taking into account, that qavg have fixed</span>
<span class="cm">	   point at Wlog, two lines</span>
<span class="cm">	   below have the following floating point equivalent:</span>

<span class="cm">	   max_P*(qavg - qth_min)/(qth_max-qth_min) &lt; rnd/qcount</span>

<span class="cm">	   Any questions? --ANK (980924)</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(((</span><span class="n">qavg</span> <span class="o">-</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">qth_min</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">Wlog</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">qcount</span> <span class="o">&lt;</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">qR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RED_BELOW_MIN_THRESH</span><span class="p">,</span>
	<span class="n">RED_BETWEEN_TRESH</span><span class="p">,</span>
	<span class="n">RED_ABOVE_MAX_TRESH</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">red_cmp_thresh</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">red_parms</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">qavg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qavg</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">qth_min</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">RED_BELOW_MIN_THRESH</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">qavg</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">qth_max</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">RED_ABOVE_MAX_TRESH</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">RED_BETWEEN_TRESH</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RED_DONT_MARK</span><span class="p">,</span>
	<span class="n">RED_PROB_MARK</span><span class="p">,</span>
	<span class="n">RED_HARD_MARK</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">red_action</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">red_parms</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">red_vars</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">qavg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">red_cmp_thresh</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">qavg</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">RED_BELOW_MIN_THRESH</span>:
			<span class="n">v</span><span class="o">-&gt;</span><span class="n">qcount</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">RED_DONT_MARK</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">RED_BETWEEN_TRESH</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">qcount</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">red_mark_probability</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">qavg</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">v</span><span class="o">-&gt;</span><span class="n">qcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">v</span><span class="o">-&gt;</span><span class="n">qR</span> <span class="o">=</span> <span class="n">red_random</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">RED_PROB_MARK</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">v</span><span class="o">-&gt;</span><span class="n">qR</span> <span class="o">=</span> <span class="n">red_random</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">RED_DONT_MARK</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">RED_ABOVE_MAX_TRESH</span>:
			<span class="n">v</span><span class="o">-&gt;</span><span class="n">qcount</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">RED_HARD_MARK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">RED_DONT_MARK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">red_adaptative_algo</span><span class="p">(</span><span class="k">struct</span> <span class="n">red_parms</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">red_vars</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">qavg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_p_delta</span><span class="p">;</span>

	<span class="n">qavg</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">qavg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">red_is_idling</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
		<span class="n">qavg</span> <span class="o">=</span> <span class="n">red_calc_qavg_from_idle_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

	<span class="cm">/* v-&gt;qavg is fixed point number with point at Wlog */</span>
	<span class="n">qavg</span> <span class="o">&gt;&gt;=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">Wlog</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qavg</span> <span class="o">&gt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">target_max</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">max_P</span> <span class="o">&lt;=</span> <span class="n">MAX_P_MAX</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">max_P</span> <span class="o">+=</span> <span class="n">MAX_P_ALPHA</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">max_P</span><span class="p">);</span> <span class="cm">/* maxp = maxp + alpha */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">qavg</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">target_min</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">max_P</span> <span class="o">&gt;=</span> <span class="n">MAX_P_MIN</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">max_P</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">max_P</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="o">*</span><span class="mi">9</span><span class="p">;</span> <span class="cm">/* maxp = maxp * Beta */</span>

	<span class="n">max_p_delta</span> <span class="o">=</span> <span class="n">DIV_ROUND_CLOSEST</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">max_P</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">qth_delta</span><span class="p">);</span>
	<span class="n">max_p_delta</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_p_delta</span><span class="p">,</span> <span class="mi">1U</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">max_P_reciprocal</span> <span class="o">=</span> <span class="n">reciprocal_value</span><span class="p">(</span><span class="n">max_p_delta</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
