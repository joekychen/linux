<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › netlabel.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>netlabel.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * NetLabel System</span>
<span class="cm"> *</span>
<span class="cm"> * The NetLabel system manages static and dynamic label mappings for network</span>
<span class="cm"> * protocols such as CIPSO and RIPSO.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Paul Moore &lt;paul@paul-moore.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * (c) Copyright Hewlett-Packard Development Company, L.P., 2006, 2008</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software;  you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY;  without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> * the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program;  if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _NETLABEL_H</span>
<span class="cp">#define _NETLABEL_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/in6.h&gt;</span>
<span class="cp">#include &lt;net/netlink.h&gt;</span>
<span class="cp">#include &lt;net/request_sock.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="k">struct</span> <span class="n">cipso_v4_doi</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * NetLabel - A management interface for maintaining network packet label</span>
<span class="cm"> *            mapping tables for explicit packet labling protocols.</span>
<span class="cm"> *</span>
<span class="cm"> * Network protocols such as CIPSO and RIPSO require a label translation layer</span>
<span class="cm"> * to convert the label on the packet into something meaningful on the host</span>
<span class="cm"> * machine.  In the current Linux implementation these mapping tables live</span>
<span class="cm"> * inside the kernel; NetLabel provides a mechanism for user space applications</span>
<span class="cm"> * to manage these mapping tables.</span>
<span class="cm"> *</span>
<span class="cm"> * NetLabel makes use of the Generic NETLINK mechanism as a transport layer to</span>
<span class="cm"> * send messages between kernel and user space.  The general format of a</span>
<span class="cm"> * NetLabel message is shown below:</span>
<span class="cm"> *</span>
<span class="cm"> *  +-----------------+-------------------+--------- --- -- -</span>
<span class="cm"> *  | struct nlmsghdr | struct genlmsghdr | payload</span>
<span class="cm"> *  +-----------------+-------------------+--------- --- -- -</span>
<span class="cm"> *</span>
<span class="cm"> * The &#39;nlmsghdr&#39; and &#39;genlmsghdr&#39; structs should be dealt with like normal.</span>
<span class="cm"> * The payload is dependent on the subsystem specified in the</span>
<span class="cm"> * &#39;nlmsghdr-&gt;nlmsg_type&#39; and should be defined below, supporting functions</span>
<span class="cm"> * should be defined in the corresponding net/netlabel/netlabel_&lt;subsys&gt;.h|c</span>
<span class="cm"> * file.  All of the fields in the NetLabel payload are NETLINK attributes, see</span>
<span class="cm"> * the include/net/netlink.h file for more information on NETLINK attributes.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * NetLabel NETLINK protocol</span>
<span class="cm"> */</span>

<span class="cm">/* NetLabel NETLINK protocol version</span>
<span class="cm"> *  1: initial version</span>
<span class="cm"> *  2: added static labels for unlabeled connections</span>
<span class="cm"> *  3: network selectors added to the NetLabel/LSM domain mapping and the</span>
<span class="cm"> *     CIPSO_V4_MAP_LOCAL CIPSO mapping was added</span>
<span class="cm"> */</span>
<span class="cp">#define NETLBL_PROTO_VERSION            3</span>

<span class="cm">/* NetLabel NETLINK types/families */</span>
<span class="cp">#define NETLBL_NLTYPE_NONE              0</span>
<span class="cp">#define NETLBL_NLTYPE_MGMT              1</span>
<span class="cp">#define NETLBL_NLTYPE_MGMT_NAME         &quot;NLBL_MGMT&quot;</span>
<span class="cp">#define NETLBL_NLTYPE_RIPSO             2</span>
<span class="cp">#define NETLBL_NLTYPE_RIPSO_NAME        &quot;NLBL_RIPSO&quot;</span>
<span class="cp">#define NETLBL_NLTYPE_CIPSOV4           3</span>
<span class="cp">#define NETLBL_NLTYPE_CIPSOV4_NAME      &quot;NLBL_CIPSOv4&quot;</span>
<span class="cp">#define NETLBL_NLTYPE_CIPSOV6           4</span>
<span class="cp">#define NETLBL_NLTYPE_CIPSOV6_NAME      &quot;NLBL_CIPSOv6&quot;</span>
<span class="cp">#define NETLBL_NLTYPE_UNLABELED         5</span>
<span class="cp">#define NETLBL_NLTYPE_UNLABELED_NAME    &quot;NLBL_UNLBL&quot;</span>
<span class="cp">#define NETLBL_NLTYPE_ADDRSELECT        6</span>
<span class="cp">#define NETLBL_NLTYPE_ADDRSELECT_NAME   &quot;NLBL_ADRSEL&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * NetLabel - Kernel API for accessing the network packet label mappings.</span>
<span class="cm"> *</span>
<span class="cm"> * The following functions are provided for use by other kernel modules,</span>
<span class="cm"> * specifically kernel LSM modules, to provide a consistent, transparent API</span>
<span class="cm"> * for dealing with explicit packet labeling protocols such as CIPSO and</span>
<span class="cm"> * RIPSO.  The functions defined here are implemented in the</span>
<span class="cm"> * net/netlabel/netlabel_kapi.c file.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/* NetLabel audit information */</span>
<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">secid</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">loginuid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sessionid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * LSM security attributes</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct netlbl_lsm_cache - NetLabel LSM security attribute cache</span>
<span class="cm"> * @refcount: atomic reference counter</span>
<span class="cm"> * @free: LSM supplied function to free the cache data</span>
<span class="cm"> * @data: LSM supplied cache data</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * This structure is provided for LSMs which wish to make use of the NetLabel</span>
<span class="cm"> * caching mechanism to store LSM specific data/attributes in the NetLabel</span>
<span class="cm"> * cache.  If the LSM has to perform a lot of translation from the NetLabel</span>
<span class="cm"> * security attributes into it&#39;s own internal representation then the cache</span>
<span class="cm"> * mechanism can provide a way to eliminate some or all of that translation</span>
<span class="cm"> * overhead on a cache hit.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">netlbl_lsm_cache</span> <span class="p">{</span>
	<span class="n">atomic_t</span> <span class="n">refcount</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct netlbl_lsm_secattr_catmap - NetLabel LSM secattr category bitmap</span>
<span class="cm"> * @startbit: the value of the lowest order bit in the bitmap</span>
<span class="cm"> * @bitmap: the category bitmap</span>
<span class="cm"> * @next: pointer to the next bitmap &quot;node&quot; or NULL</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * This structure is used to represent category bitmaps.  Due to the large</span>
<span class="cm"> * number of categories supported by most labeling protocols it is not</span>
<span class="cm"> * practical to transfer a full bitmap internally so NetLabel adopts a sparse</span>
<span class="cm"> * bitmap structure modeled after SELinux&#39;s ebitmap structure.</span>
<span class="cm"> * The catmap bitmap field MUST be a power of two in length and large</span>
<span class="cm"> * enough to hold at least 240 bits.  Special care (i.e. check the code!)</span>
<span class="cm"> * should be used when changing these values as the LSM implementation</span>
<span class="cm"> * probably has functions which rely on the sizes of these types to speed</span>
<span class="cm"> * processing.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define NETLBL_CATMAP_MAPTYPE           u64</span>
<span class="cp">#define NETLBL_CATMAP_MAPCNT            4</span>
<span class="cp">#define NETLBL_CATMAP_MAPSIZE           (sizeof(NETLBL_CATMAP_MAPTYPE) * 8)</span>
<span class="cp">#define NETLBL_CATMAP_SIZE              (NETLBL_CATMAP_MAPSIZE * \</span>
<span class="cp">					 NETLBL_CATMAP_MAPCNT)</span>
<span class="cp">#define NETLBL_CATMAP_BIT               (NETLBL_CATMAP_MAPTYPE)0x01</span>
<span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">startbit</span><span class="p">;</span>
	<span class="n">NETLBL_CATMAP_MAPTYPE</span> <span class="n">bitmap</span><span class="p">[</span><span class="n">NETLBL_CATMAP_MAPCNT</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct netlbl_lsm_secattr - NetLabel LSM security attributes</span>
<span class="cm"> * @flags: indicate structure attributes, see NETLBL_SECATTR_*</span>
<span class="cm"> * @type: indicate the NLTYPE of the attributes</span>
<span class="cm"> * @domain: the NetLabel LSM domain</span>
<span class="cm"> * @cache: NetLabel LSM specific cache</span>
<span class="cm"> * @attr.mls: MLS sensitivity label</span>
<span class="cm"> * @attr.mls.cat: MLS category bitmap</span>
<span class="cm"> * @attr.mls.lvl: MLS sensitivity level</span>
<span class="cm"> * @attr.secid: LSM specific secid token</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * This structure is used to pass security attributes between NetLabel and the</span>
<span class="cm"> * LSM modules.  The flags field is used to specify which fields within the</span>
<span class="cm"> * struct are valid and valid values can be created by bitwise OR&#39;ing the</span>
<span class="cm"> * NETLBL_SECATTR_* defines.  The domain field is typically set by the LSM to</span>
<span class="cm"> * specify domain specific configuration settings and is not usually used by</span>
<span class="cm"> * NetLabel itself when returning security attributes to the LSM.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="cm">/* bitmap values for &#39;flags&#39; */</span>
<span class="cp">#define NETLBL_SECATTR_NONE             0x00000000</span>
<span class="cp">#define NETLBL_SECATTR_DOMAIN           0x00000001</span>
<span class="cp">#define NETLBL_SECATTR_DOMAIN_CPY       (NETLBL_SECATTR_DOMAIN | \</span>
<span class="cp">					 NETLBL_SECATTR_FREE_DOMAIN)</span>
<span class="cp">#define NETLBL_SECATTR_CACHE            0x00000002</span>
<span class="cp">#define NETLBL_SECATTR_MLS_LVL          0x00000004</span>
<span class="cp">#define NETLBL_SECATTR_MLS_CAT          0x00000008</span>
<span class="cp">#define NETLBL_SECATTR_SECID            0x00000010</span>
	<span class="cm">/* bitmap meta-values for &#39;flags&#39; */</span>
<span class="cp">#define NETLBL_SECATTR_FREE_DOMAIN      0x01000000</span>
<span class="cp">#define NETLBL_SECATTR_CACHEABLE        (NETLBL_SECATTR_MLS_LVL | \</span>
<span class="cp">					 NETLBL_SECATTR_MLS_CAT | \</span>
<span class="cp">					 NETLBL_SECATTR_SECID)</span>
	<span class="n">u32</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netlbl_lsm_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">cat</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">lvl</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">mls</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">secid</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">attr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * LSM security attribute operations (inline)</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_secattr_cache_alloc - Allocate and initialize a secattr cache</span>
<span class="cm"> * @flags: the memory allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Allocate and initialize a netlbl_lsm_cache structure.  Returns a pointer</span>
<span class="cm"> * on success, NULL on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">netlbl_lsm_cache</span> <span class="o">*</span><span class="nf">netlbl_secattr_cache_alloc</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_lsm_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cache</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="p">)</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_secattr_cache_free - Frees a netlbl_lsm_cache struct</span>
<span class="cm"> * @cache: the struct to free</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Frees @secattr including all of the internal buffers.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netlbl_secattr_cache_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">)</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_secattr_catmap_alloc - Allocate a LSM secattr catmap</span>
<span class="cm"> * @flags: memory allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Allocate memory for a LSM secattr catmap, returns a pointer on success, NULL</span>
<span class="cm"> * on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="nf">netlbl_secattr_catmap_alloc</span><span class="p">(</span>
	                                                           <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_secattr_catmap_free - Free a LSM secattr catmap</span>
<span class="cm"> * @catmap: the category bitmap</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Free a LSM secattr catmap.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netlbl_secattr_catmap_free</span><span class="p">(</span>
	                              <span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">catmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">iter</span> <span class="o">=</span> <span class="n">catmap</span><span class="p">;</span>
		<span class="n">catmap</span> <span class="o">=</span> <span class="n">catmap</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">catmap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_secattr_init - Initialize a netlbl_lsm_secattr struct</span>
<span class="cm"> * @secattr: the struct to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Initialize an already allocated netlbl_lsm_secattr struct.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netlbl_secattr_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">secattr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">secattr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_secattr_destroy - Clears a netlbl_lsm_secattr struct</span>
<span class="cm"> * @secattr: the struct to clear</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Destroys the @secattr struct, including freeing all of the internal buffers.</span>
<span class="cm"> * The struct must be reset with a call to netlbl_secattr_init() before reuse.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netlbl_secattr_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NETLBL_SECATTR_FREE_DOMAIN</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NETLBL_SECATTR_CACHE</span><span class="p">)</span>
		<span class="n">netlbl_secattr_cache_free</span><span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NETLBL_SECATTR_MLS_CAT</span><span class="p">)</span>
		<span class="n">netlbl_secattr_catmap_free</span><span class="p">(</span><span class="n">secattr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mls</span><span class="p">.</span><span class="n">cat</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_secattr_alloc - Allocate and initialize a netlbl_lsm_secattr struct</span>
<span class="cm"> * @flags: the memory allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Allocate and initialize a netlbl_lsm_secattr struct.  Returns a valid</span>
<span class="cm"> * pointer on success, or NULL on failure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="nf">netlbl_secattr_alloc</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * netlbl_secattr_free - Frees a netlbl_lsm_secattr struct</span>
<span class="cm"> * @secattr: the struct to free</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Frees @secattr including all of the internal buffers.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netlbl_secattr_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netlbl_secattr_destroy</span><span class="p">(</span><span class="n">secattr</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">secattr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NETLABEL</span>
<span class="cm">/*</span>
<span class="cm"> * LSM configuration operations</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">netlbl_cfg_map_del</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
		       <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlbl_cfg_unlbl_map_add</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
			     <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlbl_cfg_unlbl_static_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
				<span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">secid</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlbl_cfg_unlbl_static_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
				<span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlbl_cfg_cipsov4_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">cipso_v4_doi</span> <span class="o">*</span><span class="n">doi_def</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">netlbl_cfg_cipsov4_del</span><span class="p">(</span><span class="n">u32</span> <span class="n">doi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlbl_cfg_cipsov4_map_add</span><span class="p">(</span><span class="n">u32</span> <span class="n">doi</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * LSM security attribute operations</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">netlbl_secattr_catmap_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">catmap</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">offset</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlbl_secattr_catmap_walk_rng</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">catmap</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">offset</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlbl_secattr_catmap_setbit</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">catmap</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">bit</span><span class="p">,</span>
				 <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlbl_secattr_catmap_setrng</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">catmap</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">start</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">end</span><span class="p">,</span>
				 <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * LSM protocol operations (NetLabel LSM/kernel API)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">netlbl_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlbl_sock_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			<span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">netlbl_sock_delattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlbl_sock_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlbl_conn_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlbl_req_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">netlbl_req_delattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlbl_skbuff_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			  <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlbl_skbuff_getattr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			  <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">netlbl_skbuff_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gateway</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * LSM label mapping cache operations</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">netlbl_cache_invalidate</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlbl_cache_add</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Protocol engine operations</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">netlbl_audit_start</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_cfg_map_del</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
				     <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_cfg_unlbl_map_add</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
					   <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
					   <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
					   <span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_cfg_unlbl_static_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
					      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span>
					      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
					      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
					      <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
					      <span class="n">u32</span> <span class="n">secid</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_cfg_unlbl_static_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
					      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span>
					      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
					      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
					      <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_cfg_cipsov4_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">cipso_v4_doi</span> <span class="o">*</span><span class="n">doi_def</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netlbl_cfg_cipsov4_del</span><span class="p">(</span><span class="n">u32</span> <span class="n">doi</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_cfg_cipsov4_map_add</span><span class="p">(</span><span class="n">u32</span> <span class="n">doi</span><span class="p">,</span>
					     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
					     <span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
					     <span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_secattr_catmap_walk</span><span class="p">(</span>
	                              <span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">catmap</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_secattr_catmap_walk_rng</span><span class="p">(</span>
				      <span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">catmap</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_secattr_catmap_setbit</span><span class="p">(</span>
	                              <span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">catmap</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">bit</span><span class="p">,</span>
				      <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_secattr_catmap_setrng</span><span class="p">(</span>
	                              <span class="k">struct</span> <span class="n">netlbl_lsm_secattr_catmap</span> <span class="o">*</span><span class="n">catmap</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">start</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">end</span><span class="p">,</span>
				      <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_sock_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				      <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netlbl_sock_delattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_sock_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_conn_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_req_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netlbl_req_delattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_skbuff_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_skbuff_getattr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					<span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netlbl_skbuff_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">error</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">gateway</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netlbl_cache_invalidate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netlbl_cache_add</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">netlbl_lsm_secattr</span> <span class="o">*</span><span class="n">secattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="nf">netlbl_audit_start</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">netlbl_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NETLABEL */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _NETLABEL_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
