<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › irda › irttp.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>irttp.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*********************************************************************</span>
<span class="cm"> *                </span>
<span class="cm"> * Filename:      irttp.h</span>
<span class="cm"> * Version:       1.0</span>
<span class="cm"> * Description:   Tiny Transport Protocol (TTP) definitions</span>
<span class="cm"> * Status:        Experimental.</span>
<span class="cm"> * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> * Created at:    Sun Aug 31 20:14:31 1997</span>
<span class="cm"> * Modified at:   Sun Dec 12 13:09:07 1999</span>
<span class="cm"> * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> * </span>
<span class="cm"> *     Copyright (c) 1998-1999 Dag Brattli &lt;dagb@cs.uit.no&gt;, </span>
<span class="cm"> *     All Rights Reserved.</span>
<span class="cm"> *     Copyright (c) 2000-2002 Jean Tourrilhes &lt;jt@hpl.hp.com&gt;</span>
<span class="cm"> *     </span>
<span class="cm"> *     This program is free software; you can redistribute it and/or </span>
<span class="cm"> *     modify it under the terms of the GNU General Public License as </span>
<span class="cm"> *     published by the Free Software Foundation; either version 2 of </span>
<span class="cm"> *     the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *     Neither Dag Brattli nor University of Tromsø admit liability nor</span>
<span class="cm"> *     provide warranty for any of this software. This material is </span>
<span class="cm"> *     provided &quot;AS-IS&quot; and at no charge.</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************/</span>

<span class="cp">#ifndef IRTTP_H</span>
<span class="cp">#define IRTTP_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>

<span class="cp">#include &lt;net/irda/irda.h&gt;</span>
<span class="cp">#include &lt;net/irda/irlmp.h&gt;		</span><span class="cm">/* struct lsap_cb */</span><span class="cp"></span>
<span class="cp">#include &lt;net/irda/qos.h&gt;		</span><span class="cm">/* struct qos_info */</span><span class="cp"></span>
<span class="cp">#include &lt;net/irda/irqueue.h&gt;</span>

<span class="cp">#define TTP_MAX_CONNECTIONS    LM_MAX_CONNECTIONS</span>
<span class="cp">#define TTP_HEADER             1</span>
<span class="cp">#define TTP_MAX_HEADER         (TTP_HEADER + LMP_MAX_HEADER)</span>
<span class="cp">#define TTP_SAR_HEADER         5</span>
<span class="cp">#define TTP_PARAMETERS         0x80</span>
<span class="cp">#define TTP_MORE               0x80</span>

<span class="cm">/* Transmission queue sizes */</span>
<span class="cm">/* Worst case scenario, two window of data - Jean II */</span>
<span class="cp">#define TTP_TX_MAX_QUEUE	14</span>
<span class="cm">/* We need to keep at least 5 frames to make sure that we can refill</span>
<span class="cm"> * appropriately the LAP layer. LAP keeps only two buffers, and we need</span>
<span class="cm"> * to have 7 to make a full window - Jean II */</span>
<span class="cp">#define TTP_TX_LOW_THRESHOLD	5</span>
<span class="cm">/* Most clients are synchronous with respect to flow control, so we can</span>
<span class="cm"> * keep a low number of Tx buffers in TTP - Jean II */</span>
<span class="cp">#define TTP_TX_HIGH_THRESHOLD	7</span>

<span class="cm">/* Receive queue sizes */</span>
<span class="cm">/* Minimum of credit that the peer should hold.</span>
<span class="cm"> * If the peer has less credits than 9 frames, we will explicitly send</span>
<span class="cm"> * him some credits (through irttp_give_credit() and a specific frame).</span>
<span class="cm"> * Note that when we give credits it&#39;s likely that it won&#39;t be sent in</span>
<span class="cm"> * this LAP window, but in the next one. So, we make sure that the peer</span>
<span class="cm"> * has something to send while waiting for credits (one LAP window == 7</span>
<span class="cm"> * + 1 frames while he process the credits). - Jean II */</span>
<span class="cp">#define TTP_RX_MIN_CREDIT	8</span>
<span class="cm">/* This is the default maximum number of credits held by the peer, so the</span>
<span class="cm"> * default maximum number of frames he can send us before needing flow</span>
<span class="cm"> * control answer from us (this may be negociated differently at TSAP setup).</span>
<span class="cm"> * We want to minimise the number of times we have to explicitly send some</span>
<span class="cm"> * credit to the peer, hoping we can piggyback it on the return data. In</span>
<span class="cm"> * particular, it doesn&#39;t make sense for us to send credit more than once</span>
<span class="cm"> * per LAP window.</span>
<span class="cm"> * Moreover, giving credits has some latency, so we need strictly more than</span>
<span class="cm"> * a LAP window, otherwise we may already have credits in our Tx queue.</span>
<span class="cm"> * But on the other hand, we don&#39;t want to keep too many Rx buffer here</span>
<span class="cm"> * before starting to flow control the other end, so make it exactly one</span>
<span class="cm"> * LAP window + 1 + MIN_CREDITS. - Jean II */</span>
<span class="cp">#define TTP_RX_DEFAULT_CREDIT	16</span>
<span class="cm">/* Maximum number of credits we can allow the peer to have, and therefore</span>
<span class="cm"> * maximum Rx queue size.</span>
<span class="cm"> * Note that we try to deliver packets to the higher layer every time we</span>
<span class="cm"> * receive something, so in normal mode the Rx queue will never contains</span>
<span class="cm"> * more than one or two packets. - Jean II */</span>
<span class="cp">#define TTP_RX_MAX_CREDIT	21</span>

<span class="cm">/* What clients should use when calling ttp_open_tsap() */</span>
<span class="cp">#define DEFAULT_INITIAL_CREDIT	TTP_RX_DEFAULT_CREDIT</span>

<span class="cm">/* Some priorities for disconnect requests */</span>
<span class="cp">#define P_NORMAL    0</span>
<span class="cp">#define P_HIGH      1</span>

<span class="cp">#define TTP_SAR_DISABLE 0</span>
<span class="cp">#define TTP_SAR_UNBOUND 0xffffffff</span>

<span class="cm">/* Parameters */</span>
<span class="cp">#define TTP_MAX_SDU_SIZE 0x01</span>

<span class="cm">/*</span>
<span class="cm"> *  This structure contains all data associated with one instance of a TTP </span>
<span class="cm"> *  connection.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="p">{</span>
	<span class="n">irda_queue_t</span> <span class="n">q</span><span class="p">;</span>            <span class="cm">/* Must be first */</span>
	<span class="n">magic_t</span> <span class="n">magic</span><span class="p">;</span>        <span class="cm">/* Just in case */</span>

	<span class="n">__u8</span> <span class="n">stsap_sel</span><span class="p">;</span>       <span class="cm">/* Source TSAP */</span>
	<span class="n">__u8</span> <span class="n">dtsap_sel</span><span class="p">;</span>       <span class="cm">/* Destination TSAP */</span>

	<span class="k">struct</span> <span class="n">lsap_cb</span> <span class="o">*</span><span class="n">lsap</span><span class="p">;</span> <span class="cm">/* Corresponding LSAP to this TSAP */</span>

	<span class="n">__u8</span> <span class="n">connected</span><span class="p">;</span>       <span class="cm">/* TSAP connected */</span>
	 
	<span class="n">__u8</span> <span class="n">initial_credit</span><span class="p">;</span>  <span class="cm">/* Initial credit to give peer */</span>

        <span class="kt">int</span> <span class="n">avail_credit</span><span class="p">;</span>    <span class="cm">/* Available credit to return to peer */</span>
	<span class="kt">int</span> <span class="n">remote_credit</span><span class="p">;</span>   <span class="cm">/* Credit held by peer TTP entity */</span>
	<span class="kt">int</span> <span class="n">send_credit</span><span class="p">;</span>     <span class="cm">/* Credit held by local TTP entity */</span>
	
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">tx_queue</span><span class="p">;</span> <span class="cm">/* Frames to be transmitted */</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">rx_queue</span><span class="p">;</span> <span class="cm">/* Received frames */</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">rx_fragments</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_queue_lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_queue_lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="n">notify_t</span> <span class="n">notify</span><span class="p">;</span>       <span class="cm">/* Callbacks to client layer */</span>

	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">todo_timer</span><span class="p">;</span> 

	<span class="n">__u32</span> <span class="n">max_seg_size</span><span class="p">;</span>     <span class="cm">/* Max data that fit into an IrLAP frame */</span>
	<span class="n">__u8</span>  <span class="n">max_header_size</span><span class="p">;</span>

	<span class="kt">int</span>   <span class="n">rx_sdu_busy</span><span class="p">;</span>     <span class="cm">/* RxSdu.busy */</span>
	<span class="n">__u32</span> <span class="n">rx_sdu_size</span><span class="p">;</span>     <span class="cm">/* Current size of a partially received frame */</span>
	<span class="n">__u32</span> <span class="n">rx_max_sdu_size</span><span class="p">;</span> <span class="cm">/* Max receive user data size */</span>

	<span class="kt">int</span> <span class="n">tx_sdu_busy</span><span class="p">;</span>       <span class="cm">/* TxSdu.busy */</span>
	<span class="n">__u32</span> <span class="n">tx_max_sdu_size</span><span class="p">;</span> <span class="cm">/* Max transmit user data size */</span>

	<span class="kt">int</span> <span class="n">close_pend</span><span class="p">;</span>        <span class="cm">/* Close, but disconnect_pend */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">disconnect_pend</span><span class="p">;</span> <span class="cm">/* Disconnect, but still data to send */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">disconnect_skb</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">irttp_cb</span> <span class="p">{</span>
	<span class="n">magic_t</span>    <span class="n">magic</span><span class="p">;</span>	
	<span class="n">hashbin_t</span> <span class="o">*</span><span class="n">tsaps</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span>  <span class="n">irttp_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">irttp_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">irttp_open_tsap</span><span class="p">(</span><span class="n">__u8</span> <span class="n">stsap_sel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">credit</span><span class="p">,</span> <span class="n">notify_t</span> <span class="o">*</span><span class="n">notify</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">irttp_close_tsap</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">irttp_data_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">irttp_udata_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">irttp_connect_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">dtsap_sel</span><span class="p">,</span> 
			  <span class="n">__u32</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">daddr</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">qos_info</span> <span class="o">*</span><span class="n">qos</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">max_sdu_size</span><span class="p">,</span> 
			  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">userdata</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">irttp_connect_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">max_sdu_size</span><span class="p">,</span> 
			    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">userdata</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">irttp_disconnect_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">priority</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">irttp_flow_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">LOCAL_FLOW</span> <span class="n">flow</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">irttp_dup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">irttp_get_saddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">irlmp_get_saddr</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">irttp_get_daddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">irlmp_get_daddr</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">irttp_get_max_seg_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_seg_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* After doing a irttp_dup(), this get one of the two socket back into</span>
<span class="cm"> * a state where it&#39;s waiting incomming connections.</span>
<span class="cm"> * Note : this can be used *only* if the socket is not yet connected</span>
<span class="cm"> * (i.e. NO irttp_connect_response() done on this socket).</span>
<span class="cm"> * - Jean II */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irttp_listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irlmp_listen</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">dtsap_sel</span> <span class="o">=</span> <span class="n">LSAP_ANY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return TRUE if the node is in primary mode (i.e. master)</span>
<span class="cm"> * - Jean II */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">irttp_is_primary</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsap_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">self</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="o">-&gt;</span><span class="n">lap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">irlap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">irlap_is_primary</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lsap</span><span class="o">-&gt;</span><span class="n">lap</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* IRTTP_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
