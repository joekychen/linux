<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › wimax.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>wimax.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux WiMAX</span>
<span class="cm"> * Kernel space API for accessing WiMAX devices</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007-2008 Intel Corporation &lt;linux-wimax@intel.com&gt;</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * The WiMAX stack provides an API for controlling and managing the</span>
<span class="cm"> * system&#39;s WiMAX devices. This API affects the control plane; the</span>
<span class="cm"> * data plane is accessed via the network stack (netdev).</span>
<span class="cm"> *</span>
<span class="cm"> * Parts of the WiMAX stack API and notifications are exported to</span>
<span class="cm"> * user space via Generic Netlink. In user space, libwimax (part of</span>
<span class="cm"> * the wimax-tools package) provides a shim layer for accessing those</span>
<span class="cm"> * calls.</span>
<span class="cm"> *</span>
<span class="cm"> * The API is standarized for all WiMAX devices and different drivers</span>
<span class="cm"> * implement the backend support for it. However, device-specific</span>
<span class="cm"> * messaging pipes are provided that can be used to issue commands and</span>
<span class="cm"> * receive notifications in free form.</span>
<span class="cm"> *</span>
<span class="cm"> * Currently the messaging pipes are the only means of control as it</span>
<span class="cm"> * is not known (due to the lack of more devices in the market) what</span>
<span class="cm"> * will be a good abstraction layer. Expect this to change as more</span>
<span class="cm"> * devices show in the market. This API is designed to be growable in</span>
<span class="cm"> * order to address this problem.</span>
<span class="cm"> *</span>
<span class="cm"> * USAGE</span>
<span class="cm"> *</span>
<span class="cm"> * Embed a `struct wimax_dev` at the beginning of the the device&#39;s</span>
<span class="cm"> * private structure, initialize and register it. For details, see</span>
<span class="cm"> * `struct wimax_dev`s documentation.</span>
<span class="cm"> *</span>
<span class="cm"> * Once this is done, wimax-tools&#39;s libwimaxll can be used to</span>
<span class="cm"> * communicate with the driver from user space. You user space</span>
<span class="cm"> * application does not have to forcibily use libwimaxll and can talk</span>
<span class="cm"> * the generic netlink protocol directly if desired.</span>
<span class="cm"> *</span>
<span class="cm"> * Remember this is a very low level API that will to provide all of</span>
<span class="cm"> * WiMAX features. Other daemons and services running in user space</span>
<span class="cm"> * are the expected clients of it. They offer a higher level API that</span>
<span class="cm"> * applications should use (an example of this is the Intel&#39;s WiMAX</span>
<span class="cm"> * Network Service for the i2400m).</span>
<span class="cm"> *</span>
<span class="cm"> * DESIGN</span>
<span class="cm"> *</span>
<span class="cm"> * Although not set on final stone, this very basic interface is</span>
<span class="cm"> * mostly completed. Remember this is meant to grow as new common</span>
<span class="cm"> * operations are decided upon. New operations will be added to the</span>
<span class="cm"> * interface, intent being on keeping backwards compatibility as much</span>
<span class="cm"> * as possible.</span>
<span class="cm"> *</span>
<span class="cm"> * This layer implements a set of calls to control a WiMAX device,</span>
<span class="cm"> * exposing a frontend to the rest of the kernel and user space (via</span>
<span class="cm"> * generic netlink) and a backend implementation in the driver through</span>
<span class="cm"> * function pointers.</span>
<span class="cm"> *</span>
<span class="cm"> * WiMAX devices have a state, and a kernel-only API allows the</span>
<span class="cm"> * drivers to manipulate that state. State transitions are atomic, and</span>
<span class="cm"> * only some of them are allowed (see `enum wimax_st`).</span>
<span class="cm"> *</span>
<span class="cm"> * Most API calls will set the state automatically; in most cases</span>
<span class="cm"> * drivers have to only report state changes due to external</span>
<span class="cm"> * conditions.</span>
<span class="cm"> *</span>
<span class="cm"> * All API operations are &#39;atomic&#39;, serialized through a mutex in the</span>
<span class="cm"> * `struct wimax_dev`.</span>
<span class="cm"> *</span>
<span class="cm"> * EXPORTING TO USER SPACE THROUGH GENERIC NETLINK</span>
<span class="cm"> *</span>
<span class="cm"> * The API is exported to user space using generic netlink (other</span>
<span class="cm"> * methods can be added as needed).</span>
<span class="cm"> *</span>
<span class="cm"> * There is a Generic Netlink Family named &quot;WiMAX&quot;, where interfaces</span>
<span class="cm"> * supporting the WiMAX interface receive commands and broadcast their</span>
<span class="cm"> * signals over a multicast group named &quot;msg&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Mapping to the source/destination interface is done by an interface</span>
<span class="cm"> * index attribute.</span>
<span class="cm"> *</span>
<span class="cm"> * For user-to-kernel traffic (commands) we use a function call</span>
<span class="cm"> * marshalling mechanism, where a message X with attributes A, B, C</span>
<span class="cm"> * sent from user space to kernel space means executing the WiMAX API</span>
<span class="cm"> * call wimax_X(A, B, C), sending the results back as a message.</span>
<span class="cm"> *</span>
<span class="cm"> * Kernel-to-user (notifications or signals) communication is sent</span>
<span class="cm"> * over multicast groups. This allows to have multiple applications</span>
<span class="cm"> * monitoring them.</span>
<span class="cm"> *</span>
<span class="cm"> * Each command/signal gets assigned it&#39;s own attribute policy. This</span>
<span class="cm"> * way the validator will verify that all the attributes in there are</span>
<span class="cm"> * only the ones that should be for each command/signal. Thing of an</span>
<span class="cm"> * attribute mapping to a type+argumentname for each command/signal.</span>
<span class="cm"> *</span>
<span class="cm"> * If we had a single policy for *all* commands/signals, after running</span>
<span class="cm"> * the validator we&#39;d have to check &quot;does this attribute belong in</span>
<span class="cm"> * here&quot;?  for each one. It can be done manually, but it&#39;s just easier</span>
<span class="cm"> * to have the validator do that job with multiple policies. As well,</span>
<span class="cm"> * it makes it easier to later expand each command/signal signature</span>
<span class="cm"> * without affecting others and keeping the namespace more or less</span>
<span class="cm"> * sane. Not that it is too complicated, but it makes it even easier.</span>
<span class="cm"> *</span>
<span class="cm"> * No state information is maintained in the kernel for each user</span>
<span class="cm"> * space connection (the connection is stateless).</span>
<span class="cm"> *</span>
<span class="cm"> * TESTING FOR THE INTERFACE AND VERSIONING</span>
<span class="cm"> *</span>
<span class="cm"> * If network interface X is a WiMAX device, there will be a Generic</span>
<span class="cm"> * Netlink family named &quot;WiMAX X&quot; and the device will present a</span>
<span class="cm"> * &quot;wimax&quot; directory in it&#39;s network sysfs directory</span>
<span class="cm"> * (/sys/class/net/DEVICE/wimax) [used by HAL].</span>
<span class="cm"> *</span>
<span class="cm"> * The inexistence of any of these means the device does not support</span>
<span class="cm"> * this WiMAX API.</span>
<span class="cm"> *</span>
<span class="cm"> * By querying the generic netlink controller, versioning information</span>
<span class="cm"> * and the multicast groups available can be found. Applications using</span>
<span class="cm"> * the interface can either rely on that or use the generic netlink</span>
<span class="cm"> * controller to figure out which generic netlink commands/signals are</span>
<span class="cm"> * supported.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: this versioning is a last resort to avoid hard</span>
<span class="cm"> *    incompatibilities. It is the intention of the design of this</span>
<span class="cm"> *    stack not to introduce backward incompatible changes.</span>
<span class="cm"> *</span>
<span class="cm"> * The version code has to fit in one byte (restrictions imposed by</span>
<span class="cm"> * generic netlink); we use `version / 10` for the major version and</span>
<span class="cm"> * `version % 10` for the minor. This gives 9 minors for each major</span>
<span class="cm"> * and 25 majors.</span>
<span class="cm"> *</span>
<span class="cm"> * The version change protocol is as follow:</span>
<span class="cm"> *</span>
<span class="cm"> * - Major versions: needs to be increased if an existing message/API</span>
<span class="cm"> *   call is changed or removed. Doesn&#39;t need to be changed if a new</span>
<span class="cm"> *   message is added.</span>
<span class="cm"> *</span>
<span class="cm"> * - Minor version: needs to be increased if new messages/API calls are</span>
<span class="cm"> *   being added or some other consideration that doesn&#39;t impact the</span>
<span class="cm"> *   user-kernel interface too much (like some kind of bug fix) and</span>
<span class="cm"> *   that is kind of left up in the air to common sense.</span>
<span class="cm"> *</span>
<span class="cm"> * User space code should not try to work if the major version it was</span>
<span class="cm"> * compiled for differs from what the kernel offers. As well, if the</span>
<span class="cm"> * minor version of the kernel interface is lower than the one user</span>
<span class="cm"> * space is expecting (the one it was compiled for), the kernel</span>
<span class="cm"> * might be missing API calls; user space shall be ready to handle</span>
<span class="cm"> * said condition. Use the generic netlink controller operations to</span>
<span class="cm"> * find which ones are supported and which not.</span>
<span class="cm"> *</span>
<span class="cm"> * libwimaxll:wimaxll_open() takes care of checking versions.</span>
<span class="cm"> *</span>
<span class="cm"> * THE OPERATIONS:</span>
<span class="cm"> *</span>
<span class="cm"> * Each operation is defined in its on file (drivers/net/wimax/op-*.c)</span>
<span class="cm"> * for clarity. The parts needed for an operation are:</span>
<span class="cm"> *</span>
<span class="cm"> *  - a function pointer in `struct wimax_dev`: optional, as the</span>
<span class="cm"> *    operation might be implemented by the stack and not by the</span>
<span class="cm"> *    driver.</span>
<span class="cm"> *</span>
<span class="cm"> *    All function pointers are named wimax_dev-&gt;op_*(), and drivers</span>
<span class="cm"> *    must implement them except where noted otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> *  - When exported to user space, a `struct nla_policy` to define the</span>
<span class="cm"> *    attributes of the generic netlink command and a `struct genl_ops`</span>
<span class="cm"> *    to define the operation.</span>
<span class="cm"> *</span>
<span class="cm"> * All the declarations for the operation codes (WIMAX_GNL_OP_&lt;NAME&gt;)</span>
<span class="cm"> * and generic netlink attributes (WIMAX_GNL_&lt;NAME&gt;_*) are declared in</span>
<span class="cm"> * include/linux/wimax.h; this file is intended to be cloned by user</span>
<span class="cm"> * space to gain access to those declarations.</span>
<span class="cm"> *</span>
<span class="cm"> * A few caveats to remember:</span>
<span class="cm"> *</span>
<span class="cm"> *  - Need to define attribute numbers starting in 1; otherwise it</span>
<span class="cm"> *    fails.</span>
<span class="cm"> *</span>
<span class="cm"> *  - the `struct genl_family` requires a maximum attribute id; when</span>
<span class="cm"> *    defining the `struct nla_policy` for each message, it has to have</span>
<span class="cm"> *    an array size of WIMAX_GNL_ATTR_MAX+1.</span>
<span class="cm"> *</span>
<span class="cm"> * The op_*() function pointers will not be called if the wimax_dev is</span>
<span class="cm"> * in a state &lt;= %WIMAX_ST_UNINITIALIZED. The exception is:</span>
<span class="cm"> *</span>
<span class="cm"> * - op_reset: can be called at any time after wimax_dev_add() has</span>
<span class="cm"> *   been called.</span>
<span class="cm"> *</span>
<span class="cm"> * THE PIPE INTERFACE:</span>
<span class="cm"> *</span>
<span class="cm"> * This interface is kept intentionally simple. The driver can send</span>
<span class="cm"> * and receive free-form messages to/from user space through a</span>
<span class="cm"> * pipe. See drivers/net/wimax/op-msg.c for details.</span>
<span class="cm"> *</span>
<span class="cm"> * The kernel-to-user messages are sent with</span>
<span class="cm"> * wimax_msg(). user-to-kernel messages are delivered via</span>
<span class="cm"> * wimax_dev-&gt;op_msg_from_user().</span>
<span class="cm"> *</span>
<span class="cm"> * RFKILL:</span>
<span class="cm"> *</span>
<span class="cm"> * RFKILL support is built into the wimax_dev layer; the driver just</span>
<span class="cm"> * needs to call wimax_report_rfkill_{hw,sw}() to inform of changes in</span>
<span class="cm"> * the hardware or software RF kill switches. When the stack wants to</span>
<span class="cm"> * turn the radio off, it will call wimax_dev-&gt;op_rfkill_sw_toggle(),</span>
<span class="cm"> * which the driver implements.</span>
<span class="cm"> *</span>
<span class="cm"> * User space can set the software RF Kill switch by calling</span>
<span class="cm"> * wimax_rfkill().</span>
<span class="cm"> *</span>
<span class="cm"> * The code for now only supports devices that don&#39;t require polling;</span>
<span class="cm"> * If the device needs to be polled, create a self-rearming delayed</span>
<span class="cm"> * work struct for polling or look into adding polled support to the</span>
<span class="cm"> * WiMAX stack.</span>
<span class="cm"> *</span>
<span class="cm"> * When initializing the hardware (_probe), after calling</span>
<span class="cm"> * wimax_dev_add(), query the device for it&#39;s RF Kill switches status</span>
<span class="cm"> * and feed it back to the WiMAX stack using</span>
<span class="cm"> * wimax_report_rfkill_{hw,sw}(). If any switch is missing, always</span>
<span class="cm"> * report it as ON.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: the wimax stack uses an inverted terminology to that of the</span>
<span class="cm"> * RFKILL subsystem:</span>
<span class="cm"> *</span>
<span class="cm"> *  - ON: radio is ON, RFKILL is DISABLED or OFF.</span>
<span class="cm"> *  - OFF: radio is OFF, RFKILL is ENABLED or ON.</span>
<span class="cm"> *</span>
<span class="cm"> * MISCELLANEOUS OPS:</span>
<span class="cm"> *</span>
<span class="cm"> * wimax_reset() can be used to reset the device to power on state; by</span>
<span class="cm"> * default it issues a warm reset that maintains the same device</span>
<span class="cm"> * node. If that is not possible, it falls back to a cold reset</span>
<span class="cm"> * (device reconnect). The driver implements the backend to this</span>
<span class="cm"> * through wimax_dev-&gt;op_reset().</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __NET__WIMAX_H__</span>
<span class="cp">#define __NET__WIMAX_H__</span>

<span class="cp">#include &lt;linux/wimax.h&gt;</span>
<span class="cp">#include &lt;net/genetlink.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>

<span class="k">struct</span> <span class="n">net_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">genl_info</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">wimax_dev</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct wimax_dev - Generic WiMAX device</span>
<span class="cm"> *</span>
<span class="cm"> * @net_dev: [fill] Pointer to the &amp;struct net_device this WiMAX</span>
<span class="cm"> *     device implements.</span>
<span class="cm"> *</span>
<span class="cm"> * @op_msg_from_user: [fill] Driver-specific operation to</span>
<span class="cm"> *     handle a raw message from user space to the driver. The</span>
<span class="cm"> *     driver can send messages to user space using with</span>
<span class="cm"> *     wimax_msg_to_user().</span>
<span class="cm"> *</span>
<span class="cm"> * @op_rfkill_sw_toggle: [fill] Driver-specific operation to act on</span>
<span class="cm"> *     userspace (or any other agent) requesting the WiMAX device to</span>
<span class="cm"> *     change the RF Kill software switch (WIMAX_RF_ON or</span>
<span class="cm"> *     WIMAX_RF_OFF).</span>
<span class="cm"> *     If such hardware support is not present, it is assumed the</span>
<span class="cm"> *     radio cannot be switched off and it is always on (and the stack</span>
<span class="cm"> *     will error out when trying to switch it off). In such case,</span>
<span class="cm"> *     this function pointer can be left as NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * @op_reset: [fill] Driver specific operation to reset the</span>
<span class="cm"> *     device.</span>
<span class="cm"> *     This operation should always attempt first a warm reset that</span>
<span class="cm"> *     does not disconnect the device from the bus and return 0.</span>
<span class="cm"> *     If that fails, it should resort to some sort of cold or bus</span>
<span class="cm"> *     reset (even if it implies a bus disconnection and device</span>
<span class="cm"> *     disappearance). In that case, -ENODEV should be returned to</span>
<span class="cm"> *     indicate the device is gone.</span>
<span class="cm"> *     This operation has to be synchronous, and return only when the</span>
<span class="cm"> *     reset is complete. In case of having had to resort to bus/cold</span>
<span class="cm"> *     reset implying a device disconnection, the call is allowed to</span>
<span class="cm"> *     return inmediately.</span>
<span class="cm"> *     NOTE: wimax_dev-&gt;mutex is NOT locked when this op is being</span>
<span class="cm"> *     called; however, wimax_dev-&gt;mutex_reset IS locked to ensure</span>
<span class="cm"> *     serialization of calls to wimax_reset().</span>
<span class="cm"> *     See wimax_reset()&#39;s documentation.</span>
<span class="cm"> *</span>
<span class="cm"> * @name: [fill] A way to identify this device. We need to register a</span>
<span class="cm"> *     name with many subsystems (rfkill, workqueue creation, etc).</span>
<span class="cm"> *     We can&#39;t use the network device name as that</span>
<span class="cm"> *     might change and in some instances we don&#39;t know it yet (until</span>
<span class="cm"> *     we don&#39;t call register_netdev()). So we generate an unique one</span>
<span class="cm"> *     using the driver name and device bus id, place it here and use</span>
<span class="cm"> *     it across the board. Recommended naming:</span>
<span class="cm"> *     DRIVERNAME-BUSNAME:BUSID (dev-&gt;bus-&gt;name, dev-&gt;bus_id).</span>
<span class="cm"> *</span>
<span class="cm"> * @id_table_node: [private] link to the list of wimax devices kept by</span>
<span class="cm"> *     id-table.c. Protected by it&#39;s own spinlock.</span>
<span class="cm"> *</span>
<span class="cm"> * @mutex: [private] Serializes all concurrent access and execution of</span>
<span class="cm"> *     operations.</span>
<span class="cm"> *</span>
<span class="cm"> * @mutex_reset: [private] Serializes reset operations. Needs to be a</span>
<span class="cm"> *     different mutex because as part of the reset operation, the</span>
<span class="cm"> *     driver has to call back into the stack to do things such as</span>
<span class="cm"> *     state change, that require wimax_dev-&gt;mutex.</span>
<span class="cm"> *</span>
<span class="cm"> * @state: [private] Current state of the WiMAX device.</span>
<span class="cm"> *</span>
<span class="cm"> * @rfkill: [private] integration into the RF-Kill infrastructure.</span>
<span class="cm"> *</span>
<span class="cm"> * @rf_sw: [private] State of the software radio switch (OFF/ON)</span>
<span class="cm"> *</span>
<span class="cm"> * @rf_hw: [private] State of the hardware radio switch (OFF/ON)</span>
<span class="cm"> *</span>
<span class="cm"> * @debugfs_dentry: [private] Used to hook up a debugfs entry. This</span>
<span class="cm"> *     shows up in the debugfs root as wimax\:DEVICENAME.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * This structure defines a common interface to access all WiMAX</span>
<span class="cm"> * devices from different vendors and provides a common API as well as</span>
<span class="cm"> * a free-form device-specific messaging channel.</span>
<span class="cm"> *</span>
<span class="cm"> * Usage:</span>
<span class="cm"> *  1. Embed a &amp;struct wimax_dev at *the beginning* the network</span>
<span class="cm"> *     device structure so that netdev_priv() points to it.</span>
<span class="cm"> *</span>
<span class="cm"> *  2. memset() it to zero</span>
<span class="cm"> *</span>
<span class="cm"> *  3. Initialize with wimax_dev_init(). This will leave the WiMAX</span>
<span class="cm"> *     device in the %__WIMAX_ST_NULL state.</span>
<span class="cm"> *</span>
<span class="cm"> *  4. Fill all the fields marked with [fill]; once called</span>
<span class="cm"> *     wimax_dev_add(), those fields CANNOT be modified.</span>
<span class="cm"> *</span>
<span class="cm"> *  5. Call wimax_dev_add() *after* registering the network</span>
<span class="cm"> *     device. This will leave the WiMAX device in the %WIMAX_ST_DOWN</span>
<span class="cm"> *     state.</span>
<span class="cm"> *     Protect the driver&#39;s net_device-&gt;open() against succeeding if</span>
<span class="cm"> *     the wimax device state is lower than %WIMAX_ST_DOWN.</span>
<span class="cm"> *</span>
<span class="cm"> *  6. Select when the device is going to be turned on/initialized;</span>
<span class="cm"> *     for example, it could be initialized on &#39;ifconfig up&#39; (when the</span>
<span class="cm"> *     netdev op &#39;open()&#39; is called on the driver).</span>
<span class="cm"> *</span>
<span class="cm"> * When the device is initialized (at `ifconfig up` time, or right</span>
<span class="cm"> * after calling wimax_dev_add() from _probe(), make sure the</span>
<span class="cm"> * following steps are taken</span>
<span class="cm"> *</span>
<span class="cm"> *  a. Move the device to %WIMAX_ST_UNINITIALIZED. This is needed so</span>
<span class="cm"> *     some API calls that shouldn&#39;t work until the device is ready</span>
<span class="cm"> *     can be blocked.</span>
<span class="cm"> *</span>
<span class="cm"> *  b. Initialize the device. Make sure to turn the SW radio switch</span>
<span class="cm"> *     off and move the device to state %WIMAX_ST_RADIO_OFF when</span>
<span class="cm"> *     done. When just initialized, a device should be left in RADIO</span>
<span class="cm"> *     OFF state until user space devices to turn it on.</span>
<span class="cm"> *</span>
<span class="cm"> *  c. Query the device for the state of the hardware rfkill switch</span>
<span class="cm"> *     and call wimax_rfkill_report_hw() and wimax_rfkill_report_sw()</span>
<span class="cm"> *     as needed. See below.</span>
<span class="cm"> *</span>
<span class="cm"> * wimax_dev_rm() undoes before unregistering the network device. Once</span>
<span class="cm"> * wimax_dev_add() is called, the driver can get called on the</span>
<span class="cm"> * wimax_dev-&gt;op_* function pointers</span>
<span class="cm"> *</span>
<span class="cm"> * CONCURRENCY:</span>
<span class="cm"> *</span>
<span class="cm"> * The stack provides a mutex for each device that will disallow API</span>
<span class="cm"> * calls happening concurrently; thus, op calls into the driver</span>
<span class="cm"> * through the wimax_dev-&gt;op*() function pointers will always be</span>
<span class="cm"> * serialized and *never* concurrent.</span>
<span class="cm"> *</span>
<span class="cm"> * For locking, take wimax_dev-&gt;mutex is taken; (most) operations in</span>
<span class="cm"> * the API have to check for wimax_dev_is_ready() to return 0 before</span>
<span class="cm"> * continuing (this is done internally).</span>
<span class="cm"> *</span>
<span class="cm"> * REFERENCE COUNTING:</span>
<span class="cm"> *</span>
<span class="cm"> * The WiMAX device is reference counted by the associated network</span>
<span class="cm"> * device. The only operation that can be used to reference the device</span>
<span class="cm"> * is wimax_dev_get_by_genl_info(), and the reference it acquires has</span>
<span class="cm"> * to be released with dev_put(wimax_dev-&gt;net_dev).</span>
<span class="cm"> *</span>
<span class="cm"> * RFKILL:</span>
<span class="cm"> *</span>
<span class="cm"> * At startup, both HW and SW radio switchess are assumed to be off.</span>
<span class="cm"> *</span>
<span class="cm"> * At initialization time [after calling wimax_dev_add()], have the</span>
<span class="cm"> * driver query the device for the status of the software and hardware</span>
<span class="cm"> * RF kill switches and call wimax_report_rfkill_hw() and</span>
<span class="cm"> * wimax_rfkill_report_sw() to indicate their state. If any is</span>
<span class="cm"> * missing, just call it to indicate it is ON (radio always on).</span>
<span class="cm"> *</span>
<span class="cm"> * Whenever the driver detects a change in the state of the RF kill</span>
<span class="cm"> * switches, it should call wimax_report_rfkill_hw() or</span>
<span class="cm"> * wimax_report_rfkill_sw() to report it to the stack.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">wimax_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">id_table_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>		<span class="cm">/* Protects all members and API calls */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex_reset</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">wimax_st</span> <span class="n">state</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">op_msg_from_user</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="n">wimax_dev</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">op_rfkill_sw_toggle</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="n">wimax_dev</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">wimax_rf_state</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">op_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="n">wimax_dev</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rf_hw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rf_sw</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_dentry</span><span class="p">;</span>
<span class="p">};</span>



<span class="cm">/*</span>
<span class="cm"> * WiMAX stack public API for device drivers</span>
<span class="cm"> * -----------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * These functions are not exported to user space.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wimax_dev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wimax_dev_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wimax_dev_rm</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="nf">net_dev_to_wimax</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">wimax_dev_to_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="n">wimax_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">wimax_dev</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">wimax_state_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">wimax_st</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">wimax_st</span> <span class="n">wimax_state_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Radio Switch state reporting.</span>
<span class="cm"> *</span>
<span class="cm"> * enum wimax_rf_state is declared in linux/wimax.h so the exports</span>
<span class="cm"> * to user space can use it.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wimax_report_rfkill_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">wimax_rf_state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wimax_report_rfkill_sw</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">wimax_rf_state</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Free-form messaging to/from user space</span>
<span class="cm"> *</span>
<span class="cm"> * Sending a message:</span>
<span class="cm"> *</span>
<span class="cm"> *   wimax_msg(wimax_dev, pipe_name, buf, buf_size, GFP_KERNEL);</span>
<span class="cm"> *</span>
<span class="cm"> * Broken up:</span>
<span class="cm"> *</span>
<span class="cm"> *   skb = wimax_msg_alloc(wimax_dev, pipe_name, buf_size, GFP_KERNEL);</span>
<span class="cm"> *   ...fill up skb...</span>
<span class="cm"> *   wimax_msg_send(wimax_dev, pipe_name, skb);</span>
<span class="cm"> *</span>
<span class="cm"> * Be sure not to modify skb-&gt;data in the middle (ie: don&#39;t use</span>
<span class="cm"> * skb_push()/skb_pull()/skb_reserve() on the skb).</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;pipe_name&quot; is any string, than can be interpreted as the name of</span>
<span class="cm"> * the pipe or destinatary; the interpretation of it is driver</span>
<span class="cm"> * specific, so the recipient can multiplex it as wished. It can be</span>
<span class="cm"> * NULL, it won&#39;t be used - an example is using a &quot;diagnostics&quot; tag to</span>
<span class="cm"> * send diagnostics information that a device-specific diagnostics</span>
<span class="cm"> * tool would be interested in.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">wimax_msg_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wimax_msg_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wimax_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
		     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">wimax_msg_data_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">wimax_msg_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">wimax_msg_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * WiMAX stack user space API</span>
<span class="cm"> * --------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * This API is what gets exported to user space for general</span>
<span class="cm"> * operations. As well, they can be called from within the kernel,</span>
<span class="cm"> * (with a properly referenced `struct wimax_dev`).</span>
<span class="cm"> *</span>
<span class="cm"> * Properly referenced means: the &#39;struct net_device&#39; that embeds the</span>
<span class="cm"> * device&#39;s control structure and (as such) the &#39;struct wimax_dev&#39; is</span>
<span class="cm"> * referenced by the caller.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wimax_rfkill</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">wimax_rf_state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wimax_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* #ifndef __NET__WIMAX_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
