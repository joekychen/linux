<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › net_namespace.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>net_namespace.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Operations on the network namespace</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __NET_NET_NAMESPACE_H</span>
<span class="cp">#define __NET_NET_NAMESPACE_H</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>

<span class="cp">#include &lt;net/netns/core.h&gt;</span>
<span class="cp">#include &lt;net/netns/mib.h&gt;</span>
<span class="cp">#include &lt;net/netns/unix.h&gt;</span>
<span class="cp">#include &lt;net/netns/packet.h&gt;</span>
<span class="cp">#include &lt;net/netns/ipv4.h&gt;</span>
<span class="cp">#include &lt;net/netns/ipv6.h&gt;</span>
<span class="cp">#include &lt;net/netns/dccp.h&gt;</span>
<span class="cp">#include &lt;net/netns/x_tables.h&gt;</span>
<span class="cp">#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)</span>
<span class="cp">#include &lt;net/netns/conntrack.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;net/netns/xfrm.h&gt;</span>

<span class="k">struct</span> <span class="n">proc_dir_entry</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">net_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sock</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ctl_table_header</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">net_generic</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sock</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">netns_ipvs</span><span class="p">;</span>


<span class="cp">#define NETDEV_HASHBITS    8</span>
<span class="cp">#define NETDEV_HASHENTRIES (1 &lt;&lt; NETDEV_HASHBITS)</span>

<span class="k">struct</span> <span class="n">net</span> <span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">passive</span><span class="p">;</span>	<span class="cm">/* To decided when the network</span>
<span class="cm">						 * namespace should be freed.</span>
<span class="cm">						 */</span>
	<span class="n">atomic_t</span>		<span class="n">count</span><span class="p">;</span>		<span class="cm">/* To decided when the network</span>
<span class="cm">						 *  namespace should be shut down.</span>
<span class="cm">						 */</span>
<span class="cp">#ifdef NETNS_REFCNT_DEBUG</span>
	<span class="n">atomic_t</span>		<span class="n">use_count</span><span class="p">;</span>	<span class="cm">/* To track references we</span>
<span class="cm">						 * destroy on demand</span>
<span class="cm">						 */</span>
<span class="cp">#endif</span>
	<span class="n">spinlock_t</span>		<span class="n">rules_mod_lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>		<span class="cm">/* list of network namespaces */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">cleanup_list</span><span class="p">;</span>	<span class="cm">/* namespaces on death row */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">exit_list</span><span class="p">;</span>	<span class="cm">/* Use only net_mutex */</span>

	<span class="k">struct</span> <span class="n">proc_dir_entry</span> 	<span class="o">*</span><span class="n">proc_net</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> 	<span class="o">*</span><span class="n">proc_net_stat</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SYSCTL</span>
	<span class="k">struct</span> <span class="n">ctl_table_set</span>	<span class="n">sysctls</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">sock</span> 		<span class="o">*</span><span class="n">rtnl</span><span class="p">;</span>			<span class="cm">/* rtnetlink socket */</span>
	<span class="k">struct</span> <span class="n">sock</span>		<span class="o">*</span><span class="n">genl_sock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> 	<span class="n">dev_base_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> 	<span class="o">*</span><span class="n">dev_name_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="o">*</span><span class="n">dev_index_head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">dev_base_seq</span><span class="p">;</span>	<span class="cm">/* protected by rtnl_mutex */</span>

	<span class="cm">/* core fib_rules */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">rules_ops</span><span class="p">;</span>


	<span class="k">struct</span> <span class="n">net_device</span>       <span class="o">*</span><span class="n">loopback_dev</span><span class="p">;</span>          <span class="cm">/* The loopback */</span>
	<span class="k">struct</span> <span class="n">netns_core</span>	<span class="n">core</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netns_mib</span>	<span class="n">mib</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netns_packet</span>	<span class="n">packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netns_unix</span>	<span class="n">unx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netns_ipv4</span>	<span class="n">ipv4</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">struct</span> <span class="n">netns_ipv6</span>	<span class="n">ipv6</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(CONFIG_IP_DCCP) || defined(CONFIG_IP_DCCP_MODULE)</span>
	<span class="k">struct</span> <span class="n">netns_dccp</span>	<span class="n">dccp</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_NETFILTER</span>
	<span class="k">struct</span> <span class="n">netns_xt</span>		<span class="n">xt</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)</span>
	<span class="k">struct</span> <span class="n">netns_ct</span>		<span class="n">ct</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">sock</span>		<span class="o">*</span><span class="n">nfnl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span>		<span class="o">*</span><span class="n">nfnl_stash</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_WEXT_CORE</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span>	<span class="n">wext_nlevents</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">net_generic</span> <span class="n">__rcu</span>	<span class="o">*</span><span class="n">gen</span><span class="p">;</span>

	<span class="cm">/* Note : following structs are cache line aligned */</span>
<span class="cp">#ifdef CONFIG_XFRM</span>
	<span class="k">struct</span> <span class="n">netns_xfrm</span>	<span class="n">xfrm</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">netns_ipvs</span>	<span class="o">*</span><span class="n">ipvs</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp">#include &lt;linux/seq_file_net.h&gt;</span>

<span class="cm">/* Init&#39;s network namespace */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">net</span> <span class="n">init_net</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NET</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">copy_net_ns</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net_ns</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_NET */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">copy_net_ns</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net_ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* There is nothing to copy so this is a noop */</span>
	<span class="k">return</span> <span class="n">net_ns</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NET */</span><span class="cp"></span>


<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">net_namespace_list</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">get_net_ns_by_pid</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">get_net_ns_by_fd</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NET_NS</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__put_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">get_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">net</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">maybe_get_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Used when we know struct net exists but we</span>
<span class="cm">	 * aren&#39;t guaranteed a previous reference count</span>
<span class="cm">	 * exists.  If the reference count is zero this</span>
<span class="cm">	 * function fails and returns NULL.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span>
		<span class="n">net</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">net</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span>
		<span class="n">__put_net</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">net_eq</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net1</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">net1</span> <span class="o">==</span> <span class="n">net2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">net_drop_ns</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">get_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">net</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">maybe_get_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">net</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">net_eq</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net1</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define net_drop_ns NULL</span>
<span class="cp">#endif</span>


<span class="cp">#ifdef NETNS_REFCNT_DEBUG</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">hold_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">net</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">release_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net</span><span class="p">)</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">hold_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">net</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">release_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_NET_NS</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_pnet</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">**</span><span class="n">pnet</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">pnet</span> <span class="o">=</span> <span class="n">net</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">read_pnet</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">pnet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">pnet</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cp">#define write_pnet(pnet, net)	do { (void)(net);} while (0)</span>
<span class="cp">#define read_pnet(pnet)		(&amp;init_net)</span>

<span class="cp">#endif</span>

<span class="cp">#define for_each_net(VAR)				\</span>
<span class="cp">	list_for_each_entry(VAR, &amp;net_namespace_list, list)</span>

<span class="cp">#define for_each_net_rcu(VAR)				\</span>
<span class="cp">	list_for_each_entry_rcu(VAR, &amp;net_namespace_list, list)</span>

<span class="cp">#ifdef CONFIG_NET_NS</span>
<span class="cp">#define __net_init</span>
<span class="cp">#define __net_exit</span>
<span class="cp">#define __net_initdata</span>
<span class="cp">#else</span>
<span class="cp">#define __net_init	__init</span>
<span class="cp">#define __net_exit	__exit_refok</span>
<span class="cp">#define __net_initdata	__initdata</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">pernet_operations</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exit</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exit_batch</span><span class="p">)(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">net_exit_list</span><span class="p">);</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">id</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Use these carefully.  If you implement a network device and it</span>
<span class="cm"> * needs per network namespace operations use device pernet operations,</span>
<span class="cm"> * otherwise use pernet subsys operations.</span>
<span class="cm"> *</span>
<span class="cm"> * Network interfaces need to be removed from a dying netns _before_</span>
<span class="cm"> * subsys notifiers can be called, as most of the network code cleanup</span>
<span class="cm"> * (which is done from subsys notifiers) runs with the assumption that</span>
<span class="cm"> * dev_remove_pack has been called so no new packets will arrive during</span>
<span class="cm"> * and after the cleanup functions have been called.  dev_remove_pack</span>
<span class="cm"> * is not per namespace so instead the guarantee of no more packets</span>
<span class="cm"> * arriving in a network namespace is provided by ensuring that all</span>
<span class="cm"> * network devices and all sockets have left the network namespace</span>
<span class="cm"> * before the cleanup methods are called.</span>
<span class="cm"> *</span>
<span class="cm"> * For the longest time the ipv4 icmp code was registered as a pernet</span>
<span class="cm"> * device which caused kernel oops, and panics during network</span>
<span class="cm"> * namespace cleanup.   So please don&#39;t get this wrong.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">register_pernet_subsys</span><span class="p">(</span><span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">unregister_pernet_subsys</span><span class="p">(</span><span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">register_pernet_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">unregister_pernet_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ctl_table</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ctl_table_header</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SYSCTL</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">net_sysctl_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ctl_table_header</span> <span class="o">*</span><span class="n">register_net_sysctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">unregister_net_sysctl_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table_header</span> <span class="o">*</span><span class="n">header</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">net_sysctl_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ctl_table_header</span> <span class="o">*</span><span class="nf">register_net_sysctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unregister_net_sysctl_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table_header</span> <span class="o">*</span><span class="n">header</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="cp">#endif </span><span class="cm">/* __NET_NET_NAMESPACE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
