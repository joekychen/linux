<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › mac80211.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>mac80211.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * mac80211 &lt;-&gt; driver interface</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2002-2005, Devicescape Software, Inc.</span>
<span class="cm"> * Copyright 2006-2007	Jiri Benc &lt;jbenc@suse.cz&gt;</span>
<span class="cm"> * Copyright 2007-2010	Johannes Berg &lt;johannes@sipsolutions.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef MAC80211_H</span>
<span class="cp">#define MAC80211_H</span>

<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/ieee80211.h&gt;</span>
<span class="cp">#include &lt;net/cfg80211.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Introduction</span>
<span class="cm"> *</span>
<span class="cm"> * mac80211 is the Linux stack for 802.11 hardware that implements</span>
<span class="cm"> * only partial functionality in hard- or firmware. This document</span>
<span class="cm"> * defines the interface between mac80211 and low-level hardware</span>
<span class="cm"> * drivers.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Calling mac80211 from interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * Only ieee80211_tx_status_irqsafe() and ieee80211_rx_irqsafe() can be</span>
<span class="cm"> * called in hardware interrupt context. The low-level driver must not call any</span>
<span class="cm"> * other functions in hardware interrupt context. If there is a need for such</span>
<span class="cm"> * call, the low-level driver should first ACK the interrupt and perform the</span>
<span class="cm"> * IEEE 802.11 code call after this, e.g. from a scheduled workqueue or even</span>
<span class="cm"> * tasklet function.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: If the driver opts to use the _irqsafe() functions, it may not also</span>
<span class="cm"> *	 use the non-IRQ-safe functions!</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Warning</span>
<span class="cm"> *</span>
<span class="cm"> * If you&#39;re reading this document and not the header file itself, it will</span>
<span class="cm"> * be incomplete because not all documentation has been converted yet.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Frame format</span>
<span class="cm"> *</span>
<span class="cm"> * As a general rule, when frames are passed between mac80211 and the driver,</span>
<span class="cm"> * they start with the IEEE 802.11 header and include the same octets that are</span>
<span class="cm"> * sent over the air except for the FCS which should be calculated by the</span>
<span class="cm"> * hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * There are, however, various exceptions to this rule for advanced features:</span>
<span class="cm"> *</span>
<span class="cm"> * The first exception is for hardware encryption and decryption offload</span>
<span class="cm"> * where the IV/ICV may or may not be generated in hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * Secondly, when the hardware handles fragmentation, the frame handed to</span>
<span class="cm"> * the driver from mac80211 is the MSDU, not the MPDU.</span>
<span class="cm"> *</span>
<span class="cm"> * Finally, for received frames, the driver is able to indicate that it has</span>
<span class="cm"> * filled a radiotap header and put that in front of the frame; if it does</span>
<span class="cm"> * not do so then mac80211 may add this under certain circumstances.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: mac80211 workqueue</span>
<span class="cm"> *</span>
<span class="cm"> * mac80211 provides its own workqueue for drivers and internal mac80211 use.</span>
<span class="cm"> * The workqueue is a single threaded workqueue and can only be accessed by</span>
<span class="cm"> * helpers for sanity checking. Drivers must ensure all work added onto the</span>
<span class="cm"> * mac80211 workqueue should be cancelled on the driver stop() callback.</span>
<span class="cm"> *</span>
<span class="cm"> * mac80211 will flushed the workqueue upon interface removal and during</span>
<span class="cm"> * suspend.</span>
<span class="cm"> *</span>
<span class="cm"> * All work performed on the mac80211 workqueue must not acquire the RTNL lock.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_max_queues - maximum number of queues</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_MAX_QUEUES: Maximum number of regular device queues.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_max_queues</span> <span class="p">{</span>
	<span class="n">IEEE80211_MAX_QUEUES</span> <span class="o">=</span>		<span class="mi">16</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define IEEE80211_INVAL_HW_QUEUE	0xff</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_ac_numbers - AC numbers as used in mac80211</span>
<span class="cm"> * @IEEE80211_AC_VO: voice</span>
<span class="cm"> * @IEEE80211_AC_VI: video</span>
<span class="cm"> * @IEEE80211_AC_BE: best effort</span>
<span class="cm"> * @IEEE80211_AC_BK: background</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_ac_numbers</span> <span class="p">{</span>
	<span class="n">IEEE80211_AC_VO</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IEEE80211_AC_VI</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IEEE80211_AC_BE</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">IEEE80211_AC_BK</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define IEEE80211_NUM_ACS	4</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_tx_queue_params - transmit queue configuration</span>
<span class="cm"> *</span>
<span class="cm"> * The information provided in this structure is required for QoS</span>
<span class="cm"> * transmit queue configuration. Cf. IEEE 802.11 7.3.2.29.</span>
<span class="cm"> *</span>
<span class="cm"> * @aifs: arbitration interframe space [0..255]</span>
<span class="cm"> * @cw_min: minimum contention window [a value of the form</span>
<span class="cm"> *	2^n-1 in the range 1..32767]</span>
<span class="cm"> * @cw_max: maximum contention window [like @cw_min]</span>
<span class="cm"> * @txop: maximum burst time in units of 32 usecs, 0 meaning disabled</span>
<span class="cm"> * @uapsd: is U-APSD mode enabled for the queue</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_tx_queue_params</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">txop</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cw_min</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cw_max</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">aifs</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">uapsd</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ieee80211_low_level_stats</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dot11ACKFailureCount</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dot11RTSFailureCount</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dot11FCSErrorCount</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dot11RTSSuccessCount</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_bss_change - BSS change notification flags</span>
<span class="cm"> *</span>
<span class="cm"> * These flags are used with the bss_info_changed() callback</span>
<span class="cm"> * to indicate which BSS parameter changed.</span>
<span class="cm"> *</span>
<span class="cm"> * @BSS_CHANGED_ASSOC: association status changed (associated/disassociated),</span>
<span class="cm"> *	also implies a change in the AID.</span>
<span class="cm"> * @BSS_CHANGED_ERP_CTS_PROT: CTS protection changed</span>
<span class="cm"> * @BSS_CHANGED_ERP_PREAMBLE: preamble changed</span>
<span class="cm"> * @BSS_CHANGED_ERP_SLOT: slot timing changed</span>
<span class="cm"> * @BSS_CHANGED_HT: 802.11n parameters changed</span>
<span class="cm"> * @BSS_CHANGED_BASIC_RATES: Basic rateset changed</span>
<span class="cm"> * @BSS_CHANGED_BEACON_INT: Beacon interval changed</span>
<span class="cm"> * @BSS_CHANGED_BSSID: BSSID changed, for whatever</span>
<span class="cm"> *	reason (IBSS and managed mode)</span>
<span class="cm"> * @BSS_CHANGED_BEACON: Beacon data changed, retrieve</span>
<span class="cm"> *	new beacon (beaconing modes)</span>
<span class="cm"> * @BSS_CHANGED_BEACON_ENABLED: Beaconing should be</span>
<span class="cm"> *	enabled/disabled (beaconing modes)</span>
<span class="cm"> * @BSS_CHANGED_CQM: Connection quality monitor config changed</span>
<span class="cm"> * @BSS_CHANGED_IBSS: IBSS join status changed</span>
<span class="cm"> * @BSS_CHANGED_ARP_FILTER: Hardware ARP filter address list or state changed.</span>
<span class="cm"> * @BSS_CHANGED_QOS: QoS for this association was enabled/disabled. Note</span>
<span class="cm"> *	that it is only ever disabled for station mode.</span>
<span class="cm"> * @BSS_CHANGED_IDLE: Idle changed for this BSS/interface.</span>
<span class="cm"> * @BSS_CHANGED_SSID: SSID changed for this BSS (AP mode)</span>
<span class="cm"> * @BSS_CHANGED_AP_PROBE_RESP: Probe Response changed for this BSS (AP mode)</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_bss_change</span> <span class="p">{</span>
	<span class="n">BSS_CHANGED_ASSOC</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>
	<span class="n">BSS_CHANGED_ERP_CTS_PROT</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">BSS_CHANGED_ERP_PREAMBLE</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span>
	<span class="n">BSS_CHANGED_ERP_SLOT</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span>
	<span class="n">BSS_CHANGED_HT</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">,</span>
	<span class="n">BSS_CHANGED_BASIC_RATES</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">,</span>
	<span class="n">BSS_CHANGED_BEACON_INT</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">,</span>
	<span class="n">BSS_CHANGED_BSSID</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">,</span>
	<span class="n">BSS_CHANGED_BEACON</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">,</span>
	<span class="n">BSS_CHANGED_BEACON_ENABLED</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">,</span>
	<span class="n">BSS_CHANGED_CQM</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">,</span>
	<span class="n">BSS_CHANGED_IBSS</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">11</span><span class="p">,</span>
	<span class="n">BSS_CHANGED_ARP_FILTER</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">12</span><span class="p">,</span>
	<span class="n">BSS_CHANGED_QOS</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">13</span><span class="p">,</span>
	<span class="n">BSS_CHANGED_IDLE</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">14</span><span class="p">,</span>
	<span class="n">BSS_CHANGED_SSID</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">15</span><span class="p">,</span>
	<span class="n">BSS_CHANGED_AP_PROBE_RESP</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">,</span>

	<span class="cm">/* when adding here, make sure to change ieee80211_reconfig */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The maximum number of IPv4 addresses listed for ARP filtering. If the number</span>
<span class="cm"> * of addresses for an interface increase beyond this value, hardware ARP</span>
<span class="cm"> * filtering will be disabled.</span>
<span class="cm"> */</span>
<span class="cp">#define IEEE80211_BSS_ARP_ADDR_LIST_LEN 4</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_rssi_event - RSSI threshold event</span>
<span class="cm"> * An indicator for when RSSI goes below/above a certain threshold.</span>
<span class="cm"> * @RSSI_EVENT_HIGH: AP&#39;s rssi crossed the high threshold set by the driver.</span>
<span class="cm"> * @RSSI_EVENT_LOW: AP&#39;s rssi crossed the low threshold set by the driver.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_rssi_event</span> <span class="p">{</span>
	<span class="n">RSSI_EVENT_HIGH</span><span class="p">,</span>
	<span class="n">RSSI_EVENT_LOW</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_bss_conf - holds the BSS&#39;s changing parameters</span>
<span class="cm"> *</span>
<span class="cm"> * This structure keeps information about a BSS (and an association</span>
<span class="cm"> * to that BSS) that can change during the lifetime of the BSS.</span>
<span class="cm"> *</span>
<span class="cm"> * @assoc: association status</span>
<span class="cm"> * @ibss_joined: indicates whether this station is part of an IBSS</span>
<span class="cm"> *	or not</span>
<span class="cm"> * @aid: association ID number, valid only when @assoc is true</span>
<span class="cm"> * @use_cts_prot: use CTS protection</span>
<span class="cm"> * @use_short_preamble: use 802.11b short preamble;</span>
<span class="cm"> *	if the hardware cannot handle this it must set the</span>
<span class="cm"> *	IEEE80211_HW_2GHZ_SHORT_PREAMBLE_INCAPABLE hardware flag</span>
<span class="cm"> * @use_short_slot: use short slot time (only relevant for ERP);</span>
<span class="cm"> *	if the hardware cannot handle this it must set the</span>
<span class="cm"> *	IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE hardware flag</span>
<span class="cm"> * @dtim_period: num of beacons before the next DTIM, for beaconing,</span>
<span class="cm"> *	valid in station mode only while @assoc is true and if also</span>
<span class="cm"> *	requested by %IEEE80211_HW_NEED_DTIM_PERIOD (cf. also hw conf</span>
<span class="cm"> *	@ps_dtim_period)</span>
<span class="cm"> * @last_tsf: last beacon&#39;s/probe response&#39;s TSF timestamp (could be old</span>
<span class="cm"> *	as it may have been received during scanning long ago)</span>
<span class="cm"> * @beacon_int: beacon interval</span>
<span class="cm"> * @assoc_capability: capabilities taken from assoc resp</span>
<span class="cm"> * @basic_rates: bitmap of basic rates, each bit stands for an</span>
<span class="cm"> *	index into the rate table configured by the driver in</span>
<span class="cm"> *	the current band.</span>
<span class="cm"> * @mcast_rate: per-band multicast rate index + 1 (0: disabled)</span>
<span class="cm"> * @bssid: The BSSID for this BSS</span>
<span class="cm"> * @enable_beacon: whether beaconing should be enabled or not</span>
<span class="cm"> * @channel_type: Channel type for this BSS -- the hardware might be</span>
<span class="cm"> *	configured for HT40+ while this BSS only uses no-HT, for</span>
<span class="cm"> *	example.</span>
<span class="cm"> * @ht_operation_mode: HT operation mode like in &amp;struct ieee80211_ht_operation.</span>
<span class="cm"> *	This field is only valid when the channel type is one of the HT types.</span>
<span class="cm"> * @cqm_rssi_thold: Connection quality monitor RSSI threshold, a zero value</span>
<span class="cm"> *	implies disabled</span>
<span class="cm"> * @cqm_rssi_hyst: Connection quality monitor RSSI hysteresis</span>
<span class="cm"> * @arp_addr_list: List of IPv4 addresses for hardware ARP filtering. The</span>
<span class="cm"> *	may filter ARP queries targeted for other addresses than listed here.</span>
<span class="cm"> *	The driver must allow ARP queries targeted for all address listed here</span>
<span class="cm"> *	to pass through. An empty list implies no ARP queries need to pass.</span>
<span class="cm"> * @arp_addr_cnt: Number of addresses currently on the list.</span>
<span class="cm"> * @arp_filter_enabled: Enable ARP filtering - if enabled, the hardware may</span>
<span class="cm"> *	filter ARP queries based on the @arp_addr_list, if disabled, the</span>
<span class="cm"> *	hardware must not perform any ARP filtering. Note, that the filter will</span>
<span class="cm"> *	be enabled also in promiscuous mode.</span>
<span class="cm"> * @qos: This is a QoS-enabled BSS.</span>
<span class="cm"> * @idle: This interface is idle. There&#39;s also a global idle flag in the</span>
<span class="cm"> *	hardware config which may be more appropriate depending on what</span>
<span class="cm"> *	your driver/device needs to do.</span>
<span class="cm"> * @ssid: The SSID of the current vif. Only valid in AP-mode.</span>
<span class="cm"> * @ssid_len: Length of SSID given in @ssid.</span>
<span class="cm"> * @hidden_ssid: The SSID of the current vif is hidden. Only valid in AP-mode.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_bss_conf</span> <span class="p">{</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">;</span>
	<span class="cm">/* association related data */</span>
	<span class="n">bool</span> <span class="n">assoc</span><span class="p">,</span> <span class="n">ibss_joined</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">aid</span><span class="p">;</span>
	<span class="cm">/* erp related data */</span>
	<span class="n">bool</span> <span class="n">use_cts_prot</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">use_short_preamble</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">use_short_slot</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">enable_beacon</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dtim_period</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">beacon_int</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">assoc_capability</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last_tsf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">basic_rates</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mcast_rate</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">ht_operation_mode</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">cqm_rssi_thold</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cqm_rssi_hyst</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">channel_type</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">arp_addr_list</span><span class="p">[</span><span class="n">IEEE80211_BSS_ARP_ADDR_LIST_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">arp_addr_cnt</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">arp_filter_enabled</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">qos</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">idle</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ssid</span><span class="p">[</span><span class="n">IEEE80211_MAX_SSID_LEN</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">ssid_len</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">hidden_ssid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum mac80211_tx_control_flags - flags to describe transmission information/status</span>
<span class="cm"> *</span>
<span class="cm"> * These flags are used with the @flags member of &amp;ieee80211_tx_info.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_TX_CTL_REQ_TX_STATUS: require TX status callback for this frame.</span>
<span class="cm"> * @IEEE80211_TX_CTL_ASSIGN_SEQ: The driver has to assign a sequence</span>
<span class="cm"> *	number to this frame, taking care of not overwriting the fragment</span>
<span class="cm"> *	number and increasing the sequence number only when the</span>
<span class="cm"> *	IEEE80211_TX_CTL_FIRST_FRAGMENT flag is set. mac80211 will properly</span>
<span class="cm"> *	assign sequence numbers to QoS-data frames but cannot do so correctly</span>
<span class="cm"> *	for non-QoS-data and management frames because beacons need them from</span>
<span class="cm"> *	that counter as well and mac80211 cannot guarantee proper sequencing.</span>
<span class="cm"> *	If this flag is set, the driver should instruct the hardware to</span>
<span class="cm"> *	assign a sequence number to the frame or assign one itself. Cf. IEEE</span>
<span class="cm"> *	802.11-2007 7.1.3.4.1 paragraph 3. This flag will always be set for</span>
<span class="cm"> *	beacons and always be clear for frames without a sequence number field.</span>
<span class="cm"> * @IEEE80211_TX_CTL_NO_ACK: tell the low level not to wait for an ack</span>
<span class="cm"> * @IEEE80211_TX_CTL_CLEAR_PS_FILT: clear powersave filter for destination</span>
<span class="cm"> *	station</span>
<span class="cm"> * @IEEE80211_TX_CTL_FIRST_FRAGMENT: this is a first fragment of the frame</span>
<span class="cm"> * @IEEE80211_TX_CTL_SEND_AFTER_DTIM: send this frame after DTIM beacon</span>
<span class="cm"> * @IEEE80211_TX_CTL_AMPDU: this frame should be sent as part of an A-MPDU</span>
<span class="cm"> * @IEEE80211_TX_CTL_INJECTED: Frame was injected, internal to mac80211.</span>
<span class="cm"> * @IEEE80211_TX_STAT_TX_FILTERED: The frame was not transmitted</span>
<span class="cm"> *	because the destination STA was in powersave mode. Note that to</span>
<span class="cm"> *	avoid race conditions, the filter must be set by the hardware or</span>
<span class="cm"> *	firmware upon receiving a frame that indicates that the station</span>
<span class="cm"> *	went to sleep (must be done on device to filter frames already on</span>
<span class="cm"> *	the queue) and may only be unset after mac80211 gives the OK for</span>
<span class="cm"> *	that by setting the IEEE80211_TX_CTL_CLEAR_PS_FILT (see above),</span>
<span class="cm"> *	since only then is it guaranteed that no more frames are in the</span>
<span class="cm"> *	hardware queue.</span>
<span class="cm"> * @IEEE80211_TX_STAT_ACK: Frame was acknowledged</span>
<span class="cm"> * @IEEE80211_TX_STAT_AMPDU: The frame was aggregated, so status</span>
<span class="cm"> * 	is for the whole aggregation.</span>
<span class="cm"> * @IEEE80211_TX_STAT_AMPDU_NO_BACK: no block ack was returned,</span>
<span class="cm"> * 	so consider using block ack request (BAR).</span>
<span class="cm"> * @IEEE80211_TX_CTL_RATE_CTRL_PROBE: internal to mac80211, can be</span>
<span class="cm"> *	set by rate control algorithms to indicate probe rate, will</span>
<span class="cm"> *	be cleared for fragmented frames (except on the last fragment)</span>
<span class="cm"> * @IEEE80211_TX_INTFL_NEED_TXPROCESSING: completely internal to mac80211,</span>
<span class="cm"> *	used to indicate that a pending frame requires TX processing before</span>
<span class="cm"> *	it can be sent out.</span>
<span class="cm"> * @IEEE80211_TX_INTFL_RETRIED: completely internal to mac80211,</span>
<span class="cm"> *	used to indicate that a frame was already retried due to PS</span>
<span class="cm"> * @IEEE80211_TX_INTFL_DONT_ENCRYPT: completely internal to mac80211,</span>
<span class="cm"> *	used to indicate frame should not be encrypted</span>
<span class="cm"> * @IEEE80211_TX_CTL_NO_PS_BUFFER: This frame is a response to a poll</span>
<span class="cm"> *	frame (PS-Poll or uAPSD) or a non-bufferable MMPDU and must</span>
<span class="cm"> *	be sent although the station is in powersave mode.</span>
<span class="cm"> * @IEEE80211_TX_CTL_MORE_FRAMES: More frames will be passed to the</span>
<span class="cm"> *	transmit function after the current frame, this can be used</span>
<span class="cm"> *	by drivers to kick the DMA queue only if unset or when the</span>
<span class="cm"> *	queue gets full.</span>
<span class="cm"> * @IEEE80211_TX_INTFL_RETRANSMISSION: This frame is being retransmitted</span>
<span class="cm"> *	after TX status because the destination was asleep, it must not</span>
<span class="cm"> *	be modified again (no seqno assignment, crypto, etc.)</span>
<span class="cm"> * @IEEE80211_TX_INTFL_NL80211_FRAME_TX: Frame was requested through nl80211</span>
<span class="cm"> *	MLME command (internal to mac80211 to figure out whether to send TX</span>
<span class="cm"> *	status to user space)</span>
<span class="cm"> * @IEEE80211_TX_CTL_LDPC: tells the driver to use LDPC for this frame</span>
<span class="cm"> * @IEEE80211_TX_CTL_STBC: Enables Space-Time Block Coding (STBC) for this</span>
<span class="cm"> *	frame and selects the maximum number of streams that it can use.</span>
<span class="cm"> * @IEEE80211_TX_CTL_TX_OFFCHAN: Marks this packet to be transmitted on</span>
<span class="cm"> *	the off-channel channel when a remain-on-channel offload is done</span>
<span class="cm"> *	in hardware -- normal packets still flow and are expected to be</span>
<span class="cm"> *	handled properly by the device.</span>
<span class="cm"> * @IEEE80211_TX_INTFL_TKIP_MIC_FAILURE: Marks this packet to be used for TKIP</span>
<span class="cm"> *	testing. It will be sent out with incorrect Michael MIC key to allow</span>
<span class="cm"> *	TKIP countermeasures to be tested.</span>
<span class="cm"> * @IEEE80211_TX_CTL_NO_CCK_RATE: This frame will be sent at non CCK rate.</span>
<span class="cm"> *	This flag is actually used for management frame especially for P2P</span>
<span class="cm"> *	frames not being sent at CCK rate in 2GHz band.</span>
<span class="cm"> * @IEEE80211_TX_STATUS_EOSP: This packet marks the end of service period,</span>
<span class="cm"> *	when its status is reported the service period ends. For frames in</span>
<span class="cm"> *	an SP that mac80211 transmits, it is already set; for driver frames</span>
<span class="cm"> *	the driver may set this flag. It is also used to do the same for</span>
<span class="cm"> *	PS-Poll responses.</span>
<span class="cm"> * @IEEE80211_TX_CTL_USE_MINRATE: This frame will be sent at lowest rate.</span>
<span class="cm"> *	This flag is used to send nullfunc frame at minimum rate when</span>
<span class="cm"> *	the nullfunc is used for connection monitoring purpose.</span>
<span class="cm"> * @IEEE80211_TX_CTL_DONTFRAG: Don&#39;t fragment this packet even if it</span>
<span class="cm"> *	would be fragmented by size (this is optional, only used for</span>
<span class="cm"> *	monitor injection).</span>
<span class="cm"> *</span>
<span class="cm"> * Note: If you have to add new flags to the enumeration, then don&#39;t</span>
<span class="cm"> *	 forget to update %IEEE80211_TX_TEMPORARY_FLAGS when necessary.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">mac80211_tx_control_flags</span> <span class="p">{</span>
	<span class="n">IEEE80211_TX_CTL_REQ_TX_STATUS</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_CTL_ASSIGN_SEQ</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_CTL_NO_ACK</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_CTL_CLEAR_PS_FILT</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_CTL_FIRST_FRAGMENT</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_CTL_SEND_AFTER_DTIM</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_CTL_AMPDU</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_CTL_INJECTED</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_STAT_TX_FILTERED</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_STAT_ACK</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_STAT_AMPDU</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_STAT_AMPDU_NO_BACK</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">11</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_CTL_RATE_CTRL_PROBE</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_INTFL_NEED_TXPROCESSING</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">14</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_INTFL_RETRIED</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_INTFL_DONT_ENCRYPT</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_CTL_NO_PS_BUFFER</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">17</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_CTL_MORE_FRAMES</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">18</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_INTFL_RETRANSMISSION</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">19</span><span class="p">),</span>
	<span class="cm">/* hole at 20, use later */</span>
	<span class="n">IEEE80211_TX_INTFL_NL80211_FRAME_TX</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">21</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_CTL_LDPC</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">22</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_CTL_STBC</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">24</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_CTL_TX_OFFCHAN</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">25</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_INTFL_TKIP_MIC_FAILURE</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">26</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_CTL_NO_CCK_RATE</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">27</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_STATUS_EOSP</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">28</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_CTL_USE_MINRATE</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">29</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_CTL_DONTFRAG</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
<span class="p">};</span>

<span class="cp">#define IEEE80211_TX_CTL_STBC_SHIFT		23</span>

<span class="cm">/*</span>
<span class="cm"> * This definition is used as a mask to clear all temporary flags, which are</span>
<span class="cm"> * set by the tx handlers for each transmission attempt by the mac80211 stack.</span>
<span class="cm"> */</span>
<span class="cp">#define IEEE80211_TX_TEMPORARY_FLAGS (IEEE80211_TX_CTL_NO_ACK |		      \</span>
<span class="cp">	IEEE80211_TX_CTL_CLEAR_PS_FILT | IEEE80211_TX_CTL_FIRST_FRAGMENT |    \</span>
<span class="cp">	IEEE80211_TX_CTL_SEND_AFTER_DTIM | IEEE80211_TX_CTL_AMPDU |	      \</span>
<span class="cp">	IEEE80211_TX_STAT_TX_FILTERED |	IEEE80211_TX_STAT_ACK |		      \</span>
<span class="cp">	IEEE80211_TX_STAT_AMPDU | IEEE80211_TX_STAT_AMPDU_NO_BACK |	      \</span>
<span class="cp">	IEEE80211_TX_CTL_RATE_CTRL_PROBE | IEEE80211_TX_CTL_NO_PS_BUFFER |    \</span>
<span class="cp">	IEEE80211_TX_CTL_MORE_FRAMES | IEEE80211_TX_CTL_LDPC |		      \</span>
<span class="cp">	IEEE80211_TX_CTL_STBC | IEEE80211_TX_STATUS_EOSP)</span>

<span class="cm">/**</span>
<span class="cm"> * enum mac80211_rate_control_flags - per-rate flags set by the</span>
<span class="cm"> *	Rate Control algorithm.</span>
<span class="cm"> *</span>
<span class="cm"> * These flags are set by the Rate control algorithm for each rate during tx,</span>
<span class="cm"> * in the @flags member of struct ieee80211_tx_rate.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_TX_RC_USE_RTS_CTS: Use RTS/CTS exchange for this rate.</span>
<span class="cm"> * @IEEE80211_TX_RC_USE_CTS_PROTECT: CTS-to-self protection is required.</span>
<span class="cm"> *	This is set if the current BSS requires ERP protection.</span>
<span class="cm"> * @IEEE80211_TX_RC_USE_SHORT_PREAMBLE: Use short preamble.</span>
<span class="cm"> * @IEEE80211_TX_RC_MCS: HT rate.</span>
<span class="cm"> * @IEEE80211_TX_RC_GREEN_FIELD: Indicates whether this rate should be used in</span>
<span class="cm"> *	Greenfield mode.</span>
<span class="cm"> * @IEEE80211_TX_RC_40_MHZ_WIDTH: Indicates if the Channel Width should be 40 MHz.</span>
<span class="cm"> * @IEEE80211_TX_RC_DUP_DATA: The frame should be transmitted on both of the</span>
<span class="cm"> *	adjacent 20 MHz channels, if the current channel type is</span>
<span class="cm"> *	NL80211_CHAN_HT40MINUS or NL80211_CHAN_HT40PLUS.</span>
<span class="cm"> * @IEEE80211_TX_RC_SHORT_GI: Short Guard interval should be used for this rate.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">mac80211_rate_control_flags</span> <span class="p">{</span>
	<span class="n">IEEE80211_TX_RC_USE_RTS_CTS</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_RC_USE_CTS_PROTECT</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_RC_USE_SHORT_PREAMBLE</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>

	<span class="cm">/* rate index is an MCS rate number instead of an index */</span>
	<span class="n">IEEE80211_TX_RC_MCS</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_RC_GREEN_FIELD</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_RC_40_MHZ_WIDTH</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_RC_DUP_DATA</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
	<span class="n">IEEE80211_TX_RC_SHORT_GI</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
<span class="p">};</span>


<span class="cm">/* there are 40 bytes if you don&#39;t need the rateset to be kept */</span>
<span class="cp">#define IEEE80211_TX_INFO_DRIVER_DATA_SIZE 40</span>

<span class="cm">/* if you do need the rateset, then you have less space */</span>
<span class="cp">#define IEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE 24</span>

<span class="cm">/* maximum number of rate stages */</span>
<span class="cp">#define IEEE80211_TX_MAX_RATES	5</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_tx_rate - rate selection/status</span>
<span class="cm"> *</span>
<span class="cm"> * @idx: rate index to attempt to send with</span>
<span class="cm"> * @flags: rate control flags (&amp;enum mac80211_rate_control_flags)</span>
<span class="cm"> * @count: number of tries in this rate before going to the next rate</span>
<span class="cm"> *</span>
<span class="cm"> * A value of -1 for @idx indicates an invalid rate and, if used</span>
<span class="cm"> * in an array of retry rates, that no more rates should be tried.</span>
<span class="cm"> *</span>
<span class="cm"> * When used for transmit status reporting, the driver should</span>
<span class="cm"> * always report the rate along with the flags it used.</span>
<span class="cm"> *</span>
<span class="cm"> * &amp;struct ieee80211_tx_info contains an array of these structs</span>
<span class="cm"> * in the control information, and it will be filled by the rate</span>
<span class="cm"> * control algorithm according to what should be sent. For example,</span>
<span class="cm"> * if this array contains, in the format { &lt;idx&gt;, &lt;count&gt; } the</span>
<span class="cm"> * information</span>
<span class="cm"> *    { 3, 2 }, { 2, 2 }, { 1, 4 }, { -1, 0 }, { -1, 0 }</span>
<span class="cm"> * then this means that the frame should be transmitted</span>
<span class="cm"> * up to twice at rate 3, up to twice at rate 2, and up to four</span>
<span class="cm"> * times at rate 1 if it doesn&#39;t get acknowledged. Say it gets</span>
<span class="cm"> * acknowledged by the peer after the fifth attempt, the status</span>
<span class="cm"> * information should then contain</span>
<span class="cm"> *   { 3, 2 }, { 2, 2 }, { 1, 1 }, { -1, 0 } ...</span>
<span class="cm"> * since it was transmitted twice at rate 3, twice at rate 2</span>
<span class="cm"> * and once at rate 1 after which we received an acknowledgement.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_tx_rate</span> <span class="p">{</span>
	<span class="n">s8</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_tx_info - skb transmit information</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is placed in skb-&gt;cb for three uses:</span>
<span class="cm"> *  (1) mac80211 TX control - mac80211 tells the driver what to do</span>
<span class="cm"> *  (2) driver internal use (if applicable)</span>
<span class="cm"> *  (3) TX status information - driver tells mac80211 what happened</span>
<span class="cm"> *</span>
<span class="cm"> * The TX control&#39;s sta pointer is only valid during the -&gt;tx call,</span>
<span class="cm"> * it may be NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * @flags: transmit info flags, defined above</span>
<span class="cm"> * @band: the band to transmit on (use for checking for races)</span>
<span class="cm"> * @hw_queue: HW queue to put the frame on, skb_get_queue_mapping() gives the AC</span>
<span class="cm"> * @ack_frame_id: internal frame ID for TX status, used internally</span>
<span class="cm"> * @control: union for control data</span>
<span class="cm"> * @status: union for status data</span>
<span class="cm"> * @driver_data: array of driver_data pointers</span>
<span class="cm"> * @ampdu_ack_len: number of acked aggregated frames.</span>
<span class="cm"> * 	relevant only if IEEE80211_TX_STAT_AMPDU was set.</span>
<span class="cm"> * @ampdu_len: number of aggregated frames.</span>
<span class="cm"> * 	relevant only if IEEE80211_TX_STAT_AMPDU was set.</span>
<span class="cm"> * @ack_signal: signal strength of the ACK frame</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="p">{</span>
	<span class="cm">/* common information */</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">band</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">hw_queue</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">ack_frame_id</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">union</span> <span class="p">{</span>
				<span class="cm">/* rate control */</span>
				<span class="k">struct</span> <span class="p">{</span>
					<span class="k">struct</span> <span class="n">ieee80211_tx_rate</span> <span class="n">rates</span><span class="p">[</span>
						<span class="n">IEEE80211_TX_MAX_RATES</span><span class="p">];</span>
					<span class="n">s8</span> <span class="n">rts_cts_rate_idx</span><span class="p">;</span>
				<span class="p">};</span>
				<span class="cm">/* only needed before rate control */</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="p">};</span>
			<span class="cm">/* NB: vif can be NULL for injected frames */</span>
			<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">hw_key</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">control</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ieee80211_tx_rate</span> <span class="n">rates</span><span class="p">[</span><span class="n">IEEE80211_TX_MAX_RATES</span><span class="p">];</span>
			<span class="n">u8</span> <span class="n">ampdu_ack_len</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">ack_signal</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">ampdu_len</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">antenna</span><span class="p">;</span>
			<span class="cm">/* 14 bytes free */</span>
		<span class="p">}</span> <span class="n">status</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ieee80211_tx_rate</span> <span class="n">driver_rates</span><span class="p">[</span>
				<span class="n">IEEE80211_TX_MAX_RATES</span><span class="p">];</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">rate_driver_data</span><span class="p">[</span>
				<span class="n">IEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)];</span>
		<span class="p">};</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">driver_data</span><span class="p">[</span>
			<span class="n">IEEE80211_TX_INFO_DRIVER_DATA_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)];</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_sched_scan_ies - scheduled scan IEs</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is used to pass the appropriate IEs to be used in scheduled</span>
<span class="cm"> * scans for all bands.  It contains both the IEs passed from the userspace</span>
<span class="cm"> * and the ones generated by mac80211.</span>
<span class="cm"> *</span>
<span class="cm"> * @ie: array with the IEs for each supported band</span>
<span class="cm"> * @len: array with the total length of the IEs for each band</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_sched_scan_ies</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="nf">IEEE80211_SKB_CB</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ieee80211_rx_status</span> <span class="o">*</span><span class="nf">IEEE80211_SKB_RXCB</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_rx_status</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_tx_info_clear_status - clear TX status</span>
<span class="cm"> *</span>
<span class="cm"> * @info: The &amp;struct ieee80211_tx_info to be cleared.</span>
<span class="cm"> *</span>
<span class="cm"> * When the driver passes an skb back to mac80211, it must report</span>
<span class="cm"> * a number of things in TX status. This function clears everything</span>
<span class="cm"> * in the TX status but the rate control information (it does clear</span>
<span class="cm"> * the count since you need to fill that in anyway).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: You can only use this function if you do NOT use</span>
<span class="cm"> *	 info-&gt;driver_data! Use info-&gt;rate_driver_data</span>
<span class="cm"> *	 instead if you need only the less space that allows.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ieee80211_tx_info_clear_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_tx_info</span><span class="p">,</span> <span class="n">status</span><span class="p">.</span><span class="n">rates</span><span class="p">)</span> <span class="o">!=</span>
		     <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_tx_info</span><span class="p">,</span> <span class="n">control</span><span class="p">.</span><span class="n">rates</span><span class="p">));</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_tx_info</span><span class="p">,</span> <span class="n">status</span><span class="p">.</span><span class="n">rates</span><span class="p">)</span> <span class="o">!=</span>
		     <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_tx_info</span><span class="p">,</span> <span class="n">driver_rates</span><span class="p">));</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_tx_info</span><span class="p">,</span> <span class="n">status</span><span class="p">.</span><span class="n">rates</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">);</span>
	<span class="cm">/* clear the rate counts */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IEEE80211_TX_MAX_RATES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">rates</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span>
	    <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_tx_info</span><span class="p">,</span> <span class="n">status</span><span class="p">.</span><span class="n">ampdu_ack_len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">23</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">ampdu_ack_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_tx_info</span><span class="p">)</span> <span class="o">-</span>
	       <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_tx_info</span><span class="p">,</span> <span class="n">status</span><span class="p">.</span><span class="n">ampdu_ack_len</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * enum mac80211_rx_flags - receive flags</span>
<span class="cm"> *</span>
<span class="cm"> * These flags are used with the @flag member of &amp;struct ieee80211_rx_status.</span>
<span class="cm"> * @RX_FLAG_MMIC_ERROR: Michael MIC error was reported on this frame.</span>
<span class="cm"> *	Use together with %RX_FLAG_MMIC_STRIPPED.</span>
<span class="cm"> * @RX_FLAG_DECRYPTED: This frame was decrypted in hardware.</span>
<span class="cm"> * @RX_FLAG_MMIC_STRIPPED: the Michael MIC is stripped off this frame,</span>
<span class="cm"> *	verification has been done by the hardware.</span>
<span class="cm"> * @RX_FLAG_IV_STRIPPED: The IV/ICV are stripped from this frame.</span>
<span class="cm"> *	If this flag is set, the stack cannot do any replay detection</span>
<span class="cm"> *	hence the driver or hardware will have to do that.</span>
<span class="cm"> * @RX_FLAG_FAILED_FCS_CRC: Set this flag if the FCS check failed on</span>
<span class="cm"> *	the frame.</span>
<span class="cm"> * @RX_FLAG_FAILED_PLCP_CRC: Set this flag if the PCLP check failed on</span>
<span class="cm"> *	the frame.</span>
<span class="cm"> * @RX_FLAG_MACTIME_MPDU: The timestamp passed in the RX status (@mactime</span>
<span class="cm"> *	field) is valid and contains the time the first symbol of the MPDU</span>
<span class="cm"> *	was received. This is useful in monitor mode and for proper IBSS</span>
<span class="cm"> *	merging.</span>
<span class="cm"> * @RX_FLAG_SHORTPRE: Short preamble was used for this frame</span>
<span class="cm"> * @RX_FLAG_HT: HT MCS was used and rate_idx is MCS index</span>
<span class="cm"> * @RX_FLAG_40MHZ: HT40 (40 MHz) was used</span>
<span class="cm"> * @RX_FLAG_SHORT_GI: Short guard interval was used</span>
<span class="cm"> * @RX_FLAG_NO_SIGNAL_VAL: The signal strength value is not present.</span>
<span class="cm"> *	Valid only for data frames (mainly A-MPDU)</span>
<span class="cm"> * @RX_FLAG_HT_GF: This frame was received in a HT-greenfield transmission, if</span>
<span class="cm"> *	the driver fills this value it should add %IEEE80211_RADIOTAP_MCS_HAVE_FMT</span>
<span class="cm"> *	to hw.radiotap_mcs_details to advertise that fact</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">mac80211_rx_flags</span> <span class="p">{</span>
	<span class="n">RX_FLAG_MMIC_ERROR</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>
	<span class="n">RX_FLAG_DECRYPTED</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">RX_FLAG_MMIC_STRIPPED</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span>
	<span class="n">RX_FLAG_IV_STRIPPED</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">,</span>
	<span class="n">RX_FLAG_FAILED_FCS_CRC</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">,</span>
	<span class="n">RX_FLAG_FAILED_PLCP_CRC</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">,</span>
	<span class="n">RX_FLAG_MACTIME_MPDU</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">,</span>
	<span class="n">RX_FLAG_SHORTPRE</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">,</span>
	<span class="n">RX_FLAG_HT</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">,</span>
	<span class="n">RX_FLAG_40MHZ</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">,</span>
	<span class="n">RX_FLAG_SHORT_GI</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">11</span><span class="p">,</span>
	<span class="n">RX_FLAG_NO_SIGNAL_VAL</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">12</span><span class="p">,</span>
	<span class="n">RX_FLAG_HT_GF</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">13</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_rx_status - receive status</span>
<span class="cm"> *</span>
<span class="cm"> * The low-level driver should provide this information (the subset</span>
<span class="cm"> * supported by hardware) to the 802.11 code with each received</span>
<span class="cm"> * frame, in the skb&#39;s control buffer (cb).</span>
<span class="cm"> *</span>
<span class="cm"> * @mactime: value in microseconds of the 64-bit Time Synchronization Function</span>
<span class="cm"> * 	(TSF) timer when the first data symbol (MPDU) arrived at the hardware.</span>
<span class="cm"> * @band: the active band when this frame was received</span>
<span class="cm"> * @freq: frequency the radio was tuned to when receiving this frame, in MHz</span>
<span class="cm"> * @signal: signal strength when receiving this frame, either in dBm, in dB or</span>
<span class="cm"> *	unspecified depending on the hardware capabilities flags</span>
<span class="cm"> *	@IEEE80211_HW_SIGNAL_*</span>
<span class="cm"> * @antenna: antenna used</span>
<span class="cm"> * @rate_idx: index of data rate into band&#39;s supported rates or MCS index if</span>
<span class="cm"> *	HT rates are use (RX_FLAG_HT)</span>
<span class="cm"> * @flag: %RX_FLAG_*</span>
<span class="cm"> * @rx_flags: internal RX flags for mac80211</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_rx_status</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">mactime</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">freq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">signal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">antenna</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rate_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_conf_flags - configuration flags</span>
<span class="cm"> *</span>
<span class="cm"> * Flags to define PHY configuration options</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_CONF_MONITOR: there&#39;s a monitor interface present -- use this</span>
<span class="cm"> *	to determine for example whether to calculate timestamps for packets</span>
<span class="cm"> *	or not, do not use instead of filter flags!</span>
<span class="cm"> * @IEEE80211_CONF_PS: Enable 802.11 power save mode (managed mode only).</span>
<span class="cm"> *	This is the power save mode defined by IEEE 802.11-2007 section 11.2,</span>
<span class="cm"> *	meaning that the hardware still wakes up for beacons, is able to</span>
<span class="cm"> *	transmit frames and receive the possible acknowledgment frames.</span>
<span class="cm"> *	Not to be confused with hardware specific wakeup/sleep states,</span>
<span class="cm"> *	driver is responsible for that. See the section &quot;Powersave support&quot;</span>
<span class="cm"> *	for more.</span>
<span class="cm"> * @IEEE80211_CONF_IDLE: The device is running, but idle; if the flag is set</span>
<span class="cm"> *	the driver should be prepared to handle configuration requests but</span>
<span class="cm"> *	may turn the device off as much as possible. Typically, this flag will</span>
<span class="cm"> *	be set when an interface is set UP but not associated or scanning, but</span>
<span class="cm"> *	it can also be unset in that case when monitor interfaces are active.</span>
<span class="cm"> * @IEEE80211_CONF_OFFCHANNEL: The device is currently not on its main</span>
<span class="cm"> *	operating channel.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_conf_flags</span> <span class="p">{</span>
	<span class="n">IEEE80211_CONF_MONITOR</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">IEEE80211_CONF_PS</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IEEE80211_CONF_IDLE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">IEEE80211_CONF_OFFCHANNEL</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">),</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_conf_changed - denotes which configuration changed</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_CONF_CHANGE_LISTEN_INTERVAL: the listen interval changed</span>
<span class="cm"> * @IEEE80211_CONF_CHANGE_MONITOR: the monitor flag changed</span>
<span class="cm"> * @IEEE80211_CONF_CHANGE_PS: the PS flag or dynamic PS timeout changed</span>
<span class="cm"> * @IEEE80211_CONF_CHANGE_POWER: the TX power changed</span>
<span class="cm"> * @IEEE80211_CONF_CHANGE_CHANNEL: the channel/channel_type changed</span>
<span class="cm"> * @IEEE80211_CONF_CHANGE_RETRY_LIMITS: retry limits changed</span>
<span class="cm"> * @IEEE80211_CONF_CHANGE_IDLE: Idle flag changed</span>
<span class="cm"> * @IEEE80211_CONF_CHANGE_SMPS: Spatial multiplexing powersave mode changed</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_conf_changed</span> <span class="p">{</span>
	<span class="n">IEEE80211_CONF_CHANGE_SMPS</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IEEE80211_CONF_CHANGE_LISTEN_INTERVAL</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">IEEE80211_CONF_CHANGE_MONITOR</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">IEEE80211_CONF_CHANGE_PS</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
	<span class="n">IEEE80211_CONF_CHANGE_POWER</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	<span class="n">IEEE80211_CONF_CHANGE_CHANNEL</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
	<span class="n">IEEE80211_CONF_CHANGE_RETRY_LIMITS</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
	<span class="n">IEEE80211_CONF_CHANGE_IDLE</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_smps_mode - spatial multiplexing power save mode</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_SMPS_AUTOMATIC: automatic</span>
<span class="cm"> * @IEEE80211_SMPS_OFF: off</span>
<span class="cm"> * @IEEE80211_SMPS_STATIC: static</span>
<span class="cm"> * @IEEE80211_SMPS_DYNAMIC: dynamic</span>
<span class="cm"> * @IEEE80211_SMPS_NUM_MODES: internal, don&#39;t use</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_smps_mode</span> <span class="p">{</span>
	<span class="n">IEEE80211_SMPS_AUTOMATIC</span><span class="p">,</span>
	<span class="n">IEEE80211_SMPS_OFF</span><span class="p">,</span>
	<span class="n">IEEE80211_SMPS_STATIC</span><span class="p">,</span>
	<span class="n">IEEE80211_SMPS_DYNAMIC</span><span class="p">,</span>

	<span class="cm">/* keep last */</span>
	<span class="n">IEEE80211_SMPS_NUM_MODES</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_conf - configuration of the device</span>
<span class="cm"> *</span>
<span class="cm"> * This struct indicates how the driver shall configure the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * @flags: configuration flags defined above</span>
<span class="cm"> *</span>
<span class="cm"> * @listen_interval: listen interval in units of beacon interval</span>
<span class="cm"> * @max_sleep_period: the maximum number of beacon intervals to sleep for</span>
<span class="cm"> *	before checking the beacon for a TIM bit (managed mode only); this</span>
<span class="cm"> *	value will be only achievable between DTIM frames, the hardware</span>
<span class="cm"> *	needs to check for the multicast traffic bit in DTIM beacons.</span>
<span class="cm"> *	This variable is valid only when the CONF_PS flag is set.</span>
<span class="cm"> * @ps_dtim_period: The DTIM period of the AP we&#39;re connected to, for use</span>
<span class="cm"> *	in power saving. Power saving will not be enabled until a beacon</span>
<span class="cm"> *	has been received and the DTIM period is known.</span>
<span class="cm"> * @dynamic_ps_timeout: The dynamic powersave timeout (in ms), see the</span>
<span class="cm"> *	powersave documentation below. This variable is valid only when</span>
<span class="cm"> *	the CONF_PS flag is set.</span>
<span class="cm"> *</span>
<span class="cm"> * @power_level: requested transmit power (in dBm)</span>
<span class="cm"> *</span>
<span class="cm"> * @channel: the channel to tune to</span>
<span class="cm"> * @channel_type: the channel (HT) type</span>
<span class="cm"> *</span>
<span class="cm"> * @long_frame_max_tx_count: Maximum number of transmissions for a &quot;long&quot; frame</span>
<span class="cm"> *    (a frame not RTS protected), called &quot;dot11LongRetryLimit&quot; in 802.11,</span>
<span class="cm"> *    but actually means the number of transmissions not the number of retries</span>
<span class="cm"> * @short_frame_max_tx_count: Maximum number of transmissions for a &quot;short&quot;</span>
<span class="cm"> *    frame, called &quot;dot11ShortRetryLimit&quot; in 802.11, but actually means the</span>
<span class="cm"> *    number of transmissions not the number of retries</span>
<span class="cm"> *</span>
<span class="cm"> * @smps_mode: spatial multiplexing powersave mode; note that</span>
<span class="cm"> *	%IEEE80211_SMPS_STATIC is used when the device is not</span>
<span class="cm"> *	configured for an HT channel</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_conf</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">power_level</span><span class="p">,</span> <span class="n">dynamic_ps_timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_sleep_period</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">listen_interval</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ps_dtim_period</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">long_frame_max_tx_count</span><span class="p">,</span> <span class="n">short_frame_max_tx_count</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">channel_type</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ieee80211_smps_mode</span> <span class="n">smps_mode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_channel_switch - holds the channel switch data</span>
<span class="cm"> *</span>
<span class="cm"> * The information provided in this structure is required for channel switch</span>
<span class="cm"> * operation.</span>
<span class="cm"> *</span>
<span class="cm"> * @timestamp: value in microseconds of the 64-bit Time Synchronization</span>
<span class="cm"> *	Function (TSF) timer when the frame containing the channel switch</span>
<span class="cm"> *	announcement was received. This is simply the rx.mactime parameter</span>
<span class="cm"> *	the driver passed into mac80211.</span>
<span class="cm"> * @block_tx: Indicates whether transmission must be blocked before the</span>
<span class="cm"> *	scheduled channel switch, as indicated by the AP.</span>
<span class="cm"> * @channel: the new channel to switch to</span>
<span class="cm"> * @count: the number of TBTT&#39;s until the channel switch event</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_channel_switch</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">timestamp</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">block_tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_vif_flags - virtual interface flags</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_VIF_BEACON_FILTER: the device performs beacon filtering</span>
<span class="cm"> *	on this virtual interface to avoid unnecessary CPU wakeups</span>
<span class="cm"> * @IEEE80211_VIF_SUPPORTS_CQM_RSSI: the device can do connection quality</span>
<span class="cm"> *	monitoring on this virtual interface -- i.e. it can monitor</span>
<span class="cm"> *	connection quality related parameters, such as the RSSI level and</span>
<span class="cm"> *	provide notifications if configured trigger levels are reached.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_vif_flags</span> <span class="p">{</span>
	<span class="n">IEEE80211_VIF_BEACON_FILTER</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">IEEE80211_VIF_SUPPORTS_CQM_RSSI</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_vif - per-interface data</span>
<span class="cm"> *</span>
<span class="cm"> * Data in this structure is continually present for driver</span>
<span class="cm"> * use during the life of a virtual interface.</span>
<span class="cm"> *</span>
<span class="cm"> * @type: type of this virtual interface</span>
<span class="cm"> * @bss_conf: BSS configuration for this interface, either our own</span>
<span class="cm"> *	or the BSS we&#39;re associated to</span>
<span class="cm"> * @addr: address of this interface</span>
<span class="cm"> * @p2p: indicates whether this AP or STA interface is a p2p</span>
<span class="cm"> *	interface, i.e. a GO or p2p-sta respectively</span>
<span class="cm"> * @driver_flags: flags/capabilities the driver has for this interface,</span>
<span class="cm"> *	these need to be set (or cleared) when the interface is added</span>
<span class="cm"> *	or, if supported by the driver, the interface type is changed</span>
<span class="cm"> *	at runtime, mac80211 will never touch this field</span>
<span class="cm"> * @hw_queue: hardware queue for each AC</span>
<span class="cm"> * @cab_queue: content-after-beacon (DTIM beacon really) queue, AP mode only</span>
<span class="cm"> * @drv_priv: data area for driver use, will always be aligned to</span>
<span class="cm"> *	sizeof(void *).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_bss_conf</span> <span class="n">bss_conf</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">bool</span> <span class="n">p2p</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">cab_queue</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hw_queue</span><span class="p">[</span><span class="n">IEEE80211_NUM_ACS</span><span class="p">];</span>

	<span class="n">u32</span> <span class="n">driver_flags</span><span class="p">;</span>

	<span class="cm">/* must be last */</span>
	<span class="n">u8</span> <span class="n">drv_priv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))));</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ieee80211_vif_is_mesh</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MAC80211_MESH</span>
	<span class="k">return</span> <span class="n">vif</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">NL80211_IFTYPE_MESH_POINT</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_key_flags - key flags</span>
<span class="cm"> *</span>
<span class="cm"> * These flags are used for communication about keys between the driver</span>
<span class="cm"> * and mac80211, with the @flags parameter of &amp;struct ieee80211_key_conf.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_KEY_FLAG_WMM_STA: Set by mac80211, this flag indicates</span>
<span class="cm"> *	that the STA this key will be used with could be using QoS.</span>
<span class="cm"> * @IEEE80211_KEY_FLAG_GENERATE_IV: This flag should be set by the</span>
<span class="cm"> *	driver to indicate that it requires IV generation for this</span>
<span class="cm"> *	particular key.</span>
<span class="cm"> * @IEEE80211_KEY_FLAG_GENERATE_MMIC: This flag should be set by</span>
<span class="cm"> *	the driver for a TKIP key if it requires Michael MIC</span>
<span class="cm"> *	generation in software.</span>
<span class="cm"> * @IEEE80211_KEY_FLAG_PAIRWISE: Set by mac80211, this flag indicates</span>
<span class="cm"> *	that the key is pairwise rather then a shared key.</span>
<span class="cm"> * @IEEE80211_KEY_FLAG_SW_MGMT: This flag should be set by the driver for a</span>
<span class="cm"> *	CCMP key if it requires CCMP encryption of management frames (MFP) to</span>
<span class="cm"> *	be done in software.</span>
<span class="cm"> * @IEEE80211_KEY_FLAG_PUT_IV_SPACE: This flag should be set by the driver</span>
<span class="cm"> *	if space should be prepared for the IV, but the IV</span>
<span class="cm"> *	itself should not be generated. Do not set together with</span>
<span class="cm"> *	@IEEE80211_KEY_FLAG_GENERATE_IV on the same key.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_key_flags</span> <span class="p">{</span>
	<span class="n">IEEE80211_KEY_FLAG_WMM_STA</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>
	<span class="n">IEEE80211_KEY_FLAG_GENERATE_IV</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">IEEE80211_KEY_FLAG_GENERATE_MMIC</span><span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span>
	<span class="n">IEEE80211_KEY_FLAG_PAIRWISE</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span>
	<span class="n">IEEE80211_KEY_FLAG_SW_MGMT</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">,</span>
	<span class="n">IEEE80211_KEY_FLAG_PUT_IV_SPACE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_key_conf - key information</span>
<span class="cm"> *</span>
<span class="cm"> * This key information is given by mac80211 to the driver by</span>
<span class="cm"> * the set_key() callback in &amp;struct ieee80211_ops.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw_key_idx: To be set by the driver, this is the key index the driver</span>
<span class="cm"> *	wants to be given when a frame is transmitted and needs to be</span>
<span class="cm"> *	encrypted in hardware.</span>
<span class="cm"> * @cipher: The key&#39;s cipher suite selector.</span>
<span class="cm"> * @flags: key flags, see &amp;enum ieee80211_key_flags.</span>
<span class="cm"> * @keyidx: the key index (0-3)</span>
<span class="cm"> * @keylen: key material length</span>
<span class="cm"> * @key: key material. For ALG_TKIP the key is encoded as a 256-bit (32 byte)</span>
<span class="cm"> * 	data block:</span>
<span class="cm"> * 	- Temporal Encryption Key (128 bits)</span>
<span class="cm"> * 	- Temporal Authenticator Tx MIC Key (64 bits)</span>
<span class="cm"> * 	- Temporal Authenticator Rx MIC Key (64 bits)</span>
<span class="cm"> * @icv_len: The ICV length for this key type</span>
<span class="cm"> * @iv_len: The IV length for this key type</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">cipher</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">icv_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">iv_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hw_key_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">keyidx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">keylen</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum set_key_cmd - key command</span>
<span class="cm"> *</span>
<span class="cm"> * Used with the set_key() callback in &amp;struct ieee80211_ops, this</span>
<span class="cm"> * indicates whether a key is being removed or added.</span>
<span class="cm"> *</span>
<span class="cm"> * @SET_KEY: a key is set</span>
<span class="cm"> * @DISABLE_KEY: a key must be disabled</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">set_key_cmd</span> <span class="p">{</span>
	<span class="n">SET_KEY</span><span class="p">,</span> <span class="n">DISABLE_KEY</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_sta_state - station state</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_STA_NOTEXIST: station doesn&#39;t exist at all,</span>
<span class="cm"> *	this is a special state for add/remove transitions</span>
<span class="cm"> * @IEEE80211_STA_NONE: station exists without special state</span>
<span class="cm"> * @IEEE80211_STA_AUTH: station is authenticated</span>
<span class="cm"> * @IEEE80211_STA_ASSOC: station is associated</span>
<span class="cm"> * @IEEE80211_STA_AUTHORIZED: station is authorized (802.1X)</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_sta_state</span> <span class="p">{</span>
	<span class="cm">/* NOTE: These need to be ordered correctly! */</span>
	<span class="n">IEEE80211_STA_NOTEXIST</span><span class="p">,</span>
	<span class="n">IEEE80211_STA_NONE</span><span class="p">,</span>
	<span class="n">IEEE80211_STA_AUTH</span><span class="p">,</span>
	<span class="n">IEEE80211_STA_ASSOC</span><span class="p">,</span>
	<span class="n">IEEE80211_STA_AUTHORIZED</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_sta - station table entry</span>
<span class="cm"> *</span>
<span class="cm"> * A station table entry represents a station we are possibly</span>
<span class="cm"> * communicating with. Since stations are RCU-managed in</span>
<span class="cm"> * mac80211, any ieee80211_sta pointer you get access to must</span>
<span class="cm"> * either be protected by rcu_read_lock() explicitly or implicitly,</span>
<span class="cm"> * or you must take good care to not use such a pointer after a</span>
<span class="cm"> * call to your sta_remove callback that removed it.</span>
<span class="cm"> *</span>
<span class="cm"> * @addr: MAC address</span>
<span class="cm"> * @aid: AID we assigned to the station if we&#39;re an AP</span>
<span class="cm"> * @supp_rates: Bitmap of supported rates (per band)</span>
<span class="cm"> * @ht_cap: HT capabilities of this STA; restricted to our own TX capabilities</span>
<span class="cm"> * @wme: indicates whether the STA supports WME. Only valid during AP-mode.</span>
<span class="cm"> * @drv_priv: data area for driver use, will always be aligned to</span>
<span class="cm"> *	sizeof(void *), size is determined in hw information.</span>
<span class="cm"> * @uapsd_queues: bitmap of queues configured for uapsd. Only valid</span>
<span class="cm"> *	if wme is supported.</span>
<span class="cm"> * @max_sp: max Service Period. Only valid if wme is supported.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">supp_rates</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">aid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_sta_ht_cap</span> <span class="n">ht_cap</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">wme</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">uapsd_queues</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_sp</span><span class="p">;</span>

	<span class="cm">/* must be last */</span>
	<span class="n">u8</span> <span class="n">drv_priv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))));</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum sta_notify_cmd - sta notify command</span>
<span class="cm"> *</span>
<span class="cm"> * Used with the sta_notify() callback in &amp;struct ieee80211_ops, this</span>
<span class="cm"> * indicates if an associated station made a power state transition.</span>
<span class="cm"> *</span>
<span class="cm"> * @STA_NOTIFY_SLEEP: a station is now sleeping</span>
<span class="cm"> * @STA_NOTIFY_AWAKE: a sleeping station woke up</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">sta_notify_cmd</span> <span class="p">{</span>
	<span class="n">STA_NOTIFY_SLEEP</span><span class="p">,</span> <span class="n">STA_NOTIFY_AWAKE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_hw_flags - hardware flags</span>
<span class="cm"> *</span>
<span class="cm"> * These flags are used to indicate hardware capabilities to</span>
<span class="cm"> * the stack. Generally, flags here should have their meaning</span>
<span class="cm"> * done in a way that the simplest hardware doesn&#39;t need setting</span>
<span class="cm"> * any particular flags. There are some exceptions to this rule,</span>
<span class="cm"> * however, so you are advised to review these flags carefully.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_HAS_RATE_CONTROL:</span>
<span class="cm"> *	The hardware or firmware includes rate control, and cannot be</span>
<span class="cm"> *	controlled by the stack. As such, no rate control algorithm</span>
<span class="cm"> *	should be instantiated, and the TX rate reported to userspace</span>
<span class="cm"> *	will be taken from the TX status instead of the rate control</span>
<span class="cm"> *	algorithm.</span>
<span class="cm"> *	Note that this requires that the driver implement a number of</span>
<span class="cm"> *	callbacks so it has the correct information, it needs to have</span>
<span class="cm"> *	the @set_rts_threshold callback and must look at the BSS config</span>
<span class="cm"> *	@use_cts_prot for G/N protection, @use_short_slot for slot</span>
<span class="cm"> *	timing in 2.4 GHz and @use_short_preamble for preambles for</span>
<span class="cm"> *	CCK frames.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_RX_INCLUDES_FCS:</span>
<span class="cm"> *	Indicates that received frames passed to the stack include</span>
<span class="cm"> *	the FCS at the end.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING:</span>
<span class="cm"> *	Some wireless LAN chipsets buffer broadcast/multicast frames</span>
<span class="cm"> *	for power saving stations in the hardware/firmware and others</span>
<span class="cm"> *	rely on the host system for such buffering. This option is used</span>
<span class="cm"> *	to configure the IEEE 802.11 upper layer to buffer broadcast and</span>
<span class="cm"> *	multicast frames when there are power saving stations so that</span>
<span class="cm"> *	the driver can fetch them with ieee80211_get_buffered_bc().</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE:</span>
<span class="cm"> *	Hardware is not capable of short slot operation on the 2.4 GHz band.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_2GHZ_SHORT_PREAMBLE_INCAPABLE:</span>
<span class="cm"> *	Hardware is not capable of receiving frames with short preamble on</span>
<span class="cm"> *	the 2.4 GHz band.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_SIGNAL_UNSPEC:</span>
<span class="cm"> *	Hardware can provide signal values but we don&#39;t know its units. We</span>
<span class="cm"> *	expect values between 0 and @max_signal.</span>
<span class="cm"> *	If possible please provide dB or dBm instead.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_SIGNAL_DBM:</span>
<span class="cm"> *	Hardware gives signal values in dBm, decibel difference from</span>
<span class="cm"> *	one milliwatt. This is the preferred method since it is standardized</span>
<span class="cm"> *	between different devices. @max_signal does not need to be set.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_SPECTRUM_MGMT:</span>
<span class="cm"> * 	Hardware supports spectrum management defined in 802.11h</span>
<span class="cm"> * 	Measurement, Channel Switch, Quieting, TPC</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_AMPDU_AGGREGATION:</span>
<span class="cm"> *	Hardware supports 11n A-MPDU aggregation.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_SUPPORTS_PS:</span>
<span class="cm"> *	Hardware has power save support (i.e. can go to sleep).</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_PS_NULLFUNC_STACK:</span>
<span class="cm"> *	Hardware requires nullfunc frame handling in stack, implies</span>
<span class="cm"> *	stack support for dynamic PS.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_SUPPORTS_DYNAMIC_PS:</span>
<span class="cm"> *	Hardware has support for dynamic PS.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_MFP_CAPABLE:</span>
<span class="cm"> *	Hardware supports management frame protection (MFP, IEEE 802.11w).</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_SUPPORTS_STATIC_SMPS:</span>
<span class="cm"> *	Hardware supports static spatial multiplexing powersave,</span>
<span class="cm"> *	ie. can turn off all but one chain even on HT connections</span>
<span class="cm"> *	that should be using more chains.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_SUPPORTS_DYNAMIC_SMPS:</span>
<span class="cm"> *	Hardware supports dynamic spatial multiplexing powersave,</span>
<span class="cm"> *	ie. can turn off all but one chain and then wake the rest</span>
<span class="cm"> *	up as required after, for example, rts/cts handshake.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_SUPPORTS_UAPSD:</span>
<span class="cm"> *	Hardware supports Unscheduled Automatic Power Save Delivery</span>
<span class="cm"> *	(U-APSD) in managed mode. The mode is configured with</span>
<span class="cm"> *	conf_tx() operation.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_REPORTS_TX_ACK_STATUS:</span>
<span class="cm"> *	Hardware can provide ack status reports of Tx frames to</span>
<span class="cm"> *	the stack.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_CONNECTION_MONITOR:</span>
<span class="cm"> *      The hardware performs its own connection monitoring, including</span>
<span class="cm"> *      periodic keep-alives to the AP and probing the AP on beacon loss.</span>
<span class="cm"> *      When this flag is set, signaling beacon-loss will cause an immediate</span>
<span class="cm"> *      change to disassociated state.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_NEED_DTIM_PERIOD:</span>
<span class="cm"> *	This device needs to know the DTIM period for the BSS before</span>
<span class="cm"> *	associating.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_SUPPORTS_PER_STA_GTK: The device&#39;s crypto engine supports</span>
<span class="cm"> *	per-station GTKs as used by IBSS RSN or during fast transition. If</span>
<span class="cm"> *	the device doesn&#39;t support per-station GTKs, but can be asked not</span>
<span class="cm"> *	to decrypt group addressed frames, then IBSS RSN support is still</span>
<span class="cm"> *	possible but software crypto will be used. Advertise the wiphy flag</span>
<span class="cm"> *	only in that case.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_AP_LINK_PS: When operating in AP mode the device</span>
<span class="cm"> *	autonomously manages the PS status of connected stations. When</span>
<span class="cm"> *	this flag is set mac80211 will not trigger PS mode for connected</span>
<span class="cm"> *	stations based on the PM bit of incoming frames.</span>
<span class="cm"> *	Use ieee80211_start_ps()/ieee8021_end_ps() to manually configure</span>
<span class="cm"> *	the PS mode of connected stations.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_TX_AMPDU_SETUP_IN_HW: The device handles TX A-MPDU session</span>
<span class="cm"> *	setup strictly in HW. mac80211 should not attempt to do this in</span>
<span class="cm"> *	software.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_SCAN_WHILE_IDLE: The device can do hw scan while</span>
<span class="cm"> *	being idle (i.e. mac80211 doesn&#39;t have to go idle-off during the</span>
<span class="cm"> *	the scan).</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_WANT_MONITOR_VIF: The driver would like to be informed of</span>
<span class="cm"> *	a virtual monitor interface when monitor interfaces are the only</span>
<span class="cm"> *	active interfaces.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_HW_QUEUE_CONTROL: The driver wants to control per-interface</span>
<span class="cm"> *	queue mapping in order to use different queues (not just one per AC)</span>
<span class="cm"> *	for different virtual interfaces. See the doc section on HW queue</span>
<span class="cm"> *	control for more details.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_hw_flags</span> <span class="p">{</span>
	<span class="n">IEEE80211_HW_HAS_RATE_CONTROL</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_RX_INCLUDES_FCS</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_2GHZ_SHORT_PREAMBLE_INCAPABLE</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_SIGNAL_UNSPEC</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_SIGNAL_DBM</span>				<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_NEED_DTIM_PERIOD</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_SPECTRUM_MGMT</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_AMPDU_AGGREGATION</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_SUPPORTS_PS</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_PS_NULLFUNC_STACK</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">11</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_SUPPORTS_DYNAMIC_PS</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">12</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_MFP_CAPABLE</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">13</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_WANT_MONITOR_VIF</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">14</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_SUPPORTS_STATIC_SMPS</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">15</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_SUPPORTS_DYNAMIC_SMPS</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_SUPPORTS_UAPSD</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">17</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_REPORTS_TX_ACK_STATUS</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">18</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_CONNECTION_MONITOR</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">19</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_QUEUE_CONTROL</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_SUPPORTS_PER_STA_GTK</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">21</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_AP_LINK_PS</span>				<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">22</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_TX_AMPDU_SETUP_IN_HW</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">23</span><span class="p">,</span>
	<span class="n">IEEE80211_HW_SCAN_WHILE_IDLE</span>			<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_hw - hardware information and state</span>
<span class="cm"> *</span>
<span class="cm"> * This structure contains the configuration and hardware</span>
<span class="cm"> * information for an 802.11 PHY.</span>
<span class="cm"> *</span>
<span class="cm"> * @wiphy: This points to the &amp;struct wiphy allocated for this</span>
<span class="cm"> *	802.11 PHY. You must fill in the @perm_addr and @dev</span>
<span class="cm"> *	members of this structure using SET_IEEE80211_DEV()</span>
<span class="cm"> *	and SET_IEEE80211_PERM_ADDR(). Additionally, all supported</span>
<span class="cm"> *	bands (with channels, bitrates) are registered here.</span>
<span class="cm"> *</span>
<span class="cm"> * @conf: &amp;struct ieee80211_conf, device configuration, don&#39;t use.</span>
<span class="cm"> *</span>
<span class="cm"> * @priv: pointer to private area that was allocated for driver use</span>
<span class="cm"> *	along with this structure.</span>
<span class="cm"> *</span>
<span class="cm"> * @flags: hardware flags, see &amp;enum ieee80211_hw_flags.</span>
<span class="cm"> *</span>
<span class="cm"> * @extra_tx_headroom: headroom to reserve in each transmit skb</span>
<span class="cm"> *	for use by the driver (e.g. for transmit headers.)</span>
<span class="cm"> *</span>
<span class="cm"> * @channel_change_time: time (in microseconds) it takes to change channels.</span>
<span class="cm"> *</span>
<span class="cm"> * @max_signal: Maximum value for signal (rssi) in RX information, used</span>
<span class="cm"> *     only when @IEEE80211_HW_SIGNAL_UNSPEC or @IEEE80211_HW_SIGNAL_DB</span>
<span class="cm"> *</span>
<span class="cm"> * @max_listen_interval: max listen interval in units of beacon interval</span>
<span class="cm"> *     that HW supports</span>
<span class="cm"> *</span>
<span class="cm"> * @queues: number of available hardware transmit queues for</span>
<span class="cm"> *	data packets. WMM/QoS requires at least four, these</span>
<span class="cm"> *	queues need to have configurable access parameters.</span>
<span class="cm"> *</span>
<span class="cm"> * @rate_control_algorithm: rate control algorithm for this hardware.</span>
<span class="cm"> *	If unset (NULL), the default algorithm will be used. Must be</span>
<span class="cm"> *	set before calling ieee80211_register_hw().</span>
<span class="cm"> *</span>
<span class="cm"> * @vif_data_size: size (in bytes) of the drv_priv data area</span>
<span class="cm"> *	within &amp;struct ieee80211_vif.</span>
<span class="cm"> * @sta_data_size: size (in bytes) of the drv_priv data area</span>
<span class="cm"> *	within &amp;struct ieee80211_sta.</span>
<span class="cm"> *</span>
<span class="cm"> * @max_rates: maximum number of alternate rate retry stages the hw</span>
<span class="cm"> *	can handle.</span>
<span class="cm"> * @max_report_rates: maximum number of alternate rate retry stages</span>
<span class="cm"> *	the hw can report back.</span>
<span class="cm"> * @max_rate_tries: maximum number of tries for each stage</span>
<span class="cm"> *</span>
<span class="cm"> * @napi_weight: weight used for NAPI polling.  You must specify an</span>
<span class="cm"> *	appropriate value here if a napi_poll operation is provided</span>
<span class="cm"> *	by your driver.</span>
<span class="cm"> *</span>
<span class="cm"> * @max_rx_aggregation_subframes: maximum buffer size (number of</span>
<span class="cm"> *	sub-frames) to be used for A-MPDU block ack receiver</span>
<span class="cm"> *	aggregation.</span>
<span class="cm"> *	This is only relevant if the device has restrictions on the</span>
<span class="cm"> *	number of subframes, if it relies on mac80211 to do reordering</span>
<span class="cm"> *	it shouldn&#39;t be set.</span>
<span class="cm"> *</span>
<span class="cm"> * @max_tx_aggregation_subframes: maximum number of subframes in an</span>
<span class="cm"> *	aggregate an HT driver will transmit, used by the peer as a</span>
<span class="cm"> *	hint to size its reorder buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * @offchannel_tx_hw_queue: HW queue ID to use for offchannel TX</span>
<span class="cm"> *	(if %IEEE80211_HW_QUEUE_CONTROL is set)</span>
<span class="cm"> *</span>
<span class="cm"> * @radiotap_mcs_details: lists which MCS information can the HW</span>
<span class="cm"> *	reports, by default it is set to _MCS, _GI and _BW but doesn&#39;t</span>
<span class="cm"> *	include _FMT. Use %IEEE80211_RADIOTAP_MCS_HAVE_* values, only</span>
<span class="cm"> *	adding _BW is supported today.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_conf</span> <span class="n">conf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rate_control_algorithm</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">extra_tx_headroom</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">channel_change_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vif_data_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sta_data_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">napi_weight</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">queues</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">max_listen_interval</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">max_signal</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_rates</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_report_rates</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_rate_tries</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_rx_aggregation_subframes</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_tx_aggregation_subframes</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">offchannel_tx_hw_queue</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">radiotap_mcs_details</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * wiphy_to_ieee80211_hw - return a mac80211 driver hw struct from a wiphy</span>
<span class="cm"> *</span>
<span class="cm"> * @wiphy: the &amp;struct wiphy which we want to query</span>
<span class="cm"> *</span>
<span class="cm"> * mac80211 drivers can use this to get to their respective</span>
<span class="cm"> * &amp;struct ieee80211_hw. Drivers wishing to get to their own private</span>
<span class="cm"> * structure can then access it via hw-&gt;priv. Note that mac802111 drivers should</span>
<span class="cm"> * not use wiphy_priv() to try to get their private driver structure as this</span>
<span class="cm"> * is already used internally by mac80211.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">wiphy_to_ieee80211_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * SET_IEEE80211_DEV - set device for 802.11 hardware</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the &amp;struct ieee80211_hw to set the device for</span>
<span class="cm"> * @dev: the &amp;struct device of this 802.11 device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">SET_IEEE80211_DEV</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_wiphy_dev</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * SET_IEEE80211_PERM_ADDR - set the permanent MAC address for 802.11 hardware</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the &amp;struct ieee80211_hw to set the MAC address for</span>
<span class="cm"> * @addr: the address to set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">SET_IEEE80211_PERM_ADDR</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ieee80211_rate</span> <span class="o">*</span>
<span class="nf">ieee80211_get_tx_rate</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">band</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bitrates</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">rates</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ieee80211_rate</span> <span class="o">*</span>
<span class="nf">ieee80211_get_rts_cts_rate</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">rts_cts_rate_idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">band</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bitrates</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">rts_cts_rate_idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ieee80211_rate</span> <span class="o">*</span>
<span class="nf">ieee80211_get_alt_retry_rate</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">rates</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">bands</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">band</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bitrates</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">.</span><span class="n">rates</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_free_txskb - free TX skb</span>
<span class="cm"> * @hw: the hardware</span>
<span class="cm"> * @skb: the skb</span>
<span class="cm"> *</span>
<span class="cm"> * Free a transmit skb. Use this funtion when some failure</span>
<span class="cm"> * to transmit happened and thus status cannot be reported.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_free_txskb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Hardware crypto acceleration</span>
<span class="cm"> *</span>
<span class="cm"> * mac80211 is capable of taking advantage of many hardware</span>
<span class="cm"> * acceleration designs for encryption and decryption operations.</span>
<span class="cm"> *</span>
<span class="cm"> * The set_key() callback in the &amp;struct ieee80211_ops for a given</span>
<span class="cm"> * device is called to enable hardware acceleration of encryption and</span>
<span class="cm"> * decryption. The callback takes a @sta parameter that will be NULL</span>
<span class="cm"> * for default keys or keys used for transmission only, or point to</span>
<span class="cm"> * the station information for the peer for individual keys.</span>
<span class="cm"> * Multiple transmission keys with the same key index may be used when</span>
<span class="cm"> * VLANs are configured for an access point.</span>
<span class="cm"> *</span>
<span class="cm"> * When transmitting, the TX control data will use the @hw_key_idx</span>
<span class="cm"> * selected by the driver by modifying the &amp;struct ieee80211_key_conf</span>
<span class="cm"> * pointed to by the @key parameter to the set_key() function.</span>
<span class="cm"> *</span>
<span class="cm"> * The set_key() call for the %SET_KEY command should return 0 if</span>
<span class="cm"> * the key is now in use, -%EOPNOTSUPP or -%ENOSPC if it couldn&#39;t be</span>
<span class="cm"> * added; if you return 0 then hw_key_idx must be assigned to the</span>
<span class="cm"> * hardware key index, you are free to use the full u8 range.</span>
<span class="cm"> *</span>
<span class="cm"> * When the cmd is %DISABLE_KEY then it must succeed.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that it is permissible to not decrypt a frame even if a key</span>
<span class="cm"> * for it has been uploaded to hardware, the stack will not make any</span>
<span class="cm"> * decision based on whether a key has been uploaded or not but rather</span>
<span class="cm"> * based on the receive flags.</span>
<span class="cm"> *</span>
<span class="cm"> * The &amp;struct ieee80211_key_conf structure pointed to by the @key</span>
<span class="cm"> * parameter is guaranteed to be valid until another call to set_key()</span>
<span class="cm"> * removes it, but it can only be used as a cookie to differentiate</span>
<span class="cm"> * keys.</span>
<span class="cm"> *</span>
<span class="cm"> * In TKIP some HW need to be provided a phase 1 key, for RX decryption</span>
<span class="cm"> * acceleration (i.e. iwlwifi). Those drivers should provide update_tkip_key</span>
<span class="cm"> * handler.</span>
<span class="cm"> * The update_tkip_key() call updates the driver with the new phase 1 key.</span>
<span class="cm"> * This happens every time the iv16 wraps around (every 65536 packets). The</span>
<span class="cm"> * set_key() call will happen only once for each key (unless the AP did</span>
<span class="cm"> * rekeying), it will not include a valid phase 1 key. The valid phase 1 key is</span>
<span class="cm"> * provided by update_tkip_key only. The trigger that makes mac80211 call this</span>
<span class="cm"> * handler is software decryption with wrap around of iv16.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Powersave support</span>
<span class="cm"> *</span>
<span class="cm"> * mac80211 has support for various powersave implementations.</span>
<span class="cm"> *</span>
<span class="cm"> * First, it can support hardware that handles all powersaving by itself,</span>
<span class="cm"> * such hardware should simply set the %IEEE80211_HW_SUPPORTS_PS hardware</span>
<span class="cm"> * flag. In that case, it will be told about the desired powersave mode</span>
<span class="cm"> * with the %IEEE80211_CONF_PS flag depending on the association status.</span>
<span class="cm"> * The hardware must take care of sending nullfunc frames when necessary,</span>
<span class="cm"> * i.e. when entering and leaving powersave mode. The hardware is required</span>
<span class="cm"> * to look at the AID in beacons and signal to the AP that it woke up when</span>
<span class="cm"> * it finds traffic directed to it.</span>
<span class="cm"> *</span>
<span class="cm"> * %IEEE80211_CONF_PS flag enabled means that the powersave mode defined in</span>
<span class="cm"> * IEEE 802.11-2007 section 11.2 is enabled. This is not to be confused</span>
<span class="cm"> * with hardware wakeup and sleep states. Driver is responsible for waking</span>
<span class="cm"> * up the hardware before issuing commands to the hardware and putting it</span>
<span class="cm"> * back to sleep at appropriate times.</span>
<span class="cm"> *</span>
<span class="cm"> * When PS is enabled, hardware needs to wakeup for beacons and receive the</span>
<span class="cm"> * buffered multicast/broadcast frames after the beacon. Also it must be</span>
<span class="cm"> * possible to send frames and receive the acknowledment frame.</span>
<span class="cm"> *</span>
<span class="cm"> * Other hardware designs cannot send nullfunc frames by themselves and also</span>
<span class="cm"> * need software support for parsing the TIM bitmap. This is also supported</span>
<span class="cm"> * by mac80211 by combining the %IEEE80211_HW_SUPPORTS_PS and</span>
<span class="cm"> * %IEEE80211_HW_PS_NULLFUNC_STACK flags. The hardware is of course still</span>
<span class="cm"> * required to pass up beacons. The hardware is still required to handle</span>
<span class="cm"> * waking up for multicast traffic; if it cannot the driver must handle that</span>
<span class="cm"> * as best as it can, mac80211 is too slow to do that.</span>
<span class="cm"> *</span>
<span class="cm"> * Dynamic powersave is an extension to normal powersave in which the</span>
<span class="cm"> * hardware stays awake for a user-specified period of time after sending a</span>
<span class="cm"> * frame so that reply frames need not be buffered and therefore delayed to</span>
<span class="cm"> * the next wakeup. It&#39;s compromise of getting good enough latency when</span>
<span class="cm"> * there&#39;s data traffic and still saving significantly power in idle</span>
<span class="cm"> * periods.</span>
<span class="cm"> *</span>
<span class="cm"> * Dynamic powersave is simply supported by mac80211 enabling and disabling</span>
<span class="cm"> * PS based on traffic. Driver needs to only set %IEEE80211_HW_SUPPORTS_PS</span>
<span class="cm"> * flag and mac80211 will handle everything automatically. Additionally,</span>
<span class="cm"> * hardware having support for the dynamic PS feature may set the</span>
<span class="cm"> * %IEEE80211_HW_SUPPORTS_DYNAMIC_PS flag to indicate that it can support</span>
<span class="cm"> * dynamic PS mode itself. The driver needs to look at the</span>
<span class="cm"> * @dynamic_ps_timeout hardware configuration value and use it that value</span>
<span class="cm"> * whenever %IEEE80211_CONF_PS is set. In this case mac80211 will disable</span>
<span class="cm"> * dynamic PS feature in stack and will just keep %IEEE80211_CONF_PS</span>
<span class="cm"> * enabled whenever user has enabled powersave.</span>
<span class="cm"> *</span>
<span class="cm"> * Some hardware need to toggle a single shared antenna between WLAN and</span>
<span class="cm"> * Bluetooth to facilitate co-existence. These types of hardware set</span>
<span class="cm"> * limitations on the use of host controlled dynamic powersave whenever there</span>
<span class="cm"> * is simultaneous WLAN and Bluetooth traffic. For these types of hardware, the</span>
<span class="cm"> * driver may request temporarily going into full power save, in order to</span>
<span class="cm"> * enable toggling the antenna between BT and WLAN. If the driver requests</span>
<span class="cm"> * disabling dynamic powersave, the @dynamic_ps_timeout value will be</span>
<span class="cm"> * temporarily set to zero until the driver re-enables dynamic powersave.</span>
<span class="cm"> *</span>
<span class="cm"> * Driver informs U-APSD client support by enabling</span>
<span class="cm"> * %IEEE80211_HW_SUPPORTS_UAPSD flag. The mode is configured through the</span>
<span class="cm"> * uapsd paramater in conf_tx() operation. Hardware needs to send the QoS</span>
<span class="cm"> * Nullfunc frames and stay awake until the service period has ended. To</span>
<span class="cm"> * utilize U-APSD, dynamic powersave is disabled for voip AC and all frames</span>
<span class="cm"> * from that AC are transmitted with powersave enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: U-APSD client mode is not yet supported with</span>
<span class="cm"> * %IEEE80211_HW_PS_NULLFUNC_STACK.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Beacon filter support</span>
<span class="cm"> *</span>
<span class="cm"> * Some hardware have beacon filter support to reduce host cpu wakeups</span>
<span class="cm"> * which will reduce system power consumption. It usually works so that</span>
<span class="cm"> * the firmware creates a checksum of the beacon but omits all constantly</span>
<span class="cm"> * changing elements (TSF, TIM etc). Whenever the checksum changes the</span>
<span class="cm"> * beacon is forwarded to the host, otherwise it will be just dropped. That</span>
<span class="cm"> * way the host will only receive beacons where some relevant information</span>
<span class="cm"> * (for example ERP protection or WMM settings) have changed.</span>
<span class="cm"> *</span>
<span class="cm"> * Beacon filter support is advertised with the %IEEE80211_VIF_BEACON_FILTER</span>
<span class="cm"> * interface capability. The driver needs to enable beacon filter support</span>
<span class="cm"> * whenever power save is enabled, that is %IEEE80211_CONF_PS is set. When</span>
<span class="cm"> * power save is enabled, the stack will not check for beacon loss and the</span>
<span class="cm"> * driver needs to notify about loss of beacons with ieee80211_beacon_loss().</span>
<span class="cm"> *</span>
<span class="cm"> * The time (or number of beacons missed) until the firmware notifies the</span>
<span class="cm"> * driver of a beacon loss event (which in turn causes the driver to call</span>
<span class="cm"> * ieee80211_beacon_loss()) should be configurable and will be controlled</span>
<span class="cm"> * by mac80211 and the roaming algorithm in the future.</span>
<span class="cm"> *</span>
<span class="cm"> * Since there may be constantly changing information elements that nothing</span>
<span class="cm"> * in the software stack cares about, we will, in the future, have mac80211</span>
<span class="cm"> * tell the driver which information elements are interesting in the sense</span>
<span class="cm"> * that we want to see changes in them. This will include</span>
<span class="cm"> *  - a list of information element IDs</span>
<span class="cm"> *  - a list of OUIs for the vendor information element</span>
<span class="cm"> *</span>
<span class="cm"> * Ideally, the hardware would filter out any beacons without changes in the</span>
<span class="cm"> * requested elements, but if it cannot support that it may, at the expense</span>
<span class="cm"> * of some efficiency, filter out only a subset. For example, if the device</span>
<span class="cm"> * doesn&#39;t support checking for OUIs it should pass up all changes in all</span>
<span class="cm"> * vendor information elements.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that change, for the sake of simplification, also includes information</span>
<span class="cm"> * elements appearing or disappearing from the beacon.</span>
<span class="cm"> *</span>
<span class="cm"> * Some hardware supports an &quot;ignore list&quot; instead, just make sure nothing</span>
<span class="cm"> * that was requested is on the ignore list, and include commonly changing</span>
<span class="cm"> * information element IDs in the ignore list, for example 11 (BSS load) and</span>
<span class="cm"> * the various vendor-assigned IEs with unknown contents (128, 129, 133-136,</span>
<span class="cm"> * 149, 150, 155, 156, 173, 176, 178, 179, 219); for forward compatibility</span>
<span class="cm"> * it could also include some currently unused IDs.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * In addition to these capabilities, hardware should support notifying the</span>
<span class="cm"> * host of changes in the beacon RSSI. This is relevant to implement roaming</span>
<span class="cm"> * when no traffic is flowing (when traffic is flowing we see the RSSI of</span>
<span class="cm"> * the received data packets). This can consist in notifying the host when</span>
<span class="cm"> * the RSSI changes significantly or when it drops below or rises above</span>
<span class="cm"> * configurable thresholds. In the future these thresholds will also be</span>
<span class="cm"> * configured by mac80211 (which gets them from userspace) to implement</span>
<span class="cm"> * them as the roaming algorithm requires.</span>
<span class="cm"> *</span>
<span class="cm"> * If the hardware cannot implement this, the driver should ask it to</span>
<span class="cm"> * periodically pass beacon frames to the host so that software can do the</span>
<span class="cm"> * signal strength threshold checking.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Spatial multiplexing power save</span>
<span class="cm"> *</span>
<span class="cm"> * SMPS (Spatial multiplexing power save) is a mechanism to conserve</span>
<span class="cm"> * power in an 802.11n implementation. For details on the mechanism</span>
<span class="cm"> * and rationale, please refer to 802.11 (as amended by 802.11n-2009)</span>
<span class="cm"> * &quot;11.2.3 SM power save&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * The mac80211 implementation is capable of sending action frames</span>
<span class="cm"> * to update the AP about the station&#39;s SMPS mode, and will instruct</span>
<span class="cm"> * the driver to enter the specific mode. It will also announce the</span>
<span class="cm"> * requested SMPS mode during the association handshake. Hardware</span>
<span class="cm"> * support for this feature is required, and can be indicated by</span>
<span class="cm"> * hardware flags.</span>
<span class="cm"> *</span>
<span class="cm"> * The default mode will be &quot;automatic&quot;, which nl80211/cfg80211</span>
<span class="cm"> * defines to be dynamic SMPS in (regular) powersave, and SMPS</span>
<span class="cm"> * turned off otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * To support this feature, the driver must set the appropriate</span>
<span class="cm"> * hardware support flags, and handle the SMPS flag to the config()</span>
<span class="cm"> * operation. It will then with this mechanism be instructed to</span>
<span class="cm"> * enter the requested SMPS mode while associated to an HT AP.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Frame filtering</span>
<span class="cm"> *</span>
<span class="cm"> * mac80211 requires to see many management frames for proper</span>
<span class="cm"> * operation, and users may want to see many more frames when</span>
<span class="cm"> * in monitor mode. However, for best CPU usage and power consumption,</span>
<span class="cm"> * having as few frames as possible percolate through the stack is</span>
<span class="cm"> * desirable. Hence, the hardware should filter as much as possible.</span>
<span class="cm"> *</span>
<span class="cm"> * To achieve this, mac80211 uses filter flags (see below) to tell</span>
<span class="cm"> * the driver&#39;s configure_filter() function which frames should be</span>
<span class="cm"> * passed to mac80211 and which should be filtered out.</span>
<span class="cm"> *</span>
<span class="cm"> * Before configure_filter() is invoked, the prepare_multicast()</span>
<span class="cm"> * callback is invoked with the parameters @mc_count and @mc_list</span>
<span class="cm"> * for the combined multicast address list of all virtual interfaces.</span>
<span class="cm"> * It&#39;s use is optional, and it returns a u64 that is passed to</span>
<span class="cm"> * configure_filter(). Additionally, configure_filter() has the</span>
<span class="cm"> * arguments @changed_flags telling which flags were changed and</span>
<span class="cm"> * @total_flags with the new flag states.</span>
<span class="cm"> *</span>
<span class="cm"> * If your device has no multicast address filters your driver will</span>
<span class="cm"> * need to check both the %FIF_ALLMULTI flag and the @mc_count</span>
<span class="cm"> * parameter to see whether multicast frames should be accepted</span>
<span class="cm"> * or dropped.</span>
<span class="cm"> *</span>
<span class="cm"> * All unsupported flags in @total_flags must be cleared.</span>
<span class="cm"> * Hardware does not support a flag if it is incapable of _passing_</span>
<span class="cm"> * the frame to the stack. Otherwise the driver must ignore</span>
<span class="cm"> * the flag, but not clear it.</span>
<span class="cm"> * You must _only_ clear the flag (announce no support for the</span>
<span class="cm"> * flag to mac80211) if you are not able to pass the packet type</span>
<span class="cm"> * to the stack (so the hardware always filters it).</span>
<span class="cm"> * So for example, you should clear @FIF_CONTROL, if your hardware</span>
<span class="cm"> * always filters control frames. If your hardware always passes</span>
<span class="cm"> * control frames to the kernel and is incapable of filtering them,</span>
<span class="cm"> * you do _not_ clear the @FIF_CONTROL flag.</span>
<span class="cm"> * This rule applies to all other FIF flags as well.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: AP support for powersaving clients</span>
<span class="cm"> *</span>
<span class="cm"> * In order to implement AP and P2P GO modes, mac80211 has support for</span>
<span class="cm"> * client powersaving, both &quot;legacy&quot; PS (PS-Poll/null data) and uAPSD.</span>
<span class="cm"> * There currently is no support for sAPSD.</span>
<span class="cm"> *</span>
<span class="cm"> * There is one assumption that mac80211 makes, namely that a client</span>
<span class="cm"> * will not poll with PS-Poll and trigger with uAPSD at the same time.</span>
<span class="cm"> * Both are supported, and both can be used by the same client, but</span>
<span class="cm"> * they can&#39;t be used concurrently by the same client. This simplifies</span>
<span class="cm"> * the driver code.</span>
<span class="cm"> *</span>
<span class="cm"> * The first thing to keep in mind is that there is a flag for complete</span>
<span class="cm"> * driver implementation: %IEEE80211_HW_AP_LINK_PS. If this flag is set,</span>
<span class="cm"> * mac80211 expects the driver to handle most of the state machine for</span>
<span class="cm"> * powersaving clients and will ignore the PM bit in incoming frames.</span>
<span class="cm"> * Drivers then use ieee80211_sta_ps_transition() to inform mac80211 of</span>
<span class="cm"> * stations&#39; powersave transitions. In this mode, mac80211 also doesn&#39;t</span>
<span class="cm"> * handle PS-Poll/uAPSD.</span>
<span class="cm"> *</span>
<span class="cm"> * In the mode without %IEEE80211_HW_AP_LINK_PS, mac80211 will check the</span>
<span class="cm"> * PM bit in incoming frames for client powersave transitions. When a</span>
<span class="cm"> * station goes to sleep, we will stop transmitting to it. There is,</span>
<span class="cm"> * however, a race condition: a station might go to sleep while there is</span>
<span class="cm"> * data buffered on hardware queues. If the device has support for this</span>
<span class="cm"> * it will reject frames, and the driver should give the frames back to</span>
<span class="cm"> * mac80211 with the %IEEE80211_TX_STAT_TX_FILTERED flag set which will</span>
<span class="cm"> * cause mac80211 to retry the frame when the station wakes up. The</span>
<span class="cm"> * driver is also notified of powersave transitions by calling its</span>
<span class="cm"> * @sta_notify callback.</span>
<span class="cm"> *</span>
<span class="cm"> * When the station is asleep, it has three choices: it can wake up,</span>
<span class="cm"> * it can PS-Poll, or it can possibly start a uAPSD service period.</span>
<span class="cm"> * Waking up is implemented by simply transmitting all buffered (and</span>
<span class="cm"> * filtered) frames to the station. This is the easiest case. When</span>
<span class="cm"> * the station sends a PS-Poll or a uAPSD trigger frame, mac80211</span>
<span class="cm"> * will inform the driver of this with the @allow_buffered_frames</span>
<span class="cm"> * callback; this callback is optional. mac80211 will then transmit</span>
<span class="cm"> * the frames as usual and set the %IEEE80211_TX_CTL_NO_PS_BUFFER</span>
<span class="cm"> * on each frame. The last frame in the service period (or the only</span>
<span class="cm"> * response to a PS-Poll) also has %IEEE80211_TX_STATUS_EOSP set to</span>
<span class="cm"> * indicate that it ends the service period; as this frame must have</span>
<span class="cm"> * TX status report it also sets %IEEE80211_TX_CTL_REQ_TX_STATUS.</span>
<span class="cm"> * When TX status is reported for this frame, the service period is</span>
<span class="cm"> * marked has having ended and a new one can be started by the peer.</span>
<span class="cm"> *</span>
<span class="cm"> * Additionally, non-bufferable MMPDUs can also be transmitted by</span>
<span class="cm"> * mac80211 with the %IEEE80211_TX_CTL_NO_PS_BUFFER set in them.</span>
<span class="cm"> *</span>
<span class="cm"> * Another race condition can happen on some devices like iwlwifi</span>
<span class="cm"> * when there are frames queued for the station and it wakes up</span>
<span class="cm"> * or polls; the frames that are already queued could end up being</span>
<span class="cm"> * transmitted first instead, causing reordering and/or wrong</span>
<span class="cm"> * processing of the EOSP. The cause is that allowing frames to be</span>
<span class="cm"> * transmitted to a certain station is out-of-band communication to</span>
<span class="cm"> * the device. To allow this problem to be solved, the driver can</span>
<span class="cm"> * call ieee80211_sta_block_awake() if frames are buffered when it</span>
<span class="cm"> * is notified that the station went to sleep. When all these frames</span>
<span class="cm"> * have been filtered (see above), it must call the function again</span>
<span class="cm"> * to indicate that the station is no longer blocked.</span>
<span class="cm"> *</span>
<span class="cm"> * If the driver buffers frames in the driver for aggregation in any</span>
<span class="cm"> * way, it must use the ieee80211_sta_set_buffered() call when it is</span>
<span class="cm"> * notified of the station going to sleep to inform mac80211 of any</span>
<span class="cm"> * TIDs that have frames buffered. Note that when a station wakes up</span>
<span class="cm"> * this information is reset (hence the requirement to call it when</span>
<span class="cm"> * informed of the station going to sleep). Then, when a service</span>
<span class="cm"> * period starts for any reason, @release_buffered_frames is called</span>
<span class="cm"> * with the number of frames to be released and which TIDs they are</span>
<span class="cm"> * to come from. In this case, the driver is responsible for setting</span>
<span class="cm"> * the EOSP (for uAPSD) and MORE_DATA bits in the released frames,</span>
<span class="cm"> * to help the @more_data paramter is passed to tell the driver if</span>
<span class="cm"> * there is more data on other TIDs -- the TIDs to release frames</span>
<span class="cm"> * from are ignored since mac80211 doesn&#39;t know how many frames the</span>
<span class="cm"> * buffers for those TIDs contain.</span>
<span class="cm"> *</span>
<span class="cm"> * If the driver also implement GO mode, where absence periods may</span>
<span class="cm"> * shorten service periods (or abort PS-Poll responses), it must</span>
<span class="cm"> * filter those response frames except in the case of frames that</span>
<span class="cm"> * are buffered in the driver -- those must remain buffered to avoid</span>
<span class="cm"> * reordering. Because it is possible that no frames are released</span>
<span class="cm"> * in this case, the driver must call ieee80211_sta_eosp_irqsafe()</span>
<span class="cm"> * to indicate to mac80211 that the service period ended anyway.</span>
<span class="cm"> *</span>
<span class="cm"> * Finally, if frames from multiple TIDs are released from mac80211</span>
<span class="cm"> * but the driver might reorder them, it must clear &amp; set the flags</span>
<span class="cm"> * appropriately (only the last frame may have %IEEE80211_TX_STATUS_EOSP)</span>
<span class="cm"> * and also take care of the EOSP and MORE_DATA bits in the frame.</span>
<span class="cm"> * The driver may also use ieee80211_sta_eosp_irqsafe() in this case.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: HW queue control</span>
<span class="cm"> *</span>
<span class="cm"> * Before HW queue control was introduced, mac80211 only had a single static</span>
<span class="cm"> * assignment of per-interface AC software queues to hardware queues. This</span>
<span class="cm"> * was problematic for a few reasons:</span>
<span class="cm"> * 1) off-channel transmissions might get stuck behind other frames</span>
<span class="cm"> * 2) multiple virtual interfaces couldn&#39;t be handled correctly</span>
<span class="cm"> * 3) after-DTIM frames could get stuck behind other frames</span>
<span class="cm"> *</span>
<span class="cm"> * To solve this, hardware typically uses multiple different queues for all</span>
<span class="cm"> * the different usages, and this needs to be propagated into mac80211 so it</span>
<span class="cm"> * won&#39;t have the same problem with the software queues.</span>
<span class="cm"> *</span>
<span class="cm"> * Therefore, mac80211 now offers the %IEEE80211_HW_QUEUE_CONTROL capability</span>
<span class="cm"> * flag that tells it that the driver implements its own queue control. To do</span>
<span class="cm"> * so, the driver will set up the various queues in each &amp;struct ieee80211_vif</span>
<span class="cm"> * and the offchannel queue in &amp;struct ieee80211_hw. In response, mac80211 will</span>
<span class="cm"> * use those queue IDs in the hw_queue field of &amp;struct ieee80211_tx_info and</span>
<span class="cm"> * if necessary will queue the frame on the right software queue that mirrors</span>
<span class="cm"> * the hardware queue.</span>
<span class="cm"> * Additionally, the driver has to then use these HW queue IDs for the queue</span>
<span class="cm"> * management functions (ieee80211_stop_queue() et al.)</span>
<span class="cm"> *</span>
<span class="cm"> * The driver is free to set up the queue mappings as needed, multiple virtual</span>
<span class="cm"> * interfaces may map to the same hardware queues if needed. The setup has to</span>
<span class="cm"> * happen during add_interface or change_interface callbacks. For example, a</span>
<span class="cm"> * driver supporting station+station and station+AP modes might decide to have</span>
<span class="cm"> * 10 hardware queues to handle different scenarios:</span>
<span class="cm"> *</span>
<span class="cm"> * 4 AC HW queues for 1st vif: 0, 1, 2, 3</span>
<span class="cm"> * 4 AC HW queues for 2nd vif: 4, 5, 6, 7</span>
<span class="cm"> * after-DTIM queue for AP:   8</span>
<span class="cm"> * off-channel queue:         9</span>
<span class="cm"> *</span>
<span class="cm"> * It would then set up the hardware like this:</span>
<span class="cm"> *   hw.offchannel_tx_hw_queue = 9</span>
<span class="cm"> *</span>
<span class="cm"> * and the first virtual interface that is added as follows:</span>
<span class="cm"> *   vif.hw_queue[IEEE80211_AC_VO] = 0</span>
<span class="cm"> *   vif.hw_queue[IEEE80211_AC_VI] = 1</span>
<span class="cm"> *   vif.hw_queue[IEEE80211_AC_BE] = 2</span>
<span class="cm"> *   vif.hw_queue[IEEE80211_AC_BK] = 3</span>
<span class="cm"> *   vif.cab_queue = 8 // if AP mode, otherwise %IEEE80211_INVAL_HW_QUEUE</span>
<span class="cm"> * and the second virtual interface with 4-7.</span>
<span class="cm"> *</span>
<span class="cm"> * If queue 6 gets full, for example, mac80211 would only stop the second</span>
<span class="cm"> * virtual interface&#39;s BE queue since virtual interface queues are per AC.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the vif.cab_queue value should be set to %IEEE80211_INVAL_HW_QUEUE</span>
<span class="cm"> * whenever the queue is not used (i.e. the interface is not in AP mode) if the</span>
<span class="cm"> * queue could potentially be shared since mac80211 will look at cab_queue when</span>
<span class="cm"> * a queue is stopped/woken even if the interface is not in AP mode.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_filter_flags - hardware filter flags</span>
<span class="cm"> *</span>
<span class="cm"> * These flags determine what the filter in hardware should be</span>
<span class="cm"> * programmed to let through and what should not be passed to the</span>
<span class="cm"> * stack. It is always safe to pass more frames than requested,</span>
<span class="cm"> * but this has negative impact on power consumption.</span>
<span class="cm"> *</span>
<span class="cm"> * @FIF_PROMISC_IN_BSS: promiscuous mode within your BSS,</span>
<span class="cm"> *	think of the BSS as your network segment and then this corresponds</span>
<span class="cm"> *	to the regular ethernet device promiscuous mode.</span>
<span class="cm"> *</span>
<span class="cm"> * @FIF_ALLMULTI: pass all multicast frames, this is used if requested</span>
<span class="cm"> *	by the user or if the hardware is not capable of filtering by</span>
<span class="cm"> *	multicast address.</span>
<span class="cm"> *</span>
<span class="cm"> * @FIF_FCSFAIL: pass frames with failed FCS (but you need to set the</span>
<span class="cm"> *	%RX_FLAG_FAILED_FCS_CRC for them)</span>
<span class="cm"> *</span>
<span class="cm"> * @FIF_PLCPFAIL: pass frames with failed PLCP CRC (but you need to set</span>
<span class="cm"> *	the %RX_FLAG_FAILED_PLCP_CRC for them</span>
<span class="cm"> *</span>
<span class="cm"> * @FIF_BCN_PRBRESP_PROMISC: This flag is set during scanning to indicate</span>
<span class="cm"> *	to the hardware that it should not filter beacons or probe responses</span>
<span class="cm"> *	by BSSID. Filtering them can greatly reduce the amount of processing</span>
<span class="cm"> *	mac80211 needs to do and the amount of CPU wakeups, so you should</span>
<span class="cm"> *	honour this flag if possible.</span>
<span class="cm"> *</span>
<span class="cm"> * @FIF_CONTROL: pass control frames (except for PS Poll), if PROMISC_IN_BSS</span>
<span class="cm"> * 	is not set then only those addressed to this station.</span>
<span class="cm"> *</span>
<span class="cm"> * @FIF_OTHER_BSS: pass frames destined to other BSSes</span>
<span class="cm"> *</span>
<span class="cm"> * @FIF_PSPOLL: pass PS Poll frames, if PROMISC_IN_BSS is not set then only</span>
<span class="cm"> * 	those addressed to this station.</span>
<span class="cm"> *</span>
<span class="cm"> * @FIF_PROBE_REQ: pass probe request frames</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_filter_flags</span> <span class="p">{</span>
	<span class="n">FIF_PROMISC_IN_BSS</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>
	<span class="n">FIF_ALLMULTI</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">FIF_FCSFAIL</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span>
	<span class="n">FIF_PLCPFAIL</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span>
	<span class="n">FIF_BCN_PRBRESP_PROMISC</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">,</span>
	<span class="n">FIF_CONTROL</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">,</span>
	<span class="n">FIF_OTHER_BSS</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">,</span>
	<span class="n">FIF_PSPOLL</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">,</span>
	<span class="n">FIF_PROBE_REQ</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_ampdu_mlme_action - A-MPDU actions</span>
<span class="cm"> *</span>
<span class="cm"> * These flags are used with the ampdu_action() callback in</span>
<span class="cm"> * &amp;struct ieee80211_ops to indicate which action is needed.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that drivers MUST be able to deal with a TX aggregation</span>
<span class="cm"> * session being stopped even before they OK&#39;ed starting it by</span>
<span class="cm"> * calling ieee80211_start_tx_ba_cb_irqsafe, because the peer</span>
<span class="cm"> * might receive the addBA frame and send a delBA right away!</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_AMPDU_RX_START: start Rx aggregation</span>
<span class="cm"> * @IEEE80211_AMPDU_RX_STOP: stop Rx aggregation</span>
<span class="cm"> * @IEEE80211_AMPDU_TX_START: start Tx aggregation</span>
<span class="cm"> * @IEEE80211_AMPDU_TX_STOP: stop Tx aggregation</span>
<span class="cm"> * @IEEE80211_AMPDU_TX_OPERATIONAL: TX aggregation has become operational</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_ampdu_mlme_action</span> <span class="p">{</span>
	<span class="n">IEEE80211_AMPDU_RX_START</span><span class="p">,</span>
	<span class="n">IEEE80211_AMPDU_RX_STOP</span><span class="p">,</span>
	<span class="n">IEEE80211_AMPDU_TX_START</span><span class="p">,</span>
	<span class="n">IEEE80211_AMPDU_TX_STOP</span><span class="p">,</span>
	<span class="n">IEEE80211_AMPDU_TX_OPERATIONAL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_frame_release_type - frame release reason</span>
<span class="cm"> * @IEEE80211_FRAME_RELEASE_PSPOLL: frame released for PS-Poll</span>
<span class="cm"> * @IEEE80211_FRAME_RELEASE_UAPSD: frame(s) released due to</span>
<span class="cm"> *	frame received on trigger-enabled AC</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_frame_release_type</span> <span class="p">{</span>
	<span class="n">IEEE80211_FRAME_RELEASE_PSPOLL</span><span class="p">,</span>
	<span class="n">IEEE80211_FRAME_RELEASE_UAPSD</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_rate_control_changed - flags to indicate what changed</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_RC_BW_CHANGED: The bandwidth that can be used to transmit</span>
<span class="cm"> *	to this station changed.</span>
<span class="cm"> * @IEEE80211_RC_SMPS_CHANGED: The SMPS state of the station changed.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_rate_control_changed</span> <span class="p">{</span>
	<span class="n">IEEE80211_RC_BW_CHANGED</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">IEEE80211_RC_SMPS_CHANGED</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_ops - callbacks from mac80211 to the driver</span>
<span class="cm"> *</span>
<span class="cm"> * This structure contains various callbacks that the driver may</span>
<span class="cm"> * handle or, in some cases, must handle, for example to configure</span>
<span class="cm"> * the hardware to a new channel or to transmit a frame.</span>
<span class="cm"> *</span>
<span class="cm"> * @tx: Handler that 802.11 module calls for each transmitted frame.</span>
<span class="cm"> *	skb contains the buffer starting from the IEEE 802.11 header.</span>
<span class="cm"> *	The low-level driver should send the frame out based on</span>
<span class="cm"> *	configuration in the TX control data. This handler should,</span>
<span class="cm"> *	preferably, never fail and stop queues appropriately.</span>
<span class="cm"> *	This must be implemented if @tx_frags is not.</span>
<span class="cm"> *	Must be atomic.</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_frags: Called to transmit multiple fragments of a single MSDU.</span>
<span class="cm"> *	This handler must consume all fragments, sending out some of</span>
<span class="cm"> *	them only is useless and it can&#39;t ask for some of them to be</span>
<span class="cm"> *	queued again. If the frame is not fragmented the queue has a</span>
<span class="cm"> *	single SKB only. To avoid issues with the networking stack</span>
<span class="cm"> *	when TX status is reported the frames should be removed from</span>
<span class="cm"> *	the skb queue.</span>
<span class="cm"> *	If this is used, the tx_info @vif and @sta pointers will be</span>
<span class="cm"> *	invalid -- you must not use them in that case.</span>
<span class="cm"> *	This must be implemented if @tx isn&#39;t.</span>
<span class="cm"> *	Must be atomic.</span>
<span class="cm"> *</span>
<span class="cm"> * @start: Called before the first netdevice attached to the hardware</span>
<span class="cm"> *	is enabled. This should turn on the hardware and must turn on</span>
<span class="cm"> *	frame reception (for possibly enabled monitor interfaces.)</span>
<span class="cm"> *	Returns negative error codes, these may be seen in userspace,</span>
<span class="cm"> *	or zero.</span>
<span class="cm"> *	When the device is started it should not have a MAC address</span>
<span class="cm"> *	to avoid acknowledging frames before a non-monitor device</span>
<span class="cm"> *	is added.</span>
<span class="cm"> *	Must be implemented and can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @stop: Called after last netdevice attached to the hardware</span>
<span class="cm"> *	is disabled. This should turn off the hardware (at least</span>
<span class="cm"> *	it must turn off frame reception.)</span>
<span class="cm"> *	May be called right after add_interface if that rejects</span>
<span class="cm"> *	an interface. If you added any work onto the mac80211 workqueue</span>
<span class="cm"> *	you should ensure to cancel it on this callback.</span>
<span class="cm"> *	Must be implemented and can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @suspend: Suspend the device; mac80211 itself will quiesce before and</span>
<span class="cm"> *	stop transmitting and doing any other configuration, and then</span>
<span class="cm"> *	ask the device to suspend. This is only invoked when WoWLAN is</span>
<span class="cm"> *	configured, otherwise the device is deconfigured completely and</span>
<span class="cm"> *	reconfigured at resume time.</span>
<span class="cm"> *	The driver may also impose special conditions under which it</span>
<span class="cm"> *	wants to use the &quot;normal&quot; suspend (deconfigure), say if it only</span>
<span class="cm"> *	supports WoWLAN when the device is associated. In this case, it</span>
<span class="cm"> *	must return 1 from this function.</span>
<span class="cm"> *</span>
<span class="cm"> * @resume: If WoWLAN was configured, this indicates that mac80211 is</span>
<span class="cm"> *	now resuming its operation, after this the device must be fully</span>
<span class="cm"> *	functional again. If this returns an error, the only way out is</span>
<span class="cm"> *	to also unregister the device. If it returns 1, then mac80211</span>
<span class="cm"> *	will also go through the regular complete restart on resume.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_wakeup: Enable or disable wakeup when WoWLAN configuration is</span>
<span class="cm"> *	modified. The reason is that device_set_wakeup_enable() is</span>
<span class="cm"> *	supposed to be called when the configuration changes, not only</span>
<span class="cm"> *	in suspend().</span>
<span class="cm"> *</span>
<span class="cm"> * @add_interface: Called when a netdevice attached to the hardware is</span>
<span class="cm"> *	enabled. Because it is not called for monitor mode devices, @start</span>
<span class="cm"> *	and @stop must be implemented.</span>
<span class="cm"> *	The driver should perform any initialization it needs before</span>
<span class="cm"> *	the device can be enabled. The initial configuration for the</span>
<span class="cm"> *	interface is given in the conf parameter.</span>
<span class="cm"> *	The callback may refuse to add an interface by returning a</span>
<span class="cm"> *	negative error code (which will be seen in userspace.)</span>
<span class="cm"> *	Must be implemented and can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @change_interface: Called when a netdevice changes type. This callback</span>
<span class="cm"> *	is optional, but only if it is supported can interface types be</span>
<span class="cm"> *	switched while the interface is UP. The callback may sleep.</span>
<span class="cm"> *	Note that while an interface is being switched, it will not be</span>
<span class="cm"> *	found by the interface iteration callbacks.</span>
<span class="cm"> *</span>
<span class="cm"> * @remove_interface: Notifies a driver that an interface is going down.</span>
<span class="cm"> *	The @stop callback is called after this if it is the last interface</span>
<span class="cm"> *	and no monitor interfaces are present.</span>
<span class="cm"> *	When all interfaces are removed, the MAC address in the hardware</span>
<span class="cm"> *	must be cleared so the device no longer acknowledges packets,</span>
<span class="cm"> *	the mac_addr member of the conf structure is, however, set to the</span>
<span class="cm"> *	MAC address of the device going away.</span>
<span class="cm"> *	Hence, this callback must be implemented. It can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @config: Handler for configuration requests. IEEE 802.11 code calls this</span>
<span class="cm"> *	function to change hardware configuration, e.g., channel.</span>
<span class="cm"> *	This function should never fail but returns a negative error code</span>
<span class="cm"> *	if it does. The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @bss_info_changed: Handler for configuration requests related to BSS</span>
<span class="cm"> *	parameters that may vary during BSS&#39;s lifespan, and may affect low</span>
<span class="cm"> *	level driver (e.g. assoc/disassoc status, erp parameters).</span>
<span class="cm"> *	This function should not be used if no BSS has been set, unless</span>
<span class="cm"> *	for association indication. The @changed parameter indicates which</span>
<span class="cm"> *	of the bss parameters has changed when a call is made. The callback</span>
<span class="cm"> *	can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @prepare_multicast: Prepare for multicast filter configuration.</span>
<span class="cm"> *	This callback is optional, and its return value is passed</span>
<span class="cm"> *	to configure_filter(). This callback must be atomic.</span>
<span class="cm"> *</span>
<span class="cm"> * @configure_filter: Configure the device&#39;s RX filter.</span>
<span class="cm"> *	See the section &quot;Frame filtering&quot; for more information.</span>
<span class="cm"> *	This callback must be implemented and can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_tim: Set TIM bit. mac80211 calls this function when a TIM bit</span>
<span class="cm"> * 	must be set or cleared for a given STA. Must be atomic.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_key: See the section &quot;Hardware crypto acceleration&quot;</span>
<span class="cm"> *	This callback is only called between add_interface and</span>
<span class="cm"> *	remove_interface calls, i.e. while the given virtual interface</span>
<span class="cm"> *	is enabled.</span>
<span class="cm"> *	Returns a negative error code if the key can&#39;t be added.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @update_tkip_key: See the section &quot;Hardware crypto acceleration&quot;</span>
<span class="cm"> * 	This callback will be called in the context of Rx. Called for drivers</span>
<span class="cm"> * 	which set IEEE80211_KEY_FLAG_TKIP_REQ_RX_P1_KEY.</span>
<span class="cm"> *	The callback must be atomic.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_rekey_data: If the device supports GTK rekeying, for example while the</span>
<span class="cm"> *	host is suspended, it can assign this callback to retrieve the data</span>
<span class="cm"> *	necessary to do GTK rekeying, this is the KEK, KCK and replay counter.</span>
<span class="cm"> *	After rekeying was done it should (for example during resume) notify</span>
<span class="cm"> *	userspace of the new replay counter using ieee80211_gtk_rekey_notify().</span>
<span class="cm"> *</span>
<span class="cm"> * @hw_scan: Ask the hardware to service the scan request, no need to start</span>
<span class="cm"> *	the scan state machine in stack. The scan must honour the channel</span>
<span class="cm"> *	configuration done by the regulatory agent in the wiphy&#39;s</span>
<span class="cm"> *	registered bands. The hardware (or the driver) needs to make sure</span>
<span class="cm"> *	that power save is disabled.</span>
<span class="cm"> *	The @req ie/ie_len members are rewritten by mac80211 to contain the</span>
<span class="cm"> *	entire IEs after the SSID, so that drivers need not look at these</span>
<span class="cm"> *	at all but just send them after the SSID -- mac80211 includes the</span>
<span class="cm"> *	(extended) supported rates and HT information (where applicable).</span>
<span class="cm"> *	When the scan finishes, ieee80211_scan_completed() must be called;</span>
<span class="cm"> *	note that it also must be called when the scan cannot finish due to</span>
<span class="cm"> *	any error unless this callback returned a negative error code.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @cancel_hw_scan: Ask the low-level tp cancel the active hw scan.</span>
<span class="cm"> *	The driver should ask the hardware to cancel the scan (if possible),</span>
<span class="cm"> *	but the scan will be completed only after the driver will call</span>
<span class="cm"> *	ieee80211_scan_completed().</span>
<span class="cm"> *	This callback is needed for wowlan, to prevent enqueueing a new</span>
<span class="cm"> *	scan_work after the low-level driver was already suspended.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @sched_scan_start: Ask the hardware to start scanning repeatedly at</span>
<span class="cm"> *	specific intervals.  The driver must call the</span>
<span class="cm"> *	ieee80211_sched_scan_results() function whenever it finds results.</span>
<span class="cm"> *	This process will continue until sched_scan_stop is called.</span>
<span class="cm"> *</span>
<span class="cm"> * @sched_scan_stop: Tell the hardware to stop an ongoing scheduled scan.</span>
<span class="cm"> *</span>
<span class="cm"> * @sw_scan_start: Notifier function that is called just before a software scan</span>
<span class="cm"> *	is started. Can be NULL, if the driver doesn&#39;t need this notification.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @sw_scan_complete: Notifier function that is called just after a</span>
<span class="cm"> *	software scan finished. Can be NULL, if the driver doesn&#39;t need</span>
<span class="cm"> *	this notification.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @get_stats: Return low-level statistics.</span>
<span class="cm"> * 	Returns zero if statistics are available.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @get_tkip_seq: If your device implements TKIP encryption in hardware this</span>
<span class="cm"> *	callback should be provided to read the TKIP transmit IVs (both IV32</span>
<span class="cm"> *	and IV16) for the given key from hardware.</span>
<span class="cm"> *	The callback must be atomic.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_frag_threshold: Configuration of fragmentation threshold. Assign this</span>
<span class="cm"> *	if the device does fragmentation by itself; if this callback is</span>
<span class="cm"> *	implemented then the stack will not do fragmentation.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_rts_threshold: Configuration of RTS threshold (if device needs it)</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @sta_add: Notifies low level driver about addition of an associated station,</span>
<span class="cm"> *	AP, IBSS/WDS/mesh peer etc. This callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @sta_remove: Notifies low level driver about removal of an associated</span>
<span class="cm"> *	station, AP, IBSS/WDS/mesh peer etc. This callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @sta_notify: Notifies low level driver about power state transition of an</span>
<span class="cm"> *	associated station, AP,  IBSS/WDS/mesh peer etc. For a VIF operating</span>
<span class="cm"> *	in AP mode, this callback will not be called when the flag</span>
<span class="cm"> *	%IEEE80211_HW_AP_LINK_PS is set. Must be atomic.</span>
<span class="cm"> *</span>
<span class="cm"> * @sta_state: Notifies low level driver about state transition of a</span>
<span class="cm"> *	station (which can be the AP, a client, IBSS/WDS/mesh peer etc.)</span>
<span class="cm"> *	This callback is mutually exclusive with @sta_add/@sta_remove.</span>
<span class="cm"> *	It must not fail for down transitions but may fail for transitions</span>
<span class="cm"> *	up the list of states.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @sta_rc_update: Notifies the driver of changes to the bitrates that can be</span>
<span class="cm"> *	used to transmit to the station. The changes are advertised with bits</span>
<span class="cm"> *	from &amp;enum ieee80211_rate_control_changed and the values are reflected</span>
<span class="cm"> *	in the station data. This callback should only be used when the driver</span>
<span class="cm"> *	uses hardware rate control (%IEEE80211_HW_HAS_RATE_CONTROL) since</span>
<span class="cm"> *	otherwise the rate control algorithm is notified directly.</span>
<span class="cm"> *	Must be atomic.</span>
<span class="cm"> *</span>
<span class="cm"> * @conf_tx: Configure TX queue parameters (EDCF (aifs, cw_min, cw_max),</span>
<span class="cm"> *	bursting) for a hardware TX queue.</span>
<span class="cm"> *	Returns a negative error code on failure.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @get_tsf: Get the current TSF timer value from firmware/hardware. Currently,</span>
<span class="cm"> *	this is only used for IBSS mode BSSID merging and debugging. Is not a</span>
<span class="cm"> *	required function.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_tsf: Set the TSF timer to the specified value in the firmware/hardware.</span>
<span class="cm"> *      Currently, this is only used for IBSS mode debugging. Is not a</span>
<span class="cm"> *	required function.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @reset_tsf: Reset the TSF timer and allow firmware/hardware to synchronize</span>
<span class="cm"> *	with other STAs in the IBSS. This is only used in IBSS mode. This</span>
<span class="cm"> *	function is optional if the firmware/hardware takes full care of</span>
<span class="cm"> *	TSF synchronization.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_last_beacon: Determine whether the last IBSS beacon was sent by us.</span>
<span class="cm"> *	This is needed only for IBSS mode and the result of this function is</span>
<span class="cm"> *	used to determine whether to reply to Probe Requests.</span>
<span class="cm"> *	Returns non-zero if this device sent the last beacon.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @ampdu_action: Perform a certain A-MPDU action</span>
<span class="cm"> * 	The RA/TID combination determines the destination and TID we want</span>
<span class="cm"> * 	the ampdu action to be performed for. The action is defined through</span>
<span class="cm"> * 	ieee80211_ampdu_mlme_action. Starting sequence number (@ssn)</span>
<span class="cm"> * 	is the first frame we expect to perform the action on. Notice</span>
<span class="cm"> * 	that TX/RX_STOP can pass NULL for this parameter.</span>
<span class="cm"> *	The @buf_size parameter is only valid when the action is set to</span>
<span class="cm"> *	%IEEE80211_AMPDU_TX_OPERATIONAL and indicates the peer&#39;s reorder</span>
<span class="cm"> *	buffer size (number of subframes) for this session -- the driver</span>
<span class="cm"> *	may neither send aggregates containing more subframes than this</span>
<span class="cm"> *	nor send aggregates in a way that lost frames would exceed the</span>
<span class="cm"> *	buffer size. If just limiting the aggregate size, this would be</span>
<span class="cm"> *	possible with a buf_size of 8:</span>
<span class="cm"> *	 - TX: 1.....7</span>
<span class="cm"> *	 - RX:  2....7 (lost frame #1)</span>
<span class="cm"> *	 - TX:        8..1...</span>
<span class="cm"> *	which is invalid since #1 was now re-transmitted well past the</span>
<span class="cm"> *	buffer size of 8. Correct ways to retransmit #1 would be:</span>
<span class="cm"> *	 - TX:       1 or 18 or 81</span>
<span class="cm"> *	Even &quot;189&quot; would be wrong since 1 could be lost again.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns a negative error code on failure.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @get_survey: Return per-channel survey information</span>
<span class="cm"> *</span>
<span class="cm"> * @rfkill_poll: Poll rfkill hardware state. If you need this, you also</span>
<span class="cm"> *	need to set wiphy-&gt;rfkill_poll to %true before registration,</span>
<span class="cm"> *	and need to call wiphy_rfkill_set_hw_state() in the callback.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_coverage_class: Set slot time for given coverage class as specified</span>
<span class="cm"> *	in IEEE 802.11-2007 section 17.3.8.6 and modify ACK timeout</span>
<span class="cm"> *	accordingly. This callback is not required and may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @testmode_cmd: Implement a cfg80211 test mode command.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> * @testmode_dump: Implement a cfg80211 test mode dump. The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @flush: Flush all pending frames from the hardware queue, making sure</span>
<span class="cm"> *	that the hardware queues are empty. If the parameter @drop is set</span>
<span class="cm"> *	to %true, pending frames may be dropped. The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @channel_switch: Drivers that need (or want) to offload the channel</span>
<span class="cm"> *	switch operation for CSAs received from the AP may implement this</span>
<span class="cm"> *	callback. They must then call ieee80211_chswitch_done() to indicate</span>
<span class="cm"> *	completion of the channel switch.</span>
<span class="cm"> *</span>
<span class="cm"> * @napi_poll: Poll Rx queue for incoming data frames.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_antenna: Set antenna configuration (tx_ant, rx_ant) on the device.</span>
<span class="cm"> *	Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may</span>
<span class="cm"> *	reject TX/RX mask combinations they cannot support by returning -EINVAL</span>
<span class="cm"> *	(also see nl80211.h @NL80211_ATTR_WIPHY_ANTENNA_TX).</span>
<span class="cm"> *</span>
<span class="cm"> * @get_antenna: Get current antenna configuration from device (tx_ant, rx_ant).</span>
<span class="cm"> *</span>
<span class="cm"> * @remain_on_channel: Starts an off-channel period on the given channel, must</span>
<span class="cm"> *	call back to ieee80211_ready_on_channel() when on that channel. Note</span>
<span class="cm"> *	that normal channel traffic is not stopped as this is intended for hw</span>
<span class="cm"> *	offload. Frames to transmit on the off-channel channel are transmitted</span>
<span class="cm"> *	normally except for the %IEEE80211_TX_CTL_TX_OFFCHAN flag. When the</span>
<span class="cm"> *	duration (which will always be non-zero) expires, the driver must call</span>
<span class="cm"> *	ieee80211_remain_on_channel_expired(). This callback may sleep.</span>
<span class="cm"> * @cancel_remain_on_channel: Requests that an ongoing off-channel period is</span>
<span class="cm"> *	aborted before it expires. This callback may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_ringparam: Set tx and rx ring sizes.</span>
<span class="cm"> *</span>
<span class="cm"> * @get_ringparam: Get tx and rx ring current and maximum sizes.</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_frames_pending: Check if there is any pending frame in the hardware</span>
<span class="cm"> *	queues before entering power save.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_bitrate_mask: Set a mask of rates to be used for rate control selection</span>
<span class="cm"> *	when transmitting a frame. Currently only legacy rates are handled.</span>
<span class="cm"> *	The callback can sleep.</span>
<span class="cm"> * @rssi_callback: Notify driver when the average RSSI goes above/below</span>
<span class="cm"> *	thresholds that were registered previously. The callback can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @release_buffered_frames: Release buffered frames according to the given</span>
<span class="cm"> *	parameters. In the case where the driver buffers some frames for</span>
<span class="cm"> *	sleeping stations mac80211 will use this callback to tell the driver</span>
<span class="cm"> *	to release some frames, either for PS-poll or uAPSD.</span>
<span class="cm"> *	Note that if the @more_data paramter is %false the driver must check</span>
<span class="cm"> *	if there are more frames on the given TIDs, and if there are more than</span>
<span class="cm"> *	the frames being released then it must still set the more-data bit in</span>
<span class="cm"> *	the frame. If the @more_data parameter is %true, then of course the</span>
<span class="cm"> *	more-data bit must always be set.</span>
<span class="cm"> *	The @tids parameter tells the driver which TIDs to release frames</span>
<span class="cm"> *	from, for PS-poll it will always have only a single bit set.</span>
<span class="cm"> *	In the case this is used for a PS-poll initiated release, the</span>
<span class="cm"> *	@num_frames parameter will always be 1 so code can be shared. In</span>
<span class="cm"> *	this case the driver must also set %IEEE80211_TX_STATUS_EOSP flag</span>
<span class="cm"> *	on the TX status (and must report TX status) so that the PS-poll</span>
<span class="cm"> *	period is properly ended. This is used to avoid sending multiple</span>
<span class="cm"> *	responses for a retried PS-poll frame.</span>
<span class="cm"> *	In the case this is used for uAPSD, the @num_frames parameter may be</span>
<span class="cm"> *	bigger than one, but the driver may send fewer frames (it must send</span>
<span class="cm"> *	at least one, however). In this case it is also responsible for</span>
<span class="cm"> *	setting the EOSP flag in the QoS header of the frames. Also, when the</span>
<span class="cm"> *	service period ends, the driver must set %IEEE80211_TX_STATUS_EOSP</span>
<span class="cm"> *	on the last frame in the SP. Alternatively, it may call the function</span>
<span class="cm"> *	ieee80211_sta_eosp_irqsafe() to inform mac80211 of the end of the SP.</span>
<span class="cm"> *	This callback must be atomic.</span>
<span class="cm"> * @allow_buffered_frames: Prepare device to allow the given number of frames</span>
<span class="cm"> *	to go out to the given station. The frames will be sent by mac80211</span>
<span class="cm"> *	via the usual TX path after this call. The TX information for frames</span>
<span class="cm"> *	released will also have the %IEEE80211_TX_CTL_NO_PS_BUFFER flag set</span>
<span class="cm"> *	and the last one will also have %IEEE80211_TX_STATUS_EOSP set. In case</span>
<span class="cm"> *	frames from multiple TIDs are released and the driver might reorder</span>
<span class="cm"> *	them between the TIDs, it must set the %IEEE80211_TX_STATUS_EOSP flag</span>
<span class="cm"> *	on the last frame and clear it on all others and also handle the EOSP</span>
<span class="cm"> *	bit in the QoS header correctly. Alternatively, it can also call the</span>
<span class="cm"> *	ieee80211_sta_eosp_irqsafe() function.</span>
<span class="cm"> *	The @tids parameter is a bitmap and tells the driver which TIDs the</span>
<span class="cm"> *	frames will be on; it will at most have two bits set.</span>
<span class="cm"> *	This callback must be atomic.</span>
<span class="cm"> *</span>
<span class="cm"> * @get_et_sset_count:  Ethtool API to get string-set count.</span>
<span class="cm"> *</span>
<span class="cm"> * @get_et_stats:  Ethtool API to get a set of u64 stats.</span>
<span class="cm"> *</span>
<span class="cm"> * @get_et_strings:  Ethtool API to get a set of strings to describe stats</span>
<span class="cm"> *	and perhaps other supported types of ethtool data-sets.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_ops</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">tx</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">tx_frags</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">skbs</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">stop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfg80211_wowlan</span> <span class="o">*</span><span class="n">wowlan</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_wakeup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enabled</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">add_interface</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">change_interface</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">new_type</span><span class="p">,</span> <span class="n">bool</span> <span class="n">p2p</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove_interface</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">config</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">changed</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">bss_info_changed</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ieee80211_bss_conf</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">changed</span><span class="p">);</span>

	<span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">prepare_multicast</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">netdev_hw_addr_list</span> <span class="o">*</span><span class="n">mc_list</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">configure_filter</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">changed_flags</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">total_flags</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">multicast</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_tim</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
		       <span class="n">bool</span> <span class="n">set</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_key</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">enum</span> <span class="n">set_key_cmd</span> <span class="n">cmd</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">update_tkip_key</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">conf</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">iv32</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">phase1key</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_rekey_data</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">cfg80211_gtk_rekey_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hw_scan</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">cfg80211_scan_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cancel_hw_scan</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sched_scan_start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">cfg80211_sched_scan_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_sched_scan_ies</span> <span class="o">*</span><span class="n">ies</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sched_scan_stop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sw_scan_start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sw_scan_complete</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_stats</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ieee80211_low_level_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_tkip_seq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="n">hw_key_idx</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="o">*</span><span class="n">iv32</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">iv16</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_frag_threshold</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_rts_threshold</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sta_add</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sta_remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sta_notify</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">sta_notify_cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sta_state</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
			 <span class="k">enum</span> <span class="n">ieee80211_sta_state</span> <span class="n">old_state</span><span class="p">,</span>
			 <span class="k">enum</span> <span class="n">ieee80211_sta_state</span> <span class="n">new_state</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sta_rc_update</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">changed</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">conf_tx</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span> <span class="n">u16</span> <span class="n">ac</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_tx_queue_params</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
	<span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">get_tsf</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_tsf</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			<span class="n">u64</span> <span class="n">tsf</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset_tsf</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">tx_last_beacon</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ampdu_action</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">ieee80211_ampdu_mlme_action</span> <span class="n">action</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tid</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">ssn</span><span class="p">,</span>
			    <span class="n">u8</span> <span class="n">buf_size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_survey</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">survey_info</span> <span class="o">*</span><span class="n">survey</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rfkill_poll</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_coverage_class</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="n">coverage_class</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NL80211_TESTMODE</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">testmode_cmd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">testmode_dump</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">drop</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">channel_switch</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ieee80211_channel_switch</span> <span class="o">*</span><span class="n">ch_switch</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">napi_poll</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_antenna</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tx_ant</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rx_ant</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_antenna</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">tx_ant</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">rx_ant</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remain_on_channel</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">channel_type</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">duration</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cancel_remain_on_channel</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_ringparam</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rx</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_ringparam</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="o">*</span><span class="n">tx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">tx_max</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">rx_max</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">tx_frames_pending</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_bitrate_mask</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">cfg80211_bitrate_mask</span> <span class="o">*</span><span class="n">mask</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rssi_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">ieee80211_rssi_event</span> <span class="n">rssi_event</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">allow_buffered_frames</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
				      <span class="n">u16</span> <span class="n">tids</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_frames</span><span class="p">,</span>
				      <span class="k">enum</span> <span class="n">ieee80211_frame_release_type</span> <span class="n">reason</span><span class="p">,</span>
				      <span class="n">bool</span> <span class="n">more_data</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release_buffered_frames</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
					<span class="n">u16</span> <span class="n">tids</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_frames</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">ieee80211_frame_release_type</span> <span class="n">reason</span><span class="p">,</span>
					<span class="n">bool</span> <span class="n">more_data</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_et_sset_count</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sset</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_et_stats</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ethtool_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_et_strings</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">sset</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_alloc_hw -  Allocate a new hardware device</span>
<span class="cm"> *</span>
<span class="cm"> * This must be called once for each hardware device. The returned pointer</span>
<span class="cm"> * must be used to refer to this device when calling other functions.</span>
<span class="cm"> * mac80211 allocates a private data area for the driver pointed to by</span>
<span class="cm"> * @priv in &amp;struct ieee80211_hw, the size of this area is given as</span>
<span class="cm"> * @priv_data_len.</span>
<span class="cm"> *</span>
<span class="cm"> * @priv_data_len: length of private data</span>
<span class="cm"> * @ops: callbacks for this device</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">ieee80211_alloc_hw</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">priv_data_len</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_register_hw - Register hardware device</span>
<span class="cm"> *</span>
<span class="cm"> * You must call this function before any other functions in</span>
<span class="cm"> * mac80211. Note that before a hardware can be registered, you</span>
<span class="cm"> * need to fill the contained wiphy&#39;s information.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the device to register as returned by ieee80211_alloc_hw()</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ieee80211_register_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_tpt_blink - throughput blink description</span>
<span class="cm"> * @throughput: throughput in Kbit/sec</span>
<span class="cm"> * @blink_time: blink time in milliseconds</span>
<span class="cm"> *	(full cycle, ie. one off + one on period)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_tpt_blink</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">throughput</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blink_time</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_tpt_led_trigger_flags - throughput trigger flags</span>
<span class="cm"> * @IEEE80211_TPT_LEDTRIG_FL_RADIO: enable blinking with radio</span>
<span class="cm"> * @IEEE80211_TPT_LEDTRIG_FL_WORK: enable blinking when working</span>
<span class="cm"> * @IEEE80211_TPT_LEDTRIG_FL_CONNECTED: enable blinking when at least one</span>
<span class="cm"> *	interface is connected in some way, including being an AP</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_tpt_led_trigger_flags</span> <span class="p">{</span>
	<span class="n">IEEE80211_TPT_LEDTRIG_FL_RADIO</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">IEEE80211_TPT_LEDTRIG_FL_WORK</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">IEEE80211_TPT_LEDTRIG_FL_CONNECTED</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_MAC80211_LEDS</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__ieee80211_get_tx_led_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__ieee80211_get_rx_led_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__ieee80211_get_assoc_led_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__ieee80211_get_radio_led_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__ieee80211_create_tpt_led_trigger</span><span class="p">(</span>
				<span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_tpt_blink</span> <span class="o">*</span><span class="n">blink_table</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blink_table_len</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cm">/**</span>
<span class="cm"> * ieee80211_get_tx_led_name - get name of TX LED</span>
<span class="cm"> *</span>
<span class="cm"> * mac80211 creates a transmit LED trigger for each wireless hardware</span>
<span class="cm"> * that can be used to drive LEDs if your driver registers a LED device.</span>
<span class="cm"> * This function returns the name (or %NULL if not configured for LEDs)</span>
<span class="cm"> * of the trigger so you can automatically link the LED device.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware to get the LED trigger name for</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ieee80211_get_tx_led_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MAC80211_LEDS</span>
	<span class="k">return</span> <span class="n">__ieee80211_get_tx_led_name</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_get_rx_led_name - get name of RX LED</span>
<span class="cm"> *</span>
<span class="cm"> * mac80211 creates a receive LED trigger for each wireless hardware</span>
<span class="cm"> * that can be used to drive LEDs if your driver registers a LED device.</span>
<span class="cm"> * This function returns the name (or %NULL if not configured for LEDs)</span>
<span class="cm"> * of the trigger so you can automatically link the LED device.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware to get the LED trigger name for</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ieee80211_get_rx_led_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MAC80211_LEDS</span>
	<span class="k">return</span> <span class="n">__ieee80211_get_rx_led_name</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_get_assoc_led_name - get name of association LED</span>
<span class="cm"> *</span>
<span class="cm"> * mac80211 creates a association LED trigger for each wireless hardware</span>
<span class="cm"> * that can be used to drive LEDs if your driver registers a LED device.</span>
<span class="cm"> * This function returns the name (or %NULL if not configured for LEDs)</span>
<span class="cm"> * of the trigger so you can automatically link the LED device.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware to get the LED trigger name for</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ieee80211_get_assoc_led_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MAC80211_LEDS</span>
	<span class="k">return</span> <span class="n">__ieee80211_get_assoc_led_name</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_get_radio_led_name - get name of radio LED</span>
<span class="cm"> *</span>
<span class="cm"> * mac80211 creates a radio change LED trigger for each wireless hardware</span>
<span class="cm"> * that can be used to drive LEDs if your driver registers a LED device.</span>
<span class="cm"> * This function returns the name (or %NULL if not configured for LEDs)</span>
<span class="cm"> * of the trigger so you can automatically link the LED device.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware to get the LED trigger name for</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ieee80211_get_radio_led_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MAC80211_LEDS</span>
	<span class="k">return</span> <span class="n">__ieee80211_get_radio_led_name</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_create_tpt_led_trigger - create throughput LED trigger</span>
<span class="cm"> * @hw: the hardware to create the trigger for</span>
<span class="cm"> * @flags: trigger flags, see &amp;enum ieee80211_tpt_led_trigger_flags</span>
<span class="cm"> * @blink_table: the blink table -- needs to be ordered by throughput</span>
<span class="cm"> * @blink_table_len: size of the blink table</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %NULL (in case of error, or if no LED</span>
<span class="cm"> * triggers are configured) or the name of the new trigger.</span>
<span class="cm"> * This function must be called before ieee80211_register_hw().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">ieee80211_create_tpt_led_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_tpt_blink</span> <span class="o">*</span><span class="n">blink_table</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blink_table_len</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MAC80211_LEDS</span>
	<span class="k">return</span> <span class="n">__ieee80211_create_tpt_led_trigger</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">blink_table</span><span class="p">,</span>
						  <span class="n">blink_table_len</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_unregister_hw - Unregister a hardware device</span>
<span class="cm"> *</span>
<span class="cm"> * This function instructs mac80211 to free allocated resources</span>
<span class="cm"> * and unregister netdevices from the networking subsystem.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware to unregister</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_unregister_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_free_hw - free hardware descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * This function frees everything that was allocated, including the</span>
<span class="cm"> * private data for the driver. You must call ieee80211_unregister_hw()</span>
<span class="cm"> * before calling this function.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware to free</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_free_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_restart_hw - restart hardware completely</span>
<span class="cm"> *</span>
<span class="cm"> * Call this function when the hardware was restarted for some reason</span>
<span class="cm"> * (hardware error, ...) and the driver is unable to restore its state</span>
<span class="cm"> * by itself. mac80211 assumes that at this point the driver/hardware</span>
<span class="cm"> * is completely uninitialised and stopped, it starts the process by</span>
<span class="cm"> * calling the -&gt;start() operation. The driver will need to reset all</span>
<span class="cm"> * internal state that it has prior to calling this function.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware to restart</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_restart_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="cm">/** ieee80211_napi_schedule - schedule NAPI poll</span>
<span class="cm"> *</span>
<span class="cm"> * Use this function to schedule NAPI polling on a device.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware to start polling</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_napi_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="cm">/** ieee80211_napi_complete - complete NAPI polling</span>
<span class="cm"> *</span>
<span class="cm"> * Use this function to finish NAPI polling on a device.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware to stop polling</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_napi_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_rx - receive frame</span>
<span class="cm"> *</span>
<span class="cm"> * Use this function to hand received frames to mac80211. The receive</span>
<span class="cm"> * buffer in @skb must start with an IEEE 802.11 header. In case of a</span>
<span class="cm"> * paged @skb is used, the driver is recommended to put the ieee80211</span>
<span class="cm"> * header of the frame on the linear part of the @skb to avoid memory</span>
<span class="cm"> * allocation and/or memcpy by the stack.</span>
<span class="cm"> *</span>
<span class="cm"> * This function may not be called in IRQ context. Calls to this function</span>
<span class="cm"> * for a single hardware must be synchronized against each other. Calls to</span>
<span class="cm"> * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe() may not be</span>
<span class="cm"> * mixed for a single hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * In process context use instead ieee80211_rx_ni().</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware this frame came in on</span>
<span class="cm"> * @skb: the buffer to receive, owned by mac80211 after this call</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_rx_irqsafe - receive frame</span>
<span class="cm"> *</span>
<span class="cm"> * Like ieee80211_rx() but can be called in IRQ context</span>
<span class="cm"> * (internally defers to a tasklet.)</span>
<span class="cm"> *</span>
<span class="cm"> * Calls to this function, ieee80211_rx() or ieee80211_rx_ni() may not</span>
<span class="cm"> * be mixed for a single hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware this frame came in on</span>
<span class="cm"> * @skb: the buffer to receive, owned by mac80211 after this call</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_rx_irqsafe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_rx_ni - receive frame (in process context)</span>
<span class="cm"> *</span>
<span class="cm"> * Like ieee80211_rx() but can be called in process context</span>
<span class="cm"> * (internally disables bottom halves).</span>
<span class="cm"> *</span>
<span class="cm"> * Calls to this function, ieee80211_rx() and ieee80211_rx_irqsafe() may</span>
<span class="cm"> * not be mixed for a single hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware this frame came in on</span>
<span class="cm"> * @skb: the buffer to receive, owned by mac80211 after this call</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ieee80211_rx_ni</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">ieee80211_rx</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_sta_ps_transition - PS transition for connected sta</span>
<span class="cm"> *</span>
<span class="cm"> * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS</span>
<span class="cm"> * flag set, use this function to inform mac80211 about a connected station</span>
<span class="cm"> * entering/leaving PS mode.</span>
<span class="cm"> *</span>
<span class="cm"> * This function may not be called in IRQ context or with softirqs enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * Calls to this function for a single hardware must be synchronized against</span>
<span class="cm"> * each other.</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns -EINVAL when the requested PS mode is already set.</span>
<span class="cm"> *</span>
<span class="cm"> * @sta: currently connected sta</span>
<span class="cm"> * @start: start or stop PS</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ieee80211_sta_ps_transition</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">bool</span> <span class="n">start</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_sta_ps_transition_ni - PS transition for connected sta</span>
<span class="cm"> *                                  (in process context)</span>
<span class="cm"> *</span>
<span class="cm"> * Like ieee80211_sta_ps_transition() but can be called in process context</span>
<span class="cm"> * (internally disables bottom halves). Concurrent call restriction still</span>
<span class="cm"> * applies.</span>
<span class="cm"> *</span>
<span class="cm"> * @sta: currently connected sta</span>
<span class="cm"> * @start: start or stop PS</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ieee80211_sta_ps_transition_ni</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
						  <span class="n">bool</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ieee80211_sta_ps_transition</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The TX headroom reserved by mac80211 for its own tx_status functions.</span>
<span class="cm"> * This is enough for the radiotap header.</span>
<span class="cm"> */</span>
<span class="cp">#define IEEE80211_TX_STATUS_HEADROOM	14</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_sta_set_buffered - inform mac80211 about driver-buffered frames</span>
<span class="cm"> * @sta: &amp;struct ieee80211_sta pointer for the sleeping station</span>
<span class="cm"> * @tid: the TID that has buffered frames</span>
<span class="cm"> * @buffered: indicates whether or not frames are buffered for this TID</span>
<span class="cm"> *</span>
<span class="cm"> * If a driver buffers frames for a powersave station instead of passing</span>
<span class="cm"> * them back to mac80211 for retransmission, the station may still need</span>
<span class="cm"> * to be told that there are buffered frames via the TIM bit.</span>
<span class="cm"> *</span>
<span class="cm"> * This function informs mac80211 whether or not there are frames that are</span>
<span class="cm"> * buffered in the driver for a given TID; mac80211 can then use this data</span>
<span class="cm"> * to set the TIM bit (NOTE: This may call back into the driver&#39;s set_tim</span>
<span class="cm"> * call! Beware of the locking!)</span>
<span class="cm"> *</span>
<span class="cm"> * If all frames are released to the station (due to PS-poll or uAPSD)</span>
<span class="cm"> * then the driver needs to inform mac80211 that there no longer are</span>
<span class="cm"> * frames buffered. However, when the station wakes up mac80211 assumes</span>
<span class="cm"> * that all buffered frames will be transmitted and clears this data,</span>
<span class="cm"> * drivers need to make sure they inform mac80211 about all buffered</span>
<span class="cm"> * frames on the sleep transition (sta_notify() with %STA_NOTIFY_SLEEP).</span>
<span class="cm"> *</span>
<span class="cm"> * Note that technically mac80211 only needs to know this per AC, not per</span>
<span class="cm"> * TID, but since driver buffering will inevitably happen per TID (since</span>
<span class="cm"> * it is related to aggregation) it is easier to make mac80211 map the</span>
<span class="cm"> * TID to the AC as required instead of keeping track in all drivers that</span>
<span class="cm"> * use this API.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_sta_set_buffered</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
				<span class="n">u8</span> <span class="n">tid</span><span class="p">,</span> <span class="n">bool</span> <span class="n">buffered</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_tx_status - transmit status callback</span>
<span class="cm"> *</span>
<span class="cm"> * Call this function for all transmitted frames after they have been</span>
<span class="cm"> * transmitted. It is permissible to not call this function for</span>
<span class="cm"> * multicast frames but this can affect statistics.</span>
<span class="cm"> *</span>
<span class="cm"> * This function may not be called in IRQ context. Calls to this function</span>
<span class="cm"> * for a single hardware must be synchronized against each other. Calls</span>
<span class="cm"> * to this function, ieee80211_tx_status_ni() and ieee80211_tx_status_irqsafe()</span>
<span class="cm"> * may not be mixed for a single hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware the frame was transmitted by</span>
<span class="cm"> * @skb: the frame that was transmitted, owned by mac80211 after this call</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_tx_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_tx_status_ni - transmit status callback (in process context)</span>
<span class="cm"> *</span>
<span class="cm"> * Like ieee80211_tx_status() but can be called in process context.</span>
<span class="cm"> *</span>
<span class="cm"> * Calls to this function, ieee80211_tx_status() and</span>
<span class="cm"> * ieee80211_tx_status_irqsafe() may not be mixed</span>
<span class="cm"> * for a single hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware the frame was transmitted by</span>
<span class="cm"> * @skb: the frame that was transmitted, owned by mac80211 after this call</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ieee80211_tx_status_ni</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">ieee80211_tx_status</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_tx_status_irqsafe - IRQ-safe transmit status callback</span>
<span class="cm"> *</span>
<span class="cm"> * Like ieee80211_tx_status() but can be called in IRQ context</span>
<span class="cm"> * (internally defers to a tasklet.)</span>
<span class="cm"> *</span>
<span class="cm"> * Calls to this function, ieee80211_tx_status() and</span>
<span class="cm"> * ieee80211_tx_status_ni() may not be mixed for a single hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware the frame was transmitted by</span>
<span class="cm"> * @skb: the frame that was transmitted, owned by mac80211 after this call</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_tx_status_irqsafe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_report_low_ack - report non-responding station</span>
<span class="cm"> *</span>
<span class="cm"> * When operating in AP-mode, call this function to report a non-responding</span>
<span class="cm"> * connected STA.</span>
<span class="cm"> *</span>
<span class="cm"> * @sta: the non-responding connected sta</span>
<span class="cm"> * @num_packets: number of packets sent to @sta without a response</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_report_low_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">u32</span> <span class="n">num_packets</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_beacon_get_tim - beacon generation function</span>
<span class="cm"> * @hw: pointer obtained from ieee80211_alloc_hw().</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> * @tim_offset: pointer to variable that will receive the TIM IE offset.</span>
<span class="cm"> *	Set to 0 if invalid (in non-AP modes).</span>
<span class="cm"> * @tim_length: pointer to variable that will receive the TIM IE length,</span>
<span class="cm"> *	(including the ID and length bytes!).</span>
<span class="cm"> *	Set to 0 if invalid (in non-AP modes).</span>
<span class="cm"> *</span>
<span class="cm"> * If the driver implements beaconing modes, it must use this function to</span>
<span class="cm"> * obtain the beacon frame/template.</span>
<span class="cm"> *</span>
<span class="cm"> * If the beacon frames are generated by the host system (i.e., not in</span>
<span class="cm"> * hardware/firmware), the driver uses this function to get each beacon</span>
<span class="cm"> * frame from mac80211 -- it is responsible for calling this function</span>
<span class="cm"> * before the beacon is needed (e.g. based on hardware interrupt).</span>
<span class="cm"> *</span>
<span class="cm"> * If the beacon frames are generated by the device, then the driver</span>
<span class="cm"> * must use the returned beacon as the template and change the TIM IE</span>
<span class="cm"> * according to the current DTIM parameters/TIM bitmap.</span>
<span class="cm"> *</span>
<span class="cm"> * The driver is responsible for freeing the returned skb.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">ieee80211_beacon_get_tim</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
					 <span class="n">u16</span> <span class="o">*</span><span class="n">tim_offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">tim_length</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_beacon_get - beacon generation function</span>
<span class="cm"> * @hw: pointer obtained from ieee80211_alloc_hw().</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> *</span>
<span class="cm"> * See ieee80211_beacon_get_tim().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">ieee80211_beacon_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ieee80211_beacon_get_tim</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">vif</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_proberesp_get - retrieve a Probe Response template</span>
<span class="cm"> * @hw: pointer obtained from ieee80211_alloc_hw().</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> *</span>
<span class="cm"> * Creates a Probe Response template which can, for example, be uploaded to</span>
<span class="cm"> * hardware. The destination address should be set by the caller.</span>
<span class="cm"> *</span>
<span class="cm"> * Can only be called in AP mode.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">ieee80211_proberesp_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_pspoll_get - retrieve a PS Poll template</span>
<span class="cm"> * @hw: pointer obtained from ieee80211_alloc_hw().</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> *</span>
<span class="cm"> * Creates a PS Poll a template which can, for example, uploaded to</span>
<span class="cm"> * hardware. The template must be updated after association so that correct</span>
<span class="cm"> * AID, BSSID and MAC address is used.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Caller (or hardware) is responsible for setting the</span>
<span class="cm"> * &amp;IEEE80211_FCTL_PM bit.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">ieee80211_pspoll_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_nullfunc_get - retrieve a nullfunc template</span>
<span class="cm"> * @hw: pointer obtained from ieee80211_alloc_hw().</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> *</span>
<span class="cm"> * Creates a Nullfunc template which can, for example, uploaded to</span>
<span class="cm"> * hardware. The template must be updated after association so that correct</span>
<span class="cm"> * BSSID and address is used.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Caller (or hardware) is responsible for setting the</span>
<span class="cm"> * &amp;IEEE80211_FCTL_PM bit as well as Duration and Sequence Control fields.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">ieee80211_nullfunc_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_probereq_get - retrieve a Probe Request template</span>
<span class="cm"> * @hw: pointer obtained from ieee80211_alloc_hw().</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> * @ssid: SSID buffer</span>
<span class="cm"> * @ssid_len: length of SSID</span>
<span class="cm"> * @ie: buffer containing all IEs except SSID for the template</span>
<span class="cm"> * @ie_len: length of the IE buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Creates a Probe Request template which can, for example, be uploaded to</span>
<span class="cm"> * hardware.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">ieee80211_probereq_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
				       <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ssid</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ssid_len</span><span class="p">,</span>
				       <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ie_len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_rts_get - RTS frame generation function</span>
<span class="cm"> * @hw: pointer obtained from ieee80211_alloc_hw().</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> * @frame: pointer to the frame that is going to be protected by the RTS.</span>
<span class="cm"> * @frame_len: the frame length (in octets).</span>
<span class="cm"> * @frame_txctl: &amp;struct ieee80211_tx_info of the frame.</span>
<span class="cm"> * @rts: The buffer where to store the RTS frame.</span>
<span class="cm"> *</span>
<span class="cm"> * If the RTS frames are generated by the host system (i.e., not in</span>
<span class="cm"> * hardware/firmware), the low-level driver uses this function to receive</span>
<span class="cm"> * the next RTS frame from the 802.11 code. The low-level is responsible</span>
<span class="cm"> * for calling this function before and RTS frame is needed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_rts_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">frame_len</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">frame_txctl</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ieee80211_rts</span> <span class="o">*</span><span class="n">rts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_rts_duration - Get the duration field for an RTS frame</span>
<span class="cm"> * @hw: pointer obtained from ieee80211_alloc_hw().</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> * @frame_len: the length of the frame that is going to be protected by the RTS.</span>
<span class="cm"> * @frame_txctl: &amp;struct ieee80211_tx_info of the frame.</span>
<span class="cm"> *</span>
<span class="cm"> * If the RTS is generated in firmware, but the host system must provide</span>
<span class="cm"> * the duration field, the low-level driver uses this function to receive</span>
<span class="cm"> * the duration field value in little-endian byteorder.</span>
<span class="cm"> */</span>
<span class="n">__le16</span> <span class="n">ieee80211_rts_duration</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">frame_len</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">frame_txctl</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_ctstoself_get - CTS-to-self frame generation function</span>
<span class="cm"> * @hw: pointer obtained from ieee80211_alloc_hw().</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> * @frame: pointer to the frame that is going to be protected by the CTS-to-self.</span>
<span class="cm"> * @frame_len: the frame length (in octets).</span>
<span class="cm"> * @frame_txctl: &amp;struct ieee80211_tx_info of the frame.</span>
<span class="cm"> * @cts: The buffer where to store the CTS-to-self frame.</span>
<span class="cm"> *</span>
<span class="cm"> * If the CTS-to-self frames are generated by the host system (i.e., not in</span>
<span class="cm"> * hardware/firmware), the low-level driver uses this function to receive</span>
<span class="cm"> * the next CTS-to-self frame from the 802.11 code. The low-level is responsible</span>
<span class="cm"> * for calling this function before and CTS-to-self frame is needed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_ctstoself_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">frame_len</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">frame_txctl</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ieee80211_cts</span> <span class="o">*</span><span class="n">cts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_ctstoself_duration - Get the duration field for a CTS-to-self frame</span>
<span class="cm"> * @hw: pointer obtained from ieee80211_alloc_hw().</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> * @frame_len: the length of the frame that is going to be protected by the CTS-to-self.</span>
<span class="cm"> * @frame_txctl: &amp;struct ieee80211_tx_info of the frame.</span>
<span class="cm"> *</span>
<span class="cm"> * If the CTS-to-self is generated in firmware, but the host system must provide</span>
<span class="cm"> * the duration field, the low-level driver uses this function to receive</span>
<span class="cm"> * the duration field value in little-endian byteorder.</span>
<span class="cm"> */</span>
<span class="n">__le16</span> <span class="n">ieee80211_ctstoself_duration</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="n">frame_len</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_tx_info</span> <span class="o">*</span><span class="n">frame_txctl</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_generic_frame_duration - Calculate the duration field for a frame</span>
<span class="cm"> * @hw: pointer obtained from ieee80211_alloc_hw().</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> * @band: the band to calculate the frame duration on</span>
<span class="cm"> * @frame_len: the length of the frame.</span>
<span class="cm"> * @rate: the rate at which the frame is going to be transmitted.</span>
<span class="cm"> *</span>
<span class="cm"> * Calculate the duration field of some generic frame, given its</span>
<span class="cm"> * length and transmission rate (in 100kbps).</span>
<span class="cm"> */</span>
<span class="n">__le16</span> <span class="n">ieee80211_generic_frame_duration</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">frame_len</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ieee80211_rate</span> <span class="o">*</span><span class="n">rate</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_get_buffered_bc - accessing buffered broadcast and multicast frames</span>
<span class="cm"> * @hw: pointer as obtained from ieee80211_alloc_hw().</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> *</span>
<span class="cm"> * Function for accessing buffered broadcast and multicast frames. If</span>
<span class="cm"> * hardware/firmware does not implement buffering of broadcast/multicast</span>
<span class="cm"> * frames when power saving is used, 802.11 code buffers them in the host</span>
<span class="cm"> * memory. The low-level driver uses this function to fetch next buffered</span>
<span class="cm"> * frame. In most cases, this is used when generating beacon frame. This</span>
<span class="cm"> * function returns a pointer to the next buffered skb or NULL if no more</span>
<span class="cm"> * buffered frames are available.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: buffered frames are returned only after DTIM beacon frame was</span>
<span class="cm"> * generated with ieee80211_beacon_get() and the low-level driver must thus</span>
<span class="cm"> * call ieee80211_beacon_get() first. ieee80211_get_buffered_bc() returns</span>
<span class="cm"> * NULL if the previous generated beacon was not DTIM, so the low-level driver</span>
<span class="cm"> * does not need to check for DTIM beacons separately and should be able to</span>
<span class="cm"> * use common code for all beacons.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span>
<span class="n">ieee80211_get_buffered_bc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_get_tkip_p1k_iv - get a TKIP phase 1 key for IV32</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the TKIP phase 1 key for the given IV32.</span>
<span class="cm"> *</span>
<span class="cm"> * @keyconf: the parameter passed with the set key</span>
<span class="cm"> * @iv32: IV32 to get the P1K for</span>
<span class="cm"> * @p1k: a buffer to which the key will be written, as 5 u16 values</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_get_tkip_p1k_iv</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">keyconf</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">iv32</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">p1k</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_get_tkip_p1k - get a TKIP phase 1 key</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the TKIP phase 1 key for the IV32 taken</span>
<span class="cm"> * from the given packet.</span>
<span class="cm"> *</span>
<span class="cm"> * @keyconf: the parameter passed with the set key</span>
<span class="cm"> * @skb: the packet to take the IV32 value from that will be encrypted</span>
<span class="cm"> *	with this P1K</span>
<span class="cm"> * @p1k: a buffer to which the key will be written, as 5 u16 values</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ieee80211_get_tkip_p1k</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">keyconf</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">p1k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">ieee80211_hdrlen</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">frame_control</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">iv32</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>

	<span class="n">ieee80211_get_tkip_p1k_iv</span><span class="p">(</span><span class="n">keyconf</span><span class="p">,</span> <span class="n">iv32</span><span class="p">,</span> <span class="n">p1k</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_get_tkip_rx_p1k - get a TKIP phase 1 key for RX</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the TKIP phase 1 key for the given IV32</span>
<span class="cm"> * and transmitter address.</span>
<span class="cm"> *</span>
<span class="cm"> * @keyconf: the parameter passed with the set key</span>
<span class="cm"> * @ta: TA that will be used with the key</span>
<span class="cm"> * @iv32: IV32 to get the P1K for</span>
<span class="cm"> * @p1k: a buffer to which the key will be written, as 5 u16 values</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_get_tkip_rx_p1k</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">keyconf</span><span class="p">,</span>
			       <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ta</span><span class="p">,</span> <span class="n">u32</span> <span class="n">iv32</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">p1k</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_get_tkip_p2k - get a TKIP phase 2 key</span>
<span class="cm"> *</span>
<span class="cm"> * This function computes the TKIP RC4 key for the IV values</span>
<span class="cm"> * in the packet.</span>
<span class="cm"> *</span>
<span class="cm"> * @keyconf: the parameter passed with the set key</span>
<span class="cm"> * @skb: the packet to take the IV32/IV16 values from that will be</span>
<span class="cm"> *	encrypted with this key</span>
<span class="cm"> * @p2k: a buffer to which the key will be written, 16 bytes</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_get_tkip_p2k</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">keyconf</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">p2k</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_key_seq - key sequence counter</span>
<span class="cm"> *</span>
<span class="cm"> * @tkip: TKIP data, containing IV32 and IV16 in host byte order</span>
<span class="cm"> * @ccmp: PN data, most significant byte first (big endian,</span>
<span class="cm"> *	reverse order than in packet)</span>
<span class="cm"> * @aes_cmac: PN data, most significant byte first (big endian,</span>
<span class="cm"> *	reverse order than in packet)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_key_seq</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">iv32</span><span class="p">;</span>
			<span class="n">u16</span> <span class="n">iv16</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">tkip</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">pn</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">ccmp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">pn</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">aes_cmac</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_get_key_tx_seq - get key TX sequence counter</span>
<span class="cm"> *</span>
<span class="cm"> * @keyconf: the parameter passed with the set key</span>
<span class="cm"> * @seq: buffer to receive the sequence data</span>
<span class="cm"> *</span>
<span class="cm"> * This function allows a driver to retrieve the current TX IV/PN</span>
<span class="cm"> * for the given key. It must not be called if IV generation is</span>
<span class="cm"> * offloaded to the device.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function may only be called when no TX processing</span>
<span class="cm"> * can be done concurrently, for example when queues are stopped</span>
<span class="cm"> * and the stop has been synchronized.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_get_key_tx_seq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">keyconf</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ieee80211_key_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_get_key_rx_seq - get key RX sequence counter</span>
<span class="cm"> *</span>
<span class="cm"> * @keyconf: the parameter passed with the set key</span>
<span class="cm"> * @tid: The TID, or -1 for the management frame value (CCMP only);</span>
<span class="cm"> *	the value on TID 0 is also used for non-QoS frames. For</span>
<span class="cm"> *	CMAC, only TID 0 is valid.</span>
<span class="cm"> * @seq: buffer to receive the sequence data</span>
<span class="cm"> *</span>
<span class="cm"> * This function allows a driver to retrieve the current RX IV/PNs</span>
<span class="cm"> * for the given key. It must not be called if IV checking is done</span>
<span class="cm"> * by the device and not by mac80211.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function may only be called when no RX processing</span>
<span class="cm"> * can be done concurrently.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_get_key_rx_seq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">keyconf</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_key_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_gtk_rekey_notify - notify userspace supplicant of rekeying</span>
<span class="cm"> * @vif: virtual interface the rekeying was done on</span>
<span class="cm"> * @bssid: The BSSID of the AP, for checking association</span>
<span class="cm"> * @replay_ctr: the new replay counter after GTK rekeying</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_gtk_rekey_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">replay_ctr</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_wake_queue - wake specific queue</span>
<span class="cm"> * @hw: pointer as obtained from ieee80211_alloc_hw().</span>
<span class="cm"> * @queue: queue number (counted from zero).</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers should use this function instead of netif_wake_queue.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_wake_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_stop_queue - stop specific queue</span>
<span class="cm"> * @hw: pointer as obtained from ieee80211_alloc_hw().</span>
<span class="cm"> * @queue: queue number (counted from zero).</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers should use this function instead of netif_stop_queue.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_stop_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_queue_stopped - test status of the queue</span>
<span class="cm"> * @hw: pointer as obtained from ieee80211_alloc_hw().</span>
<span class="cm"> * @queue: queue number (counted from zero).</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers should use this function instead of netif_stop_queue.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">ieee80211_queue_stopped</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_stop_queues - stop all queues</span>
<span class="cm"> * @hw: pointer as obtained from ieee80211_alloc_hw().</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers should use this function instead of netif_stop_queue.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_stop_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_wake_queues - wake all queues</span>
<span class="cm"> * @hw: pointer as obtained from ieee80211_alloc_hw().</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers should use this function instead of netif_wake_queue.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_wake_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_scan_completed - completed hardware scan</span>
<span class="cm"> *</span>
<span class="cm"> * When hardware scan offload is used (i.e. the hw_scan() callback is</span>
<span class="cm"> * assigned) this function needs to be called by the driver to notify</span>
<span class="cm"> * mac80211 that the scan finished. This function can be called from</span>
<span class="cm"> * any context, including hardirq context.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware that finished the scan</span>
<span class="cm"> * @aborted: set to true if scan was aborted</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_scan_completed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">aborted</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_sched_scan_results - got results from scheduled scan</span>
<span class="cm"> *</span>
<span class="cm"> * When a scheduled scan is running, this function needs to be called by the</span>
<span class="cm"> * driver whenever there are new scan results available.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware that is performing scheduled scans</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_sched_scan_results</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_sched_scan_stopped - inform that the scheduled scan has stopped</span>
<span class="cm"> *</span>
<span class="cm"> * When a scheduled scan is running, this function can be called by</span>
<span class="cm"> * the driver if it needs to stop the scan to perform another task.</span>
<span class="cm"> * Usual scenarios are drivers that cannot continue the scheduled scan</span>
<span class="cm"> * while associating, for instance.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware that is performing scheduled scans</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_sched_scan_stopped</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_iterate_active_interfaces - iterate active interfaces</span>
<span class="cm"> *</span>
<span class="cm"> * This function iterates over the interfaces associated with a given</span>
<span class="cm"> * hardware that are currently active and calls the callback for them.</span>
<span class="cm"> * This function allows the iterator function to sleep, when the iterator</span>
<span class="cm"> * function is atomic @ieee80211_iterate_active_interfaces_atomic can</span>
<span class="cm"> * be used.</span>
<span class="cm"> * Does not iterate over a new interface during add_interface()</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware struct of which the interfaces should be iterated over</span>
<span class="cm"> * @iterator: the iterator function to call</span>
<span class="cm"> * @data: first argument of the iterator function</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_iterate_active_interfaces</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">iterator</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">),</span>
					 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_iterate_active_interfaces_atomic - iterate active interfaces</span>
<span class="cm"> *</span>
<span class="cm"> * This function iterates over the interfaces associated with a given</span>
<span class="cm"> * hardware that are currently active and calls the callback for them.</span>
<span class="cm"> * This function requires the iterator callback function to be atomic,</span>
<span class="cm"> * if that is not desired, use @ieee80211_iterate_active_interfaces instead.</span>
<span class="cm"> * Does not iterate over a new interface during add_interface()</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware struct of which the interfaces should be iterated over</span>
<span class="cm"> * @iterator: the iterator function to call, cannot sleep</span>
<span class="cm"> * @data: first argument of the iterator function</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_iterate_active_interfaces_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
						<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">iterator</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
						    <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">),</span>
						<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_queue_work - add work onto the mac80211 workqueue</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers and mac80211 use this to add work onto the mac80211 workqueue.</span>
<span class="cm"> * This helper ensures drivers are not queueing work when they should not be.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware struct for the interface we are adding work for</span>
<span class="cm"> * @work: the work we want to add onto the mac80211 workqueue</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_queue_delayed_work - add work onto the mac80211 workqueue</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers and mac80211 use this to queue delayed work onto the mac80211</span>
<span class="cm"> * workqueue.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: the hardware struct for the interface we are adding work for</span>
<span class="cm"> * @dwork: delayable work to queue onto the mac80211 workqueue</span>
<span class="cm"> * @delay: number of jiffies to wait before queueing</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_queue_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_start_tx_ba_session - Start a tx Block Ack session.</span>
<span class="cm"> * @sta: the station for which to start a BA session</span>
<span class="cm"> * @tid: the TID to BA on.</span>
<span class="cm"> * @timeout: session timeout value (in TUs)</span>
<span class="cm"> *</span>
<span class="cm"> * Return: success if addBA request was sent, failure otherwise</span>
<span class="cm"> *</span>
<span class="cm"> * Although mac80211/low level driver/user space application can estimate</span>
<span class="cm"> * the need to start aggregation on a certain RA/TID, the session level</span>
<span class="cm"> * will be managed by the mac80211.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ieee80211_start_tx_ba_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tid</span><span class="p">,</span>
				  <span class="n">u16</span> <span class="n">timeout</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_start_tx_ba_cb_irqsafe - low level driver ready to aggregate.</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback</span>
<span class="cm"> * @ra: receiver address of the BA session recipient.</span>
<span class="cm"> * @tid: the TID to BA on.</span>
<span class="cm"> *</span>
<span class="cm"> * This function must be called by low level driver once it has</span>
<span class="cm"> * finished with preparations for the BA session. It can be called</span>
<span class="cm"> * from any context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_start_tx_ba_cb_irqsafe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span>
				      <span class="n">u16</span> <span class="n">tid</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_stop_tx_ba_session - Stop a Block Ack session.</span>
<span class="cm"> * @sta: the station whose BA session to stop</span>
<span class="cm"> * @tid: the TID to stop BA.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: negative error if the TID is invalid, or no aggregation active</span>
<span class="cm"> *</span>
<span class="cm"> * Although mac80211/low level driver/user space application can estimate</span>
<span class="cm"> * the need to stop aggregation on a certain RA/TID, the session level</span>
<span class="cm"> * will be managed by the mac80211.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ieee80211_stop_tx_ba_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tid</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_stop_tx_ba_cb_irqsafe - low level driver ready to stop aggregate.</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback</span>
<span class="cm"> * @ra: receiver address of the BA session recipient.</span>
<span class="cm"> * @tid: the desired TID to BA on.</span>
<span class="cm"> *</span>
<span class="cm"> * This function must be called by low level driver once it has</span>
<span class="cm"> * finished with preparations for the BA session tear down. It</span>
<span class="cm"> * can be called from any context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_stop_tx_ba_cb_irqsafe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span>
				     <span class="n">u16</span> <span class="n">tid</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_find_sta - find a station</span>
<span class="cm"> *</span>
<span class="cm"> * @vif: virtual interface to look for station on</span>
<span class="cm"> * @addr: station&#39;s address</span>
<span class="cm"> *</span>
<span class="cm"> * This function must be called under RCU lock and the</span>
<span class="cm"> * resulting pointer is only valid under RCU lock as well.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">ieee80211_find_sta</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
					 <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_find_sta_by_ifaddr - find a station on hardware</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: pointer as obtained from ieee80211_alloc_hw()</span>
<span class="cm"> * @addr: remote station&#39;s address</span>
<span class="cm"> * @localaddr: local address (vif-&gt;sdata-&gt;vif.addr). Use NULL for &#39;any&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * This function must be called under RCU lock and the</span>
<span class="cm"> * resulting pointer is only valid under RCU lock as well.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: You may pass NULL for localaddr, but then you will just get</span>
<span class="cm"> *      the first STA that matches the remote address &#39;addr&#39;.</span>
<span class="cm"> *      We can have multiple STA associated with multiple</span>
<span class="cm"> *      logical stations (e.g. consider a station connecting to another</span>
<span class="cm"> *      BSSID on the same AP hardware without disconnecting first).</span>
<span class="cm"> *      In this case, the result of this method with localaddr NULL</span>
<span class="cm"> *      is not reliable.</span>
<span class="cm"> *</span>
<span class="cm"> * DO NOT USE THIS FUNCTION with localaddr NULL if at all possible.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">ieee80211_find_sta_by_ifaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					       <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
					       <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">localaddr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_sta_block_awake - block station from waking up</span>
<span class="cm"> * @hw: the hardware</span>
<span class="cm"> * @pubsta: the station</span>
<span class="cm"> * @block: whether to block or unblock</span>
<span class="cm"> *</span>
<span class="cm"> * Some devices require that all frames that are on the queues</span>
<span class="cm"> * for a specific station that went to sleep are flushed before</span>
<span class="cm"> * a poll response or frames after the station woke up can be</span>
<span class="cm"> * delivered to that it. Note that such frames must be rejected</span>
<span class="cm"> * by the driver as filtered, with the appropriate status flag.</span>
<span class="cm"> *</span>
<span class="cm"> * This function allows implementing this mode in a race-free</span>
<span class="cm"> * manner.</span>
<span class="cm"> *</span>
<span class="cm"> * To do this, a driver must keep track of the number of frames</span>
<span class="cm"> * still enqueued for a specific station. If this number is not</span>
<span class="cm"> * zero when the station goes to sleep, the driver must call</span>
<span class="cm"> * this function to force mac80211 to consider the station to</span>
<span class="cm"> * be asleep regardless of the station&#39;s actual state. Once the</span>
<span class="cm"> * number of outstanding frames reaches zero, the driver must</span>
<span class="cm"> * call this function again to unblock the station. That will</span>
<span class="cm"> * cause mac80211 to be able to send ps-poll responses, and if</span>
<span class="cm"> * the station queried in the meantime then frames will also</span>
<span class="cm"> * be sent out as a result of this. Additionally, the driver</span>
<span class="cm"> * will be notified that the station woke up some time after</span>
<span class="cm"> * it is unblocked, regardless of whether the station actually</span>
<span class="cm"> * woke up while blocked or not.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_sta_block_awake</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">pubsta</span><span class="p">,</span> <span class="n">bool</span> <span class="n">block</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_sta_eosp - notify mac80211 about end of SP</span>
<span class="cm"> * @pubsta: the station</span>
<span class="cm"> *</span>
<span class="cm"> * When a device transmits frames in a way that it can&#39;t tell</span>
<span class="cm"> * mac80211 in the TX status about the EOSP, it must clear the</span>
<span class="cm"> * %IEEE80211_TX_STATUS_EOSP bit and call this function instead.</span>
<span class="cm"> * This applies for PS-Poll as well as uAPSD.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that there is no non-_irqsafe version right now as</span>
<span class="cm"> * it wasn&#39;t needed, but just like _tx_status() and _rx()</span>
<span class="cm"> * must not be mixed in irqsafe/non-irqsafe versions, this</span>
<span class="cm"> * function must not be mixed with those either. Use the</span>
<span class="cm"> * all irqsafe, or all non-irqsafe, don&#39;t mix! If you need</span>
<span class="cm"> * the non-irqsafe version of this, you need to add it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_sta_eosp_irqsafe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">pubsta</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_iter_keys - iterate keys programmed into the device</span>
<span class="cm"> * @hw: pointer obtained from ieee80211_alloc_hw()</span>
<span class="cm"> * @vif: virtual interface to iterate, may be %NULL for all</span>
<span class="cm"> * @iter: iterator function that will be called for each key</span>
<span class="cm"> * @iter_data: custom data to pass to the iterator function</span>
<span class="cm"> *</span>
<span class="cm"> * This function can be used to iterate all the keys known to</span>
<span class="cm"> * mac80211, even those that weren&#39;t previously programmed into</span>
<span class="cm"> * the device. This is intended for use in WoWLAN if the device</span>
<span class="cm"> * needs reprogramming of the keys during suspend. Note that due</span>
<span class="cm"> * to locking reasons, it is also only safe to call this at few</span>
<span class="cm"> * spots since it must hold the RTNL and be able to sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * The order in which the keys are iterated matches the order</span>
<span class="cm"> * in which they were originally installed and handed to the</span>
<span class="cm"> * set_key callback.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_iter_keys</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
			 <span class="kt">void</span> <span class="o">*</span><span class="n">iter_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_ap_probereq_get - retrieve a Probe Request template</span>
<span class="cm"> * @hw: pointer obtained from ieee80211_alloc_hw().</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> *</span>
<span class="cm"> * Creates a Probe Request template which can, for example, be uploaded to</span>
<span class="cm"> * hardware. The template is filled with bssid, ssid and supported rate</span>
<span class="cm"> * information. This function must only be called from within the</span>
<span class="cm"> * .bss_info_changed callback function and only in managed mode. The function</span>
<span class="cm"> * is only useful when the interface is associated, otherwise it will return</span>
<span class="cm"> * NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">ieee80211_ap_probereq_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_beacon_loss - inform hardware does not receive beacons</span>
<span class="cm"> *</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> *</span>
<span class="cm"> * When beacon filtering is enabled with %IEEE80211_VIF_BEACON_FILTER and</span>
<span class="cm"> * %IEEE80211_CONF_PS is set, the driver needs to inform whenever the</span>
<span class="cm"> * hardware is not receiving beacons with this function.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_beacon_loss</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_connection_loss - inform hardware has lost connection to the AP</span>
<span class="cm"> *</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> *</span>
<span class="cm"> * When beacon filtering is enabled with %IEEE80211_VIF_BEACON_FILTER, and</span>
<span class="cm"> * %IEEE80211_CONF_PS and %IEEE80211_HW_CONNECTION_MONITOR are set, the driver</span>
<span class="cm"> * needs to inform if the connection to the AP has been lost.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will cause immediate change to disassociated state,</span>
<span class="cm"> * without connection recovery attempts.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_connection_loss</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_resume_disconnect - disconnect from AP after resume</span>
<span class="cm"> *</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> *</span>
<span class="cm"> * Instructs mac80211 to disconnect from the AP after resume.</span>
<span class="cm"> * Drivers can use this after WoWLAN if they know that the</span>
<span class="cm"> * connection cannot be kept up, for example because keys were</span>
<span class="cm"> * used while the device was asleep but the replay counters or</span>
<span class="cm"> * similar cannot be retrieved from the device during resume.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that due to implementation issues, if the driver uses</span>
<span class="cm"> * the reconfiguration functionality during resume the interface</span>
<span class="cm"> * will still be added as associated first during resume and then</span>
<span class="cm"> * disconnect normally later.</span>
<span class="cm"> *</span>
<span class="cm"> * This function can only be called from the resume callback and</span>
<span class="cm"> * the driver must not be holding any of its own locks while it</span>
<span class="cm"> * calls this function, or at least not any locks it needs in the</span>
<span class="cm"> * key configuration paths (if it supports HW crypto).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_resume_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_disable_dyn_ps - force mac80211 to temporarily disable dynamic psm</span>
<span class="cm"> *</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> *</span>
<span class="cm"> * Some hardware require full power save to manage simultaneous BT traffic</span>
<span class="cm"> * on the WLAN frequency. Full PSM is required periodically, whenever there are</span>
<span class="cm"> * burst of BT traffic. The hardware gets information of BT traffic via</span>
<span class="cm"> * hardware co-existence lines, and consequentially requests mac80211 to</span>
<span class="cm"> * (temporarily) enter full psm.</span>
<span class="cm"> * This function will only temporarily disable dynamic PS, not enable PSM if</span>
<span class="cm"> * it was not already enabled.</span>
<span class="cm"> * The driver must make sure to re-enable dynamic PS using</span>
<span class="cm"> * ieee80211_enable_dyn_ps() if the driver has disabled it.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_disable_dyn_ps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_enable_dyn_ps - restore dynamic psm after being disabled</span>
<span class="cm"> *</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> *</span>
<span class="cm"> * This function restores dynamic PS after being temporarily disabled via</span>
<span class="cm"> * ieee80211_disable_dyn_ps(). Each ieee80211_disable_dyn_ps() call must</span>
<span class="cm"> * be coupled with an eventual call to this function.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_enable_dyn_ps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_cqm_rssi_notify - inform a configured connection quality monitoring</span>
<span class="cm"> *	rssi threshold triggered</span>
<span class="cm"> *</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> * @rssi_event: the RSSI trigger event type</span>
<span class="cm"> * @gfp: context flags</span>
<span class="cm"> *</span>
<span class="cm"> * When the %IEEE80211_VIF_SUPPORTS_CQM_RSSI is set, and a connection quality</span>
<span class="cm"> * monitoring is configured with an rssi threshold, the driver will inform</span>
<span class="cm"> * whenever the rssi level reaches the threshold.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_cqm_rssi_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">nl80211_cqm_rssi_threshold_event</span> <span class="n">rssi_event</span><span class="p">,</span>
			       <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_get_operstate - get the operstate of the vif</span>
<span class="cm"> *</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> *</span>
<span class="cm"> * The driver might need to know the operstate of the net_device</span>
<span class="cm"> * (specifically, whether the link is IF_OPER_UP after resume)</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ieee80211_get_operstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_chswitch_done - Complete channel switch process</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> * @success: make the channel switch successful or not</span>
<span class="cm"> *</span>
<span class="cm"> * Complete the channel switch post-process: set the new operational channel</span>
<span class="cm"> * and wake up the suspended queues.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_chswitch_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span> <span class="n">bool</span> <span class="n">success</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_request_smps - request SM PS transition</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> * @smps_mode: new SM PS mode</span>
<span class="cm"> *</span>
<span class="cm"> * This allows the driver to request an SM PS transition in managed</span>
<span class="cm"> * mode. This is useful when the driver has more information than</span>
<span class="cm"> * the stack about possible interference, for example by bluetooth.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_request_smps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">ieee80211_smps_mode</span> <span class="n">smps_mode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_key_removed - disable hw acceleration for key</span>
<span class="cm"> * @key_conf: The key hw acceleration should be disabled for</span>
<span class="cm"> *</span>
<span class="cm"> * This allows drivers to indicate that the given key has been</span>
<span class="cm"> * removed from hardware acceleration, due to a new key that</span>
<span class="cm"> * was added. Don&#39;t use this if the key can continue to be used</span>
<span class="cm"> * for TX, if the key restriction is on RX only it is permitted</span>
<span class="cm"> * to keep the key for TX only and not call this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Due to locking constraints, it may only be called during</span>
<span class="cm"> * @set_key. This function must be allowed to sleep, and the</span>
<span class="cm"> * key it tries to disable may still be used until it returns.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_key_removed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_key_conf</span> <span class="o">*</span><span class="n">key_conf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_ready_on_channel - notification of remain-on-channel start</span>
<span class="cm"> * @hw: pointer as obtained from ieee80211_alloc_hw()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_ready_on_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_remain_on_channel_expired - remain_on_channel duration expired</span>
<span class="cm"> * @hw: pointer as obtained from ieee80211_alloc_hw()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_remain_on_channel_expired</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_stop_rx_ba_session - callback to stop existing BA sessions</span>
<span class="cm"> *</span>
<span class="cm"> * in order not to harm the system performance and user experience, the device</span>
<span class="cm"> * may request not to allow any rx ba session and tear down existing rx ba</span>
<span class="cm"> * sessions based on system constraints such as periodic BT activity that needs</span>
<span class="cm"> * to limit wlan activity (eg.sco or a2dp).&quot;</span>
<span class="cm"> * in such cases, the intention is to limit the duration of the rx ppdu and</span>
<span class="cm"> * therefore prevent the peer device to use a-mpdu aggregation.</span>
<span class="cm"> *</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> * @ba_rx_bitmap: Bit map of open rx ba per tid</span>
<span class="cm"> * @addr: &amp; to bssid mac address</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_stop_rx_ba_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span> <span class="n">u16</span> <span class="n">ba_rx_bitmap</span><span class="p">,</span>
				  <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_send_bar - send a BlockAckReq frame</span>
<span class="cm"> *</span>
<span class="cm"> * can be used to flush pending frames from the peer&#39;s aggregation reorder</span>
<span class="cm"> * buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.</span>
<span class="cm"> * @ra: the peer&#39;s destination address</span>
<span class="cm"> * @tid: the TID of the aggregation session</span>
<span class="cm"> * @ssn: the new starting sequence number for the receiver</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_send_bar</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tid</span><span class="p">,</span> <span class="n">u16</span> <span class="n">ssn</span><span class="p">);</span>

<span class="cm">/* Rate control API */</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_tx_rate_control - rate control information for/from RC algo</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: The hardware the algorithm is invoked for.</span>
<span class="cm"> * @sband: The band this frame is being transmitted on.</span>
<span class="cm"> * @bss_conf: the current BSS configuration</span>
<span class="cm"> * @skb: the skb that will be transmitted, the control information in it needs</span>
<span class="cm"> *	to be filled in</span>
<span class="cm"> * @reported_rate: The rate control algorithm can fill this in to indicate</span>
<span class="cm"> *	which rate should be reported to userspace as the current rate and</span>
<span class="cm"> *	used for rate calculations in the mesh network.</span>
<span class="cm"> * @rts: whether RTS will be used for this frame because it is longer than the</span>
<span class="cm"> *	RTS threshold</span>
<span class="cm"> * @short_preamble: whether mac80211 will request short-preamble transmission</span>
<span class="cm"> *	if the selected rate supports it</span>
<span class="cm"> * @max_rate_idx: user-requested maximum (legacy) rate</span>
<span class="cm"> *	(deprecated; this will be removed once drivers get updated to use</span>
<span class="cm"> *	rate_idx_mask)</span>
<span class="cm"> * @rate_idx_mask: user-requested (legacy) rate mask</span>
<span class="cm"> * @rate_idx_mcs_mask: user-requested MCS rate mask</span>
<span class="cm"> * @bss: whether this frame is sent out in AP or IBSS mode</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_tx_rate_control</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_bss_conf</span> <span class="o">*</span><span class="n">bss_conf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_tx_rate</span> <span class="n">reported_rate</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rts</span><span class="p">,</span> <span class="n">short_preamble</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_rate_idx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rate_idx_mask</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rate_idx_mcs_mask</span><span class="p">[</span><span class="n">IEEE80211_HT_MCS_MASK_LEN</span><span class="p">];</span>
	<span class="n">bool</span> <span class="n">bss</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rate_control_ops</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ieee80211_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfsdir</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>

	<span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc_sta</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rate_init</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv_sta</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rate_update</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv_sta</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">changed</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free_sta</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="o">*</span><span class="n">priv_sta</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">tx_status</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv_sta</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_rate</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv_sta</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ieee80211_tx_rate_control</span> <span class="o">*</span><span class="n">txrc</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">add_sta_debugfs</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv_sta</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove_sta_debugfs</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv_sta</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rate_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sta</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">sta</span><span class="o">-&gt;</span><span class="n">supp_rates</span><span class="p">[</span><span class="n">band</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="n">index</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rate_control_send_low - helper for drivers for management/no-ack frames</span>
<span class="cm"> *</span>
<span class="cm"> * Rate control algorithms that agree to use the lowest rate to</span>
<span class="cm"> * send management frames and NO_ACK data with the respective hw</span>
<span class="cm"> * retries should use this in the beginning of their mac80211 get_rate</span>
<span class="cm"> * callback. If true is returned the rate control can simply return.</span>
<span class="cm"> * If false is returned we guarantee that sta and sta and priv_sta is</span>
<span class="cm"> * not null.</span>
<span class="cm"> *</span>
<span class="cm"> * Rate control algorithms wishing to do more intelligent selection of</span>
<span class="cm"> * rate for multicast/broadcast frames may choose to not use this.</span>
<span class="cm"> *</span>
<span class="cm"> * @sta: &amp;struct ieee80211_sta pointer to the target destination. Note</span>
<span class="cm"> * 	that this may be null.</span>
<span class="cm"> * @priv_sta: private rate control structure. This may be null.</span>
<span class="cm"> * @txrc: rate control information we sholud populate for mac80211.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="n">rate_control_send_low</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">priv_sta</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ieee80211_tx_rate_control</span> <span class="o">*</span><span class="n">txrc</span><span class="p">);</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="n">s8</span>
<span class="nf">rate_lowest_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sband</span><span class="o">-&gt;</span><span class="n">n_bitrates</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rate_supported</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">sband</span><span class="o">-&gt;</span><span class="n">band</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* warn when we cannot find a rate. */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* and return 0 (the lowest index) */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="n">bool</span> <span class="nf">rate_usable_index_exists</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ieee80211_sta</span> <span class="o">*</span><span class="n">sta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sband</span><span class="o">-&gt;</span><span class="n">n_bitrates</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rate_supported</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">sband</span><span class="o">-&gt;</span><span class="n">band</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">ieee80211_rate_control_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">rate_control_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ieee80211_rate_control_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">rate_control_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">conf_is_ht20</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_conf</span> <span class="o">*</span><span class="n">conf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">channel_type</span> <span class="o">==</span> <span class="n">NL80211_CHAN_HT20</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">conf_is_ht40_minus</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_conf</span> <span class="o">*</span><span class="n">conf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">channel_type</span> <span class="o">==</span> <span class="n">NL80211_CHAN_HT40MINUS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">conf_is_ht40_plus</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_conf</span> <span class="o">*</span><span class="n">conf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">channel_type</span> <span class="o">==</span> <span class="n">NL80211_CHAN_HT40PLUS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">conf_is_ht40</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_conf</span> <span class="o">*</span><span class="n">conf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">conf_is_ht40_minus</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span> <span class="o">||</span> <span class="n">conf_is_ht40_plus</span><span class="p">(</span><span class="n">conf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">conf_is_ht</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_conf</span> <span class="o">*</span><span class="n">conf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">channel_type</span> <span class="o">!=</span> <span class="n">NL80211_CHAN_NO_HT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">nl80211_iftype</span>
<span class="nf">ieee80211_iftype_p2p</span><span class="p">(</span><span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">type</span><span class="p">,</span> <span class="n">bool</span> <span class="n">p2p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p2p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NL80211_IFTYPE_STATION</span>:
			<span class="k">return</span> <span class="n">NL80211_IFTYPE_P2P_CLIENT</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NL80211_IFTYPE_AP</span>:
			<span class="k">return</span> <span class="n">NL80211_IFTYPE_P2P_GO</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">nl80211_iftype</span>
<span class="nf">ieee80211_vif_type_p2p</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ieee80211_iftype_p2p</span><span class="p">(</span><span class="n">vif</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">vif</span><span class="o">-&gt;</span><span class="n">p2p</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ieee80211_enable_rssi_reports</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">rssi_min_thold</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">rssi_max_thold</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ieee80211_disable_rssi_reports</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ieee80211_add_srates_ie</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">need_basic</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ieee80211_add_ext_srates_ie</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">need_basic</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_ave_rssi - report the average rssi for the specified interface</span>
<span class="cm"> *</span>
<span class="cm"> * @vif: the specified virtual interface</span>
<span class="cm"> *</span>
<span class="cm"> * This function return the average rssi value for the requested interface.</span>
<span class="cm"> * It assumes that the given vif is valid.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ieee80211_ave_rssi</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_vif</span> <span class="o">*</span><span class="n">vif</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* MAC80211_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
