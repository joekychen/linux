<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › iw_handler.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>iw_handler.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file define the new driver API for Wireless Extensions</span>
<span class="cm"> *</span>
<span class="cm"> * Version :	8	16.3.07</span>
<span class="cm"> *</span>
<span class="cm"> * Authors :	Jean Tourrilhes - HPL - &lt;jt@hpl.hp.com&gt;</span>
<span class="cm"> * Copyright (c) 2001-2007 Jean Tourrilhes, All Rights Reserved.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _IW_HANDLER_H</span>
<span class="cp">#define _IW_HANDLER_H</span>

<span class="cm">/************************** DOCUMENTATION **************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Initial driver API (1996 -&gt; onward) :</span>
<span class="cm"> * -----------------------------------</span>
<span class="cm"> * The initial API just sends the IOCTL request received from user space</span>
<span class="cm"> * to the driver (via the driver ioctl handler). The driver has to</span>
<span class="cm"> * handle all the rest...</span>
<span class="cm"> *</span>
<span class="cm"> * The initial API also defines a specific handler in struct net_device</span>
<span class="cm"> * to handle wireless statistics.</span>
<span class="cm"> *</span>
<span class="cm"> * The initial APIs served us well and has proven a reasonably good design.</span>
<span class="cm"> * However, there is a few shortcommings :</span>
<span class="cm"> *	o No events, everything is a request to the driver.</span>
<span class="cm"> *	o Large ioctl function in driver with gigantic switch statement</span>
<span class="cm"> *	  (i.e. spaghetti code).</span>
<span class="cm"> *	o Driver has to mess up with copy_to/from_user, and in many cases</span>
<span class="cm"> *	  does it unproperly. Common mistakes are :</span>
<span class="cm"> *		* buffer overflows (no checks or off by one checks)</span>
<span class="cm"> *		* call copy_to/from_user with irq disabled</span>
<span class="cm"> *	o The user space interface is tied to ioctl because of the use</span>
<span class="cm"> *	  copy_to/from_user.</span>
<span class="cm"> *</span>
<span class="cm"> * New driver API (2002 -&gt; onward) :</span>
<span class="cm"> * -------------------------------</span>
<span class="cm"> * The new driver API is just a bunch of standard functions (handlers),</span>
<span class="cm"> * each handling a specific Wireless Extension. The driver just export</span>
<span class="cm"> * the list of handler it supports, and those will be called apropriately.</span>
<span class="cm"> *</span>
<span class="cm"> * I tried to keep the main advantage of the previous API (simplicity,</span>
<span class="cm"> * efficiency and light weight), and also I provide a good dose of backward</span>
<span class="cm"> * compatibility (most structures are the same, driver can use both API</span>
<span class="cm"> * simultaneously, ...).</span>
<span class="cm"> * Hopefully, I&#39;ve also addressed the shortcomming of the initial API.</span>
<span class="cm"> *</span>
<span class="cm"> * The advantage of the new API are :</span>
<span class="cm"> *	o Handling of Extensions in driver broken in small contained functions</span>
<span class="cm"> *	o Tighter checks of ioctl before calling the driver</span>
<span class="cm"> *	o Flexible commit strategy (at least, the start of it)</span>
<span class="cm"> *	o Backward compatibility (can be mixed with old API)</span>
<span class="cm"> *	o Driver doesn&#39;t have to worry about memory and user-space issues</span>
<span class="cm"> * The last point is important for the following reasons :</span>
<span class="cm"> *	o You are now able to call the new driver API from any API you</span>
<span class="cm"> *		want (including from within other parts of the kernel).</span>
<span class="cm"> *	o Common mistakes are avoided (buffer overflow, user space copy</span>
<span class="cm"> *		with irq disabled and so on).</span>
<span class="cm"> *</span>
<span class="cm"> * The Drawback of the new API are :</span>
<span class="cm"> *	o bloat (especially kernel)</span>
<span class="cm"> *	o need to migrate existing drivers to new API</span>
<span class="cm"> * My initial testing shows that the new API adds around 3kB to the kernel</span>
<span class="cm"> * and save between 0 and 5kB from a typical driver.</span>
<span class="cm"> * Also, as all structures and data types are unchanged, the migration is</span>
<span class="cm"> * quite straightforward (but tedious).</span>
<span class="cm"> *</span>
<span class="cm"> * ---</span>
<span class="cm"> *</span>
<span class="cm"> * The new driver API is defined below in this file. User space should</span>
<span class="cm"> * not be aware of what&#39;s happening down there...</span>
<span class="cm"> *</span>
<span class="cm"> * A new kernel wrapper is in charge of validating the IOCTLs and calling</span>
<span class="cm"> * the appropriate driver handler. This is implemented in :</span>
<span class="cm"> *	# net/core/wireless.c</span>
<span class="cm"> *</span>
<span class="cm"> * The driver export the list of handlers in :</span>
<span class="cm"> *	# include/linux/netdevice.h (one place)</span>
<span class="cm"> *</span>
<span class="cm"> * The new driver API is available for WIRELESS_EXT &gt;= 13.</span>
<span class="cm"> * Good luck with migration to the new API ;-)</span>
<span class="cm"> */</span>

<span class="cm">/* ---------------------- THE IMPLEMENTATION ---------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * Some of the choice I&#39;ve made are pretty controversials. Defining an</span>
<span class="cm"> * API is very much weighting compromises. This goes into some of the</span>
<span class="cm"> * details and the thinking behind the implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * Implementation goals :</span>
<span class="cm"> * --------------------</span>
<span class="cm"> * The implementation goals were as follow :</span>
<span class="cm"> *	o Obvious : you should not need a PhD to understand what&#39;s happening,</span>
<span class="cm"> *		the benefit is easier maintenance.</span>
<span class="cm"> *	o Flexible : it should accommodate a wide variety of driver</span>
<span class="cm"> *		implementations and be as flexible as the old API.</span>
<span class="cm"> *	o Lean : it should be efficient memory wise to minimise the impact</span>
<span class="cm"> *		on kernel footprint.</span>
<span class="cm"> *	o Transparent to user space : the large number of user space</span>
<span class="cm"> *		applications that use Wireless Extensions should not need</span>
<span class="cm"> *		any modifications.</span>
<span class="cm"> *</span>
<span class="cm"> * Array of functions versus Struct of functions</span>
<span class="cm"> * ---------------------------------------------</span>
<span class="cm"> * 1) Having an array of functions allow the kernel code to access the</span>
<span class="cm"> * handler in a single lookup, which is much more efficient (think hash</span>
<span class="cm"> * table here).</span>
<span class="cm"> * 2) The only drawback is that driver writer may put their handler in</span>
<span class="cm"> * the wrong slot. This is trivial to test (I set the frequency, the</span>
<span class="cm"> * bitrate changes). Once the handler is in the proper slot, it will be</span>
<span class="cm"> * there forever, because the array is only extended at the end.</span>
<span class="cm"> * 3) Backward/forward compatibility : adding new handler just require</span>
<span class="cm"> * extending the array, so you can put newer driver in older kernel</span>
<span class="cm"> * without having to patch the kernel code (and vice versa).</span>
<span class="cm"> *</span>
<span class="cm"> * All handler are of the same generic type</span>
<span class="cm"> * ----------------------------------------</span>
<span class="cm"> * That&#39;s a feature !!!</span>
<span class="cm"> * 1) Having a generic handler allow to have generic code, which is more</span>
<span class="cm"> * efficient. If each of the handler was individually typed I would need</span>
<span class="cm"> * to add a big switch in the kernel (== more bloat). This solution is</span>
<span class="cm"> * more scalable, adding new Wireless Extensions doesn&#39;t add new code.</span>
<span class="cm"> * 2) You can use the same handler in different slots of the array. For</span>
<span class="cm"> * hardware, it may be more efficient or logical to handle multiple</span>
<span class="cm"> * Wireless Extensions with a single function, and the API allow you to</span>
<span class="cm"> * do that. (An example would be a single record on the card to control</span>
<span class="cm"> * both bitrate and frequency, the handler would read the old record,</span>
<span class="cm"> * modify it according to info-&gt;cmd and rewrite it).</span>
<span class="cm"> *</span>
<span class="cm"> * Functions prototype uses union iwreq_data</span>
<span class="cm"> * -----------------------------------------</span>
<span class="cm"> * Some would have preferred functions defined this way :</span>
<span class="cm"> *	static int mydriver_ioctl_setrate(struct net_device *dev, </span>
<span class="cm"> *					  long rate, int auto)</span>
<span class="cm"> * 1) The kernel code doesn&#39;t &quot;validate&quot; the content of iwreq_data, and</span>
<span class="cm"> * can&#39;t do it (different hardware may have different notion of what a</span>
<span class="cm"> * valid frequency is), so we don&#39;t pretend that we do it.</span>
<span class="cm"> * 2) The above form is not extendable. If I want to add a flag (for</span>
<span class="cm"> * example to distinguish setting max rate and basic rate), I would</span>
<span class="cm"> * break the prototype. Using iwreq_data is more flexible.</span>
<span class="cm"> * 3) Also, the above form is not generic (see above).</span>
<span class="cm"> * 4) I don&#39;t expect driver developper using the wrong field of the</span>
<span class="cm"> * union (Doh !), so static typechecking doesn&#39;t add much value.</span>
<span class="cm"> * 5) Lastly, you can skip the union by doing :</span>
<span class="cm"> *	static int mydriver_ioctl_setrate(struct net_device *dev,</span>
<span class="cm"> *					  struct iw_request_info *info,</span>
<span class="cm"> *					  struct iw_param *rrq,</span>
<span class="cm"> *					  char *extra)</span>
<span class="cm"> * And then adding the handler in the array like this :</span>
<span class="cm"> *        (iw_handler) mydriver_ioctl_setrate,             // SIOCSIWRATE</span>
<span class="cm"> *</span>
<span class="cm"> * Using functions and not a registry</span>
<span class="cm"> * ----------------------------------</span>
<span class="cm"> * Another implementation option would have been for every instance to</span>
<span class="cm"> * define a registry (a struct containing all the Wireless Extensions)</span>
<span class="cm"> * and only have a function to commit the registry to the hardware.</span>
<span class="cm"> * 1) This approach can be emulated by the current code, but not</span>
<span class="cm"> * vice versa.</span>
<span class="cm"> * 2) Some drivers don&#39;t keep any configuration in the driver, for them</span>
<span class="cm"> * adding such a registry would be a significant bloat.</span>
<span class="cm"> * 3) The code to translate from Wireless Extension to native format is</span>
<span class="cm"> * needed anyway, so it would not reduce significantely the amount of code.</span>
<span class="cm"> * 4) The current approach only selectively translate Wireless Extensions</span>
<span class="cm"> * to native format and only selectively set, whereas the registry approach</span>
<span class="cm"> * would require to translate all WE and set all parameters for any single</span>
<span class="cm"> * change.</span>
<span class="cm"> * 5) For many Wireless Extensions, the GET operation return the current</span>
<span class="cm"> * dynamic value, not the value that was set.</span>
<span class="cm"> *</span>
<span class="cm"> * This header is &lt;net/iw_handler.h&gt;</span>
<span class="cm"> * ---------------------------------</span>
<span class="cm"> * 1) This header is kernel space only and should not be exported to</span>
<span class="cm"> * user space. Headers in &quot;include/linux/&quot; are exported, headers in</span>
<span class="cm"> * &quot;include/net/&quot; are not.</span>
<span class="cm"> *</span>
<span class="cm"> * Mixed 32/64 bit issues</span>
<span class="cm"> * ----------------------</span>
<span class="cm"> * The Wireless Extensions are designed to be 64 bit clean, by using only</span>
<span class="cm"> * datatypes with explicit storage size.</span>
<span class="cm"> * There are some issues related to kernel and user space using different</span>
<span class="cm"> * memory model, and in particular 64bit kernel with 32bit user space.</span>
<span class="cm"> * The problem is related to struct iw_point, that contains a pointer</span>
<span class="cm"> * that *may* need to be translated.</span>
<span class="cm"> * This is quite messy. The new API doesn&#39;t solve this problem (it can&#39;t),</span>
<span class="cm"> * but is a step in the right direction :</span>
<span class="cm"> * 1) Meta data about each ioctl is easily available, so we know what type</span>
<span class="cm"> * of translation is needed.</span>
<span class="cm"> * 2) The move of data between kernel and user space is only done in a single</span>
<span class="cm"> * place in the kernel, so adding specific hooks in there is possible.</span>
<span class="cm"> * 3) In the long term, it allows to move away from using ioctl as the</span>
<span class="cm"> * user space API.</span>
<span class="cm"> *</span>
<span class="cm"> * So many comments and so few code</span>
<span class="cm"> * --------------------------------</span>
<span class="cm"> * That&#39;s a feature. Comments won&#39;t bloat the resulting kernel binary.</span>
<span class="cm"> */</span>

<span class="cm">/***************************** INCLUDES *****************************/</span>

<span class="cp">#include &lt;linux/wireless.h&gt;		</span><span class="cm">/* IOCTL user space API */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>

<span class="cm">/***************************** VERSION *****************************/</span>
<span class="cm">/*</span>
<span class="cm"> * This constant is used to know which version of the driver API is</span>
<span class="cm"> * available. Hopefully, this will be pretty stable and no changes</span>
<span class="cm"> * will be needed...</span>
<span class="cm"> * I just plan to increment with each new version.</span>
<span class="cm"> */</span>
<span class="cp">#define IW_HANDLER_VERSION	8</span>

<span class="cm">/*</span>
<span class="cm"> * Changes :</span>
<span class="cm"> *</span>
<span class="cm"> * V2 to V3</span>
<span class="cm"> * --------</span>
<span class="cm"> *	- Move event definition in &lt;linux/wireless.h&gt;</span>
<span class="cm"> *	- Add Wireless Event support :</span>
<span class="cm"> *		o wireless_send_event() prototype</span>
<span class="cm"> *		o iwe_stream_add_event/point() inline functions</span>
<span class="cm"> * V3 to V4</span>
<span class="cm"> * --------</span>
<span class="cm"> *	- Reshuffle IW_HEADER_TYPE_XXX to map IW_PRIV_TYPE_XXX changes</span>
<span class="cm"> *</span>
<span class="cm"> * V4 to V5</span>
<span class="cm"> * --------</span>
<span class="cm"> *	- Add new spy support : struct iw_spy_data &amp; prototypes</span>
<span class="cm"> *</span>
<span class="cm"> * V5 to V6</span>
<span class="cm"> * --------</span>
<span class="cm"> *	- Change the way we get to spy_data method for added safety</span>
<span class="cm"> *	- Remove spy #ifdef, they are always on -&gt; cleaner code</span>
<span class="cm"> *	- Add IW_DESCR_FLAG_NOMAX flag for very large requests</span>
<span class="cm"> *	- Start migrating get_wireless_stats to struct iw_handler_def</span>
<span class="cm"> *</span>
<span class="cm"> * V6 to V7</span>
<span class="cm"> * --------</span>
<span class="cm"> *	- Add struct ieee80211_device pointer in struct iw_public_data</span>
<span class="cm"> *	- Remove (struct iw_point *)-&gt;pointer from events and streams</span>
<span class="cm"> *	- Remove spy_offset from struct iw_handler_def</span>
<span class="cm"> *	- Add &quot;check&quot; version of event macros for ieee802.11 stack</span>
<span class="cm"> *</span>
<span class="cm"> * V7 to V8</span>
<span class="cm"> * ----------</span>
<span class="cm"> *	- Prevent leaking of kernel space in stream on 64 bits.</span>
<span class="cm"> */</span>

<span class="cm">/**************************** CONSTANTS ****************************/</span>

<span class="cm">/* Enhanced spy support available */</span>
<span class="cp">#define IW_WIRELESS_SPY</span>
<span class="cp">#define IW_WIRELESS_THRSPY</span>

<span class="cm">/* Special error message for the driver to indicate that we</span>
<span class="cm"> * should do a commit after return from the iw_handler */</span>
<span class="cp">#define EIWCOMMIT	EINPROGRESS</span>

<span class="cm">/* Flags available in struct iw_request_info */</span>
<span class="cp">#define IW_REQUEST_FLAG_COMPAT	0x0001	</span><span class="cm">/* Compat ioctl call */</span><span class="cp"></span>

<span class="cm">/* Type of headers we know about (basically union iwreq_data) */</span>
<span class="cp">#define IW_HEADER_TYPE_NULL	0	</span><span class="cm">/* Not available */</span><span class="cp"></span>
<span class="cp">#define IW_HEADER_TYPE_CHAR	2	</span><span class="cm">/* char [IFNAMSIZ] */</span><span class="cp"></span>
<span class="cp">#define IW_HEADER_TYPE_UINT	4	</span><span class="cm">/* __u32 */</span><span class="cp"></span>
<span class="cp">#define IW_HEADER_TYPE_FREQ	5	</span><span class="cm">/* struct iw_freq */</span><span class="cp"></span>
<span class="cp">#define IW_HEADER_TYPE_ADDR	6	</span><span class="cm">/* struct sockaddr */</span><span class="cp"></span>
<span class="cp">#define IW_HEADER_TYPE_POINT	8	</span><span class="cm">/* struct iw_point */</span><span class="cp"></span>
<span class="cp">#define IW_HEADER_TYPE_PARAM	9	</span><span class="cm">/* struct iw_param */</span><span class="cp"></span>
<span class="cp">#define IW_HEADER_TYPE_QUAL	10	</span><span class="cm">/* struct iw_quality */</span><span class="cp"></span>

<span class="cm">/* Handling flags */</span>
<span class="cm">/* Most are not implemented. I just use them as a reminder of some</span>
<span class="cm"> * cool features we might need one day ;-) */</span>
<span class="cp">#define IW_DESCR_FLAG_NONE	0x0000	</span><span class="cm">/* Obvious */</span><span class="cp"></span>
<span class="cm">/* Wrapper level flags */</span>
<span class="cp">#define IW_DESCR_FLAG_DUMP	0x0001	</span><span class="cm">/* Not part of the dump command */</span><span class="cp"></span>
<span class="cp">#define IW_DESCR_FLAG_EVENT	0x0002	</span><span class="cm">/* Generate an event on SET */</span><span class="cp"></span>
<span class="cp">#define IW_DESCR_FLAG_RESTRICT	0x0004	</span><span class="cm">/* GET : request is ROOT only */</span><span class="cp"></span>
				<span class="cm">/* SET : Omit payload from generated iwevent */</span>
<span class="cp">#define IW_DESCR_FLAG_NOMAX	0x0008	</span><span class="cm">/* GET : no limit on request size */</span><span class="cp"></span>
<span class="cm">/* Driver level flags */</span>
<span class="cp">#define IW_DESCR_FLAG_WAIT	0x0100	</span><span class="cm">/* Wait for driver event */</span><span class="cp"></span>

<span class="cm">/****************************** TYPES ******************************/</span>

<span class="cm">/* ----------------------- WIRELESS HANDLER ----------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * A wireless handler is just a standard function, that looks like the</span>
<span class="cm"> * ioctl handler.</span>
<span class="cm"> * We also define there how a handler list look like... As the Wireless</span>
<span class="cm"> * Extension space is quite dense, we use a simple array, which is faster</span>
<span class="cm"> * (that&#39;s the perfect hash table ;-).</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Meta data about the request passed to the iw_handler.</span>
<span class="cm"> * Most handlers can safely ignore what&#39;s in there.</span>
<span class="cm"> * The &#39;cmd&#39; field might come handy if you want to use the same handler</span>
<span class="cm"> * for multiple command...</span>
<span class="cm"> * This struct is also my long term insurance. I can add new fields here</span>
<span class="cm"> * without breaking the prototype of iw_handler...</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iw_request_info</span> <span class="p">{</span>
	<span class="n">__u16</span>		<span class="n">cmd</span><span class="p">;</span>		<span class="cm">/* Wireless Extension command */</span>
	<span class="n">__u16</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* More to come ;-) */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">net_device</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This is how a function handling a Wireless Extension should look</span>
<span class="cm"> * like (both get and set, standard and private).</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">iw_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iw_request_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			  <span class="k">union</span> <span class="n">iwreq_data</span> <span class="o">*</span><span class="n">wrqu</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">extra</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This define all the handler that the driver export.</span>
<span class="cm"> * As you need only one per driver type, please use a static const</span>
<span class="cm"> * shared by all driver instances... Same for the members...</span>
<span class="cm"> * This will be linked from net_device in &lt;linux/netdevice.h&gt;</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iw_handler_def</span> <span class="p">{</span>

	<span class="cm">/* Array of handlers for standard ioctls</span>
<span class="cm">	 * We will call dev-&gt;wireless_handlers-&gt;standard[ioctl - SIOCIWFIRST]</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="n">iw_handler</span> <span class="o">*</span>	<span class="n">standard</span><span class="p">;</span>
	<span class="cm">/* Number of handlers defined (more precisely, index of the</span>
<span class="cm">	 * last defined handler + 1) */</span>
	<span class="n">__u16</span>			<span class="n">num_standard</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_WEXT_PRIV</span>
	<span class="n">__u16</span>			<span class="n">num_private</span><span class="p">;</span>
	<span class="cm">/* Number of private arg description */</span>
	<span class="n">__u16</span>			<span class="n">num_private_args</span><span class="p">;</span>
	<span class="cm">/* Array of handlers for private ioctls</span>
<span class="cm">	 * Will call dev-&gt;wireless_handlers-&gt;private[ioctl - SIOCIWFIRSTPRIV]</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="n">iw_handler</span> <span class="o">*</span>	<span class="n">private</span><span class="p">;</span>

	<span class="cm">/* Arguments of private handler. This one is just a list, so you</span>
<span class="cm">	 * can put it in any order you want and should not leave holes...</span>
<span class="cm">	 * We will automatically export that to user space... */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iw_priv_args</span> <span class="o">*</span>	<span class="n">private_args</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* New location of get_wireless_stats, to de-bloat struct net_device.</span>
<span class="cm">	 * The old pointer in struct net_device will be gradually phased</span>
<span class="cm">	 * out, and drivers are encouraged to use this one... */</span>
	<span class="k">struct</span> <span class="n">iw_statistics</span><span class="o">*</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_wireless_stats</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* ---------------------- IOCTL DESCRIPTION ---------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * One of the main goal of the new interface is to deal entirely with</span>
<span class="cm"> * user space/kernel space memory move.</span>
<span class="cm"> * For that, we need to know :</span>
<span class="cm"> *	o if iwreq is a pointer or contain the full data</span>
<span class="cm"> *	o what is the size of the data to copy</span>
<span class="cm"> *</span>
<span class="cm"> * For private IOCTLs, we use the same rules as used by iwpriv and</span>
<span class="cm"> * defined in struct iw_priv_args.</span>
<span class="cm"> *</span>
<span class="cm"> * For standard IOCTLs, things are quite different and we need to</span>
<span class="cm"> * use the stuctures below. Actually, this struct is also more</span>
<span class="cm"> * efficient, but that&#39;s another story...</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Describe how a standard IOCTL looks like.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iw_ioctl_description</span> <span class="p">{</span>
	<span class="n">__u8</span>	<span class="n">header_type</span><span class="p">;</span>		<span class="cm">/* NULL, iw_point or other */</span>
	<span class="n">__u8</span>	<span class="n">token_type</span><span class="p">;</span>		<span class="cm">/* Future */</span>
	<span class="n">__u16</span>	<span class="n">token_size</span><span class="p">;</span>		<span class="cm">/* Granularity of payload */</span>
	<span class="n">__u16</span>	<span class="n">min_tokens</span><span class="p">;</span>		<span class="cm">/* Min acceptable token number */</span>
	<span class="n">__u16</span>	<span class="n">max_tokens</span><span class="p">;</span>		<span class="cm">/* Max acceptable token number */</span>
	<span class="n">__u32</span>	<span class="n">flags</span><span class="p">;</span>			<span class="cm">/* Special handling of the request */</span>
<span class="p">};</span>

<span class="cm">/* Need to think of short header translation table. Later. */</span>

<span class="cm">/* --------------------- ENHANCED SPY SUPPORT --------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * In the old days, the driver was handling spy support all by itself.</span>
<span class="cm"> * Now, the driver can delegate this task to Wireless Extensions.</span>
<span class="cm"> * It needs to include this struct in its private part and use the</span>
<span class="cm"> * standard spy iw_handler.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Instance specific spy data, i.e. addresses spied and quality for them.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iw_spy_data</span> <span class="p">{</span>
	<span class="cm">/* --- Standard spy support --- */</span>
	<span class="kt">int</span>			<span class="n">spy_number</span><span class="p">;</span>
	<span class="n">u_char</span>			<span class="n">spy_address</span><span class="p">[</span><span class="n">IW_MAX_SPY</span><span class="p">][</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iw_quality</span>	<span class="n">spy_stat</span><span class="p">[</span><span class="n">IW_MAX_SPY</span><span class="p">];</span>
	<span class="cm">/* --- Enhanced spy support (event) */</span>
	<span class="k">struct</span> <span class="n">iw_quality</span>	<span class="n">spy_thr_low</span><span class="p">;</span>	<span class="cm">/* Low threshold */</span>
	<span class="k">struct</span> <span class="n">iw_quality</span>	<span class="n">spy_thr_high</span><span class="p">;</span>	<span class="cm">/* High threshold */</span>
	<span class="n">u_char</span>			<span class="n">spy_thr_under</span><span class="p">[</span><span class="n">IW_MAX_SPY</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* --------------------- DEVICE WIRELESS DATA --------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * This is all the wireless data specific to a device instance that</span>
<span class="cm"> * is managed by the core of Wireless Extensions or the 802.11 layer.</span>
<span class="cm"> * We only keep pointer to those structures, so that a driver is free</span>
<span class="cm"> * to share them between instances.</span>
<span class="cm"> * This structure should be initialised before registering the device.</span>
<span class="cm"> * Access to this data follow the same rules as any other struct net_device</span>
<span class="cm"> * data (i.e. valid as long as struct net_device exist, same locking rules).</span>
<span class="cm"> */</span>
<span class="cm">/* Forward declaration */</span>
<span class="k">struct</span> <span class="n">libipw_device</span><span class="p">;</span>
<span class="cm">/* The struct */</span>
<span class="k">struct</span> <span class="n">iw_public_data</span> <span class="p">{</span>
	<span class="cm">/* Driver enhanced spy support */</span>
	<span class="k">struct</span> <span class="n">iw_spy_data</span> <span class="o">*</span>		<span class="n">spy_data</span><span class="p">;</span>
	<span class="cm">/* Legacy structure managed by the ipw2x00-specific IEEE 802.11 layer */</span>
	<span class="k">struct</span> <span class="n">libipw_device</span> <span class="o">*</span>		<span class="n">libipw</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**************************** PROTOTYPES ****************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Functions part of the Wireless Extensions (defined in net/core/wireless.c).</span>
<span class="cm"> * Those may be called only within the kernel.</span>
<span class="cm"> */</span>

<span class="cm">/* First : function strictly used inside the kernel */</span>

<span class="cm">/* Handle /proc/net/wireless, called in net/code/dev.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_get_wireless_info</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>

<span class="cm">/* Second : functions that may be called by driver modules */</span>

<span class="cm">/* Send a single event to user space */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wireless_send_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span>	<span class="n">dev</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">cmd</span><span class="p">,</span>
				<span class="k">union</span> <span class="n">iwreq_data</span> <span class="o">*</span>	<span class="n">wrqu</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>		<span class="n">extra</span><span class="p">);</span>

<span class="cm">/* We may need a function to send a stream of events to user space.</span>
<span class="cm"> * More on that later... */</span>

<span class="cm">/* Standard handler for SIOCSIWSPY */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">iw_handler_set_spy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span>	<span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">iw_request_info</span> <span class="o">*</span>	<span class="n">info</span><span class="p">,</span>
			      <span class="k">union</span> <span class="n">iwreq_data</span> <span class="o">*</span>	<span class="n">wrqu</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span>			<span class="n">extra</span><span class="p">);</span>
<span class="cm">/* Standard handler for SIOCGIWSPY */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">iw_handler_get_spy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span>	<span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">iw_request_info</span> <span class="o">*</span>	<span class="n">info</span><span class="p">,</span>
			      <span class="k">union</span> <span class="n">iwreq_data</span> <span class="o">*</span>	<span class="n">wrqu</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span>			<span class="n">extra</span><span class="p">);</span>
<span class="cm">/* Standard handler for SIOCSIWTHRSPY */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">iw_handler_set_thrspy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span>	<span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">iw_request_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
				 <span class="k">union</span> <span class="n">iwreq_data</span> <span class="o">*</span>	<span class="n">wrqu</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">*</span>			<span class="n">extra</span><span class="p">);</span>
<span class="cm">/* Standard handler for SIOCGIWTHRSPY */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">iw_handler_get_thrspy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span>	<span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">iw_request_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
				 <span class="k">union</span> <span class="n">iwreq_data</span> <span class="o">*</span>	<span class="n">wrqu</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">*</span>			<span class="n">extra</span><span class="p">);</span>
<span class="cm">/* Driver call to update spy records */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wireless_spy_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span>	<span class="n">dev</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span>		<span class="n">address</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">iw_quality</span> <span class="o">*</span>	<span class="n">wstats</span><span class="p">);</span>

<span class="cm">/************************* INLINE FUNTIONS *************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Function that are so simple that it&#39;s more efficient inlining them</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwe_stream_lcp_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_request_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IW_REQUEST_FLAG_COMPAT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IW_EV_COMPAT_LCP_LEN</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">IW_EV_LCP_LEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwe_stream_point_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_request_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IW_REQUEST_FLAG_COMPAT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IW_EV_COMPAT_POINT_LEN</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">IW_EV_POINT_LEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iwe_stream_event_len_adjust</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_request_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">event_len</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IW_REQUEST_FLAG_COMPAT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event_len</span> <span class="o">-=</span> <span class="n">IW_EV_LCP_LEN</span><span class="p">;</span>
		<span class="n">event_len</span> <span class="o">+=</span> <span class="n">IW_EV_COMPAT_LCP_LEN</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">event_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Wrapper to add an Wireless Event to a stream of events.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">iwe_stream_add_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_request_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ends</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">iw_event</span> <span class="o">*</span><span class="n">iwe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lcp_len</span> <span class="o">=</span> <span class="n">iwe_stream_lcp_len</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="n">event_len</span> <span class="o">=</span> <span class="n">iwe_stream_event_len_adjust</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">event_len</span><span class="p">);</span>

	<span class="cm">/* Check if it&#39;s possible */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">stream</span> <span class="o">+</span> <span class="n">event_len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ends</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iwe</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">event_len</span><span class="p">;</span>
		<span class="cm">/* Beware of alignement issues on 64 bits */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">iwe</span><span class="p">,</span> <span class="n">IW_EV_LCP_PK_LEN</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">stream</span> <span class="o">+</span> <span class="n">lcp_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iwe</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">,</span>
		       <span class="n">event_len</span> <span class="o">-</span> <span class="n">lcp_len</span><span class="p">);</span>
		<span class="n">stream</span> <span class="o">+=</span> <span class="n">event_len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">stream</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Wrapper to add an short Wireless Event containing a pointer to a</span>
<span class="cm"> * stream of events.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">iwe_stream_add_point</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_request_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ends</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">iw_event</span> <span class="o">*</span><span class="n">iwe</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">extra</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">event_len</span> <span class="o">=</span> <span class="n">iwe_stream_point_len</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">+</span> <span class="n">iwe</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">point_len</span> <span class="o">=</span> <span class="n">iwe_stream_point_len</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">lcp_len</span>   <span class="o">=</span> <span class="n">iwe_stream_lcp_len</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/* Check if it&#39;s possible */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">stream</span> <span class="o">+</span> <span class="n">event_len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ends</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iwe</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">event_len</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">iwe</span><span class="p">,</span> <span class="n">IW_EV_LCP_PK_LEN</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">stream</span> <span class="o">+</span> <span class="n">lcp_len</span><span class="p">,</span>
		       <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">iwe</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="n">IW_EV_POINT_OFF</span><span class="p">,</span>
		       <span class="n">IW_EV_POINT_PK_LEN</span> <span class="o">-</span> <span class="n">IW_EV_LCP_PK_LEN</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">stream</span> <span class="o">+</span> <span class="n">point_len</span><span class="p">,</span> <span class="n">extra</span><span class="p">,</span> <span class="n">iwe</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
		<span class="n">stream</span> <span class="o">+=</span> <span class="n">event_len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">stream</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Wrapper to add a value to a Wireless Event in a stream of events.</span>
<span class="cm"> * Be careful, this one is tricky to use properly :</span>
<span class="cm"> * At the first run, you need to have (value = event + IW_EV_LCP_LEN).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">iwe_stream_add_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_request_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
		     <span class="kt">char</span> <span class="o">*</span><span class="n">ends</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iw_event</span> <span class="o">*</span><span class="n">iwe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lcp_len</span> <span class="o">=</span> <span class="n">iwe_stream_lcp_len</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t duplicate LCP */</span>
	<span class="n">event_len</span> <span class="o">-=</span> <span class="n">IW_EV_LCP_LEN</span><span class="p">;</span>

	<span class="cm">/* Check if it&#39;s possible */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">value</span> <span class="o">+</span> <span class="n">event_len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ends</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Add new value */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iwe</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">,</span> <span class="n">event_len</span><span class="p">);</span>
		<span class="n">value</span> <span class="o">+=</span> <span class="n">event_len</span><span class="p">;</span>
		<span class="cm">/* Patch LCP */</span>
		<span class="n">iwe</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">value</span> <span class="o">-</span> <span class="n">event</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">iwe</span><span class="p">,</span> <span class="n">lcp_len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* _IW_HANDLER_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
