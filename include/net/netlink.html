<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › netlink.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>netlink.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __NET_NETLINK_H</span>
<span class="cp">#define __NET_NETLINK_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/netlink.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>

<span class="cm">/* ========================================================================</span>
<span class="cm"> *         Netlink Messages and Attributes Interface (As Seen On TV)</span>
<span class="cm"> * ------------------------------------------------------------------------</span>
<span class="cm"> *                          Messages Interface</span>
<span class="cm"> * ------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * Message Format:</span>
<span class="cm"> *    &lt;--- nlmsg_total_size(payload)  ---&gt;</span>
<span class="cm"> *    &lt;-- nlmsg_msg_size(payload) -&gt;</span>
<span class="cm"> *   +----------+- - -+-------------+- - -+-------- - -</span>
<span class="cm"> *   | nlmsghdr | Pad |   Payload   | Pad | nlmsghdr</span>
<span class="cm"> *   +----------+- - -+-------------+- - -+-------- - -</span>
<span class="cm"> *   nlmsg_data(nlh)---^                   ^</span>
<span class="cm"> *   nlmsg_next(nlh)-----------------------+</span>
<span class="cm"> *</span>
<span class="cm"> * Payload Format:</span>
<span class="cm"> *    &lt;---------------------- nlmsg_len(nlh) ---------------------&gt;</span>
<span class="cm"> *    &lt;------ hdrlen ------&gt;       &lt;- nlmsg_attrlen(nlh, hdrlen) -&gt;</span>
<span class="cm"> *   +----------------------+- - -+--------------------------------+</span>
<span class="cm"> *   |     Family Header    | Pad |           Attributes           |</span>
<span class="cm"> *   +----------------------+- - -+--------------------------------+</span>
<span class="cm"> *   nlmsg_attrdata(nlh, hdrlen)---^</span>
<span class="cm"> *</span>
<span class="cm"> * Data Structures:</span>
<span class="cm"> *   struct nlmsghdr			netlink message header</span>
<span class="cm"> *</span>
<span class="cm"> * Message Construction:</span>
<span class="cm"> *   nlmsg_new()			create a new netlink message</span>
<span class="cm"> *   nlmsg_put()			add a netlink message to an skb</span>
<span class="cm"> *   nlmsg_put_answer()			callback based nlmsg_put()</span>
<span class="cm"> *   nlmsg_end()			finalize netlink message</span>
<span class="cm"> *   nlmsg_get_pos()			return current position in message</span>
<span class="cm"> *   nlmsg_trim()			trim part of message</span>
<span class="cm"> *   nlmsg_cancel()			cancel message construction</span>
<span class="cm"> *   nlmsg_free()			free a netlink message</span>
<span class="cm"> *</span>
<span class="cm"> * Message Sending:</span>
<span class="cm"> *   nlmsg_multicast()			multicast message to several groups</span>
<span class="cm"> *   nlmsg_unicast()			unicast a message to a single socket</span>
<span class="cm"> *   nlmsg_notify()			send notification message</span>
<span class="cm"> *</span>
<span class="cm"> * Message Length Calculations:</span>
<span class="cm"> *   nlmsg_msg_size(payload)		length of message w/o padding</span>
<span class="cm"> *   nlmsg_total_size(payload)		length of message w/ padding</span>
<span class="cm"> *   nlmsg_padlen(payload)		length of padding at tail</span>
<span class="cm"> *</span>
<span class="cm"> * Message Payload Access:</span>
<span class="cm"> *   nlmsg_data(nlh)			head of message payload</span>
<span class="cm"> *   nlmsg_len(nlh)			length of message payload</span>
<span class="cm"> *   nlmsg_attrdata(nlh, hdrlen)	head of attributes data</span>
<span class="cm"> *   nlmsg_attrlen(nlh, hdrlen)		length of attributes data</span>
<span class="cm"> *</span>
<span class="cm"> * Message Parsing:</span>
<span class="cm"> *   nlmsg_ok(nlh, remaining)		does nlh fit into remaining bytes?</span>
<span class="cm"> *   nlmsg_next(nlh, remaining)		get next netlink message</span>
<span class="cm"> *   nlmsg_parse()			parse attributes of a message</span>
<span class="cm"> *   nlmsg_find_attr()			find an attribute in a message</span>
<span class="cm"> *   nlmsg_for_each_msg()		loop over all messages</span>
<span class="cm"> *   nlmsg_validate()			validate netlink message incl. attrs</span>
<span class="cm"> *   nlmsg_for_each_attr()		loop over all attributes</span>
<span class="cm"> *</span>
<span class="cm"> * Misc:</span>
<span class="cm"> *   nlmsg_report()			report back to application?</span>
<span class="cm"> *</span>
<span class="cm"> * ------------------------------------------------------------------------</span>
<span class="cm"> *                          Attributes Interface</span>
<span class="cm"> * ------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * Attribute Format:</span>
<span class="cm"> *    &lt;------- nla_total_size(payload) -------&gt;</span>
<span class="cm"> *    &lt;---- nla_attr_size(payload) -----&gt;</span>
<span class="cm"> *   +----------+- - -+- - - - - - - - - +- - -+-------- - -</span>
<span class="cm"> *   |  Header  | Pad |     Payload      | Pad |  Header</span>
<span class="cm"> *   +----------+- - -+- - - - - - - - - +- - -+-------- - -</span>
<span class="cm"> *                     &lt;- nla_len(nla) -&gt;      ^</span>
<span class="cm"> *   nla_data(nla)----^                        |</span>
<span class="cm"> *   nla_next(nla)-----------------------------&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * Data Structures:</span>
<span class="cm"> *   struct nlattr			netlink attribute header</span>
<span class="cm"> *</span>
<span class="cm"> * Attribute Construction:</span>
<span class="cm"> *   nla_reserve(skb, type, len)	reserve room for an attribute</span>
<span class="cm"> *   nla_reserve_nohdr(skb, len)	reserve room for an attribute w/o hdr</span>
<span class="cm"> *   nla_put(skb, type, len, data)	add attribute to skb</span>
<span class="cm"> *   nla_put_nohdr(skb, len, data)	add attribute w/o hdr</span>
<span class="cm"> *   nla_append(skb, len, data)		append data to skb</span>
<span class="cm"> *</span>
<span class="cm"> * Attribute Construction for Basic Types:</span>
<span class="cm"> *   nla_put_u8(skb, type, value)	add u8 attribute to skb</span>
<span class="cm"> *   nla_put_u16(skb, type, value)	add u16 attribute to skb</span>
<span class="cm"> *   nla_put_u32(skb, type, value)	add u32 attribute to skb</span>
<span class="cm"> *   nla_put_u64(skb, type, value)	add u64 attribute to skb</span>
<span class="cm"> *   nla_put_string(skb, type, str)	add string attribute to skb</span>
<span class="cm"> *   nla_put_flag(skb, type)		add flag attribute to skb</span>
<span class="cm"> *   nla_put_msecs(skb, type, jiffies)	add msecs attribute to skb</span>
<span class="cm"> *</span>
<span class="cm"> * Nested Attributes Construction:</span>
<span class="cm"> *   nla_nest_start(skb, type)		start a nested attribute</span>
<span class="cm"> *   nla_nest_end(skb, nla)		finalize a nested attribute</span>
<span class="cm"> *   nla_nest_cancel(skb, nla)		cancel nested attribute construction</span>
<span class="cm"> *</span>
<span class="cm"> * Attribute Length Calculations:</span>
<span class="cm"> *   nla_attr_size(payload)		length of attribute w/o padding</span>
<span class="cm"> *   nla_total_size(payload)		length of attribute w/ padding</span>
<span class="cm"> *   nla_padlen(payload)		length of padding</span>
<span class="cm"> *</span>
<span class="cm"> * Attribute Payload Access:</span>
<span class="cm"> *   nla_data(nla)			head of attribute payload</span>
<span class="cm"> *   nla_len(nla)			length of attribute payload</span>
<span class="cm"> *</span>
<span class="cm"> * Attribute Payload Access for Basic Types:</span>
<span class="cm"> *   nla_get_u8(nla)			get payload for a u8 attribute</span>
<span class="cm"> *   nla_get_u16(nla)			get payload for a u16 attribute</span>
<span class="cm"> *   nla_get_u32(nla)			get payload for a u32 attribute</span>
<span class="cm"> *   nla_get_u64(nla)			get payload for a u64 attribute</span>
<span class="cm"> *   nla_get_flag(nla)			return 1 if flag is true</span>
<span class="cm"> *   nla_get_msecs(nla)			get payload for a msecs attribute</span>
<span class="cm"> *</span>
<span class="cm"> * Attribute Misc:</span>
<span class="cm"> *   nla_memcpy(dest, nla, count)	copy attribute into memory</span>
<span class="cm"> *   nla_memcmp(nla, data, size)	compare attribute with memory area</span>
<span class="cm"> *   nla_strlcpy(dst, nla, size)	copy attribute to a sized string</span>
<span class="cm"> *   nla_strcmp(nla, str)		compare attribute with string</span>
<span class="cm"> *</span>
<span class="cm"> * Attribute Parsing:</span>
<span class="cm"> *   nla_ok(nla, remaining)		does nla fit into remaining bytes?</span>
<span class="cm"> *   nla_next(nla, remaining)		get next netlink attribute</span>
<span class="cm"> *   nla_validate()			validate a stream of attributes</span>
<span class="cm"> *   nla_validate_nested()		validate a stream of nested attributes</span>
<span class="cm"> *   nla_find()				find attribute in stream of attributes</span>
<span class="cm"> *   nla_find_nested()			find attribute in nested attributes</span>
<span class="cm"> *   nla_parse()			parse and validate stream of attrs</span>
<span class="cm"> *   nla_parse_nested()			parse nested attribuets</span>
<span class="cm"> *   nla_for_each_attr()		loop over all attributes</span>
<span class="cm"> *   nla_for_each_nested()		loop over the nested attributes</span>
<span class="cm"> *=========================================================================</span>
<span class="cm"> */</span>

 <span class="cm">/**</span>
<span class="cm">  * Standard attribute types to specify validation policy</span>
<span class="cm">  */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">NLA_UNSPEC</span><span class="p">,</span>
	<span class="n">NLA_U8</span><span class="p">,</span>
	<span class="n">NLA_U16</span><span class="p">,</span>
	<span class="n">NLA_U32</span><span class="p">,</span>
	<span class="n">NLA_U64</span><span class="p">,</span>
	<span class="n">NLA_STRING</span><span class="p">,</span>
	<span class="n">NLA_FLAG</span><span class="p">,</span>
	<span class="n">NLA_MSECS</span><span class="p">,</span>
	<span class="n">NLA_NESTED</span><span class="p">,</span>
	<span class="n">NLA_NESTED_COMPAT</span><span class="p">,</span>
	<span class="n">NLA_NUL_STRING</span><span class="p">,</span>
	<span class="n">NLA_BINARY</span><span class="p">,</span>
	<span class="n">__NLA_TYPE_MAX</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define NLA_TYPE_MAX (__NLA_TYPE_MAX - 1)</span>

<span class="cm">/**</span>
<span class="cm"> * struct nla_policy - attribute validation policy</span>
<span class="cm"> * @type: Type of attribute or NLA_UNSPEC</span>
<span class="cm"> * @len: Type specific length of payload</span>
<span class="cm"> *</span>
<span class="cm"> * Policies are defined as arrays of this struct, the array must be</span>
<span class="cm"> * accessible by attribute type up to the highest identifier to be expected.</span>
<span class="cm"> *</span>
<span class="cm"> * Meaning of `len&#39; field:</span>
<span class="cm"> *    NLA_STRING           Maximum length of string</span>
<span class="cm"> *    NLA_NUL_STRING       Maximum length of string (excluding NUL)</span>
<span class="cm"> *    NLA_FLAG             Unused</span>
<span class="cm"> *    NLA_BINARY           Maximum length of attribute payload</span>
<span class="cm"> *    NLA_NESTED           Don&#39;t use `len&#39; field -- length verification is</span>
<span class="cm"> *                         done by checking len of nested header (or empty)</span>
<span class="cm"> *    NLA_NESTED_COMPAT    Minimum length of structure payload</span>
<span class="cm"> *    NLA_U8, NLA_U16,</span>
<span class="cm"> *    NLA_U32, NLA_U64,</span>
<span class="cm"> *    NLA_MSECS            Leaving the length field zero will verify the</span>
<span class="cm"> *                         given type fits, using it verifies minimum length</span>
<span class="cm"> *                         just like &quot;All other&quot;</span>
<span class="cm"> *    All other            Minimum length of attribute payload</span>
<span class="cm"> *</span>
<span class="cm"> * Example:</span>
<span class="cm"> * static const struct nla_policy my_policy[ATTR_MAX+1] = {</span>
<span class="cm"> * 	[ATTR_FOO] = { .type = NLA_U16 },</span>
<span class="cm"> *	[ATTR_BAR] = { .type = NLA_STRING, .len = BARSIZ },</span>
<span class="cm"> *	[ATTR_BAZ] = { .len = sizeof(struct mystruct) },</span>
<span class="cm"> * };</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nla_policy</span> <span class="p">{</span>
	<span class="n">u16</span>		<span class="n">type</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nl_info - netlink source information</span>
<span class="cm"> * @nlh: Netlink message header of original request</span>
<span class="cm"> * @pid: Netlink PID of requesting application</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nl_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">nlmsghdr</span>		<span class="o">*</span><span class="n">nlh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span>		<span class="o">*</span><span class="n">nl_net</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">pid</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span>		<span class="n">netlink_rcv_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="p">));</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">nlmsg_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group</span><span class="p">,</span> <span class="kt">int</span> <span class="n">report</span><span class="p">,</span>
				     <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span>		<span class="n">nla_validate</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxtype</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">nla_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">nla_parse</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlattr</span> <span class="o">**</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxtype</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">nla_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">nla_policy_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nla_policy</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span>	<span class="n">nla_find</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">size_t</span>		<span class="n">nla_strlcpy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="n">dstsize</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">nla_memcpy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">nla_memcmp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">nla_strcmp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span>	<span class="n">__nla_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">attrlen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span>		<span class="n">__nla_reserve_nohdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrlen</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span>	<span class="n">nla_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">attrlen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span>		<span class="n">nla_reserve_nohdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrlen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">__nla_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">attrlen</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">__nla_put_nohdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrlen</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">nla_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">attrlen</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">nla_put_nohdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrlen</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">nla_append</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrlen</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> * Netlink Messages</span>
<span class="cm"> **************************************************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_msg_size - length of netlink message not including padding</span>
<span class="cm"> * @payload: length of message payload</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nlmsg_msg_size</span><span class="p">(</span><span class="kt">int</span> <span class="n">payload</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">NLMSG_HDRLEN</span> <span class="o">+</span> <span class="n">payload</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_total_size - length of netlink message including padding</span>
<span class="cm"> * @payload: length of message payload</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nlmsg_total_size</span><span class="p">(</span><span class="kt">int</span> <span class="n">payload</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">NLMSG_ALIGN</span><span class="p">(</span><span class="n">nlmsg_msg_size</span><span class="p">(</span><span class="n">payload</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_padlen - length of padding at the message&#39;s tail</span>
<span class="cm"> * @payload: length of message payload</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nlmsg_padlen</span><span class="p">(</span><span class="kt">int</span> <span class="n">payload</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nlmsg_total_size</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">-</span> <span class="n">nlmsg_msg_size</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_data - head of message payload</span>
<span class="cm"> * @nlh: netlink message header</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">nlmsg_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">nlh</span> <span class="o">+</span> <span class="n">NLMSG_HDRLEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_len - length of message payload</span>
<span class="cm"> * @nlh: netlink message header</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nlmsg_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span> <span class="o">-</span> <span class="n">NLMSG_HDRLEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_attrdata - head of attributes data</span>
<span class="cm"> * @nlh: netlink message header</span>
<span class="cm"> * @hdrlen: length of family specific header</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="nf">nlmsg_attrdata</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">hdrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">nlmsg_data</span><span class="p">(</span><span class="n">nlh</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="n">NLMSG_ALIGN</span><span class="p">(</span><span class="n">hdrlen</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_attrlen - length of attributes data</span>
<span class="cm"> * @nlh: netlink message header</span>
<span class="cm"> * @hdrlen: length of family specific header</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nlmsg_attrlen</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hdrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nlmsg_len</span><span class="p">(</span><span class="n">nlh</span><span class="p">)</span> <span class="o">-</span> <span class="n">NLMSG_ALIGN</span><span class="p">(</span><span class="n">hdrlen</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_ok - check if the netlink message fits into the remaining bytes</span>
<span class="cm"> * @nlh: netlink message header</span>
<span class="cm"> * @remaining: number of bytes remaining in message stream</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nlmsg_ok</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">remaining</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlmsghdr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlmsghdr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span> <span class="o">&lt;=</span> <span class="n">remaining</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_next - next netlink message in message stream</span>
<span class="cm"> * @nlh: netlink message header</span>
<span class="cm"> * @remaining: number of bytes remaining in message stream</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the next netlink message in the message stream and</span>
<span class="cm"> * decrements remaining by the size of the current message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span>
<span class="nf">nlmsg_next</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">remaining</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">totlen</span> <span class="o">=</span> <span class="n">NLMSG_ALIGN</span><span class="p">(</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span><span class="p">);</span>

	<span class="o">*</span><span class="n">remaining</span> <span class="o">-=</span> <span class="n">totlen</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">nlh</span> <span class="o">+</span> <span class="n">totlen</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_parse - parse attributes of a netlink message</span>
<span class="cm"> * @nlh: netlink message header</span>
<span class="cm"> * @hdrlen: length of family specific header</span>
<span class="cm"> * @tb: destination array with maxtype+1 elements</span>
<span class="cm"> * @maxtype: maximum attribute type to be expected</span>
<span class="cm"> * @policy: validation policy</span>
<span class="cm"> *</span>
<span class="cm"> * See nla_parse()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nlmsg_parse</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hdrlen</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">maxtype</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">nla_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span> <span class="o">&lt;</span> <span class="n">nlmsg_msg_size</span><span class="p">(</span><span class="n">hdrlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nla_parse</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">maxtype</span><span class="p">,</span> <span class="n">nlmsg_attrdata</span><span class="p">(</span><span class="n">nlh</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">),</span>
			 <span class="n">nlmsg_attrlen</span><span class="p">(</span><span class="n">nlh</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">),</span> <span class="n">policy</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_find_attr - find a specific attribute in a netlink message</span>
<span class="cm"> * @nlh: netlink message header</span>
<span class="cm"> * @hdrlen: length of familiy specific header</span>
<span class="cm"> * @attrtype: type of attribute to look for</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the first attribute which matches the specified type.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="nf">nlmsg_find_attr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">hdrlen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_find</span><span class="p">(</span><span class="n">nlmsg_attrdata</span><span class="p">(</span><span class="n">nlh</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">),</span>
			<span class="n">nlmsg_attrlen</span><span class="p">(</span><span class="n">nlh</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">),</span> <span class="n">attrtype</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_validate - validate a netlink message including attributes</span>
<span class="cm"> * @nlh: netlinket message header</span>
<span class="cm"> * @hdrlen: length of familiy specific header</span>
<span class="cm"> * @maxtype: maximum attribute type to be expected</span>
<span class="cm"> * @policy: validation policy</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nlmsg_validate</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">hdrlen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxtype</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">nla_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span> <span class="o">&lt;</span> <span class="n">nlmsg_msg_size</span><span class="p">(</span><span class="n">hdrlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nla_validate</span><span class="p">(</span><span class="n">nlmsg_attrdata</span><span class="p">(</span><span class="n">nlh</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">),</span>
			    <span class="n">nlmsg_attrlen</span><span class="p">(</span><span class="n">nlh</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">),</span> <span class="n">maxtype</span><span class="p">,</span> <span class="n">policy</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_report - need to report back to application?</span>
<span class="cm"> * @nlh: netlink message header</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if a report back to the application is requested.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nlmsg_report</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_flags</span> <span class="o">&amp;</span> <span class="n">NLM_F_ECHO</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_for_each_attr - iterate over a stream of attributes</span>
<span class="cm"> * @pos: loop counter, set to current attribute</span>
<span class="cm"> * @nlh: netlink message header</span>
<span class="cm"> * @hdrlen: length of familiy specific header</span>
<span class="cm"> * @rem: initialized to len, holds bytes currently remaining in stream</span>
<span class="cm"> */</span>
<span class="cp">#define nlmsg_for_each_attr(pos, nlh, hdrlen, rem) \</span>
<span class="cp">	nla_for_each_attr(pos, nlmsg_attrdata(nlh, hdrlen), \</span>
<span class="cp">			  nlmsg_attrlen(nlh, hdrlen), rem)</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_put - Add a new netlink message to an skb</span>
<span class="cm"> * @skb: socket buffer to store message in</span>
<span class="cm"> * @pid: netlink process id</span>
<span class="cm"> * @seq: sequence number of message</span>
<span class="cm"> * @type: message type</span>
<span class="cm"> * @payload: length of message payload</span>
<span class="cm"> * @flags: message flags</span>
<span class="cm"> *</span>
<span class="cm"> * Returns NULL if the tailroom of the skb is insufficient to store</span>
<span class="cm"> * the message header and payload.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="nf">nlmsg_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">payload</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nlmsg_total_size</span><span class="p">(</span><span class="n">payload</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__nlmsg_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_put_answer - Add a new callback based netlink message to an skb</span>
<span class="cm"> * @skb: socket buffer to store message in</span>
<span class="cm"> * @cb: netlink callback</span>
<span class="cm"> * @type: message type</span>
<span class="cm"> * @payload: length of message payload</span>
<span class="cm"> * @flags: message flags</span>
<span class="cm"> *</span>
<span class="cm"> * Returns NULL if the tailroom of the skb is insufficient to store</span>
<span class="cm"> * the message header and payload.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="nf">nlmsg_put_answer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">payload</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nlmsg_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">NETLINK_CB</span><span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span><span class="p">,</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_seq</span><span class="p">,</span>
			 <span class="n">type</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_new - Allocate a new netlink message</span>
<span class="cm"> * @payload: size of the message payload</span>
<span class="cm"> * @flags: the type of memory to allocate.</span>
<span class="cm"> *</span>
<span class="cm"> * Use NLMSG_DEFAULT_SIZE if the size of the payload isn&#39;t known</span>
<span class="cm"> * and a good default is needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">nlmsg_new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">payload</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">nlmsg_total_size</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_end - Finalize a netlink message</span>
<span class="cm"> * @skb: socket buffer the message is stored in</span>
<span class="cm"> * @nlh: netlink message header</span>
<span class="cm"> *</span>
<span class="cm"> * Corrects the netlink message header to include the appeneded</span>
<span class="cm"> * attributes. Only necessary if attributes have been added to</span>
<span class="cm"> * the message.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the total data length of the skb.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nlmsg_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span> <span class="o">=</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">nlh</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_get_pos - return current position in netlink message</span>
<span class="cm"> * @skb: socket buffer the message is stored in</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the current tail of the message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">nlmsg_get_pos</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_trim - Trim message to a mark</span>
<span class="cm"> * @skb: socket buffer the message is stored in</span>
<span class="cm"> * @mark: mark to trim to</span>
<span class="cm"> *</span>
<span class="cm"> * Trims the message to the provided mark.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nlmsg_trim</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mark</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mark</span><span class="p">)</span>
		<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">mark</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_cancel - Cancel construction of a netlink message</span>
<span class="cm"> * @skb: socket buffer the message is stored in</span>
<span class="cm"> * @nlh: netlink message header</span>
<span class="cm"> *</span>
<span class="cm"> * Removes the complete netlink message including all</span>
<span class="cm"> * attributes from the socket buffer again.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nlmsg_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nlmsg_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nlh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_free - free a netlink message</span>
<span class="cm"> * @skb: socket buffer of netlink message</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nlmsg_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_multicast - multicast a netlink message</span>
<span class="cm"> * @sk: netlink socket to spread messages to</span>
<span class="cm"> * @skb: netlink message as socket buffer</span>
<span class="cm"> * @pid: own netlink pid to avoid sending to yourself</span>
<span class="cm"> * @group: multicast group id</span>
<span class="cm"> * @flags: allocation flags</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nlmsg_multicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">NETLINK_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">dst_group</span> <span class="o">=</span> <span class="n">group</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">netlink_broadcast</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_unicast - unicast a netlink message</span>
<span class="cm"> * @sk: netlink socket to spread message to</span>
<span class="cm"> * @skb: netlink message as socket buffer</span>
<span class="cm"> * @pid: netlink pid of the destination socket</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nlmsg_unicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">netlink_unicast</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">MSG_DONTWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsg_for_each_msg - iterate over a stream of messages</span>
<span class="cm"> * @pos: loop counter, set to current message</span>
<span class="cm"> * @head: head of message stream</span>
<span class="cm"> * @len: length of message stream</span>
<span class="cm"> * @rem: initialized to len, holds bytes currently remaining in stream</span>
<span class="cm"> */</span>
<span class="cp">#define nlmsg_for_each_msg(pos, head, len, rem) \</span>
<span class="cp">	for (pos = head, rem = len; \</span>
<span class="cp">	     nlmsg_ok(pos, rem); \</span>
<span class="cp">	     pos = nlmsg_next(pos, &amp;(rem)))</span>

<span class="cm">/**</span>
<span class="cm"> * nl_dump_check_consistent - check if sequence is consistent and advertise if not</span>
<span class="cm"> * @cb: netlink callback structure that stores the sequence number</span>
<span class="cm"> * @nlh: netlink message header to write the flag to</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks if the sequence (generation) number changed during dump</span>
<span class="cm"> * and if it did, advertises it in the netlink message header.</span>
<span class="cm"> *</span>
<span class="cm"> * The correct way to use it is to set cb-&gt;seq to the generation counter when</span>
<span class="cm"> * all locks for dumping have been acquired, and then call this function for</span>
<span class="cm"> * each message that is generated.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that due to initialisation concerns, 0 is an invalid sequence number</span>
<span class="cm"> * and must not be used by code that uses this functionality.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">nl_dump_check_consistent</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">prev_seq</span> <span class="o">&amp;&amp;</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">!=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">prev_seq</span><span class="p">)</span>
		<span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_flags</span> <span class="o">|=</span> <span class="n">NLM_F_DUMP_INTR</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">prev_seq</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> * Netlink Attributes</span>
<span class="cm"> **************************************************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * nla_attr_size - length of attribute not including padding</span>
<span class="cm"> * @payload: length of payload</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_attr_size</span><span class="p">(</span><span class="kt">int</span> <span class="n">payload</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">NLA_HDRLEN</span> <span class="o">+</span> <span class="n">payload</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_total_size - total length of attribute including padding</span>
<span class="cm"> * @payload: length of payload</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_total_size</span><span class="p">(</span><span class="kt">int</span> <span class="n">payload</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">NLA_ALIGN</span><span class="p">(</span><span class="n">nla_attr_size</span><span class="p">(</span><span class="n">payload</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_padlen - length of padding at the tail of attribute</span>
<span class="cm"> * @payload: length of payload</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_padlen</span><span class="p">(</span><span class="kt">int</span> <span class="n">payload</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_total_size</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">-</span> <span class="n">nla_attr_size</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_type - attribute type</span>
<span class="cm"> * @nla: netlink attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_type</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla</span><span class="o">-&gt;</span><span class="n">nla_type</span> <span class="o">&amp;</span> <span class="n">NLA_TYPE_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_data - head of payload</span>
<span class="cm"> * @nla: netlink attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">nla_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">nla</span> <span class="o">+</span> <span class="n">NLA_HDRLEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_len - length of payload</span>
<span class="cm"> * @nla: netlink attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla</span><span class="o">-&gt;</span><span class="n">nla_len</span> <span class="o">-</span> <span class="n">NLA_HDRLEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_ok - check if the netlink attribute fits into the remaining bytes</span>
<span class="cm"> * @nla: netlink attribute</span>
<span class="cm"> * @remaining: number of bytes remaining in attribute stream</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_ok</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">,</span> <span class="kt">int</span> <span class="n">remaining</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">remaining</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nla</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">nla</span><span class="o">-&gt;</span><span class="n">nla_len</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nla</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">nla</span><span class="o">-&gt;</span><span class="n">nla_len</span> <span class="o">&lt;=</span> <span class="n">remaining</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_next - next netlink attribute in attribute stream</span>
<span class="cm"> * @nla: netlink attribute</span>
<span class="cm"> * @remaining: number of bytes remaining in attribute stream</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the next netlink attribute in the attribute stream and</span>
<span class="cm"> * decrements remaining by the size of the current attribute.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="nf">nla_next</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">remaining</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">totlen</span> <span class="o">=</span> <span class="n">NLA_ALIGN</span><span class="p">(</span><span class="n">nla</span><span class="o">-&gt;</span><span class="n">nla_len</span><span class="p">);</span>

	<span class="o">*</span><span class="n">remaining</span> <span class="o">-=</span> <span class="n">totlen</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">nla</span> <span class="o">+</span> <span class="n">totlen</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_find_nested - find attribute in a set of nested attributes</span>
<span class="cm"> * @nla: attribute containing the nested attributes</span>
<span class="cm"> * @attrtype: type of attribute to look for</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the first attribute which matches the specified type.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span>
<span class="nf">nla_find_nested</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_find</span><span class="p">(</span><span class="n">nla_data</span><span class="p">(</span><span class="n">nla</span><span class="p">),</span> <span class="n">nla_len</span><span class="p">(</span><span class="n">nla</span><span class="p">),</span> <span class="n">attrtype</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_parse_nested - parse nested attributes</span>
<span class="cm"> * @tb: destination array with maxtype+1 elements</span>
<span class="cm"> * @maxtype: maximum attribute type to be expected</span>
<span class="cm"> * @nla: attribute containing the nested attributes</span>
<span class="cm"> * @policy: validation policy</span>
<span class="cm"> *</span>
<span class="cm"> * See nla_parse()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_parse_nested</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">maxtype</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">nla_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_parse</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">maxtype</span><span class="p">,</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">nla</span><span class="p">),</span> <span class="n">nla_len</span><span class="p">(</span><span class="n">nla</span><span class="p">),</span> <span class="n">policy</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_put_u8 - Add a u8 netlink attribute to a socket buffer</span>
<span class="cm"> * @skb: socket buffer to add attribute to</span>
<span class="cm"> * @attrtype: attribute type</span>
<span class="cm"> * @value: numeric value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_u8</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_put_u16 - Add a u16 netlink attribute to a socket buffer</span>
<span class="cm"> * @skb: socket buffer to add attribute to</span>
<span class="cm"> * @attrtype: attribute type</span>
<span class="cm"> * @value: numeric value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_u16</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_put_be16 - Add a __be16 netlink attribute to a socket buffer</span>
<span class="cm"> * @skb: socket buffer to add attribute to</span>
<span class="cm"> * @attrtype: attribute type</span>
<span class="cm"> * @value: numeric value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_be16</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be16</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_put_net16 - Add 16-bit network byte order netlink attribute to a socket buffer</span>
<span class="cm"> * @skb: socket buffer to add attribute to</span>
<span class="cm"> * @attrtype: attribute type</span>
<span class="cm"> * @value: numeric value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_net16</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_put_be16</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span> <span class="o">|</span> <span class="n">NLA_F_NET_BYTEORDER</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_put_le16 - Add a __le16 netlink attribute to a socket buffer</span>
<span class="cm"> * @skb: socket buffer to add attribute to</span>
<span class="cm"> * @attrtype: attribute type</span>
<span class="cm"> * @value: numeric value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_le16</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span> <span class="n">__le16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le16</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_put_u32 - Add a u32 netlink attribute to a socket buffer</span>
<span class="cm"> * @skb: socket buffer to add attribute to</span>
<span class="cm"> * @attrtype: attribute type</span>
<span class="cm"> * @value: numeric value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_u32</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_put_be32 - Add a __be32 netlink attribute to a socket buffer</span>
<span class="cm"> * @skb: socket buffer to add attribute to</span>
<span class="cm"> * @attrtype: attribute type</span>
<span class="cm"> * @value: numeric value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_be32</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be32</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_put_net32 - Add 32-bit network byte order netlink attribute to a socket buffer</span>
<span class="cm"> * @skb: socket buffer to add attribute to</span>
<span class="cm"> * @attrtype: attribute type</span>
<span class="cm"> * @value: numeric value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_net32</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_put_be32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span> <span class="o">|</span> <span class="n">NLA_F_NET_BYTEORDER</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_put_le32 - Add a __le32 netlink attribute to a socket buffer</span>
<span class="cm"> * @skb: socket buffer to add attribute to</span>
<span class="cm"> * @attrtype: attribute type</span>
<span class="cm"> * @value: numeric value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_le32</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span> <span class="n">__le32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le32</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_put_u64 - Add a u64 netlink attribute to a socket buffer</span>
<span class="cm"> * @skb: socket buffer to add attribute to</span>
<span class="cm"> * @attrtype: attribute type</span>
<span class="cm"> * @value: numeric value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_u64</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span> <span class="n">u64</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_put_be64 - Add a __be64 netlink attribute to a socket buffer</span>
<span class="cm"> * @skb: socket buffer to add attribute to</span>
<span class="cm"> * @attrtype: attribute type</span>
<span class="cm"> * @value: numeric value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_be64</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span> <span class="n">__be64</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be64</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_put_net64 - Add 64-bit network byte order netlink attribute to a socket buffer</span>
<span class="cm"> * @skb: socket buffer to add attribute to</span>
<span class="cm"> * @attrtype: attribute type</span>
<span class="cm"> * @value: numeric value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_net64</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span> <span class="n">__be64</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_put_be64</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span> <span class="o">|</span> <span class="n">NLA_F_NET_BYTEORDER</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_put_le64 - Add a __le64 netlink attribute to a socket buffer</span>
<span class="cm"> * @skb: socket buffer to add attribute to</span>
<span class="cm"> * @attrtype: attribute type</span>
<span class="cm"> * @value: numeric value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_le64</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span> <span class="n">__le64</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le64</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_put_string - Add a string netlink attribute to a socket buffer</span>
<span class="cm"> * @skb: socket buffer to add attribute to</span>
<span class="cm"> * @attrtype: attribute type</span>
<span class="cm"> * @str: NUL terminated string</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_put_flag - Add a flag netlink attribute to a socket buffer</span>
<span class="cm"> * @skb: socket buffer to add attribute to</span>
<span class="cm"> * @attrtype: attribute type</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_put_msecs - Add a msecs netlink attribute to a socket buffer</span>
<span class="cm"> * @skb: socket buffer to add attribute to</span>
<span class="cm"> * @attrtype: attribute type</span>
<span class="cm"> * @jiffies: number of msecs in jiffies</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_msecs</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffies</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_get_u32 - return payload of u32 attribute</span>
<span class="cm"> * @nla: u32 netlink attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">nla_get_u32</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">nla</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_get_be32 - return payload of __be32 attribute</span>
<span class="cm"> * @nla: __be32 netlink attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__be32</span> <span class="nf">nla_get_be32</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">nla</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_get_u16 - return payload of u16 attribute</span>
<span class="cm"> * @nla: u16 netlink attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">nla_get_u16</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">nla</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_get_be16 - return payload of __be16 attribute</span>
<span class="cm"> * @nla: __be16 netlink attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__be16</span> <span class="nf">nla_get_be16</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">nla</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_get_le16 - return payload of __le16 attribute</span>
<span class="cm"> * @nla: __le16 netlink attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__le16</span> <span class="nf">nla_get_le16</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">nla</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_get_u8 - return payload of u8 attribute</span>
<span class="cm"> * @nla: u8 netlink attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">nla_get_u8</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">nla</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_get_u64 - return payload of u64 attribute</span>
<span class="cm"> * @nla: u64 netlink attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">nla_get_u64</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">nla_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">nla</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_get_be64 - return payload of __be64 attribute</span>
<span class="cm"> * @nla: __be64 netlink attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__be64</span> <span class="nf">nla_get_be64</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be64</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">nla_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">nla</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_get_flag - return payload of flag attribute</span>
<span class="cm"> * @nla: flag netlink attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_get_flag</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!!</span><span class="n">nla</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_get_msecs - return payload of msecs attribute</span>
<span class="cm"> * @nla: msecs netlink attribute</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of milliseconds in jiffies.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">nla_get_msecs</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">msecs</span> <span class="o">=</span> <span class="n">nla_get_u64</span><span class="p">(</span><span class="n">nla</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">msecs_to_jiffies</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">msecs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_nest_start - Start a new level of nested attributes</span>
<span class="cm"> * @skb: socket buffer to add attributes to</span>
<span class="cm"> * @attrtype: attribute type of container</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the container attribute</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="nf">nla_nest_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">attrtype</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_nest_end - Finalize nesting of attributes</span>
<span class="cm"> * @skb: socket buffer the attributes are stored in</span>
<span class="cm"> * @start: container attribute</span>
<span class="cm"> *</span>
<span class="cm"> * Corrects the container attribute header to include the all</span>
<span class="cm"> * appeneded attributes.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the total data length of the skb.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_nest_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">start</span><span class="o">-&gt;</span><span class="n">nla_len</span> <span class="o">=</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">start</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_nest_cancel - Cancel nesting of attributes</span>
<span class="cm"> * @skb: socket buffer the message is stored in</span>
<span class="cm"> * @start: container attribute</span>
<span class="cm"> *</span>
<span class="cm"> * Removes the container attribute and including all nested</span>
<span class="cm"> * attributes. Returns -EMSGSIZE</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nla_nest_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nlmsg_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_validate_nested - Validate a stream of nested attributes</span>
<span class="cm"> * @start: container attribute</span>
<span class="cm"> * @maxtype: maximum attribute type to be expected</span>
<span class="cm"> * @policy: validation policy</span>
<span class="cm"> *</span>
<span class="cm"> * Validates all attributes in the nested attribute stream against the</span>
<span class="cm"> * specified policy. Attributes with a type exceeding maxtype will be</span>
<span class="cm"> * ignored. See documenation of struct nla_policy for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success or a negative error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_validate_nested</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxtype</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">nla_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nla_validate</span><span class="p">(</span><span class="n">nla_data</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">nla_len</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">maxtype</span><span class="p">,</span> <span class="n">policy</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nla_for_each_attr - iterate over a stream of attributes</span>
<span class="cm"> * @pos: loop counter, set to current attribute</span>
<span class="cm"> * @head: head of attribute stream</span>
<span class="cm"> * @len: length of attribute stream</span>
<span class="cm"> * @rem: initialized to len, holds bytes currently remaining in stream</span>
<span class="cm"> */</span>
<span class="cp">#define nla_for_each_attr(pos, head, len, rem) \</span>
<span class="cp">	for (pos = head, rem = len; \</span>
<span class="cp">	     nla_ok(pos, rem); \</span>
<span class="cp">	     pos = nla_next(pos, &amp;(rem)))</span>

<span class="cm">/**</span>
<span class="cm"> * nla_for_each_nested - iterate over nested attributes</span>
<span class="cm"> * @pos: loop counter, set to current attribute</span>
<span class="cm"> * @nla: attribute containing the nested attributes</span>
<span class="cm"> * @rem: initialized to len, holds bytes currently remaining in stream</span>
<span class="cm"> */</span>
<span class="cp">#define nla_for_each_nested(pos, nla, rem) \</span>
<span class="cp">	nla_for_each_attr(pos, nla_data(nla), nla_len(nla), rem)</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
