<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › sock.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sock.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * INET		An implementation of the TCP/IP protocol suite for the LINUX</span>
<span class="cm"> *		operating system.  INET is implemented using the  BSD Socket</span>
<span class="cm"> *		interface as the means of communication with the user level.</span>
<span class="cm"> *</span>
<span class="cm"> *		Definitions for the AF_INET socket handler.</span>
<span class="cm"> *</span>
<span class="cm"> * Version:	@(#)sock.h	1.0.4	05/13/93</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:	Ross Biro</span>
<span class="cm"> *		Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;</span>
<span class="cm"> *		Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;</span>
<span class="cm"> *		Florian La Roche &lt;flla@stud.uni-sb.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Fixes:</span>
<span class="cm"> *		Alan Cox	:	Volatiles in skbuff pointers. See</span>
<span class="cm"> *					skbuff comments. May be overdone,</span>
<span class="cm"> *					better to prove they can be removed</span>
<span class="cm"> *					than the reverse.</span>
<span class="cm"> *		Alan Cox	:	Added a zapped field for tcp to note</span>
<span class="cm"> *					a socket is reset and must stay shut up</span>
<span class="cm"> *		Alan Cox	:	New fields for options</span>
<span class="cm"> *	Pauline Middelink	:	identd support</span>
<span class="cm"> *		Alan Cox	:	Eliminate low level recv/recvfrom</span>
<span class="cm"> *		David S. Miller	:	New socket lookup architecture.</span>
<span class="cm"> *              Steve Whitehouse:       Default routines for sock_ops</span>
<span class="cm"> *              Arnaldo C. Melo :	removed net_pinfo, tp_pinfo and made</span>
<span class="cm"> *              			protinfo be just a void pointer, as the</span>
<span class="cm"> *              			protocol specific parts were moved to</span>
<span class="cm"> *              			respective headers and ipv4/v6, etc now</span>
<span class="cm"> *              			use private slabcaches for its socks</span>
<span class="cm"> *              Pedro Hortas	:	New flags field for socket options</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *		This program is free software; you can redistribute it and/or</span>
<span class="cm"> *		modify it under the terms of the GNU General Public License</span>
<span class="cm"> *		as published by the Free Software Foundation; either version</span>
<span class="cm"> *		2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _SOCK_H</span>
<span class="cp">#define _SOCK_H</span>

<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/list_nulls.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/lockdep.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;	</span><span class="cm">/* struct sk_buff */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/memcontrol.h&gt;</span>
<span class="cp">#include &lt;linux/res_counter.h&gt;</span>
<span class="cp">#include &lt;linux/static_key.h&gt;</span>
<span class="cp">#include &lt;linux/aio.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>

<span class="cp">#include &lt;linux/filter.h&gt;</span>
<span class="cp">#include &lt;linux/rculist_nulls.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;net/dst.h&gt;</span>
<span class="cp">#include &lt;net/checksum.h&gt;</span>

<span class="k">struct</span> <span class="n">cgroup</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cgroup_subsys</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NET</span>
<span class="kt">int</span> <span class="n">mem_cgroup_sockets_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mem_cgroup_sockets_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">mem_cgroup_sockets_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">mem_cgroup_sockets_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cm">/*</span>
<span class="cm"> * This structure really needs to be cleaned up.</span>
<span class="cm"> * Most of it is for TCP, and not used by any of</span>
<span class="cm"> * the other protocols.</span>
<span class="cm"> */</span>

<span class="cm">/* Define this to get the SOCK_DBG debugging facility. */</span>
<span class="cp">#define SOCK_DEBUGGING</span>
<span class="cp">#ifdef SOCK_DEBUGGING</span>
<span class="cp">#define SOCK_DEBUG(sk, msg...) do { if ((sk) &amp;&amp; sock_flag((sk), SOCK_DBG)) \</span>
<span class="cp">					printk(KERN_DEBUG msg); } while (0)</span>
<span class="cp">#else</span>
<span class="cm">/* Validate arguments and do nothing */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="nf">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* This is the per-socket lock.  The spinlock provides a synchronization</span>
<span class="cm"> * between user contexts and software interrupt processing, whereas the</span>
<span class="cm"> * mini-semaphore synchronizes multiple users amongst themselves.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">slock</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">owned</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">wq</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We express the mutex-alike socket_lock semantics</span>
<span class="cm">	 * to the lock validator by explicitly managing</span>
<span class="cm">	 * the slock as a lock variant (in addition to</span>
<span class="cm">	 * the slock itself):</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
	<span class="k">struct</span> <span class="n">lockdep_map</span> <span class="n">dep_map</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span> <span class="n">socket_lock_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">sock</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">proto</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">net</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *	struct sock_common - minimal network layer representation of sockets</span>
<span class="cm"> *	@skc_daddr: Foreign IPv4 addr</span>
<span class="cm"> *	@skc_rcv_saddr: Bound local IPv4 addr</span>
<span class="cm"> *	@skc_hash: hash value used with various protocol lookup tables</span>
<span class="cm"> *	@skc_u16hashes: two u16 hash values used by UDP lookup tables</span>
<span class="cm"> *	@skc_family: network address family</span>
<span class="cm"> *	@skc_state: Connection state</span>
<span class="cm"> *	@skc_reuse: %SO_REUSEADDR setting</span>
<span class="cm"> *	@skc_bound_dev_if: bound device index if != 0</span>
<span class="cm"> *	@skc_bind_node: bind hash linkage for various protocol lookup tables</span>
<span class="cm"> *	@skc_portaddr_node: second hash linkage for UDP/UDP-Lite protocol</span>
<span class="cm"> *	@skc_prot: protocol handlers inside a network family</span>
<span class="cm"> *	@skc_net: reference to the network namespace of this socket</span>
<span class="cm"> *	@skc_node: main hash linkage for various protocol lookup tables</span>
<span class="cm"> *	@skc_nulls_node: main hash linkage for TCP/UDP/UDP-Lite protocol</span>
<span class="cm"> *	@skc_tx_queue_mapping: tx queue number for this connection</span>
<span class="cm"> *	@skc_refcnt: reference count</span>
<span class="cm"> *</span>
<span class="cm"> *	This is the minimal network layer representation of sockets, the header</span>
<span class="cm"> *	for struct sock and struct inet_timewait_sock.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sock_common</span> <span class="p">{</span>
	<span class="cm">/* skc_daddr and skc_rcv_saddr must be grouped :</span>
<span class="cm">	 * cf INET_MATCH() and INET_TW_MATCH()</span>
<span class="cm">	 */</span>
	<span class="n">__be32</span>			<span class="n">skc_daddr</span><span class="p">;</span>
	<span class="n">__be32</span>			<span class="n">skc_rcv_saddr</span><span class="p">;</span>

	<span class="k">union</span>  <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">skc_hash</span><span class="p">;</span>
		<span class="n">__u16</span>		<span class="n">skc_u16hashes</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">skc_family</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">skc_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">skc_reuse</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">skc_bound_dev_if</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">skc_bind_node</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hlist_nulls_node</span> <span class="n">skc_portaddr_node</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">proto</span>		<span class="o">*</span><span class="n">skc_prot</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NET_NS</span>
	<span class="k">struct</span> <span class="n">net</span>	 	<span class="o">*</span><span class="n">skc_net</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * fields between dontcopy_begin/dontcopy_end</span>
<span class="cm">	 * are not copied in sock_copy()</span>
<span class="cm">	 */</span>
	<span class="cm">/* private: */</span>
	<span class="kt">int</span>			<span class="n">skc_dontcopy_begin</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="cm">/* public: */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">skc_node</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hlist_nulls_node</span> <span class="n">skc_nulls_node</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="kt">int</span>			<span class="n">skc_tx_queue_mapping</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">skc_refcnt</span><span class="p">;</span>
	<span class="cm">/* private: */</span>
	<span class="kt">int</span>                     <span class="n">skc_dontcopy_end</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="cm">/* public: */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cg_proto</span><span class="p">;</span>
<span class="cm">/**</span>
<span class="cm">  *	struct sock - network layer representation of sockets</span>
<span class="cm">  *	@__sk_common: shared layout with inet_timewait_sock</span>
<span class="cm">  *	@sk_shutdown: mask of %SEND_SHUTDOWN and/or %RCV_SHUTDOWN</span>
<span class="cm">  *	@sk_userlocks: %SO_SNDBUF and %SO_RCVBUF settings</span>
<span class="cm">  *	@sk_lock:	synchronizer</span>
<span class="cm">  *	@sk_rcvbuf: size of receive buffer in bytes</span>
<span class="cm">  *	@sk_wq: sock wait queue and async head</span>
<span class="cm">  *	@sk_dst_cache: destination cache</span>
<span class="cm">  *	@sk_dst_lock: destination cache lock</span>
<span class="cm">  *	@sk_policy: flow policy</span>
<span class="cm">  *	@sk_receive_queue: incoming packets</span>
<span class="cm">  *	@sk_wmem_alloc: transmit queue bytes committed</span>
<span class="cm">  *	@sk_write_queue: Packet sending queue</span>
<span class="cm">  *	@sk_async_wait_queue: DMA copied packets</span>
<span class="cm">  *	@sk_omem_alloc: &quot;o&quot; is &quot;option&quot; or &quot;other&quot;</span>
<span class="cm">  *	@sk_wmem_queued: persistent queue size</span>
<span class="cm">  *	@sk_forward_alloc: space allocated forward</span>
<span class="cm">  *	@sk_allocation: allocation mode</span>
<span class="cm">  *	@sk_sndbuf: size of send buffer in bytes</span>
<span class="cm">  *	@sk_flags: %SO_LINGER (l_onoff), %SO_BROADCAST, %SO_KEEPALIVE,</span>
<span class="cm">  *		   %SO_OOBINLINE settings, %SO_TIMESTAMPING settings</span>
<span class="cm">  *	@sk_no_check: %SO_NO_CHECK setting, wether or not checkup packets</span>
<span class="cm">  *	@sk_route_caps: route capabilities (e.g. %NETIF_F_TSO)</span>
<span class="cm">  *	@sk_route_nocaps: forbidden route capabilities (e.g NETIF_F_GSO_MASK)</span>
<span class="cm">  *	@sk_gso_type: GSO type (e.g. %SKB_GSO_TCPV4)</span>
<span class="cm">  *	@sk_gso_max_size: Maximum GSO segment size to build</span>
<span class="cm">  *	@sk_lingertime: %SO_LINGER l_linger setting</span>
<span class="cm">  *	@sk_backlog: always used with the per-socket spinlock held</span>
<span class="cm">  *	@sk_callback_lock: used with the callbacks in the end of this struct</span>
<span class="cm">  *	@sk_error_queue: rarely used</span>
<span class="cm">  *	@sk_prot_creator: sk_prot of original sock creator (see ipv6_setsockopt,</span>
<span class="cm">  *			  IPV6_ADDRFORM for instance)</span>
<span class="cm">  *	@sk_err: last error</span>
<span class="cm">  *	@sk_err_soft: errors that don&#39;t cause failure but are the cause of a</span>
<span class="cm">  *		      persistent failure not just &#39;timed out&#39;</span>
<span class="cm">  *	@sk_drops: raw/udp drops counter</span>
<span class="cm">  *	@sk_ack_backlog: current listen backlog</span>
<span class="cm">  *	@sk_max_ack_backlog: listen backlog set in listen()</span>
<span class="cm">  *	@sk_priority: %SO_PRIORITY setting</span>
<span class="cm">  *	@sk_cgrp_prioidx: socket group&#39;s priority map index</span>
<span class="cm">  *	@sk_type: socket type (%SOCK_STREAM, etc)</span>
<span class="cm">  *	@sk_protocol: which protocol this socket belongs in this network family</span>
<span class="cm">  *	@sk_peer_pid: &amp;struct pid for this socket&#39;s peer</span>
<span class="cm">  *	@sk_peer_cred: %SO_PEERCRED setting</span>
<span class="cm">  *	@sk_rcvlowat: %SO_RCVLOWAT setting</span>
<span class="cm">  *	@sk_rcvtimeo: %SO_RCVTIMEO setting</span>
<span class="cm">  *	@sk_sndtimeo: %SO_SNDTIMEO setting</span>
<span class="cm">  *	@sk_rxhash: flow hash received from netif layer</span>
<span class="cm">  *	@sk_filter: socket filtering instructions</span>
<span class="cm">  *	@sk_protinfo: private area, net family specific, when not using slab</span>
<span class="cm">  *	@sk_timer: sock cleanup timer</span>
<span class="cm">  *	@sk_stamp: time stamp of last packet received</span>
<span class="cm">  *	@sk_socket: Identd and reporting IO signals</span>
<span class="cm">  *	@sk_user_data: RPC layer private data</span>
<span class="cm">  *	@sk_sndmsg_page: cached page for sendmsg</span>
<span class="cm">  *	@sk_sndmsg_off: cached offset for sendmsg</span>
<span class="cm">  *	@sk_peek_off: current peek_offset value</span>
<span class="cm">  *	@sk_send_head: front of stuff to transmit</span>
<span class="cm">  *	@sk_security: used by security modules</span>
<span class="cm">  *	@sk_mark: generic packet mark</span>
<span class="cm">  *	@sk_classid: this socket&#39;s cgroup classid</span>
<span class="cm">  *	@sk_cgrp: this socket&#39;s cgroup-specific proto data</span>
<span class="cm">  *	@sk_write_pending: a write to stream socket waits to start</span>
<span class="cm">  *	@sk_state_change: callback to indicate change in the state of the sock</span>
<span class="cm">  *	@sk_data_ready: callback to indicate there is data to be processed</span>
<span class="cm">  *	@sk_write_space: callback to indicate there is bf sending space available</span>
<span class="cm">  *	@sk_error_report: callback to indicate errors (e.g. %MSG_ERRQUEUE)</span>
<span class="cm">  *	@sk_backlog_rcv: callback to process the backlog</span>
<span class="cm">  *	@sk_destruct: called at sock freeing time, i.e. when all refcnt == 0</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sock</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now struct inet_timewait_sock also uses sock_common, so please just</span>
<span class="cm">	 * don&#39;t add nothing before this first member (__sk_common) --acme</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sock_common</span>	<span class="n">__sk_common</span><span class="p">;</span>
<span class="cp">#define sk_node			__sk_common.skc_node</span>
<span class="cp">#define sk_nulls_node		__sk_common.skc_nulls_node</span>
<span class="cp">#define sk_refcnt		__sk_common.skc_refcnt</span>
<span class="cp">#define sk_tx_queue_mapping	__sk_common.skc_tx_queue_mapping</span>

<span class="cp">#define sk_dontcopy_begin	__sk_common.skc_dontcopy_begin</span>
<span class="cp">#define sk_dontcopy_end		__sk_common.skc_dontcopy_end</span>
<span class="cp">#define sk_hash			__sk_common.skc_hash</span>
<span class="cp">#define sk_family		__sk_common.skc_family</span>
<span class="cp">#define sk_state		__sk_common.skc_state</span>
<span class="cp">#define sk_reuse		__sk_common.skc_reuse</span>
<span class="cp">#define sk_bound_dev_if		__sk_common.skc_bound_dev_if</span>
<span class="cp">#define sk_bind_node		__sk_common.skc_bind_node</span>
<span class="cp">#define sk_prot			__sk_common.skc_prot</span>
<span class="cp">#define sk_net			__sk_common.skc_net</span>
	<span class="n">socket_lock_t</span>		<span class="n">sk_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span>	<span class="n">sk_receive_queue</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The backlog queue is special, it is always used with</span>
<span class="cm">	 * the per-socket spinlock held and requires low latency</span>
<span class="cm">	 * access. Therefore we special case it&#39;s implementation.</span>
<span class="cm">	 * Note : rmem_alloc is in this structure to fill a hole</span>
<span class="cm">	 * on 64bit arches, not because its logically part of</span>
<span class="cm">	 * backlog.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">atomic_t</span>	<span class="n">rmem_alloc</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">len</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sk_buff</span>	<span class="o">*</span><span class="n">head</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sk_buff</span>	<span class="o">*</span><span class="n">tail</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">sk_backlog</span><span class="p">;</span>
<span class="cp">#define sk_rmem_alloc sk_backlog.rmem_alloc</span>
	<span class="kt">int</span>			<span class="n">sk_forward_alloc</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="n">__u32</span>			<span class="n">sk_rxhash</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">atomic_t</span>		<span class="n">sk_drops</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sk_rcvbuf</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sk_filter</span> <span class="n">__rcu</span>	<span class="o">*</span><span class="n">sk_filter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_wq</span> <span class="n">__rcu</span>	<span class="o">*</span><span class="n">sk_wq</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NET_DMA</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span>	<span class="n">sk_async_wait_queue</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_XFRM</span>
	<span class="k">struct</span> <span class="n">xfrm_policy</span>	<span class="o">*</span><span class="n">sk_policy</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> 		<span class="n">sk_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dst_entry</span>	<span class="o">*</span><span class="n">sk_dst_cache</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">sk_dst_lock</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">sk_wmem_alloc</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">sk_omem_alloc</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sk_sndbuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span>	<span class="n">sk_write_queue</span><span class="p">;</span>
	<span class="n">kmemcheck_bitfield_begin</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sk_shutdown</span>  <span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
				<span class="n">sk_no_check</span>  <span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
				<span class="n">sk_userlocks</span> <span class="o">:</span> <span class="mi">4</span><span class="p">,</span>
				<span class="n">sk_protocol</span>  <span class="o">:</span> <span class="mi">8</span><span class="p">,</span>
				<span class="n">sk_type</span>      <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">kmemcheck_bitfield_end</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">sk_wmem_queued</span><span class="p">;</span>
	<span class="n">gfp_t</span>			<span class="n">sk_allocation</span><span class="p">;</span>
	<span class="n">netdev_features_t</span>	<span class="n">sk_route_caps</span><span class="p">;</span>
	<span class="n">netdev_features_t</span>	<span class="n">sk_route_nocaps</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sk_gso_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sk_gso_max_size</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sk_rcvlowat</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	        <span class="n">sk_lingertime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span>	<span class="n">sk_error_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proto</span>		<span class="o">*</span><span class="n">sk_prot_creator</span><span class="p">;</span>
	<span class="n">rwlock_t</span>		<span class="n">sk_callback_lock</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sk_err</span><span class="p">,</span>
				<span class="n">sk_err_soft</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">sk_ack_backlog</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">sk_max_ack_backlog</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">sk_priority</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_CGROUPS</span>
	<span class="n">__u32</span>			<span class="n">sk_cgrp_prioidx</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">pid</span>		<span class="o">*</span><span class="n">sk_peer_pid</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span>	<span class="o">*</span><span class="n">sk_peer_cred</span><span class="p">;</span>
	<span class="kt">long</span>			<span class="n">sk_rcvtimeo</span><span class="p">;</span>
	<span class="kt">long</span>			<span class="n">sk_sndtimeo</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">sk_protinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">sk_timer</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="n">sk_stamp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span>		<span class="o">*</span><span class="n">sk_socket</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">sk_user_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">sk_sndmsg_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">sk_send_head</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">sk_sndmsg_off</span><span class="p">;</span>
	<span class="n">__s32</span>			<span class="n">sk_peek_off</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sk_write_pending</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SECURITY</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">sk_security</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">__u32</span>			<span class="n">sk_mark</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">sk_classid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cg_proto</span>		<span class="o">*</span><span class="n">sk_cgrp</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">sk_state_change</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">sk_data_ready</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">sk_write_space</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">sk_error_report</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">sk_backlog_rcv</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">void</span>                    <span class="p">(</span><span class="o">*</span><span class="n">sk_destruct</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * SK_CAN_REUSE and SK_NO_REUSE on a socket mean that the socket is OK</span>
<span class="cm"> * or not whether his port will be reused by someone else. SK_FORCE_REUSE</span>
<span class="cm"> * on a socket means that the socket will reuse everybody else&#39;s port</span>
<span class="cm"> * without looking at the other&#39;s sk_reuse value.</span>
<span class="cm"> */</span>

<span class="cp">#define SK_NO_REUSE	0</span>
<span class="cp">#define SK_CAN_REUSE	1</span>
<span class="cp">#define SK_FORCE_REUSE	2</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sk_peek_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peek_off</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peek_off</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_peek_offset_bwd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peek_off</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peek_off</span> <span class="o">&gt;=</span> <span class="n">val</span><span class="p">)</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peek_off</span> <span class="o">-=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peek_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_peek_offset_fwd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peek_off</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peek_off</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hashed lists helper routines</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">sk_entry</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hlist_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span><span class="p">,</span> <span class="n">sk_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">__sk_head</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hlist_entry</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span><span class="p">,</span> <span class="n">sk_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">sk_head</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hlist_empty</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">__sk_head</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">__sk_nulls_head</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hlist_nulls_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hlist_nulls_entry</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span><span class="p">,</span> <span class="n">sk_nulls_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">sk_nulls_head</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hlist_nulls_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hlist_nulls_empty</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">__sk_nulls_head</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">sk_next</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_node</span><span class="p">.</span><span class="n">next</span> <span class="o">?</span>
		<span class="n">hlist_entry</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_node</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span><span class="p">,</span> <span class="n">sk_node</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">sk_nulls_next</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">is_a_nulls</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_nulls_node</span><span class="p">.</span><span class="n">next</span><span class="p">))</span> <span class="o">?</span>
		<span class="n">hlist_nulls_entry</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_nulls_node</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sock</span><span class="p">,</span> <span class="n">sk_nulls_node</span><span class="p">)</span> <span class="o">:</span>
		<span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sk_unhashed</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sk_hashed</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">sk_unhashed</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_node_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_nulls_node_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_nulls_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__sk_del_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* NB: equivalent to hlist_del_init_rcu */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">__sk_del_node_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk_hashed</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__sk_del_node</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">sk_node_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_node</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Grab socket reference count. This operation is valid only</span>
<span class="cm">   when sk is ALREADY grabbed f.e. it is found in hash table</span>
<span class="cm">   or a list and the lookup is made under lock preventing hash table</span>
<span class="cm">   modifications.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Ungrab socket in the context, which assumes that socket refcnt</span>
<span class="cm">   cannot hit zero, f.e. it is true in context of any socketcall.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__sock_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sk_del_node_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">__sk_del_node_init</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* paranoid for a while -acme */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">__sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define sk_del_node_init_rcu(sk)	sk_del_node_init(sk)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">__sk_nulls_del_node_init_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk_hashed</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hlist_nulls_del_init_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_nulls_node</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sk_nulls_del_node_init_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">__sk_nulls_del_node_init_rcu</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* paranoid for a while -acme */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">__sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__sk_add_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_add_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sock_hold</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">__sk_add_node</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_add_node_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sock_hold</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">hlist_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__sk_nulls_add_node_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hlist_nulls_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hlist_nulls_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_nulls_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_nulls_add_node_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hlist_nulls_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sock_hold</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">__sk_nulls_add_node_rcu</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__sk_del_bind_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_bind_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_add_bind_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_bind_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define sk_for_each(__sk, node, list) \</span>
<span class="cp">	hlist_for_each_entry(__sk, node, list, sk_node)</span>
<span class="cp">#define sk_for_each_rcu(__sk, node, list) \</span>
<span class="cp">	hlist_for_each_entry_rcu(__sk, node, list, sk_node)</span>
<span class="cp">#define sk_nulls_for_each(__sk, node, list) \</span>
<span class="cp">	hlist_nulls_for_each_entry(__sk, node, list, sk_nulls_node)</span>
<span class="cp">#define sk_nulls_for_each_rcu(__sk, node, list) \</span>
<span class="cp">	hlist_nulls_for_each_entry_rcu(__sk, node, list, sk_nulls_node)</span>
<span class="cp">#define sk_for_each_from(__sk, node) \</span>
<span class="cp">	if (__sk &amp;&amp; ({ node = &amp;(__sk)-&gt;sk_node; 1; })) \</span>
<span class="cp">		hlist_for_each_entry_from(__sk, node, sk_node)</span>
<span class="cp">#define sk_nulls_for_each_from(__sk, node) \</span>
<span class="cp">	if (__sk &amp;&amp; ({ node = &amp;(__sk)-&gt;sk_nulls_node; 1; })) \</span>
<span class="cp">		hlist_nulls_for_each_entry_from(__sk, node, sk_nulls_node)</span>
<span class="cp">#define sk_for_each_safe(__sk, node, tmp, list) \</span>
<span class="cp">	hlist_for_each_entry_safe(__sk, node, tmp, list, sk_node)</span>
<span class="cp">#define sk_for_each_bound(__sk, node, list) \</span>
<span class="cp">	hlist_for_each_entry(__sk, node, list, sk_bind_node)</span>

<span class="cm">/* Sock flags */</span>
<span class="k">enum</span> <span class="n">sock_flags</span> <span class="p">{</span>
	<span class="n">SOCK_DEAD</span><span class="p">,</span>
	<span class="n">SOCK_DONE</span><span class="p">,</span>
	<span class="n">SOCK_URGINLINE</span><span class="p">,</span>
	<span class="n">SOCK_KEEPOPEN</span><span class="p">,</span>
	<span class="n">SOCK_LINGER</span><span class="p">,</span>
	<span class="n">SOCK_DESTROY</span><span class="p">,</span>
	<span class="n">SOCK_BROADCAST</span><span class="p">,</span>
	<span class="n">SOCK_TIMESTAMP</span><span class="p">,</span>
	<span class="n">SOCK_ZAPPED</span><span class="p">,</span>
	<span class="n">SOCK_USE_WRITE_QUEUE</span><span class="p">,</span> <span class="cm">/* whether to call sk-&gt;sk_write_space in sock_wfree */</span>
	<span class="n">SOCK_DBG</span><span class="p">,</span> <span class="cm">/* %SO_DEBUG setting */</span>
	<span class="n">SOCK_RCVTSTAMP</span><span class="p">,</span> <span class="cm">/* %SO_TIMESTAMP setting */</span>
	<span class="n">SOCK_RCVTSTAMPNS</span><span class="p">,</span> <span class="cm">/* %SO_TIMESTAMPNS setting */</span>
	<span class="n">SOCK_LOCALROUTE</span><span class="p">,</span> <span class="cm">/* route locally only, %SO_DONTROUTE setting */</span>
	<span class="n">SOCK_QUEUE_SHRUNK</span><span class="p">,</span> <span class="cm">/* write queue has been shrunk recently */</span>
	<span class="n">SOCK_TIMESTAMPING_TX_HARDWARE</span><span class="p">,</span>  <span class="cm">/* %SOF_TIMESTAMPING_TX_HARDWARE */</span>
	<span class="n">SOCK_TIMESTAMPING_TX_SOFTWARE</span><span class="p">,</span>  <span class="cm">/* %SOF_TIMESTAMPING_TX_SOFTWARE */</span>
	<span class="n">SOCK_TIMESTAMPING_RX_HARDWARE</span><span class="p">,</span>  <span class="cm">/* %SOF_TIMESTAMPING_RX_HARDWARE */</span>
	<span class="n">SOCK_TIMESTAMPING_RX_SOFTWARE</span><span class="p">,</span>  <span class="cm">/* %SOF_TIMESTAMPING_RX_SOFTWARE */</span>
	<span class="n">SOCK_TIMESTAMPING_SOFTWARE</span><span class="p">,</span>     <span class="cm">/* %SOF_TIMESTAMPING_SOFTWARE */</span>
	<span class="n">SOCK_TIMESTAMPING_RAW_HARDWARE</span><span class="p">,</span> <span class="cm">/* %SOF_TIMESTAMPING_RAW_HARDWARE */</span>
	<span class="n">SOCK_TIMESTAMPING_SYS_HARDWARE</span><span class="p">,</span> <span class="cm">/* %SOF_TIMESTAMPING_SYS_HARDWARE */</span>
	<span class="n">SOCK_FASYNC</span><span class="p">,</span> <span class="cm">/* fasync() active */</span>
	<span class="n">SOCK_RXQ_OVFL</span><span class="p">,</span>
	<span class="n">SOCK_ZEROCOPY</span><span class="p">,</span> <span class="cm">/* buffers from userspace */</span>
	<span class="n">SOCK_WIFI_STATUS</span><span class="p">,</span> <span class="cm">/* push wifi status to userspace */</span>
	<span class="n">SOCK_NOFCS</span><span class="p">,</span> <span class="cm">/* Tell NIC not to do the Ethernet FCS.</span>
<span class="cm">		     * Will use last 4 bytes of packet sent from</span>
<span class="cm">		     * user-space instead.</span>
<span class="cm">		     */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_copy_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">nsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">osk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nsk</span><span class="o">-&gt;</span><span class="n">sk_flags</span> <span class="o">=</span> <span class="n">osk</span><span class="o">-&gt;</span><span class="n">sk_flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_set_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">enum</span> <span class="n">sock_flags</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_reset_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">enum</span> <span class="n">sock_flags</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sock_flag</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">enum</span> <span class="n">sock_flags</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_acceptq_removed</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_ack_backlog</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_acceptq_added</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_ack_backlog</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sk_acceptq_is_full</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_ack_backlog</span> <span class="o">&gt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_max_ack_backlog</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Compute minimal free write space needed to queue new packets.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sk_stream_min_wspace</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sk_stream_wspace</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">-</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sk_stream_write_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sk_stream_memory_free</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* OOB backlog add */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__sk_add_backlog</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* dont let skb dst not refcounted, we are going to leave rcu lock */</span>
	<span class="n">skb_dst_force</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog</span><span class="p">.</span><span class="n">tail</span><span class="p">)</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog</span><span class="p">.</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Take into account size of receive queue and backlog queue</span>
<span class="cm"> * Do not take into account this skb truesize,</span>
<span class="cm"> * to allow even a single big packet to come.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sk_rcvqueues_full</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">qsize</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog</span><span class="p">.</span><span class="n">len</span> <span class="o">+</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">qsize</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The per-socket spinlock must be held here. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__must_check</span> <span class="kt">int</span> <span class="nf">sk_add_backlog</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk_rcvqueues_full</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">limit</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="n">__sk_add_backlog</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog</span><span class="p">.</span><span class="n">len</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sk_backlog_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog_rcv</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_rps_record_flow</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="k">struct</span> <span class="n">rps_sock_flow_table</span> <span class="o">*</span><span class="n">sock_flow_table</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">sock_flow_table</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">rps_sock_flow_table</span><span class="p">);</span>
	<span class="n">rps_record_sock_flow</span><span class="p">(</span><span class="n">sock_flow_table</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rxhash</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_rps_reset_flow</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="k">struct</span> <span class="n">rps_sock_flow_table</span> <span class="o">*</span><span class="n">sock_flow_table</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">sock_flow_table</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">rps_sock_flow_table</span><span class="p">);</span>
	<span class="n">rps_reset_sock_flow</span><span class="p">(</span><span class="n">sock_flow_table</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rxhash</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_rps_save_rxhash</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rxhash</span> <span class="o">!=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">rxhash</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sock_rps_reset_flow</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rxhash</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">rxhash</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_rps_reset_rxhash</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="n">sock_rps_reset_flow</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rxhash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#define sk_wait_event(__sk, __timeo, __condition)			\</span>
<span class="cp">	({	int __rc;						\</span>
<span class="cp">		release_sock(__sk);					\</span>
<span class="cp">		__rc = __condition;					\</span>
<span class="cp">		if (!__rc) {						\</span>
<span class="cp">			*(__timeo) = schedule_timeout(*(__timeo));	\</span>
<span class="cp">		}							\</span>
<span class="cp">		lock_sock(__sk);					\</span>
<span class="cp">		__rc = __condition;					\</span>
<span class="cp">		__rc;							\</span>
<span class="cp">	})</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sk_stream_wait_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timeo_p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sk_stream_wait_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timeo_p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sk_stream_wait_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeo_p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sk_stream_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sk_stream_kill_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sk_wait_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timeo</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">request_sock_ops</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">timewait_sock_ops</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">inet_hashinfo</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">raw_hashinfo</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>

<span class="cm">/* Networking protocol blocks we attach to sockets.</span>
<span class="cm"> * socket layer -&gt; transport layer interface</span>
<span class="cm"> * transport -&gt; network interface is defined by struct inet_proto</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">proto</span> <span class="p">{</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					<span class="kt">long</span> <span class="n">timeout</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">addr_len</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span>		<span class="p">(</span><span class="o">*</span><span class="n">accept</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>

	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">setsockopt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">getsockopt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">option</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">compat_setsockopt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">compat_getsockopt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">option</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">compat_ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">sendmsg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">recvmsg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
					   <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">noblock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="o">*</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">sendpage</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr_len</span><span class="p">);</span>

	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">backlog_rcv</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Keeping track of sk&#39;s, looking them up, and port selection methods. */</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">hash</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">unhash</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">rehash</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">get_port</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">snum</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">clear_sk</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/* Keeping track of sockets in use */</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">inuse_idx</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Memory pressure */</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">enter_memory_pressure</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">atomic_long_t</span>		<span class="o">*</span><span class="n">memory_allocated</span><span class="p">;</span>	<span class="cm">/* Current allocated memory. */</span>
	<span class="k">struct</span> <span class="n">percpu_counter</span>	<span class="o">*</span><span class="n">sockets_allocated</span><span class="p">;</span>	<span class="cm">/* Current number of sockets. */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Pressure flag: try to collapse.</span>
<span class="cm">	 * Technical note: it is used by multiple contexts non atomically.</span>
<span class="cm">	 * All the __sk_mem_schedule() is of this nature: accounting</span>
<span class="cm">	 * is strict, actions are advisory and have some latency.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">memory_pressure</span><span class="p">;</span>
	<span class="kt">long</span>			<span class="o">*</span><span class="n">sysctl_mem</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">sysctl_wmem</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">sysctl_rmem</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_header</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">no_autobind</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">kmem_cache</span>	<span class="o">*</span><span class="n">slab</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">obj_size</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">slab_flags</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">percpu_counter</span>	<span class="o">*</span><span class="n">orphan_count</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">request_sock_ops</span>	<span class="o">*</span><span class="n">rsk_prot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timewait_sock_ops</span> <span class="o">*</span><span class="n">twsk_prot</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inet_hashinfo</span>	<span class="o">*</span><span class="n">hashinfo</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">udp_table</span>	<span class="o">*</span><span class="n">udp_table</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">raw_hashinfo</span>	<span class="o">*</span><span class="n">raw_hash</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">h</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">module</span>		<span class="o">*</span><span class="n">owner</span><span class="p">;</span>

	<span class="kt">char</span>			<span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">node</span><span class="p">;</span>
<span class="cp">#ifdef SOCK_REFCNT_DEBUG</span>
	<span class="n">atomic_t</span>		<span class="n">socks</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR_KMEM</span>
	<span class="cm">/*</span>
<span class="cm">	 * cgroup specific init/deinit functions. Called once for all</span>
<span class="cm">	 * protocols that implement it, from cgroups populate function.</span>
<span class="cm">	 * This function has to setup any files the protocol want to</span>
<span class="cm">	 * appear in the kmem cgroup filesystem.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">init_cgroup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">destroy_cgroup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cg_proto</span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">proto_cgroup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Bits in struct cg_proto.flags</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">cg_proto_flags</span> <span class="p">{</span>
	<span class="cm">/* Currently active and new sockets should be assigned to cgroups */</span>
	<span class="n">MEMCG_SOCK_ACTIVE</span><span class="p">,</span>
	<span class="cm">/* It was ever activated; we must disarm static keys on destruction */</span>
	<span class="n">MEMCG_SOCK_ACTIVATED</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cg_proto</span> <span class="p">{</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">enter_memory_pressure</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">res_counter</span>	<span class="o">*</span><span class="n">memory_allocated</span><span class="p">;</span>	<span class="cm">/* Current allocated memory. */</span>
	<span class="k">struct</span> <span class="n">percpu_counter</span>	<span class="o">*</span><span class="n">sockets_allocated</span><span class="p">;</span>	<span class="cm">/* Current number of sockets. */</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">memory_pressure</span><span class="p">;</span>
	<span class="kt">long</span>			<span class="o">*</span><span class="n">sysctl_mem</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * memcg field is used to find which memcg we belong directly</span>
<span class="cm">	 * Each memcg struct can hold more than one cg_proto, so container_of</span>
<span class="cm">	 * won&#39;t really cut.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The elegant solution would be having an inverse function to</span>
<span class="cm">	 * proto_cgroup in struct proto, but that means polluting the structure</span>
<span class="cm">	 * for everybody, instead of just for memcg users.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span>	<span class="o">*</span><span class="n">memcg</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">proto_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alloc_slab</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">proto_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">memcg_proto_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">cg_proto</span> <span class="o">*</span><span class="n">cg_proto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">MEMCG_SOCK_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cg_proto</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">memcg_proto_activated</span><span class="p">(</span><span class="k">struct</span> <span class="n">cg_proto</span> <span class="o">*</span><span class="n">cg_proto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">MEMCG_SOCK_ACTIVATED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cg_proto</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef SOCK_REFCNT_DEBUG</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_refcnt_debug_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">socks</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_refcnt_debug_dec</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">socks</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s socket %p released, %d are still alive</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">socks</span><span class="p">));</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_refcnt_debug_release</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Destruction of the %s socket %p delayed, refcnt=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* SOCK_REFCNT_DEBUG */</span><span class="cp"></span>
<span class="cp">#define sk_refcnt_debug_inc(sk) do { } while (0)</span>
<span class="cp">#define sk_refcnt_debug_dec(sk) do { } while (0)</span>
<span class="cp">#define sk_refcnt_debug_release(sk) do { } while (0)</span>
<span class="cp">#endif </span><span class="cm">/* SOCK_REFCNT_DEBUG */</span><span class="cp"></span>

<span class="cp">#if defined(CONFIG_CGROUP_MEM_RES_CTLR_KMEM) &amp;&amp; defined(CONFIG_NET)</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">static_key</span> <span class="n">memcg_socket_limit_enabled</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cg_proto</span> <span class="o">*</span><span class="nf">parent_cg_proto</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">proto</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">cg_proto</span> <span class="o">*</span><span class="n">cg_proto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">proto</span><span class="o">-&gt;</span><span class="n">proto_cgroup</span><span class="p">(</span><span class="n">parent_mem_cgroup</span><span class="p">(</span><span class="n">cg_proto</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#define mem_cgroup_sockets_enabled static_key_false(&amp;memcg_socket_limit_enabled)</span>
<span class="cp">#else</span>
<span class="cp">#define mem_cgroup_sockets_enabled 0</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cg_proto</span> <span class="o">*</span><span class="nf">parent_cg_proto</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">proto</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">cg_proto</span> <span class="o">*</span><span class="n">cg_proto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sk_has_memory_pressure</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">memory_pressure</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sk_under_memory_pressure</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">memory_pressure</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_sockets_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">!!*</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="o">-&gt;</span><span class="n">memory_pressure</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">!!*</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">memory_pressure</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_leave_memory_pressure</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">memory_pressure</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">memory_pressure</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memory_pressure</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">memory_pressure</span><span class="p">)</span>
		<span class="o">*</span><span class="n">memory_pressure</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_sockets_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cg_proto</span> <span class="o">*</span><span class="n">cg_proto</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(;</span> <span class="n">cg_proto</span><span class="p">;</span> <span class="n">cg_proto</span> <span class="o">=</span> <span class="n">parent_cg_proto</span><span class="p">(</span><span class="n">prot</span><span class="p">,</span> <span class="n">cg_proto</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cg_proto</span><span class="o">-&gt;</span><span class="n">memory_pressure</span><span class="p">)</span>
				<span class="o">*</span><span class="n">cg_proto</span><span class="o">-&gt;</span><span class="n">memory_pressure</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_enter_memory_pressure</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">enter_memory_pressure</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_sockets_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cg_proto</span> <span class="o">*</span><span class="n">cg_proto</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(;</span> <span class="n">cg_proto</span><span class="p">;</span> <span class="n">cg_proto</span> <span class="o">=</span> <span class="n">parent_cg_proto</span><span class="p">(</span><span class="n">prot</span><span class="p">,</span> <span class="n">cg_proto</span><span class="p">))</span>
			<span class="n">cg_proto</span><span class="o">-&gt;</span><span class="n">enter_memory_pressure</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">enter_memory_pressure</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">sk_prot_mem_limits</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="o">*</span><span class="n">prot</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">sysctl_mem</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_sockets_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">)</span>
		<span class="n">prot</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="o">-&gt;</span><span class="n">sysctl_mem</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">prot</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">memcg_memory_allocated_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">cg_proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">amt</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="o">*</span><span class="n">parent_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">res_counter</span> <span class="o">*</span><span class="n">fail</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">res_counter_charge_nofail</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">memory_allocated</span><span class="p">,</span>
					<span class="n">amt</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fail</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">parent_status</span> <span class="o">=</span> <span class="n">OVER_LIMIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">memcg_memory_allocated_sub</span><span class="p">(</span><span class="k">struct</span> <span class="n">cg_proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">amt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">res_counter_uncharge</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">memory_allocated</span><span class="p">,</span> <span class="n">amt</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">memcg_memory_allocated_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cg_proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">memory_allocated</span><span class="p">,</span> <span class="n">RES_USAGE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span>
<span class="nf">sk_memory_allocated</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_sockets_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">memcg_memory_allocated_read</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">memory_allocated</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span>
<span class="nf">sk_memory_allocated_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amt</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">parent_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_sockets_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcg_memory_allocated_add</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">,</span> <span class="n">amt</span><span class="p">,</span> <span class="n">parent_status</span><span class="p">);</span>
		<span class="cm">/* update the root cgroup regardless */</span>
		<span class="n">atomic_long_add_return</span><span class="p">(</span><span class="n">amt</span><span class="p">,</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">memory_allocated</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">memcg_memory_allocated_read</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">atomic_long_add_return</span><span class="p">(</span><span class="n">amt</span><span class="p">,</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">memory_allocated</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">sk_memory_allocated_sub</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_sockets_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">)</span>
		<span class="n">memcg_memory_allocated_sub</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">,</span> <span class="n">amt</span><span class="p">);</span>

	<span class="n">atomic_long_sub</span><span class="p">(</span><span class="n">amt</span><span class="p">,</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">memory_allocated</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_sockets_allocated_dec</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_sockets_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cg_proto</span> <span class="o">*</span><span class="n">cg_proto</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(;</span> <span class="n">cg_proto</span><span class="p">;</span> <span class="n">cg_proto</span> <span class="o">=</span> <span class="n">parent_cg_proto</span><span class="p">(</span><span class="n">prot</span><span class="p">,</span> <span class="n">cg_proto</span><span class="p">))</span>
			<span class="n">percpu_counter_dec</span><span class="p">(</span><span class="n">cg_proto</span><span class="o">-&gt;</span><span class="n">sockets_allocated</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">percpu_counter_dec</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">sockets_allocated</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_sockets_allocated_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_sockets_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cg_proto</span> <span class="o">*</span><span class="n">cg_proto</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(;</span> <span class="n">cg_proto</span><span class="p">;</span> <span class="n">cg_proto</span> <span class="o">=</span> <span class="n">parent_cg_proto</span><span class="p">(</span><span class="n">prot</span><span class="p">,</span> <span class="n">cg_proto</span><span class="p">))</span>
			<span class="n">percpu_counter_inc</span><span class="p">(</span><span class="n">cg_proto</span><span class="o">-&gt;</span><span class="n">sockets_allocated</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">percpu_counter_inc</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">sockets_allocated</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">sk_sockets_allocated_read_positive</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_sockets_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">percpu_counter_read_positive</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="o">-&gt;</span><span class="n">sockets_allocated</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">percpu_counter_read_positive</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">sockets_allocated</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">proto_sockets_allocated_sum_positive</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">percpu_counter_sum_positive</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">sockets_allocated</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span>
<span class="nf">proto_memory_allocated</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">memory_allocated</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">proto_memory_pressure</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">memory_pressure</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">!!*</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">memory_pressure</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cm">/* Called with local bh disabled */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sock_prot_inuse_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sock_prot_inuse_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">proto</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_prot_inuse_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">inc</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="cm">/* With per-bucket locks this operation is not-atomic, so that</span>
<span class="cm"> * this version is not worse.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__sk_prot_rehash</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">unhash</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">sk_prot_clear_portaddr_nulls</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/* About 10 seconds */</span>
<span class="cp">#define SOCK_DESTROY_TIME (10*HZ)</span>

<span class="cm">/* Sockets 0-1023 can&#39;t be bound to unless you are superuser */</span>
<span class="cp">#define PROT_SOCK	1024</span>

<span class="cp">#define SHUTDOWN_MASK	3</span>
<span class="cp">#define RCV_SHUTDOWN	1</span>
<span class="cp">#define SEND_SHUTDOWN	2</span>

<span class="cp">#define SOCK_SNDBUF_LOCK	1</span>
<span class="cp">#define SOCK_RCVBUF_LOCK	2</span>
<span class="cp">#define SOCK_BINDADDR_LOCK	4</span>
<span class="cp">#define SOCK_BINDPORT_LOCK	8</span>

<span class="cm">/* sock_iocb: used to kick off async processing of socket ios */</span>
<span class="k">struct</span> <span class="n">sock_iocb</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span>		<span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span>		<span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scm_cookie</span>	<span class="o">*</span><span class="n">scm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msghdr</span>		<span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">async_msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kiocb</span>		<span class="o">*</span><span class="n">kiocb</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock_iocb</span> <span class="o">*</span><span class="nf">kiocb_to_siocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock_iocb</span> <span class="o">*</span><span class="p">)</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="nf">siocb_to_kiocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock_iocb</span> <span class="o">*</span><span class="n">si</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">kiocb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">socket_alloc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="n">socket</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="nf">SOCKET_I</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket_alloc</span><span class="p">,</span> <span class="n">vfs_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">SOCK_INODE</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">socket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">container_of</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket_alloc</span><span class="p">,</span> <span class="n">socket</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Functions for memory accounting</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__sk_mem_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kind</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__sk_mem_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="cp">#define SK_MEM_QUANTUM ((int)PAGE_SIZE)</span>
<span class="cp">#define SK_MEM_QUANTUM_SHIFT ilog2(SK_MEM_QUANTUM)</span>
<span class="cp">#define SK_MEM_SEND	0</span>
<span class="cp">#define SK_MEM_RECV	1</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sk_mem_pages</span><span class="p">(</span><span class="kt">int</span> <span class="n">amt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">amt</span> <span class="o">+</span> <span class="n">SK_MEM_QUANTUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">SK_MEM_QUANTUM_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sk_has_account</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* return true if protocol supports memory accounting */</span>
	<span class="k">return</span> <span class="o">!!</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">memory_allocated</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sk_wmem_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk_has_account</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_forward_alloc</span> <span class="o">||</span>
		<span class="n">__sk_mem_schedule</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">SK_MEM_SEND</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sk_rmem_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk_has_account</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_forward_alloc</span> <span class="o">||</span>
		<span class="n">__sk_mem_schedule</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">SK_MEM_RECV</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_mem_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk_has_account</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_forward_alloc</span> <span class="o">&gt;=</span> <span class="n">SK_MEM_QUANTUM</span><span class="p">)</span>
		<span class="n">__sk_mem_reclaim</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_mem_reclaim_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk_has_account</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_forward_alloc</span> <span class="o">&gt;</span> <span class="n">SK_MEM_QUANTUM</span><span class="p">)</span>
		<span class="n">__sk_mem_reclaim</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_mem_charge</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk_has_account</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_forward_alloc</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_mem_uncharge</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk_has_account</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_forward_alloc</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_wmem_free_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_QUEUE_SHRUNK</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">-=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>
	<span class="n">sk_mem_uncharge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
	<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Used by processes to &quot;lock&quot; a socket state, so that</span>
<span class="cm"> * interrupts and bottom half handlers won&#39;t change it</span>
<span class="cm"> * from under us. It essentially blocks any incoming</span>
<span class="cm"> * packets, so that we won&#39;t get any new data or any</span>
<span class="cm"> * packets that change the state of the socket.</span>
<span class="cm"> *</span>
<span class="cm"> * While locked, BH processing will add new packets to</span>
<span class="cm"> * the backlog queue.  This queue is processed by the</span>
<span class="cm"> * owner of the socket lock right before it is released.</span>
<span class="cm"> *</span>
<span class="cm"> * Since ~2.3.5 it is also exclusive sleep lock serializing</span>
<span class="cm"> * accesses from user process context.</span>
<span class="cm"> */</span>
<span class="cp">#define sock_owned_by_user(sk)	((sk)-&gt;sk_lock.owned)</span>

<span class="cm">/*</span>
<span class="cm"> * Macro so as to not evaluate some arguments when</span>
<span class="cm"> * lockdep is not enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * Mark both the sk_lock and the sk_lock.slock as a</span>
<span class="cm"> * per-address-family lock class.</span>
<span class="cm"> */</span>
<span class="cp">#define sock_lock_init_class_and_name(sk, sname, skey, name, key)	\</span>
<span class="cp">do {									\</span>
<span class="cp">	sk-&gt;sk_lock.owned = 0;						\</span>
<span class="cp">	init_waitqueue_head(&amp;sk-&gt;sk_lock.wq);				\</span>
<span class="cp">	spin_lock_init(&amp;(sk)-&gt;sk_lock.slock);				\</span>
<span class="cp">	debug_check_no_locks_freed((void *)&amp;(sk)-&gt;sk_lock,		\</span>
<span class="cp">			sizeof((sk)-&gt;sk_lock));				\</span>
<span class="cp">	lockdep_set_class_and_name(&amp;(sk)-&gt;sk_lock.slock,		\</span>
<span class="cp">				(skey), (sname));				\</span>
<span class="cp">	lockdep_init_map(&amp;(sk)-&gt;sk_lock.dep_map, (name), (key), 0);	\</span>
<span class="cp">} while (0)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">lock_sock_nested</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">subclass</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lock_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lock_sock_nested</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">release_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="cm">/* BH context may only use the following locking interface. */</span>
<span class="cp">#define bh_lock_sock(__sk)	spin_lock(&amp;((__sk)-&gt;sk_lock.slock))</span>
<span class="cp">#define bh_lock_sock_nested(__sk) \</span>
<span class="cp">				spin_lock_nested(&amp;((__sk)-&gt;sk_lock.slock), \</span>
<span class="cp">				SINGLE_DEPTH_NESTING)</span>
<span class="cp">#define bh_unlock_sock(__sk)	spin_unlock(&amp;((__sk)-&gt;sk_lock.slock))</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">lock_sock_fast</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * unlock_sock_fast - complement of lock_sock_fast</span>
<span class="cm"> * @sk: socket</span>
<span class="cm"> * @slow: slow mode</span>
<span class="cm"> *</span>
<span class="cm"> * fast unlock socket for user context.</span>
<span class="cm"> * If slow mode is on, we call regular release_sock()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unlock_sock_fast</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">bool</span> <span class="n">slow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slow</span><span class="p">)</span>
		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">slock</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">extern</span> <span class="k">struct</span> <span class="n">sock</span>		<span class="o">*</span><span class="n">sk_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span>
					  <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>			<span class="n">sk_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>			<span class="n">sk_release_kernel</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sock</span>		<span class="o">*</span><span class="n">sk_clone_lock</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					       <span class="k">const</span> <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">sock_wmalloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">,</span>
					      <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">sock_rmalloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">,</span>
					      <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>			<span class="n">sock_wfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>			<span class="n">sock_rfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span>			<span class="n">sock_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span>			<span class="n">sock_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">sock_alloc_send_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
						     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
						     <span class="kt">int</span> <span class="n">noblock</span><span class="p">,</span>
						     <span class="kt">int</span> <span class="o">*</span><span class="n">errcode</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">sock_alloc_send_pskb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
						      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">header_len</span><span class="p">,</span>
						      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data_len</span><span class="p">,</span>
						      <span class="kt">int</span> <span class="n">noblock</span><span class="p">,</span>
						      <span class="kt">int</span> <span class="o">*</span><span class="n">errcode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sock_kmalloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
			  <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sock_kfree_s</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sk_send_sigurg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_CGROUPS</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sock_update_classid</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_update_classid</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Functions to fill in entries in struct proto_ops when a protocol</span>
<span class="cm"> * does not implement a particular function.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span>                      <span class="n">sock_no_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>                      <span class="n">sock_no_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>                      <span class="n">sock_no_socketpair</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>                      <span class="n">sock_no_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>                      <span class="n">sock_no_getname</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span>             <span class="n">sock_no_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>                      <span class="n">sock_no_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>			<span class="n">sock_no_listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>                      <span class="n">sock_no_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>			<span class="n">sock_no_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
						   <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>			<span class="n">sock_no_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
						   <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>                      <span class="n">sock_no_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>                      <span class="n">sock_no_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>			<span class="n">sock_no_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span>			<span class="n">sock_no_sendpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Functions to fill in entries in struct proto_ops when a protocol</span>
<span class="cm"> * uses the inet style.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sock_common_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
				  <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sock_common_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sock_common_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
				  <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">compat_sock_common_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">compat_sock_common_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sk_common_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Default socket callbacks and setup code</span>
<span class="cm"> */</span>

<span class="cm">/* Initialise core socket variables */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sock_init_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sk_filter_release_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rcu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	sk_filter_release - release a socket filter</span>
<span class="cm"> *	@fp: filter to remove</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove a filter from a socket and release its resources.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_filter_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_filter</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">))</span>
		<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">sk_filter_release_rcu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_filter_uncharge</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_filter</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">sk_filter_len</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

	<span class="n">atomic_sub</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_omem_alloc</span><span class="p">);</span>
	<span class="n">sk_filter_release</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_filter_charge</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_filter</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="n">atomic_add</span><span class="p">(</span><span class="n">sk_filter_len</span><span class="p">(</span><span class="n">fp</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_omem_alloc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Socket reference counting postulates.</span>
<span class="cm"> *</span>
<span class="cm"> * * Each user of socket SHOULD hold a reference count.</span>
<span class="cm"> * * Each access point to socket (an hash table bucket, reference from a list,</span>
<span class="cm"> *   running timer, skb in flight MUST hold a reference count.</span>
<span class="cm"> * * When reference count hits 0, it means it will never increase back.</span>
<span class="cm"> * * When reference count hits 0, it means that no references from</span>
<span class="cm"> *   outside exist to this socket and current process on current CPU</span>
<span class="cm"> *   is last user and may/should destroy this socket.</span>
<span class="cm"> * * sk_free is called from any context: process, BH, IRQ. When</span>
<span class="cm"> *   it is called, socket has no references from outside -&gt; sk_free</span>
<span class="cm"> *   may release descendant resources allocated by the socket, but</span>
<span class="cm"> *   to the time when it is called, socket is NOT referenced by any</span>
<span class="cm"> *   hash tables, lists etc.</span>
<span class="cm"> * * Packets, delivered from outside (from network or from another process)</span>
<span class="cm"> *   and enqueued on receive/error queues SHOULD NOT grab reference count,</span>
<span class="cm"> *   when they sit in queue. Otherwise, packets will leak to hole, when</span>
<span class="cm"> *   socket is looked up by one cpu and unhasing is made by another CPU.</span>
<span class="cm"> *   It is true for udp/raw, netlink (leak to receive and error queues), tcp</span>
<span class="cm"> *   (leak to backlog). Packet socket does all the processing inside</span>
<span class="cm"> *   BR_NETPROTO_LOCK, so that it has not this race condition. UNIX sockets</span>
<span class="cm"> *   use separate SMP lock, so that they are prone too.</span>
<span class="cm"> */</span>

<span class="cm">/* Ungrab socket and destroy it, if it was the last reference. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">))</span>
		<span class="n">sk_free</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sk_receive_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">int</span> <span class="n">nested</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_tx_queue_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_tx_queue_mapping</span> <span class="o">=</span> <span class="n">tx_queue</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_tx_queue_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_tx_queue_mapping</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sk_tx_queue_get</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sk</span> <span class="o">?</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_tx_queue_mapping</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_set_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sk_tx_queue_clear</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="nf">sk_sleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket_wq</span><span class="p">,</span> <span class="n">wait</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* Detach socket from process context.</span>
<span class="cm"> * Announce socket dead, detach it from wait queue and inode.</span>
<span class="cm"> * Note that parent inode held reference count on this struct sock,</span>
<span class="cm"> * we do not release it in this function, because protocol</span>
<span class="cm"> * probably wants some additional cleanups or even continuing</span>
<span class="cm"> * to work with this socket (TCP).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_orphan</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">);</span>
	<span class="n">sk_set_socket</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wq</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_graft</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wq</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">;</span>
	<span class="n">parent</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>
	<span class="n">sk_set_socket</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="n">security_sock_graft</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sock_i_uid</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sock_i_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span>
<span class="nf">__sk_dst_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_dst_cache</span><span class="p">,</span> <span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">||</span>
						       <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">slock</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span>
<span class="nf">sk_dst_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">dst</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_dst_cache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="p">)</span>
		<span class="n">dst_hold</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">dst</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sk_reset_txq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dst_negative_advice</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">ndst</span><span class="p">,</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">__sk_dst_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span> <span class="o">&amp;&amp;</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">negative_advice</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ndst</span> <span class="o">=</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">negative_advice</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ndst</span> <span class="o">!=</span> <span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_dst_cache</span><span class="p">,</span> <span class="n">ndst</span><span class="p">);</span>
			<span class="n">sk_reset_txq</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">__sk_dst_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">old_dst</span><span class="p">;</span>

	<span class="n">sk_tx_queue_clear</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This can be called while sk is owned by the caller only,</span>
<span class="cm">	 * with no state that can be checked in a rcu_dereference_check() cond</span>
<span class="cm">	 */</span>
	<span class="n">old_dst</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_dst_cache</span><span class="p">);</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_dst_cache</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
	<span class="n">dst_release</span><span class="p">(</span><span class="n">old_dst</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">sk_dst_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_dst_lock</span><span class="p">);</span>
	<span class="n">__sk_dst_set</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_dst_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">__sk_dst_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__sk_dst_set</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">sk_dst_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_dst_lock</span><span class="p">);</span>
	<span class="n">__sk_dst_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_dst_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">__sk_dst_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cookie</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">sk_dst_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cookie</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sk_can_gso</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">net_gso_ok</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_route_caps</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_gso_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sk_setup_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_nocaps_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">netdev_features_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_route_nocaps</span> <span class="o">|=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_route_caps</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_do_copy_data_nocache</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					   <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">copy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">__wsum</span> <span class="n">csum</span> <span class="o">=</span> <span class="n">csum_and_copy_from_user</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">csum_block_add</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">,</span> <span class="n">csum</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_route_caps</span> <span class="o">&amp;</span> <span class="n">NETIF_F_NOCACHE_COPY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">__copy_from_user_nocache</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">copy</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">copy</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_add_data_nocache</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">copy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">skb_do_copy_data_nocache</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">copy</span><span class="p">),</span>
				       <span class="n">copy</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">__skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_copy_to_page_nocache</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="kt">int</span> <span class="n">copy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">skb_do_copy_data_nocache</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span>
				       <span class="n">copy</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span>	     <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span>	     <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span>	     <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span>   <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
	<span class="n">sk_mem_charge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_copy_to_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="kt">int</span> <span class="n">copy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">__wsum</span> <span class="n">csum</span> <span class="o">=</span> <span class="n">csum_and_copy_from_user</span><span class="p">(</span><span class="n">from</span><span class="p">,</span>
						     <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span>
							    <span class="n">copy</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">csum_block_add</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">,</span> <span class="n">csum</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">copy</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span>	     <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span>	     <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span>	     <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span>   <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
	<span class="n">sk_mem_charge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sk_wmem_alloc_get - returns write allocations</span>
<span class="cm"> * @sk: socket</span>
<span class="cm"> *</span>
<span class="cm"> * Returns sk_wmem_alloc minus initial offset of one</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sk_wmem_alloc_get</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sk_rmem_alloc_get - returns read allocations</span>
<span class="cm"> * @sk: socket</span>
<span class="cm"> *</span>
<span class="cm"> * Returns sk_rmem_alloc</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sk_rmem_alloc_get</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sk_has_allocations - check if allocations are outstanding</span>
<span class="cm"> * @sk: socket</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if socket has write or read allocations</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sk_has_allocations</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sk_wmem_alloc_get</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">||</span> <span class="n">sk_rmem_alloc_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wq_has_sleeper - check if there are any waiting processes</span>
<span class="cm"> * @wq: struct socket_wq</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if socket_wq has waiting processes</span>
<span class="cm"> *</span>
<span class="cm"> * The purpose of the wq_has_sleeper and sock_poll_wait is to wrap the memory</span>
<span class="cm"> * barrier call. They were added due to the race found within the tcp code.</span>
<span class="cm"> *</span>
<span class="cm"> * Consider following tcp code paths:</span>
<span class="cm"> *</span>
<span class="cm"> * CPU1                  CPU2</span>
<span class="cm"> *</span>
<span class="cm"> * sys_select            receive packet</span>
<span class="cm"> *   ...                 ...</span>
<span class="cm"> *   __add_wait_queue    update tp-&gt;rcv_nxt</span>
<span class="cm"> *   ...                 ...</span>
<span class="cm"> *   tp-&gt;rcv_nxt check   sock_def_readable</span>
<span class="cm"> *   ...                 {</span>
<span class="cm"> *   schedule               rcu_read_lock();</span>
<span class="cm"> *                          wq = rcu_dereference(sk-&gt;sk_wq);</span>
<span class="cm"> *                          if (wq &amp;&amp; waitqueue_active(&amp;wq-&gt;wait))</span>
<span class="cm"> *                              wake_up_interruptible(&amp;wq-&gt;wait)</span>
<span class="cm"> *                          ...</span>
<span class="cm"> *                       }</span>
<span class="cm"> *</span>
<span class="cm"> * The race for tcp fires when the __add_wait_queue changes done by CPU1 stay</span>
<span class="cm"> * in its cache, and so does the tp-&gt;rcv_nxt update on CPU2 side.  The CPU1</span>
<span class="cm"> * could then endup calling schedule and sleep forever if there are no more</span>
<span class="cm"> * data on the socket.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">wq_has_sleeper</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We need to be sure we are in sync with the</span>
<span class="cm">	 * add_wait_queue modifications to the wait queue.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This memory barrier is paired in the sock_poll_wait.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">wq</span> <span class="o">&amp;&amp;</span> <span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sock_poll_wait - place memory barrier behind the poll_wait call.</span>
<span class="cm"> * @filp:           file</span>
<span class="cm"> * @wait_address:   socket wait queue</span>
<span class="cm"> * @p:              poll_table</span>
<span class="cm"> *</span>
<span class="cm"> * See the comments in the wq_has_sleeper function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_poll_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
		<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wait_address</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">poll_does_not_wait</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">wait_address</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">poll_wait</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">wait_address</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="cm">/* We need to be sure we are in sync with the</span>
<span class="cm">		 * socket flags modification.</span>
<span class="cm">		 *</span>
<span class="cm">		 * This memory barrier is paired in the wq_has_sleeper.</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Queue a received datagram if it will fit. Stream and sequenced</span>
<span class="cm"> *	protocols can&#39;t normally use this as they need to fit buffers in</span>
<span class="cm"> *	and play with them.</span>
<span class="cm"> *</span>
<span class="cm"> *	Inlined as it&#39;s very short and called for pretty much every</span>
<span class="cm"> *	packet ever received.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_set_owner_w</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_orphan</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">sock_wfree</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We used to take a refcount on sk, but following operation</span>
<span class="cm">	 * is enough to guarantee sk_free() wont free this sock until</span>
<span class="cm">	 * all in-flight packets are completed</span>
<span class="cm">	 */</span>
	<span class="n">atomic_add</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_set_owner_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_orphan</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">sock_rfree</span><span class="p">;</span>
	<span class="n">atomic_add</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">);</span>
	<span class="n">sk_mem_charge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sk_reset_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sk_stop_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sock_queue_rcv_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sock_queue_err_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Recover an error report and clear atomically</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sock_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">sock_wspace</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">amt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">SEND_SHUTDOWN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">amt</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">-</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">amt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">amt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">amt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_wake_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">,</span> <span class="kt">int</span> <span class="n">band</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_FASYNC</span><span class="p">))</span>
		<span class="n">sock_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">band</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define SOCK_MIN_SNDBUF 2048</span>
<span class="cm">/*</span>
<span class="cm"> * Since sk_rmem_alloc sums skb-&gt;truesize, even a small frame might need</span>
<span class="cm"> * sizeof(sk_buff) + MTU + padding, unless net driver perform copybreak</span>
<span class="cm"> */</span>
<span class="cp">#define SOCK_MIN_RCVBUF (2048 + sizeof(struct sk_buff))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_stream_moderate_sndbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">&amp;</span> <span class="n">SOCK_SNDBUF_LOCK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">,</span> <span class="n">SOCK_MIN_SNDBUF</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">sk_stream_alloc_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">sk_stream_alloc_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk_enter_memory_pressure</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">sk_stream_moderate_sndbuf</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Default write policy as shown to user space via poll/select/SIGIO</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sock_writeable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">gfp_t</span> <span class="nf">gfp_any</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">in_softirq</span><span class="p">()</span> <span class="o">?</span> <span class="n">GFP_ATOMIC</span> <span class="o">:</span> <span class="n">GFP_KERNEL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">sock_rcvtimeo</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">bool</span> <span class="n">noblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">noblock</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvtimeo</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">sock_sndtimeo</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">bool</span> <span class="n">noblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">noblock</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndtimeo</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sock_rcvlowat</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">waitall</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">waitall</span> <span class="o">?</span> <span class="n">len</span> <span class="o">:</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvlowat</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="o">?</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Alas, with timeout socket operations are not restartable.</span>
<span class="cm"> * Compare this to poll().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sock_intr_errno</span><span class="p">(</span><span class="kt">long</span> <span class="n">timeo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">timeo</span> <span class="o">==</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span> <span class="o">?</span> <span class="o">-</span><span class="n">ERESTARTSYS</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__sock_recv_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__sock_recv_wifi_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">sock_recv_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span> <span class="n">kt</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_shared_hwtstamps</span> <span class="o">*</span><span class="n">hwtstamps</span> <span class="o">=</span> <span class="n">skb_hwtstamps</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * generate control messages if</span>
<span class="cm">	 * - receive time stamping in software requested (SOCK_RCVTSTAMP</span>
<span class="cm">	 *   or SOCK_TIMESTAMPING_RX_SOFTWARE)</span>
<span class="cm">	 * - software time stamp available and wanted</span>
<span class="cm">	 *   (SOCK_TIMESTAMPING_SOFTWARE)</span>
<span class="cm">	 * - hardware time stamps available and wanted</span>
<span class="cm">	 *   (SOCK_TIMESTAMPING_SYS_HARDWARE or</span>
<span class="cm">	 *   SOCK_TIMESTAMPING_RAW_HARDWARE)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_RCVTSTAMP</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_RX_SOFTWARE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">kt</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&amp;&amp;</span> <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_SOFTWARE</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hwtstamps</span><span class="o">-&gt;</span><span class="n">hwtstamp</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&amp;&amp;</span>
	     <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_RAW_HARDWARE</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hwtstamps</span><span class="o">-&gt;</span><span class="n">syststamp</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&amp;&amp;</span>
	     <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_SYS_HARDWARE</span><span class="p">)))</span>
		<span class="n">__sock_recv_timestamp</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_stamp</span> <span class="o">=</span> <span class="n">kt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WIFI_STATUS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">wifi_acked_valid</span><span class="p">)</span>
		<span class="n">__sock_recv_wifi_status</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__sock_recv_ts_and_drops</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_recv_ts_and_drops</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define FLAGS_TS_OR_DROPS ((1UL &lt;&lt; SOCK_RXQ_OVFL)			| \</span>
<span class="cp">			   (1UL &lt;&lt; SOCK_RCVTSTAMP)			| \</span>
<span class="cp">			   (1UL &lt;&lt; SOCK_TIMESTAMPING_RX_SOFTWARE)	| \</span>
<span class="cp">			   (1UL &lt;&lt; SOCK_TIMESTAMPING_SOFTWARE)		| \</span>
<span class="cp">			   (1UL &lt;&lt; SOCK_TIMESTAMPING_RAW_HARDWARE)	| \</span>
<span class="cp">			   (1UL &lt;&lt; SOCK_TIMESTAMPING_SYS_HARDWARE))</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_TS_OR_DROPS</span><span class="p">)</span>
		<span class="n">__sock_recv_ts_and_drops</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_stamp</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sock_tx_timestamp - checks whether the outgoing packet is to be time stamped</span>
<span class="cm"> * @sk:		socket sending this packet</span>
<span class="cm"> * @tx_flags:	filled with instructions for time stamping</span>
<span class="cm"> *</span>
<span class="cm"> * Currently only depends on SOCK_TIMESTAMPING* flags. Returns error code if</span>
<span class="cm"> * parameters are invalid.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sock_tx_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">tx_flags</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sk_eat_skb - Release a skb if it is no longer needed</span>
<span class="cm"> * @sk: socket to eat this skb from</span>
<span class="cm"> * @skb: socket buffer to eat</span>
<span class="cm"> * @copied_early: flag indicating whether DMA operations copied this data early</span>
<span class="cm"> *</span>
<span class="cm"> * This routine must be called with interrupts disabled or with the socket</span>
<span class="cm"> * locked so that the sk_buff queue operation is ok.</span>
<span class="cm">*/</span>
<span class="cp">#ifdef CONFIG_NET_DMA</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_eat_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">copied_early</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copied_early</span><span class="p">)</span>
		<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_async_wait_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_eat_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">copied_early</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
	<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">sock_net</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">read_pnet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_net</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">sock_net_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_pnet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_net</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Kernel sockets, f.e. rtnl or icmp_socket, are a part of a namespace.</span>
<span class="cm"> * They should not hold a reference to a namespace in order to allow</span>
<span class="cm"> * to stop it.</span>
<span class="cm"> * Sockets after sk_change_net should be released using sk_release_kernel</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_change_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_net</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
	<span class="n">sock_net_set</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">hold_net</span><span class="p">(</span><span class="n">net</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">skb_steal_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">sk</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sock_enable_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sock_get_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sock_get_timestampns</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Enable debug/info messages</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">net_msg_warn</span><span class="p">;</span>
<span class="cp">#define NETDEBUG(fmt, args...) \</span>
<span class="cp">	do { if (net_msg_warn) printk(fmt,##args); } while (0)</span>

<span class="cp">#define LIMIT_NETDEBUG(fmt, args...) \</span>
<span class="cp">	do { if (net_msg_warn &amp;&amp; net_ratelimit()) printk(fmt,##args); } while(0)</span>

<span class="k">extern</span> <span class="n">__u32</span> <span class="n">sysctl_wmem_max</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">__u32</span> <span class="n">sysctl_rmem_max</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sk_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_optmem_max</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">__u32</span> <span class="n">sysctl_wmem_default</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">__u32</span> <span class="n">sysctl_rmem_default</span><span class="p">;</span>

<span class="cp">#endif	</span><span class="cm">/* _SOCK_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
