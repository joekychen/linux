<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › xfrm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfrm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _NET_XFRM_H</span>
<span class="cp">#define _NET_XFRM_H</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/xfrm.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/pfkeyv2.h&gt;</span>
<span class="cp">#include &lt;linux/ipsec.h&gt;</span>
<span class="cp">#include &lt;linux/in6.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/dst.h&gt;</span>
<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &lt;net/route.h&gt;</span>
<span class="cp">#include &lt;net/ipv6.h&gt;</span>
<span class="cp">#include &lt;net/ip6_fib.h&gt;</span>
<span class="cp">#include &lt;net/flow.h&gt;</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>

<span class="cp">#ifdef CONFIG_XFRM_STATISTICS</span>
<span class="cp">#include &lt;net/snmp.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#define XFRM_PROTO_ESP		50</span>
<span class="cp">#define XFRM_PROTO_AH		51</span>
<span class="cp">#define XFRM_PROTO_COMP		108</span>
<span class="cp">#define XFRM_PROTO_IPIP		4</span>
<span class="cp">#define XFRM_PROTO_IPV6		41</span>
<span class="cp">#define XFRM_PROTO_ROUTING	IPPROTO_ROUTING</span>
<span class="cp">#define XFRM_PROTO_DSTOPTS	IPPROTO_DSTOPTS</span>

<span class="cp">#define XFRM_ALIGN4(len)	(((len) + 3) &amp; ~3)</span>
<span class="cp">#define XFRM_ALIGN8(len)	(((len) + 7) &amp; ~7)</span>
<span class="cp">#define MODULE_ALIAS_XFRM_MODE(family, encap) \</span>
<span class="cp">	MODULE_ALIAS(&quot;xfrm-mode-&quot; __stringify(family) &quot;-&quot; __stringify(encap))</span>
<span class="cp">#define MODULE_ALIAS_XFRM_TYPE(family, proto) \</span>
<span class="cp">	MODULE_ALIAS(&quot;xfrm-type-&quot; __stringify(family) &quot;-&quot; __stringify(proto))</span>

<span class="cp">#ifdef CONFIG_XFRM_STATISTICS</span>
<span class="cp">#define XFRM_INC_STATS(net, field)	SNMP_INC_STATS((net)-&gt;mib.xfrm_statistics, field)</span>
<span class="cp">#define XFRM_INC_STATS_BH(net, field)	SNMP_INC_STATS_BH((net)-&gt;mib.xfrm_statistics, field)</span>
<span class="cp">#define XFRM_INC_STATS_USER(net, field)	SNMP_INC_STATS_USER((net)-mib.xfrm_statistics, field)</span>
<span class="cp">#else</span>
<span class="cp">#define XFRM_INC_STATS(net, field)	((void)(net))</span>
<span class="cp">#define XFRM_INC_STATS_BH(net, field)	((void)(net))</span>
<span class="cp">#define XFRM_INC_STATS_USER(net, field)	((void)(net))</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="n">xfrm_cfg_mutex</span><span class="p">;</span>

<span class="cm">/* Organization of SPD aka &quot;XFRM rules&quot;</span>
<span class="cm">   ------------------------------------</span>

<span class="cm">   Basic objects:</span>
<span class="cm">   - policy rule, struct xfrm_policy (=SPD entry)</span>
<span class="cm">   - bundle of transformations, struct dst_entry == struct xfrm_dst (=SA bundle)</span>
<span class="cm">   - instance of a transformer, struct xfrm_state (=SA)</span>
<span class="cm">   - template to clone xfrm_state, struct xfrm_tmpl</span>

<span class="cm">   SPD is plain linear list of xfrm_policy rules, ordered by priority.</span>
<span class="cm">   (To be compatible with existing pfkeyv2 implementations,</span>
<span class="cm">   many rules with priority of 0x7fffffff are allowed to exist and</span>
<span class="cm">   such rules are ordered in an unpredictable way, thanks to bsd folks.)</span>

<span class="cm">   Lookup is plain linear search until the first match with selector.</span>

<span class="cm">   If &quot;action&quot; is &quot;block&quot;, then we prohibit the flow, otherwise:</span>
<span class="cm">   if &quot;xfrms_nr&quot; is zero, the flow passes untransformed. Otherwise,</span>
<span class="cm">   policy entry has list of up to XFRM_MAX_DEPTH transformations,</span>
<span class="cm">   described by templates xfrm_tmpl. Each template is resolved</span>
<span class="cm">   to a complete xfrm_state (see below) and we pack bundle of transformations</span>
<span class="cm">   to a dst_entry returned to requestor.</span>

<span class="cm">   dst -. xfrm  .-&gt; xfrm_state #1</span>
<span class="cm">    |---. child .-&gt; dst -. xfrm .-&gt; xfrm_state #2</span>
<span class="cm">                     |---. child .-&gt; dst -. xfrm .-&gt; xfrm_state #3</span>
<span class="cm">                                      |---. child .-&gt; NULL</span>

<span class="cm">   Bundles are cached at xrfm_policy struct (field -&gt;bundles).</span>


<span class="cm">   Resolution of xrfm_tmpl</span>
<span class="cm">   -----------------------</span>
<span class="cm">   Template contains:</span>
<span class="cm">   1. -&gt;mode		Mode: transport or tunnel</span>
<span class="cm">   2. -&gt;id.proto	Protocol: AH/ESP/IPCOMP</span>
<span class="cm">   3. -&gt;id.daddr	Remote tunnel endpoint, ignored for transport mode.</span>
<span class="cm">      Q: allow to resolve security gateway?</span>
<span class="cm">   4. -&gt;id.spi          If not zero, static SPI.</span>
<span class="cm">   5. -&gt;saddr		Local tunnel endpoint, ignored for transport mode.</span>
<span class="cm">   6. -&gt;algos		List of allowed algos. Plain bitmask now.</span>
<span class="cm">      Q: ealgos, aalgos, calgos. What a mess...</span>
<span class="cm">   7. -&gt;share		Sharing mode.</span>
<span class="cm">      Q: how to implement private sharing mode? To add struct sock* to</span>
<span class="cm">      flow id?</span>

<span class="cm">   Having this template we search through SAD searching for entries</span>
<span class="cm">   with appropriate mode/proto/algo, permitted by selector.</span>
<span class="cm">   If no appropriate entry found, it is requested from key manager.</span>

<span class="cm">   PROBLEMS:</span>
<span class="cm">   Q: How to find all the bundles referring to a physical path for</span>
<span class="cm">      PMTU discovery? Seems, dst should contain list of all parents...</span>
<span class="cm">      and enter to infinite locking hierarchy disaster.</span>
<span class="cm">      No! It is easier, we will not search for them, let them find us.</span>
<span class="cm">      We add genid to each dst plus pointer to genid of raw IP route,</span>
<span class="cm">      pmtu disc will update pmtu on raw IP route and increase its genid.</span>
<span class="cm">      dst_check() will see this for top level and trigger resyncing</span>
<span class="cm">      metrics. Plus, it will be made via sk-&gt;sk_dst_cache. Solved.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">xfrm_state_walk</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">all</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">state</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u8</span>		<span class="n">dying</span><span class="p">;</span>
		<span class="n">u8</span>		<span class="n">proto</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="n">u32</span>			<span class="n">seq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Full description of state of transformer. */</span>
<span class="k">struct</span> <span class="n">xfrm_state</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_NET_NS</span>
	<span class="k">struct</span> <span class="n">net</span>		<span class="o">*</span><span class="n">xs_net</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">gclist</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">bydst</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">bysrc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">byspi</span><span class="p">;</span>

	<span class="n">atomic_t</span>		<span class="n">refcnt</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">xfrm_id</span>		<span class="n">id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_selector</span>	<span class="n">sel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_mark</span>	<span class="n">mark</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">tfcpad</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">genid</span><span class="p">;</span>

	<span class="cm">/* Key manager bits */</span>
	<span class="k">struct</span> <span class="n">xfrm_state_walk</span>	<span class="n">km</span><span class="p">;</span>

	<span class="cm">/* Parameters of this state. */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u32</span>		<span class="n">reqid</span><span class="p">;</span>
		<span class="n">u8</span>		<span class="n">mode</span><span class="p">;</span>
		<span class="n">u8</span>		<span class="n">replay_window</span><span class="p">;</span>
		<span class="n">u8</span>		<span class="n">aalgo</span><span class="p">,</span> <span class="n">ealgo</span><span class="p">,</span> <span class="n">calgo</span><span class="p">;</span>
		<span class="n">u8</span>		<span class="n">flags</span><span class="p">;</span>
		<span class="n">u16</span>		<span class="n">family</span><span class="p">;</span>
		<span class="n">xfrm_address_t</span>	<span class="n">saddr</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">header_len</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">trailer_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">props</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">xfrm_lifetime_cfg</span> <span class="n">lft</span><span class="p">;</span>

	<span class="cm">/* Data for transformer */</span>
	<span class="k">struct</span> <span class="n">xfrm_algo_auth</span>	<span class="o">*</span><span class="n">aalg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_algo</span>	<span class="o">*</span><span class="n">ealg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_algo</span>	<span class="o">*</span><span class="n">calg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_algo_aead</span>	<span class="o">*</span><span class="n">aead</span><span class="p">;</span>

	<span class="cm">/* Data for encapsulator */</span>
	<span class="k">struct</span> <span class="n">xfrm_encap_tmpl</span>	<span class="o">*</span><span class="n">encap</span><span class="p">;</span>

	<span class="cm">/* Data for care-of address */</span>
	<span class="n">xfrm_address_t</span>	<span class="o">*</span><span class="n">coaddr</span><span class="p">;</span>

	<span class="cm">/* IPComp needs an IPIP tunnel for handling uncompressed packets */</span>
	<span class="k">struct</span> <span class="n">xfrm_state</span>	<span class="o">*</span><span class="n">tunnel</span><span class="p">;</span>

	<span class="cm">/* If a tunnel, number of users + 1 */</span>
	<span class="n">atomic_t</span>		<span class="n">tunnel_users</span><span class="p">;</span>

	<span class="cm">/* State for replay detection */</span>
	<span class="k">struct</span> <span class="n">xfrm_replay_state</span> <span class="n">replay</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_replay_state_esn</span> <span class="o">*</span><span class="n">replay_esn</span><span class="p">;</span>

	<span class="cm">/* Replay detection state at the time we sent the last notification */</span>
	<span class="k">struct</span> <span class="n">xfrm_replay_state</span> <span class="n">preplay</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_replay_state_esn</span> <span class="o">*</span><span class="n">preplay_esn</span><span class="p">;</span>

	<span class="cm">/* The functions for replay detection. */</span>
	<span class="k">struct</span> <span class="n">xfrm_replay</span>	<span class="o">*</span><span class="n">repl</span><span class="p">;</span>

	<span class="cm">/* internal flag that only holds state for delayed aevent at the</span>
<span class="cm">	 * moment</span>
<span class="cm">	*/</span>
	<span class="n">u32</span>			<span class="n">xflags</span><span class="p">;</span>

	<span class="cm">/* Replay detection notification settings */</span>
	<span class="n">u32</span>			<span class="n">replay_maxage</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">replay_maxdiff</span><span class="p">;</span>

	<span class="cm">/* Replay detection notification timer */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">rtimer</span><span class="p">;</span>

	<span class="cm">/* Statistics */</span>
	<span class="k">struct</span> <span class="n">xfrm_stats</span>	<span class="n">stats</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">xfrm_lifetime_cur</span> <span class="n">curlft</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_hrtimer</span>	<span class="n">mtimer</span><span class="p">;</span>

	<span class="cm">/* Last used time */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">lastused</span><span class="p">;</span>

	<span class="cm">/* Reference to data common to all the instances of this</span>
<span class="cm">	 * transformer. */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_type</span>	<span class="o">*</span><span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_mode</span>	<span class="o">*</span><span class="n">inner_mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_mode</span>	<span class="o">*</span><span class="n">inner_mode_iaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_mode</span>	<span class="o">*</span><span class="n">outer_mode</span><span class="p">;</span>

	<span class="cm">/* Security context */</span>
	<span class="k">struct</span> <span class="n">xfrm_sec_ctx</span>	<span class="o">*</span><span class="n">security</span><span class="p">;</span>

	<span class="cm">/* Private data of this transformer, format is opaque,</span>
<span class="cm">	 * interpreted by xfrm_type methods. */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">xs_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">read_pnet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">xs_net</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* xflags - make enum if more show up */</span>
<span class="cp">#define XFRM_TIME_DEFER	1</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">XFRM_STATE_VOID</span><span class="p">,</span>
	<span class="n">XFRM_STATE_ACQ</span><span class="p">,</span>
	<span class="n">XFRM_STATE_VALID</span><span class="p">,</span>
	<span class="n">XFRM_STATE_ERROR</span><span class="p">,</span>
	<span class="n">XFRM_STATE_EXPIRED</span><span class="p">,</span>
	<span class="n">XFRM_STATE_DEAD</span>
<span class="p">};</span>

<span class="cm">/* callback structure passed from either netlink or pfkey */</span>
<span class="k">struct</span> <span class="n">km_event</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">hard</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">proto</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">byid</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">aevent</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">type</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">u32</span>	<span class="n">seq</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">pid</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xfrm_replay</span> <span class="p">{</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">advance</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">net_seq</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">check</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			 <span class="n">__be32</span> <span class="n">net_seq</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">notify</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">overflow</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">net_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xfrm_type</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xfrm_dst</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xfrm_policy_afinfo</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">family</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dst_ops</span>		<span class="o">*</span><span class="n">dst_ops</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">garbage_collect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dst_entry</span>	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">dst_lookup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tos</span><span class="p">,</span>
					       <span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span>
					       <span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">daddr</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">get_saddr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">daddr</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">decode_session</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">reverse</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">get_tos</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">init_path</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_dst</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">nfheader_len</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">fill_dst</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_dst</span> <span class="o">*</span><span class="n">xdst</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					    <span class="k">const</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dst_entry</span>	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">blackhole_route</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">orig</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_policy_register_afinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_policy_afinfo</span> <span class="o">*</span><span class="n">afinfo</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_policy_unregister_afinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_policy_afinfo</span> <span class="o">*</span><span class="n">afinfo</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">km_policy_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">xp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">km_event</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">km_state_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">km_event</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">xfrm_tmpl</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">km_query</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_tmpl</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">km_state_expired</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hard</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__xfrm_state_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">xfrm_state_afinfo</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">family</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">proto</span><span class="p">;</span>
	<span class="n">__be16</span>			<span class="n">eth_proto</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span>		<span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_type</span>	<span class="o">*</span><span class="n">type_map</span><span class="p">[</span><span class="n">IPPROTO_MAX</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">xfrm_mode</span>	<span class="o">*</span><span class="n">mode_map</span><span class="p">[</span><span class="n">XFRM_MODE_MAX</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">init_flags</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">init_tempsel</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_selector</span> <span class="o">*</span><span class="n">sel</span><span class="p">,</span>
						<span class="k">const</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">init_temprop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
						<span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_tmpl</span> <span class="o">*</span><span class="n">tmpl</span><span class="p">,</span>
						<span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span>
						<span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">saddr</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">tmpl_sort</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_tmpl</span> <span class="o">**</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_tmpl</span> <span class="o">**</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">state_sort</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">**</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">**</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">output</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">output_finish</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">extract_input</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">extract_output</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">transport_finish</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						    <span class="kt">int</span> <span class="n">async</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_state_register_afinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state_afinfo</span> <span class="o">*</span><span class="n">afinfo</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_state_unregister_afinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state_afinfo</span> <span class="o">*</span><span class="n">afinfo</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_state_delete_tunnel</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">xfrm_type</span> <span class="p">{</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">description</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span>		<span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">proto</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define XFRM_TYPE_NON_FRAGMENT	1</span>
<span class="cp">#define XFRM_TYPE_REPLAY_PROT	2</span>
<span class="cp">#define XFRM_TYPE_LOCAL_COADDR	4</span>
<span class="cp">#define XFRM_TYPE_REMOTE_COADDR	8</span>

	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">init_state</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">input</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">output</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">pskb</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">reject</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">hdr_offset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">**</span><span class="p">);</span>
	<span class="cm">/* Estimate maximal size of result of transformation of a dgram */</span>
	<span class="n">u32</span>			<span class="p">(</span><span class="o">*</span><span class="n">get_mtu</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_register_type</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_unregister_type</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">xfrm_mode</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Remove encapsulation header.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The IP header will be moved over the top of the encapsulation</span>
<span class="cm">	 * header.</span>
<span class="cm">	 *</span>
<span class="cm">	 * On entry, the transport header shall point to where the IP header</span>
<span class="cm">	 * should be and the network header shall be set to where the IP</span>
<span class="cm">	 * header currently is.  skb-&gt;data shall point to the start of the</span>
<span class="cm">	 * payload.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">input2</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is the actual input entry point.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For transport mode and equivalent this would be identical to</span>
<span class="cm">	 * input2 (which does not need to be set).  While tunnel mode</span>
<span class="cm">	 * and equivalent would set this to the tunnel encapsulation function</span>
<span class="cm">	 * xfrm4_prepare_input that would in turn call input2.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">input</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add encapsulation header.</span>
<span class="cm">	 *</span>
<span class="cm">	 * On exit, the transport header will be set to the start of the</span>
<span class="cm">	 * encapsulation header to be filled in by x-&gt;type-&gt;output and</span>
<span class="cm">	 * the mac header will be set to the nextheader (protocol for</span>
<span class="cm">	 * IPv4) field of the extension header directly preceding the</span>
<span class="cm">	 * encapsulation header, or in its absence, that of the top IP</span>
<span class="cm">	 * header.  The value of the network header will always point</span>
<span class="cm">	 * to the top IP header while skb-&gt;data will point to the payload.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">output2</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is the actual output entry point.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For transport mode and equivalent this would be identical to</span>
<span class="cm">	 * output2 (which does not need to be set).  While tunnel mode</span>
<span class="cm">	 * and equivalent would set this to a tunnel encapsulation function</span>
<span class="cm">	 * (xfrm4_prepare_output or xfrm6_prepare_output) that would in turn</span>
<span class="cm">	 * call output2.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">output</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">xfrm_state_afinfo</span> <span class="o">*</span><span class="n">afinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">encap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Flags for xfrm_mode. */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">XFRM_MODE_FLAG_TUNNEL</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_register_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_unregister_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_af2proto</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">return</span> <span class="n">IPPROTO_IPIP</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="k">return</span> <span class="n">IPPROTO_IPV6</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">xfrm_mode</span> <span class="o">*</span><span class="nf">xfrm_ip2inner_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ipproto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ipproto</span> <span class="o">==</span> <span class="n">IPPROTO_IPIP</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">ipproto</span> <span class="o">==</span> <span class="n">IPPROTO_IPV6</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">family</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">inner_mode</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">inner_mode_iaf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">xfrm_tmpl</span> <span class="p">{</span>
<span class="cm">/* id in template is interpreted as:</span>
<span class="cm"> * daddr - destination of tunnel, may be zero for transport mode.</span>
<span class="cm"> * spi   - zero to acquire spi. Not zero if spi is static, then</span>
<span class="cm"> *	   daddr must be fixed too.</span>
<span class="cm"> * proto - AH/ESP/IPCOMP</span>
<span class="cm"> */</span>
	<span class="k">struct</span> <span class="n">xfrm_id</span>		<span class="n">id</span><span class="p">;</span>

<span class="cm">/* Source address of tunnel. Ignored, if it is not a tunnel. */</span>
	<span class="n">xfrm_address_t</span>		<span class="n">saddr</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">encap_family</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">reqid</span><span class="p">;</span>

<span class="cm">/* Mode: transport, tunnel etc. */</span>
	<span class="n">u8</span>			<span class="n">mode</span><span class="p">;</span>

<span class="cm">/* Sharing mode: unique, this session only, this user only etc. */</span>
	<span class="n">u8</span>			<span class="n">share</span><span class="p">;</span>

<span class="cm">/* May skip this transfomration if no SA is found */</span>
	<span class="n">u8</span>			<span class="n">optional</span><span class="p">;</span>

<span class="cm">/* Skip aalgos/ealgos/calgos checks. */</span>
	<span class="n">u8</span>			<span class="n">allalgs</span><span class="p">;</span>

<span class="cm">/* Bit mask of algos allowed for acquisition */</span>
	<span class="n">u32</span>			<span class="n">aalgos</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ealgos</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">calgos</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define XFRM_MAX_DEPTH		6</span>

<span class="k">struct</span> <span class="n">xfrm_policy_walk_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">all</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">dead</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xfrm_policy_walk</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfrm_policy_walk_entry</span> <span class="n">walk</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">seq</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_NET_NS</span>
	<span class="k">struct</span> <span class="n">net</span>		<span class="o">*</span><span class="n">xp_net</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">bydst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">byidx</span><span class="p">;</span>

	<span class="cm">/* This lock only affects elements except for entry. */</span>
	<span class="n">rwlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">refcnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">timer</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">flow_cache_object</span> <span class="n">flo</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">genid</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">priority</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_mark</span>	<span class="n">mark</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_selector</span>	<span class="n">selector</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_lifetime_cfg</span> <span class="n">lft</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_lifetime_cur</span> <span class="n">curlft</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_policy_walk_entry</span> <span class="n">walk</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">type</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">action</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">xfrm_nr</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">family</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_sec_ctx</span>	<span class="o">*</span><span class="n">security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_tmpl</span>       	<span class="n">xfrm_vec</span><span class="p">[</span><span class="n">XFRM_MAX_DEPTH</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">xp_net</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">xp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">read_pnet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xp</span><span class="o">-&gt;</span><span class="n">xp_net</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">xfrm_kmaddress</span> <span class="p">{</span>
	<span class="n">xfrm_address_t</span>          <span class="n">local</span><span class="p">;</span>
	<span class="n">xfrm_address_t</span>          <span class="n">remote</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">reserved</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">family</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xfrm_migrate</span> <span class="p">{</span>
	<span class="n">xfrm_address_t</span>		<span class="n">old_daddr</span><span class="p">;</span>
	<span class="n">xfrm_address_t</span>		<span class="n">old_saddr</span><span class="p">;</span>
	<span class="n">xfrm_address_t</span>		<span class="n">new_daddr</span><span class="p">;</span>
	<span class="n">xfrm_address_t</span>		<span class="n">new_saddr</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">proto</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">mode</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">reserved</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">reqid</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">old_family</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">new_family</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define XFRM_KM_TIMEOUT                30</span>
<span class="cm">/* which seqno */</span>
<span class="cp">#define XFRM_REPLAY_SEQ		1</span>
<span class="cp">#define XFRM_REPLAY_OSEQ	2</span>
<span class="cp">#define XFRM_REPLAY_SEQ_MASK	3</span>
<span class="cm">/* what happened */</span>
<span class="cp">#define XFRM_REPLAY_UPDATE	XFRM_AE_CR</span>
<span class="cp">#define XFRM_REPLAY_TIMEOUT	XFRM_AE_CE</span>

<span class="cm">/* default aevent timeout in units of 100ms */</span>
<span class="cp">#define XFRM_AE_ETIME			10</span>
<span class="cm">/* Async Event timer multiplier */</span>
<span class="cp">#define XFRM_AE_ETH_M			10</span>
<span class="cm">/* default seq threshold size */</span>
<span class="cp">#define XFRM_AE_SEQT_SIZE		2</span>

<span class="k">struct</span> <span class="n">xfrm_mgr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">notify</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">km_event</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">acquire</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_tmpl</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">xp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfrm_policy</span>	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">compile_policy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opt</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dir</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">new_mapping</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">ipaddr</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">sport</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">notify_policy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">km_event</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">report</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u8</span> <span class="n">proto</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_selector</span> <span class="o">*</span><span class="n">sel</span><span class="p">,</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">migrate</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_selector</span> <span class="o">*</span><span class="n">sel</span><span class="p">,</span>
					   <span class="n">u8</span> <span class="n">dir</span><span class="p">,</span> <span class="n">u8</span> <span class="n">type</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_migrate</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">num_bundles</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_kmaddress</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_register_km</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_mgr</span> <span class="o">*</span><span class="n">km</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_unregister_km</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_mgr</span> <span class="o">*</span><span class="n">km</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is used for the duration where packets are being</span>
<span class="cm"> * transformed by IPsec.  As soon as the packet leaves IPsec the</span>
<span class="cm"> * area beyond the generic IP part may be overwritten.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xfrm_skb_cb</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inet_skb_parm</span> <span class="n">h4</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">inet6_skb_parm</span> <span class="n">h6</span><span class="p">;</span>
        <span class="p">}</span> <span class="n">header</span><span class="p">;</span>

        <span class="cm">/* Sequence number for replay protection. */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u32</span> <span class="n">low</span><span class="p">;</span>
			<span class="n">__u32</span> <span class="n">hi</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">output</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__be32</span> <span class="n">low</span><span class="p">;</span>
			<span class="n">__be32</span> <span class="n">hi</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">input</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">seq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define XFRM_SKB_CB(__skb) ((struct xfrm_skb_cb *)&amp;((__skb)-&gt;cb[0]))</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is used by the afinfo prepare_input/prepare_output functions</span>
<span class="cm"> * to transmit header information to the mode input/output functions.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xfrm_mode_skb_cb</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inet_skb_parm</span> <span class="n">h4</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">inet6_skb_parm</span> <span class="n">h6</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">header</span><span class="p">;</span>

	<span class="cm">/* Copied from header for IPv4, always set to zero and DF for IPv6. */</span>
	<span class="n">__be16</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">frag_off</span><span class="p">;</span>

	<span class="cm">/* IP header length (excluding options or extension headers). */</span>
	<span class="n">u8</span> <span class="n">ihl</span><span class="p">;</span>

	<span class="cm">/* TOS for IPv4, class for IPv6. */</span>
	<span class="n">u8</span> <span class="n">tos</span><span class="p">;</span>

	<span class="cm">/* TTL for IPv4, hop limitfor IPv6. */</span>
	<span class="n">u8</span> <span class="n">ttl</span><span class="p">;</span>

	<span class="cm">/* Protocol for IPv4, NH for IPv6. */</span>
	<span class="n">u8</span> <span class="n">protocol</span><span class="p">;</span>

	<span class="cm">/* Option length for IPv4, zero for IPv6. */</span>
	<span class="n">u8</span> <span class="n">optlen</span><span class="p">;</span>

	<span class="cm">/* Used by IPv6 only, zero for IPv4. */</span>
	<span class="n">u8</span> <span class="n">flow_lbl</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define XFRM_MODE_SKB_CB(__skb) ((struct xfrm_mode_skb_cb *)&amp;((__skb)-&gt;cb[0]))</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is used by the input processing to locate the SPI and</span>
<span class="cm"> * related information.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xfrm_spi_skb_cb</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inet_skb_parm</span> <span class="n">h4</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">inet6_skb_parm</span> <span class="n">h6</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">header</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">daddroff</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define XFRM_SPI_SKB_CB(__skb) ((struct xfrm_spi_skb_cb *)&amp;((__skb)-&gt;cb[0]))</span>

<span class="cm">/* Audit Information */</span>
<span class="k">struct</span> <span class="n">xfrm_audit</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">secid</span><span class="p">;</span>
	<span class="n">uid_t</span>	<span class="n">loginuid</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">sessionid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_AUDITSYSCALL</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="nf">xfrm_audit_start</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">audit_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">audit_enabled</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">audit_buf</span> <span class="o">=</span> <span class="n">audit_log_start</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">audit_context</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span>
				    <span class="n">AUDIT_MAC_IPSEC_EVENT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">audit_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">audit_log_format</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="s">&quot;op=%s&quot;</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">audit_buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_audit_helper_usrinfo</span><span class="p">(</span><span class="n">uid_t</span> <span class="n">auid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ses</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">audit_buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">secctx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">secctx_len</span><span class="p">;</span>

	<span class="n">audit_log_format</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="s">&quot; auid=%u ses=%u&quot;</span><span class="p">,</span> <span class="n">auid</span><span class="p">,</span> <span class="n">ses</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">secid</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">security_secid_to_secctx</span><span class="p">(</span><span class="n">secid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secctx_len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">audit_log_format</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">,</span> <span class="s">&quot; subj=%s&quot;</span><span class="p">,</span> <span class="n">secctx</span><span class="p">);</span>
		<span class="n">security_release_secctx</span><span class="p">(</span><span class="n">secctx</span><span class="p">,</span> <span class="n">secctx_len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">audit_log_task_context</span><span class="p">(</span><span class="n">audit_buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_audit_policy_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">xp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">auid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ses</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_audit_policy_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">xp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">auid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ses</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_audit_state_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">auid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ses</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_audit_state_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">auid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ses</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_audit_state_replay_overflow</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_audit_state_replay</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">net_seq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_audit_state_notfound_simple</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u16</span> <span class="n">family</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_audit_state_notfound</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
				      <span class="n">__be32</span> <span class="n">net_spi</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">net_seq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_audit_state_icvfail</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u8</span> <span class="n">proto</span><span class="p">);</span>
<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_audit_policy_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">xp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">auid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ses</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_audit_policy_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">xp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">auid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ses</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_audit_state_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">auid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ses</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_audit_state_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">auid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ses</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_audit_state_replay_overflow</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_audit_state_replay</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">net_seq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_audit_state_notfound_simple</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="n">u16</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_audit_state_notfound</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u16</span> <span class="n">family</span><span class="p">,</span>
				      <span class="n">__be32</span> <span class="n">net_spi</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">net_seq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_audit_state_icvfail</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u8</span> <span class="n">proto</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_AUDITSYSCALL */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_pol_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">policy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_policy_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_pol_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">))</span>
		<span class="n">xfrm_policy_destroy</span><span class="p">(</span><span class="n">policy</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_pols_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">**</span><span class="n">pols</span><span class="p">,</span> <span class="kt">int</span> <span class="n">npols</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">npols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
		<span class="n">xfrm_pol_put</span><span class="p">(</span><span class="n">pols</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__xfrm_state_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__xfrm_state_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_state_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">))</span>
		<span class="n">__xfrm_state_destroy</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_state_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">addr_match</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">token1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">token2</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">prefixlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">a1</span> <span class="o">=</span> <span class="n">token1</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">a2</span> <span class="o">=</span> <span class="n">token2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pdw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pbi</span><span class="p">;</span>

	<span class="n">pdw</span> <span class="o">=</span> <span class="n">prefixlen</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">;</span>	  <span class="cm">/* num of whole u32 in prefix */</span>
	<span class="n">pbi</span> <span class="o">=</span> <span class="n">prefixlen</span> <span class="o">&amp;</span>  <span class="mh">0x1f</span><span class="p">;</span>  <span class="cm">/* num of bits in incomplete u32 in prefix */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdw</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">pdw</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pbi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__be32</span> <span class="n">mask</span><span class="p">;</span>

		<span class="n">mask</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">((</span><span class="mh">0xffffffff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">pbi</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">a1</span><span class="p">[</span><span class="n">pdw</span><span class="p">]</span> <span class="o">^</span> <span class="n">a2</span><span class="p">[</span><span class="n">pdw</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">addr4_match</span><span class="p">(</span><span class="n">__be32</span> <span class="n">a1</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">a2</span><span class="p">,</span> <span class="n">u8</span> <span class="n">prefixlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* C99 6.5.7 (3): u32 &lt;&lt; 32 is undefined behaviour */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prefixlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">((</span><span class="n">a1</span> <span class="o">^</span> <span class="n">a2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">htonl</span><span class="p">(</span><span class="mh">0xFFFFFFFFu</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">prefixlen</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span>
<span class="n">__be16</span> <span class="nf">xfrm_flowi_sport</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">flowi_uli</span> <span class="o">*</span><span class="n">uli</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be16</span> <span class="n">port</span><span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">flowi_proto</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPPROTO_TCP</span>:
	<span class="k">case</span> <span class="n">IPPROTO_UDP</span>:
	<span class="k">case</span> <span class="n">IPPROTO_UDPLITE</span>:
	<span class="k">case</span> <span class="n">IPPROTO_SCTP</span>:
		<span class="n">port</span> <span class="o">=</span> <span class="n">uli</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">.</span><span class="n">sport</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPPROTO_ICMP</span>:
	<span class="k">case</span> <span class="n">IPPROTO_ICMPV6</span>:
		<span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">uli</span><span class="o">-&gt;</span><span class="n">icmpt</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPPROTO_MH</span>:
		<span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">uli</span><span class="o">-&gt;</span><span class="n">mht</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPPROTO_GRE</span>:
		<span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ntohl</span><span class="p">(</span><span class="n">uli</span><span class="o">-&gt;</span><span class="n">gre_key</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/*XXX*/</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">port</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span>
<span class="n">__be16</span> <span class="nf">xfrm_flowi_dport</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">flowi_uli</span> <span class="o">*</span><span class="n">uli</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be16</span> <span class="n">port</span><span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">flowi_proto</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPPROTO_TCP</span>:
	<span class="k">case</span> <span class="n">IPPROTO_UDP</span>:
	<span class="k">case</span> <span class="n">IPPROTO_UDPLITE</span>:
	<span class="k">case</span> <span class="n">IPPROTO_SCTP</span>:
		<span class="n">port</span> <span class="o">=</span> <span class="n">uli</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">.</span><span class="n">dport</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPPROTO_ICMP</span>:
	<span class="k">case</span> <span class="n">IPPROTO_ICMPV6</span>:
		<span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">uli</span><span class="o">-&gt;</span><span class="n">icmpt</span><span class="p">.</span><span class="n">code</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPPROTO_GRE</span>:
		<span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ntohl</span><span class="p">(</span><span class="n">uli</span><span class="o">-&gt;</span><span class="n">gre_key</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/*XXX*/</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">port</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">xfrm_selector_match</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_selector</span> <span class="o">*</span><span class="n">sel</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SECURITY_NETWORK_XFRM</span>
<span class="cm">/*	If neither has a context --&gt; match</span>
<span class="cm"> * 	Otherwise, both must have a context and the sids, doi, alg must match</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">xfrm_sec_ctx_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">s2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="o">!</span><span class="n">s1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">s2</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">s1</span> <span class="o">&amp;&amp;</span> <span class="n">s2</span> <span class="o">&amp;&amp;</span>
		 <span class="p">(</span><span class="n">s1</span><span class="o">-&gt;</span><span class="n">ctx_sid</span> <span class="o">==</span> <span class="n">s2</span><span class="o">-&gt;</span><span class="n">ctx_sid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="p">(</span><span class="n">s1</span><span class="o">-&gt;</span><span class="n">ctx_doi</span> <span class="o">==</span> <span class="n">s2</span><span class="o">-&gt;</span><span class="n">ctx_doi</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="p">(</span><span class="n">s1</span><span class="o">-&gt;</span><span class="n">ctx_alg</span> <span class="o">==</span> <span class="n">s2</span><span class="o">-&gt;</span><span class="n">ctx_alg</span><span class="p">)));</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">xfrm_sec_ctx_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">s2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* A struct encoding bundle of transformations to apply to some set of flow.</span>
<span class="cm"> *</span>
<span class="cm"> * dst-&gt;child points to the next element of bundle.</span>
<span class="cm"> * dst-&gt;xfrm  points to an instanse of transformer.</span>
<span class="cm"> *</span>
<span class="cm"> * Due to unfortunate limitations of current routing cache, which we</span>
<span class="cm"> * have no time to fix, it mirrors struct rtable and bound to the same</span>
<span class="cm"> * routing key, including saddr,daddr. However, we can have many of</span>
<span class="cm"> * bundles differing by session id. All the bundles grow from a parent</span>
<span class="cm"> * policy rule.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xfrm_dst</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dst_entry</span>	<span class="n">dst</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rtable</span>		<span class="n">rt</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rt6_info</span>		<span class="n">rt6</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">route</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flow_cache_object</span> <span class="n">flo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">pols</span><span class="p">[</span><span class="n">XFRM_POLICY_TYPE_MAX</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">num_pols</span><span class="p">,</span> <span class="n">num_xfrms</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_XFRM_SUB_POLICY</span>
	<span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">origin</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_selector</span> <span class="o">*</span><span class="n">partner</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">u32</span> <span class="n">xfrm_genid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">policy_genid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">route_mtu_cached</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">child_mtu_cached</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">route_cookie</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">path_cookie</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_XFRM</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_dst_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_dst</span> <span class="o">*</span><span class="n">xdst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfrm_pols_put</span><span class="p">(</span><span class="n">xdst</span><span class="o">-&gt;</span><span class="n">pols</span><span class="p">,</span> <span class="n">xdst</span><span class="o">-&gt;</span><span class="n">num_pols</span><span class="p">);</span>
	<span class="n">dst_release</span><span class="p">(</span><span class="n">xdst</span><span class="o">-&gt;</span><span class="n">route</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">xdst</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">xfrm</span><span class="p">))</span>
		<span class="n">xfrm_state_put</span><span class="p">(</span><span class="n">xdst</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">xfrm</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_XFRM_SUB_POLICY</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">xdst</span><span class="o">-&gt;</span><span class="n">origin</span><span class="p">);</span>
	<span class="n">xdst</span><span class="o">-&gt;</span><span class="n">origin</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">xdst</span><span class="o">-&gt;</span><span class="n">partner</span><span class="p">);</span>
	<span class="n">xdst</span><span class="o">-&gt;</span><span class="n">partner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_dst_ifdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">sec_path</span> <span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">refcnt</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfrm_state</span>	<span class="o">*</span><span class="n">xvec</span><span class="p">[</span><span class="n">XFRM_MAX_DEPTH</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">secpath_exists</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_XFRM</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sec_path</span> <span class="o">*</span>
<span class="nf">secpath_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">sec_path</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__secpath_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sec_path</span> <span class="o">*</span><span class="n">sp</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">secpath_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sec_path</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">))</span>
		<span class="n">__secpath_destroy</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">sec_path</span> <span class="o">*</span><span class="n">secpath_dup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sec_path</span> <span class="o">*</span><span class="n">src</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">secpath_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_XFRM</span>
	<span class="n">secpath_put</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">xfrm_addr_any</span><span class="p">(</span><span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">return</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">a4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="k">return</span> <span class="n">ipv6_addr_any</span><span class="p">((</span><span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">a6</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">__xfrm4_state_addr_cmp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_tmpl</span> <span class="o">*</span><span class="n">tmpl</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>	<span class="p">(</span><span class="n">tmpl</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">.</span><span class="n">a4</span> <span class="o">&amp;&amp;</span>
		 <span class="n">tmpl</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">.</span><span class="n">a4</span> <span class="o">!=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">saddr</span><span class="p">.</span><span class="n">a4</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">__xfrm6_state_addr_cmp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_tmpl</span> <span class="o">*</span><span class="n">tmpl</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>	<span class="p">(</span><span class="o">!</span><span class="n">ipv6_addr_any</span><span class="p">((</span><span class="k">struct</span> <span class="n">in6_addr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tmpl</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="n">ipv6_addr_cmp</span><span class="p">((</span><span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tmpl</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">saddr</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">xfrm_state_addr_cmp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_tmpl</span> <span class="o">*</span><span class="n">tmpl</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">return</span> <span class="n">__xfrm4_state_addr_cmp</span><span class="p">(</span><span class="n">tmpl</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="k">return</span> <span class="n">__xfrm6_state_addr_cmp</span><span class="p">(</span><span class="n">tmpl</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">!</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_XFRM</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__xfrm_policy_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__xfrm_policy_check2</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reverse</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ndir</span> <span class="o">=</span> <span class="n">dir</span> <span class="o">|</span> <span class="p">(</span><span class="n">reverse</span> <span class="o">?</span> <span class="n">XFRM_POLICY_MASK</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_policy</span><span class="p">[</span><span class="n">XFRM_POLICY_IN</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">__xfrm_policy_check</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ndir</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">);</span>

	<span class="k">return</span>	<span class="p">(</span><span class="o">!</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">xfrm</span><span class="p">.</span><span class="n">policy_count</span><span class="p">[</span><span class="n">dir</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DST_NOPOLICY</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">__xfrm_policy_check</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ndir</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_policy_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__xfrm_policy_check2</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm4_policy_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xfrm_policy_check</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm6_policy_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xfrm_policy_check</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">AF_INET6</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm4_policy_check_reverse</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__xfrm_policy_check2</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm6_policy_check_reverse</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__xfrm_policy_check2</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">AF_INET6</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__xfrm_decode_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reverse</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_decode_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__xfrm_decode_session</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_decode_session_reverse</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__xfrm_decode_session</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__xfrm_route_forward</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_route_forward</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span>	<span class="o">!</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">xfrm</span><span class="p">.</span><span class="n">policy_count</span><span class="p">[</span><span class="n">XFRM_POLICY_OUT</span><span class="p">]</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DST_NOXFRM</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">__xfrm_route_forward</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">family</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm4_route_forward</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xfrm_route_forward</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm6_route_forward</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xfrm_route_forward</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">AF_INET6</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__xfrm_sk_clone_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_sk_clone_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_policy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_policy</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="k">return</span> <span class="n">__xfrm_sk_clone_policy</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_policy_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_sk_free_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_policy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfrm_policy_delete</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_policy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">XFRM_POLICY_MAX</span><span class="p">);</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_policy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_policy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfrm_policy_delete</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_policy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">XFRM_POLICY_MAX</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_policy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_sk_free_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_sk_clone_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm6_route_forward</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>  
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm4_route_forward</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span> 
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm6_policy_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span> 
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> 
<span class="p">}</span> 
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm4_policy_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_policy_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_decode_session_reverse</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm4_policy_check_reverse</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm6_policy_check_reverse</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">__inline__</span>
<span class="n">xfrm_address_t</span> <span class="o">*</span><span class="nf">xfrm_flowi_daddr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">){</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">xfrm_address_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip4</span><span class="p">.</span><span class="n">daddr</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">xfrm_address_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip6</span><span class="p">.</span><span class="n">daddr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span>
<span class="n">xfrm_address_t</span> <span class="o">*</span><span class="nf">xfrm_flowi_saddr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">){</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">xfrm_address_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip4</span><span class="p">.</span><span class="n">saddr</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">xfrm_address_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip6</span><span class="p">.</span><span class="n">saddr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span>
<span class="kt">void</span> <span class="nf">xfrm_flowi_addr_get</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
			 <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">saddr</span><span class="o">-&gt;</span><span class="n">a4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip4</span><span class="p">.</span><span class="n">saddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">saddr</span><span class="o">-&gt;</span><span class="n">a4</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">daddr</span><span class="o">-&gt;</span><span class="n">a4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip4</span><span class="p">.</span><span class="n">daddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">daddr</span><span class="o">-&gt;</span><span class="n">a4</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="p">)</span><span class="n">saddr</span><span class="o">-&gt;</span><span class="n">a6</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip6</span><span class="p">.</span><span class="n">saddr</span><span class="p">;</span>
		<span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="p">)</span><span class="n">daddr</span><span class="o">-&gt;</span><span class="n">a6</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip6</span><span class="p">.</span><span class="n">daddr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span>
<span class="nf">__xfrm4_state_addr_check</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
			 <span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span> <span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">saddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">daddr</span><span class="o">-&gt;</span><span class="n">a4</span> <span class="o">==</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">daddr</span><span class="p">.</span><span class="n">a4</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">saddr</span><span class="o">-&gt;</span><span class="n">a4</span> <span class="o">==</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">saddr</span><span class="p">.</span><span class="n">a4</span> <span class="o">||</span> <span class="o">!</span><span class="n">saddr</span><span class="o">-&gt;</span><span class="n">a4</span> <span class="o">||</span> <span class="o">!</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">saddr</span><span class="p">.</span><span class="n">a4</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span>
<span class="nf">__xfrm6_state_addr_check</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
			 <span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span> <span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">saddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ipv6_addr_cmp</span><span class="p">((</span><span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="p">)</span><span class="n">daddr</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">daddr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">ipv6_addr_cmp</span><span class="p">((</span><span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="p">)</span><span class="n">saddr</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">saddr</span><span class="p">)</span><span class="o">||</span> 
	     <span class="n">ipv6_addr_any</span><span class="p">((</span><span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="p">)</span><span class="n">saddr</span><span class="p">)</span> <span class="o">||</span> 
	     <span class="n">ipv6_addr_any</span><span class="p">((</span><span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">props</span><span class="p">.</span><span class="n">saddr</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span>
<span class="nf">xfrm_state_addr_check</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
		      <span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span> <span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">return</span> <span class="n">__xfrm4_state_addr_check</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">saddr</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="k">return</span> <span class="n">__xfrm6_state_addr_check</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">saddr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span>
<span class="nf">xfrm_state_addr_flow_check</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">return</span> <span class="n">__xfrm4_state_addr_check</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
						<span class="p">(</span><span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip4</span><span class="p">.</span><span class="n">daddr</span><span class="p">,</span>
						<span class="p">(</span><span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip4</span><span class="p">.</span><span class="n">saddr</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="k">return</span> <span class="n">__xfrm6_state_addr_check</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
						<span class="p">(</span><span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip6</span><span class="p">.</span><span class="n">daddr</span><span class="p">,</span>
						<span class="p">(</span><span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip6</span><span class="p">.</span><span class="n">saddr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_state_kern</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">tunnel_users</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_id_proto_match</span><span class="p">(</span><span class="n">u8</span> <span class="n">proto</span><span class="p">,</span> <span class="n">u8</span> <span class="n">userproto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">userproto</span> <span class="o">||</span> <span class="n">proto</span> <span class="o">==</span> <span class="n">userproto</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">userproto</span> <span class="o">==</span> <span class="n">IPSEC_PROTO_ANY</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">proto</span> <span class="o">==</span> <span class="n">IPPROTO_AH</span> <span class="o">||</span>
						  <span class="n">proto</span> <span class="o">==</span> <span class="n">IPPROTO_ESP</span> <span class="o">||</span>
						  <span class="n">proto</span> <span class="o">==</span> <span class="n">IPPROTO_COMP</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfrm algorithm information</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xfrm_algo_aead_info</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">icv_truncbits</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xfrm_algo_auth_info</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">icv_truncbits</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">icv_fullbits</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xfrm_algo_encr_info</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">blockbits</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">defkeybits</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xfrm_algo_comp_info</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">threshold</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xfrm_algo_desc</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">compat</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">available</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xfrm_algo_aead_info</span> <span class="n">aead</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">xfrm_algo_auth_info</span> <span class="n">auth</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">xfrm_algo_encr_info</span> <span class="n">encr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">xfrm_algo_comp_info</span> <span class="n">comp</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">uinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sadb_alg</span> <span class="n">desc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* XFRM tunnel handlers.  */</span>
<span class="k">struct</span> <span class="n">xfrm_tunnel</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">err_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">info</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">xfrm_tunnel</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">priority</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xfrm6_tunnel</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">err_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inet6_skb_parm</span> <span class="o">*</span><span class="n">opt</span><span class="p">,</span>
			   <span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="n">u8</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">info</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfrm6_tunnel</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">priority</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm4_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">rt_hash_size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_state_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_state_fini</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm4_state_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_XFRM</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm6_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm6_fini</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm6_state_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm6_state_fini</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm6_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm6_fini</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_XFRM_STATISTICS</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_proc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_proc_fini</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_sysctl_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SYSCTL</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_sysctl_fini</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_sysctl_fini</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_state_walk_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state_walk</span> <span class="o">*</span><span class="n">walk</span><span class="p">,</span> <span class="n">u8</span> <span class="n">proto</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_state_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_state_walk</span> <span class="o">*</span><span class="n">walk</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_state_walk_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state_walk</span> <span class="o">*</span><span class="n">walk</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">xfrm_state_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">xfrm_state_find</span><span class="p">(</span><span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span>
					  <span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">xfrm_tmpl</span> <span class="o">*</span><span class="n">tmpl</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">xfrm_stateonly_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mark</span><span class="p">,</span>
					       <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span>
					       <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">,</span>
					       <span class="n">u8</span> <span class="n">mode</span><span class="p">,</span> <span class="n">u8</span> <span class="n">proto</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reqid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_state_check_expire</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_state_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_state_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_state_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">xfrm_state_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mark</span><span class="p">,</span>
					    <span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">spi</span><span class="p">,</span>
					    <span class="n">u8</span> <span class="n">proto</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">xfrm_state_lookup_byaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mark</span><span class="p">,</span>
						   <span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span>
						   <span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span>
						   <span class="n">u8</span> <span class="n">proto</span><span class="p">,</span>
						   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_XFRM_SUB_POLICY</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_tmpl_sort</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_tmpl</span> <span class="o">**</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_tmpl</span> <span class="o">**</span><span class="n">src</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_state_sort</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">**</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">**</span><span class="n">src</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_tmpl_sort</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_tmpl</span> <span class="o">**</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_tmpl</span> <span class="o">**</span><span class="n">src</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_state_sort</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">**</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">**</span><span class="n">src</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">xfrmk_sadinfo</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">sadhcnt</span><span class="p">;</span> <span class="cm">/* current hash bkts */</span>
	<span class="n">u32</span> <span class="n">sadhmcnt</span><span class="p">;</span> <span class="cm">/* max allowed hash bkts */</span>
	<span class="n">u32</span> <span class="n">sadcnt</span><span class="p">;</span> <span class="cm">/* current running count */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xfrmk_spdinfo</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">incnt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">outcnt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fwdcnt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">inscnt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">outscnt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fwdscnt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">spdhcnt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">spdhmcnt</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">xfrm_find_acq_byseq</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mark</span><span class="p">,</span>
					      <span class="n">u32</span> <span class="n">seq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_state_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_state_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u8</span> <span class="n">proto</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_sad_getinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrmk_sadinfo</span> <span class="o">*</span><span class="n">si</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_spd_getinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrmk_spdinfo</span> <span class="o">*</span><span class="n">si</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">xfrm_replay_seqhi</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">net_seq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_init_replay</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_state_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mtu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__xfrm_init_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">bool</span> <span class="n">init_replay</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_init_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_prepare_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nexthdr</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">spi</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">encap_type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_input_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nexthdr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_output_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_inner_extract_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm4_extract_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm4_extract_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm4_rcv_encap</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nexthdr</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">spi</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">encap_type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm4_transport_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">async</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm4_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm4_rcv_spi</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nexthdr</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xfrm4_rcv_encap</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nexthdr</span><span class="p">,</span> <span class="n">spi</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm4_extract_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm4_prepare_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm4_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm4_output_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm4_tunnel_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_tunnel</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm4_tunnel_deregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_tunnel</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm6_extract_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm6_extract_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm6_rcv_spi</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nexthdr</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">spi</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm6_transport_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">async</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm6_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm6_input_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span>
			    <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span> <span class="n">u8</span> <span class="n">proto</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm6_tunnel_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm6_tunnel</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm6_tunnel_deregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm6_tunnel</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__be32</span> <span class="n">xfrm6_tunnel_alloc_spi</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">saddr</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__be32</span> <span class="n">xfrm6_tunnel_spi_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">saddr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm6_extract_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm6_prepare_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm6_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm6_output_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm6_find_1stfragopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="o">**</span><span class="n">prevhdr</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_XFRM</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm4_udp_encap_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_user_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_user_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
 	<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
<span class="p">}</span> 

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm4_udp_encap_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
 	<span class="cm">/* should not happen */</span>
 	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">xfrm_policy_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_policy_walk_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_policy_walk</span> <span class="o">*</span><span class="n">walk</span><span class="p">,</span> <span class="n">u8</span> <span class="n">type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_policy_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_policy_walk</span> <span class="o">*</span><span class="n">walk</span><span class="p">,</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_policy_walk_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_policy_walk</span> <span class="o">*</span><span class="n">walk</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">xfrm_policy_insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">policy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">excl</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">xfrm_policy_bysel_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mark</span><span class="p">,</span>
					  <span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">xfrm_selector</span> <span class="o">*</span><span class="n">sel</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delete</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">xfrm_policy_byid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mark</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delete</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">xfrm_policy_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_audit</span> <span class="o">*</span><span class="n">audit_info</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">xfrm_get_acqseq</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_alloc_spi</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">u32</span> <span class="n">minspi</span><span class="p">,</span> <span class="n">u32</span> <span class="n">maxspi</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">xfrm_find_acq</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_mark</span> <span class="o">*</span><span class="n">mark</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="n">mode</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reqid</span><span class="p">,</span> <span class="n">u8</span> <span class="n">proto</span><span class="p">,</span>
				 <span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span>
				 <span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">family</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_sk_policy_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_XFRM_MIGRATE</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">km_migrate</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_selector</span> <span class="o">*</span><span class="n">sel</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dir</span><span class="p">,</span> <span class="n">u8</span> <span class="n">type</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_migrate</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_bundles</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_kmaddress</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span> <span class="n">xfrm_migrate_state_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_migrate</span> <span class="o">*</span><span class="n">m</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span> <span class="n">xfrm_state_migrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">xfrm_migrate</span> <span class="o">*</span><span class="n">m</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_migrate</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_selector</span> <span class="o">*</span><span class="n">sel</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dir</span><span class="p">,</span> <span class="n">u8</span> <span class="n">type</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">xfrm_migrate</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_bundles</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">xfrm_kmaddress</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">km_new_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">ipaddr</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">sport</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">km_policy_expired</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hard</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">km_report</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u8</span> <span class="n">proto</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_selector</span> <span class="o">*</span><span class="n">sel</span><span class="p">,</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_input_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_parse_spi</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u8</span> <span class="n">nexthdr</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">seq</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">xfrm_probe_algs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_count_auth_supported</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfrm_count_enc_supported</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_algo_desc</span> <span class="o">*</span><span class="n">xfrm_aalg_get_byidx</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_algo_desc</span> <span class="o">*</span><span class="n">xfrm_ealg_get_byidx</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_algo_desc</span> <span class="o">*</span><span class="n">xfrm_aalg_get_byid</span><span class="p">(</span><span class="kt">int</span> <span class="n">alg_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_algo_desc</span> <span class="o">*</span><span class="n">xfrm_ealg_get_byid</span><span class="p">(</span><span class="kt">int</span> <span class="n">alg_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_algo_desc</span> <span class="o">*</span><span class="n">xfrm_calg_get_byid</span><span class="p">(</span><span class="kt">int</span> <span class="n">alg_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_algo_desc</span> <span class="o">*</span><span class="n">xfrm_aalg_get_byname</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">probe</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_algo_desc</span> <span class="o">*</span><span class="n">xfrm_ealg_get_byname</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">probe</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_algo_desc</span> <span class="o">*</span><span class="n">xfrm_calg_get_byname</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">probe</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">xfrm_algo_desc</span> <span class="o">*</span><span class="n">xfrm_aead_get_byname</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">icv_len</span><span class="p">,</span>
						   <span class="kt">int</span> <span class="n">probe</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_addr_cmp</span><span class="p">(</span><span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">xfrm_address_t</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">a4</span> <span class="o">-</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">a4</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="k">return</span> <span class="n">ipv6_addr_cmp</span><span class="p">((</span><span class="k">const</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">,</span>
				     <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_policy_id2dir</span><span class="p">(</span><span class="n">u32</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">index</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_XFRM</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_aevent_is_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">nlsk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">nlsk</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">xfrm</span><span class="p">.</span><span class="n">nlsk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nlsk</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">netlink_has_listeners</span><span class="p">(</span><span class="n">nlsk</span><span class="p">,</span> <span class="n">XFRMNLGRP_AEVENTS</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_alg_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_algo</span> <span class="o">*</span><span class="n">alg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">alg</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">alg</span><span class="o">-&gt;</span><span class="n">alg_key_len</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_alg_auth_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_algo_auth</span> <span class="o">*</span><span class="n">alg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">alg</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">alg</span><span class="o">-&gt;</span><span class="n">alg_key_len</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_replay_state_esn_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_replay_state_esn</span> <span class="o">*</span><span class="n">replay_esn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">replay_esn</span><span class="p">)</span> <span class="o">+</span> <span class="n">replay_esn</span><span class="o">-&gt;</span><span class="n">bmp_len</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_XFRM_MIGRATE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_replay_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">orig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">x</span><span class="o">-&gt;</span><span class="n">replay_esn</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">xfrm_replay_state_esn_len</span><span class="p">(</span><span class="n">orig</span><span class="o">-&gt;</span><span class="n">replay_esn</span><span class="p">),</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">replay_esn</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">x</span><span class="o">-&gt;</span><span class="n">replay_esn</span><span class="o">-&gt;</span><span class="n">bmp_len</span> <span class="o">=</span> <span class="n">orig</span><span class="o">-&gt;</span><span class="n">replay_esn</span><span class="o">-&gt;</span><span class="n">bmp_len</span><span class="p">;</span>
	<span class="n">x</span><span class="o">-&gt;</span><span class="n">replay_esn</span><span class="o">-&gt;</span><span class="n">replay_window</span> <span class="o">=</span> <span class="n">orig</span><span class="o">-&gt;</span><span class="n">replay_esn</span><span class="o">-&gt;</span><span class="n">replay_window</span><span class="p">;</span>

	<span class="n">x</span><span class="o">-&gt;</span><span class="n">preplay_esn</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">replay_esn</span><span class="p">,</span>
				 <span class="n">xfrm_replay_state_esn_len</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">replay_esn</span><span class="p">),</span>
				 <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">preplay_esn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">replay_esn</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">xfrm_algo</span> <span class="o">*</span><span class="nf">xfrm_algo_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_algo</span> <span class="o">*</span><span class="n">orig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">xfrm_alg_len</span><span class="p">(</span><span class="n">orig</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">xfrm_algo_auth</span> <span class="o">*</span><span class="nf">xfrm_algo_auth_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_algo_auth</span> <span class="o">*</span><span class="n">orig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">xfrm_alg_auth_len</span><span class="p">(</span><span class="n">orig</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_states_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">**</span><span class="n">states</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">xfrm_state_put</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">states</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xfrm_states_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">**</span><span class="n">states</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">xfrm_state_delete</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">states</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_XFRM</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="nf">xfrm_input_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">xvec</span><span class="p">[</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_mark_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlattr</span> <span class="o">**</span><span class="n">attrs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_mark</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_MARK</span><span class="p">])</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="n">XFRMA_MARK</span><span class="p">]),</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_mark</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">&amp;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xfrm_mark_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xfrm_mark</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">|</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">XFRMA_MARK</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_mark</span><span class="p">),</span> <span class="n">m</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">nla_put_failure:</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* _NET_XFRM_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
