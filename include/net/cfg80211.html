<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › cfg80211.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>cfg80211.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __NET_CFG80211_H</span>
<span class="cp">#define __NET_CFG80211_H</span>
<span class="cm">/*</span>
<span class="cm"> * 802.11 device and configuration interface</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2006-2010	Johannes Berg &lt;johannes@sipsolutions.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/netlink.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/nl80211.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/ieee80211.h&gt;</span>
<span class="cp">#include &lt;net/regulatory.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Introduction</span>
<span class="cm"> *</span>
<span class="cm"> * cfg80211 is the configuration API for 802.11 devices in Linux. It bridges</span>
<span class="cm"> * userspace and drivers, and offers some utility functionality associated</span>
<span class="cm"> * with 802.11. cfg80211 must, directly or indirectly via mac80211, be used</span>
<span class="cm"> * by all modern wireless drivers in Linux, so that they offer a consistent</span>
<span class="cm"> * API through nl80211. For backward compatibility, cfg80211 also offers</span>
<span class="cm"> * wireless extensions to userspace, but hides them from drivers completely.</span>
<span class="cm"> *</span>
<span class="cm"> * Additionally, cfg80211 contains code to help enforce regulatory spectrum</span>
<span class="cm"> * use restrictions.</span>
<span class="cm"> */</span>


<span class="cm">/**</span>
<span class="cm"> * DOC: Device registration</span>
<span class="cm"> *</span>
<span class="cm"> * In order for a driver to use cfg80211, it must register the hardware device</span>
<span class="cm"> * with cfg80211. This happens through a number of hardware capability structs</span>
<span class="cm"> * described below.</span>
<span class="cm"> *</span>
<span class="cm"> * The fundamental structure for each device is the &#39;wiphy&#39;, of which each</span>
<span class="cm"> * instance describes a physical wireless device connected to the system. Each</span>
<span class="cm"> * such wiphy can have zero, one, or many virtual interfaces associated with</span>
<span class="cm"> * it, which need to be identified as such by pointing the network interface&#39;s</span>
<span class="cm"> * @ieee80211_ptr pointer to a &amp;struct wireless_dev which further describes</span>
<span class="cm"> * the wireless part of the interface, normally this struct is embedded in the</span>
<span class="cm"> * network interface&#39;s private data area. Drivers can optionally allow creating</span>
<span class="cm"> * or destroying virtual interfaces on the fly, but without at least one or the</span>
<span class="cm"> * ability to create some the wireless device isn&#39;t useful.</span>
<span class="cm"> *</span>
<span class="cm"> * Each wiphy structure contains device capability information, and also has</span>
<span class="cm"> * a pointer to the various operations the driver offers. The definitions and</span>
<span class="cm"> * structures here describe these capabilities in detail.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * wireless hardware capability structures</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_band - supported frequency bands</span>
<span class="cm"> *</span>
<span class="cm"> * The bands are assigned this way because the supported</span>
<span class="cm"> * bitrates differ in these bands.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_BAND_2GHZ: 2.4GHz ISM band</span>
<span class="cm"> * @IEEE80211_BAND_5GHZ: around 5GHz band (4.9-5.7)</span>
<span class="cm"> * @IEEE80211_NUM_BANDS: number of defined bands</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="p">{</span>
	<span class="n">IEEE80211_BAND_2GHZ</span> <span class="o">=</span> <span class="n">NL80211_BAND_2GHZ</span><span class="p">,</span>
	<span class="n">IEEE80211_BAND_5GHZ</span> <span class="o">=</span> <span class="n">NL80211_BAND_5GHZ</span><span class="p">,</span>

	<span class="cm">/* keep last */</span>
	<span class="n">IEEE80211_NUM_BANDS</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_channel_flags - channel flags</span>
<span class="cm"> *</span>
<span class="cm"> * Channel flags set by the regulatory control code.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_CHAN_DISABLED: This channel is disabled.</span>
<span class="cm"> * @IEEE80211_CHAN_PASSIVE_SCAN: Only passive scanning is permitted</span>
<span class="cm"> *	on this channel.</span>
<span class="cm"> * @IEEE80211_CHAN_NO_IBSS: IBSS is not allowed on this channel.</span>
<span class="cm"> * @IEEE80211_CHAN_RADAR: Radar detection is required on this channel.</span>
<span class="cm"> * @IEEE80211_CHAN_NO_HT40PLUS: extension channel above this channel</span>
<span class="cm"> * 	is not permitted.</span>
<span class="cm"> * @IEEE80211_CHAN_NO_HT40MINUS: extension channel below this channel</span>
<span class="cm"> * 	is not permitted.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_channel_flags</span> <span class="p">{</span>
	<span class="n">IEEE80211_CHAN_DISABLED</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>
	<span class="n">IEEE80211_CHAN_PASSIVE_SCAN</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">IEEE80211_CHAN_NO_IBSS</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span>
	<span class="n">IEEE80211_CHAN_RADAR</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span>
	<span class="n">IEEE80211_CHAN_NO_HT40PLUS</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">,</span>
	<span class="n">IEEE80211_CHAN_NO_HT40MINUS</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define IEEE80211_CHAN_NO_HT40 \</span>
<span class="cp">	(IEEE80211_CHAN_NO_HT40PLUS | IEEE80211_CHAN_NO_HT40MINUS)</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_channel - channel definition</span>
<span class="cm"> *</span>
<span class="cm"> * This structure describes a single channel for use</span>
<span class="cm"> * with cfg80211.</span>
<span class="cm"> *</span>
<span class="cm"> * @center_freq: center frequency in MHz</span>
<span class="cm"> * @hw_value: hardware-specific value for the channel</span>
<span class="cm"> * @flags: channel flags from &amp;enum ieee80211_channel_flags.</span>
<span class="cm"> * @orig_flags: channel flags at registration time, used by regulatory</span>
<span class="cm"> *	code to support devices with additional restrictions</span>
<span class="cm"> * @band: band this channel belongs to.</span>
<span class="cm"> * @max_antenna_gain: maximum antenna gain in dBi</span>
<span class="cm"> * @max_power: maximum transmission power (in dBm)</span>
<span class="cm"> * @max_reg_power: maximum regulatory transmission power (in dBm)</span>
<span class="cm"> * @beacon_found: helper to regulatory code to indicate when a beacon</span>
<span class="cm"> *	has been found on this channel. Use regulatory_hint_found_beacon()</span>
<span class="cm"> *	to enable this, this is useful only on 5 GHz band.</span>
<span class="cm"> * @orig_mag: internal use</span>
<span class="cm"> * @orig_mpwr: internal use</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">center_freq</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">hw_value</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_antenna_gain</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_power</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_reg_power</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">beacon_found</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">orig_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">orig_mag</span><span class="p">,</span> <span class="n">orig_mpwr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ieee80211_rate_flags - rate flags</span>
<span class="cm"> *</span>
<span class="cm"> * Hardware/specification flags for rates. These are structured</span>
<span class="cm"> * in a way that allows using the same bitrate structure for</span>
<span class="cm"> * different bands/PHY modes.</span>
<span class="cm"> *</span>
<span class="cm"> * @IEEE80211_RATE_SHORT_PREAMBLE: Hardware can send with short</span>
<span class="cm"> *	preamble on this bitrate; only relevant in 2.4GHz band and</span>
<span class="cm"> *	with CCK rates.</span>
<span class="cm"> * @IEEE80211_RATE_MANDATORY_A: This bitrate is a mandatory rate</span>
<span class="cm"> *	when used with 802.11a (on the 5 GHz band); filled by the</span>
<span class="cm"> *	core code when registering the wiphy.</span>
<span class="cm"> * @IEEE80211_RATE_MANDATORY_B: This bitrate is a mandatory rate</span>
<span class="cm"> *	when used with 802.11b (on the 2.4 GHz band); filled by the</span>
<span class="cm"> *	core code when registering the wiphy.</span>
<span class="cm"> * @IEEE80211_RATE_MANDATORY_G: This bitrate is a mandatory rate</span>
<span class="cm"> *	when used with 802.11g (on the 2.4 GHz band); filled by the</span>
<span class="cm"> *	core code when registering the wiphy.</span>
<span class="cm"> * @IEEE80211_RATE_ERP_G: This is an ERP rate in 802.11g mode.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ieee80211_rate_flags</span> <span class="p">{</span>
	<span class="n">IEEE80211_RATE_SHORT_PREAMBLE</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>
	<span class="n">IEEE80211_RATE_MANDATORY_A</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">IEEE80211_RATE_MANDATORY_B</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span>
	<span class="n">IEEE80211_RATE_MANDATORY_G</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span>
	<span class="n">IEEE80211_RATE_ERP_G</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_rate - bitrate definition</span>
<span class="cm"> *</span>
<span class="cm"> * This structure describes a bitrate that an 802.11 PHY can</span>
<span class="cm"> * operate with. The two values @hw_value and @hw_value_short</span>
<span class="cm"> * are only for driver use when pointers to this structure are</span>
<span class="cm"> * passed around.</span>
<span class="cm"> *</span>
<span class="cm"> * @flags: rate-specific flags</span>
<span class="cm"> * @bitrate: bitrate in units of 100 Kbps</span>
<span class="cm"> * @hw_value: driver/hardware value for this rate</span>
<span class="cm"> * @hw_value_short: driver/hardware value for this rate when</span>
<span class="cm"> *	short preamble is used</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_rate</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">bitrate</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">hw_value</span><span class="p">,</span> <span class="n">hw_value_short</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_sta_ht_cap - STA&#39;s HT capabilities</span>
<span class="cm"> *</span>
<span class="cm"> * This structure describes most essential parameters needed</span>
<span class="cm"> * to describe 802.11n HT capabilities for an STA.</span>
<span class="cm"> *</span>
<span class="cm"> * @ht_supported: is HT supported by the STA</span>
<span class="cm"> * @cap: HT capabilities map as described in 802.11n spec</span>
<span class="cm"> * @ampdu_factor: Maximum A-MPDU length factor</span>
<span class="cm"> * @ampdu_density: Minimum A-MPDU spacing</span>
<span class="cm"> * @mcs: Supported MCS rates</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_sta_ht_cap</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">cap</span><span class="p">;</span> <span class="cm">/* use IEEE80211_HT_CAP_ */</span>
	<span class="n">bool</span> <span class="n">ht_supported</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ampdu_factor</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ampdu_density</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_mcs_info</span> <span class="n">mcs</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_supported_band - frequency band definition</span>
<span class="cm"> *</span>
<span class="cm"> * This structure describes a frequency band a wiphy</span>
<span class="cm"> * is able to operate in.</span>
<span class="cm"> *</span>
<span class="cm"> * @channels: Array of channels the hardware can operate in</span>
<span class="cm"> *	in this band.</span>
<span class="cm"> * @band: the band this structure represents</span>
<span class="cm"> * @n_channels: Number of channels in @channels</span>
<span class="cm"> * @bitrates: Array of bitrates the hardware can operate with</span>
<span class="cm"> *	in this band. Must be sorted to give a valid &quot;supported</span>
<span class="cm"> *	rates&quot; IE, i.e. CCK rates first, then OFDM.</span>
<span class="cm"> * @n_bitrates: Number of bitrates in @bitrates</span>
<span class="cm"> * @ht_cap: HT capabilities in this band</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_rate</span> <span class="o">*</span><span class="n">bitrates</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_channels</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_bitrates</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_sta_ht_cap</span> <span class="n">ht_cap</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Wireless hardware/device configuration structures and methods</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Actions and configuration</span>
<span class="cm"> *</span>
<span class="cm"> * Each wireless device and each virtual interface offer a set of configuration</span>
<span class="cm"> * operations and other actions that are invoked by userspace. Each of these</span>
<span class="cm"> * actions is described in the operations structure, and the parameters these</span>
<span class="cm"> * operations use are described separately.</span>
<span class="cm"> *</span>
<span class="cm"> * Additionally, some operations are asynchronous and expect to get status</span>
<span class="cm"> * information via some functions that drivers need to call.</span>
<span class="cm"> *</span>
<span class="cm"> * Scanning and BSS list handling with its associated functionality is described</span>
<span class="cm"> * in a separate chapter.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct vif_params - describes virtual interface parameters</span>
<span class="cm"> * @use_4addr: use 4-address frames</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vif_params</span> <span class="p">{</span>
       <span class="kt">int</span> <span class="n">use_4addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct key_params - key information</span>
<span class="cm"> *</span>
<span class="cm"> * Information about a key</span>
<span class="cm"> *</span>
<span class="cm"> * @key: key material</span>
<span class="cm"> * @key_len: length of key material</span>
<span class="cm"> * @cipher: cipher suite selector</span>
<span class="cm"> * @seq: sequence counter (IV/PN) for TKIP and CCMP keys, only used</span>
<span class="cm"> *	with the get_key() callback, must be in little endian,</span>
<span class="cm"> *	length given by @seq_len.</span>
<span class="cm"> * @seq_len: length of @seq.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">key_params</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">key_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">seq_len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cipher</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum survey_info_flags - survey information flags</span>
<span class="cm"> *</span>
<span class="cm"> * @SURVEY_INFO_NOISE_DBM: noise (in dBm) was filled in</span>
<span class="cm"> * @SURVEY_INFO_IN_USE: channel is currently being used</span>
<span class="cm"> * @SURVEY_INFO_CHANNEL_TIME: channel active time (in ms) was filled in</span>
<span class="cm"> * @SURVEY_INFO_CHANNEL_TIME_BUSY: channel busy time was filled in</span>
<span class="cm"> * @SURVEY_INFO_CHANNEL_TIME_EXT_BUSY: extension channel busy time was filled in</span>
<span class="cm"> * @SURVEY_INFO_CHANNEL_TIME_RX: channel receive time was filled in</span>
<span class="cm"> * @SURVEY_INFO_CHANNEL_TIME_TX: channel transmit time was filled in</span>
<span class="cm"> *</span>
<span class="cm"> * Used by the driver to indicate which info in &amp;struct survey_info</span>
<span class="cm"> * it has filled in during the get_survey().</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">survey_info_flags</span> <span class="p">{</span>
	<span class="n">SURVEY_INFO_NOISE_DBM</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>
	<span class="n">SURVEY_INFO_IN_USE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">SURVEY_INFO_CHANNEL_TIME</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span>
	<span class="n">SURVEY_INFO_CHANNEL_TIME_BUSY</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span>
	<span class="n">SURVEY_INFO_CHANNEL_TIME_EXT_BUSY</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">,</span>
	<span class="n">SURVEY_INFO_CHANNEL_TIME_RX</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">,</span>
	<span class="n">SURVEY_INFO_CHANNEL_TIME_TX</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct survey_info - channel survey response</span>
<span class="cm"> *</span>
<span class="cm"> * @channel: the channel this survey record reports, mandatory</span>
<span class="cm"> * @filled: bitflag of flags from &amp;enum survey_info_flags</span>
<span class="cm"> * @noise: channel noise in dBm. This and all following fields are</span>
<span class="cm"> *     optional</span>
<span class="cm"> * @channel_time: amount of time in ms the radio spent on the channel</span>
<span class="cm"> * @channel_time_busy: amount of time the primary channel was sensed busy</span>
<span class="cm"> * @channel_time_ext_busy: amount of time the extension channel was sensed busy</span>
<span class="cm"> * @channel_time_rx: amount of time the radio spent receiving data</span>
<span class="cm"> * @channel_time_tx: amount of time the radio spent transmitting data</span>
<span class="cm"> *</span>
<span class="cm"> * Used by dump_survey() to report back per-channel survey information.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure can later be expanded with things like</span>
<span class="cm"> * channel duty cycle etc.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">survey_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">channel_time</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">channel_time_busy</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">channel_time_ext_busy</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">channel_time_rx</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">channel_time_tx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">filled</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">noise</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_crypto_settings - Crypto settings</span>
<span class="cm"> * @wpa_versions: indicates which, if any, WPA versions are enabled</span>
<span class="cm"> *	(from enum nl80211_wpa_versions)</span>
<span class="cm"> * @cipher_group: group key cipher suite (or 0 if unset)</span>
<span class="cm"> * @n_ciphers_pairwise: number of AP supported unicast ciphers</span>
<span class="cm"> * @ciphers_pairwise: unicast key cipher suites</span>
<span class="cm"> * @n_akm_suites: number of AKM suites</span>
<span class="cm"> * @akm_suites: AKM suites</span>
<span class="cm"> * @control_port: Whether user space controls IEEE 802.1X port, i.e.,</span>
<span class="cm"> *	sets/clears %NL80211_STA_FLAG_AUTHORIZED. If true, the driver is</span>
<span class="cm"> *	required to assume that the port is unauthorized until authorized by</span>
<span class="cm"> *	user space. Otherwise, port is marked authorized by default.</span>
<span class="cm"> * @control_port_ethertype: the control port protocol that should be</span>
<span class="cm"> *	allowed through even on unauthorized ports</span>
<span class="cm"> * @control_port_no_encrypt: TRUE to prevent encryption of control port</span>
<span class="cm"> *	protocol frames.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_crypto_settings</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">wpa_versions</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cipher_group</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_ciphers_pairwise</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ciphers_pairwise</span><span class="p">[</span><span class="n">NL80211_MAX_NR_CIPHER_SUITES</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">n_akm_suites</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">akm_suites</span><span class="p">[</span><span class="n">NL80211_MAX_NR_AKM_SUITES</span><span class="p">];</span>
	<span class="n">bool</span> <span class="n">control_port</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">control_port_ethertype</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">control_port_no_encrypt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_beacon_data - beacon data</span>
<span class="cm"> * @head: head portion of beacon (before TIM IE)</span>
<span class="cm"> *     or %NULL if not changed</span>
<span class="cm"> * @tail: tail portion of beacon (after TIM IE)</span>
<span class="cm"> *     or %NULL if not changed</span>
<span class="cm"> * @head_len: length of @head</span>
<span class="cm"> * @tail_len: length of @tail</span>
<span class="cm"> * @beacon_ies: extra information element(s) to add into Beacon frames or %NULL</span>
<span class="cm"> * @beacon_ies_len: length of beacon_ies in octets</span>
<span class="cm"> * @proberesp_ies: extra information element(s) to add into Probe Response</span>
<span class="cm"> *	frames or %NULL</span>
<span class="cm"> * @proberesp_ies_len: length of proberesp_ies in octets</span>
<span class="cm"> * @assocresp_ies: extra information element(s) to add into (Re)Association</span>
<span class="cm"> *	Response frames or %NULL</span>
<span class="cm"> * @assocresp_ies_len: length of assocresp_ies in octets</span>
<span class="cm"> * @probe_resp_len: length of probe response template (@probe_resp)</span>
<span class="cm"> * @probe_resp: probe response template (AP mode only)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_beacon_data</span> <span class="p">{</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">beacon_ies</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">proberesp_ies</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">assocresp_ies</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">probe_resp</span><span class="p">;</span>

	<span class="kt">size_t</span> <span class="n">head_len</span><span class="p">,</span> <span class="n">tail_len</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">beacon_ies_len</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">proberesp_ies_len</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">assocresp_ies_len</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">probe_resp_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_ap_settings - AP configuration</span>
<span class="cm"> *</span>
<span class="cm"> * Used to configure an AP interface.</span>
<span class="cm"> *</span>
<span class="cm"> * @beacon: beacon data</span>
<span class="cm"> * @beacon_interval: beacon interval</span>
<span class="cm"> * @dtim_period: DTIM period</span>
<span class="cm"> * @ssid: SSID to be used in the BSS (note: may be %NULL if not provided from</span>
<span class="cm"> *	user space)</span>
<span class="cm"> * @ssid_len: length of @ssid</span>
<span class="cm"> * @hidden_ssid: whether to hide the SSID in Beacon/Probe Response frames</span>
<span class="cm"> * @crypto: crypto settings</span>
<span class="cm"> * @privacy: the BSS uses privacy</span>
<span class="cm"> * @auth_type: Authentication type (algorithm)</span>
<span class="cm"> * @inactivity_timeout: time in seconds to determine station&#39;s inactivity.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_ap_settings</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfg80211_beacon_data</span> <span class="n">beacon</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">beacon_interval</span><span class="p">,</span> <span class="n">dtim_period</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ssid</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ssid_len</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">nl80211_hidden_ssid</span> <span class="n">hidden_ssid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg80211_crypto_settings</span> <span class="n">crypto</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">privacy</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">nl80211_auth_type</span> <span class="n">auth_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">inactivity_timeout</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum plink_action - actions to perform in mesh peers</span>
<span class="cm"> *</span>
<span class="cm"> * @PLINK_ACTION_INVALID: action 0 is reserved</span>
<span class="cm"> * @PLINK_ACTION_OPEN: start mesh peer link establishment</span>
<span class="cm"> * @PLINK_ACTION_BLOCK: block traffic from this mesh peer</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">plink_actions</span> <span class="p">{</span>
	<span class="n">PLINK_ACTION_INVALID</span><span class="p">,</span>
	<span class="n">PLINK_ACTION_OPEN</span><span class="p">,</span>
	<span class="n">PLINK_ACTION_BLOCK</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum station_parameters_apply_mask - station parameter values to apply</span>
<span class="cm"> * @STATION_PARAM_APPLY_UAPSD: apply new uAPSD parameters (uapsd_queues, max_sp)</span>
<span class="cm"> *</span>
<span class="cm"> * Not all station parameters have in-band &quot;no change&quot; signalling,</span>
<span class="cm"> * for those that don&#39;t these flags will are used.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">station_parameters_apply_mask</span> <span class="p">{</span>
	<span class="n">STATION_PARAM_APPLY_UAPSD</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct station_parameters - station parameters</span>
<span class="cm"> *</span>
<span class="cm"> * Used to change and create a new station.</span>
<span class="cm"> *</span>
<span class="cm"> * @vlan: vlan interface station should belong to</span>
<span class="cm"> * @supported_rates: supported rates in IEEE 802.11 format</span>
<span class="cm"> *	(or NULL for no change)</span>
<span class="cm"> * @supported_rates_len: number of supported rates</span>
<span class="cm"> * @sta_flags_mask: station flags that changed</span>
<span class="cm"> *	(bitmask of BIT(NL80211_STA_FLAG_...))</span>
<span class="cm"> * @sta_flags_set: station flags values</span>
<span class="cm"> *	(bitmask of BIT(NL80211_STA_FLAG_...))</span>
<span class="cm"> * @listen_interval: listen interval or -1 for no change</span>
<span class="cm"> * @aid: AID or zero for no change</span>
<span class="cm"> * @plink_action: plink action to take</span>
<span class="cm"> * @plink_state: set the peer link state for a station</span>
<span class="cm"> * @ht_capa: HT capabilities of station</span>
<span class="cm"> * @uapsd_queues: bitmap of queues configured for uapsd. same format</span>
<span class="cm"> *	as the AC bitmap in the QoS info field</span>
<span class="cm"> * @max_sp: max Service Period. same format as the MAX_SP in the</span>
<span class="cm"> *	QoS info field (but already shifted down)</span>
<span class="cm"> * @sta_modify_mask: bitmap indicating which parameters changed</span>
<span class="cm"> *	(for those that don&#39;t have a natural &quot;no change&quot; value),</span>
<span class="cm"> *	see &amp;enum station_parameters_apply_mask</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">station_parameters</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">supported_rates</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">vlan</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sta_flags_mask</span><span class="p">,</span> <span class="n">sta_flags_set</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sta_modify_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">listen_interval</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">aid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">supported_rates_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">plink_action</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">plink_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_ht_cap</span> <span class="o">*</span><span class="n">ht_capa</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">uapsd_queues</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_sp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum station_info_flags - station information flags</span>
<span class="cm"> *</span>
<span class="cm"> * Used by the driver to indicate which info in &amp;struct station_info</span>
<span class="cm"> * it has filled in during get_station() or dump_station().</span>
<span class="cm"> *</span>
<span class="cm"> * @STATION_INFO_INACTIVE_TIME: @inactive_time filled</span>
<span class="cm"> * @STATION_INFO_RX_BYTES: @rx_bytes filled</span>
<span class="cm"> * @STATION_INFO_TX_BYTES: @tx_bytes filled</span>
<span class="cm"> * @STATION_INFO_LLID: @llid filled</span>
<span class="cm"> * @STATION_INFO_PLID: @plid filled</span>
<span class="cm"> * @STATION_INFO_PLINK_STATE: @plink_state filled</span>
<span class="cm"> * @STATION_INFO_SIGNAL: @signal filled</span>
<span class="cm"> * @STATION_INFO_TX_BITRATE: @txrate fields are filled</span>
<span class="cm"> *  (tx_bitrate, tx_bitrate_flags and tx_bitrate_mcs)</span>
<span class="cm"> * @STATION_INFO_RX_PACKETS: @rx_packets filled</span>
<span class="cm"> * @STATION_INFO_TX_PACKETS: @tx_packets filled</span>
<span class="cm"> * @STATION_INFO_TX_RETRIES: @tx_retries filled</span>
<span class="cm"> * @STATION_INFO_TX_FAILED: @tx_failed filled</span>
<span class="cm"> * @STATION_INFO_RX_DROP_MISC: @rx_dropped_misc filled</span>
<span class="cm"> * @STATION_INFO_SIGNAL_AVG: @signal_avg filled</span>
<span class="cm"> * @STATION_INFO_RX_BITRATE: @rxrate fields are filled</span>
<span class="cm"> * @STATION_INFO_BSS_PARAM: @bss_param filled</span>
<span class="cm"> * @STATION_INFO_CONNECTED_TIME: @connected_time filled</span>
<span class="cm"> * @STATION_INFO_ASSOC_REQ_IES: @assoc_req_ies filled</span>
<span class="cm"> * @STATION_INFO_STA_FLAGS: @sta_flags filled</span>
<span class="cm"> * @STATION_INFO_BEACON_LOSS_COUNT: @beacon_loss_count filled</span>
<span class="cm"> * @STATION_INFO_T_OFFSET: @t_offset filled</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">station_info_flags</span> <span class="p">{</span>
	<span class="n">STATION_INFO_INACTIVE_TIME</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>
	<span class="n">STATION_INFO_RX_BYTES</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">STATION_INFO_TX_BYTES</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span>
	<span class="n">STATION_INFO_LLID</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span>
	<span class="n">STATION_INFO_PLID</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">,</span>
	<span class="n">STATION_INFO_PLINK_STATE</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">,</span>
	<span class="n">STATION_INFO_SIGNAL</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">,</span>
	<span class="n">STATION_INFO_TX_BITRATE</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">,</span>
	<span class="n">STATION_INFO_RX_PACKETS</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">,</span>
	<span class="n">STATION_INFO_TX_PACKETS</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">,</span>
	<span class="n">STATION_INFO_TX_RETRIES</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">,</span>
	<span class="n">STATION_INFO_TX_FAILED</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">11</span><span class="p">,</span>
	<span class="n">STATION_INFO_RX_DROP_MISC</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">12</span><span class="p">,</span>
	<span class="n">STATION_INFO_SIGNAL_AVG</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">13</span><span class="p">,</span>
	<span class="n">STATION_INFO_RX_BITRATE</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">14</span><span class="p">,</span>
	<span class="n">STATION_INFO_BSS_PARAM</span>          <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">15</span><span class="p">,</span>
	<span class="n">STATION_INFO_CONNECTED_TIME</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">,</span>
	<span class="n">STATION_INFO_ASSOC_REQ_IES</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">17</span><span class="p">,</span>
	<span class="n">STATION_INFO_STA_FLAGS</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">18</span><span class="p">,</span>
	<span class="n">STATION_INFO_BEACON_LOSS_COUNT</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">19</span><span class="p">,</span>
	<span class="n">STATION_INFO_T_OFFSET</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum station_info_rate_flags - bitrate info flags</span>
<span class="cm"> *</span>
<span class="cm"> * Used by the driver to indicate the specific rate transmission</span>
<span class="cm"> * type for 802.11n transmissions.</span>
<span class="cm"> *</span>
<span class="cm"> * @RATE_INFO_FLAGS_MCS: @tx_bitrate_mcs filled</span>
<span class="cm"> * @RATE_INFO_FLAGS_40_MHZ_WIDTH: 40 Mhz width transmission</span>
<span class="cm"> * @RATE_INFO_FLAGS_SHORT_GI: 400ns guard interval</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">rate_info_flags</span> <span class="p">{</span>
	<span class="n">RATE_INFO_FLAGS_MCS</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>
	<span class="n">RATE_INFO_FLAGS_40_MHZ_WIDTH</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">RATE_INFO_FLAGS_SHORT_GI</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct rate_info - bitrate information</span>
<span class="cm"> *</span>
<span class="cm"> * Information about a receiving or transmitting bitrate</span>
<span class="cm"> *</span>
<span class="cm"> * @flags: bitflag of flags from &amp;enum rate_info_flags</span>
<span class="cm"> * @mcs: mcs index if struct describes a 802.11n bitrate</span>
<span class="cm"> * @legacy: bitrate in 100kbit/s for 802.11abg</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rate_info</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mcs</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">legacy</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum station_info_rate_flags - bitrate info flags</span>
<span class="cm"> *</span>
<span class="cm"> * Used by the driver to indicate the specific rate transmission</span>
<span class="cm"> * type for 802.11n transmissions.</span>
<span class="cm"> *</span>
<span class="cm"> * @BSS_PARAM_FLAGS_CTS_PROT: whether CTS protection is enabled</span>
<span class="cm"> * @BSS_PARAM_FLAGS_SHORT_PREAMBLE: whether short preamble is enabled</span>
<span class="cm"> * @BSS_PARAM_FLAGS_SHORT_SLOT_TIME: whether short slot time is enabled</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">bss_param_flags</span> <span class="p">{</span>
	<span class="n">BSS_PARAM_FLAGS_CTS_PROT</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>
	<span class="n">BSS_PARAM_FLAGS_SHORT_PREAMBLE</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">BSS_PARAM_FLAGS_SHORT_SLOT_TIME</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct sta_bss_parameters - BSS parameters for the attached station</span>
<span class="cm"> *</span>
<span class="cm"> * Information about the currently associated BSS</span>
<span class="cm"> *</span>
<span class="cm"> * @flags: bitflag of flags from &amp;enum bss_param_flags</span>
<span class="cm"> * @dtim_period: DTIM period for the BSS</span>
<span class="cm"> * @beacon_interval: beacon interval</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sta_bss_parameters</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dtim_period</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">beacon_interval</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct station_info - station information</span>
<span class="cm"> *</span>
<span class="cm"> * Station information filled by driver for get_station() and dump_station.</span>
<span class="cm"> *</span>
<span class="cm"> * @filled: bitflag of flags from &amp;enum station_info_flags</span>
<span class="cm"> * @connected_time: time(in secs) since a station is last connected</span>
<span class="cm"> * @inactive_time: time since last station activity (tx/rx) in milliseconds</span>
<span class="cm"> * @rx_bytes: bytes received from this station</span>
<span class="cm"> * @tx_bytes: bytes transmitted to this station</span>
<span class="cm"> * @llid: mesh local link id</span>
<span class="cm"> * @plid: mesh peer link id</span>
<span class="cm"> * @plink_state: mesh peer link state</span>
<span class="cm"> * @signal: the signal strength, type depends on the wiphy&#39;s signal_type</span>
<span class="cm">	NOTE: For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.</span>
<span class="cm"> * @signal_avg: avg signal strength, type depends on the wiphy&#39;s signal_type</span>
<span class="cm">	NOTE: For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.</span>
<span class="cm"> * @txrate: current unicast bitrate from this station</span>
<span class="cm"> * @rxrate: current unicast bitrate to this station</span>
<span class="cm"> * @rx_packets: packets received from this station</span>
<span class="cm"> * @tx_packets: packets transmitted to this station</span>
<span class="cm"> * @tx_retries: cumulative retry counts</span>
<span class="cm"> * @tx_failed: number of failed transmissions (retries exceeded, no ACK)</span>
<span class="cm"> * @rx_dropped_misc:  Dropped for un-specified reason.</span>
<span class="cm"> * @bss_param: current BSS parameters</span>
<span class="cm"> * @generation: generation number for nl80211 dumps.</span>
<span class="cm"> *	This number should increase every time the list of stations</span>
<span class="cm"> *	changes, i.e. when a station is added or removed, so that</span>
<span class="cm"> *	userspace can tell whether it got a consistent snapshot.</span>
<span class="cm"> * @assoc_req_ies: IEs from (Re)Association Request.</span>
<span class="cm"> *	This is used only when in AP mode with drivers that do not use</span>
<span class="cm"> *	user space MLME/SME implementation. The information is provided for</span>
<span class="cm"> *	the cfg80211_new_sta() calls to notify user space of the IEs.</span>
<span class="cm"> * @assoc_req_ies_len: Length of assoc_req_ies buffer in octets.</span>
<span class="cm"> * @sta_flags: station flags mask &amp; values</span>
<span class="cm"> * @beacon_loss_count: Number of times beacon loss event has triggered.</span>
<span class="cm"> * @t_offset: Time offset of the station relative to this host.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">station_info</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">filled</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">connected_time</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">inactive_time</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_bytes</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">llid</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">plid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">plink_state</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">signal</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">signal_avg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rate_info</span> <span class="n">txrate</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rate_info</span> <span class="n">rxrate</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_packets</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_packets</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_retries</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_failed</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_dropped_misc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sta_bss_parameters</span> <span class="n">bss_param</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nl80211_sta_flag_update</span> <span class="n">sta_flags</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">generation</span><span class="p">;</span>

	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">assoc_req_ies</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">assoc_req_ies_len</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">beacon_loss_count</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">t_offset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note: Add a new enum station_info_flags value for each new field and</span>
<span class="cm">	 * use it to check which fields are initialized.</span>
<span class="cm">	 */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum monitor_flags - monitor flags</span>
<span class="cm"> *</span>
<span class="cm"> * Monitor interface configuration flags. Note that these must be the bits</span>
<span class="cm"> * according to the nl80211 flags.</span>
<span class="cm"> *</span>
<span class="cm"> * @MONITOR_FLAG_FCSFAIL: pass frames with bad FCS</span>
<span class="cm"> * @MONITOR_FLAG_PLCPFAIL: pass frames with bad PLCP</span>
<span class="cm"> * @MONITOR_FLAG_CONTROL: pass control frames</span>
<span class="cm"> * @MONITOR_FLAG_OTHER_BSS: disable BSSID filtering</span>
<span class="cm"> * @MONITOR_FLAG_COOK_FRAMES: report frames after processing</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">monitor_flags</span> <span class="p">{</span>
	<span class="n">MONITOR_FLAG_FCSFAIL</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">NL80211_MNTR_FLAG_FCSFAIL</span><span class="p">,</span>
	<span class="n">MONITOR_FLAG_PLCPFAIL</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">NL80211_MNTR_FLAG_PLCPFAIL</span><span class="p">,</span>
	<span class="n">MONITOR_FLAG_CONTROL</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">NL80211_MNTR_FLAG_CONTROL</span><span class="p">,</span>
	<span class="n">MONITOR_FLAG_OTHER_BSS</span>		<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">NL80211_MNTR_FLAG_OTHER_BSS</span><span class="p">,</span>
	<span class="n">MONITOR_FLAG_COOK_FRAMES</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">NL80211_MNTR_FLAG_COOK_FRAMES</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum mpath_info_flags -  mesh path information flags</span>
<span class="cm"> *</span>
<span class="cm"> * Used by the driver to indicate which info in &amp;struct mpath_info it has filled</span>
<span class="cm"> * in during get_station() or dump_station().</span>
<span class="cm"> *</span>
<span class="cm"> * @MPATH_INFO_FRAME_QLEN: @frame_qlen filled</span>
<span class="cm"> * @MPATH_INFO_SN: @sn filled</span>
<span class="cm"> * @MPATH_INFO_METRIC: @metric filled</span>
<span class="cm"> * @MPATH_INFO_EXPTIME: @exptime filled</span>
<span class="cm"> * @MPATH_INFO_DISCOVERY_TIMEOUT: @discovery_timeout filled</span>
<span class="cm"> * @MPATH_INFO_DISCOVERY_RETRIES: @discovery_retries filled</span>
<span class="cm"> * @MPATH_INFO_FLAGS: @flags filled</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">mpath_info_flags</span> <span class="p">{</span>
	<span class="n">MPATH_INFO_FRAME_QLEN</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">MPATH_INFO_SN</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">MPATH_INFO_METRIC</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">MPATH_INFO_EXPTIME</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">MPATH_INFO_DISCOVERY_TIMEOUT</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
	<span class="n">MPATH_INFO_DISCOVERY_RETRIES</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	<span class="n">MPATH_INFO_FLAGS</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct mpath_info - mesh path information</span>
<span class="cm"> *</span>
<span class="cm"> * Mesh path information filled by driver for get_mpath() and dump_mpath().</span>
<span class="cm"> *</span>
<span class="cm"> * @filled: bitfield of flags from &amp;enum mpath_info_flags</span>
<span class="cm"> * @frame_qlen: number of queued frames for this destination</span>
<span class="cm"> * @sn: target sequence number</span>
<span class="cm"> * @metric: metric (cost) of this mesh path</span>
<span class="cm"> * @exptime: expiration time for the mesh path from now, in msecs</span>
<span class="cm"> * @flags: mesh path flags</span>
<span class="cm"> * @discovery_timeout: total mesh path discovery timeout, in msecs</span>
<span class="cm"> * @discovery_retries: mesh path discovery retries</span>
<span class="cm"> * @generation: generation number for nl80211 dumps.</span>
<span class="cm"> *	This number should increase every time the list of mesh paths</span>
<span class="cm"> *	changes, i.e. when a station is added or removed, so that</span>
<span class="cm"> *	userspace can tell whether it got a consistent snapshot.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mpath_info</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">filled</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frame_qlen</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sn</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">metric</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">exptime</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">discovery_timeout</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">discovery_retries</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">generation</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct bss_parameters - BSS parameters</span>
<span class="cm"> *</span>
<span class="cm"> * Used to change BSS parameters (mainly for AP mode).</span>
<span class="cm"> *</span>
<span class="cm"> * @use_cts_prot: Whether to use CTS protection</span>
<span class="cm"> *	(0 = no, 1 = yes, -1 = do not change)</span>
<span class="cm"> * @use_short_preamble: Whether the use of short preambles is allowed</span>
<span class="cm"> *	(0 = no, 1 = yes, -1 = do not change)</span>
<span class="cm"> * @use_short_slot_time: Whether the use of short slot time is allowed</span>
<span class="cm"> *	(0 = no, 1 = yes, -1 = do not change)</span>
<span class="cm"> * @basic_rates: basic rates in IEEE 802.11 format</span>
<span class="cm"> *	(or NULL for no change)</span>
<span class="cm"> * @basic_rates_len: number of basic rates</span>
<span class="cm"> * @ap_isolate: do not forward packets between connected stations</span>
<span class="cm"> * @ht_opmode: HT Operation mode</span>
<span class="cm"> * 	(u16 = opmode, -1 = do not change)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bss_parameters</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">use_cts_prot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_short_preamble</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_short_slot_time</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">basic_rates</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">basic_rates_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ap_isolate</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ht_opmode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct mesh_config - 802.11s mesh configuration</span>
<span class="cm"> *</span>
<span class="cm"> * These parameters can be changed while the mesh is active.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mesh_config</span> <span class="p">{</span>
	<span class="cm">/* Timeouts in ms */</span>
	<span class="cm">/* Mesh plink management parameters */</span>
	<span class="n">u16</span> <span class="n">dot11MeshRetryTimeout</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">dot11MeshConfirmTimeout</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">dot11MeshHoldingTimeout</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">dot11MeshMaxPeerLinks</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">dot11MeshMaxRetries</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">dot11MeshTTL</span><span class="p">;</span>
	<span class="cm">/* ttl used in path selection information elements */</span>
	<span class="n">u8</span>  <span class="n">element_ttl</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">auto_open_plinks</span><span class="p">;</span>
	<span class="cm">/* neighbor offset synchronization */</span>
	<span class="n">u32</span> <span class="n">dot11MeshNbrOffsetMaxNeighbor</span><span class="p">;</span>
	<span class="cm">/* HWMP parameters */</span>
	<span class="n">u8</span>  <span class="n">dot11MeshHWMPmaxPREQretries</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">path_refresh_time</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">min_discovery_timeout</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dot11MeshHWMPactivePathTimeout</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">dot11MeshHWMPpreqMinInterval</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">dot11MeshHWMPperrMinInterval</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">dot11MeshHWMPnetDiameterTraversalTime</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">dot11MeshHWMPRootMode</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">dot11MeshHWMPRannInterval</span><span class="p">;</span>
	<span class="cm">/* This is missnamed in draft 12.0: dot11MeshGateAnnouncementProtocol</span>
<span class="cm">	 * set to true only means that the station will announce others it&#39;s a</span>
<span class="cm">	 * mesh gate, but not necessarily using the gate announcement protocol.</span>
<span class="cm">	 * Still keeping the same nomenclature to be in sync with the spec. */</span>
	<span class="n">bool</span>  <span class="n">dot11MeshGateAnnouncementProtocol</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">dot11MeshForwarding</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">rssi_threshold</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ht_opmode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct mesh_setup - 802.11s mesh setup configuration</span>
<span class="cm"> * @mesh_id: the mesh ID</span>
<span class="cm"> * @mesh_id_len: length of the mesh ID, at least 1 and at most 32 bytes</span>
<span class="cm"> * @sync_method: which synchronization method to use</span>
<span class="cm"> * @path_sel_proto: which path selection protocol to use</span>
<span class="cm"> * @path_metric: which metric to use</span>
<span class="cm"> * @ie: vendor information elements (optional)</span>
<span class="cm"> * @ie_len: length of vendor information elements</span>
<span class="cm"> * @is_authenticated: this mesh requires authentication</span>
<span class="cm"> * @is_secure: this mesh uses security</span>
<span class="cm"> * @mcast_rate: multicat rate for Mesh Node [6Mbps is the default for 802.11a]</span>
<span class="cm"> *</span>
<span class="cm"> * These parameters are fixed when the mesh is created.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mesh_setup</span> <span class="p">{</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mesh_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mesh_id_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sync_method</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">path_sel_proto</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">path_metric</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ie_len</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_authenticated</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_secure</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mcast_rate</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_txq_params - TX queue parameters</span>
<span class="cm"> * @ac: AC identifier</span>
<span class="cm"> * @txop: Maximum burst time in units of 32 usecs, 0 meaning disabled</span>
<span class="cm"> * @cwmin: Minimum contention window [a value of the form 2^n-1 in the range</span>
<span class="cm"> *	1..32767]</span>
<span class="cm"> * @cwmax: Maximum contention window [a value of the form 2^n-1 in the range</span>
<span class="cm"> *	1..32767]</span>
<span class="cm"> * @aifs: Arbitration interframe space [0..255]</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_txq_params</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">nl80211_ac</span> <span class="n">ac</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">txop</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cwmin</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cwmax</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">aifs</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* from net/wireless.h */</span>
<span class="k">struct</span> <span class="n">wiphy</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Scanning and BSS list handling</span>
<span class="cm"> *</span>
<span class="cm"> * The scanning process itself is fairly simple, but cfg80211 offers quite</span>
<span class="cm"> * a bit of helper functionality. To start a scan, the scan operation will</span>
<span class="cm"> * be invoked with a scan definition. This scan definition contains the</span>
<span class="cm"> * channels to scan, and the SSIDs to send probe requests for (including the</span>
<span class="cm"> * wildcard, if desired). A passive scan is indicated by having no SSIDs to</span>
<span class="cm"> * probe. Additionally, a scan request may contain extra information elements</span>
<span class="cm"> * that should be added to the probe request. The IEs are guaranteed to be</span>
<span class="cm"> * well-formed, and will not exceed the maximum length the driver advertised</span>
<span class="cm"> * in the wiphy structure.</span>
<span class="cm"> *</span>
<span class="cm"> * When scanning finds a BSS, cfg80211 needs to be notified of that, because</span>
<span class="cm"> * it is responsible for maintaining the BSS list; the driver should not</span>
<span class="cm"> * maintain a list itself. For this notification, various functions exist.</span>
<span class="cm"> *</span>
<span class="cm"> * Since drivers do not maintain a BSS list, there are also a number of</span>
<span class="cm"> * functions to search for a BSS and obtain information about it from the</span>
<span class="cm"> * BSS structure cfg80211 maintains. The BSS list is also made available</span>
<span class="cm"> * to userspace.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_ssid - SSID description</span>
<span class="cm"> * @ssid: the SSID</span>
<span class="cm"> * @ssid_len: length of the ssid</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_ssid</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">ssid</span><span class="p">[</span><span class="n">IEEE80211_MAX_SSID_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">ssid_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_scan_request - scan request description</span>
<span class="cm"> *</span>
<span class="cm"> * @ssids: SSIDs to scan for (active scan only)</span>
<span class="cm"> * @n_ssids: number of SSIDs</span>
<span class="cm"> * @channels: channels to scan on.</span>
<span class="cm"> * @n_channels: total number of channels to scan</span>
<span class="cm"> * @ie: optional information element(s) to add into Probe Request or %NULL</span>
<span class="cm"> * @ie_len: length of ie in octets</span>
<span class="cm"> * @rates: bitmap of rates to advertise for each band</span>
<span class="cm"> * @wiphy: the wiphy this was for</span>
<span class="cm"> * @dev: the interface</span>
<span class="cm"> * @aborted: (internal) scan request was notified as aborted</span>
<span class="cm"> * @no_cck: used to send probe requests at non CCK rate in 2GHz band</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_scan_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfg80211_ssid</span> <span class="o">*</span><span class="n">ssids</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_ssids</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">n_channels</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ie_len</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">rates</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>

	<span class="cm">/* internal */</span>
	<span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">aborted</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">no_cck</span><span class="p">;</span>

	<span class="cm">/* keep last */</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_match_set - sets of attributes to match</span>
<span class="cm"> *</span>
<span class="cm"> * @ssid: SSID to be matched</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_match_set</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfg80211_ssid</span> <span class="n">ssid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_sched_scan_request - scheduled scan request description</span>
<span class="cm"> *</span>
<span class="cm"> * @ssids: SSIDs to scan for (passed in the probe_reqs in active scans)</span>
<span class="cm"> * @n_ssids: number of SSIDs</span>
<span class="cm"> * @n_channels: total number of channels to scan</span>
<span class="cm"> * @interval: interval between each scheduled scan cycle</span>
<span class="cm"> * @ie: optional information element(s) to add into Probe Request or %NULL</span>
<span class="cm"> * @ie_len: length of ie in octets</span>
<span class="cm"> * @match_sets: sets of parameters to be matched for a scan result</span>
<span class="cm"> * 	entry to be considered valid and to be passed to the host</span>
<span class="cm"> * 	(others are filtered out).</span>
<span class="cm"> *	If ommited, all results are passed.</span>
<span class="cm"> * @n_match_sets: number of match sets</span>
<span class="cm"> * @wiphy: the wiphy this was for</span>
<span class="cm"> * @dev: the interface</span>
<span class="cm"> * @channels: channels to scan</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_sched_scan_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfg80211_ssid</span> <span class="o">*</span><span class="n">ssids</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_ssids</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">n_channels</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">interval</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ie_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg80211_match_set</span> <span class="o">*</span><span class="n">match_sets</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_match_sets</span><span class="p">;</span>

	<span class="cm">/* internal */</span>
	<span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* keep last */</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum cfg80211_signal_type - signal type</span>
<span class="cm"> *</span>
<span class="cm"> * @CFG80211_SIGNAL_TYPE_NONE: no signal strength information available</span>
<span class="cm"> * @CFG80211_SIGNAL_TYPE_MBM: signal strength in mBm (100*dBm)</span>
<span class="cm"> * @CFG80211_SIGNAL_TYPE_UNSPEC: signal strength, increasing from 0 through 100</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">cfg80211_signal_type</span> <span class="p">{</span>
	<span class="n">CFG80211_SIGNAL_TYPE_NONE</span><span class="p">,</span>
	<span class="n">CFG80211_SIGNAL_TYPE_MBM</span><span class="p">,</span>
	<span class="n">CFG80211_SIGNAL_TYPE_UNSPEC</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_bss - BSS description</span>
<span class="cm"> *</span>
<span class="cm"> * This structure describes a BSS (which may also be a mesh network)</span>
<span class="cm"> * for use in scan results and similar.</span>
<span class="cm"> *</span>
<span class="cm"> * @channel: channel this BSS is on</span>
<span class="cm"> * @bssid: BSSID of the BSS</span>
<span class="cm"> * @tsf: timestamp of last received update</span>
<span class="cm"> * @beacon_interval: the beacon interval as from the frame</span>
<span class="cm"> * @capability: the capability field in host byte order</span>
<span class="cm"> * @information_elements: the information elements (Note that there</span>
<span class="cm"> *	is no guarantee that these are well-formed!); this is a pointer to</span>
<span class="cm"> *	either the beacon_ies or proberesp_ies depending on whether Probe</span>
<span class="cm"> *	Response frame has been received</span>
<span class="cm"> * @len_information_elements: total length of the information elements</span>
<span class="cm"> * @beacon_ies: the information elements from the last Beacon frame</span>
<span class="cm"> * @len_beacon_ies: total length of the beacon_ies</span>
<span class="cm"> * @proberesp_ies: the information elements from the last Probe Response frame</span>
<span class="cm"> * @len_proberesp_ies: total length of the proberesp_ies</span>
<span class="cm"> * @signal: signal strength value (type depends on the wiphy&#39;s signal_type)</span>
<span class="cm"> * @free_priv: function pointer to free private data</span>
<span class="cm"> * @priv: private area for driver use, has at least wiphy-&gt;bss_priv_size bytes</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">bssid</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">tsf</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">beacon_interval</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">capability</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">information_elements</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len_information_elements</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">beacon_ies</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len_beacon_ies</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">proberesp_ies</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len_proberesp_ies</span><span class="p">;</span>

	<span class="n">s32</span> <span class="n">signal</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free_priv</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))));</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_bss_get_ie - find IE with given ID</span>
<span class="cm"> * @bss: the bss to search</span>
<span class="cm"> * @ie: the IE ID</span>
<span class="cm"> * Returns %NULL if not found.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ieee80211_bss_get_ie</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ie</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_auth_request - Authentication request data</span>
<span class="cm"> *</span>
<span class="cm"> * This structure provides information needed to complete IEEE 802.11</span>
<span class="cm"> * authentication.</span>
<span class="cm"> *</span>
<span class="cm"> * @bss: The BSS to authenticate with.</span>
<span class="cm"> * @auth_type: Authentication type (algorithm)</span>
<span class="cm"> * @ie: Extra IEs to add to Authentication frame or %NULL</span>
<span class="cm"> * @ie_len: Length of ie buffer in octets</span>
<span class="cm"> * @key_len: length of WEP key for shared key authentication</span>
<span class="cm"> * @key_idx: index of WEP key for shared key authentication</span>
<span class="cm"> * @key: WEP key for shared key authentication</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_auth_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ie_len</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">nl80211_auth_type</span> <span class="n">auth_type</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">key_len</span><span class="p">,</span> <span class="n">key_idx</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum cfg80211_assoc_req_flags - Over-ride default behaviour in association.</span>
<span class="cm"> *</span>
<span class="cm"> * @ASSOC_REQ_DISABLE_HT:  Disable HT (802.11n)</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">cfg80211_assoc_req_flags</span> <span class="p">{</span>
	<span class="n">ASSOC_REQ_DISABLE_HT</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_assoc_request - (Re)Association request data</span>
<span class="cm"> *</span>
<span class="cm"> * This structure provides information needed to complete IEEE 802.11</span>
<span class="cm"> * (re)association.</span>
<span class="cm"> * @bss: The BSS to associate with. If the call is successful the driver</span>
<span class="cm"> *	is given a reference that it must release, normally via a call to</span>
<span class="cm"> *	cfg80211_send_rx_assoc(), or, if association timed out, with a</span>
<span class="cm"> *	call to cfg80211_put_bss() (in addition to calling</span>
<span class="cm"> *	cfg80211_send_assoc_timeout())</span>
<span class="cm"> * @ie: Extra IEs to add to (Re)Association Request frame or %NULL</span>
<span class="cm"> * @ie_len: Length of ie buffer in octets</span>
<span class="cm"> * @use_mfp: Use management frame protection (IEEE 802.11w) in this association</span>
<span class="cm"> * @crypto: crypto settings</span>
<span class="cm"> * @prev_bssid: previous BSSID, if not %NULL use reassociate frame</span>
<span class="cm"> * @flags:  See &amp;enum cfg80211_assoc_req_flags</span>
<span class="cm"> * @ht_capa:  HT Capabilities over-rides.  Values set in ht_capa_mask</span>
<span class="cm"> *   will be used in ht_capa.  Un-supported values will be ignored.</span>
<span class="cm"> * @ht_capa_mask:  The bits of ht_capa which are to be used.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_assoc_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">,</span> <span class="o">*</span><span class="n">prev_bssid</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ie_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg80211_crypto_settings</span> <span class="n">crypto</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">use_mfp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_ht_cap</span> <span class="n">ht_capa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_ht_cap</span> <span class="n">ht_capa_mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_deauth_request - Deauthentication request data</span>
<span class="cm"> *</span>
<span class="cm"> * This structure provides information needed to complete IEEE 802.11</span>
<span class="cm"> * deauthentication.</span>
<span class="cm"> *</span>
<span class="cm"> * @bssid: the BSSID of the BSS to deauthenticate from</span>
<span class="cm"> * @ie: Extra IEs to add to Deauthentication frame or %NULL</span>
<span class="cm"> * @ie_len: Length of ie buffer in octets</span>
<span class="cm"> * @reason_code: The reason code for the deauthentication</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_deauth_request</span> <span class="p">{</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ie_len</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">reason_code</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_disassoc_request - Disassociation request data</span>
<span class="cm"> *</span>
<span class="cm"> * This structure provides information needed to complete IEEE 802.11</span>
<span class="cm"> * disassocation.</span>
<span class="cm"> *</span>
<span class="cm"> * @bss: the BSS to disassociate from</span>
<span class="cm"> * @ie: Extra IEs to add to Disassociation frame or %NULL</span>
<span class="cm"> * @ie_len: Length of ie buffer in octets</span>
<span class="cm"> * @reason_code: The reason code for the disassociation</span>
<span class="cm"> * @local_state_change: This is a request for a local state only, i.e., no</span>
<span class="cm"> *	Disassociation frame is to be transmitted.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_disassoc_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ie_len</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">reason_code</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">local_state_change</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_ibss_params - IBSS parameters</span>
<span class="cm"> *</span>
<span class="cm"> * This structure defines the IBSS parameters for the join_ibss()</span>
<span class="cm"> * method.</span>
<span class="cm"> *</span>
<span class="cm"> * @ssid: The SSID, will always be non-null.</span>
<span class="cm"> * @ssid_len: The length of the SSID, will always be non-zero.</span>
<span class="cm"> * @bssid: Fixed BSSID requested, maybe be %NULL, if set do not</span>
<span class="cm"> *	search for IBSSs with a different BSSID.</span>
<span class="cm"> * @channel: The channel to use if no IBSS can be found to join.</span>
<span class="cm"> * @channel_type: channel type (HT mode)</span>
<span class="cm"> * @channel_fixed: The channel should be fixed -- do not search for</span>
<span class="cm"> *	IBSSs to join on other channels.</span>
<span class="cm"> * @ie: information element(s) to include in the beacon</span>
<span class="cm"> * @ie_len: length of that</span>
<span class="cm"> * @beacon_interval: beacon interval to use</span>
<span class="cm"> * @privacy: this is a protected network, keys will be configured</span>
<span class="cm"> *	after joining</span>
<span class="cm"> * @control_port: whether user space controls IEEE 802.1X port, i.e.,</span>
<span class="cm"> *	sets/clears %NL80211_STA_FLAG_AUTHORIZED. If true, the driver is</span>
<span class="cm"> *	required to assume that the port is unauthorized until authorized by</span>
<span class="cm"> *	user space. Otherwise, port is marked authorized by default.</span>
<span class="cm"> * @basic_rates: bitmap of basic rates to use when creating the IBSS</span>
<span class="cm"> * @mcast_rate: per-band multicast rate index + 1 (0: disabled)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_ibss_params</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ssid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">channel_type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ssid_len</span><span class="p">,</span> <span class="n">ie_len</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">beacon_interval</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">basic_rates</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">channel_fixed</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">privacy</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">control_port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mcast_rate</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_connect_params - Connection parameters</span>
<span class="cm"> *</span>
<span class="cm"> * This structure provides information needed to complete IEEE 802.11</span>
<span class="cm"> * authentication and association.</span>
<span class="cm"> *</span>
<span class="cm"> * @channel: The channel to use or %NULL if not specified (auto-select based</span>
<span class="cm"> *	on scan results)</span>
<span class="cm"> * @bssid: The AP BSSID or %NULL if not specified (auto-select based on scan</span>
<span class="cm"> *	results)</span>
<span class="cm"> * @ssid: SSID</span>
<span class="cm"> * @ssid_len: Length of ssid in octets</span>
<span class="cm"> * @auth_type: Authentication type (algorithm)</span>
<span class="cm"> * @ie: IEs for association request</span>
<span class="cm"> * @ie_len: Length of assoc_ie in octets</span>
<span class="cm"> * @privacy: indicates whether privacy-enabled APs should be used</span>
<span class="cm"> * @crypto: crypto settings</span>
<span class="cm"> * @key_len: length of WEP key for shared key authentication</span>
<span class="cm"> * @key_idx: index of WEP key for shared key authentication</span>
<span class="cm"> * @key: WEP key for shared key authentication</span>
<span class="cm"> * @flags:  See &amp;enum cfg80211_assoc_req_flags</span>
<span class="cm"> * @bg_scan_period:  Background scan period in seconds</span>
<span class="cm"> *   or -1 to indicate that default value is to be used.</span>
<span class="cm"> * @ht_capa:  HT Capabilities over-rides.  Values set in ht_capa_mask</span>
<span class="cm"> *   will be used in ht_capa.  Un-supported values will be ignored.</span>
<span class="cm"> * @ht_capa_mask:  The bits of ht_capa which are to be used.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_connect_params</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ssid</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ssid_len</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">nl80211_auth_type</span> <span class="n">auth_type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ie_len</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">privacy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg80211_crypto_settings</span> <span class="n">crypto</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">key_len</span><span class="p">,</span> <span class="n">key_idx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bg_scan_period</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_ht_cap</span> <span class="n">ht_capa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee80211_ht_cap</span> <span class="n">ht_capa_mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum wiphy_params_flags - set_wiphy_params bitfield values</span>
<span class="cm"> * @WIPHY_PARAM_RETRY_SHORT: wiphy-&gt;retry_short has changed</span>
<span class="cm"> * @WIPHY_PARAM_RETRY_LONG: wiphy-&gt;retry_long has changed</span>
<span class="cm"> * @WIPHY_PARAM_FRAG_THRESHOLD: wiphy-&gt;frag_threshold has changed</span>
<span class="cm"> * @WIPHY_PARAM_RTS_THRESHOLD: wiphy-&gt;rts_threshold has changed</span>
<span class="cm"> * @WIPHY_PARAM_COVERAGE_CLASS: coverage class changed</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">wiphy_params_flags</span> <span class="p">{</span>
	<span class="n">WIPHY_PARAM_RETRY_SHORT</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">WIPHY_PARAM_RETRY_LONG</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">WIPHY_PARAM_FRAG_THRESHOLD</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">WIPHY_PARAM_RTS_THRESHOLD</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">WIPHY_PARAM_COVERAGE_CLASS</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * cfg80211_bitrate_mask - masks for bitrate control</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_bitrate_mask</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">legacy</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">mcs</span><span class="p">[</span><span class="n">IEEE80211_HT_MCS_MASK_LEN</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">control</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>
<span class="p">};</span>
<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_pmksa - PMK Security Association</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is passed to the set/del_pmksa() method for PMKSA</span>
<span class="cm"> * caching.</span>
<span class="cm"> *</span>
<span class="cm"> * @bssid: The AP&#39;s BSSID.</span>
<span class="cm"> * @pmkid: The PMK material itself.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_pmksa</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">pmkid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_wowlan_trig_pkt_pattern - packet pattern</span>
<span class="cm"> * @mask: bitmask where to match pattern and where to ignore bytes,</span>
<span class="cm"> *	one bit per byte, in same format as nl80211</span>
<span class="cm"> * @pattern: bytes to match where bitmask is 1</span>
<span class="cm"> * @pattern_len: length of pattern (in bytes)</span>
<span class="cm"> *</span>
<span class="cm"> * Internal note: @mask and @pattern are allocated in one chunk of</span>
<span class="cm"> * memory, free @mask only!</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_wowlan_trig_pkt_pattern</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="o">*</span><span class="n">pattern</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pattern_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_wowlan - Wake on Wireless-LAN support info</span>
<span class="cm"> *</span>
<span class="cm"> * This structure defines the enabled WoWLAN triggers for the device.</span>
<span class="cm"> * @any: wake up on any activity -- special trigger if device continues</span>
<span class="cm"> *	operating as normal during suspend</span>
<span class="cm"> * @disconnect: wake up if getting disconnected</span>
<span class="cm"> * @magic_pkt: wake up on receiving magic packet</span>
<span class="cm"> * @patterns: wake up on receiving packet matching a pattern</span>
<span class="cm"> * @n_patterns: number of patterns</span>
<span class="cm"> * @gtk_rekey_failure: wake up on GTK rekey failure</span>
<span class="cm"> * @eap_identity_req: wake up on EAP identity request packet</span>
<span class="cm"> * @four_way_handshake: wake up on 4-way handshake</span>
<span class="cm"> * @rfkill_release: wake up when rfkill is released</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_wowlan</span> <span class="p">{</span>
	<span class="n">bool</span> <span class="n">any</span><span class="p">,</span> <span class="n">disconnect</span><span class="p">,</span> <span class="n">magic_pkt</span><span class="p">,</span> <span class="n">gtk_rekey_failure</span><span class="p">,</span>
	     <span class="n">eap_identity_req</span><span class="p">,</span> <span class="n">four_way_handshake</span><span class="p">,</span>
	     <span class="n">rfkill_release</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg80211_wowlan_trig_pkt_pattern</span> <span class="o">*</span><span class="n">patterns</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_patterns</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_gtk_rekey_data - rekey data</span>
<span class="cm"> * @kek: key encryption key</span>
<span class="cm"> * @kck: key confirmation key</span>
<span class="cm"> * @replay_ctr: replay counter</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_gtk_rekey_data</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">kek</span><span class="p">[</span><span class="n">NL80211_KEK_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">kck</span><span class="p">[</span><span class="n">NL80211_KCK_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">replay_ctr</span><span class="p">[</span><span class="n">NL80211_REPLAY_CTR_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct cfg80211_ops - backend description for wireless configuration</span>
<span class="cm"> *</span>
<span class="cm"> * This struct is registered by fullmac card drivers and/or wireless stacks</span>
<span class="cm"> * in order to handle configuration requests on their interfaces.</span>
<span class="cm"> *</span>
<span class="cm"> * All callbacks except where otherwise noted should return 0</span>
<span class="cm"> * on success or a negative error code.</span>
<span class="cm"> *</span>
<span class="cm"> * All operations are currently invoked under rtnl for consistency with the</span>
<span class="cm"> * wireless extensions but this is subject to reevaluation as soon as this</span>
<span class="cm"> * code is used more widely and we have a first user without wext.</span>
<span class="cm"> *</span>
<span class="cm"> * @suspend: wiphy device needs to be suspended. The variable @wow will</span>
<span class="cm"> *	be %NULL or contain the enabled Wake-on-Wireless triggers that are</span>
<span class="cm"> *	configured for the device.</span>
<span class="cm"> * @resume: wiphy device needs to be resumed</span>
<span class="cm"> * @set_wakeup: Called when WoWLAN is enabled/disabled, use this callback</span>
<span class="cm"> *	to call device_set_wakeup_enable() to enable/disable wakeup from</span>
<span class="cm"> *	the device.</span>
<span class="cm"> *</span>
<span class="cm"> * @add_virtual_intf: create a new virtual interface with the given name,</span>
<span class="cm"> *	must set the struct wireless_dev&#39;s iftype. Beware: You must create</span>
<span class="cm"> *	the new netdev in the wiphy&#39;s network namespace! Returns the netdev,</span>
<span class="cm"> *	or an ERR_PTR.</span>
<span class="cm"> *</span>
<span class="cm"> * @del_virtual_intf: remove the virtual interface determined by ifindex.</span>
<span class="cm"> *</span>
<span class="cm"> * @change_virtual_intf: change type/configuration of virtual interface,</span>
<span class="cm"> *	keep the struct wireless_dev&#39;s iftype updated.</span>
<span class="cm"> *</span>
<span class="cm"> * @add_key: add a key with the given parameters. @mac_addr will be %NULL</span>
<span class="cm"> *	when adding a group key.</span>
<span class="cm"> *</span>
<span class="cm"> * @get_key: get information about the key with the given parameters.</span>
<span class="cm"> *	@mac_addr will be %NULL when requesting information for a group</span>
<span class="cm"> *	key. All pointers given to the @callback function need not be valid</span>
<span class="cm"> *	after it returns. This function should return an error if it is</span>
<span class="cm"> *	not possible to retrieve the key, -ENOENT if it doesn&#39;t exist.</span>
<span class="cm"> *</span>
<span class="cm"> * @del_key: remove a key given the @mac_addr (%NULL for a group key)</span>
<span class="cm"> *	and @key_index, return -ENOENT if the key doesn&#39;t exist.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_default_key: set the default key on an interface</span>
<span class="cm"> *</span>
<span class="cm"> * @set_default_mgmt_key: set the default management frame key on an interface</span>
<span class="cm"> *</span>
<span class="cm"> * @set_rekey_data: give the data necessary for GTK rekeying to the driver</span>
<span class="cm"> *</span>
<span class="cm"> * @start_ap: Start acting in AP mode defined by the parameters.</span>
<span class="cm"> * @change_beacon: Change the beacon parameters for an access point mode</span>
<span class="cm"> *	interface. This should reject the call when AP mode wasn&#39;t started.</span>
<span class="cm"> * @stop_ap: Stop being an AP, including stopping beaconing.</span>
<span class="cm"> *</span>
<span class="cm"> * @add_station: Add a new station.</span>
<span class="cm"> * @del_station: Remove a station; @mac may be NULL to remove all stations.</span>
<span class="cm"> * @change_station: Modify a given station. Note that flags changes are not much</span>
<span class="cm"> *	validated in cfg80211, in particular the auth/assoc/authorized flags</span>
<span class="cm"> *	might come to the driver in invalid combinations -- make sure to check</span>
<span class="cm"> *	them, also against the existing state! Also, supported_rates changes are</span>
<span class="cm"> *	not checked in station mode -- drivers need to reject (or ignore) them</span>
<span class="cm"> *	for anything but TDLS peers.</span>
<span class="cm"> * @get_station: get station information for the station identified by @mac</span>
<span class="cm"> * @dump_station: dump station callback -- resume dump at index @idx</span>
<span class="cm"> *</span>
<span class="cm"> * @add_mpath: add a fixed mesh path</span>
<span class="cm"> * @del_mpath: delete a given mesh path</span>
<span class="cm"> * @change_mpath: change a given mesh path</span>
<span class="cm"> * @get_mpath: get a mesh path for the given parameters</span>
<span class="cm"> * @dump_mpath: dump mesh path callback -- resume dump at index @idx</span>
<span class="cm"> * @join_mesh: join the mesh network with the specified parameters</span>
<span class="cm"> * @leave_mesh: leave the current mesh network</span>
<span class="cm"> *</span>
<span class="cm"> * @get_mesh_config: Get the current mesh configuration</span>
<span class="cm"> *</span>
<span class="cm"> * @update_mesh_config: Update mesh parameters on a running mesh.</span>
<span class="cm"> *	The mask is a bitfield which tells us which parameters to</span>
<span class="cm"> *	set, and which to leave alone.</span>
<span class="cm"> *</span>
<span class="cm"> * @change_bss: Modify parameters for a given BSS.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_txq_params: Set TX queue parameters</span>
<span class="cm"> *</span>
<span class="cm"> * @set_channel: Set channel for a given wireless interface. Some devices</span>
<span class="cm"> *	may support multi-channel operation (by channel hopping) so cfg80211</span>
<span class="cm"> *	doesn&#39;t verify much. Note, however, that the passed netdev may be</span>
<span class="cm"> *	%NULL as well if the user requested changing the channel for the</span>
<span class="cm"> *	device itself, or for a monitor interface.</span>
<span class="cm"> * @get_channel: Get the current operating channel, should return %NULL if</span>
<span class="cm"> *	there&#39;s no single defined operating channel if for example the</span>
<span class="cm"> *	device implements channel hopping for multi-channel virtual interfaces.</span>
<span class="cm"> *</span>
<span class="cm"> * @scan: Request to do a scan. If returning zero, the scan request is given</span>
<span class="cm"> *	the driver, and will be valid until passed to cfg80211_scan_done().</span>
<span class="cm"> *	For scan results, call cfg80211_inform_bss(); you can call this outside</span>
<span class="cm"> *	the scan/scan_done bracket too.</span>
<span class="cm"> *</span>
<span class="cm"> * @auth: Request to authenticate with the specified peer</span>
<span class="cm"> * @assoc: Request to (re)associate with the specified peer</span>
<span class="cm"> * @deauth: Request to deauthenticate from the specified peer</span>
<span class="cm"> * @disassoc: Request to disassociate from the specified peer</span>
<span class="cm"> *</span>
<span class="cm"> * @connect: Connect to the ESS with the specified parameters. When connected,</span>
<span class="cm"> *	call cfg80211_connect_result() with status code %WLAN_STATUS_SUCCESS.</span>
<span class="cm"> *	If the connection fails for some reason, call cfg80211_connect_result()</span>
<span class="cm"> *	with the status from the AP.</span>
<span class="cm"> * @disconnect: Disconnect from the BSS/ESS.</span>
<span class="cm"> *</span>
<span class="cm"> * @join_ibss: Join the specified IBSS (or create if necessary). Once done, call</span>
<span class="cm"> *	cfg80211_ibss_joined(), also call that function when changing BSSID due</span>
<span class="cm"> *	to a merge.</span>
<span class="cm"> * @leave_ibss: Leave the IBSS.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_wiphy_params: Notify that wiphy parameters have changed;</span>
<span class="cm"> *	@changed bitfield (see &amp;enum wiphy_params_flags) describes which values</span>
<span class="cm"> *	have changed. The actual parameter values are available in</span>
<span class="cm"> *	struct wiphy. If returning an error, no value should be changed.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_tx_power: set the transmit power according to the parameters,</span>
<span class="cm"> *	the power passed is in mBm, to get dBm use MBM_TO_DBM().</span>
<span class="cm"> * @get_tx_power: store the current TX power into the dbm variable;</span>
<span class="cm"> *	return 0 if successful</span>
<span class="cm"> *</span>
<span class="cm"> * @set_wds_peer: set the WDS peer for a WDS interface</span>
<span class="cm"> *</span>
<span class="cm"> * @rfkill_poll: polls the hw rfkill line, use cfg80211 reporting</span>
<span class="cm"> *	functions to adjust rfkill hw state</span>
<span class="cm"> *</span>
<span class="cm"> * @dump_survey: get site survey information.</span>
<span class="cm"> *</span>
<span class="cm"> * @remain_on_channel: Request the driver to remain awake on the specified</span>
<span class="cm"> *	channel for the specified duration to complete an off-channel</span>
<span class="cm"> *	operation (e.g., public action frame exchange). When the driver is</span>
<span class="cm"> *	ready on the requested channel, it must indicate this with an event</span>
<span class="cm"> *	notification by calling cfg80211_ready_on_channel().</span>
<span class="cm"> * @cancel_remain_on_channel: Cancel an on-going remain-on-channel operation.</span>
<span class="cm"> *	This allows the operation to be terminated prior to timeout based on</span>
<span class="cm"> *	the duration value.</span>
<span class="cm"> * @mgmt_tx: Transmit a management frame.</span>
<span class="cm"> * @mgmt_tx_cancel_wait: Cancel the wait time from transmitting a management</span>
<span class="cm"> *	frame on another channel</span>
<span class="cm"> *</span>
<span class="cm"> * @testmode_cmd: run a test mode command</span>
<span class="cm"> * @testmode_dump: Implement a test mode dump. The cb-&gt;args[2] and up may be</span>
<span class="cm"> *	used by the function, but 0 and 1 must not be touched. Additionally,</span>
<span class="cm"> *	return error codes other than -ENOBUFS and -ENOENT will terminate the</span>
<span class="cm"> *	dump and return to userspace with an error, so be careful. If any data</span>
<span class="cm"> *	was passed in from userspace then the data/len arguments will be present</span>
<span class="cm"> *	and point to the data contained in %NL80211_ATTR_TESTDATA.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_bitrate_mask: set the bitrate mask configuration</span>
<span class="cm"> *</span>
<span class="cm"> * @set_pmksa: Cache a PMKID for a BSSID. This is mostly useful for fullmac</span>
<span class="cm"> *	devices running firmwares capable of generating the (re) association</span>
<span class="cm"> *	RSN IE. It allows for faster roaming between WPA2 BSSIDs.</span>
<span class="cm"> * @del_pmksa: Delete a cached PMKID.</span>
<span class="cm"> * @flush_pmksa: Flush all cached PMKIDs.</span>
<span class="cm"> * @set_power_mgmt: Configure WLAN power management. A timeout value of -1</span>
<span class="cm"> *	allows the driver to adjust the dynamic ps timeout value.</span>
<span class="cm"> * @set_cqm_rssi_config: Configure connection quality monitor RSSI threshold.</span>
<span class="cm"> * @sched_scan_start: Tell the driver to start a scheduled scan.</span>
<span class="cm"> * @sched_scan_stop: Tell the driver to stop an ongoing scheduled</span>
<span class="cm"> *	scan.  The driver_initiated flag specifies whether the driver</span>
<span class="cm"> *	itself has informed that the scan has stopped.</span>
<span class="cm"> *</span>
<span class="cm"> * @mgmt_frame_register: Notify driver that a management frame type was</span>
<span class="cm"> *	registered. Note that this callback may not sleep, and cannot run</span>
<span class="cm"> *	concurrently with itself.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_antenna: Set antenna configuration (tx_ant, rx_ant) on the device.</span>
<span class="cm"> *	Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may</span>
<span class="cm"> *	reject TX/RX mask combinations they cannot support by returning -EINVAL</span>
<span class="cm"> *	(also see nl80211.h @NL80211_ATTR_WIPHY_ANTENNA_TX).</span>
<span class="cm"> *</span>
<span class="cm"> * @get_antenna: Get current antenna configuration from device (tx_ant, rx_ant).</span>
<span class="cm"> *</span>
<span class="cm"> * @set_ringparam: Set tx and rx ring sizes.</span>
<span class="cm"> *</span>
<span class="cm"> * @get_ringparam: Get tx and rx ring current and maximum sizes.</span>
<span class="cm"> *</span>
<span class="cm"> * @tdls_mgmt: Transmit a TDLS management frame.</span>
<span class="cm"> * @tdls_oper: Perform a high-level TDLS operation (e.g. TDLS link setup).</span>
<span class="cm"> *</span>
<span class="cm"> * @probe_client: probe an associated client, must return a cookie that it</span>
<span class="cm"> *	later passes to cfg80211_probe_status().</span>
<span class="cm"> *</span>
<span class="cm"> * @set_noack_map: Set the NoAck Map for the TIDs.</span>
<span class="cm"> *</span>
<span class="cm"> * @get_et_sset_count:  Ethtool API to get string-set count.</span>
<span class="cm"> *	See @ethtool_ops.get_sset_count</span>
<span class="cm"> *</span>
<span class="cm"> * @get_et_stats:  Ethtool API to get a set of u64 stats.</span>
<span class="cm"> *	See @ethtool_ops.get_ethtool_stats</span>
<span class="cm"> *</span>
<span class="cm"> * @get_et_strings:  Ethtool API to get a set of strings to describe stats</span>
<span class="cm"> *	and perhaps other supported types of ethtool data-sets.</span>
<span class="cm"> *	See @ethtool_ops.get_strings</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_ops</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfg80211_wowlan</span> <span class="o">*</span><span class="n">wow</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_wakeup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enabled</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">add_virtual_intf</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
						<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
						<span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">type</span><span class="p">,</span>
						<span class="n">u32</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">vif_params</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">del_virtual_intf</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">change_virtual_intf</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				       <span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">vif_params</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">add_key</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			   <span class="n">u8</span> <span class="n">key_index</span><span class="p">,</span> <span class="n">bool</span> <span class="n">pairwise</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">key_params</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_key</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			   <span class="n">u8</span> <span class="n">key_index</span><span class="p">,</span> <span class="n">bool</span> <span class="n">pairwise</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key_params</span><span class="o">*</span><span class="p">));</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">del_key</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			   <span class="n">u8</span> <span class="n">key_index</span><span class="p">,</span> <span class="n">bool</span> <span class="n">pairwise</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_default_key</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
				   <span class="n">u8</span> <span class="n">key_index</span><span class="p">,</span> <span class="n">bool</span> <span class="n">unicast</span><span class="p">,</span> <span class="n">bool</span> <span class="n">multicast</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_default_mgmt_key</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
					<span class="n">u8</span> <span class="n">key_index</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">start_ap</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">cfg80211_ap_settings</span> <span class="o">*</span><span class="n">settings</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">change_beacon</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">cfg80211_beacon_data</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">stop_ap</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>


	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">add_station</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">,</span> <span class="k">struct</span> <span class="n">station_parameters</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">del_station</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">change_station</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">,</span> <span class="k">struct</span> <span class="n">station_parameters</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_station</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">,</span> <span class="k">struct</span> <span class="n">station_info</span> <span class="o">*</span><span class="n">sinfo</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">dump_station</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">,</span> <span class="k">struct</span> <span class="n">station_info</span> <span class="o">*</span><span class="n">sinfo</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">add_mpath</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">next_hop</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">del_mpath</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="o">*</span><span class="n">dst</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">change_mpath</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="n">u8</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">next_hop</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_mpath</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">next_hop</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">mpath_info</span> <span class="o">*</span><span class="n">pinfo</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">dump_mpath</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">next_hop</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">mpath_info</span> <span class="o">*</span><span class="n">pinfo</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_mesh_config</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mesh_config</span> <span class="o">*</span><span class="n">conf</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">update_mesh_config</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">mesh_config</span> <span class="o">*</span><span class="n">nconf</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">join_mesh</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">mesh_config</span> <span class="o">*</span><span class="n">conf</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">mesh_setup</span> <span class="o">*</span><span class="n">setup</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">leave_mesh</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">change_bss</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">bss_parameters</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_txq_params</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ieee80211_txq_params</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_channel</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">channel_type</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">scan</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cfg80211_scan_request</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">auth</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cfg80211_auth_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">assoc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">cfg80211_assoc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">deauth</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">cfg80211_deauth_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">disassoc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">cfg80211_disassoc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">cfg80211_connect_params</span> <span class="o">*</span><span class="n">sme</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="n">u16</span> <span class="n">reason_code</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">join_ibss</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">cfg80211_ibss_params</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">leave_ibss</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_wiphy_params</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">u32</span> <span class="n">changed</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_tx_power</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">nl80211_tx_power_setting</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mbm</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_tx_power</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dbm</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_wds_peer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">rfkill_poll</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NL80211_TESTMODE</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">testmode_cmd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">testmode_dump</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_bitrate_mask</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">peer</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">cfg80211_bitrate_mask</span> <span class="o">*</span><span class="n">mask</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">dump_survey</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">survey_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_pmksa</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">cfg80211_pmksa</span> <span class="o">*</span><span class="n">pmksa</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">del_pmksa</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">cfg80211_pmksa</span> <span class="o">*</span><span class="n">pmksa</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">flush_pmksa</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">remain_on_channel</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">channel_type</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">duration</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="o">*</span><span class="n">cookie</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">cancel_remain_on_channel</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					    <span class="n">u64</span> <span class="n">cookie</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">mgmt_tx</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="n">bool</span> <span class="n">offchan</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">channel_type</span><span class="p">,</span>
			  <span class="n">bool</span> <span class="n">channel_type_valid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">,</span>
			  <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">bool</span> <span class="n">no_cck</span><span class="p">,</span>
			  <span class="n">bool</span> <span class="n">dont_wait_for_ack</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">cookie</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">mgmt_tx_cancel_wait</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				       <span class="n">u64</span> <span class="n">cookie</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_power_mgmt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="n">bool</span> <span class="n">enabled</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_cqm_rssi_config</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				       <span class="n">s32</span> <span class="n">rssi_thold</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rssi_hyst</span><span class="p">);</span>

	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">mgmt_frame_register</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				       <span class="n">u16</span> <span class="n">frame_type</span><span class="p">,</span> <span class="n">bool</span> <span class="n">reg</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_antenna</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tx_ant</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rx_ant</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_antenna</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">tx_ant</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">rx_ant</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_ringparam</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">rx</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_ringparam</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="o">*</span><span class="n">tx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">tx_max</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">rx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">rx_max</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">sched_scan_start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">cfg80211_sched_scan_request</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">sched_scan_stop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_rekey_data</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">cfg80211_gtk_rekey_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">tdls_mgmt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="n">u8</span> <span class="o">*</span><span class="n">peer</span><span class="p">,</span> <span class="n">u8</span> <span class="n">action_code</span><span class="p">,</span>  <span class="n">u8</span> <span class="n">dialog_token</span><span class="p">,</span>
			     <span class="n">u16</span> <span class="n">status_code</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">tdls_oper</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="n">u8</span> <span class="o">*</span><span class="n">peer</span><span class="p">,</span> <span class="k">enum</span> <span class="n">nl80211_tdls_operation</span> <span class="n">oper</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">probe_client</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">peer</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">cookie</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_noack_map</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="n">u16</span> <span class="n">noack_map</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_channel</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
					       <span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_et_sset_count</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sset</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_et_stats</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ethtool_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_et_strings</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">sset</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * wireless hardware and networking interfaces structures</span>
<span class="cm"> * and registration/helper functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * enum wiphy_flags - wiphy capability flags</span>
<span class="cm"> *</span>
<span class="cm"> * @WIPHY_FLAG_CUSTOM_REGULATORY:  tells us the driver for this device</span>
<span class="cm"> * 	has its own custom regulatory domain and cannot identify the</span>
<span class="cm"> * 	ISO / IEC 3166 alpha2 it belongs to. When this is enabled</span>
<span class="cm"> * 	we will disregard the first regulatory hint (when the</span>
<span class="cm"> * 	initiator is %REGDOM_SET_BY_CORE).</span>
<span class="cm"> * @WIPHY_FLAG_STRICT_REGULATORY: tells us the driver for this device will</span>
<span class="cm"> *	ignore regulatory domain settings until it gets its own regulatory</span>
<span class="cm"> *	domain via its regulatory_hint() unless the regulatory hint is</span>
<span class="cm"> *	from a country IE. After its gets its own regulatory domain it will</span>
<span class="cm"> *	only allow further regulatory domain settings to further enhance</span>
<span class="cm"> *	compliance. For example if channel 13 and 14 are disabled by this</span>
<span class="cm"> *	regulatory domain no user regulatory domain can enable these channels</span>
<span class="cm"> *	at a later time. This can be used for devices which do not have</span>
<span class="cm"> *	calibration information guaranteed for frequencies or settings</span>
<span class="cm"> *	outside of its regulatory domain. If used in combination with</span>
<span class="cm"> *	WIPHY_FLAG_CUSTOM_REGULATORY the inspected country IE power settings</span>
<span class="cm"> *	will be followed.</span>
<span class="cm"> * @WIPHY_FLAG_DISABLE_BEACON_HINTS: enable this if your driver needs to ensure</span>
<span class="cm"> *	that passive scan flags and beaconing flags may not be lifted by</span>
<span class="cm"> *	cfg80211 due to regulatory beacon hints. For more information on beacon</span>
<span class="cm"> *	hints read the documenation for regulatory_hint_found_beacon()</span>
<span class="cm"> * @WIPHY_FLAG_NETNS_OK: if not set, do not allow changing the netns of this</span>
<span class="cm"> *	wiphy at all</span>
<span class="cm"> * @WIPHY_FLAG_PS_ON_BY_DEFAULT: if set to true, powersave will be enabled</span>
<span class="cm"> *	by default -- this flag will be set depending on the kernel&#39;s default</span>
<span class="cm"> *	on wiphy_new(), but can be changed by the driver if it has a good</span>
<span class="cm"> *	reason to override the default</span>
<span class="cm"> * @WIPHY_FLAG_4ADDR_AP: supports 4addr mode even on AP (with a single station</span>
<span class="cm"> *	on a VLAN interface)</span>
<span class="cm"> * @WIPHY_FLAG_4ADDR_STATION: supports 4addr mode even as a station</span>
<span class="cm"> * @WIPHY_FLAG_CONTROL_PORT_PROTOCOL: This device supports setting the</span>
<span class="cm"> *	control port protocol ethertype. The device also honours the</span>
<span class="cm"> *	control_port_no_encrypt flag.</span>
<span class="cm"> * @WIPHY_FLAG_IBSS_RSN: The device supports IBSS RSN.</span>
<span class="cm"> * @WIPHY_FLAG_MESH_AUTH: The device supports mesh authentication by routing</span>
<span class="cm"> *	auth frames to userspace. See @NL80211_MESH_SETUP_USERSPACE_AUTH.</span>
<span class="cm"> * @WIPHY_FLAG_SUPPORTS_SCHED_SCAN: The device supports scheduled scans.</span>
<span class="cm"> * @WIPHY_FLAG_SUPPORTS_FW_ROAM: The device supports roaming feature in the</span>
<span class="cm"> *	firmware.</span>
<span class="cm"> * @WIPHY_FLAG_AP_UAPSD: The device supports uapsd on AP.</span>
<span class="cm"> * @WIPHY_FLAG_SUPPORTS_TDLS: The device supports TDLS (802.11z) operation.</span>
<span class="cm"> * @WIPHY_FLAG_TDLS_EXTERNAL_SETUP: The device does not handle TDLS (802.11z)</span>
<span class="cm"> *	link setup/discovery operations internally. Setup, discovery and</span>
<span class="cm"> *	teardown packets should be sent through the @NL80211_CMD_TDLS_MGMT</span>
<span class="cm"> *	command. When this flag is not set, @NL80211_CMD_TDLS_OPER should be</span>
<span class="cm"> *	used for asking the driver/firmware to perform a TDLS operation.</span>
<span class="cm"> * @WIPHY_FLAG_HAVE_AP_SME: device integrates AP SME</span>
<span class="cm"> * @WIPHY_FLAG_REPORTS_OBSS: the device will report beacons from other BSSes</span>
<span class="cm"> *	when there are virtual interfaces in AP mode by calling</span>
<span class="cm"> *	cfg80211_report_obss_beacon().</span>
<span class="cm"> * @WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD: When operating as an AP, the device</span>
<span class="cm"> *	responds to probe-requests in hardware.</span>
<span class="cm"> * @WIPHY_FLAG_OFFCHAN_TX: Device supports direct off-channel TX.</span>
<span class="cm"> * @WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL: Device supports remain-on-channel call.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">wiphy_flags</span> <span class="p">{</span>
	<span class="n">WIPHY_FLAG_CUSTOM_REGULATORY</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_STRICT_REGULATORY</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_DISABLE_BEACON_HINTS</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_NETNS_OK</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_PS_ON_BY_DEFAULT</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_4ADDR_AP</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_4ADDR_STATION</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_CONTROL_PORT_PROTOCOL</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_IBSS_RSN</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_MESH_AUTH</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_SUPPORTS_SCHED_SCAN</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">11</span><span class="p">),</span>
	<span class="cm">/* use hole at 12 */</span>
	<span class="n">WIPHY_FLAG_SUPPORTS_FW_ROAM</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_AP_UAPSD</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">14</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_SUPPORTS_TDLS</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_TDLS_EXTERNAL_SETUP</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_HAVE_AP_SME</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">17</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_REPORTS_OBSS</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">18</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">19</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_OFFCHAN_TX</span>			<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
	<span class="n">WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">21</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_iface_limit - limit on certain interface types</span>
<span class="cm"> * @max: maximum number of interfaces of these types</span>
<span class="cm"> * @types: interface types (bits)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_iface_limit</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">max</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">types</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_iface_combination - possible interface combination</span>
<span class="cm"> * @limits: limits for the given interface types</span>
<span class="cm"> * @n_limits: number of limitations</span>
<span class="cm"> * @num_different_channels: can use up to this many different channels</span>
<span class="cm"> * @max_interfaces: maximum number of interfaces in total allowed in this</span>
<span class="cm"> *	group</span>
<span class="cm"> * @beacon_int_infra_match: In this combination, the beacon intervals</span>
<span class="cm"> *	between infrastructure and AP types must match. This is required</span>
<span class="cm"> *	only in special cases.</span>
<span class="cm"> *</span>
<span class="cm"> * These examples can be expressed as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * Allow #STA &lt;= 1, #AP &lt;= 1, matching BI, channels = 1, 2 total:</span>
<span class="cm"> *</span>
<span class="cm"> *  struct ieee80211_iface_limit limits1[] = {</span>
<span class="cm"> *	{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION), },</span>
<span class="cm"> *	{ .max = 1, .types = BIT(NL80211_IFTYPE_AP}, },</span>
<span class="cm"> *  };</span>
<span class="cm"> *  struct ieee80211_iface_combination combination1 = {</span>
<span class="cm"> *	.limits = limits1,</span>
<span class="cm"> *	.n_limits = ARRAY_SIZE(limits1),</span>
<span class="cm"> *	.max_interfaces = 2,</span>
<span class="cm"> *	.beacon_int_infra_match = true,</span>
<span class="cm"> *  };</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Allow #{AP, P2P-GO} &lt;= 8, channels = 1, 8 total:</span>
<span class="cm"> *</span>
<span class="cm"> *  struct ieee80211_iface_limit limits2[] = {</span>
<span class="cm"> *	{ .max = 8, .types = BIT(NL80211_IFTYPE_AP) |</span>
<span class="cm"> *			     BIT(NL80211_IFTYPE_P2P_GO), },</span>
<span class="cm"> *  };</span>
<span class="cm"> *  struct ieee80211_iface_combination combination2 = {</span>
<span class="cm"> *	.limits = limits2,</span>
<span class="cm"> *	.n_limits = ARRAY_SIZE(limits2),</span>
<span class="cm"> *	.max_interfaces = 8,</span>
<span class="cm"> *	.num_different_channels = 1,</span>
<span class="cm"> *  };</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Allow #STA &lt;= 1, #{P2P-client,P2P-GO} &lt;= 3 on two channels, 4 total.</span>
<span class="cm"> * This allows for an infrastructure connection and three P2P connections.</span>
<span class="cm"> *</span>
<span class="cm"> *  struct ieee80211_iface_limit limits3[] = {</span>
<span class="cm"> *	{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION), },</span>
<span class="cm"> *	{ .max = 3, .types = BIT(NL80211_IFTYPE_P2P_GO) |</span>
<span class="cm"> *			     BIT(NL80211_IFTYPE_P2P_CLIENT), },</span>
<span class="cm"> *  };</span>
<span class="cm"> *  struct ieee80211_iface_combination combination3 = {</span>
<span class="cm"> *	.limits = limits3,</span>
<span class="cm"> *	.n_limits = ARRAY_SIZE(limits3),</span>
<span class="cm"> *	.max_interfaces = 4,</span>
<span class="cm"> *	.num_different_channels = 2,</span>
<span class="cm"> *  };</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_iface_combination</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_iface_limit</span> <span class="o">*</span><span class="n">limits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_different_channels</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">max_interfaces</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">n_limits</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">beacon_int_infra_match</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mac_address</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ieee80211_txrx_stypes</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum wiphy_wowlan_support_flags - WoWLAN support flags</span>
<span class="cm"> * @WIPHY_WOWLAN_ANY: supports wakeup for the special &quot;any&quot;</span>
<span class="cm"> *	trigger that keeps the device operating as-is and</span>
<span class="cm"> *	wakes up the host on any activity, for example a</span>
<span class="cm"> *	received packet that passed filtering; note that the</span>
<span class="cm"> *	packet should be preserved in that case</span>
<span class="cm"> * @WIPHY_WOWLAN_MAGIC_PKT: supports wakeup on magic packet</span>
<span class="cm"> *	(see nl80211.h)</span>
<span class="cm"> * @WIPHY_WOWLAN_DISCONNECT: supports wakeup on disconnect</span>
<span class="cm"> * @WIPHY_WOWLAN_SUPPORTS_GTK_REKEY: supports GTK rekeying while asleep</span>
<span class="cm"> * @WIPHY_WOWLAN_GTK_REKEY_FAILURE: supports wakeup on GTK rekey failure</span>
<span class="cm"> * @WIPHY_WOWLAN_EAP_IDENTITY_REQ: supports wakeup on EAP identity request</span>
<span class="cm"> * @WIPHY_WOWLAN_4WAY_HANDSHAKE: supports wakeup on 4-way handshake failure</span>
<span class="cm"> * @WIPHY_WOWLAN_RFKILL_RELEASE: supports wakeup on RF-kill release</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">wiphy_wowlan_support_flags</span> <span class="p">{</span>
	<span class="n">WIPHY_WOWLAN_ANY</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">WIPHY_WOWLAN_MAGIC_PKT</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">WIPHY_WOWLAN_DISCONNECT</span>		<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">WIPHY_WOWLAN_SUPPORTS_GTK_REKEY</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">WIPHY_WOWLAN_GTK_REKEY_FAILURE</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
	<span class="n">WIPHY_WOWLAN_EAP_IDENTITY_REQ</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
	<span class="n">WIPHY_WOWLAN_4WAY_HANDSHAKE</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
	<span class="n">WIPHY_WOWLAN_RFKILL_RELEASE</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct wiphy_wowlan_support - WoWLAN support data</span>
<span class="cm"> * @flags: see &amp;enum wiphy_wowlan_support_flags</span>
<span class="cm"> * @n_patterns: number of supported wakeup patterns</span>
<span class="cm"> *	(see nl80211.h for the pattern definition)</span>
<span class="cm"> * @pattern_max_len: maximum length of each pattern</span>
<span class="cm"> * @pattern_min_len: minimum length of each pattern</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">wiphy_wowlan_support</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_patterns</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pattern_max_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pattern_min_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct wiphy - wireless hardware description</span>
<span class="cm"> * @reg_notifier: the driver&#39;s regulatory notification callback,</span>
<span class="cm"> *	note that if your driver uses wiphy_apply_custom_regulatory()</span>
<span class="cm"> *	the reg_notifier&#39;s request can be passed as NULL</span>
<span class="cm"> * @regd: the driver&#39;s regulatory domain, if one was requested via</span>
<span class="cm"> * 	the regulatory_hint() API. This can be used by the driver</span>
<span class="cm"> *	on the reg_notifier() if it chooses to ignore future</span>
<span class="cm"> *	regulatory domain changes caused by other drivers.</span>
<span class="cm"> * @signal_type: signal type reported in &amp;struct cfg80211_bss.</span>
<span class="cm"> * @cipher_suites: supported cipher suites</span>
<span class="cm"> * @n_cipher_suites: number of supported cipher suites</span>
<span class="cm"> * @retry_short: Retry limit for short frames (dot11ShortRetryLimit)</span>
<span class="cm"> * @retry_long: Retry limit for long frames (dot11LongRetryLimit)</span>
<span class="cm"> * @frag_threshold: Fragmentation threshold (dot11FragmentationThreshold);</span>
<span class="cm"> *	-1 = fragmentation disabled, only odd values &gt;= 256 used</span>
<span class="cm"> * @rts_threshold: RTS threshold (dot11RTSThreshold); -1 = RTS/CTS disabled</span>
<span class="cm"> * @_net: the network namespace this wiphy currently lives in</span>
<span class="cm"> * @perm_addr: permanent MAC address of this device</span>
<span class="cm"> * @addr_mask: If the device supports multiple MAC addresses by masking,</span>
<span class="cm"> *	set this to a mask with variable bits set to 1, e.g. if the last</span>
<span class="cm"> *	four bits are variable then set it to 00:...:00:0f. The actual</span>
<span class="cm"> *	variable bits shall be determined by the interfaces added, with</span>
<span class="cm"> *	interfaces not matching the mask being rejected to be brought up.</span>
<span class="cm"> * @n_addresses: number of addresses in @addresses.</span>
<span class="cm"> * @addresses: If the device has more than one address, set this pointer</span>
<span class="cm"> *	to a list of addresses (6 bytes each). The first one will be used</span>
<span class="cm"> *	by default for perm_addr. In this case, the mask should be set to</span>
<span class="cm"> *	all-zeroes. In this case it is assumed that the device can handle</span>
<span class="cm"> *	the same number of arbitrary MAC addresses.</span>
<span class="cm"> * @registered: protects -&gt;resume and -&gt;suspend sysfs callbacks against</span>
<span class="cm"> *	unregister hardware</span>
<span class="cm"> * @debugfsdir: debugfs directory used for this wiphy, will be renamed</span>
<span class="cm"> *	automatically on wiphy renames</span>
<span class="cm"> * @dev: (virtual) struct device for this wiphy</span>
<span class="cm"> * @registered: helps synchronize suspend/resume with wiphy unregister</span>
<span class="cm"> * @wext: wireless extension handlers</span>
<span class="cm"> * @priv: driver private data (sized according to wiphy_new() parameter)</span>
<span class="cm"> * @interface_modes: bitmask of interfaces types valid for this wiphy,</span>
<span class="cm"> *	must be set by driver</span>
<span class="cm"> * @iface_combinations: Valid interface combinations array, should not</span>
<span class="cm"> *	list single interface types.</span>
<span class="cm"> * @n_iface_combinations: number of entries in @iface_combinations array.</span>
<span class="cm"> * @software_iftypes: bitmask of software interface types, these are not</span>
<span class="cm"> *	subject to any restrictions since they are purely managed in SW.</span>
<span class="cm"> * @flags: wiphy flags, see &amp;enum wiphy_flags</span>
<span class="cm"> * @features: features advertised to nl80211, see &amp;enum nl80211_feature_flags.</span>
<span class="cm"> * @bss_priv_size: each BSS struct has private data allocated with it,</span>
<span class="cm"> *	this variable determines its size</span>
<span class="cm"> * @max_scan_ssids: maximum number of SSIDs the device can scan for in</span>
<span class="cm"> *	any given scan</span>
<span class="cm"> * @max_sched_scan_ssids: maximum number of SSIDs the device can scan</span>
<span class="cm"> *	for in any given scheduled scan</span>
<span class="cm"> * @max_match_sets: maximum number of match sets the device can handle</span>
<span class="cm"> *	when performing a scheduled scan, 0 if filtering is not</span>
<span class="cm"> *	supported.</span>
<span class="cm"> * @max_scan_ie_len: maximum length of user-controlled IEs device can</span>
<span class="cm"> *	add to probe request frames transmitted during a scan, must not</span>
<span class="cm"> *	include fixed IEs like supported rates</span>
<span class="cm"> * @max_sched_scan_ie_len: same as max_scan_ie_len, but for scheduled</span>
<span class="cm"> *	scans</span>
<span class="cm"> * @coverage_class: current coverage class</span>
<span class="cm"> * @fw_version: firmware version for ethtool reporting</span>
<span class="cm"> * @hw_version: hardware version for ethtool reporting</span>
<span class="cm"> * @max_num_pmkids: maximum number of PMKIDs supported by device</span>
<span class="cm"> * @privid: a pointer that drivers can use to identify if an arbitrary</span>
<span class="cm"> *	wiphy is theirs, e.g. in global notifiers</span>
<span class="cm"> * @bands: information about bands/channels supported by this device</span>
<span class="cm"> *</span>
<span class="cm"> * @mgmt_stypes: bitmasks of frame subtypes that can be subscribed to or</span>
<span class="cm"> *	transmitted through nl80211, points to an array indexed by interface</span>
<span class="cm"> *	type</span>
<span class="cm"> *</span>
<span class="cm"> * @available_antennas_tx: bitmap of antennas which are available to be</span>
<span class="cm"> *	configured as TX antennas. Antenna configuration commands will be</span>
<span class="cm"> *	rejected unless this or @available_antennas_rx is set.</span>
<span class="cm"> *</span>
<span class="cm"> * @available_antennas_rx: bitmap of antennas which are available to be</span>
<span class="cm"> *	configured as RX antennas. Antenna configuration commands will be</span>
<span class="cm"> *	rejected unless this or @available_antennas_tx is set.</span>
<span class="cm"> *</span>
<span class="cm"> * @probe_resp_offload:</span>
<span class="cm"> *	 Bitmap of supported protocols for probe response offloading.</span>
<span class="cm"> *	 See &amp;enum nl80211_probe_resp_offload_support_attr. Only valid</span>
<span class="cm"> *	 when the wiphy flag @WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD is set.</span>
<span class="cm"> *</span>
<span class="cm"> * @max_remain_on_channel_duration: Maximum time a remain-on-channel operation</span>
<span class="cm"> *	may request, if implemented.</span>
<span class="cm"> *</span>
<span class="cm"> * @wowlan: WoWLAN support information</span>
<span class="cm"> *</span>
<span class="cm"> * @ap_sme_capa: AP SME capabilities, flags from &amp;enum nl80211_ap_sme_features.</span>
<span class="cm"> * @ht_capa_mod_mask:  Specify what ht_cap values can be over-ridden.</span>
<span class="cm"> *	If null, then none can be over-ridden.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">wiphy</span> <span class="p">{</span>
	<span class="cm">/* assign these fields before you register the wiphy */</span>

	<span class="cm">/* permanent MAC address(es) */</span>
	<span class="n">u8</span> <span class="n">perm_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">addr_mask</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">mac_address</span> <span class="o">*</span><span class="n">addresses</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_txrx_stypes</span> <span class="o">*</span><span class="n">mgmt_stypes</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_iface_combination</span> <span class="o">*</span><span class="n">iface_combinations</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_iface_combinations</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">software_iftypes</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">n_addresses</span><span class="p">;</span>

	<span class="cm">/* Supported interface modes, OR together BIT(NL80211_IFTYPE_...) */</span>
	<span class="n">u16</span> <span class="n">interface_modes</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">flags</span><span class="p">,</span> <span class="n">features</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">ap_sme_capa</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">cfg80211_signal_type</span> <span class="n">signal_type</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">bss_priv_size</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_scan_ssids</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_sched_scan_ssids</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_match_sets</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">max_scan_ie_len</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">max_sched_scan_ie_len</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">n_cipher_suites</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">cipher_suites</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">retry_short</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">retry_long</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frag_threshold</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rts_threshold</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">coverage_class</span><span class="p">;</span>

	<span class="kt">char</span> <span class="n">fw_version</span><span class="p">[</span><span class="n">ETHTOOL_BUSINFO_LEN</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">hw_version</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">wiphy_wowlan_support</span> <span class="n">wowlan</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">max_remain_on_channel_duration</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">max_num_pmkids</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">available_antennas_tx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">available_antennas_rx</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Bitmap of supported protocols for probe response offloading</span>
<span class="cm">	 * see &amp;enum nl80211_probe_resp_offload_support_attr. Only valid</span>
<span class="cm">	 * when the wiphy flag @WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD is set.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">probe_resp_offload</span><span class="p">;</span>

	<span class="cm">/* If multiple wiphys are registered and you&#39;re handed e.g.</span>
<span class="cm">	 * a regular netdev with assigned ieee80211_ptr, you won&#39;t</span>
<span class="cm">	 * know whether it points to a wiphy your driver has registered</span>
<span class="cm">	 * or not. Assign this to something global to your driver to</span>
<span class="cm">	 * help determine whether you own this wiphy or not. */</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">privid</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">bands</span><span class="p">[</span><span class="n">IEEE80211_NUM_BANDS</span><span class="p">];</span>

	<span class="cm">/* Lets us get back the wiphy on the callback */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">reg_notifier</span><span class="p">)(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">regulatory_request</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>

	<span class="cm">/* fields below are read-only, assigned by cfg80211 */</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">regd</span><span class="p">;</span>

	<span class="cm">/* the item in /sys/class/ieee80211/ points to this,</span>
<span class="cm">	 * you need use set_wiphy_dev() (see below) */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* protects -&gt;resume, -&gt;suspend sysfs callbacks against unregister hw */</span>
	<span class="n">bool</span> <span class="n">registered</span><span class="p">;</span>

	<span class="cm">/* dir in debugfs: ieee80211/&lt;wiphyname&gt; */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfsdir</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_ht_cap</span> <span class="o">*</span><span class="n">ht_capa_mod_mask</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NET_NS</span>
	<span class="cm">/* the network namespace this phy lives in currently */</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">_net</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_CFG80211_WEXT</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iw_handler_def</span> <span class="o">*</span><span class="n">wext</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="kt">char</span> <span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="n">NETDEV_ALIGN</span><span class="p">)));</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">wiphy_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">read_pnet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">_net</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wiphy_net_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_pnet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">_net</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wiphy_priv - return priv from wiphy</span>
<span class="cm"> *</span>
<span class="cm"> * @wiphy: the wiphy whose priv pointer to return</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">wiphy_priv</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">wiphy</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * priv_to_wiphy - return the wiphy containing the priv</span>
<span class="cm"> *</span>
<span class="cm"> * @priv: a pointer previously returned by wiphy_priv</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="nf">priv_to_wiphy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wiphy</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * set_wiphy_dev - set device pointer for wiphy</span>
<span class="cm"> *</span>
<span class="cm"> * @wiphy: The wiphy whose device to bind</span>
<span class="cm"> * @dev: The device to parent it to</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_wiphy_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wiphy_dev - get wiphy dev pointer</span>
<span class="cm"> *</span>
<span class="cm"> * @wiphy: The wiphy whose device struct to look up</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">wiphy_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wiphy_name - get wiphy name</span>
<span class="cm"> *</span>
<span class="cm"> * @wiphy: The wiphy whose name to return</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">wiphy_name</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wiphy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wiphy_new - create a new wiphy for use with cfg80211</span>
<span class="cm"> *</span>
<span class="cm"> * @ops: The configuration operations for this device</span>
<span class="cm"> * @sizeof_priv: The size of the private area to allocate</span>
<span class="cm"> *</span>
<span class="cm"> * Create a new wiphy and associate the given operations with it.</span>
<span class="cm"> * @sizeof_priv bytes are allocated for private use.</span>
<span class="cm"> *</span>
<span class="cm"> * The returned pointer must be assigned to each netdev&#39;s</span>
<span class="cm"> * ieee80211_ptr for proper operation.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy_new</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cfg80211_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sizeof_priv</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * wiphy_register - register a wiphy with cfg80211</span>
<span class="cm"> *</span>
<span class="cm"> * @wiphy: The wiphy to register.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a non-negative wiphy index or a negative error code.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wiphy_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * wiphy_unregister - deregister a wiphy from cfg80211</span>
<span class="cm"> *</span>
<span class="cm"> * @wiphy: The wiphy to unregister.</span>
<span class="cm"> *</span>
<span class="cm"> * After this call, no more requests can be made with this priv</span>
<span class="cm"> * pointer, but the call may sleep to wait for an outstanding</span>
<span class="cm"> * request that is being handled.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wiphy_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * wiphy_free - free wiphy</span>
<span class="cm"> *</span>
<span class="cm"> * @wiphy: The wiphy to free</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wiphy_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">);</span>

<span class="cm">/* internal structs */</span>
<span class="k">struct</span> <span class="n">cfg80211_conn</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cfg80211_internal_bss</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cfg80211_cached_keys</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct wireless_dev - wireless per-netdev state</span>
<span class="cm"> *</span>
<span class="cm"> * This structure must be allocated by the driver/stack</span>
<span class="cm"> * that uses the ieee80211_ptr field in struct net_device</span>
<span class="cm"> * (this is intentional so it can be allocated along with</span>
<span class="cm"> * the netdev.)</span>
<span class="cm"> *</span>
<span class="cm"> * @wiphy: pointer to hardware description</span>
<span class="cm"> * @iftype: interface type</span>
<span class="cm"> * @list: (private) Used to collect the interfaces</span>
<span class="cm"> * @netdev: (private) Used to reference back to the netdev</span>
<span class="cm"> * @current_bss: (private) Used by the internal configuration code</span>
<span class="cm"> * @channel: (private) Used by the internal configuration code to track</span>
<span class="cm"> *	user-set AP, monitor and WDS channels for wireless extensions</span>
<span class="cm"> * @bssid: (private) Used by the internal configuration code</span>
<span class="cm"> * @ssid: (private) Used by the internal configuration code</span>
<span class="cm"> * @ssid_len: (private) Used by the internal configuration code</span>
<span class="cm"> * @mesh_id_len: (private) Used by the internal configuration code</span>
<span class="cm"> * @mesh_id_up_len: (private) Used by the internal configuration code</span>
<span class="cm"> * @wext: (private) Used by the internal wireless extensions compat code</span>
<span class="cm"> * @use_4addr: indicates 4addr mode is used on this interface, must be</span>
<span class="cm"> *	set by driver (if supported) on add_interface BEFORE registering the</span>
<span class="cm"> *	netdev and may otherwise be used by driver read-only, will be update</span>
<span class="cm"> *	by cfg80211 on change_interface</span>
<span class="cm"> * @mgmt_registrations: list of registrations for management frames</span>
<span class="cm"> * @mgmt_registrations_lock: lock for the list</span>
<span class="cm"> * @mtx: mutex used to lock data in this struct</span>
<span class="cm"> * @cleanup_work: work struct used for cleanup that can&#39;t be done directly</span>
<span class="cm"> * @beacon_interval: beacon interval used on this device for transmitting</span>
<span class="cm"> *	beacons, 0 when not valid</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">wireless_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">iftype</span><span class="p">;</span>

	<span class="cm">/* the remainder of this struct should be private to cfg80211 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">mgmt_registrations</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">mgmt_registrations_lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">cleanup_work</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">use_4addr</span><span class="p">;</span>

	<span class="cm">/* currently used for IBSS and SME - might be rearranged later */</span>
	<span class="n">u8</span> <span class="n">ssid</span><span class="p">[</span><span class="n">IEEE80211_MAX_SSID_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">ssid_len</span><span class="p">,</span> <span class="n">mesh_id_len</span><span class="p">,</span> <span class="n">mesh_id_up_len</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">CFG80211_SME_IDLE</span><span class="p">,</span>
		<span class="n">CFG80211_SME_CONNECTING</span><span class="p">,</span>
		<span class="n">CFG80211_SME_CONNECTED</span><span class="p">,</span>
	<span class="p">}</span> <span class="n">sme_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg80211_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfg80211_cached_keys</span> <span class="o">*</span><span class="n">connect_keys</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">event_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">event_lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">cfg80211_internal_bss</span> <span class="o">*</span><span class="n">current_bss</span><span class="p">;</span> <span class="cm">/* associated / joined */</span>
	<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">ps</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ps_timeout</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">beacon_interval</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">ap_unexpected_nlpid</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_CFG80211_WEXT</span>
	<span class="cm">/* wext data */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cfg80211_ibss_params</span> <span class="n">ibss</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cfg80211_connect_params</span> <span class="n">connect</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cfg80211_cached_keys</span> <span class="o">*</span><span class="n">keys</span><span class="p">;</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">ie_len</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">bssid</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">],</span> <span class="n">prev_bssid</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
		<span class="n">u8</span> <span class="n">ssid</span><span class="p">[</span><span class="n">IEEE80211_MAX_SSID_LEN</span><span class="p">];</span>
		<span class="n">s8</span> <span class="n">default_key</span><span class="p">,</span> <span class="n">default_mgmt_key</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">prev_bssid_valid</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">wext</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * wdev_priv - return wiphy priv from wireless_dev</span>
<span class="cm"> *</span>
<span class="cm"> * @wdev: The wireless device whose wiphy&#39;s priv pointer to return</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">wdev_priv</span><span class="p">(</span><span class="k">struct</span> <span class="n">wireless_dev</span> <span class="o">*</span><span class="n">wdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">wdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">wiphy_priv</span><span class="p">(</span><span class="n">wdev</span><span class="o">-&gt;</span><span class="n">wiphy</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Utility functions</span>
<span class="cm"> *</span>
<span class="cm"> * cfg80211 offers a number of utility functions that can be useful.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_channel_to_frequency - convert channel number to frequency</span>
<span class="cm"> * @chan: channel number</span>
<span class="cm"> * @band: band, necessary due to channel number overlap</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ieee80211_channel_to_frequency</span><span class="p">(</span><span class="kt">int</span> <span class="n">chan</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ieee80211_band</span> <span class="n">band</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_frequency_to_channel - convert frequency to channel number</span>
<span class="cm"> * @freq: center frequency</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ieee80211_frequency_to_channel</span><span class="p">(</span><span class="kt">int</span> <span class="n">freq</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Name indirection necessary because the ieee80211 code also has</span>
<span class="cm"> * a function named &quot;ieee80211_get_channel&quot;, so if you include</span>
<span class="cm"> * cfg80211&#39;s header file you get cfg80211&#39;s version, if you try</span>
<span class="cm"> * to include both header files you&#39;ll (rightfully!) get a symbol</span>
<span class="cm"> * clash.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">__ieee80211_get_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
							 <span class="kt">int</span> <span class="n">freq</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * ieee80211_get_channel - get channel struct from wiphy for specified frequency</span>
<span class="cm"> * @wiphy: the struct wiphy to get the channel for</span>
<span class="cm"> * @freq: the center frequency of the channel</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span>
<span class="nf">ieee80211_get_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__ieee80211_get_channel</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_get_response_rate - get basic rate for a given rate</span>
<span class="cm"> *</span>
<span class="cm"> * @sband: the band to look for rates in</span>
<span class="cm"> * @basic_rates: bitmap of basic rates</span>
<span class="cm"> * @bitrate: the bitrate for which to find the basic rate</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the basic rate corresponding to a given</span>
<span class="cm"> * bitrate, that is the next lower bitrate contained in the basic</span>
<span class="cm"> * rate map, which is, for this function, given as a bitmap of</span>
<span class="cm"> * indices of rates in the band&#39;s bitrate table.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ieee80211_rate</span> <span class="o">*</span>
<span class="n">ieee80211_get_response_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ieee80211_supported_band</span> <span class="o">*</span><span class="n">sband</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">basic_rates</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bitrate</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Radiotap parsing functions -- for controlled injection support</span>
<span class="cm"> *</span>
<span class="cm"> * Implemented in net/wireless/radiotap.c</span>
<span class="cm"> * Documentation in Documentation/networking/radiotap-headers.txt</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">radiotap_align_size</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">align</span><span class="o">:</span><span class="mi">4</span><span class="p">,</span> <span class="n">size</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ieee80211_radiotap_namespace</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">radiotap_align_size</span> <span class="o">*</span><span class="n">align_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_bits</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">oui</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">subns</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ieee80211_radiotap_vendor_namespaces</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_radiotap_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_ns</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ieee80211_radiotap_iterator - tracks walk thru present radiotap args</span>
<span class="cm"> * @this_arg_index: index of current arg, valid after each successful call</span>
<span class="cm"> *	to ieee80211_radiotap_iterator_next()</span>
<span class="cm"> * @this_arg: pointer to current radiotap arg; it is valid after each</span>
<span class="cm"> *	call to ieee80211_radiotap_iterator_next() but also after</span>
<span class="cm"> *	ieee80211_radiotap_iterator_init() where it will point to</span>
<span class="cm"> *	the beginning of the actual data portion</span>
<span class="cm"> * @this_arg_size: length of the current arg, for convenience</span>
<span class="cm"> * @current_namespace: pointer to the current namespace definition</span>
<span class="cm"> *	(or internally %NULL if the current namespace is unknown)</span>
<span class="cm"> * @is_radiotap_ns: indicates whether the current namespace is the default</span>
<span class="cm"> *	radiotap namespace or not</span>
<span class="cm"> *</span>
<span class="cm"> * @_rtheader: pointer to the radiotap header we are walking through</span>
<span class="cm"> * @_max_length: length of radiotap header in cpu byte ordering</span>
<span class="cm"> * @_arg_index: next argument index</span>
<span class="cm"> * @_arg: next argument pointer</span>
<span class="cm"> * @_next_bitmap: internal pointer to next present u32</span>
<span class="cm"> * @_bitmap_shifter: internal shifter for curr u32 bitmap, b0 set == arg present</span>
<span class="cm"> * @_vns: vendor namespace definitions</span>
<span class="cm"> * @_next_ns_data: beginning of the next namespace&#39;s data</span>
<span class="cm"> * @_reset_on_ext: internal; reset the arg index to 0 when going to the</span>
<span class="cm"> *	next bitmap word</span>
<span class="cm"> *</span>
<span class="cm"> * Describes the radiotap parser state. Fields prefixed with an underscore</span>
<span class="cm"> * must not be used by users of the parser, only by the parser internally.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ieee80211_radiotap_iterator</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ieee80211_radiotap_header</span> <span class="o">*</span><span class="n">_rtheader</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_radiotap_vendor_namespaces</span> <span class="o">*</span><span class="n">_vns</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_radiotap_namespace</span> <span class="o">*</span><span class="n">current_namespace</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">_arg</span><span class="p">,</span> <span class="o">*</span><span class="n">_next_ns_data</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">_next_bitmap</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">this_arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">this_arg_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">this_arg_size</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">is_radiotap_ns</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">_max_length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">_arg_index</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">_bitmap_shifter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">_reset_on_ext</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ieee80211_radiotap_iterator_init</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">ieee80211_radiotap_iterator</span> <span class="o">*</span><span class="n">iterator</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ieee80211_radiotap_header</span> <span class="o">*</span><span class="n">radiotap_header</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">max_length</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_radiotap_vendor_namespaces</span> <span class="o">*</span><span class="n">vns</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ieee80211_radiotap_iterator_next</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">ieee80211_radiotap_iterator</span> <span class="o">*</span><span class="n">iterator</span><span class="p">);</span>


<span class="k">extern</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">rfc1042_header</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bridge_tunnel_header</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_get_hdrlen_from_skb - get header length from data</span>
<span class="cm"> *</span>
<span class="cm"> * Given an skb with a raw 802.11 header at the data pointer this function</span>
<span class="cm"> * returns the 802.11 header length in bytes (not including encryption</span>
<span class="cm"> * headers). If the data in the sk_buff is too short to contain a valid 802.11</span>
<span class="cm"> * header the function returns 0.</span>
<span class="cm"> *</span>
<span class="cm"> * @skb: the frame</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ieee80211_get_hdrlen_from_skb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_hdrlen - get header length in bytes from frame control</span>
<span class="cm"> * @fc: frame control field in little-endian format</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__attribute_const__</span> <span class="n">ieee80211_hdrlen</span><span class="p">(</span><span class="n">__le16</span> <span class="n">fc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Data path helpers</span>
<span class="cm"> *</span>
<span class="cm"> * In addition to generic utilities, cfg80211 also offers</span>
<span class="cm"> * functions that help implement the data path for devices</span>
<span class="cm"> * that do not do the 802.11/802.3 conversion on the device.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_data_to_8023 - convert an 802.11 data frame to 802.3</span>
<span class="cm"> * @skb: the 802.11 data frame</span>
<span class="cm"> * @addr: the device MAC address</span>
<span class="cm"> * @iftype: the virtual interface type</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ieee80211_data_to_8023</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			   <span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">iftype</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_data_from_8023 - convert an 802.3 frame to 802.11</span>
<span class="cm"> * @skb: the 802.3 frame</span>
<span class="cm"> * @addr: the device MAC address</span>
<span class="cm"> * @iftype: the virtual interface type</span>
<span class="cm"> * @bssid: the network bssid (used only for iftype STATION and ADHOC)</span>
<span class="cm"> * @qos: build 802.11 QoS data frame</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ieee80211_data_from_8023</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">iftype</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">,</span> <span class="n">bool</span> <span class="n">qos</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ieee80211_amsdu_to_8023s - decode an IEEE 802.11n A-MSDU frame</span>
<span class="cm"> *</span>
<span class="cm"> * Decode an IEEE 802.11n A-MSDU frame and convert it to a list of</span>
<span class="cm"> * 802.3 frames. The @list will be empty if the decode fails. The</span>
<span class="cm"> * @skb is consumed after the function returns.</span>
<span class="cm"> *</span>
<span class="cm"> * @skb: The input IEEE 802.11n A-MSDU frame.</span>
<span class="cm"> * @list: The output list of 802.3 frames. It must be allocated and</span>
<span class="cm"> *	initialized by by the caller.</span>
<span class="cm"> * @addr: The device MAC address.</span>
<span class="cm"> * @iftype: The device interface type.</span>
<span class="cm"> * @extra_headroom: The hardware extra headroom for SKBs in the @list.</span>
<span class="cm"> * @has_80211_header: Set it true if SKB is with IEEE 802.11 header.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ieee80211_amsdu_to_8023s</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
			      <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">nl80211_iftype</span> <span class="n">iftype</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">extra_headroom</span><span class="p">,</span>
			      <span class="n">bool</span> <span class="n">has_80211_header</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_classify8021d - determine the 802.1p/1d tag for a data frame</span>
<span class="cm"> * @skb: the data frame</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cfg80211_classify8021d</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_find_ie - find information element in data</span>
<span class="cm"> *</span>
<span class="cm"> * @eid: element ID</span>
<span class="cm"> * @ies: data consisting of IEs</span>
<span class="cm"> * @len: length of data</span>
<span class="cm"> *</span>
<span class="cm"> * This function will return %NULL if the element ID could</span>
<span class="cm"> * not be found or if the element is invalid (claims to be</span>
<span class="cm"> * longer than the given data), or a pointer to the first byte</span>
<span class="cm"> * of the requested element, that is the byte containing the</span>
<span class="cm"> * element ID. There are no checks on the element length</span>
<span class="cm"> * other than having to fit into the given data.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">cfg80211_find_ie</span><span class="p">(</span><span class="n">u8</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ies</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_find_vendor_ie - find vendor specific information element in data</span>
<span class="cm"> *</span>
<span class="cm"> * @oui: vendor OUI</span>
<span class="cm"> * @oui_type: vendor-specific OUI type</span>
<span class="cm"> * @ies: data consisting of IEs</span>
<span class="cm"> * @len: length of data</span>
<span class="cm"> *</span>
<span class="cm"> * This function will return %NULL if the vendor specific element ID</span>
<span class="cm"> * could not be found or if the element is invalid (claims to be</span>
<span class="cm"> * longer than the given data), or a pointer to the first byte</span>
<span class="cm"> * of the requested element, that is the byte containing the</span>
<span class="cm"> * element ID. There are no checks on the element length</span>
<span class="cm"> * other than having to fit into the given data.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">cfg80211_find_vendor_ie</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oui</span><span class="p">,</span> <span class="n">u8</span> <span class="n">oui_type</span><span class="p">,</span>
				  <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ies</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: Regulatory enforcement infrastructure</span>
<span class="cm"> *</span>
<span class="cm"> * TODO</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * regulatory_hint - driver hint to the wireless core a regulatory domain</span>
<span class="cm"> * @wiphy: the wireless device giving the hint (used only for reporting</span>
<span class="cm"> *	conflicts)</span>
<span class="cm"> * @alpha2: the ISO/IEC 3166 alpha2 the driver claims its regulatory domain</span>
<span class="cm"> * 	should be in. If @rd is set this should be NULL. Note that if you</span>
<span class="cm"> * 	set this to NULL you should still set rd-&gt;alpha2 to some accepted</span>
<span class="cm"> * 	alpha2.</span>
<span class="cm"> *</span>
<span class="cm"> * Wireless drivers can use this function to hint to the wireless core</span>
<span class="cm"> * what it believes should be the current regulatory domain by</span>
<span class="cm"> * giving it an ISO/IEC 3166 alpha2 country code it knows its regulatory</span>
<span class="cm"> * domain should be in or by providing a completely build regulatory domain.</span>
<span class="cm"> * If the driver provides an ISO/IEC 3166 alpha2 userspace will be queried</span>
<span class="cm"> * for a regulatory domain structure for the respective country.</span>
<span class="cm"> *</span>
<span class="cm"> * The wiphy must have been registered to cfg80211 prior to this call.</span>
<span class="cm"> * For cfg80211 drivers this means you must first use wiphy_register(),</span>
<span class="cm"> * for mac80211 drivers you must first use ieee80211_register_hw().</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers should check the return value, its possible you can get</span>
<span class="cm"> * an -ENOMEM.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">regulatory_hint</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpha2</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * wiphy_apply_custom_regulatory - apply a custom driver regulatory domain</span>
<span class="cm"> * @wiphy: the wireless device we want to process the regulatory domain on</span>
<span class="cm"> * @regd: the custom regulatory domain to use for this wiphy</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers can sometimes have custom regulatory domains which do not apply</span>
<span class="cm"> * to a specific country. Drivers can use this to apply such custom regulatory</span>
<span class="cm"> * domains. This routine must be called prior to wiphy registration. The</span>
<span class="cm"> * custom regulatory domain will be trusted completely and as such previous</span>
<span class="cm"> * default channel settings will be disregarded. If no rule is found for a</span>
<span class="cm"> * channel on the regulatory domain the channel will be disabled.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wiphy_apply_custom_regulatory</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_regdomain</span> <span class="o">*</span><span class="n">regd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * freq_reg_info - get regulatory information for the given frequency</span>
<span class="cm"> * @wiphy: the wiphy for which we want to process this rule for</span>
<span class="cm"> * @center_freq: Frequency in KHz for which we want regulatory information for</span>
<span class="cm"> * @desired_bw_khz: the desired max bandwidth you want to use per</span>
<span class="cm"> *	channel. Note that this is still 20 MHz if you want to use HT40</span>
<span class="cm"> *	as HT40 makes use of two channels for its 40 MHz width bandwidth.</span>
<span class="cm"> *	If set to 0 we&#39;ll assume you want the standard 20 MHz.</span>
<span class="cm"> * @reg_rule: the regulatory rule which we have for this frequency</span>
<span class="cm"> *</span>
<span class="cm"> * Use this function to get the regulatory rule for a specific frequency on</span>
<span class="cm"> * a given wireless device. If the device has a specific regulatory domain</span>
<span class="cm"> * it wants to follow we respect that unless a country IE has been received</span>
<span class="cm"> * and processed already.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if it was able to find a valid regulatory rule which does</span>
<span class="cm"> * apply to the given center_freq otherwise it returns non-zero. It will</span>
<span class="cm"> * also return -ERANGE if we determine the given center_freq does not even have</span>
<span class="cm"> * a regulatory rule for a frequency range in the center_freq&#39;s band. See</span>
<span class="cm"> * freq_in_rule_band() for our current definition of a band -- this is purely</span>
<span class="cm"> * subjective and right now its 802.11 specific.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">freq_reg_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">center_freq</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">desired_bw_khz</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">ieee80211_reg_rule</span> <span class="o">**</span><span class="n">reg_rule</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * callbacks for asynchronous cfg80211 methods, notification</span>
<span class="cm"> * functions and BSS handling helpers</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_scan_done - notify that scan finished</span>
<span class="cm"> *</span>
<span class="cm"> * @request: the corresponding scan request</span>
<span class="cm"> * @aborted: set to true if the scan was aborted for any reason,</span>
<span class="cm"> *	userspace will be notified of that</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_scan_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfg80211_scan_request</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span> <span class="n">bool</span> <span class="n">aborted</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_sched_scan_results - notify that new scan results are available</span>
<span class="cm"> *</span>
<span class="cm"> * @wiphy: the wiphy which got scheduled scan results</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_sched_scan_results</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_sched_scan_stopped - notify that the scheduled scan has stopped</span>
<span class="cm"> *</span>
<span class="cm"> * @wiphy: the wiphy on which the scheduled scan stopped</span>
<span class="cm"> *</span>
<span class="cm"> * The driver can call this function to inform cfg80211 that the</span>
<span class="cm"> * scheduled scan had to be stopped, for whatever reason.  The driver</span>
<span class="cm"> * is then called back via the sched_scan_stop operation when done.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_sched_scan_stopped</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_inform_bss_frame - inform cfg80211 of a received BSS frame</span>
<span class="cm"> *</span>
<span class="cm"> * @wiphy: the wiphy reporting the BSS</span>
<span class="cm"> * @channel: The channel the frame was received on</span>
<span class="cm"> * @mgmt: the management frame (probe response or beacon)</span>
<span class="cm"> * @len: length of the management frame</span>
<span class="cm"> * @signal: the signal strength, type depends on the wiphy&#39;s signal_type</span>
<span class="cm"> * @gfp: context flags</span>
<span class="cm"> *</span>
<span class="cm"> * This informs cfg80211 that BSS information was found and</span>
<span class="cm"> * the BSS should be updated/added.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Returns a referenced struct, must be released with cfg80211_put_bss()!</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span> <span class="n">__must_check</span>
<span class="n">cfg80211_inform_bss_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ieee80211_mgmt</span> <span class="o">*</span><span class="n">mgmt</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			  <span class="n">s32</span> <span class="n">signal</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_inform_bss - inform cfg80211 of a new BSS</span>
<span class="cm"> *</span>
<span class="cm"> * @wiphy: the wiphy reporting the BSS</span>
<span class="cm"> * @channel: The channel the frame was received on</span>
<span class="cm"> * @bssid: the BSSID of the BSS</span>
<span class="cm"> * @tsf: the TSF sent by the peer in the beacon/probe response (or 0)</span>
<span class="cm"> * @capability: the capability field sent by the peer</span>
<span class="cm"> * @beacon_interval: the beacon interval announced by the peer</span>
<span class="cm"> * @ie: additional IEs sent by the peer</span>
<span class="cm"> * @ielen: length of the additional IEs</span>
<span class="cm"> * @signal: the signal strength, type depends on the wiphy&#39;s signal_type</span>
<span class="cm"> * @gfp: context flags</span>
<span class="cm"> *</span>
<span class="cm"> * This informs cfg80211 that BSS information was found and</span>
<span class="cm"> * the BSS should be updated/added.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Returns a referenced struct, must be released with cfg80211_put_bss()!</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span> <span class="n">__must_check</span>
<span class="n">cfg80211_inform_bss</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
		    <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">tsf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">capability</span><span class="p">,</span>
		    <span class="n">u16</span> <span class="n">beacon_interval</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ielen</span><span class="p">,</span>
		    <span class="n">s32</span> <span class="n">signal</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span><span class="n">cfg80211_get_bss</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
				      <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">,</span>
				      <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ssid</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ssid_len</span><span class="p">,</span>
				      <span class="n">u16</span> <span class="n">capa_mask</span><span class="p">,</span> <span class="n">u16</span> <span class="n">capa_val</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span>
<span class="nf">cfg80211_get_ibss</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
		  <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ssid</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ssid_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cfg80211_get_bss</span><span class="p">(</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ssid</span><span class="p">,</span> <span class="n">ssid_len</span><span class="p">,</span>
				<span class="n">WLAN_CAPABILITY_IBSS</span><span class="p">,</span> <span class="n">WLAN_CAPABILITY_IBSS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span><span class="n">cfg80211_get_mesh</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
				       <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">meshid</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">meshidlen</span><span class="p">,</span>
				       <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">meshcfg</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * cfg80211_ref_bss - reference BSS struct</span>
<span class="cm"> * @bss: the BSS struct to reference</span>
<span class="cm"> *</span>
<span class="cm"> * Increments the refcount of the given BSS struct.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_ref_bss</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_put_bss - unref BSS struct</span>
<span class="cm"> * @bss: the BSS struct</span>
<span class="cm"> *</span>
<span class="cm"> * Decrements the refcount of the given BSS struct.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_put_bss</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_unlink_bss - unlink BSS from internal data structures</span>
<span class="cm"> * @wiphy: the wiphy</span>
<span class="cm"> * @bss: the bss to remove</span>
<span class="cm"> *</span>
<span class="cm"> * This function removes the given BSS from the internal data structures</span>
<span class="cm"> * thereby making it no longer show up in scan results etc. Use this</span>
<span class="cm"> * function when you detect a BSS is gone. Normally BSSes will also time</span>
<span class="cm"> * out, so it is not necessary to use this function at all.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_unlink_bss</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_send_rx_auth - notification of processed authentication</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @buf: authentication frame (header + body)</span>
<span class="cm"> * @len: length of the frame data</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called whenever an authentication has been processed in</span>
<span class="cm"> * station mode. The driver is required to call either this function or</span>
<span class="cm"> * cfg80211_send_auth_timeout() to indicate the result of cfg80211_ops::auth()</span>
<span class="cm"> * call. This function may sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_send_rx_auth</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_send_auth_timeout - notification of timed out authentication</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @addr: The MAC address of the device with which the authentication timed out</span>
<span class="cm"> *</span>
<span class="cm"> * This function may sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_send_auth_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_send_rx_assoc - notification of processed association</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @bss: the BSS struct association was requested for, the struct reference</span>
<span class="cm"> *	is owned by cfg80211 after this call</span>
<span class="cm"> * @buf: (re)association response frame (header + body)</span>
<span class="cm"> * @len: length of the frame data</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called whenever a (re)association response has been</span>
<span class="cm"> * processed in station mode. The driver is required to call either this</span>
<span class="cm"> * function or cfg80211_send_assoc_timeout() to indicate the result of</span>
<span class="cm"> * cfg80211_ops::assoc() call. This function may sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_send_rx_assoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">,</span>
			    <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_send_assoc_timeout - notification of timed out association</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @addr: The MAC address of the device with which the association timed out</span>
<span class="cm"> *</span>
<span class="cm"> * This function may sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_send_assoc_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_send_deauth - notification of processed deauthentication</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @buf: deauthentication frame (header + body)</span>
<span class="cm"> * @len: length of the frame data</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called whenever deauthentication has been processed in</span>
<span class="cm"> * station mode. This includes both received deauthentication frames and</span>
<span class="cm"> * locally generated ones. This function may sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_send_deauth</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __cfg80211_send_deauth - notification of processed deauthentication</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @buf: deauthentication frame (header + body)</span>
<span class="cm"> * @len: length of the frame data</span>
<span class="cm"> *</span>
<span class="cm"> * Like cfg80211_send_deauth(), but doesn&#39;t take the wdev lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__cfg80211_send_deauth</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_send_disassoc - notification of processed disassociation</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @buf: disassociation response frame (header + body)</span>
<span class="cm"> * @len: length of the frame data</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called whenever disassociation has been processed in</span>
<span class="cm"> * station mode. This includes both received disassociation frames and locally</span>
<span class="cm"> * generated ones. This function may sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_send_disassoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __cfg80211_send_disassoc - notification of processed disassociation</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @buf: disassociation response frame (header + body)</span>
<span class="cm"> * @len: length of the frame data</span>
<span class="cm"> *</span>
<span class="cm"> * Like cfg80211_send_disassoc(), but doesn&#39;t take the wdev lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__cfg80211_send_disassoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_send_unprot_deauth - notification of unprotected deauthentication</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @buf: deauthentication frame (header + body)</span>
<span class="cm"> * @len: length of the frame data</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called whenever a received Deauthentication frame has been</span>
<span class="cm"> * dropped in station mode because of MFP being used but the Deauthentication</span>
<span class="cm"> * frame was not protected. This function may sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_send_unprot_deauth</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_send_unprot_disassoc - notification of unprotected disassociation</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @buf: disassociation frame (header + body)</span>
<span class="cm"> * @len: length of the frame data</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called whenever a received Disassociation frame has been</span>
<span class="cm"> * dropped in station mode because of MFP being used but the Disassociation</span>
<span class="cm"> * frame was not protected. This function may sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_send_unprot_disassoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_michael_mic_failure - notification of Michael MIC failure (TKIP)</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @addr: The source MAC address of the frame</span>
<span class="cm"> * @key_type: The key type that the received frame used</span>
<span class="cm"> * @key_id: Key identifier (0..3). Can be -1 if missing.</span>
<span class="cm"> * @tsc: The TSC value of the frame that generated the MIC failure (6 octets)</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called whenever the local MAC detects a MIC failure in a</span>
<span class="cm"> * received frame. This matches with MLME-MICHAELMICFAILURE.indication()</span>
<span class="cm"> * primitive.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_michael_mic_failure</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				  <span class="k">enum</span> <span class="n">nl80211_key_type</span> <span class="n">key_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key_id</span><span class="p">,</span>
				  <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">tsc</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_ibss_joined - notify cfg80211 that device joined an IBSS</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @bssid: the BSSID of the IBSS joined</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * This function notifies cfg80211 that the device joined an IBSS or</span>
<span class="cm"> * switched to a different BSSID. Before this function can be called,</span>
<span class="cm"> * either a beacon has to have been received from the IBSS, or one of</span>
<span class="cm"> * the cfg80211_inform_bss{,_frame} functions must have been called</span>
<span class="cm"> * with the locally generated beacon -- this guarantees that there is</span>
<span class="cm"> * always a scan result for this IBSS. cfg80211 will handle the rest.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_ibss_joined</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_notify_new_candidate - notify cfg80211 of a new mesh peer candidate</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @macaddr: the MAC address of the new candidate</span>
<span class="cm"> * @ie: information elements advertised by the peer candidate</span>
<span class="cm"> * @ie_len: lenght of the information elements buffer</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * This function notifies cfg80211 that the mesh peer candidate has been</span>
<span class="cm"> * detected, most likely via a beacon or, less likely, via a probe response.</span>
<span class="cm"> * cfg80211 then sends a notification to userspace.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_notify_new_peer_candidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">macaddr</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ie_len</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: RFkill integration</span>
<span class="cm"> *</span>
<span class="cm"> * RFkill integration in cfg80211 is almost invisible to drivers,</span>
<span class="cm"> * as cfg80211 automatically registers an rfkill instance for each</span>
<span class="cm"> * wireless device it knows about. Soft kill is also translated</span>
<span class="cm"> * into disconnecting and turning all interfaces off, drivers are</span>
<span class="cm"> * expected to turn off the device when all interfaces are down.</span>
<span class="cm"> *</span>
<span class="cm"> * However, devices may have a hard RFkill line, in which case they</span>
<span class="cm"> * also need to interact with the rfkill subsystem, via cfg80211.</span>
<span class="cm"> * They can do this with a few helper functions documented here.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * wiphy_rfkill_set_hw_state - notify cfg80211 about hw block state</span>
<span class="cm"> * @wiphy: the wiphy</span>
<span class="cm"> * @blocked: block status</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">wiphy_rfkill_set_hw_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * wiphy_rfkill_start_polling - start polling rfkill</span>
<span class="cm"> * @wiphy: the wiphy</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">wiphy_rfkill_start_polling</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * wiphy_rfkill_stop_polling - stop polling rfkill</span>
<span class="cm"> * @wiphy: the wiphy</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">wiphy_rfkill_stop_polling</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NL80211_TESTMODE</span>
<span class="cm">/**</span>
<span class="cm"> * DOC: Test mode</span>
<span class="cm"> *</span>
<span class="cm"> * Test mode is a set of utility functions to allow drivers to</span>
<span class="cm"> * interact with driver-specific tools to aid, for instance,</span>
<span class="cm"> * factory programming.</span>
<span class="cm"> *</span>
<span class="cm"> * This chapter describes how drivers interact with it, for more</span>
<span class="cm"> * information see the nl80211 book&#39;s chapter on it.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_testmode_alloc_reply_skb - allocate testmode reply</span>
<span class="cm"> * @wiphy: the wiphy</span>
<span class="cm"> * @approxlen: an upper bound of the length of the data that will</span>
<span class="cm"> *	be put into the skb</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates and pre-fills an skb for a reply to</span>
<span class="cm"> * the testmode command. Since it is intended for a reply, calling</span>
<span class="cm"> * it outside of the @testmode_cmd operation is invalid.</span>
<span class="cm"> *</span>
<span class="cm"> * The returned skb (or %NULL if any errors happen) is pre-filled</span>
<span class="cm"> * with the wiphy index and set up in a way that any data that is</span>
<span class="cm"> * put into the skb (with skb_put(), nla_put() or similar) will end</span>
<span class="cm"> * up being within the %NL80211_ATTR_TESTDATA attribute, so all that</span>
<span class="cm"> * needs to be done with the skb is adding data for the corresponding</span>
<span class="cm"> * userspace tool which can then read that data out of the testdata</span>
<span class="cm"> * attribute. You must not modify the skb in any other way.</span>
<span class="cm"> *</span>
<span class="cm"> * When done, call cfg80211_testmode_reply() with the skb and return</span>
<span class="cm"> * its error code as the result of the @testmode_cmd operation.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">cfg80211_testmode_alloc_reply_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">approxlen</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_testmode_reply - send the reply skb</span>
<span class="cm"> * @skb: The skb, must have been allocated with</span>
<span class="cm"> *	cfg80211_testmode_alloc_reply_skb()</span>
<span class="cm"> *</span>
<span class="cm"> * Returns an error code or 0 on success, since calling this</span>
<span class="cm"> * function will usually be the last thing before returning</span>
<span class="cm"> * from the @testmode_cmd you should return the error code.</span>
<span class="cm"> * Note that this function consumes the skb regardless of the</span>
<span class="cm"> * return value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">cfg80211_testmode_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_testmode_alloc_event_skb - allocate testmode event</span>
<span class="cm"> * @wiphy: the wiphy</span>
<span class="cm"> * @approxlen: an upper bound of the length of the data that will</span>
<span class="cm"> *	be put into the skb</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates and pre-fills an skb for an event on the</span>
<span class="cm"> * testmode multicast group.</span>
<span class="cm"> *</span>
<span class="cm"> * The returned skb (or %NULL if any errors happen) is set up in the</span>
<span class="cm"> * same way as with cfg80211_testmode_alloc_reply_skb() but prepared</span>
<span class="cm"> * for an event. As there, you should simply add data to it that will</span>
<span class="cm"> * then end up in the %NL80211_ATTR_TESTDATA attribute. Again, you must</span>
<span class="cm"> * not modify the skb in any other way.</span>
<span class="cm"> *</span>
<span class="cm"> * When done filling the skb, call cfg80211_testmode_event() with the</span>
<span class="cm"> * skb to send the event.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">cfg80211_testmode_alloc_event_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">approxlen</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_testmode_event - send the event</span>
<span class="cm"> * @skb: The skb, must have been allocated with</span>
<span class="cm"> *	cfg80211_testmode_alloc_event_skb()</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends the given @skb, which must have been allocated</span>
<span class="cm"> * by cfg80211_testmode_alloc_event_skb(), as an event. It always</span>
<span class="cm"> * consumes it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_testmode_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cp">#define CFG80211_TESTMODE_CMD(cmd)	.testmode_cmd = (cmd),</span>
<span class="cp">#define CFG80211_TESTMODE_DUMP(cmd)	.testmode_dump = (cmd),</span>
<span class="cp">#else</span>
<span class="cp">#define CFG80211_TESTMODE_CMD(cmd)</span>
<span class="cp">#define CFG80211_TESTMODE_DUMP(cmd)</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_connect_result - notify cfg80211 of connection result</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @bssid: the BSSID of the AP</span>
<span class="cm"> * @req_ie: association request IEs (maybe be %NULL)</span>
<span class="cm"> * @req_ie_len: association request IEs length</span>
<span class="cm"> * @resp_ie: association response IEs (may be %NULL)</span>
<span class="cm"> * @resp_ie_len: assoc response IEs length</span>
<span class="cm"> * @status: status code, 0 for successful connection, use</span>
<span class="cm"> *	%WLAN_STATUS_UNSPECIFIED_FAILURE if your device cannot give you</span>
<span class="cm"> *	the real status code for failures.</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * It should be called by the underlying driver whenever connect() has</span>
<span class="cm"> * succeeded.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_connect_result</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">,</span>
			     <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">req_ie</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">req_ie_len</span><span class="p">,</span>
			     <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">resp_ie</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">resp_ie_len</span><span class="p">,</span>
			     <span class="n">u16</span> <span class="n">status</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_roamed - notify cfg80211 of roaming</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @channel: the channel of the new AP</span>
<span class="cm"> * @bssid: the BSSID of the new AP</span>
<span class="cm"> * @req_ie: association request IEs (maybe be %NULL)</span>
<span class="cm"> * @req_ie_len: association request IEs length</span>
<span class="cm"> * @resp_ie: association response IEs (may be %NULL)</span>
<span class="cm"> * @resp_ie_len: assoc response IEs length</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * It should be called by the underlying driver whenever it roamed</span>
<span class="cm"> * from one AP to another while connected.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_roamed</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
		     <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">,</span>
		     <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">req_ie</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">req_ie_len</span><span class="p">,</span>
		     <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">resp_ie</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">resp_ie_len</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_roamed_bss - notify cfg80211 of roaming</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @bss: entry of bss to which STA got roamed</span>
<span class="cm"> * @req_ie: association request IEs (maybe be %NULL)</span>
<span class="cm"> * @req_ie_len: association request IEs length</span>
<span class="cm"> * @resp_ie: association response IEs (may be %NULL)</span>
<span class="cm"> * @resp_ie_len: assoc response IEs length</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * This is just a wrapper to notify cfg80211 of roaming event with driver</span>
<span class="cm"> * passing bss to avoid a race in timeout of the bss entry. It should be</span>
<span class="cm"> * called by the underlying driver whenever it roamed from one AP to another</span>
<span class="cm"> * while connected. Drivers which have roaming implemented in firmware</span>
<span class="cm"> * may use this function to avoid a race in bss entry timeout where the bss</span>
<span class="cm"> * entry of the new AP is seen in the driver, but gets timed out by the time</span>
<span class="cm"> * it is accessed in __cfg80211_roamed() due to delay in scheduling</span>
<span class="cm"> * rdev-&gt;event_work. In case of any failures, the reference is released</span>
<span class="cm"> * either in cfg80211_roamed_bss() or in __cfg80211_romed(), Otherwise,</span>
<span class="cm"> * it will be released while diconneting from the current bss.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_roamed_bss</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfg80211_bss</span> <span class="o">*</span><span class="n">bss</span><span class="p">,</span>
			 <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">req_ie</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">req_ie_len</span><span class="p">,</span>
			 <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">resp_ie</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">resp_ie_len</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_disconnected - notify cfg80211 that connection was dropped</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @ie: information elements of the deauth/disassoc frame (may be %NULL)</span>
<span class="cm"> * @ie_len: length of IEs</span>
<span class="cm"> * @reason: reason code for the disconnection, set it to 0 if unknown</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * After it calls this function, the driver should enter an idle state</span>
<span class="cm"> * and not try to connect to any AP any more.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_disconnected</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reason</span><span class="p">,</span>
			   <span class="n">u8</span> <span class="o">*</span><span class="n">ie</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ie_len</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_ready_on_channel - notification of remain_on_channel start</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @cookie: the request cookie</span>
<span class="cm"> * @chan: The current channel (from remain_on_channel request)</span>
<span class="cm"> * @channel_type: Channel type</span>
<span class="cm"> * @duration: Duration in milliseconds that the driver intents to remain on the</span>
<span class="cm"> *	channel</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_ready_on_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">cookie</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">channel_type</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">duration</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_remain_on_channel_expired - remain_on_channel duration expired</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @cookie: the request cookie</span>
<span class="cm"> * @chan: The current channel (from remain_on_channel request)</span>
<span class="cm"> * @channel_type: Channel type</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_remain_on_channel_expired</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">u64</span> <span class="n">cookie</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">channel_type</span><span class="p">,</span>
					<span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * cfg80211_new_sta - notify userspace about station</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: the netdev</span>
<span class="cm"> * @mac_addr: the station&#39;s address</span>
<span class="cm"> * @sinfo: the station information</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_new_sta</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">station_info</span> <span class="o">*</span><span class="n">sinfo</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_del_sta - notify userspace about deletion of a station</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: the netdev</span>
<span class="cm"> * @mac_addr: the station&#39;s address</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_del_sta</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_rx_mgmt - notification of received, unprocessed management frame</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @freq: Frequency on which the frame was received in MHz</span>
<span class="cm"> * @sig_dbm: signal strength in mBm, or 0 if unknown</span>
<span class="cm"> * @buf: Management frame (header + body)</span>
<span class="cm"> * @len: length of the frame data</span>
<span class="cm"> * @gfp: context flags</span>
<span class="cm"> *</span>
<span class="cm"> * Returns %true if a user space application has registered for this frame.</span>
<span class="cm"> * For action frames, that makes it responsible for rejecting unrecognized</span>
<span class="cm"> * action frames; %false otherwise, in which case for action frames the</span>
<span class="cm"> * driver is responsible for rejecting the frame.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called whenever an Action frame is received for a station</span>
<span class="cm"> * mode interface, but is not processed in kernel.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="n">cfg80211_rx_mgmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">freq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig_dbm</span><span class="p">,</span>
		      <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_mgmt_tx_status - notification of TX status for management frame</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @cookie: Cookie returned by cfg80211_ops::mgmt_tx()</span>
<span class="cm"> * @buf: Management frame (header + body)</span>
<span class="cm"> * @len: length of the frame data</span>
<span class="cm"> * @ack: Whether frame was acknowledged</span>
<span class="cm"> * @gfp: context flags</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called whenever a management frame was requested to be</span>
<span class="cm"> * transmitted with cfg80211_ops::mgmt_tx() to report the TX status of the</span>
<span class="cm"> * transmission attempt.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_mgmt_tx_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">cookie</span><span class="p">,</span>
			     <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ack</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * cfg80211_cqm_rssi_notify - connection quality monitoring rssi event</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @rssi_event: the triggered RSSI event</span>
<span class="cm"> * @gfp: context flags</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called when a configured connection quality monitoring</span>
<span class="cm"> * rssi threshold reached event occurs.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_cqm_rssi_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">nl80211_cqm_rssi_threshold_event</span> <span class="n">rssi_event</span><span class="p">,</span>
			      <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_cqm_pktloss_notify - notify userspace about packetloss to peer</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @peer: peer&#39;s MAC address</span>
<span class="cm"> * @num_packets: how many packets were lost -- should be a fixed threshold</span>
<span class="cm"> *	but probably no less than maybe 50, or maybe a throughput dependent</span>
<span class="cm"> *	threshold (to account for temporary interference)</span>
<span class="cm"> * @gfp: context flags</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_cqm_pktloss_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">peer</span><span class="p">,</span> <span class="n">u32</span> <span class="n">num_packets</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_gtk_rekey_notify - notify userspace about driver rekeying</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @bssid: BSSID of AP (to avoid races)</span>
<span class="cm"> * @replay_ctr: new replay counter</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_gtk_rekey_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">,</span>
			       <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">replay_ctr</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_pmksa_candidate_notify - notify about PMKSA caching candidate</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> * @index: candidate index (the smaller the index, the higher the priority)</span>
<span class="cm"> * @bssid: BSSID of AP</span>
<span class="cm"> * @preauth: Whether AP advertises support for RSN pre-authentication</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_pmksa_candidate_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
				     <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bssid</span><span class="p">,</span> <span class="n">bool</span> <span class="n">preauth</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_rx_spurious_frame - inform userspace about a spurious frame</span>
<span class="cm"> * @dev: The device the frame matched to</span>
<span class="cm"> * @addr: the transmitter address</span>
<span class="cm"> * @gfp: context flags</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used in AP mode (only!) to inform userspace that</span>
<span class="cm"> * a spurious class 3 frame was received, to be able to deauth the</span>
<span class="cm"> * sender.</span>
<span class="cm"> * Returns %true if the frame was passed to userspace (or this failed</span>
<span class="cm"> * for a reason other than not having a subscription.)</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="n">cfg80211_rx_spurious_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_rx_unexpected_4addr_frame - inform about unexpected WDS frame</span>
<span class="cm"> * @dev: The device the frame matched to</span>
<span class="cm"> * @addr: the transmitter address</span>
<span class="cm"> * @gfp: context flags</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used in AP mode (only!) to inform userspace that</span>
<span class="cm"> * an associated station sent a 4addr frame but that wasn&#39;t expected.</span>
<span class="cm"> * It is allowed and desirable to send this event only once for each</span>
<span class="cm"> * station to avoid event flooding.</span>
<span class="cm"> * Returns %true if the frame was passed to userspace (or this failed</span>
<span class="cm"> * for a reason other than not having a subscription.)</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="n">cfg80211_rx_unexpected_4addr_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_probe_status - notify userspace about probe status</span>
<span class="cm"> * @dev: the device the probe was sent on</span>
<span class="cm"> * @addr: the address of the peer</span>
<span class="cm"> * @cookie: the cookie filled in @probe_client previously</span>
<span class="cm"> * @acked: indicates whether probe was acked or not</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_probe_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			   <span class="n">u64</span> <span class="n">cookie</span><span class="p">,</span> <span class="n">bool</span> <span class="n">acked</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cfg80211_report_obss_beacon - report beacon from other APs</span>
<span class="cm"> * @wiphy: The wiphy that received the beacon</span>
<span class="cm"> * @frame: the frame</span>
<span class="cm"> * @len: length of the frame</span>
<span class="cm"> * @freq: frequency the frame was received on</span>
<span class="cm"> * @sig_dbm: signal strength in mBm, or 0 if unknown</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * Use this function to report to userspace when a beacon was</span>
<span class="cm"> * received. It is not useful to call this when there is no</span>
<span class="cm"> * netdev that is in AP/GO mode.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_report_obss_beacon</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				 <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">freq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig_dbm</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * cfg80211_can_beacon_sec_chan - test if ht40 on extension channel can be used</span>
<span class="cm"> * @wiphy: the wiphy</span>
<span class="cm"> * @chan: main channel</span>
<span class="cm"> * @channel_type: HT mode</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="n">cfg80211_can_beacon_sec_chan</span><span class="p">(</span><span class="k">struct</span> <span class="n">wiphy</span> <span class="o">*</span><span class="n">wiphy</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ieee80211_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
				  <span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">channel_type</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * cfg80211_ch_switch_notify - update wdev channel and notify userspace</span>
<span class="cm"> * @dev: the device which switched channels</span>
<span class="cm"> * @freq: new channel frequency (in MHz)</span>
<span class="cm"> * @type: channel type</span>
<span class="cm"> *</span>
<span class="cm"> * Acquires wdev_lock, so must only be called from sleepable driver context!</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cfg80211_ch_switch_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">freq</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">nl80211_channel_type</span> <span class="n">type</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * cfg80211_calculate_bitrate - calculate actual bitrate (in 100Kbps units)</span>
<span class="cm"> * @rate: given rate_info to calculate bitrate from</span>
<span class="cm"> *</span>
<span class="cm"> * return 0 if MCS index &gt;= 32</span>
<span class="cm"> */</span>
<span class="n">u16</span> <span class="n">cfg80211_calculate_bitrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">rate_info</span> <span class="o">*</span><span class="n">rate</span><span class="p">);</span>

<span class="cm">/* Logging, debugging and troubleshooting/diagnostic helpers. */</span>

<span class="cm">/* wiphy_printk helpers, similar to dev_printk */</span>

<span class="cp">#define wiphy_printk(level, wiphy, format, args...)		\</span>
<span class="cp">	dev_printk(level, &amp;(wiphy)-&gt;dev, format, ##args)</span>
<span class="cp">#define wiphy_emerg(wiphy, format, args...)			\</span>
<span class="cp">	dev_emerg(&amp;(wiphy)-&gt;dev, format, ##args)</span>
<span class="cp">#define wiphy_alert(wiphy, format, args...)			\</span>
<span class="cp">	dev_alert(&amp;(wiphy)-&gt;dev, format, ##args)</span>
<span class="cp">#define wiphy_crit(wiphy, format, args...)			\</span>
<span class="cp">	dev_crit(&amp;(wiphy)-&gt;dev, format, ##args)</span>
<span class="cp">#define wiphy_err(wiphy, format, args...)			\</span>
<span class="cp">	dev_err(&amp;(wiphy)-&gt;dev, format, ##args)</span>
<span class="cp">#define wiphy_warn(wiphy, format, args...)			\</span>
<span class="cp">	dev_warn(&amp;(wiphy)-&gt;dev, format, ##args)</span>
<span class="cp">#define wiphy_notice(wiphy, format, args...)			\</span>
<span class="cp">	dev_notice(&amp;(wiphy)-&gt;dev, format, ##args)</span>
<span class="cp">#define wiphy_info(wiphy, format, args...)			\</span>
<span class="cp">	dev_info(&amp;(wiphy)-&gt;dev, format, ##args)</span>

<span class="cp">#define wiphy_debug(wiphy, format, args...)			\</span>
<span class="cp">	wiphy_printk(KERN_DEBUG, wiphy, format, ##args)</span>

<span class="cp">#define wiphy_dbg(wiphy, format, args...)			\</span>
<span class="cp">	dev_dbg(&amp;(wiphy)-&gt;dev, format, ##args)</span>

<span class="cp">#if defined(VERBOSE_DEBUG)</span>
<span class="cp">#define wiphy_vdbg	wiphy_dbg</span>
<span class="cp">#else</span>
<span class="cp">#define wiphy_vdbg(wiphy, format, args...)				\</span>
<span class="cp">({									\</span>
<span class="cp">	if (0)								\</span>
<span class="cp">		wiphy_printk(KERN_DEBUG, wiphy, format, ##args);	\</span>
<span class="cp">	0;								\</span>
<span class="cp">})</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * wiphy_WARN() acts like wiphy_printk(), but with the key difference</span>
<span class="cm"> * of using a WARN/WARN_ON to get the message out, including the</span>
<span class="cm"> * file/line information and a backtrace.</span>
<span class="cm"> */</span>
<span class="cp">#define wiphy_WARN(wiphy, format, args...)			\</span>
<span class="cp">	WARN(1, &quot;wiphy: %s\n&quot; format, wiphy_name(wiphy), ##args);</span>

<span class="cp">#endif </span><span class="cm">/* __NET_CFG80211_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
