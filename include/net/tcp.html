<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › tcp.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tcp.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * INET		An implementation of the TCP/IP protocol suite for the LINUX</span>
<span class="cm"> *		operating system.  INET is implemented using the  BSD Socket</span>
<span class="cm"> *		interface as the means of communication with the user level.</span>
<span class="cm"> *</span>
<span class="cm"> *		Definitions for the TCP module.</span>
<span class="cm"> *</span>
<span class="cm"> * Version:	@(#)tcp.h	1.0.5	05/23/93</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:	Ross Biro</span>
<span class="cm"> *		Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *		This program is free software; you can redistribute it and/or</span>
<span class="cm"> *		modify it under the terms of the GNU General Public License</span>
<span class="cm"> *		as published by the Free Software Foundation; either version</span>
<span class="cm"> *		2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _TCP_H</span>
<span class="cp">#define _TCP_H</span>

<span class="cp">#define FASTRETRANS_DEBUG 1</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/dmaengine.h&gt;</span>
<span class="cp">#include &lt;linux/crypto.h&gt;</span>
<span class="cp">#include &lt;linux/cryptohash.h&gt;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>

<span class="cp">#include &lt;net/inet_connection_sock.h&gt;</span>
<span class="cp">#include &lt;net/inet_timewait_sock.h&gt;</span>
<span class="cp">#include &lt;net/inet_hashtables.h&gt;</span>
<span class="cp">#include &lt;net/checksum.h&gt;</span>
<span class="cp">#include &lt;net/request_sock.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/snmp.h&gt;</span>
<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &lt;net/tcp_states.h&gt;</span>
<span class="cp">#include &lt;net/inet_ecn.h&gt;</span>
<span class="cp">#include &lt;net/dst.h&gt;</span>

<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/memcontrol.h&gt;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">inet_hashinfo</span> <span class="n">tcp_hashinfo</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">tcp_orphan_count</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_time_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeo</span><span class="p">);</span>

<span class="cp">#define MAX_TCP_HEADER	(128 + MAX_HEADER)</span>
<span class="cp">#define MAX_TCP_OPTION_SPACE 40</span>

<span class="cm">/* </span>
<span class="cm"> * Never offer a window over 32767 without using window scaling. Some</span>
<span class="cm"> * poor stacks do signed 16bit maths! </span>
<span class="cm"> */</span>
<span class="cp">#define MAX_TCP_WINDOW		32767U</span>

<span class="cm">/* Offer an initial receive window of 10 mss. */</span>
<span class="cp">#define TCP_DEFAULT_INIT_RCVWND	10</span>

<span class="cm">/* Minimal accepted MSS. It is (60+60+8) - (20+20). */</span>
<span class="cp">#define TCP_MIN_MSS		88U</span>

<span class="cm">/* The least MTU to use for probing */</span>
<span class="cp">#define TCP_BASE_MSS		512</span>

<span class="cm">/* After receiving this amount of duplicate ACKs fast retransmit starts. */</span>
<span class="cp">#define TCP_FASTRETRANS_THRESH 3</span>

<span class="cm">/* Maximal reordering. */</span>
<span class="cp">#define TCP_MAX_REORDERING	127</span>

<span class="cm">/* Maximal number of ACKs sent quickly to accelerate slow-start. */</span>
<span class="cp">#define TCP_MAX_QUICKACKS	16U</span>

<span class="cm">/* urg_data states */</span>
<span class="cp">#define TCP_URG_VALID	0x0100</span>
<span class="cp">#define TCP_URG_NOTYET	0x0200</span>
<span class="cp">#define TCP_URG_READ	0x0400</span>

<span class="cp">#define TCP_RETR1	3	</span><span class="cm">/*</span>
<span class="cm">				 * This is how many retries it does before it</span>
<span class="cm">				 * tries to figure out if the gateway is</span>
<span class="cm">				 * down. Minimal RFC value is 3; it corresponds</span>
<span class="cm">				 * to ~3sec-8min depending on RTO.</span>
<span class="cm">				 */</span><span class="cp"></span>

<span class="cp">#define TCP_RETR2	15	</span><span class="cm">/*</span>
<span class="cm">				 * This should take at least</span>
<span class="cm">				 * 90 minutes to time out.</span>
<span class="cm">				 * RFC1122 says that the limit is 100 sec.</span>
<span class="cm">				 * 15 is ~13-30min depending on RTO.</span>
<span class="cm">				 */</span><span class="cp"></span>

<span class="cp">#define TCP_SYN_RETRIES	 5	</span><span class="cm">/* number of times to retry active opening a</span>
<span class="cm">				 * connection: ~180sec is RFC minimum	*/</span><span class="cp"></span>

<span class="cp">#define TCP_SYNACK_RETRIES 5	</span><span class="cm">/* number of times to retry passive opening a</span>
<span class="cm">				 * connection: ~180sec is RFC minimum	*/</span><span class="cp"></span>

<span class="cp">#define TCP_TIMEWAIT_LEN (60*HZ) </span><span class="cm">/* how long to wait to destroy TIME-WAIT</span>
<span class="cm">				  * state, about 60 seconds	*/</span><span class="cp"></span>
<span class="cp">#define TCP_FIN_TIMEOUT	TCP_TIMEWAIT_LEN</span>
                                 <span class="cm">/* BSD style FIN_WAIT2 deadlock breaker.</span>
<span class="cm">				  * It used to be 3min, new value is 60sec,</span>
<span class="cm">				  * to combine FIN-WAIT-2 timeout with</span>
<span class="cm">				  * TIME-WAIT timer.</span>
<span class="cm">				  */</span>

<span class="cp">#define TCP_DELACK_MAX	((unsigned)(HZ/5))	</span><span class="cm">/* maximal time to delay before sending an ACK */</span><span class="cp"></span>
<span class="cp">#if HZ &gt;= 100</span>
<span class="cp">#define TCP_DELACK_MIN	((unsigned)(HZ/25))	</span><span class="cm">/* minimal time to delay before sending an ACK */</span><span class="cp"></span>
<span class="cp">#define TCP_ATO_MIN	((unsigned)(HZ/25))</span>
<span class="cp">#else</span>
<span class="cp">#define TCP_DELACK_MIN	4U</span>
<span class="cp">#define TCP_ATO_MIN	4U</span>
<span class="cp">#endif</span>
<span class="cp">#define TCP_RTO_MAX	((unsigned)(120*HZ))</span>
<span class="cp">#define TCP_RTO_MIN	((unsigned)(HZ/5))</span>
<span class="cp">#define TCP_TIMEOUT_INIT ((unsigned)(1*HZ))	</span><span class="cm">/* RFC6298 2.1 initial RTO value	*/</span><span class="cp"></span>
<span class="cp">#define TCP_TIMEOUT_FALLBACK ((unsigned)(3*HZ))	</span><span class="cm">/* RFC 1122 initial RTO value, now</span>
<span class="cm">						 * used as a fallback RTO for the</span>
<span class="cm">						 * initial data transmission if no</span>
<span class="cm">						 * valid RTT sample has been acquired,</span>
<span class="cm">						 * most likely due to retrans in 3WHS.</span>
<span class="cm">						 */</span><span class="cp"></span>

<span class="cp">#define TCP_RESOURCE_PROBE_INTERVAL ((unsigned)(HZ/2U)) </span><span class="cm">/* Maximal interval between probes</span>
<span class="cm">					                 * for local resources.</span>
<span class="cm">					                 */</span><span class="cp"></span>

<span class="cp">#define TCP_KEEPALIVE_TIME	(120*60*HZ)	</span><span class="cm">/* two hours */</span><span class="cp"></span>
<span class="cp">#define TCP_KEEPALIVE_PROBES	9		</span><span class="cm">/* Max of 9 keepalive probes	*/</span><span class="cp"></span>
<span class="cp">#define TCP_KEEPALIVE_INTVL	(75*HZ)</span>

<span class="cp">#define MAX_TCP_KEEPIDLE	32767</span>
<span class="cp">#define MAX_TCP_KEEPINTVL	32767</span>
<span class="cp">#define MAX_TCP_KEEPCNT		127</span>
<span class="cp">#define MAX_TCP_SYNCNT		127</span>

<span class="cp">#define TCP_SYNQ_INTERVAL	(HZ/5)	</span><span class="cm">/* Period of SYNACK timer */</span><span class="cp"></span>

<span class="cp">#define TCP_PAWS_24DAYS	(60 * 60 * 24 * 24)</span>
<span class="cp">#define TCP_PAWS_MSL	60		</span><span class="cm">/* Per-host timestamps are invalidated</span>
<span class="cm">					 * after this time. It should be equal</span>
<span class="cm">					 * (or greater than) TCP_TIMEWAIT_LEN</span>
<span class="cm">					 * to provide reliability equal to one</span>
<span class="cm">					 * provided by timewait state.</span>
<span class="cm">					 */</span><span class="cp"></span>
<span class="cp">#define TCP_PAWS_WINDOW	1		</span><span class="cm">/* Replay window for per-host</span>
<span class="cm">					 * timestamps. It must be less than</span>
<span class="cm">					 * minimal timewait lifetime.</span>
<span class="cm">					 */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> *	TCP option</span>
<span class="cm"> */</span>
 
<span class="cp">#define TCPOPT_NOP		1	</span><span class="cm">/* Padding */</span><span class="cp"></span>
<span class="cp">#define TCPOPT_EOL		0	</span><span class="cm">/* End of options */</span><span class="cp"></span>
<span class="cp">#define TCPOPT_MSS		2	</span><span class="cm">/* Segment size negotiating */</span><span class="cp"></span>
<span class="cp">#define TCPOPT_WINDOW		3	</span><span class="cm">/* Window scaling */</span><span class="cp"></span>
<span class="cp">#define TCPOPT_SACK_PERM        4       </span><span class="cm">/* SACK Permitted */</span><span class="cp"></span>
<span class="cp">#define TCPOPT_SACK             5       </span><span class="cm">/* SACK Block */</span><span class="cp"></span>
<span class="cp">#define TCPOPT_TIMESTAMP	8	</span><span class="cm">/* Better RTT estimations/PAWS */</span><span class="cp"></span>
<span class="cp">#define TCPOPT_MD5SIG		19	</span><span class="cm">/* MD5 Signature (RFC2385) */</span><span class="cp"></span>
<span class="cp">#define TCPOPT_COOKIE		253	</span><span class="cm">/* Cookie extension (experimental) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *     TCP option lengths</span>
<span class="cm"> */</span>

<span class="cp">#define TCPOLEN_MSS            4</span>
<span class="cp">#define TCPOLEN_WINDOW         3</span>
<span class="cp">#define TCPOLEN_SACK_PERM      2</span>
<span class="cp">#define TCPOLEN_TIMESTAMP      10</span>
<span class="cp">#define TCPOLEN_MD5SIG         18</span>
<span class="cp">#define TCPOLEN_COOKIE_BASE    2	</span><span class="cm">/* Cookie-less header extension */</span><span class="cp"></span>
<span class="cp">#define TCPOLEN_COOKIE_PAIR    3	</span><span class="cm">/* Cookie pair header extension */</span><span class="cp"></span>
<span class="cp">#define TCPOLEN_COOKIE_MIN     (TCPOLEN_COOKIE_BASE+TCP_COOKIE_MIN)</span>
<span class="cp">#define TCPOLEN_COOKIE_MAX     (TCPOLEN_COOKIE_BASE+TCP_COOKIE_MAX)</span>

<span class="cm">/* But this is what stacks really send out. */</span>
<span class="cp">#define TCPOLEN_TSTAMP_ALIGNED		12</span>
<span class="cp">#define TCPOLEN_WSCALE_ALIGNED		4</span>
<span class="cp">#define TCPOLEN_SACKPERM_ALIGNED	4</span>
<span class="cp">#define TCPOLEN_SACK_BASE		2</span>
<span class="cp">#define TCPOLEN_SACK_BASE_ALIGNED	4</span>
<span class="cp">#define TCPOLEN_SACK_PERBLOCK		8</span>
<span class="cp">#define TCPOLEN_MD5SIG_ALIGNED		20</span>
<span class="cp">#define TCPOLEN_MSS_ALIGNED		4</span>

<span class="cm">/* Flags in tp-&gt;nonagle */</span>
<span class="cp">#define TCP_NAGLE_OFF		1	</span><span class="cm">/* Nagle&#39;s algo is disabled */</span><span class="cp"></span>
<span class="cp">#define TCP_NAGLE_CORK		2	</span><span class="cm">/* Socket is corked	    */</span><span class="cp"></span>
<span class="cp">#define TCP_NAGLE_PUSH		4	</span><span class="cm">/* Cork is overridden for already queued data */</span><span class="cp"></span>

<span class="cm">/* TCP thin-stream limits */</span>
<span class="cp">#define TCP_THIN_LINEAR_RETRIES 6       </span><span class="cm">/* After 6 linear retries, do exp. backoff */</span><span class="cp"></span>

<span class="cm">/* TCP initial congestion window as per draft-hkchu-tcpm-initcwnd-01 */</span>
<span class="cp">#define TCP_INIT_CWND		10</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">inet_timewait_death_row</span> <span class="n">tcp_death_row</span><span class="p">;</span>

<span class="cm">/* sysctl variables for tcp */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_timestamps</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_window_scaling</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_sack</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_fin_timeout</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_keepalive_time</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_keepalive_probes</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_keepalive_intvl</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_syn_retries</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_synack_retries</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_retries1</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_retries2</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_orphan_retries</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_syncookies</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_retrans_collapse</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_stdurg</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_rfc1337</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_abort_on_overflow</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_max_orphans</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_fack</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_reordering</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_ecn</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_dsack</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_wmem</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_rmem</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_app_win</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_adv_win_scale</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_tw_reuse</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_frto</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_frto_response</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_low_latency</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_dma_copybreak</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_nometrics_save</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_moderate_rcvbuf</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_tso_win_divisor</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_abc</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_mtu_probing</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_base_mss</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_workaround_signed_windows</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_slow_start_after_idle</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_max_ssthresh</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_cookie_size</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_thin_linear_timeouts</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_thin_dupack</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_tcp_early_retrans</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">atomic_long_t</span> <span class="n">tcp_memory_allocated</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">tcp_sockets_allocated</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_memory_pressure</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The next routines deal with comparing 32 bit unsigned ints</span>
<span class="cm"> * and worry about wraparound (automatic with unsigned arithmetic).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">before</span><span class="p">(</span><span class="n">__u32</span> <span class="n">seq1</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">seq2</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">__s32</span><span class="p">)(</span><span class="n">seq1</span><span class="o">-</span><span class="n">seq2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define after(seq2, seq1) 	before(seq1, seq2)</span>

<span class="cm">/* is s2&lt;=s1&lt;=s3 ? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">between</span><span class="p">(</span><span class="n">__u32</span> <span class="n">seq1</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">seq2</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">seq3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq3</span> <span class="o">-</span> <span class="n">seq2</span> <span class="o">&gt;=</span> <span class="n">seq1</span> <span class="o">-</span> <span class="n">seq2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_out_of_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">&gt;</span> <span class="n">SOCK_MIN_SNDBUF</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sk_memory_allocated</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sk_prot_mem_limits</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_too_many_orphans</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="o">*</span><span class="n">ocp</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">orphan_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">orphans</span> <span class="o">=</span> <span class="n">percpu_counter_read_positive</span><span class="p">(</span><span class="n">ocp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">orphans</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span> <span class="o">&gt;</span> <span class="n">sysctl_tcp_max_orphans</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">orphans</span> <span class="o">=</span> <span class="n">percpu_counter_sum_positive</span><span class="p">(</span><span class="n">ocp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">orphans</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span> <span class="o">&gt;</span> <span class="n">sysctl_tcp_max_orphans</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">tcp_check_oom</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">);</span>

<span class="cm">/* syncookies: remember time of last synqueue overflow */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_synq_overflow</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* syncookies: no recent synqueue overflow on this listening socket? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_synq_no_recent_overflow</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_overflow</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent_stamp</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">last_overflow</span> <span class="o">+</span> <span class="n">TCP_TIMEOUT_FALLBACK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">proto</span> <span class="n">tcp_prot</span><span class="p">;</span>

<span class="cp">#define TCP_INC_STATS(net, field)	SNMP_INC_STATS((net)-&gt;mib.tcp_statistics, field)</span>
<span class="cp">#define TCP_INC_STATS_BH(net, field)	SNMP_INC_STATS_BH((net)-&gt;mib.tcp_statistics, field)</span>
<span class="cp">#define TCP_DEC_STATS(net, field)	SNMP_DEC_STATS((net)-&gt;mib.tcp_statistics, field)</span>
<span class="cp">#define TCP_ADD_STATS_USER(net, field, val) SNMP_ADD_STATS_USER((net)-&gt;mib.tcp_statistics, field, val)</span>
<span class="cp">#define TCP_ADD_STATS(net, field, val)	SNMP_ADD_STATS((net)-&gt;mib.tcp_statistics, field, val)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_init_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_v4_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_shutdown</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_v4_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">inet_peer</span> <span class="o">*</span><span class="n">tcp_v4_get_peer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">release_it</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">tcp_v4_tw_get_peer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_v4_tw_remember_stamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">inet_timewait_sock</span> <span class="o">*</span><span class="n">tw</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		       <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_sendpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_rcv_state_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_rcv_established</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_rcv_space_adjust</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_cleanup_rbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">copied</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_twsk_unique</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sktw</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">twp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_twsk_destructor</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">tcp_splice_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_dec_quickack_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pkts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">quick</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pkts</span> <span class="o">&gt;=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">quick</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">quick</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* Leaving quickack mode we deflate ATO. */</span>
			<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">ato</span>   <span class="o">=</span> <span class="n">TCP_ATO_MIN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">quick</span> <span class="o">-=</span> <span class="n">pkts</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define	TCP_ECN_OK		1</span>
<span class="cp">#define	TCP_ECN_QUEUE_CWR	2</span>
<span class="cp">#define	TCP_ECN_DEMAND_CWR	4</span>
<span class="cp">#define	TCP_ECN_SEEN		8</span>

<span class="k">enum</span> <span class="n">tcp_tw_status</span> <span class="p">{</span>
	<span class="n">TCP_TW_SUCCESS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">TCP_TW_RST</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">TCP_TW_ACK</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">TCP_TW_SYN</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">};</span>


<span class="k">extern</span> <span class="k">enum</span> <span class="n">tcp_tw_status</span> <span class="n">tcp_timewait_state_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">inet_timewait_sock</span> <span class="o">*</span><span class="n">tw</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						     <span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span> <span class="n">tcp_check_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">**</span><span class="n">prev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_child_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">tcp_use_frto</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_enter_frto</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_enter_loss</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_clear_retrans</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_update_metrics</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_init_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tcp_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="n">wait</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
			  <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
			  <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">compat_tcp_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">compat_tcp_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_set_keepalive</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_syn_ack_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		       <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">addr_len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_parse_options</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">tcp_options_received</span> <span class="o">*</span><span class="n">opt_rx</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">**</span><span class="n">hvpp</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">estab</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">tcp_parse_md5sig_option</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	TCP v4 functions exported for the inet6 API</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_v4_send_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_v4_conn_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span> <span class="n">tcp_create_openreq_child</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span> <span class="n">tcp_v4_syn_recv_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_v4_do_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_v4_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">addr_len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="n">tcp_make_synack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">request_values</span> <span class="o">*</span><span class="n">rvp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">tcp_connect_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">tcp_finish_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">tcp_send_rcvq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/* From syncookies.c */</span>
<span class="k">extern</span> <span class="n">__u32</span> <span class="n">syncookie_secret</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">16</span><span class="o">-</span><span class="mi">4</span><span class="o">+</span><span class="n">SHA_DIGEST_WORDS</span><span class="p">];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">cookie_v4_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> 
				    <span class="k">struct</span> <span class="n">ip_options</span> <span class="o">*</span><span class="n">opt</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SYN_COOKIES</span>
<span class="k">extern</span> <span class="n">__u32</span> <span class="n">cookie_v4_init_sequence</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> 
				     <span class="n">__u16</span> <span class="o">*</span><span class="n">mss</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">cookie_v4_init_sequence</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					    <span class="n">__u16</span> <span class="o">*</span><span class="n">mss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="n">__u32</span> <span class="n">cookie_init_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">cookie_check_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_options_received</span> <span class="o">*</span><span class="n">opt</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* From net/ipv6/syncookies.c */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">cookie_v6_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SYN_COOKIES</span>
<span class="k">extern</span> <span class="n">__u32</span> <span class="n">cookie_v6_init_sequence</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				     <span class="n">__u16</span> <span class="o">*</span><span class="n">mss</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">cookie_v6_init_sequence</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					    <span class="n">__u16</span> <span class="o">*</span><span class="n">mss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cm">/* tcp_output.c */</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__tcp_push_pending_frames</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_mss</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">nonagle</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">tcp_may_send_now</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_retransmit_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_retransmit_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_xmit_retransmit_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_simple_retransmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_trim_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_fragment</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_send_probe0</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_send_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_write_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_send_fin</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_send_active_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_send_synack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">tcp_syn_flood_action</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">proto</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_push_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss_now</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_send_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_send_delayed_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="cm">/* tcp_input.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_cwnd_application_limited</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_resume_early_retransmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_rearm_rto</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="cm">/* tcp_timer.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_init_xmit_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_clear_xmit_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inet_csk_clear_xmit_timers</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tcp_sync_mss</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pmtu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tcp_current_mss</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="cm">/* Bound MSS / TSO packet size with the half of the window */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_bound_to_half_wnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pktsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cutoff</span><span class="p">;</span>

	<span class="cm">/* When peer uses tiny windows, there is no use in packetizing</span>
<span class="cm">	 * to sub-MSS pieces for the sake of SWS or making sure there</span>
<span class="cm">	 * are enough packets in the pipe for fast recovery.</span>
<span class="cm">	 *</span>
<span class="cm">	 * On the other hand, for extremely large MSS devices, handling</span>
<span class="cm">	 * smaller than MSS windows in this way does make sense.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_window</span> <span class="o">&gt;=</span> <span class="mi">512</span><span class="p">)</span>
		<span class="n">cutoff</span> <span class="o">=</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_window</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cutoff</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_window</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cutoff</span> <span class="o">&amp;&amp;</span> <span class="n">pktsize</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="mi">68U</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">pktsize</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* tcp.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_get_info</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcp_info</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Read &#39;sendfile()&#39;-style from a TCP socket */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sk_read_actor_t</span><span class="p">)(</span><span class="n">read_descriptor_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_read_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">read_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
			 <span class="n">sk_read_actor_t</span> <span class="n">recv_actor</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_initialize_rcv_mss</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_mtu_to_mss</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pmtu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_mss_to_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mss</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_mtup_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_valid_rtt_meas</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq_rtt</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_bound_rto</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_rto</span> <span class="o">&gt;</span> <span class="n">TCP_RTO_MAX</span><span class="p">)</span>
		<span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_rto</span> <span class="o">=</span> <span class="n">TCP_RTO_MAX</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">__tcp_set_rto</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__tcp_fast_path_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">snd_wnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">pred_flags</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">)</span> <span class="o">|</span>
			       <span class="n">ntohl</span><span class="p">(</span><span class="n">TCP_FLAG_ACK</span><span class="p">)</span> <span class="o">|</span>
			       <span class="n">snd_wnd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_fast_path_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__tcp_fast_path_on</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wnd</span> <span class="o">&gt;&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">snd_wscale</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_fast_path_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span> <span class="o">&amp;&amp;</span>
	    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span><span class="p">)</span>
		<span class="n">tcp_fast_path_on</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Compute the actual rto_min value */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">tcp_rto_min</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">__sk_dst_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">rto_min</span> <span class="o">=</span> <span class="n">TCP_RTO_MIN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span> <span class="o">&amp;&amp;</span> <span class="n">dst_metric_locked</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_RTO_MIN</span><span class="p">))</span>
		<span class="n">rto_min</span> <span class="o">=</span> <span class="n">dst_metric_rtt</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_RTO_MIN</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rto_min</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Compute the actual receive window we are currently advertising.</span>
<span class="cm"> * Rcv_nxt can be after the window if our peer push more data</span>
<span class="cm"> * than the offered window.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">tcp_receive_window</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">win</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wup</span> <span class="o">+</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">win</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">win</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">win</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Choose a new window, without checks for shrinking, and without</span>
<span class="cm"> * scaling applied to the result.  The caller does these things</span>
<span class="cm"> * if necessary.  This is a &quot;raw&quot; window selection.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">__tcp_select_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">tcp_send_window_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="cm">/* TCP timestamps are only 32-bits, this causes a slight</span>
<span class="cm"> * complication on 64-bit systems since we store a snapshot</span>
<span class="cm"> * of jiffies in the buffer control blocks below.  We decided</span>
<span class="cm"> * to use only the low 32-bits of jiffies and hide the ugly</span>
<span class="cm"> * casts with the following macro.</span>
<span class="cm"> */</span>
<span class="cp">#define tcp_time_stamp		((__u32)(jiffies))</span>

<span class="cp">#define tcp_flag_byte(th) (((u_int8_t *)th)[13])</span>

<span class="cp">#define TCPHDR_FIN 0x01</span>
<span class="cp">#define TCPHDR_SYN 0x02</span>
<span class="cp">#define TCPHDR_RST 0x04</span>
<span class="cp">#define TCPHDR_PSH 0x08</span>
<span class="cp">#define TCPHDR_ACK 0x10</span>
<span class="cp">#define TCPHDR_URG 0x20</span>
<span class="cp">#define TCPHDR_ECE 0x40</span>
<span class="cp">#define TCPHDR_CWR 0x80</span>

<span class="cm">/* This is what the send packet queuing engine uses to pass</span>
<span class="cm"> * TCP per-packet control information to the transmission code.</span>
<span class="cm"> * We also store the host-order sequence numbers in here too.</span>
<span class="cm"> * This is 44 bytes if IPV6 is enabled.</span>
<span class="cm"> * If this grows please adjust skbuff.h:skbuff-&gt;cb[xxx] size appropriately.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tcp_skb_cb</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inet_skb_parm</span>	<span class="n">h4</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
		<span class="k">struct</span> <span class="n">inet6_skb_parm</span>	<span class="n">h6</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="n">header</span><span class="p">;</span>	<span class="cm">/* For incoming frames		*/</span>
	<span class="n">__u32</span>		<span class="n">seq</span><span class="p">;</span>		<span class="cm">/* Starting sequence number	*/</span>
	<span class="n">__u32</span>		<span class="n">end_seq</span><span class="p">;</span>	<span class="cm">/* SEQ + FIN + SYN + datalen	*/</span>
	<span class="n">__u32</span>		<span class="n">when</span><span class="p">;</span>		<span class="cm">/* used to compute rtt&#39;s	*/</span>
	<span class="n">__u8</span>		<span class="n">tcp_flags</span><span class="p">;</span>	<span class="cm">/* TCP header flags. (tcp[13])	*/</span>

	<span class="n">__u8</span>		<span class="n">sacked</span><span class="p">;</span>		<span class="cm">/* State flags for SACK/FACK.	*/</span>
<span class="cp">#define TCPCB_SACKED_ACKED	0x01	</span><span class="cm">/* SKB ACK&#39;d by a SACK block	*/</span><span class="cp"></span>
<span class="cp">#define TCPCB_SACKED_RETRANS	0x02	</span><span class="cm">/* SKB retransmitted		*/</span><span class="cp"></span>
<span class="cp">#define TCPCB_LOST		0x04	</span><span class="cm">/* SKB is lost			*/</span><span class="cp"></span>
<span class="cp">#define TCPCB_TAGBITS		0x07	</span><span class="cm">/* All tag bits			*/</span><span class="cp"></span>
<span class="cp">#define TCPCB_EVER_RETRANS	0x80	</span><span class="cm">/* Ever retransmitted frame	*/</span><span class="cp"></span>
<span class="cp">#define TCPCB_RETRANS		(TCPCB_SACKED_RETRANS|TCPCB_EVER_RETRANS)</span>

	<span class="n">__u8</span>		<span class="n">ip_dsfield</span><span class="p">;</span>	<span class="cm">/* IPv4 tos or IPv6 dsfield	*/</span>
	<span class="cm">/* 1 byte hole */</span>
	<span class="n">__u32</span>		<span class="n">ack_seq</span><span class="p">;</span>	<span class="cm">/* Sequence number ACK&#39;d	*/</span>
<span class="p">};</span>

<span class="cp">#define TCP_SKB_CB(__skb)	((struct tcp_skb_cb *)&amp;((__skb)-&gt;cb[0]))</span>

<span class="cm">/* RFC3168 : 6.1.1 SYN packets must not have ECT/ECN bits set</span>
<span class="cm"> *</span>
<span class="cm"> * If we receive a SYN packet with these bits set, it means a network is</span>
<span class="cm"> * playing bad games with TOS bits. In order to avoid possible false congestion</span>
<span class="cm"> * notifications, we disable TCP ECN negociation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">TCP_ECN_create_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_tcp_ecn</span> <span class="o">&amp;&amp;</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">ece</span> <span class="o">&amp;&amp;</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">cwr</span> <span class="o">&amp;&amp;</span>
	    <span class="n">INET_ECN_is_not_ect</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ip_dsfield</span><span class="p">))</span>
		<span class="n">inet_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ecn_ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Due to TSO, an SKB can be composed of multiple actual</span>
<span class="cm"> * packets.  To keep these tracked properly, we use this.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_skb_pcount</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is valid iff tcp_skb_pcount() &gt; 1. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_skb_mss</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Events passed to congestion control interface */</span>
<span class="k">enum</span> <span class="n">tcp_ca_event</span> <span class="p">{</span>
	<span class="n">CA_EVENT_TX_START</span><span class="p">,</span>	<span class="cm">/* first transmit when no packets in flight */</span>
	<span class="n">CA_EVENT_CWND_RESTART</span><span class="p">,</span>	<span class="cm">/* congestion window restart */</span>
	<span class="n">CA_EVENT_COMPLETE_CWR</span><span class="p">,</span>	<span class="cm">/* end of congestion recovery */</span>
	<span class="n">CA_EVENT_FRTO</span><span class="p">,</span>		<span class="cm">/* fast recovery timeout */</span>
	<span class="n">CA_EVENT_LOSS</span><span class="p">,</span>		<span class="cm">/* loss timeout */</span>
	<span class="n">CA_EVENT_FAST_ACK</span><span class="p">,</span>	<span class="cm">/* in sequence ack */</span>
	<span class="n">CA_EVENT_SLOW_ACK</span><span class="p">,</span>	<span class="cm">/* other ack */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Interface for adding new TCP congestion control handlers</span>
<span class="cm"> */</span>
<span class="cp">#define TCP_CA_NAME_MAX	16</span>
<span class="cp">#define TCP_CA_MAX	128</span>
<span class="cp">#define TCP_CA_BUF_MAX	(TCP_CA_NAME_MAX*TCP_CA_MAX)</span>

<span class="cp">#define TCP_CONG_NON_RESTRICTED 0x1</span>
<span class="cp">#define TCP_CONG_RTT_STAMP	0x2</span>

<span class="k">struct</span> <span class="n">tcp_congestion_ops</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* initialize private data (optional) */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="cm">/* cleanup private data  (optional) */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* return slow start threshold (required) */</span>
	<span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">ssthresh</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="cm">/* lower bound for congestion window (optional) */</span>
	<span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">min_cwnd</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="cm">/* do new cwnd calculation (required) */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cong_avoid</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ack</span><span class="p">,</span> <span class="n">u32</span> <span class="n">in_flight</span><span class="p">);</span>
	<span class="cm">/* call before changing ca_state (optional) */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_state</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u8</span> <span class="n">new_state</span><span class="p">);</span>
	<span class="cm">/* call when cwnd event occurs (optional) */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cwnd_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">enum</span> <span class="n">tcp_ca_event</span> <span class="n">ev</span><span class="p">);</span>
	<span class="cm">/* new value of cwnd after loss (optional) */</span>
	<span class="n">u32</span>  <span class="p">(</span><span class="o">*</span><span class="n">undo_cwnd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="cm">/* hook for packet ack accounting (optional) */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pkts_acked</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">num_acked</span><span class="p">,</span> <span class="n">s32</span> <span class="n">rtt_us</span><span class="p">);</span>
	<span class="cm">/* get info for inet_diag (optional) */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_info</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ext</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

	<span class="kt">char</span> 		<span class="n">name</span><span class="p">[</span><span class="n">TCP_CA_NAME_MAX</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">module</span> 	<span class="o">*</span><span class="n">owner</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_register_congestion_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_congestion_ops</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_unregister_congestion_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_congestion_ops</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_init_congestion_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_cleanup_congestion_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_set_default_congestion_control</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_get_default_congestion_control</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_get_available_congestion_control</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_get_allowed_congestion_control</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_set_allowed_congestion_control</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">allowed</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_set_congestion_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_slow_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_cong_avoid_ai</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">w</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">tcp_congestion_ops</span> <span class="n">tcp_init_congestion_ops</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">tcp_reno_ssthresh</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_reno_cong_avoid</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ack</span><span class="p">,</span> <span class="n">u32</span> <span class="n">in_flight</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">tcp_reno_min_cwnd</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">tcp_congestion_ops</span> <span class="n">tcp_reno</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_set_ca_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">ca_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="o">-&gt;</span><span class="n">set_state</span><span class="p">)</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="o">-&gt;</span><span class="n">set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ca_state</span><span class="p">);</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">=</span> <span class="n">ca_state</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_ca_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">enum</span> <span class="n">tcp_ca_event</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="o">-&gt;</span><span class="n">cwnd_event</span><span class="p">)</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="o">-&gt;</span><span class="n">cwnd_event</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* These functions determine how the current flow behaves in respect of SACK</span>
<span class="cm"> * handling. SACK is negotiated with the peer, and therefore it can vary</span>
<span class="cm"> * between different flows.</span>
<span class="cm"> *</span>
<span class="cm"> * tcp_is_sack - SACK enabled</span>
<span class="cm"> * tcp_is_reno - No SACK</span>
<span class="cm"> * tcp_is_fack - FACK enabled, implies SACK enabled</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_is_sack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">sack_ok</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_is_reno</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">tcp_is_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_is_fack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">sack_ok</span> <span class="o">&amp;</span> <span class="n">TCP_FACK_ENABLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_enable_fack</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">sack_ok</span> <span class="o">|=</span> <span class="n">TCP_FACK_ENABLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* TCP early-retransmit (ER) is similar to but more conservative than</span>
<span class="cm"> * the thin-dupack feature.  Enable ER only if thin-dupack is disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_enable_early_retrans</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">do_early_retrans</span> <span class="o">=</span> <span class="n">sysctl_tcp_early_retrans</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">sysctl_tcp_thin_dupack</span> <span class="o">&amp;&amp;</span> <span class="n">sysctl_tcp_reordering</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">early_retrans_delayed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_disable_early_retrans</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">do_early_retrans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tcp_left_out</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">+</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This determines how many packets are &quot;in the network&quot; to the best</span>
<span class="cm"> * of our knowledge.  In many cases it is conservative, but where</span>
<span class="cm"> * detailed information is available from the receiver (via SACK</span>
<span class="cm"> * blocks etc.) we can make more aggressive calculations.</span>
<span class="cm"> *</span>
<span class="cm"> * Use this for decisions involving congestion control, use just</span>
<span class="cm"> * tp-&gt;packets_out to determine if the send queue is empty or not.</span>
<span class="cm"> *</span>
<span class="cm"> * Read this equation as:</span>
<span class="cm"> *</span>
<span class="cm"> *	&quot;Packets sent once on transmission queue&quot; MINUS</span>
<span class="cm"> *	&quot;Packets left network, but not honestly ACKed yet&quot; PLUS</span>
<span class="cm"> *	&quot;Packets fast retransmitted&quot;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tcp_packets_in_flight</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">-</span> <span class="n">tcp_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">+</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define TCP_INFINITE_SSTHRESH	0x7fffffff</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_in_initial_slowstart</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">&gt;=</span> <span class="n">TCP_INFINITE_SSTHRESH</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* If cwnd &gt; ssthresh, we may raise ssthresh to be half-way to cwnd.</span>
<span class="cm"> * The exception is rate halving phase, when cwnd is decreasing towards</span>
<span class="cm"> * ssthresh.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">tcp_current_ssthresh</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCPF_CA_CWR</span> <span class="o">|</span> <span class="n">TCPF_CA_Recovery</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">,</span>
			   <span class="p">((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span>
			    <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/* Use define here intentionally to get WARN_ON location shown at the caller */</span>
<span class="cp">#define tcp_verify_left_out(tp)	WARN_ON(tcp_left_out(tp) &gt; tp-&gt;packets_out)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_enter_cwr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">set_ssthresh</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__u32</span> <span class="n">tcp_init_cwnd</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">);</span>

<span class="cm">/* The maximum number of MSS of available cwnd for which TSO defers</span>
<span class="cm"> * sending if not using sysctl_tcp_tso_win_divisor.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">tcp_max_tso_deferred_mss</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Slow start with delack produces 3 packets of burst, so that</span>
<span class="cm"> * it is safe &quot;de facto&quot;.  This will be the default - same as</span>
<span class="cm"> * the default reordering threshold - but if reordering increases,</span>
<span class="cm"> * we must be able to allow cwnd to burst at least this much in order</span>
<span class="cm"> * to not pull it back when holes are filled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="n">__u32</span> <span class="nf">tcp_max_burst</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns end sequence number of the receiver&#39;s advertised window */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">tcp_wnd_end</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">+</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wnd</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">tcp_is_cwnd_limited</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">in_flight</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_minshall_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">mss</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_sml</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_check_probe_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_pending</span><span class="p">)</span>
		<span class="n">inet_csk_reset_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_PROBE0</span><span class="p">,</span>
					  <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_rto</span><span class="p">,</span> <span class="n">TCP_RTO_MAX</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_init_wl</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wl1</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_update_wl</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wl1</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate(/check) TCP checksum</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__sum16</span> <span class="nf">tcp_v4_check</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">saddr</span><span class="p">,</span>
				   <span class="n">__be32</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">__wsum</span> <span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">csum_tcpudp_magic</span><span class="p">(</span><span class="n">saddr</span><span class="p">,</span><span class="n">daddr</span><span class="p">,</span><span class="n">len</span><span class="p">,</span><span class="n">IPPROTO_TCP</span><span class="p">,</span><span class="n">base</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__sum16</span> <span class="nf">__tcp_checksum_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__skb_checksum_complete</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_checksum_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">skb_csum_unnecessary</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">__tcp_checksum_complete</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Prequeue for VJ style copy to user, combined with checksumming. */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_prequeue_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">memory</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">prequeue</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NET_DMA</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">wakeup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">pinned_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Packet is added to VJ-style prequeue for processing in process</span>
<span class="cm"> * context, if a reader task is waiting. Apparently, this exciting</span>
<span class="cm"> * idea (VJ&#39;s mail &quot;Re: query about TCP header on tcp-ip&quot; of 07 Sep 93)</span>
<span class="cm"> * failed somewhere. Latency? Burstiness? Well, at least now we will</span>
<span class="cm"> * see, why it failed. 8)8)				  --ANK</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: is this not too big to inline?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_prequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_tcp_low_latency</span> <span class="o">||</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">prequeue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">memory</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">memory</span> <span class="o">&gt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb1</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>

		<span class="k">while</span> <span class="p">((</span><span class="n">skb1</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">prequeue</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sk_backlog_rcv</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb1</span><span class="p">);</span>
			<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
					 <span class="n">LINUX_MIB_TCPPREQUEUEDROPPED</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">memory</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">prequeue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wake_up_interruptible_sync_poll</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
					   <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span> <span class="o">|</span> <span class="n">POLLRDBAND</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inet_csk_ack_scheduled</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="n">inet_csk_reset_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_DACK</span><span class="p">,</span>
						  <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">tcp_rto_min</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span>
						  <span class="n">TCP_RTO_MAX</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#undef STATE_TRACE</span>

<span class="cp">#ifdef STATE_TRACE</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">statename</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span>
	<span class="s">&quot;Unused&quot;</span><span class="p">,</span><span class="s">&quot;Established&quot;</span><span class="p">,</span><span class="s">&quot;Syn Sent&quot;</span><span class="p">,</span><span class="s">&quot;Syn Recv&quot;</span><span class="p">,</span>
	<span class="s">&quot;Fin Wait 1&quot;</span><span class="p">,</span><span class="s">&quot;Fin Wait 2&quot;</span><span class="p">,</span><span class="s">&quot;Time Wait&quot;</span><span class="p">,</span> <span class="s">&quot;Close&quot;</span><span class="p">,</span>
	<span class="s">&quot;Close Wait&quot;</span><span class="p">,</span><span class="s">&quot;Last ACK&quot;</span><span class="p">,</span><span class="s">&quot;Listen&quot;</span><span class="p">,</span><span class="s">&quot;Closing&quot;</span>
<span class="p">};</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_set_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_sack_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_options_received</span> <span class="o">*</span><span class="n">rx_opt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">dsack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">num_sacks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Determine a window scaling and initial window to offer. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_select_initial_window</span><span class="p">(</span><span class="kt">int</span> <span class="n">__space</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">mss</span><span class="p">,</span>
				      <span class="n">__u32</span> <span class="o">*</span><span class="n">rcv_wnd</span><span class="p">,</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">window_clamp</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">wscale_ok</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">rcv_wscale</span><span class="p">,</span>
				      <span class="n">__u32</span> <span class="n">init_rcv_wnd</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_win_from_space</span><span class="p">(</span><span class="kt">int</span> <span class="n">space</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sysctl_tcp_adv_win_scale</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="o">?</span>
		<span class="p">(</span><span class="n">space</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">-</span><span class="n">sysctl_tcp_adv_win_scale</span><span class="p">))</span> <span class="o">:</span>
		<span class="n">space</span> <span class="o">-</span> <span class="p">(</span><span class="n">space</span><span class="o">&gt;&gt;</span><span class="n">sysctl_tcp_adv_win_scale</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Note: caller must be prepared to deal with negative returns */</span> 
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_space</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tcp_win_from_space</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">-</span>
				  <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">));</span>
<span class="p">}</span> 

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_full_space</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tcp_win_from_space</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">);</span> 
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_openreq_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">tcp_options_received</span> <span class="o">*</span><span class="n">rx_opt</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_request_sock</span> <span class="o">*</span><span class="n">ireq</span> <span class="o">=</span> <span class="n">inet_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* So that tcp_send_synack() knows! */</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">cookie_ts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rcv_isn</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">mss</span> <span class="o">=</span> <span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">mss_clamp</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ts_recent</span> <span class="o">=</span> <span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">saw_tstamp</span> <span class="o">?</span> <span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">rcv_tsval</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ireq</span><span class="o">-&gt;</span><span class="n">tstamp_ok</span> <span class="o">=</span> <span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">tstamp_ok</span><span class="p">;</span>
	<span class="n">ireq</span><span class="o">-&gt;</span><span class="n">sack_ok</span> <span class="o">=</span> <span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">sack_ok</span><span class="p">;</span>
	<span class="n">ireq</span><span class="o">-&gt;</span><span class="n">snd_wscale</span> <span class="o">=</span> <span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">snd_wscale</span><span class="p">;</span>
	<span class="n">ireq</span><span class="o">-&gt;</span><span class="n">wscale_ok</span> <span class="o">=</span> <span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">wscale_ok</span><span class="p">;</span>
	<span class="n">ireq</span><span class="o">-&gt;</span><span class="n">acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ireq</span><span class="o">-&gt;</span><span class="n">ecn_ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ireq</span><span class="o">-&gt;</span><span class="n">rmt_port</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">;</span>
	<span class="n">ireq</span><span class="o">-&gt;</span><span class="n">loc_port</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_enter_memory_pressure</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">keepalive_intvl_when</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">keepalive_intvl</span> <span class="o">?</span> <span class="o">:</span> <span class="n">sysctl_tcp_keepalive_intvl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">keepalive_time_when</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">keepalive_time</span> <span class="o">?</span> <span class="o">:</span> <span class="n">sysctl_tcp_keepalive_time</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">keepalive_probes</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">keepalive_probes</span> <span class="o">?</span> <span class="o">:</span> <span class="n">sysctl_tcp_keepalive_probes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">keepalive_time_elapsed</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">inet_conn</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">tcp_time_stamp</span> <span class="o">-</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">lrcvtime</span><span class="p">,</span>
			  <span class="n">tcp_time_stamp</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_tstamp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_fin_time</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fin_timeout</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">linger2</span> <span class="o">?</span> <span class="o">:</span> <span class="n">sysctl_tcp_fin_timeout</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">rto</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_rto</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fin_timeout</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">rto</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">rto</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">fin_timeout</span> <span class="o">=</span> <span class="p">(</span><span class="n">rto</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">rto</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fin_timeout</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_paws_check</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_options_received</span> <span class="o">*</span><span class="n">rx_opt</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">paws_win</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">s32</span><span class="p">)(</span><span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">ts_recent</span> <span class="o">-</span> <span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">rcv_tsval</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">paws_win</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">get_seconds</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">ts_recent_stamp</span> <span class="o">+</span> <span class="n">TCP_PAWS_24DAYS</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Some OSes send SYN and SYNACK messages with tsval=0 tsecr=0,</span>
<span class="cm">	 * then following tcp messages have valid values. Ignore 0 value,</span>
<span class="cm">	 * or else &#39;negative&#39; tsval might forbid us to accept their packets.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">ts_recent</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_paws_reject</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_options_received</span> <span class="o">*</span><span class="n">rx_opt</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">rst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_paws_check</span><span class="p">(</span><span class="n">rx_opt</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* RST segments are not recommended to carry timestamp,</span>
<span class="cm">	   and, if they do, it is recommended to ignore PAWS because</span>
<span class="cm">	   &quot;their cleanup function should take precedence over timestamps.&quot;</span>
<span class="cm">	   Certainly, it is mistake. It is necessary to understand the reasons</span>
<span class="cm">	   of this constraint to relax it: if peer reboots, clock may go</span>
<span class="cm">	   out-of-sync and half-open connections will not be reset.</span>
<span class="cm">	   Actually, the problem would be not existing if all</span>
<span class="cm">	   the implementations followed draft about maintaining clock</span>
<span class="cm">	   via reboots. Linux-2.2 DOES NOT!</span>

<span class="cm">	   However, we can relax time bounds for RST segments to MSL.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rst</span> <span class="o">&amp;&amp;</span> <span class="n">get_seconds</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">rx_opt</span><span class="o">-&gt;</span><span class="n">ts_recent_stamp</span> <span class="o">+</span> <span class="n">TCP_PAWS_MSL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_mib_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* See RFC 2012 */</span>
	<span class="n">TCP_ADD_STATS_USER</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">TCP_MIB_RTOALGORITHM</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">TCP_ADD_STATS_USER</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">TCP_MIB_RTOMIN</span><span class="p">,</span> <span class="n">TCP_RTO_MIN</span><span class="o">*</span><span class="mi">1000</span><span class="o">/</span><span class="n">HZ</span><span class="p">);</span>
	<span class="n">TCP_ADD_STATS_USER</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">TCP_MIB_RTOMAX</span><span class="p">,</span> <span class="n">TCP_RTO_MAX</span><span class="o">*</span><span class="mi">1000</span><span class="o">/</span><span class="n">HZ</span><span class="p">);</span>
	<span class="n">TCP_ADD_STATS_USER</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">TCP_MIB_MAXCONN</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* from STCP */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_clear_retrans_hints_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_skb_hint</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">scoreboard_skb_hint</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_clear_all_retrans_hints</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tcp_clear_retrans_hints_partial</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_skb_hint</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* MD5 Signature */</span>
<span class="k">struct</span> <span class="n">crypto_hash</span><span class="p">;</span>

<span class="k">union</span> <span class="n">tcp_md5_addr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">in_addr</span>  <span class="n">a4</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">struct</span> <span class="n">in6_addr</span>	<span class="n">a6</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* - key database */</span>
<span class="k">struct</span> <span class="n">tcp_md5sig_key</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">node</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">keylen</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">family</span><span class="p">;</span> <span class="cm">/* AF_INET or AF_INET6 */</span>
	<span class="k">union</span> <span class="n">tcp_md5_addr</span>	<span class="n">addr</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">key</span><span class="p">[</span><span class="n">TCP_MD5SIG_MAXKEYLEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">rcu_head</span>		<span class="n">rcu</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* - sock block */</span>
<span class="k">struct</span> <span class="n">tcp_md5sig_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span>		<span class="n">rcu</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* - pseudo header */</span>
<span class="k">struct</span> <span class="n">tcp4_pseudohdr</span> <span class="p">{</span>
	<span class="n">__be32</span>		<span class="n">saddr</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">daddr</span><span class="p">;</span>
	<span class="n">__u8</span>		<span class="n">pad</span><span class="p">;</span>
	<span class="n">__u8</span>		<span class="n">protocol</span><span class="p">;</span>
	<span class="n">__be16</span>		<span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tcp6_pseudohdr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">in6_addr</span>	<span class="n">saddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in6_addr</span> <span class="n">daddr</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">len</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">protocol</span><span class="p">;</span>	<span class="cm">/* including padding */</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">tcp_md5sum_block</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp4_pseudohdr</span> <span class="n">ip4</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">struct</span> <span class="n">tcp6_pseudohdr</span> <span class="n">ip6</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* - pool: digest algorithm, hash description and scratch buffer */</span>
<span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hash_desc</span>	<span class="n">md5_desc</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">tcp_md5sum_block</span>	<span class="n">md5_blk</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* - functions */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_v4_md5_hash_skb</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">md5_hash</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcp_md5sig_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_md5_do_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">tcp_md5_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">newkey</span><span class="p">,</span>
			  <span class="n">u8</span> <span class="n">newkeylen</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_md5_do_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">tcp_md5_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">family</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">tcp_md5sig_key</span> <span class="o">*</span><span class="n">tcp_v4_md5_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">addr_sk</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">tcp_md5sig_key</span> <span class="o">*</span><span class="n">tcp_md5_do_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">union</span> <span class="n">tcp_md5_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">);</span>
<span class="cp">#define tcp_twsk_md5_key(twsk)	((twsk)-&gt;tw_md5_key)</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tcp_md5sig_key</span> <span class="o">*</span><span class="nf">tcp_md5_do_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">union</span> <span class="n">tcp_md5_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define tcp_twsk_md5_key(twsk)	NULL</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">tcp_alloc_md5sig_pool</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_free_md5sig_pool</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">tcp_md5sig_pool</span>	<span class="o">*</span><span class="n">tcp_get_md5sig_pool</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_put_md5sig_pool</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_md5_hash_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_md5_hash_skb_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">header_len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_md5_hash_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="o">*</span><span class="n">hp</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_md5sig_key</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>

<span class="cm">/* write queue abstraction */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_write_queue_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">sk_wmem_free_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">sk_mem_reclaim</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">tcp_clear_all_retrans_hints</span><span class="p">(</span><span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">tcp_write_queue_head</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">tcp_write_queue_tail</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_peek_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">tcp_write_queue_next</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
						   <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_queue_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">tcp_write_queue_prev</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
						   <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_queue_prev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define tcp_for_write_queue(skb, sk)					\</span>
<span class="cp">	skb_queue_walk(&amp;(sk)-&gt;sk_write_queue, skb)</span>

<span class="cp">#define tcp_for_write_queue_from(skb, sk)				\</span>
<span class="cp">	skb_queue_walk_from(&amp;(sk)-&gt;sk_write_queue, skb)</span>

<span class="cp">#define tcp_for_write_queue_from_safe(skb, tmp, sk)			\</span>
<span class="cp">	skb_queue_walk_from_safe(&amp;(sk)-&gt;sk_write_queue, skb, tmp)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">tcp_send_head</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_skb_is_last</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_queue_is_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_advance_send_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_skb_is_last</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span> <span class="o">=</span> <span class="n">tcp_write_queue_next</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_check_send_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_unlinked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span> <span class="o">==</span> <span class="n">skb_unlinked</span><span class="p">)</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_init_send_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__tcp_add_write_queue_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_add_write_queue_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__tcp_add_write_queue_tail</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Queue it, remembering where we must start sending. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">highest_sack</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">highest_sack</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__tcp_add_write_queue_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Insert buff after skb on the write queue of sk.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_insert_write_queue_after</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_queue_after</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">buff</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Insert new before skb on the write queue of sk.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_insert_write_queue_before</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_queue_before</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span> <span class="o">==</span> <span class="n">skb</span><span class="p">)</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_unlink_write_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_write_queue_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_push_pending_frames</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="n">__tcp_push_pending_frames</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">tcp_current_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">nonagle</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Start sequence of the skb just after the highest skb with SACKed</span>
<span class="cm"> * bit, valid only if sacked_out &gt; 0 or when the caller has ensured</span>
<span class="cm"> * validity by itself.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">tcp_highest_sack_seq</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">highest_sack</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">highest_sack</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_advance_highest_sack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">highest_sack</span> <span class="o">=</span> <span class="n">tcp_skb_is_last</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span>
						<span class="n">tcp_write_queue_next</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">tcp_highest_sack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">highest_sack</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_highest_sack_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">highest_sack</span> <span class="o">=</span> <span class="n">tcp_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Called when old skb is about to be deleted (to be combined with new skb) */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_highest_sack_combine</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">highest_sack</span><span class="p">))</span>
		<span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">highest_sack</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Determines whether this is a thin stream (which may suffer from</span>
<span class="cm"> * increased latency). Used to trigger latency-reducing mechanisms.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_stream_is_thin</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tcp_in_initial_slowstart</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* /proc */</span>
<span class="k">enum</span> <span class="n">tcp_seq_states</span> <span class="p">{</span>
	<span class="n">TCP_SEQ_STATE_LISTENING</span><span class="p">,</span>
	<span class="n">TCP_SEQ_STATE_OPENREQ</span><span class="p">,</span>
	<span class="n">TCP_SEQ_STATE_ESTABLISHED</span><span class="p">,</span>
	<span class="n">TCP_SEQ_STATE_TIME_WAIT</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">tcp_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">tcp_seq_afinfo</span> <span class="p">{</span>
	<span class="kt">char</span>				<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">sa_family_t</span>			<span class="n">family</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span>	<span class="o">*</span><span class="n">seq_fops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">seq_operations</span>		<span class="n">seq_ops</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tcp_iter_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_net_private</span>	<span class="n">p</span><span class="p">;</span>
	<span class="n">sa_family_t</span>		<span class="n">family</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">tcp_seq_states</span>	<span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span>		<span class="o">*</span><span class="n">syn_wait_sk</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">bucket</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">sbucket</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">uid</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">last_pos</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_proc_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcp_seq_afinfo</span> <span class="o">*</span><span class="n">afinfo</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_proc_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcp_seq_afinfo</span> <span class="o">*</span><span class="n">afinfo</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">request_sock_ops</span> <span class="n">tcp_request_sock_ops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">request_sock_ops</span> <span class="n">tcp6_request_sock_ops</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_v4_destroy_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_v4_gso_send_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tcp_tso_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">tcp_gro_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">head</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">tcp4_gro_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">head</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_gro_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp4_gro_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp4_proc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp4_proc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* TCP af-specific functions */</span>
<span class="k">struct</span> <span class="n">tcp_sock_af_ops</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
	<span class="k">struct</span> <span class="n">tcp_md5sig_key</span>	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">md5_lookup</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">addr_sk</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">calc_md5_hash</span><span class="p">)</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">tcp_md5sig_key</span> <span class="o">*</span><span class="n">md5</span><span class="p">,</span>
						  <span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
						  <span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
						  <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">md5_parse</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					      <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">optlen</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tcp_request_sock_ops</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
	<span class="k">struct</span> <span class="n">tcp_md5sig_key</span>	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">md5_lookup</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">calc_md5_hash</span><span class="p">)</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">tcp_md5sig_key</span> <span class="o">*</span><span class="n">md5</span><span class="p">,</span>
						  <span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
						  <span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
						  <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* Using SHA1 for now, define some constants.</span>
<span class="cm"> */</span>
<span class="cp">#define COOKIE_DIGEST_WORDS (SHA_DIGEST_WORDS)</span>
<span class="cp">#define COOKIE_MESSAGE_WORDS (SHA_MESSAGE_BYTES / 4)</span>
<span class="cp">#define COOKIE_WORKSPACE_WORDS (COOKIE_DIGEST_WORDS + COOKIE_MESSAGE_WORDS)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">tcp_cookie_generator</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">bakery</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	struct tcp_cookie_values - each socket needs extra space for the</span>
<span class="cm"> *	cookies, together with (optional) space for any SYN data.</span>
<span class="cm"> *</span>
<span class="cm"> *	A tcp_sock contains a pointer to the current value, and this is</span>
<span class="cm"> *	cloned to the tcp_timewait_sock.</span>
<span class="cm"> *</span>
<span class="cm"> * @cookie_pair:	variable data from the option exchange.</span>
<span class="cm"> *</span>
<span class="cm"> * @cookie_desired:	user specified tcpct_cookie_desired.  Zero</span>
<span class="cm"> *			indicates default (sysctl_tcp_cookie_size).</span>
<span class="cm"> *			After cookie sent, remembers size of cookie.</span>
<span class="cm"> *			Range 0, TCP_COOKIE_MIN to TCP_COOKIE_MAX.</span>
<span class="cm"> *</span>
<span class="cm"> * @s_data_desired:	user specified tcpct_s_data_desired.  When the</span>
<span class="cm"> *			constant payload is specified (@s_data_constant),</span>
<span class="cm"> *			holds its length instead.</span>
<span class="cm"> *			Range 0 to TCP_MSS_DESIRED.</span>
<span class="cm"> *</span>
<span class="cm"> * @s_data_payload:	constant data that is to be included in the</span>
<span class="cm"> *			payload of SYN or SYNACK segments when the</span>
<span class="cm"> *			cookie option is present.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tcp_cookie_values</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kref</span>	<span class="n">kref</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">cookie_pair</span><span class="p">[</span><span class="n">TCP_COOKIE_PAIR_SIZE</span><span class="p">];</span>
	<span class="n">u8</span>		<span class="n">cookie_pair_size</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">cookie_desired</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">s_data_desired</span><span class="o">:</span><span class="mi">11</span><span class="p">,</span>
			<span class="nl">s_data_constant:</span><span class="mi">1</span><span class="p">,</span>
			<span class="nl">s_data_in:</span><span class="mi">1</span><span class="p">,</span>
			<span class="nl">s_data_out:</span><span class="mi">1</span><span class="p">,</span>
			<span class="nl">s_data_unused:</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">s_data_payload</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_cookie_values_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcp_cookie_values</span><span class="p">,</span> <span class="n">kref</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* The length of constant payload data.  Note that s_data_desired is</span>
<span class="cm"> * overloaded, depending on s_data_constant: either the length of constant</span>
<span class="cm"> * data (returned here) or the limit on variable data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_s_data_size</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span><span class="o">-&gt;</span><span class="n">s_data_constant</span><span class="p">)</span>
		<span class="o">?</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span><span class="o">-&gt;</span><span class="n">s_data_desired</span>
		<span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	struct tcp_extend_values - tcp_ipv?.c to tcp_output.c workspace.</span>
<span class="cm"> *</span>
<span class="cm"> *	As tcp_request_sock has already been extended in other places, the</span>
<span class="cm"> *	only remaining method is to pass stack values along as function</span>
<span class="cm"> *	parameters.  These parameters are not needed after sending SYNACK.</span>
<span class="cm"> *</span>
<span class="cm"> * @cookie_bakery:	cryptographic secret and message workspace.</span>
<span class="cm"> *</span>
<span class="cm"> * @cookie_plus:	bytes in authenticator/cookie option, copied from</span>
<span class="cm"> *			struct tcp_options_received (above).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tcp_extend_values</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_values</span>		<span class="n">rv</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">cookie_bakery</span><span class="p">[</span><span class="n">COOKIE_WORKSPACE_WORDS</span><span class="p">];</span>
	<span class="n">u8</span>				<span class="n">cookie_plus</span><span class="o">:</span><span class="mi">6</span><span class="p">,</span>
					<span class="nl">cookie_out_never:</span><span class="mi">1</span><span class="p">,</span>
					<span class="nl">cookie_in_always:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tcp_extend_values</span> <span class="o">*</span><span class="nf">tcp_xv</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_values</span> <span class="o">*</span><span class="n">rvp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tcp_extend_values</span> <span class="o">*</span><span class="p">)</span><span class="n">rvp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_v4_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tcp_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif	</span><span class="cm">/* _TCP_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
