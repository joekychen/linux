<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › inet_hashtables.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>inet_hashtables.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * INET		An implementation of the TCP/IP protocol suite for the LINUX</span>
<span class="cm"> *		operating system.  INET is implemented using the BSD Socket</span>
<span class="cm"> *		interface as the means of communication with the user level.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:	Lotsa people, from code originally in tcp</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or</span>
<span class="cm"> *      modify it under the terms of the GNU General Public License</span>
<span class="cm"> *      as published by the Free Software Foundation; either version</span>
<span class="cm"> *      2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _INET_HASHTABLES_H</span>
<span class="cp">#define _INET_HASHTABLES_H</span>


<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>

<span class="cp">#include &lt;net/inet_connection_sock.h&gt;</span>
<span class="cp">#include &lt;net/inet_sock.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/route.h&gt;</span>
<span class="cp">#include &lt;net/tcp_states.h&gt;</span>
<span class="cp">#include &lt;net/netns/hash.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cm">/* This is for all connections with a full identity, no wildcards.</span>
<span class="cm"> * One chain is dedicated to TIME_WAIT sockets.</span>
<span class="cm"> * I&#39;ll experiment with dynamic table growth later.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inet_ehash_bucket</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_head</span> <span class="n">chain</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_head</span> <span class="n">twchain</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* There are a few simple rules, which allow for local port reuse by</span>
<span class="cm"> * an application.  In essence:</span>
<span class="cm"> *</span>
<span class="cm"> *	1) Sockets bound to different interfaces may share a local port.</span>
<span class="cm"> *	   Failing that, goto test 2.</span>
<span class="cm"> *	2) If all sockets have sk-&gt;sk_reuse set, and none of them are in</span>
<span class="cm"> *	   TCP_LISTEN state, the port may be shared.</span>
<span class="cm"> *	   Failing that, goto test 3.</span>
<span class="cm"> *	3) If all sockets are bound to a specific inet_sk(sk)-&gt;rcv_saddr local</span>
<span class="cm"> *	   address, and none of them are the same, the port may be</span>
<span class="cm"> *	   shared.</span>
<span class="cm"> *	   Failing this, the port cannot be shared.</span>
<span class="cm"> *</span>
<span class="cm"> * The interesting point, is test #2.  This is what an FTP server does</span>
<span class="cm"> * all day.  To optimize this case we use a specific flag bit defined</span>
<span class="cm"> * below.  As we add sockets to a bind bucket list, we perform a</span>
<span class="cm"> * check of: (newsk-&gt;sk_reuse &amp;&amp; (newsk-&gt;sk_state != TCP_LISTEN))</span>
<span class="cm"> * As long as all sockets added to a bind bucket pass this test,</span>
<span class="cm"> * the flag bit will be set.</span>
<span class="cm"> * The resulting situation is that tcp_v[46]_verify_bind() can just check</span>
<span class="cm"> * for this flag bit, if it is set and the socket trying to bind has</span>
<span class="cm"> * sk-&gt;sk_reuse set, we don&#39;t even have to walk the owners list at all,</span>
<span class="cm"> * we return that it is ok to bind this socket to the requested local port.</span>
<span class="cm"> *</span>
<span class="cm"> * Sounds like a lot of work, but it is worth it.  In a more naive</span>
<span class="cm"> * implementation (ie. current FreeBSD etc.) the entire list of ports</span>
<span class="cm"> * must be walked for each data port opened by an ftp server.  Needless</span>
<span class="cm"> * to say, this does not scale at all.  With a couple thousand FTP</span>
<span class="cm"> * users logged onto your box, isn&#39;t it nice to know that new data</span>
<span class="cm"> * ports are created in O(1) time?  I thought so. ;-)	-DaveM</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inet_bind_bucket</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_NET_NS</span>
	<span class="k">struct</span> <span class="n">net</span>		<span class="o">*</span><span class="n">ib_net</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">port</span><span class="p">;</span>
	<span class="kt">signed</span> <span class="kt">short</span>		<span class="n">fastreuse</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">num_owners</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="n">owners</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">ib_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">inet_bind_bucket</span> <span class="o">*</span><span class="n">ib</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">read_pnet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ib</span><span class="o">-&gt;</span><span class="n">ib_net</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define inet_bind_bucket_for_each(tb, pos, head) \</span>
<span class="cp">	hlist_for_each_entry(tb, pos, head, node)</span>

<span class="k">struct</span> <span class="n">inet_bind_hashbucket</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="n">chain</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Sockets can be hashed in established or listening table</span>
<span class="cm"> * We must use different &#39;nulls&#39; end-of-chain value for listening</span>
<span class="cm"> * hash table, or we might find a socket that was closed and</span>
<span class="cm"> * reallocated/inserted into established hash table</span>
<span class="cm"> */</span>
<span class="cp">#define LISTENING_NULLS_BASE (1U &lt;&lt; 29)</span>
<span class="k">struct</span> <span class="n">inet_listen_hashbucket</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_head</span>	<span class="n">head</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* This is for listening sockets, thus all sockets which possess wildcards. */</span>
<span class="cp">#define INET_LHTABLE_SIZE	32	</span><span class="cm">/* Yes, really, this is all you need. */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">inet_hashinfo</span> <span class="p">{</span>
	<span class="cm">/* This is for sockets with full identity only.  Sockets here will</span>
<span class="cm">	 * always be without wildcards and will have the following invariant:</span>
<span class="cm">	 *</span>
<span class="cm">	 *          TCP_ESTABLISHED &lt;= sk-&gt;sk_state &lt; TCP_CLOSE</span>
<span class="cm">	 *</span>
<span class="cm">	 * TIME_WAIT sockets use a separate chain (twchain).</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">inet_ehash_bucket</span>	<span class="o">*</span><span class="n">ehash</span><span class="p">;</span>
	<span class="n">spinlock_t</span>			<span class="o">*</span><span class="n">ehash_locks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">ehash_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">ehash_locks_mask</span><span class="p">;</span>

	<span class="cm">/* Ok, let&#39;s try this, I give up, we do need a local binding</span>
<span class="cm">	 * TCP hash as well as the others for fast bind/connect.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">inet_bind_hashbucket</span>	<span class="o">*</span><span class="n">bhash</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">bhash_size</span><span class="p">;</span>
	<span class="cm">/* 4 bytes hole on 64 bit */</span>

	<span class="k">struct</span> <span class="n">kmem_cache</span>		<span class="o">*</span><span class="n">bind_bucket_cachep</span><span class="p">;</span>

	<span class="cm">/* All the above members are written once at bootup and</span>
<span class="cm">	 * never written again _or_ are predominantly read-access.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Now align to a new cache line as all the following members</span>
<span class="cm">	 * might be often dirty.</span>
<span class="cm">	 */</span>
	<span class="cm">/* All sockets in TCP_LISTEN state will be in here.  This is the only</span>
<span class="cm">	 * table where wildcard&#39;d TCP sockets can exist.  Hash function here</span>
<span class="cm">	 * is just local port number.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">inet_listen_hashbucket</span>	<span class="n">listening_hash</span><span class="p">[</span><span class="n">INET_LHTABLE_SIZE</span><span class="p">]</span>
					<span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

	<span class="n">atomic_t</span>			<span class="n">bsockets</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">inet_ehash_bucket</span> <span class="o">*</span><span class="nf">inet_ehash_bucket</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inet_hashinfo</span> <span class="o">*</span><span class="n">hashinfo</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">hashinfo</span><span class="o">-&gt;</span><span class="n">ehash</span><span class="p">[</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="n">hashinfo</span><span class="o">-&gt;</span><span class="n">ehash_mask</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">spinlock_t</span> <span class="o">*</span><span class="nf">inet_ehash_lockp</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inet_hashinfo</span> <span class="o">*</span><span class="n">hashinfo</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">hashinfo</span><span class="o">-&gt;</span><span class="n">ehash_locks</span><span class="p">[</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="n">hashinfo</span><span class="o">-&gt;</span><span class="n">ehash_locks_mask</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">inet_ehash_locks_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inet_hashinfo</span> <span class="o">*</span><span class="n">hashinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_PROVE_LOCKING)</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pcpus</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pcpus</span> <span class="o">=</span> <span class="n">num_possible_cpus</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pcpus</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pcpus</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pcpus</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pcpus</span> <span class="o">&gt;=</span> <span class="mi">32</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">spinlock_t</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">spinlock_t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
			<span class="n">hashinfo</span><span class="o">-&gt;</span><span class="n">ehash_locks</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">spinlock_t</span><span class="p">));</span>
		<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">hashinfo</span><span class="o">-&gt;</span><span class="n">ehash_locks</span> <span class="o">=</span>	<span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">spinlock_t</span><span class="p">),</span>
						<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hashinfo</span><span class="o">-&gt;</span><span class="n">ehash_locks</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashinfo</span><span class="o">-&gt;</span><span class="n">ehash_locks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">hashinfo</span><span class="o">-&gt;</span><span class="n">ehash_locks_mask</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inet_ehash_locks_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">inet_hashinfo</span> <span class="o">*</span><span class="n">hashinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hashinfo</span><span class="o">-&gt;</span><span class="n">ehash_locks</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">hashinfo</span><span class="o">-&gt;</span><span class="n">ehash_locks_mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
							<span class="k">sizeof</span><span class="p">(</span><span class="n">spinlock_t</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
			<span class="n">vfree</span><span class="p">(</span><span class="n">hashinfo</span><span class="o">-&gt;</span><span class="n">ehash_locks</span><span class="p">);</span>
		<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">hashinfo</span><span class="o">-&gt;</span><span class="n">ehash_locks</span><span class="p">);</span>
		<span class="n">hashinfo</span><span class="o">-&gt;</span><span class="n">ehash_locks</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">inet_bind_bucket</span> <span class="o">*</span>
		    <span class="n">inet_bind_bucket_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">inet_bind_hashbucket</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">snum</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">inet_bind_bucket_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">inet_bind_bucket</span> <span class="o">*</span><span class="n">tb</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">inet_bhashfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">__u16</span> <span class="n">lport</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">bhash_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">lport</span> <span class="o">+</span> <span class="n">net_hash_mix</span><span class="p">(</span><span class="n">net</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bhash_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">inet_bind_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inet_bind_bucket</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">snum</span><span class="p">);</span>

<span class="cm">/* These can have wildcards, don&#39;t try too hard. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">inet_lhashfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">num</span> <span class="o">+</span> <span class="n">net_hash_mix</span><span class="p">(</span><span class="n">net</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INET_LHTABLE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">inet_sk_listen_hashfn</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inet_lhashfn</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inet_num</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Caller must disable local BH processing. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__inet_inherit_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">child</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">inet_put_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">inet_hashinfo_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">inet_hashinfo</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__inet_hash_nolisten</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inet_timewait_sock</span> <span class="o">*</span><span class="n">tw</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">inet_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">inet_unhash</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">__inet_lookup_listener</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">inet_hashinfo</span> <span class="o">*</span><span class="n">hashinfo</span><span class="p">,</span>
					   <span class="k">const</span> <span class="n">__be32</span> <span class="n">daddr</span><span class="p">,</span>
					   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">hnum</span><span class="p">,</span>
					   <span class="k">const</span> <span class="kt">int</span> <span class="n">dif</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">inet_lookup_listener</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">inet_hashinfo</span> <span class="o">*</span><span class="n">hashinfo</span><span class="p">,</span>
		<span class="n">__be32</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">dport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__inet_lookup_listener</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">hashinfo</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">dport</span><span class="p">),</span> <span class="n">dif</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Socket demux engine toys. */</span>
<span class="cm">/* What happens here is ugly; there&#39;s a pair of adjacent fields in</span>
<span class="cm">   struct inet_sock; __be16 dport followed by __u16 num.  We want to</span>
<span class="cm">   search by pair, so we combine the keys into a single 32bit value</span>
<span class="cm">   and compare with 32bit value read from &amp;...-&gt;dport.  Let&#39;s at least</span>
<span class="cm">   make sure that it&#39;s not mixed with anything else...</span>
<span class="cm">   On 64bit targets we combine comparisons with pair of adjacent __be32</span>
<span class="cm">   fields in the same way.</span>
<span class="cm">*/</span>
<span class="k">typedef</span> <span class="n">__u32</span> <span class="n">__bitwise</span> <span class="n">__portpair</span><span class="p">;</span>
<span class="cp">#ifdef __BIG_ENDIAN</span>
<span class="cp">#define INET_COMBINED_PORTS(__sport, __dport) \</span>
<span class="cp">	((__force __portpair)(((__force __u32)(__be16)(__sport) &lt;&lt; 16) | (__u32)(__dport)))</span>
<span class="cp">#else </span><span class="cm">/* __LITTLE_ENDIAN */</span><span class="cp"></span>
<span class="cp">#define INET_COMBINED_PORTS(__sport, __dport) \</span>
<span class="cp">	((__force __portpair)(((__u32)(__dport) &lt;&lt; 16) | (__force __u32)(__be16)(__sport)))</span>
<span class="cp">#endif</span>

<span class="cp">#if (BITS_PER_LONG == 64)</span>
<span class="k">typedef</span> <span class="n">__u64</span> <span class="n">__bitwise</span> <span class="n">__addrpair</span><span class="p">;</span>
<span class="cp">#ifdef __BIG_ENDIAN</span>
<span class="cp">#define INET_ADDR_COOKIE(__name, __saddr, __daddr) \</span>
<span class="cp">	const __addrpair __name = (__force __addrpair) ( \</span>
<span class="cp">				   (((__force __u64)(__be32)(__saddr)) &lt;&lt; 32) | \</span>
<span class="cp">				   ((__force __u64)(__be32)(__daddr)));</span>
<span class="cp">#else </span><span class="cm">/* __LITTLE_ENDIAN */</span><span class="cp"></span>
<span class="cp">#define INET_ADDR_COOKIE(__name, __saddr, __daddr) \</span>
<span class="cp">	const __addrpair __name = (__force __addrpair) ( \</span>
<span class="cp">				   (((__force __u64)(__be32)(__daddr)) &lt;&lt; 32) | \</span>
<span class="cp">				   ((__force __u64)(__be32)(__saddr)));</span>
<span class="cp">#endif </span><span class="cm">/* __BIG_ENDIAN */</span><span class="cp"></span>
<span class="cp">#define INET_MATCH(__sk, __net, __hash, __cookie, __saddr, __daddr, __ports, __dif)\</span>
<span class="cp">	(((__sk)-&gt;sk_hash == (__hash)) &amp;&amp; net_eq(sock_net(__sk), (__net)) &amp;&amp;	\</span>
<span class="cp">	 ((*((__addrpair *)&amp;(inet_sk(__sk)-&gt;inet_daddr))) == (__cookie))  &amp;&amp;	\</span>
<span class="cp">	 ((*((__portpair *)&amp;(inet_sk(__sk)-&gt;inet_dport))) == (__ports))   &amp;&amp;	\</span>
<span class="cp">	 (!((__sk)-&gt;sk_bound_dev_if) || ((__sk)-&gt;sk_bound_dev_if == (__dif))))</span>
<span class="cp">#define INET_TW_MATCH(__sk, __net, __hash, __cookie, __saddr, __daddr, __ports, __dif)\</span>
<span class="cp">	(((__sk)-&gt;sk_hash == (__hash)) &amp;&amp; net_eq(sock_net(__sk), (__net)) &amp;&amp;	\</span>
<span class="cp">	 ((*((__addrpair *)&amp;(inet_twsk(__sk)-&gt;tw_daddr))) == (__cookie)) &amp;&amp;	\</span>
<span class="cp">	 ((*((__portpair *)&amp;(inet_twsk(__sk)-&gt;tw_dport))) == (__ports)) &amp;&amp;	\</span>
<span class="cp">	 (!((__sk)-&gt;sk_bound_dev_if) || ((__sk)-&gt;sk_bound_dev_if == (__dif))))</span>
<span class="cp">#else </span><span class="cm">/* 32-bit arch */</span><span class="cp"></span>
<span class="cp">#define INET_ADDR_COOKIE(__name, __saddr, __daddr)</span>
<span class="cp">#define INET_MATCH(__sk, __net, __hash, __cookie, __saddr, __daddr, __ports, __dif)	\</span>
<span class="cp">	(((__sk)-&gt;sk_hash == (__hash)) &amp;&amp; net_eq(sock_net(__sk), (__net))	&amp;&amp;	\</span>
<span class="cp">	 (inet_sk(__sk)-&gt;inet_daddr	== (__saddr))		&amp;&amp;	\</span>
<span class="cp">	 (inet_sk(__sk)-&gt;inet_rcv_saddr	== (__daddr))		&amp;&amp;	\</span>
<span class="cp">	 ((*((__portpair *)&amp;(inet_sk(__sk)-&gt;inet_dport))) == (__ports))	&amp;&amp;	\</span>
<span class="cp">	 (!((__sk)-&gt;sk_bound_dev_if) || ((__sk)-&gt;sk_bound_dev_if == (__dif))))</span>
<span class="cp">#define INET_TW_MATCH(__sk, __net, __hash,__cookie, __saddr, __daddr, __ports, __dif)	\</span>
<span class="cp">	(((__sk)-&gt;sk_hash == (__hash)) &amp;&amp; net_eq(sock_net(__sk), (__net))	&amp;&amp;	\</span>
<span class="cp">	 (inet_twsk(__sk)-&gt;tw_daddr	== (__saddr))		&amp;&amp;	\</span>
<span class="cp">	 (inet_twsk(__sk)-&gt;tw_rcv_saddr	== (__daddr))		&amp;&amp;	\</span>
<span class="cp">	 ((*((__portpair *)&amp;(inet_twsk(__sk)-&gt;tw_dport))) == (__ports)) &amp;&amp;	\</span>
<span class="cp">	 (!((__sk)-&gt;sk_bound_dev_if) || ((__sk)-&gt;sk_bound_dev_if == (__dif))))</span>
<span class="cp">#endif </span><span class="cm">/* 64-bit arch */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Sockets in TCP_CLOSE state are _always_ taken out of the hash, so we need</span>
<span class="cm"> * not check it for lookups anymore, thanks Alexey. -DaveM</span>
<span class="cm"> *</span>
<span class="cm"> * Local BH must be disabled here.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span> <span class="n">__inet_lookup_established</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">inet_hashinfo</span> <span class="o">*</span><span class="n">hashinfo</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">__be32</span> <span class="n">saddr</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be16</span> <span class="n">sport</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">__be32</span> <span class="n">daddr</span><span class="p">,</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">hnum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">dif</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span>
	<span class="nf">inet_lookup_established</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inet_hashinfo</span> <span class="o">*</span><span class="n">hashinfo</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">__be32</span> <span class="n">saddr</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be16</span> <span class="n">sport</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">__be32</span> <span class="n">daddr</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be16</span> <span class="n">dport</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">int</span> <span class="n">dif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__inet_lookup_established</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">hashinfo</span><span class="p">,</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">sport</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span>
					 <span class="n">ntohs</span><span class="p">(</span><span class="n">dport</span><span class="p">),</span> <span class="n">dif</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">__inet_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">inet_hashinfo</span> <span class="o">*</span><span class="n">hashinfo</span><span class="p">,</span>
					 <span class="k">const</span> <span class="n">__be32</span> <span class="n">saddr</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be16</span> <span class="n">sport</span><span class="p">,</span>
					 <span class="k">const</span> <span class="n">__be32</span> <span class="n">daddr</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be16</span> <span class="n">dport</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">int</span> <span class="n">dif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">hnum</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">dport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">__inet_lookup_established</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">hashinfo</span><span class="p">,</span>
				<span class="n">saddr</span><span class="p">,</span> <span class="n">sport</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">hnum</span><span class="p">,</span> <span class="n">dif</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sk</span> <span class="o">?</span> <span class="o">:</span> <span class="n">__inet_lookup_listener</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">hashinfo</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">hnum</span><span class="p">,</span> <span class="n">dif</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">inet_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">inet_hashinfo</span> <span class="o">*</span><span class="n">hashinfo</span><span class="p">,</span>
				       <span class="k">const</span> <span class="n">__be32</span> <span class="n">saddr</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be16</span> <span class="n">sport</span><span class="p">,</span>
				       <span class="k">const</span> <span class="n">__be32</span> <span class="n">daddr</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be16</span> <span class="n">dport</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">int</span> <span class="n">dif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">sk</span> <span class="o">=</span> <span class="n">__inet_lookup</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">hashinfo</span><span class="p">,</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">sport</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">dport</span><span class="p">,</span> <span class="n">dif</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">sk</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">__inet_lookup_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">inet_hashinfo</span> <span class="o">*</span><span class="n">hashinfo</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					     <span class="k">const</span> <span class="n">__be16</span> <span class="n">sport</span><span class="p">,</span>
					     <span class="k">const</span> <span class="n">__be16</span> <span class="n">dport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sk</span> <span class="o">=</span> <span class="n">skb_steal_sock</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">sk</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">__inet_lookup</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">hashinfo</span><span class="p">,</span>
				     <span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">sport</span><span class="p">,</span>
				     <span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">dport</span><span class="p">,</span> <span class="n">inet_iif</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__inet_hash_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">inet_timewait_death_row</span> <span class="o">*</span><span class="n">death_row</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">port_offset</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_established</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inet_timewait_death_row</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="n">__u16</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inet_timewait_sock</span> <span class="o">**</span><span class="p">),</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hash</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inet_timewait_sock</span> <span class="o">*</span><span class="n">twp</span><span class="p">));</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">inet_hash_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">inet_timewait_death_row</span> <span class="o">*</span><span class="n">death_row</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* _INET_HASHTABLES_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
