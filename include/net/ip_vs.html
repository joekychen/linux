<!DOCTYPE html>
<html><head><title>joekychen/linux » include › net › ip_vs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ip_vs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *      IP Virtual Server</span>
<span class="cm"> *      data structure and functionality definitions</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _NET_IP_VS_H</span>
<span class="cp">#define _NET_IP_VS_H</span>

<span class="cp">#include &lt;linux/ip_vs.h&gt;                </span><span class="cm">/* definitions shared with userland */</span><span class="cp"></span>

<span class="cp">#include &lt;asm/types.h&gt;                  </span><span class="cm">/* for __uXX types */</span><span class="cp"></span>

<span class="cp">#include &lt;linux/list.h&gt;                 </span><span class="cm">/* for struct list_head */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/spinlock.h&gt;             </span><span class="cm">/* for struct rwlock_t */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/atomic.h&gt;                 </span><span class="cm">/* for struct atomic_t */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>

<span class="cp">#include &lt;net/checksum.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter.h&gt;		</span><span class="cm">/* for union nf_inet_addr */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/ipv6.h&gt;			</span><span class="cm">/* for struct ipv6hdr */</span><span class="cp"></span>
<span class="cp">#include &lt;net/ipv6.h&gt;</span>
<span class="cp">#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)</span>
<span class="cp">#include &lt;net/netfilter/nf_conntrack.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;net/net_namespace.h&gt;		</span><span class="cm">/* Netw namespace */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Generic access of ipvs struct</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="nf">net_ipvs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span><span class="o">*</span> <span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">ipvs</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Get net ptr from skb in traffic cases</span>
<span class="cm"> * use skb_sknet when call is from userland (ioctl or netlink)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">skb_net</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NET_NS</span>
<span class="cp">#ifdef CONFIG_IP_VS_DEBUG</span>
	<span class="cm">/*</span>
<span class="cm">	 * This is used for debug only.</span>
<span class="cm">	 * Start with the most likely hit</span>
<span class="cm">	 * End with BUG</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">nd_net</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">WARN</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;Maybe skb_sknet should be used in %s() at line:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_net</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;There is no net ptr to find in the skb in %s() line:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">?</span> <span class="o">:</span> <span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">skb_sknet</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NET_NS</span>
<span class="cp">#ifdef CONFIG_IP_VS_DEBUG</span>
	<span class="cm">/* Start with the most likely hit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_net</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">WARN</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Maybe skb_net should be used instead in %s() line:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">nd_net</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;There is no net ptr to find in the skb in %s() line:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * This one needed for single_open_net since net is stored directly in</span>
<span class="cm"> * private not as a struct i.e. seq_file_net can&#39;t be used.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">seq_file_single_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NET_NS</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="p">)</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Connections&#39; size value needed by ip_vs_ctl.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_conn_tab_size</span><span class="p">;</span>


<span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">protocol</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="n">saddr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="n">daddr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ip_vs_fill_iphdr</span><span class="p">(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">nh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="o">*</span><span class="n">iphdr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ipv6hdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">nh</span><span class="p">;</span>
		<span class="n">iphdr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">);</span>
		<span class="n">iphdr</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">nexthdr</span><span class="p">;</span>
		<span class="n">iphdr</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">.</span><span class="n">in6</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">;</span>
		<span class="n">iphdr</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">in6</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">nh</span><span class="p">;</span>
		<span class="n">iphdr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">iphdr</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
		<span class="n">iphdr</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">;</span>
		<span class="n">iphdr</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ip_vs_addr_copy</span><span class="p">(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span>
		<span class="n">dst</span><span class="o">-&gt;</span><span class="n">in6</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">in6</span><span class="p">;</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ip_vs_addr_equal</span><span class="p">(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ipv6_addr_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">in6</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in6</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IP_VS_DEBUG</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_get_debug_level</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ip_vs_dbg_addr</span><span class="p">(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_len</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="o">*</span><span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">af</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span><span class="p">],</span> <span class="n">buf_len</span> <span class="o">-</span> <span class="o">*</span><span class="n">idx</span><span class="p">,</span> <span class="s">&quot;[%pI6]&quot;</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">in6</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span><span class="p">],</span> <span class="n">buf_len</span> <span class="o">-</span> <span class="o">*</span><span class="n">idx</span><span class="p">,</span> <span class="s">&quot;%pI4&quot;</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="o">*</span><span class="n">idx</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">*</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="n">buf_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span> <span class="o">-</span> <span class="n">len</span><span class="p">];</span>
<span class="p">}</span>

<span class="cp">#define IP_VS_DBG_BUF(level, msg, ...)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		char ip_vs_dbg_buf[160];				\</span>
<span class="cp">		int ip_vs_dbg_idx = 0;					\</span>
<span class="cp">		if (level &lt;= ip_vs_get_debug_level())			\</span>
<span class="cp">			printk(KERN_DEBUG pr_fmt(msg), ##__VA_ARGS__);	\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define IP_VS_ERR_BUF(msg...)						\</span>
<span class="cp">	do {								\</span>
<span class="cp">		char ip_vs_dbg_buf[160];				\</span>
<span class="cp">		int ip_vs_dbg_idx = 0;					\</span>
<span class="cp">		pr_err(msg);						\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/* Only use from within IP_VS_DBG_BUF() or IP_VS_ERR_BUF macros */</span>
<span class="cp">#define IP_VS_DBG_ADDR(af, addr)					\</span>
<span class="cp">	ip_vs_dbg_addr(af, ip_vs_dbg_buf,				\</span>
<span class="cp">		       sizeof(ip_vs_dbg_buf), addr,			\</span>
<span class="cp">		       &amp;ip_vs_dbg_idx)</span>

<span class="cp">#define IP_VS_DBG(level, msg, ...)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if (level &lt;= ip_vs_get_debug_level())			\</span>
<span class="cp">			printk(KERN_DEBUG pr_fmt(msg), ##__VA_ARGS__);	\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define IP_VS_DBG_RL(msg, ...)						\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if (net_ratelimit())					\</span>
<span class="cp">			printk(KERN_DEBUG pr_fmt(msg), ##__VA_ARGS__);	\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define IP_VS_DBG_PKT(level, af, pp, skb, ofs, msg)			\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if (level &lt;= ip_vs_get_debug_level())			\</span>
<span class="cp">			pp-&gt;debug_packet(af, pp, skb, ofs, msg);	\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define IP_VS_DBG_RL_PKT(level, af, pp, skb, ofs, msg)			\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if (level &lt;= ip_vs_get_debug_level() &amp;&amp;			\</span>
<span class="cp">		    net_ratelimit())					\</span>
<span class="cp">			pp-&gt;debug_packet(af, pp, skb, ofs, msg);	\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else	</span><span class="cm">/* NO DEBUGGING at ALL */</span><span class="cp"></span>
<span class="cp">#define IP_VS_DBG_BUF(level, msg...)  do {} while (0)</span>
<span class="cp">#define IP_VS_ERR_BUF(msg...)  do {} while (0)</span>
<span class="cp">#define IP_VS_DBG(level, msg...)  do {} while (0)</span>
<span class="cp">#define IP_VS_DBG_RL(msg...)  do {} while (0)</span>
<span class="cp">#define IP_VS_DBG_PKT(level, af, pp, skb, ofs, msg)	do {} while (0)</span>
<span class="cp">#define IP_VS_DBG_RL_PKT(level, af, pp, skb, ofs, msg)	do {} while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#define IP_VS_BUG() BUG()</span>
<span class="cp">#define IP_VS_ERR_RL(msg, ...)						\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if (net_ratelimit())					\</span>
<span class="cp">			pr_err(msg, ##__VA_ARGS__);			\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#ifdef CONFIG_IP_VS_DEBUG</span>
<span class="cp">#define EnterFunction(level)						\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if (level &lt;= ip_vs_get_debug_level())			\</span>
<span class="cp">			printk(KERN_DEBUG				\</span>
<span class="cp">			       pr_fmt(&quot;Enter: %s, %s line %i\n&quot;),	\</span>
<span class="cp">			       __func__, __FILE__, __LINE__);		\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define LeaveFunction(level)						\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if (level &lt;= ip_vs_get_debug_level())			\</span>
<span class="cp">			printk(KERN_DEBUG				\</span>
<span class="cp">			       pr_fmt(&quot;Leave: %s, %s line %i\n&quot;),	\</span>
<span class="cp">			       __func__, __FILE__, __LINE__);		\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define EnterFunction(level)   do {} while (0)</span>
<span class="cp">#define LeaveFunction(level)   do {} while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#define	IP_VS_WAIT_WHILE(expr)	while (expr) { cpu_relax(); }</span>


<span class="cm">/*</span>
<span class="cm"> *      The port number of FTP service (in network order).</span>
<span class="cm"> */</span>
<span class="cp">#define FTPPORT  cpu_to_be16(21)</span>
<span class="cp">#define FTPDATA  cpu_to_be16(20)</span>

<span class="cm">/*</span>
<span class="cm"> *      TCP State Values</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IP_VS_TCP_S_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IP_VS_TCP_S_ESTABLISHED</span><span class="p">,</span>
	<span class="n">IP_VS_TCP_S_SYN_SENT</span><span class="p">,</span>
	<span class="n">IP_VS_TCP_S_SYN_RECV</span><span class="p">,</span>
	<span class="n">IP_VS_TCP_S_FIN_WAIT</span><span class="p">,</span>
	<span class="n">IP_VS_TCP_S_TIME_WAIT</span><span class="p">,</span>
	<span class="n">IP_VS_TCP_S_CLOSE</span><span class="p">,</span>
	<span class="n">IP_VS_TCP_S_CLOSE_WAIT</span><span class="p">,</span>
	<span class="n">IP_VS_TCP_S_LAST_ACK</span><span class="p">,</span>
	<span class="n">IP_VS_TCP_S_LISTEN</span><span class="p">,</span>
	<span class="n">IP_VS_TCP_S_SYNACK</span><span class="p">,</span>
	<span class="n">IP_VS_TCP_S_LAST</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	UDP State Values</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IP_VS_UDP_S_NORMAL</span><span class="p">,</span>
	<span class="n">IP_VS_UDP_S_LAST</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	ICMP State Values</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IP_VS_ICMP_S_NORMAL</span><span class="p">,</span>
	<span class="n">IP_VS_ICMP_S_LAST</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	SCTP State Values</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ip_vs_sctp_states</span> <span class="p">{</span>
	<span class="n">IP_VS_SCTP_S_NONE</span><span class="p">,</span>
	<span class="n">IP_VS_SCTP_S_INIT_CLI</span><span class="p">,</span>
	<span class="n">IP_VS_SCTP_S_INIT_SER</span><span class="p">,</span>
	<span class="n">IP_VS_SCTP_S_INIT_ACK_CLI</span><span class="p">,</span>
	<span class="n">IP_VS_SCTP_S_INIT_ACK_SER</span><span class="p">,</span>
	<span class="n">IP_VS_SCTP_S_ECHO_CLI</span><span class="p">,</span>
	<span class="n">IP_VS_SCTP_S_ECHO_SER</span><span class="p">,</span>
	<span class="n">IP_VS_SCTP_S_ESTABLISHED</span><span class="p">,</span>
	<span class="n">IP_VS_SCTP_S_SHUT_CLI</span><span class="p">,</span>
	<span class="n">IP_VS_SCTP_S_SHUT_SER</span><span class="p">,</span>
	<span class="n">IP_VS_SCTP_S_SHUT_ACK_CLI</span><span class="p">,</span>
	<span class="n">IP_VS_SCTP_S_SHUT_ACK_SER</span><span class="p">,</span>
	<span class="n">IP_VS_SCTP_S_CLOSED</span><span class="p">,</span>
	<span class="n">IP_VS_SCTP_S_LAST</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Delta sequence info structure</span>
<span class="cm"> *	Each ip_vs_conn has 2 (output AND input seq. changes).</span>
<span class="cm"> *      Only used in the VS/NAT.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ip_vs_seq</span> <span class="p">{</span>
	<span class="n">__u32</span>			<span class="n">init_seq</span><span class="p">;</span>	<span class="cm">/* Add delta from this seq */</span>
	<span class="n">__u32</span>			<span class="n">delta</span><span class="p">;</span>		<span class="cm">/* Delta in sequence numbers */</span>
	<span class="n">__u32</span>			<span class="n">previous_delta</span><span class="p">;</span>	<span class="cm">/* Delta in sequence numbers</span>
<span class="cm">						   before last resized pkt */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * counters per cpu</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ip_vs_counters</span> <span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">conns</span><span class="p">;</span>		<span class="cm">/* connections scheduled */</span>
	<span class="n">__u32</span>		<span class="n">inpkts</span><span class="p">;</span>		<span class="cm">/* incoming packets */</span>
	<span class="n">__u32</span>		<span class="n">outpkts</span><span class="p">;</span>	<span class="cm">/* outgoing packets */</span>
	<span class="n">__u64</span>		<span class="n">inbytes</span><span class="p">;</span>	<span class="cm">/* incoming bytes */</span>
	<span class="n">__u64</span>		<span class="n">outbytes</span><span class="p">;</span>	<span class="cm">/* outgoing bytes */</span>
<span class="p">};</span>
<span class="cm">/*</span>
<span class="cm"> * Stats per cpu</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ip_vs_cpu_stats</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_vs_counters</span>   <span class="n">ustats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">u64_stats_sync</span>   <span class="n">syncp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	IPVS statistics objects</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ip_vs_estimator</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>

	<span class="n">u64</span>			<span class="n">last_inbytes</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">last_outbytes</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">last_conns</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">last_inpkts</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">last_outpkts</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">cps</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">inpps</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">outpps</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">inbps</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">outbps</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ip_vs_stats</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_vs_stats_user</span>	<span class="n">ustats</span><span class="p">;</span>		<span class="cm">/* statistics */</span>
	<span class="k">struct</span> <span class="n">ip_vs_estimator</span>	<span class="n">est</span><span class="p">;</span>		<span class="cm">/* estimator */</span>
	<span class="k">struct</span> <span class="n">ip_vs_cpu_stats</span>	<span class="o">*</span><span class="n">cpustats</span><span class="p">;</span>	<span class="cm">/* per cpu counters */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* spin lock */</span>
	<span class="k">struct</span> <span class="n">ip_vs_stats_user</span>	<span class="n">ustats0</span><span class="p">;</span>	<span class="cm">/* reset values */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dst_entry</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">iphdr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ip_vs_conn</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ip_vs_app</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sk_buff</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ip_vs_proto_data</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_vs_protocol</span>	<span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">protocol</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">num_states</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">dont_defrag</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exit</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init_netns</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exit_netns</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">conn_schedule</span><span class="p">)(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="o">*</span><span class="n">verdict</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">**</span><span class="n">cpp</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span>
	<span class="p">(</span><span class="o">*</span><span class="n">conn_in_get</span><span class="p">)(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">proto_off</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">inverse</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span>
	<span class="p">(</span><span class="o">*</span><span class="n">conn_out_get</span><span class="p">)(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">proto_off</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">inverse</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">snat_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dnat_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">csum_check</span><span class="p">)(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>

	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">state_name</span><span class="p">)(</span><span class="kt">int</span> <span class="n">state</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">state_transition</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">register_app</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="n">inc</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">unregister_app</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="n">inc</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">app_conn_bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">debug_packet</span><span class="p">)(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">timeout_change</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * protocol data per netns</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_vs_proto_data</span>	<span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_protocol</span>	<span class="o">*</span><span class="n">pp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">timeout_table</span><span class="p">;</span>	<span class="cm">/* protocol timeout table */</span>
	<span class="n">atomic_t</span>		<span class="n">appcnt</span><span class="p">;</span>		<span class="cm">/* counter of proto app incs. */</span>
	<span class="k">struct</span> <span class="n">tcp_states_t</span>	<span class="o">*</span><span class="n">tcp_state_table</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span>   <span class="o">*</span><span class="n">ip_vs_proto_get</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">proto</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">ip_vs_proto_data_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
						     <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">proto</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ip_vs_conn_param</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span>			<span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span>	<span class="o">*</span><span class="n">caddr</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span>	<span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="n">__be16</span>				<span class="n">cport</span><span class="p">;</span>
	<span class="n">__be16</span>				<span class="n">vport</span><span class="p">;</span>
	<span class="n">__u16</span>				<span class="n">protocol</span><span class="p">;</span>
	<span class="n">u16</span>				<span class="n">af</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_pe</span>		<span class="o">*</span><span class="n">pe</span><span class="p">;</span>
	<span class="kt">char</span>				<span class="o">*</span><span class="n">pe_data</span><span class="p">;</span>
	<span class="n">__u8</span>				<span class="n">pe_data_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	IP_VS structure allocated for each dynamically scheduled connection</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">c_list</span><span class="p">;</span>         <span class="cm">/* hashed list heads */</span>
<span class="cp">#ifdef CONFIG_NET_NS</span>
	<span class="k">struct</span> <span class="n">net</span>              <span class="o">*</span><span class="n">net</span><span class="p">;</span>           <span class="cm">/* Name space */</span>
<span class="cp">#endif</span>
	<span class="cm">/* Protocol, addresses and port numbers */</span>
	<span class="n">u16</span>                     <span class="n">af</span><span class="p">;</span>             <span class="cm">/* address family */</span>
	<span class="n">__be16</span>                  <span class="n">cport</span><span class="p">;</span>
	<span class="n">__be16</span>                  <span class="n">vport</span><span class="p">;</span>
	<span class="n">__be16</span>                  <span class="n">dport</span><span class="p">;</span>
	<span class="n">__u32</span>                   <span class="n">fwmark</span><span class="p">;</span>         <span class="cm">/* Fire wall mark from skb */</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span>      <span class="n">caddr</span><span class="p">;</span>          <span class="cm">/* client address */</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span>      <span class="n">vaddr</span><span class="p">;</span>          <span class="cm">/* virtual address */</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span>      <span class="n">daddr</span><span class="p">;</span>          <span class="cm">/* destination address */</span>
	<span class="k">volatile</span> <span class="n">__u32</span>          <span class="n">flags</span><span class="p">;</span>          <span class="cm">/* status flags */</span>
	<span class="n">__u16</span>                   <span class="n">protocol</span><span class="p">;</span>       <span class="cm">/* Which protocol (TCP/UDP) */</span>

	<span class="cm">/* counter and timer */</span>
	<span class="n">atomic_t</span>		<span class="n">refcnt</span><span class="p">;</span>		<span class="cm">/* reference count */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">timer</span><span class="p">;</span>		<span class="cm">/* Expiration timer */</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">timeout</span><span class="p">;</span>	<span class="cm">/* timeout */</span>

	<span class="cm">/* Flags and state transition */</span>
	<span class="n">spinlock_t</span>              <span class="n">lock</span><span class="p">;</span>           <span class="cm">/* lock for state transition */</span>
	<span class="k">volatile</span> <span class="n">__u16</span>          <span class="n">state</span><span class="p">;</span>          <span class="cm">/* state info */</span>
	<span class="k">volatile</span> <span class="n">__u16</span>          <span class="n">old_state</span><span class="p">;</span>      <span class="cm">/* old state, to be used for</span>
<span class="cm">						 * state transition triggerd</span>
<span class="cm">						 * synchronization</span>
<span class="cm">						 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">sync_endtime</span><span class="p">;</span>	<span class="cm">/* jiffies + sent_retries */</span>

	<span class="cm">/* Control members */</span>
	<span class="k">struct</span> <span class="n">ip_vs_conn</span>       <span class="o">*</span><span class="n">control</span><span class="p">;</span>       <span class="cm">/* Master control connection */</span>
	<span class="n">atomic_t</span>                <span class="n">n_control</span><span class="p">;</span>      <span class="cm">/* Number of controlled ones */</span>
	<span class="k">struct</span> <span class="n">ip_vs_dest</span>       <span class="o">*</span><span class="n">dest</span><span class="p">;</span>          <span class="cm">/* real server */</span>
	<span class="n">atomic_t</span>                <span class="n">in_pkts</span><span class="p">;</span>        <span class="cm">/* incoming packet counter */</span>

	<span class="cm">/* packet transmitter for different forwarding methods.  If it</span>
<span class="cm">	   mangles the packet, it must return NF_DROP or better NF_STOLEN,</span>
<span class="cm">	   otherwise this must be changed to a sk_buff **.</span>
<span class="cm">	   NF_ACCEPT can be returned when destination is local.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">packet_xmit</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>

	<span class="cm">/* Note: we can group the following members into a structure,</span>
<span class="cm">	   in order to save more space, and the following members are</span>
<span class="cm">	   only used in VS/NAT anyway */</span>
	<span class="k">struct</span> <span class="n">ip_vs_app</span>        <span class="o">*</span><span class="n">app</span><span class="p">;</span>           <span class="cm">/* bound ip_vs_app object */</span>
	<span class="kt">void</span>                    <span class="o">*</span><span class="n">app_data</span><span class="p">;</span>      <span class="cm">/* Application private data */</span>
	<span class="k">struct</span> <span class="n">ip_vs_seq</span>        <span class="n">in_seq</span><span class="p">;</span>         <span class="cm">/* incoming seq. struct */</span>
	<span class="k">struct</span> <span class="n">ip_vs_seq</span>        <span class="n">out_seq</span><span class="p">;</span>        <span class="cm">/* outgoing seq. struct */</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_pe</span>	<span class="o">*</span><span class="n">pe</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">pe_data</span><span class="p">;</span>
	<span class="n">__u8</span>			<span class="n">pe_data_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  To save some memory in conn table when name space is disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">ip_vs_conn_net</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NET_NS</span>
	<span class="k">return</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ip_vs_conn_net_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NET_NS</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net</span> <span class="o">=</span> <span class="n">net</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ip_vs_conn_net_eq</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NET_NS</span>
	<span class="k">return</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">net</span> <span class="o">==</span> <span class="n">net</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Extended internal versions of struct ip_vs_service_user and</span>
<span class="cm"> *	ip_vs_dest_user for IPv6 support.</span>
<span class="cm"> *</span>
<span class="cm"> *	We need these to conveniently pass around service and destination</span>
<span class="cm"> *	options, but unfortunately, we also need to keep the old definitions to</span>
<span class="cm"> *	maintain userspace backwards compatibility for the setsockopt interface.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ip_vs_service_user_kern</span> <span class="p">{</span>
	<span class="cm">/* virtual service addresses */</span>
	<span class="n">u16</span>			<span class="n">af</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">protocol</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span>	<span class="n">addr</span><span class="p">;</span>		<span class="cm">/* virtual ip address */</span>
	<span class="n">u16</span>			<span class="n">port</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">fwmark</span><span class="p">;</span>		<span class="cm">/* firwall mark of service */</span>

	<span class="cm">/* virtual service options */</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">sched_name</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">pe_name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* virtual service flags */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">timeout</span><span class="p">;</span>	<span class="cm">/* persistent timeout in sec */</span>
	<span class="n">u32</span>			<span class="n">netmask</span><span class="p">;</span>	<span class="cm">/* persistent netmask */</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">ip_vs_dest_user_kern</span> <span class="p">{</span>
	<span class="cm">/* destination server address */</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span>	<span class="n">addr</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">port</span><span class="p">;</span>

	<span class="cm">/* real server options */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">conn_flags</span><span class="p">;</span>	<span class="cm">/* connection flags */</span>
	<span class="kt">int</span>			<span class="n">weight</span><span class="p">;</span>		<span class="cm">/* destination weight */</span>

	<span class="cm">/* thresholds for active connections */</span>
	<span class="n">u32</span>			<span class="n">u_threshold</span><span class="p">;</span>	<span class="cm">/* upper threshold */</span>
	<span class="n">u32</span>			<span class="n">l_threshold</span><span class="p">;</span>	<span class="cm">/* lower threshold */</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> *	The information about the virtual service offered to the net</span>
<span class="cm"> *	and the forwarding entries</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">s_list</span><span class="p">;</span>   <span class="cm">/* for normal service table */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">f_list</span><span class="p">;</span>   <span class="cm">/* for fwmark-based service table */</span>
	<span class="n">atomic_t</span>		<span class="n">refcnt</span><span class="p">;</span>   <span class="cm">/* reference counter */</span>
	<span class="n">atomic_t</span>		<span class="n">usecnt</span><span class="p">;</span>   <span class="cm">/* use counter */</span>

	<span class="n">u16</span>			<span class="n">af</span><span class="p">;</span>       <span class="cm">/* address family */</span>
	<span class="n">__u16</span>			<span class="n">protocol</span><span class="p">;</span> <span class="cm">/* which protocol (TCP/UDP) */</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span>	<span class="n">addr</span><span class="p">;</span>	  <span class="cm">/* IP address for virtual service */</span>
	<span class="n">__be16</span>			<span class="n">port</span><span class="p">;</span>	  <span class="cm">/* port number for the service */</span>
	<span class="n">__u32</span>                   <span class="n">fwmark</span><span class="p">;</span>   <span class="cm">/* firewall mark of the service */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>	  <span class="cm">/* service status flags */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">timeout</span><span class="p">;</span>  <span class="cm">/* persistent timeout in ticks */</span>
	<span class="n">__be32</span>			<span class="n">netmask</span><span class="p">;</span>  <span class="cm">/* grouping granularity */</span>
	<span class="k">struct</span> <span class="n">net</span>		<span class="o">*</span><span class="n">net</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">destinations</span><span class="p">;</span>  <span class="cm">/* real server d-linked list */</span>
	<span class="n">__u32</span>			<span class="n">num_dests</span><span class="p">;</span>     <span class="cm">/* number of servers */</span>
	<span class="k">struct</span> <span class="n">ip_vs_stats</span>      <span class="n">stats</span><span class="p">;</span>         <span class="cm">/* statistics for the service */</span>
	<span class="k">struct</span> <span class="n">ip_vs_app</span>	<span class="o">*</span><span class="n">inc</span><span class="p">;</span>	  <span class="cm">/* bind conns to this app inc */</span>

	<span class="cm">/* for scheduling */</span>
	<span class="k">struct</span> <span class="n">ip_vs_scheduler</span>	<span class="o">*</span><span class="n">scheduler</span><span class="p">;</span>    <span class="cm">/* bound scheduler object */</span>
	<span class="n">rwlock_t</span>		<span class="n">sched_lock</span><span class="p">;</span>    <span class="cm">/* lock sched_data */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">sched_data</span><span class="p">;</span>   <span class="cm">/* scheduler application data */</span>

	<span class="cm">/* alternate persistence engine */</span>
	<span class="k">struct</span> <span class="n">ip_vs_pe</span>		<span class="o">*</span><span class="n">pe</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> *	The real server destination forwarding entry</span>
<span class="cm"> *	with ip address, port number, and so on.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">n_list</span><span class="p">;</span>   <span class="cm">/* for the dests in the service */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">d_list</span><span class="p">;</span>   <span class="cm">/* for table with all the dests */</span>

	<span class="n">u16</span>			<span class="n">af</span><span class="p">;</span>		<span class="cm">/* address family */</span>
	<span class="n">__be16</span>			<span class="n">port</span><span class="p">;</span>		<span class="cm">/* port number of the server */</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span>	<span class="n">addr</span><span class="p">;</span>		<span class="cm">/* IP address of the server */</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* dest status flags */</span>
	<span class="n">atomic_t</span>		<span class="n">conn_flags</span><span class="p">;</span>	<span class="cm">/* flags to copy to conn */</span>
	<span class="n">atomic_t</span>		<span class="n">weight</span><span class="p">;</span>		<span class="cm">/* server weight */</span>

	<span class="n">atomic_t</span>		<span class="n">refcnt</span><span class="p">;</span>		<span class="cm">/* reference counter */</span>
	<span class="k">struct</span> <span class="n">ip_vs_stats</span>      <span class="n">stats</span><span class="p">;</span>          <span class="cm">/* statistics */</span>

	<span class="cm">/* connection counters and thresholds */</span>
	<span class="n">atomic_t</span>		<span class="n">activeconns</span><span class="p">;</span>	<span class="cm">/* active connections */</span>
	<span class="n">atomic_t</span>		<span class="n">inactconns</span><span class="p">;</span>	<span class="cm">/* inactive connections */</span>
	<span class="n">atomic_t</span>		<span class="n">persistconns</span><span class="p">;</span>	<span class="cm">/* persistent connections */</span>
	<span class="n">__u32</span>			<span class="n">u_threshold</span><span class="p">;</span>	<span class="cm">/* upper threshold */</span>
	<span class="n">__u32</span>			<span class="n">l_threshold</span><span class="p">;</span>	<span class="cm">/* lower threshold */</span>

	<span class="cm">/* for destination cache */</span>
	<span class="n">spinlock_t</span>		<span class="n">dst_lock</span><span class="p">;</span>	<span class="cm">/* lock of dst_cache */</span>
	<span class="k">struct</span> <span class="n">dst_entry</span>	<span class="o">*</span><span class="n">dst_cache</span><span class="p">;</span>	<span class="cm">/* destination cache entry */</span>
	<span class="n">u32</span>			<span class="n">dst_rtos</span><span class="p">;</span>	<span class="cm">/* RT_TOS(tos) for dst */</span>
	<span class="n">u32</span>			<span class="n">dst_cookie</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span>	<span class="n">dst_saddr</span><span class="p">;</span>

	<span class="cm">/* for virtual service */</span>
	<span class="k">struct</span> <span class="n">ip_vs_service</span>	<span class="o">*</span><span class="n">svc</span><span class="p">;</span>		<span class="cm">/* service it belongs to */</span>
	<span class="n">__u16</span>			<span class="n">protocol</span><span class="p">;</span>	<span class="cm">/* which protocol (TCP/UDP) */</span>
	<span class="n">__be16</span>			<span class="n">vport</span><span class="p">;</span>		<span class="cm">/* virtual port number */</span>
	<span class="k">union</span> <span class="n">nf_inet_addr</span>	<span class="n">vaddr</span><span class="p">;</span>		<span class="cm">/* virtual IP address */</span>
	<span class="n">__u32</span>			<span class="n">vfwmark</span><span class="p">;</span>	<span class="cm">/* firewall mark of service */</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> *	The scheduler object</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ip_vs_scheduler</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">n_list</span><span class="p">;</span>		<span class="cm">/* d-linked list head */</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>		<span class="cm">/* scheduler name */</span>
	<span class="n">atomic_t</span>		<span class="n">refcnt</span><span class="p">;</span>		<span class="cm">/* reference counter */</span>
	<span class="k">struct</span> <span class="n">module</span>		<span class="o">*</span><span class="n">module</span><span class="p">;</span>	<span class="cm">/* THIS_MODULE/NULL */</span>

	<span class="cm">/* scheduler initializing service */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init_service</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">);</span>
	<span class="cm">/* scheduling service finish */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">done_service</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">);</span>
	<span class="cm">/* scheduler updating service */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">update_service</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">);</span>

	<span class="cm">/* selecting a server from the given service */</span>
	<span class="k">struct</span> <span class="n">ip_vs_dest</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">schedule</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* The persistence engine object */</span>
<span class="k">struct</span> <span class="n">ip_vs_pe</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">n_list</span><span class="p">;</span>		<span class="cm">/* d-linked list head */</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>		<span class="cm">/* scheduler name */</span>
	<span class="n">atomic_t</span>		<span class="n">refcnt</span><span class="p">;</span>		<span class="cm">/* reference counter */</span>
	<span class="k">struct</span> <span class="n">module</span>		<span class="o">*</span><span class="n">module</span><span class="p">;</span>	<span class="cm">/* THIS_MODULE/NULL */</span>

	<span class="cm">/* get the connection template, if any */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fill_param</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_conn_param</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">ct_match</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_conn_param</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">);</span>
	<span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">hashkey_raw</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_conn_param</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u32</span> <span class="n">initval</span><span class="p">,</span>
			   <span class="n">bool</span> <span class="n">inverse</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">show_pe_data</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	The application module object (a.k.a. app incarnation)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">a_list</span><span class="p">;</span>		<span class="cm">/* member in app list */</span>
	<span class="kt">int</span>			<span class="n">type</span><span class="p">;</span>		<span class="cm">/* IP_VS_APP_TYPE_xxx */</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>		<span class="cm">/* application module name */</span>
	<span class="n">__u16</span>			<span class="n">protocol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span>		<span class="o">*</span><span class="n">module</span><span class="p">;</span>	<span class="cm">/* THIS_MODULE/NULL */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">incs_list</span><span class="p">;</span>	<span class="cm">/* list of incarnations */</span>

	<span class="cm">/* members for application incarnations */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">p_list</span><span class="p">;</span>		<span class="cm">/* member in proto app list */</span>
	<span class="k">struct</span> <span class="n">ip_vs_app</span>	<span class="o">*</span><span class="n">app</span><span class="p">;</span>		<span class="cm">/* its real application */</span>
	<span class="n">__be16</span>			<span class="n">port</span><span class="p">;</span>		<span class="cm">/* port number in net order */</span>
	<span class="n">atomic_t</span>		<span class="n">usecnt</span><span class="p">;</span>		<span class="cm">/* usage counter */</span>

	<span class="cm">/*</span>
<span class="cm">	 * output hook: Process packet in inout direction, diff set for TCP.</span>
<span class="cm">	 * Return: 0=Error, 1=Payload Not Mangled/Mangled but checksum is ok,</span>
<span class="cm">	 *	   2=Mangled but checksum was not updated</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pkt_out</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">diff</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * input hook: Process packet in outin direction, diff set for TCP.</span>
<span class="cm">	 * Return: 0=Error, 1=Payload Not Mangled/Mangled but checksum is ok,</span>
<span class="cm">	 *	   2=Mangled but checksum was not updated</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pkt_in</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">diff</span><span class="p">);</span>

	<span class="cm">/* ip_vs_app initializer */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init_conn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* ip_vs_app finish */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">done_conn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="p">);</span>


	<span class="cm">/* not used now */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bind_conn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">unbind_conn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">int</span> <span class="o">*</span>			<span class="n">timeout_table</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span>			<span class="n">timeouts</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">timeouts_size</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">conn_schedule</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="o">*</span><span class="n">verdict</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">**</span><span class="n">cpp</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span>
	<span class="p">(</span><span class="o">*</span><span class="n">conn_in_get</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">proto_off</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">inverse</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span>
	<span class="p">(</span><span class="o">*</span><span class="n">conn_out_get</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">proto_off</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">inverse</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">state_transition</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="n">app</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">timeout_change</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipvs_master_sync_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">sync_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_vs_sync_buff</span>	<span class="o">*</span><span class="n">sync_buff</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sync_queue_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sync_queue_delay</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">master_thread</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">master_wakeup_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netns_ipvs</span>	<span class="o">*</span><span class="n">ipvs</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* IPVS in network namespace */</span>
<span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">gen</span><span class="p">;</span>		<span class="cm">/* Generation */</span>
	<span class="kt">int</span>			<span class="n">enable</span><span class="p">;</span>		<span class="cm">/* enable like nf_hooks do */</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Hash table: for real service lookups</span>
<span class="cm">	 */</span>
	<span class="cp">#define IP_VS_RTAB_BITS 4</span>
	<span class="cp">#define IP_VS_RTAB_SIZE (1 &lt;&lt; IP_VS_RTAB_BITS)</span>
	<span class="cp">#define IP_VS_RTAB_MASK (IP_VS_RTAB_SIZE - 1)</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">rs_table</span><span class="p">[</span><span class="n">IP_VS_RTAB_SIZE</span><span class="p">];</span>
	<span class="cm">/* ip_vs_app */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">app_list</span><span class="p">;</span>
	<span class="cm">/* ip_vs_ftp */</span>
	<span class="k">struct</span> <span class="n">ip_vs_app</span>	<span class="o">*</span><span class="n">ftp_app</span><span class="p">;</span>
	<span class="cm">/* ip_vs_proto */</span>
	<span class="cp">#define IP_VS_PROTO_TAB_SIZE	32	</span><span class="cm">/* must be power of 2 */</span><span class="cp"></span>
	<span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">proto_data_table</span><span class="p">[</span><span class="n">IP_VS_PROTO_TAB_SIZE</span><span class="p">];</span>
	<span class="cm">/* ip_vs_proto_tcp */</span>
<span class="cp">#ifdef CONFIG_IP_VS_PROTO_TCP</span>
	<span class="cp">#define	TCP_APP_TAB_BITS	4</span>
	<span class="cp">#define	TCP_APP_TAB_SIZE	(1 &lt;&lt; TCP_APP_TAB_BITS)</span>
	<span class="cp">#define	TCP_APP_TAB_MASK	(TCP_APP_TAB_SIZE - 1)</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">tcp_apps</span><span class="p">[</span><span class="n">TCP_APP_TAB_SIZE</span><span class="p">];</span>
	<span class="n">spinlock_t</span>		<span class="n">tcp_app_lock</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* ip_vs_proto_udp */</span>
<span class="cp">#ifdef CONFIG_IP_VS_PROTO_UDP</span>
	<span class="cp">#define	UDP_APP_TAB_BITS	4</span>
	<span class="cp">#define	UDP_APP_TAB_SIZE	(1 &lt;&lt; UDP_APP_TAB_BITS)</span>
	<span class="cp">#define	UDP_APP_TAB_MASK	(UDP_APP_TAB_SIZE - 1)</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">udp_apps</span><span class="p">[</span><span class="n">UDP_APP_TAB_SIZE</span><span class="p">];</span>
	<span class="n">spinlock_t</span>		<span class="n">udp_app_lock</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* ip_vs_proto_sctp */</span>
<span class="cp">#ifdef CONFIG_IP_VS_PROTO_SCTP</span>
	<span class="cp">#define SCTP_APP_TAB_BITS	4</span>
	<span class="cp">#define SCTP_APP_TAB_SIZE	(1 &lt;&lt; SCTP_APP_TAB_BITS)</span>
	<span class="cp">#define SCTP_APP_TAB_MASK	(SCTP_APP_TAB_SIZE - 1)</span>
	<span class="cm">/* Hash table for SCTP application incarnations	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">sctp_apps</span><span class="p">[</span><span class="n">SCTP_APP_TAB_SIZE</span><span class="p">];</span>
	<span class="n">spinlock_t</span>		<span class="n">sctp_app_lock</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* ip_vs_conn */</span>
	<span class="n">atomic_t</span>		<span class="n">conn_count</span><span class="p">;</span>      <span class="cm">/*  connection counter */</span>

	<span class="cm">/* ip_vs_ctl */</span>
	<span class="k">struct</span> <span class="n">ip_vs_stats</span>		<span class="n">tot_stats</span><span class="p">;</span>  <span class="cm">/* Statistics &amp; est. */</span>

	<span class="kt">int</span>			<span class="n">num_services</span><span class="p">;</span>    <span class="cm">/* no of virtual services */</span>

	<span class="n">rwlock_t</span>		<span class="n">rs_lock</span><span class="p">;</span>         <span class="cm">/* real services table */</span>
	<span class="cm">/* Trash for destinations */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">dest_trash</span><span class="p">;</span>
	<span class="cm">/* Service counters */</span>
	<span class="n">atomic_t</span>		<span class="n">ftpsvc_counter</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">nullsvc_counter</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SYSCTL</span>
	<span class="cm">/* 1/rate drop and drop-entry variables */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">defense_work</span><span class="p">;</span>   <span class="cm">/* Work handler */</span>
	<span class="kt">int</span>			<span class="n">drop_rate</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">drop_counter</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">dropentry</span><span class="p">;</span>
	<span class="cm">/* locks in ctl.c */</span>
	<span class="n">spinlock_t</span>		<span class="n">dropentry_lock</span><span class="p">;</span>  <span class="cm">/* drop entry handling */</span>
	<span class="n">spinlock_t</span>		<span class="n">droppacket_lock</span><span class="p">;</span> <span class="cm">/* drop packet handling */</span>
	<span class="n">spinlock_t</span>		<span class="n">securetcp_lock</span><span class="p">;</span>  <span class="cm">/* state and timeout tables */</span>

	<span class="cm">/* sys-ctl struct */</span>
	<span class="k">struct</span> <span class="n">ctl_table_header</span>	<span class="o">*</span><span class="n">sysctl_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ctl_table</span>	<span class="o">*</span><span class="n">sysctl_tbl</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* sysctl variables */</span>
	<span class="kt">int</span>			<span class="n">sysctl_amemthresh</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sysctl_am_droprate</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sysctl_drop_entry</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sysctl_drop_packet</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sysctl_secure_tcp</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IP_VS_NFCT</span>
	<span class="kt">int</span>			<span class="n">sysctl_conntrack</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">int</span>			<span class="n">sysctl_snat_reroute</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sysctl_sync_ver</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sysctl_sync_ports</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sysctl_sync_qlen_max</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sysctl_sync_sock_size</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sysctl_cache_bypass</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sysctl_expire_nodest_conn</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sysctl_expire_quiescent_template</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sysctl_sync_threshold</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sysctl_sync_refresh_period</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sysctl_sync_retries</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sysctl_nat_icmp_send</span><span class="p">;</span>

	<span class="cm">/* ip_vs_lblc */</span>
	<span class="kt">int</span>			<span class="n">sysctl_lblc_expiration</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ctl_table_header</span>	<span class="o">*</span><span class="n">lblc_ctl_header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ctl_table</span>	<span class="o">*</span><span class="n">lblc_ctl_table</span><span class="p">;</span>
	<span class="cm">/* ip_vs_lblcr */</span>
	<span class="kt">int</span>			<span class="n">sysctl_lblcr_expiration</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ctl_table_header</span>	<span class="o">*</span><span class="n">lblcr_ctl_header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ctl_table</span>	<span class="o">*</span><span class="n">lblcr_ctl_table</span><span class="p">;</span>
	<span class="cm">/* ip_vs_est */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">est_list</span><span class="p">;</span>	<span class="cm">/* estimator list */</span>
	<span class="n">spinlock_t</span>		<span class="n">est_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">est_timer</span><span class="p">;</span>	<span class="cm">/* Estimation timer */</span>
	<span class="cm">/* ip_vs_sync */</span>
	<span class="n">spinlock_t</span>		<span class="n">sync_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipvs_master_sync_state</span> <span class="o">*</span><span class="n">ms</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">sync_buff_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">**</span><span class="n">backup_threads</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">threads_mask</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">send_mesg_maxlen</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">recv_mesg_maxlen</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">int</span>		<span class="n">sync_state</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">int</span>		<span class="n">master_syncid</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">int</span>		<span class="n">backup_syncid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">sync_mutex</span><span class="p">;</span>
	<span class="cm">/* multicast interface name */</span>
	<span class="kt">char</span>			<span class="n">master_mcast_ifn</span><span class="p">[</span><span class="n">IP_VS_IFNAME_MAXLEN</span><span class="p">];</span>
	<span class="kt">char</span>			<span class="n">backup_mcast_ifn</span><span class="p">[</span><span class="n">IP_VS_IFNAME_MAXLEN</span><span class="p">];</span>
	<span class="cm">/* net name space ptr */</span>
	<span class="k">struct</span> <span class="n">net</span>		<span class="o">*</span><span class="n">net</span><span class="p">;</span>            <span class="cm">/* Needed by timer routines */</span>
<span class="p">};</span>

<span class="cp">#define DEFAULT_SYNC_THRESHOLD	3</span>
<span class="cp">#define DEFAULT_SYNC_PERIOD	50</span>
<span class="cp">#define DEFAULT_SYNC_VER	1</span>
<span class="cp">#define DEFAULT_SYNC_REFRESH_PERIOD	(0U * HZ)</span>
<span class="cp">#define DEFAULT_SYNC_RETRIES		0</span>
<span class="cp">#define IPVS_SYNC_WAKEUP_RATE	8</span>
<span class="cp">#define IPVS_SYNC_QLEN_MAX	(IPVS_SYNC_WAKEUP_RATE * 4)</span>
<span class="cp">#define IPVS_SYNC_SEND_DELAY	(HZ / 50)</span>
<span class="cp">#define IPVS_SYNC_CHECK_PERIOD	HZ</span>
<span class="cp">#define IPVS_SYNC_FLUSH_TIME	(HZ * 2)</span>
<span class="cp">#define IPVS_SYNC_PORTS_MAX	(1 &lt;&lt; 6)</span>

<span class="cp">#ifdef CONFIG_SYSCTL</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sysctl_sync_threshold</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">sysctl_sync_threshold</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sysctl_sync_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">sysctl_sync_threshold</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sysctl_sync_refresh_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">sysctl_sync_refresh_period</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sysctl_sync_retries</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">sysctl_sync_retries</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sysctl_sync_ver</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">sysctl_sync_ver</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sysctl_sync_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">sysctl_sync_ports</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sysctl_sync_qlen_max</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">sysctl_sync_qlen_max</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sysctl_sync_sock_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">sysctl_sync_sock_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sysctl_sync_threshold</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">DEFAULT_SYNC_THRESHOLD</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sysctl_sync_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">DEFAULT_SYNC_PERIOD</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sysctl_sync_refresh_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">DEFAULT_SYNC_REFRESH_PERIOD</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sysctl_sync_retries</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">DEFAULT_SYNC_RETRIES</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sysctl_sync_ver</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">DEFAULT_SYNC_VER</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sysctl_sync_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sysctl_sync_qlen_max</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">IPVS_SYNC_QLEN_MAX</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sysctl_sync_sock_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *      IPVS core functions</span>
<span class="cm"> *      (from ip_vs_core.c)</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ip_vs_proto_name</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">proto</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_init_hash_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">);</span>
<span class="cp">#define IP_VS_INIT_HASH_TABLE(t) ip_vs_init_hash_table((t), ARRAY_SIZE((t)))</span>

<span class="cp">#define IP_VS_APP_TYPE_FTP	1</span>

<span class="cm">/*</span>
<span class="cm"> *     ip_vs_conn handling functions</span>
<span class="cm"> *     (from ip_vs_conn.c)</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IP_VS_DIR_INPUT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IP_VS_DIR_OUTPUT</span><span class="p">,</span>
	<span class="n">IP_VS_DIR_INPUT_ONLY</span><span class="p">,</span>
	<span class="n">IP_VS_DIR_LAST</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ip_vs_conn_fill_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">caddr</span><span class="p">,</span>
					 <span class="n">__be16</span> <span class="n">cport</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span>
					 <span class="n">__be16</span> <span class="n">vport</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">ip_vs_conn_param</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">net</span> <span class="o">=</span> <span class="n">net</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">af</span> <span class="o">=</span> <span class="n">af</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">protocol</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">caddr</span> <span class="o">=</span> <span class="n">caddr</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">cport</span> <span class="o">=</span> <span class="n">cport</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">vaddr</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">pe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">pe_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">ip_vs_conn_in_get</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_conn_param</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">ip_vs_ct_in_get</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_conn_param</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span> <span class="n">ip_vs_conn_in_get_proto</span><span class="p">(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					    <span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">proto_off</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">inverse</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">ip_vs_conn_out_get</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_conn_param</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span> <span class="n">ip_vs_conn_out_get_proto</span><span class="p">(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					     <span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_iphdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">proto_off</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">inverse</span><span class="p">);</span>

<span class="cm">/* put back the conn without restarting its timer */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__ip_vs_conn_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_conn_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_conn_fill_cport</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">cport</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">ip_vs_conn_new</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ip_vs_conn_param</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span>
				  <span class="n">__be16</span> <span class="n">dport</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">fwmark</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_conn_expire_now</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">ip_vs_state_name</span><span class="p">(</span><span class="n">__u16</span> <span class="n">proto</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_tcp_conn_listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_check_template</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_random_dropentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_conn_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_conn_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ip_vs_control_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">ctl_cp</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctl_cp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IP_VS_ERR_BUF</span><span class="p">(</span><span class="s">&quot;request control DEL for uncontrolled: &quot;</span>
			      <span class="s">&quot;%s:%d to %s:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">caddr</span><span class="p">),</span>
			      <span class="n">ntohs</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cport</span><span class="p">),</span>
			      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">),</span>
			      <span class="n">ntohs</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">));</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">IP_VS_DBG_BUF</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="s">&quot;DELeting control for: &quot;</span>
		      <span class="s">&quot;cp.dst=%s:%d ctl_cp.dst=%s:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">caddr</span><span class="p">),</span>
		      <span class="n">ntohs</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cport</span><span class="p">),</span>
		      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctl_cp</span><span class="o">-&gt;</span><span class="n">caddr</span><span class="p">),</span>
		      <span class="n">ntohs</span><span class="p">(</span><span class="n">ctl_cp</span><span class="o">-&gt;</span><span class="n">cport</span><span class="p">));</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctl_cp</span><span class="o">-&gt;</span><span class="n">n_control</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IP_VS_ERR_BUF</span><span class="p">(</span><span class="s">&quot;BUG control DEL with n=0 : &quot;</span>
			      <span class="s">&quot;%s:%d to %s:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">caddr</span><span class="p">),</span>
			      <span class="n">ntohs</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cport</span><span class="p">),</span>
			      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">),</span>
			      <span class="n">ntohs</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">));</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctl_cp</span><span class="o">-&gt;</span><span class="n">n_control</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ip_vs_control_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">ctl_cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IP_VS_ERR_BUF</span><span class="p">(</span><span class="s">&quot;request control ADD for already controlled: &quot;</span>
			      <span class="s">&quot;%s:%d to %s:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">caddr</span><span class="p">),</span>
			      <span class="n">ntohs</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cport</span><span class="p">),</span>
			      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">),</span>
			      <span class="n">ntohs</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">));</span>

		<span class="n">ip_vs_control_del</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">IP_VS_DBG_BUF</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="s">&quot;ADDing control for: &quot;</span>
		      <span class="s">&quot;cp.dst=%s:%d ctl_cp.dst=%s:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">caddr</span><span class="p">),</span>
		      <span class="n">ntohs</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cport</span><span class="p">),</span>
		      <span class="n">IP_VS_DBG_ADDR</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctl_cp</span><span class="o">-&gt;</span><span class="n">caddr</span><span class="p">),</span>
		      <span class="n">ntohs</span><span class="p">(</span><span class="n">ctl_cp</span><span class="o">-&gt;</span><span class="n">cport</span><span class="p">));</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">=</span> <span class="n">ctl_cp</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctl_cp</span><span class="o">-&gt;</span><span class="n">n_control</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * IPVS netns init &amp; cleanup functions</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_estimator_net_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_control_net_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_protocol_net_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_app_net_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_conn_net_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_sync_net_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_conn_net_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_app_net_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_protocol_net_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_control_net_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_estimator_net_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_sync_net_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_service_net_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *      IPVS application functions</span>
<span class="cm"> *      (from ip_vs_app.c)</span>
<span class="cm"> */</span>
<span class="cp">#define IP_VS_APP_MAX_PORTS  8</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">register_ip_vs_app</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="n">app</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">unregister_ip_vs_app</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="n">app</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_bind_app</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_unbind_app</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">register_ip_vs_app_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span>
				  <span class="n">__u16</span> <span class="n">proto</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_app_inc_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="n">inc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_app_inc_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_app</span> <span class="o">*</span><span class="n">inc</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_app_pkt_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_app_pkt_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ip_vs_bind_pe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_pe</span> <span class="o">*</span><span class="n">pe</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ip_vs_unbind_pe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">register_ip_vs_pe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_pe</span> <span class="o">*</span><span class="n">pe</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">unregister_ip_vs_pe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_pe</span> <span class="o">*</span><span class="n">pe</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ip_vs_pe</span> <span class="o">*</span><span class="n">ip_vs_pe_getbyname</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ip_vs_pe</span> <span class="o">*</span><span class="n">__ip_vs_pe_getbyname</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pe_name</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Use a #define to avoid all of module.h just for these trivial ops</span>
<span class="cm"> */</span>
<span class="cp">#define ip_vs_pe_get(pe)			\</span>
<span class="cp">	if (pe &amp;&amp; pe-&gt;module)			\</span>
<span class="cp">		__module_get(pe-&gt;module);</span>

<span class="cp">#define ip_vs_pe_put(pe)			\</span>
<span class="cp">	if (pe &amp;&amp; pe-&gt;module)			\</span>
<span class="cp">		module_put(pe-&gt;module);</span>

<span class="cm">/*</span>
<span class="cm"> *	IPVS protocol functions (from ip_vs_proto.c)</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_protocol_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_protocol_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_protocol_timeout_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ip_vs_create_timeout_table</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>
<span class="n">ip_vs_set_state_timeout</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="o">*</span><span class="n">names</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>
<span class="n">ip_vs_tcpudp_debug_packet</span><span class="p">(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="n">ip_vs_protocol_tcp</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="n">ip_vs_protocol_udp</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="n">ip_vs_protocol_icmp</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="n">ip_vs_protocol_esp</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="n">ip_vs_protocol_ah</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="n">ip_vs_protocol_sctp</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *      Registering/unregistering scheduler functions</span>
<span class="cm"> *      (from ip_vs_sched.c)</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">register_ip_vs_scheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_scheduler</span> <span class="o">*</span><span class="n">scheduler</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">unregister_ip_vs_scheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_scheduler</span> <span class="o">*</span><span class="n">scheduler</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_bind_scheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ip_vs_scheduler</span> <span class="o">*</span><span class="n">scheduler</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_unbind_scheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ip_vs_scheduler</span> <span class="o">*</span><span class="n">ip_vs_scheduler_get</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sched_name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_scheduler_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_scheduler</span> <span class="o">*</span><span class="n">scheduler</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span>
<span class="n">ip_vs_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ignored</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_leave</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ip_vs_proto_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_scheduler_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> *      IPVS control data and functions (from ip_vs_ctl.c)</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ip_vs_stats</span> <span class="n">ip_vs_stats</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_ip_vs_sync_ver</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span>
<span class="n">ip_vs_service_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">fwmark</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">protocol</span><span class="p">,</span>
		  <span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">vport</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ip_vs_service_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_service</span> <span class="o">*</span><span class="n">svc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">svc</span><span class="o">-&gt;</span><span class="n">usecnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="o">*</span>
<span class="n">ip_vs_lookup_real_service</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">protocol</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">dport</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_use_count_inc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_use_count_dec</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_register_nl_ioctl</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_unregister_nl_ioctl</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_control_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_control_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="o">*</span>
<span class="n">ip_vs_find_dest</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span>
		<span class="n">__be16</span> <span class="n">dport</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">vport</span><span class="p">,</span>
		<span class="n">__u16</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">fwmark</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="o">*</span><span class="n">ip_vs_try_bind_dest</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> *      IPVS sync daemon data and function prototypes</span>
<span class="cm"> *      (from ip_vs_sync.c)</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">start_sync_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mcast_ifn</span><span class="p">,</span>
			     <span class="n">__u8</span> <span class="n">syncid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">stop_sync_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_sync_conn</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pkts</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> *      IPVS rate estimator prototypes (from ip_vs_est.c)</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_start_estimator</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_stop_estimator</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_zero_estimator</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_read_estimator</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_stats_user</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ip_vs_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Various IPVS packet transmitters (from ip_vs_xmit.c)</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_null_xmit</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_bypass_xmit</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_nat_xmit</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_tunnel_xmit</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_dr_xmit</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_icmp_xmit</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span>
 <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_dst_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="o">*</span><span class="n">dest</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_bypass_xmit_v6</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_nat_xmit_v6</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_tunnel_xmit_v6</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_dr_xmit_v6</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_icmp_xmit_v6</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span>
 <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SYSCTL</span>
<span class="cm">/*</span>
<span class="cm"> *	This is a simple mechanism to ignore packets when</span>
<span class="cm"> *	we are loaded. Just set ip_vs_drop_rate to &#39;n&#39; and</span>
<span class="cm"> *	we start to drop 1/rate of the packets</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ip_vs_todrop</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">drop_rate</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">drop_counter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">drop_counter</span> <span class="o">=</span> <span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">drop_rate</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ip_vs_todrop</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *      ip_vs_fwd_tag returns the forwarding tag of the connection</span>
<span class="cm"> */</span>
<span class="cp">#define IP_VS_FWD_METHOD(cp)  (cp-&gt;flags &amp; IP_VS_CONN_F_FWD_MASK)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="nf">ip_vs_fwd_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">fwd</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">IP_VS_FWD_METHOD</span><span class="p">(</span><span class="n">cp</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IP_VS_CONN_F_MASQ</span>:
		<span class="n">fwd</span> <span class="o">=</span> <span class="sc">&#39;M&#39;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IP_VS_CONN_F_LOCALNODE</span>:
		<span class="n">fwd</span> <span class="o">=</span> <span class="sc">&#39;L&#39;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IP_VS_CONN_F_TUNNEL</span>:
		<span class="n">fwd</span> <span class="o">=</span> <span class="sc">&#39;T&#39;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IP_VS_CONN_F_DROUTE</span>:
		<span class="n">fwd</span> <span class="o">=</span> <span class="sc">&#39;R&#39;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IP_VS_CONN_F_BYPASS</span>:
		<span class="n">fwd</span> <span class="o">=</span> <span class="sc">&#39;B&#39;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">fwd</span> <span class="o">=</span> <span class="sc">&#39;?&#39;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">fwd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_nat_icmp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_nat_icmp_v6</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_protocol</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="n">__sum16</span> <span class="n">ip_vs_checksum_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__wsum</span> <span class="nf">ip_vs_check_diff4</span><span class="p">(</span><span class="n">__be32</span> <span class="n">old</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">new</span><span class="p">,</span> <span class="n">__wsum</span> <span class="n">oldsum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">diff</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">~</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="p">};</span>

	<span class="k">return</span> <span class="n">csum_partial</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">diff</span><span class="p">),</span> <span class="n">oldsum</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IP_VS_IPV6</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__wsum</span> <span class="nf">ip_vs_check_diff16</span><span class="p">(</span><span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
					<span class="n">__wsum</span> <span class="n">oldsum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">diff</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">~</span><span class="n">old</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">~</span><span class="n">old</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">~</span><span class="n">old</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">~</span><span class="n">old</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			    <span class="n">new</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>  <span class="n">new</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>  <span class="n">new</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="n">new</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">};</span>

	<span class="k">return</span> <span class="n">csum_partial</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">diff</span><span class="p">),</span> <span class="n">oldsum</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__wsum</span> <span class="nf">ip_vs_check_diff2</span><span class="p">(</span><span class="n">__be16</span> <span class="n">old</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">new</span><span class="p">,</span> <span class="n">__wsum</span> <span class="n">oldsum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be16</span> <span class="n">diff</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">~</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="p">};</span>

	<span class="k">return</span> <span class="n">csum_partial</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">diff</span><span class="p">),</span> <span class="n">oldsum</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Forget current conntrack (unconfirmed) and attach notrack entry</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ip_vs_notrack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)</span>
	<span class="k">enum</span> <span class="n">ip_conntrack_info</span> <span class="n">ctinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="n">nf_ct_get</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctinfo</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ct</span> <span class="o">||</span> <span class="o">!</span><span class="n">nf_ct_is_untracked</span><span class="p">(</span><span class="n">ct</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nf_reset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nf_ct_untracked_get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ct_general</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfctinfo</span> <span class="o">=</span> <span class="n">IP_CT_NEW</span><span class="p">;</span>
		<span class="n">nf_conntrack_get</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IP_VS_NFCT</span>
<span class="cm">/*</span>
<span class="cm"> *      Netfilter connection tracking</span>
<span class="cm"> *      (from ip_vs_nfct.c)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ip_vs_conntrack_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SYSCTL</span>
	<span class="k">return</span> <span class="n">ipvs</span><span class="o">-&gt;</span><span class="n">sysctl_conntrack</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_update_conntrack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">outin</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_vs_confirm_conntrack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_nfct_expect_related</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nf_conn</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">u_int8_t</span> <span class="n">proto</span><span class="p">,</span>
				      <span class="k">const</span> <span class="n">__be16</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from_rs</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_vs_conn_drop_conntrack</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ip_vs_conntrack_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">netns_ipvs</span> <span class="o">*</span><span class="n">ipvs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ip_vs_update_conntrack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">outin</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ip_vs_confirm_conntrack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ip_vs_conn_drop_conntrack</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_conn</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cm">/* CONFIG_IP_VS_NFCT */</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ip_vs_dest_conn_overhead</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_vs_dest</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We think the overhead of processing active connections is 256</span>
<span class="cm">	 * times higher than that of inactive connections in average. (This</span>
<span class="cm">	 * 256 times might not be accurate, we will change it later) We</span>
<span class="cm">	 * use the following formula to estimate the overhead now:</span>
<span class="cm">	 *		  dest-&gt;activeconns*256 + dest-&gt;inactconns</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">activeconns</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">inactconns</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* _NET_IP_VS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
