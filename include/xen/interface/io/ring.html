<!DOCTYPE html>
<html><head><title>joekychen/linux » include › xen › interface › io › ring.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ring.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> * ring.h</span>
<span class="cm"> *</span>
<span class="cm"> * Shared producer-consumer ring macros.</span>
<span class="cm"> *</span>
<span class="cm"> * Tim Deegan and Andrew Warfield November 2004.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __XEN_PUBLIC_IO_RING_H__</span>
<span class="cp">#define __XEN_PUBLIC_IO_RING_H__</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">RING_IDX</span><span class="p">;</span>

<span class="cm">/* Round a 32-bit unsigned constant down to the nearest power of two. */</span>
<span class="cp">#define __RD2(_x)  (((_x) &amp; 0x00000002) ? 0x2		       : ((_x) &amp; 0x1))</span>
<span class="cp">#define __RD4(_x)  (((_x) &amp; 0x0000000c) ? __RD2((_x)&gt;&gt;2)&lt;&lt;2    : __RD2(_x))</span>
<span class="cp">#define __RD8(_x)  (((_x) &amp; 0x000000f0) ? __RD4((_x)&gt;&gt;4)&lt;&lt;4    : __RD4(_x))</span>
<span class="cp">#define __RD16(_x) (((_x) &amp; 0x0000ff00) ? __RD8((_x)&gt;&gt;8)&lt;&lt;8    : __RD8(_x))</span>
<span class="cp">#define __RD32(_x) (((_x) &amp; 0xffff0000) ? __RD16((_x)&gt;&gt;16)&lt;&lt;16 : __RD16(_x))</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate size of a shared ring, given the total available space for the</span>
<span class="cm"> * ring and indexes (_sz), and the name tag of the request/response structure.</span>
<span class="cm"> * A ring contains as many entries as will fit, rounded down to the nearest</span>
<span class="cm"> * power of two (so we can mask with (size-1) to loop around).</span>
<span class="cm"> */</span>
<span class="cp">#define __CONST_RING_SIZE(_s, _sz)				\</span>
<span class="cp">	(__RD32(((_sz) - offsetof(struct _s##_sring, ring)) /	\</span>
<span class="cp">		sizeof(((struct _s##_sring *)0)-&gt;ring[0])))</span>

<span class="cm">/*</span>
<span class="cm"> * The same for passing in an actual pointer instead of a name tag.</span>
<span class="cm"> */</span>
<span class="cp">#define __RING_SIZE(_s, _sz)						\</span>
<span class="cp">	(__RD32(((_sz) - (long)&amp;(_s)-&gt;ring + (long)(_s)) / sizeof((_s)-&gt;ring[0])))</span>

<span class="cm">/*</span>
<span class="cm"> * Macros to make the correct C datatypes for a new kind of ring.</span>
<span class="cm"> *</span>
<span class="cm"> * To make a new ring datatype, you need to have two message structures,</span>
<span class="cm"> * let&#39;s say struct request, and struct response already defined.</span>
<span class="cm"> *</span>
<span class="cm"> * In a header where you want the ring datatype declared, you then do:</span>
<span class="cm"> *</span>
<span class="cm"> *     DEFINE_RING_TYPES(mytag, struct request, struct response);</span>
<span class="cm"> *</span>
<span class="cm"> * These expand out to give you a set of types, as you can see below.</span>
<span class="cm"> * The most important of these are:</span>
<span class="cm"> *</span>
<span class="cm"> *     struct mytag_sring      - The shared ring.</span>
<span class="cm"> *     struct mytag_front_ring - The &#39;front&#39; half of the ring.</span>
<span class="cm"> *     struct mytag_back_ring  - The &#39;back&#39; half of the ring.</span>
<span class="cm"> *</span>
<span class="cm"> * To initialize a ring in your code you need to know the location and size</span>
<span class="cm"> * of the shared memory area (PAGE_SIZE, for instance). To initialise</span>
<span class="cm"> * the front half:</span>
<span class="cm"> *</span>
<span class="cm"> *     struct mytag_front_ring front_ring;</span>
<span class="cm"> *     SHARED_RING_INIT((struct mytag_sring *)shared_page);</span>
<span class="cm"> *     FRONT_RING_INIT(&amp;front_ring, (struct mytag_sring *)shared_page,</span>
<span class="cm"> *		       PAGE_SIZE);</span>
<span class="cm"> *</span>
<span class="cm"> * Initializing the back follows similarly (note that only the front</span>
<span class="cm"> * initializes the shared ring):</span>
<span class="cm"> *</span>
<span class="cm"> *     struct mytag_back_ring back_ring;</span>
<span class="cm"> *     BACK_RING_INIT(&amp;back_ring, (struct mytag_sring *)shared_page,</span>
<span class="cm"> *		      PAGE_SIZE);</span>
<span class="cm"> */</span>

<span class="cp">#define DEFINE_RING_TYPES(__name, __req_t, __rsp_t)			\</span>
<span class="cp">									\</span>
<span class="cm">/* Shared ring entry */</span><span class="cp">							\</span>
<span class="cp">union __name##_sring_entry {						\</span>
<span class="cp">    __req_t req;							\</span>
<span class="cp">    __rsp_t rsp;							\</span>
<span class="cp">};									\</span>
<span class="cp">									\</span>
<span class="cm">/* Shared ring page */</span><span class="cp">							\</span>
<span class="cp">struct __name##_sring {							\</span>
<span class="cp">    RING_IDX req_prod, req_event;					\</span>
<span class="cp">    RING_IDX rsp_prod, rsp_event;					\</span>
<span class="cp">    uint8_t  pad[48];							\</span>
<span class="cp">    union __name##_sring_entry ring[1]; </span><span class="cm">/* variable-length */</span><span class="cp">		\</span>
<span class="cp">};									\</span>
<span class="cp">									\</span>
<span class="cm">/* &quot;Front&quot; end&#39;s private variables */</span><span class="cp">					\</span>
<span class="cp">struct __name##_front_ring {						\</span>
<span class="cp">    RING_IDX req_prod_pvt;						\</span>
<span class="cp">    RING_IDX rsp_cons;							\</span>
<span class="cp">    unsigned int nr_ents;						\</span>
<span class="cp">    struct __name##_sring *sring;					\</span>
<span class="cp">};									\</span>
<span class="cp">									\</span>
<span class="cm">/* &quot;Back&quot; end&#39;s private variables */</span><span class="cp">					\</span>
<span class="cp">struct __name##_back_ring {						\</span>
<span class="cp">    RING_IDX rsp_prod_pvt;						\</span>
<span class="cp">    RING_IDX req_cons;							\</span>
<span class="cp">    unsigned int nr_ents;						\</span>
<span class="cp">    struct __name##_sring *sring;					\</span>
<span class="cp">};</span>

<span class="cm">/*</span>
<span class="cm"> * Macros for manipulating rings.</span>
<span class="cm"> *</span>
<span class="cm"> * FRONT_RING_whatever works on the &quot;front end&quot; of a ring: here</span>
<span class="cm"> * requests are pushed on to the ring and responses taken off it.</span>
<span class="cm"> *</span>
<span class="cm"> * BACK_RING_whatever works on the &quot;back end&quot; of a ring: here</span>
<span class="cm"> * requests are taken off the ring and responses put on.</span>
<span class="cm"> *</span>
<span class="cm"> * N.B. these macros do NO INTERLOCKS OR FLOW CONTROL.</span>
<span class="cm"> * This is OK in 1-for-1 request-response situations where the</span>
<span class="cm"> * requestor (front end) never has more than RING_SIZE()-1</span>
<span class="cm"> * outstanding requests.</span>
<span class="cm"> */</span>

<span class="cm">/* Initialising empty rings */</span>
<span class="cp">#define SHARED_RING_INIT(_s) do {					\</span>
<span class="cp">    (_s)-&gt;req_prod  = (_s)-&gt;rsp_prod  = 0;				\</span>
<span class="cp">    (_s)-&gt;req_event = (_s)-&gt;rsp_event = 1;				\</span>
<span class="cp">    memset((_s)-&gt;pad, 0, sizeof((_s)-&gt;pad));				\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define FRONT_RING_INIT(_r, _s, __size) do {				\</span>
<span class="cp">    (_r)-&gt;req_prod_pvt = 0;						\</span>
<span class="cp">    (_r)-&gt;rsp_cons = 0;							\</span>
<span class="cp">    (_r)-&gt;nr_ents = __RING_SIZE(_s, __size);				\</span>
<span class="cp">    (_r)-&gt;sring = (_s);							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define BACK_RING_INIT(_r, _s, __size) do {				\</span>
<span class="cp">    (_r)-&gt;rsp_prod_pvt = 0;						\</span>
<span class="cp">    (_r)-&gt;req_cons = 0;							\</span>
<span class="cp">    (_r)-&gt;nr_ents = __RING_SIZE(_s, __size);				\</span>
<span class="cp">    (_r)-&gt;sring = (_s);							\</span>
<span class="cp">} while (0)</span>

<span class="cm">/* Initialize to existing shared indexes -- for recovery */</span>
<span class="cp">#define FRONT_RING_ATTACH(_r, _s, __size) do {				\</span>
<span class="cp">    (_r)-&gt;sring = (_s);							\</span>
<span class="cp">    (_r)-&gt;req_prod_pvt = (_s)-&gt;req_prod;				\</span>
<span class="cp">    (_r)-&gt;rsp_cons = (_s)-&gt;rsp_prod;					\</span>
<span class="cp">    (_r)-&gt;nr_ents = __RING_SIZE(_s, __size);				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define BACK_RING_ATTACH(_r, _s, __size) do {				\</span>
<span class="cp">    (_r)-&gt;sring = (_s);							\</span>
<span class="cp">    (_r)-&gt;rsp_prod_pvt = (_s)-&gt;rsp_prod;				\</span>
<span class="cp">    (_r)-&gt;req_cons = (_s)-&gt;req_prod;					\</span>
<span class="cp">    (_r)-&gt;nr_ents = __RING_SIZE(_s, __size);				\</span>
<span class="cp">} while (0)</span>

<span class="cm">/* How big is this ring? */</span>
<span class="cp">#define RING_SIZE(_r)							\</span>
<span class="cp">    ((_r)-&gt;nr_ents)</span>

<span class="cm">/* Number of free requests (for use on front side only). */</span>
<span class="cp">#define RING_FREE_REQUESTS(_r)						\</span>
<span class="cp">    (RING_SIZE(_r) - ((_r)-&gt;req_prod_pvt - (_r)-&gt;rsp_cons))</span>

<span class="cm">/* Test if there is an empty slot available on the front ring.</span>
<span class="cm"> * (This is only meaningful from the front. )</span>
<span class="cm"> */</span>
<span class="cp">#define RING_FULL(_r)							\</span>
<span class="cp">    (RING_FREE_REQUESTS(_r) == 0)</span>

<span class="cm">/* Test if there are outstanding messages to be processed on a ring. */</span>
<span class="cp">#define RING_HAS_UNCONSUMED_RESPONSES(_r)				\</span>
<span class="cp">    ((_r)-&gt;sring-&gt;rsp_prod - (_r)-&gt;rsp_cons)</span>

<span class="cp">#define RING_HAS_UNCONSUMED_REQUESTS(_r)				\</span>
<span class="cp">    ({									\</span>
<span class="cp">	unsigned int req = (_r)-&gt;sring-&gt;req_prod - (_r)-&gt;req_cons;	\</span>
<span class="cp">	unsigned int rsp = RING_SIZE(_r) -				\</span>
<span class="cp">			   ((_r)-&gt;req_cons - (_r)-&gt;rsp_prod_pvt);	\</span>
<span class="cp">	req &lt; rsp ? req : rsp;						\</span>
<span class="cp">    })</span>

<span class="cm">/* Direct access to individual ring elements, by index. */</span>
<span class="cp">#define RING_GET_REQUEST(_r, _idx)					\</span>
<span class="cp">    (&amp;((_r)-&gt;sring-&gt;ring[((_idx) &amp; (RING_SIZE(_r) - 1))].req))</span>

<span class="cp">#define RING_GET_RESPONSE(_r, _idx)					\</span>
<span class="cp">    (&amp;((_r)-&gt;sring-&gt;ring[((_idx) &amp; (RING_SIZE(_r) - 1))].rsp))</span>

<span class="cm">/* Loop termination condition: Would the specified index overflow the ring? */</span>
<span class="cp">#define RING_REQUEST_CONS_OVERFLOW(_r, _cons)				\</span>
<span class="cp">    (((_cons) - (_r)-&gt;rsp_prod_pvt) &gt;= RING_SIZE(_r))</span>

<span class="cp">#define RING_PUSH_REQUESTS(_r) do {					\</span>
<span class="cp">    wmb(); </span><span class="cm">/* back sees requests /before/ updated producer index */</span><span class="cp">	\</span>
<span class="cp">    (_r)-&gt;sring-&gt;req_prod = (_r)-&gt;req_prod_pvt;				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define RING_PUSH_RESPONSES(_r) do {					\</span>
<span class="cp">    wmb(); </span><span class="cm">/* front sees responses /before/ updated producer index */</span><span class="cp">	\</span>
<span class="cp">    (_r)-&gt;sring-&gt;rsp_prod = (_r)-&gt;rsp_prod_pvt;				\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Notification hold-off (req_event and rsp_event):</span>
<span class="cm"> *</span>
<span class="cm"> * When queueing requests or responses on a shared ring, it may not always be</span>
<span class="cm"> * necessary to notify the remote end. For example, if requests are in flight</span>
<span class="cm"> * in a backend, the front may be able to queue further requests without</span>
<span class="cm"> * notifying the back (if the back checks for new requests when it queues</span>
<span class="cm"> * responses).</span>
<span class="cm"> *</span>
<span class="cm"> * When enqueuing requests or responses:</span>
<span class="cm"> *</span>
<span class="cm"> *  Use RING_PUSH_{REQUESTS,RESPONSES}_AND_CHECK_NOTIFY(). The second argument</span>
<span class="cm"> *  is a boolean return value. True indicates that the receiver requires an</span>
<span class="cm"> *  asynchronous notification.</span>
<span class="cm"> *</span>
<span class="cm"> * After dequeuing requests or responses (before sleeping the connection):</span>
<span class="cm"> *</span>
<span class="cm"> *  Use RING_FINAL_CHECK_FOR_REQUESTS() or RING_FINAL_CHECK_FOR_RESPONSES().</span>
<span class="cm"> *  The second argument is a boolean return value. True indicates that there</span>
<span class="cm"> *  are pending messages on the ring (i.e., the connection should not be put</span>
<span class="cm"> *  to sleep).</span>
<span class="cm"> *</span>
<span class="cm"> *  These macros will set the req_event/rsp_event field to trigger a</span>
<span class="cm"> *  notification on the very next message that is enqueued. If you want to</span>
<span class="cm"> *  create batches of work (i.e., only receive a notification after several</span>
<span class="cm"> *  messages have been enqueued) then you will need to create a customised</span>
<span class="cm"> *  version of the FINAL_CHECK macro in your own code, which sets the event</span>
<span class="cm"> *  field appropriately.</span>
<span class="cm"> */</span>

<span class="cp">#define RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(_r, _notify) do {		\</span>
<span class="cp">    RING_IDX __old = (_r)-&gt;sring-&gt;req_prod;				\</span>
<span class="cp">    RING_IDX __new = (_r)-&gt;req_prod_pvt;				\</span>
<span class="cp">    wmb(); </span><span class="cm">/* back sees requests /before/ updated producer index */</span><span class="cp">	\</span>
<span class="cp">    (_r)-&gt;sring-&gt;req_prod = __new;					\</span>
<span class="cp">    mb(); </span><span class="cm">/* back sees new requests /before/ we check req_event */</span><span class="cp">	\</span>
<span class="cp">    (_notify) = ((RING_IDX)(__new - (_r)-&gt;sring-&gt;req_event) &lt;		\</span>
<span class="cp">		 (RING_IDX)(__new - __old));				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(_r, _notify) do {		\</span>
<span class="cp">    RING_IDX __old = (_r)-&gt;sring-&gt;rsp_prod;				\</span>
<span class="cp">    RING_IDX __new = (_r)-&gt;rsp_prod_pvt;				\</span>
<span class="cp">    wmb(); </span><span class="cm">/* front sees responses /before/ updated producer index */</span><span class="cp">	\</span>
<span class="cp">    (_r)-&gt;sring-&gt;rsp_prod = __new;					\</span>
<span class="cp">    mb(); </span><span class="cm">/* front sees new responses /before/ we check rsp_event */</span><span class="cp">	\</span>
<span class="cp">    (_notify) = ((RING_IDX)(__new - (_r)-&gt;sring-&gt;rsp_event) &lt;		\</span>
<span class="cp">		 (RING_IDX)(__new - __old));				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define RING_FINAL_CHECK_FOR_REQUESTS(_r, _work_to_do) do {		\</span>
<span class="cp">    (_work_to_do) = RING_HAS_UNCONSUMED_REQUESTS(_r);			\</span>
<span class="cp">    if (_work_to_do) break;						\</span>
<span class="cp">    (_r)-&gt;sring-&gt;req_event = (_r)-&gt;req_cons + 1;			\</span>
<span class="cp">    mb();								\</span>
<span class="cp">    (_work_to_do) = RING_HAS_UNCONSUMED_REQUESTS(_r);			\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define RING_FINAL_CHECK_FOR_RESPONSES(_r, _work_to_do) do {		\</span>
<span class="cp">    (_work_to_do) = RING_HAS_UNCONSUMED_RESPONSES(_r);			\</span>
<span class="cp">    if (_work_to_do) break;						\</span>
<span class="cp">    (_r)-&gt;sring-&gt;rsp_event = (_r)-&gt;rsp_cons + 1;			\</span>
<span class="cp">    mb();								\</span>
<span class="cp">    (_work_to_do) = RING_HAS_UNCONSUMED_RESPONSES(_r);			\</span>
<span class="cp">} while (0)</span>

<span class="cp">#endif </span><span class="cm">/* __XEN_PUBLIC_IO_RING_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
