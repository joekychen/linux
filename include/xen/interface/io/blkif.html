<!DOCTYPE html>
<html><head><title>joekychen/linux » include › xen › interface › io › blkif.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>blkif.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> * blkif.h</span>
<span class="cm"> *</span>
<span class="cm"> * Unified block-device I/O interface for Xen guest OSes.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2003-2004, Keir Fraser</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __XEN_PUBLIC_IO_BLKIF_H__</span>
<span class="cp">#define __XEN_PUBLIC_IO_BLKIF_H__</span>

<span class="cp">#include &quot;ring.h&quot;</span>
<span class="cp">#include &quot;../grant_table.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Front-&gt;back notifications: When enqueuing a new request, sending a</span>
<span class="cm"> * notification can be made conditional on req_event (i.e., the generic</span>
<span class="cm"> * hold-off mechanism provided by the ring macros). Backends must set</span>
<span class="cm"> * req_event appropriately (e.g., using RING_FINAL_CHECK_FOR_REQUESTS()).</span>
<span class="cm"> *</span>
<span class="cm"> * Back-&gt;front notifications: When enqueuing a new response, sending a</span>
<span class="cm"> * notification can be made conditional on rsp_event (i.e., the generic</span>
<span class="cm"> * hold-off mechanism provided by the ring macros). Frontends must set</span>
<span class="cm"> * rsp_event appropriately (e.g., using RING_FINAL_CHECK_FOR_RESPONSES()).</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="kt">uint16_t</span> <span class="n">blkif_vdev_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">uint64_t</span> <span class="n">blkif_sector_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * REQUEST CODES.</span>
<span class="cm"> */</span>
<span class="cp">#define BLKIF_OP_READ              0</span>
<span class="cp">#define BLKIF_OP_WRITE             1</span>
<span class="cm">/*</span>
<span class="cm"> * Recognised only if &quot;feature-barrier&quot; is present in backend xenbus info.</span>
<span class="cm"> * The &quot;feature_barrier&quot; node contains a boolean indicating whether barrier</span>
<span class="cm"> * requests are likely to succeed or fail. Either way, a barrier request</span>
<span class="cm"> * may fail at any time with BLKIF_RSP_EOPNOTSUPP if it is unsupported by</span>
<span class="cm"> * the underlying block-device hardware. The boolean simply indicates whether</span>
<span class="cm"> * or not it is worthwhile for the frontend to attempt barrier requests.</span>
<span class="cm"> * If a backend does not recognise BLKIF_OP_WRITE_BARRIER, it should *not*</span>
<span class="cm"> * create the &quot;feature-barrier&quot; node!</span>
<span class="cm"> */</span>
<span class="cp">#define BLKIF_OP_WRITE_BARRIER     2</span>

<span class="cm">/*</span>
<span class="cm"> * Recognised if &quot;feature-flush-cache&quot; is present in backend xenbus</span>
<span class="cm"> * info.  A flush will ask the underlying storage hardware to flush its</span>
<span class="cm"> * non-volatile caches as appropriate.  The &quot;feature-flush-cache&quot; node</span>
<span class="cm"> * contains a boolean indicating whether flush requests are likely to</span>
<span class="cm"> * succeed or fail. Either way, a flush request may fail at any time</span>
<span class="cm"> * with BLKIF_RSP_EOPNOTSUPP if it is unsupported by the underlying</span>
<span class="cm"> * block-device hardware. The boolean simply indicates whether or not it</span>
<span class="cm"> * is worthwhile for the frontend to attempt flushes.  If a backend does</span>
<span class="cm"> * not recognise BLKIF_OP_WRITE_FLUSH_CACHE, it should *not* create the</span>
<span class="cm"> * &quot;feature-flush-cache&quot; node!</span>
<span class="cm"> */</span>
<span class="cp">#define BLKIF_OP_FLUSH_DISKCACHE   3</span>

<span class="cm">/*</span>
<span class="cm"> * Recognised only if &quot;feature-discard&quot; is present in backend xenbus info.</span>
<span class="cm"> * The &quot;feature-discard&quot; node contains a boolean indicating whether trim</span>
<span class="cm"> * (ATA) or unmap (SCSI) - conviently called discard requests are likely</span>
<span class="cm"> * to succeed or fail. Either way, a discard request</span>
<span class="cm"> * may fail at any time with BLKIF_RSP_EOPNOTSUPP if it is unsupported by</span>
<span class="cm"> * the underlying block-device hardware. The boolean simply indicates whether</span>
<span class="cm"> * or not it is worthwhile for the frontend to attempt discard requests.</span>
<span class="cm"> * If a backend does not recognise BLKIF_OP_DISCARD, it should *not*</span>
<span class="cm"> * create the &quot;feature-discard&quot; node!</span>
<span class="cm"> *</span>
<span class="cm"> * Discard operation is a request for the underlying block device to mark</span>
<span class="cm"> * extents to be erased. However, discard does not guarantee that the blocks</span>
<span class="cm"> * will be erased from the device - it is just a hint to the device</span>
<span class="cm"> * controller that these blocks are no longer in use. What the device</span>
<span class="cm"> * controller does with that information is left to the controller.</span>
<span class="cm"> * Discard operations are passed with sector_number as the</span>
<span class="cm"> * sector index to begin discard operations at and nr_sectors as the number of</span>
<span class="cm"> * sectors to be discarded. The specified sectors should be discarded if the</span>
<span class="cm"> * underlying block device supports trim (ATA) or unmap (SCSI) operations,</span>
<span class="cm"> * or a BLKIF_RSP_EOPNOTSUPP  should be returned.</span>
<span class="cm"> * More information about trim/unmap operations at:</span>
<span class="cm"> * http://t13.org/Documents/UploadedDocuments/docs2008/</span>
<span class="cm"> *     e07154r6-Data_Set_Management_Proposal_for_ATA-ACS2.doc</span>
<span class="cm"> * http://www.seagate.com/staticfiles/support/disc/manuals/</span>
<span class="cm"> *     Interface%20manuals/100293068c.pdf</span>
<span class="cm"> * The backend can optionally provide three extra XenBus attributes to</span>
<span class="cm"> * further optimize the discard functionality:</span>
<span class="cm"> * &#39;discard-aligment&#39; - Devices that support discard functionality may</span>
<span class="cm"> * internally allocate space in units that are bigger than the exported</span>
<span class="cm"> * logical block size. The discard-alignment parameter indicates how many bytes</span>
<span class="cm"> * the beginning of the partition is offset from the internal allocation unit&#39;s</span>
<span class="cm"> * natural alignment.</span>
<span class="cm"> * &#39;discard-granularity&#39;  - Devices that support discard functionality may</span>
<span class="cm"> * internally allocate space using units that are bigger than the logical block</span>
<span class="cm"> * size. The discard-granularity parameter indicates the size of the internal</span>
<span class="cm"> * allocation unit in bytes if reported by the device. Otherwise the</span>
<span class="cm"> * discard-granularity will be set to match the device&#39;s physical block size.</span>
<span class="cm"> * &#39;discard-secure&#39; - All copies of the discarded sectors (potentially created</span>
<span class="cm"> * by garbage collection) must also be erased.  To use this feature, the flag</span>
<span class="cm"> * BLKIF_DISCARD_SECURE must be set in the blkif_request_trim.</span>
<span class="cm"> */</span>
<span class="cp">#define BLKIF_OP_DISCARD           5</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum scatter/gather segments per request.</span>
<span class="cm"> * This is carefully chosen so that sizeof(struct blkif_ring) &lt;= PAGE_SIZE.</span>
<span class="cm"> * NB. This could be 12 if the ring indexes weren&#39;t stored in the same page.</span>
<span class="cm"> */</span>
<span class="cp">#define BLKIF_MAX_SEGMENTS_PER_REQUEST 11</span>

<span class="k">struct</span> <span class="n">blkif_request_rw</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>        <span class="n">nr_segments</span><span class="p">;</span>  <span class="cm">/* number of segments                   */</span>
	<span class="n">blkif_vdev_t</span>   <span class="n">handle</span><span class="p">;</span>       <span class="cm">/* only for read/write requests         */</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="kt">uint32_t</span>       <span class="n">_pad1</span><span class="p">;</span>	     <span class="cm">/* offsetof(blkif_request,u.rw.id) == 8 */</span>
<span class="cp">#endif</span>
	<span class="kt">uint64_t</span>       <span class="n">id</span><span class="p">;</span>           <span class="cm">/* private guest value, echoed in resp  */</span>
	<span class="n">blkif_sector_t</span> <span class="n">sector_number</span><span class="p">;</span><span class="cm">/* start sector idx on disk (r/w only)  */</span>
	<span class="k">struct</span> <span class="n">blkif_request_segment</span> <span class="p">{</span>
		<span class="n">grant_ref_t</span> <span class="n">gref</span><span class="p">;</span>        <span class="cm">/* reference to I/O buffer frame        */</span>
		<span class="cm">/* @first_sect: first sector in frame to transfer (inclusive).   */</span>
		<span class="cm">/* @last_sect: last sector in frame to transfer (inclusive).     */</span>
		<span class="kt">uint8_t</span>     <span class="n">first_sect</span><span class="p">,</span> <span class="n">last_sect</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">seg</span><span class="p">[</span><span class="n">BLKIF_MAX_SEGMENTS_PER_REQUEST</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">blkif_request_discard</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>        <span class="n">flag</span><span class="p">;</span>         <span class="cm">/* BLKIF_DISCARD_SECURE or zero.        */</span>
<span class="cp">#define BLKIF_DISCARD_SECURE (1&lt;&lt;0)  </span><span class="cm">/* ignored if discard-secure=0          */</span><span class="cp"></span>
	<span class="n">blkif_vdev_t</span>   <span class="n">_pad1</span><span class="p">;</span>        <span class="cm">/* only for read/write requests         */</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="kt">uint32_t</span>       <span class="n">_pad2</span><span class="p">;</span>        <span class="cm">/* offsetof(blkif_req..,u.discard.id)==8*/</span>
<span class="cp">#endif</span>
	<span class="kt">uint64_t</span>       <span class="n">id</span><span class="p">;</span>           <span class="cm">/* private guest value, echoed in resp  */</span>
	<span class="n">blkif_sector_t</span> <span class="n">sector_number</span><span class="p">;</span>
	<span class="kt">uint64_t</span>       <span class="n">nr_sectors</span><span class="p">;</span>
	<span class="kt">uint8_t</span>        <span class="n">_pad3</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">blkif_request</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>        <span class="n">operation</span><span class="p">;</span>    <span class="cm">/* BLKIF_OP_???                         */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">blkif_request_rw</span> <span class="n">rw</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">blkif_request_discard</span> <span class="n">discard</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">blkif_response</span> <span class="p">{</span>
	<span class="kt">uint64_t</span>        <span class="n">id</span><span class="p">;</span>              <span class="cm">/* copied from request */</span>
	<span class="kt">uint8_t</span>         <span class="n">operation</span><span class="p">;</span>       <span class="cm">/* copied from request */</span>
	<span class="kt">int16_t</span>         <span class="n">status</span><span class="p">;</span>          <span class="cm">/* BLKIF_RSP_???       */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * STATUS RETURN CODES.</span>
<span class="cm"> */</span>
 <span class="cm">/* Operation not supported (only happens on barrier writes). */</span>
<span class="cp">#define BLKIF_RSP_EOPNOTSUPP  -2</span>
 <span class="cm">/* Operation failed for some unspecified reason (-EIO). */</span>
<span class="cp">#define BLKIF_RSP_ERROR       -1</span>
 <span class="cm">/* Operation completed successfully. */</span>
<span class="cp">#define BLKIF_RSP_OKAY         0</span>

<span class="cm">/*</span>
<span class="cm"> * Generate blkif ring structures and types.</span>
<span class="cm"> */</span>

<span class="n">DEFINE_RING_TYPES</span><span class="p">(</span><span class="n">blkif</span><span class="p">,</span> <span class="k">struct</span> <span class="n">blkif_request</span><span class="p">,</span> <span class="k">struct</span> <span class="n">blkif_response</span><span class="p">);</span>

<span class="cp">#define VDISK_CDROM        0x1</span>
<span class="cp">#define VDISK_REMOVABLE    0x2</span>
<span class="cp">#define VDISK_READONLY     0x4</span>

<span class="cm">/* Xen-defined major numbers for virtual disks, they look strangely</span>
<span class="cm"> * familiar */</span>
<span class="cp">#define XEN_IDE0_MAJOR	3</span>
<span class="cp">#define XEN_IDE1_MAJOR	22</span>
<span class="cp">#define XEN_SCSI_DISK0_MAJOR	8</span>
<span class="cp">#define XEN_SCSI_DISK1_MAJOR	65</span>
<span class="cp">#define XEN_SCSI_DISK2_MAJOR	66</span>
<span class="cp">#define XEN_SCSI_DISK3_MAJOR	67</span>
<span class="cp">#define XEN_SCSI_DISK4_MAJOR	68</span>
<span class="cp">#define XEN_SCSI_DISK5_MAJOR	69</span>
<span class="cp">#define XEN_SCSI_DISK6_MAJOR	70</span>
<span class="cp">#define XEN_SCSI_DISK7_MAJOR	71</span>
<span class="cp">#define XEN_SCSI_DISK8_MAJOR	128</span>
<span class="cp">#define XEN_SCSI_DISK9_MAJOR	129</span>
<span class="cp">#define XEN_SCSI_DISK10_MAJOR	130</span>
<span class="cp">#define XEN_SCSI_DISK11_MAJOR	131</span>
<span class="cp">#define XEN_SCSI_DISK12_MAJOR	132</span>
<span class="cp">#define XEN_SCSI_DISK13_MAJOR	133</span>
<span class="cp">#define XEN_SCSI_DISK14_MAJOR	134</span>
<span class="cp">#define XEN_SCSI_DISK15_MAJOR	135</span>

<span class="cp">#endif </span><span class="cm">/* __XEN_PUBLIC_IO_BLKIF_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
