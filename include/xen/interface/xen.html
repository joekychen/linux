<!DOCTYPE html>
<html><head><title>joekychen/linux » include › xen › interface › xen.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>xen.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> * xen.h</span>
<span class="cm"> *</span>
<span class="cm"> * Guest OS interface to Xen.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2004, K A Fraser</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __XEN_PUBLIC_XEN_H__</span>
<span class="cp">#define __XEN_PUBLIC_XEN_H__</span>

<span class="cp">#include &lt;asm/xen/interface.h&gt;</span>
<span class="cp">#include &lt;asm/pvclock-abi.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * XEN &quot;SYSTEM CALLS&quot; (a.k.a. HYPERCALLS).</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * x86_32: EAX = vector; EBX, ECX, EDX, ESI, EDI = args 1, 2, 3, 4, 5.</span>
<span class="cm"> *         EAX = return value</span>
<span class="cm"> *         (argument registers may be clobbered on return)</span>
<span class="cm"> * x86_64: RAX = vector; RDI, RSI, RDX, R10, R8, R9 = args 1, 2, 3, 4, 5, 6.</span>
<span class="cm"> *         RAX = return value</span>
<span class="cm"> *         (argument registers not clobbered on return; RCX, R11 are)</span>
<span class="cm"> */</span>
<span class="cp">#define __HYPERVISOR_set_trap_table        0</span>
<span class="cp">#define __HYPERVISOR_mmu_update            1</span>
<span class="cp">#define __HYPERVISOR_set_gdt               2</span>
<span class="cp">#define __HYPERVISOR_stack_switch          3</span>
<span class="cp">#define __HYPERVISOR_set_callbacks         4</span>
<span class="cp">#define __HYPERVISOR_fpu_taskswitch        5</span>
<span class="cp">#define __HYPERVISOR_sched_op_compat       6</span>
<span class="cp">#define __HYPERVISOR_dom0_op               7</span>
<span class="cp">#define __HYPERVISOR_set_debugreg          8</span>
<span class="cp">#define __HYPERVISOR_get_debugreg          9</span>
<span class="cp">#define __HYPERVISOR_update_descriptor    10</span>
<span class="cp">#define __HYPERVISOR_memory_op            12</span>
<span class="cp">#define __HYPERVISOR_multicall            13</span>
<span class="cp">#define __HYPERVISOR_update_va_mapping    14</span>
<span class="cp">#define __HYPERVISOR_set_timer_op         15</span>
<span class="cp">#define __HYPERVISOR_event_channel_op_compat 16</span>
<span class="cp">#define __HYPERVISOR_xen_version          17</span>
<span class="cp">#define __HYPERVISOR_console_io           18</span>
<span class="cp">#define __HYPERVISOR_physdev_op_compat    19</span>
<span class="cp">#define __HYPERVISOR_grant_table_op       20</span>
<span class="cp">#define __HYPERVISOR_vm_assist            21</span>
<span class="cp">#define __HYPERVISOR_update_va_mapping_otherdomain 22</span>
<span class="cp">#define __HYPERVISOR_iret                 23 </span><span class="cm">/* x86 only */</span><span class="cp"></span>
<span class="cp">#define __HYPERVISOR_vcpu_op              24</span>
<span class="cp">#define __HYPERVISOR_set_segment_base     25 </span><span class="cm">/* x86/64 only */</span><span class="cp"></span>
<span class="cp">#define __HYPERVISOR_mmuext_op            26</span>
<span class="cp">#define __HYPERVISOR_acm_op               27</span>
<span class="cp">#define __HYPERVISOR_nmi_op               28</span>
<span class="cp">#define __HYPERVISOR_sched_op             29</span>
<span class="cp">#define __HYPERVISOR_callback_op          30</span>
<span class="cp">#define __HYPERVISOR_xenoprof_op          31</span>
<span class="cp">#define __HYPERVISOR_event_channel_op     32</span>
<span class="cp">#define __HYPERVISOR_physdev_op           33</span>
<span class="cp">#define __HYPERVISOR_hvm_op               34</span>
<span class="cp">#define __HYPERVISOR_tmem_op              38</span>

<span class="cm">/* Architecture-specific hypercall definitions. */</span>
<span class="cp">#define __HYPERVISOR_arch_0               48</span>
<span class="cp">#define __HYPERVISOR_arch_1               49</span>
<span class="cp">#define __HYPERVISOR_arch_2               50</span>
<span class="cp">#define __HYPERVISOR_arch_3               51</span>
<span class="cp">#define __HYPERVISOR_arch_4               52</span>
<span class="cp">#define __HYPERVISOR_arch_5               53</span>
<span class="cp">#define __HYPERVISOR_arch_6               54</span>
<span class="cp">#define __HYPERVISOR_arch_7               55</span>

<span class="cm">/*</span>
<span class="cm"> * VIRTUAL INTERRUPTS</span>
<span class="cm"> *</span>
<span class="cm"> * Virtual interrupts that a guest OS may receive from Xen.</span>
<span class="cm"> */</span>
<span class="cp">#define VIRQ_TIMER      0  </span><span class="cm">/* Timebase update, and/or requested timeout.  */</span><span class="cp"></span>
<span class="cp">#define VIRQ_DEBUG      1  </span><span class="cm">/* Request guest to dump debug info.           */</span><span class="cp"></span>
<span class="cp">#define VIRQ_CONSOLE    2  </span><span class="cm">/* (DOM0) Bytes received on emergency console. */</span><span class="cp"></span>
<span class="cp">#define VIRQ_DOM_EXC    3  </span><span class="cm">/* (DOM0) Exceptional event for some domain.   */</span><span class="cp"></span>
<span class="cp">#define VIRQ_DEBUGGER   6  </span><span class="cm">/* (DOM0) A domain has paused for debugging.   */</span><span class="cp"></span>

<span class="cm">/* Architecture-specific VIRQ definitions. */</span>
<span class="cp">#define VIRQ_ARCH_0    16</span>
<span class="cp">#define VIRQ_ARCH_1    17</span>
<span class="cp">#define VIRQ_ARCH_2    18</span>
<span class="cp">#define VIRQ_ARCH_3    19</span>
<span class="cp">#define VIRQ_ARCH_4    20</span>
<span class="cp">#define VIRQ_ARCH_5    21</span>
<span class="cp">#define VIRQ_ARCH_6    22</span>
<span class="cp">#define VIRQ_ARCH_7    23</span>

<span class="cp">#define NR_VIRQS       24</span>
<span class="cm">/*</span>
<span class="cm"> * MMU-UPDATE REQUESTS</span>
<span class="cm"> *</span>
<span class="cm"> * HYPERVISOR_mmu_update() accepts a list of (ptr, val) pairs.</span>
<span class="cm"> * A foreigndom (FD) can be specified (or DOMID_SELF for none).</span>
<span class="cm"> * Where the FD has some effect, it is described below.</span>
<span class="cm"> * ptr[1:0] specifies the appropriate MMU_* command.</span>
<span class="cm"> *</span>
<span class="cm"> * ptr[1:0] == MMU_NORMAL_PT_UPDATE:</span>
<span class="cm"> * Updates an entry in a page table. If updating an L1 table, and the new</span>
<span class="cm"> * table entry is valid/present, the mapped frame must belong to the FD, if</span>
<span class="cm"> * an FD has been specified. If attempting to map an I/O page then the</span>
<span class="cm"> * caller assumes the privilege of the FD.</span>
<span class="cm"> * FD == DOMID_IO: Permit /only/ I/O mappings, at the priv level of the caller.</span>
<span class="cm"> * FD == DOMID_XEN: Map restricted areas of Xen&#39;s heap space.</span>
<span class="cm"> * ptr[:2]  -- Machine address of the page-table entry to modify.</span>
<span class="cm"> * val      -- Value to write.</span>
<span class="cm"> *</span>
<span class="cm"> * ptr[1:0] == MMU_MACHPHYS_UPDATE:</span>
<span class="cm"> * Updates an entry in the machine-&gt;pseudo-physical mapping table.</span>
<span class="cm"> * ptr[:2]  -- Machine address within the frame whose mapping to modify.</span>
<span class="cm"> *             The frame must belong to the FD, if one is specified.</span>
<span class="cm"> * val      -- Value to write into the mapping entry.</span>
<span class="cm"> *</span>
<span class="cm"> * ptr[1:0] == MMU_PT_UPDATE_PRESERVE_AD:</span>
<span class="cm"> * As MMU_NORMAL_PT_UPDATE above, but A/D bits currently in the PTE are ORed</span>
<span class="cm"> * with those in @val.</span>
<span class="cm"> */</span>
<span class="cp">#define MMU_NORMAL_PT_UPDATE      0 </span><span class="cm">/* checked &#39;*ptr = val&#39;. ptr is MA.       */</span><span class="cp"></span>
<span class="cp">#define MMU_MACHPHYS_UPDATE       1 </span><span class="cm">/* ptr = MA of frame to modify entry for  */</span><span class="cp"></span>
<span class="cp">#define MMU_PT_UPDATE_PRESERVE_AD 2 </span><span class="cm">/* atomically: *ptr = val | (*ptr&amp;(A|D)) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * MMU EXTENDED OPERATIONS</span>
<span class="cm"> *</span>
<span class="cm"> * HYPERVISOR_mmuext_op() accepts a list of mmuext_op structures.</span>
<span class="cm"> * A foreigndom (FD) can be specified (or DOMID_SELF for none).</span>
<span class="cm"> * Where the FD has some effect, it is described below.</span>
<span class="cm"> *</span>
<span class="cm"> * cmd: MMUEXT_(UN)PIN_*_TABLE</span>
<span class="cm"> * mfn: Machine frame number to be (un)pinned as a p.t. page.</span>
<span class="cm"> *      The frame must belong to the FD, if one is specified.</span>
<span class="cm"> *</span>
<span class="cm"> * cmd: MMUEXT_NEW_BASEPTR</span>
<span class="cm"> * mfn: Machine frame number of new page-table base to install in MMU.</span>
<span class="cm"> *</span>
<span class="cm"> * cmd: MMUEXT_NEW_USER_BASEPTR [x86/64 only]</span>
<span class="cm"> * mfn: Machine frame number of new page-table base to install in MMU</span>
<span class="cm"> *      when in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * cmd: MMUEXT_TLB_FLUSH_LOCAL</span>
<span class="cm"> * No additional arguments. Flushes local TLB.</span>
<span class="cm"> *</span>
<span class="cm"> * cmd: MMUEXT_INVLPG_LOCAL</span>
<span class="cm"> * linear_addr: Linear address to be flushed from the local TLB.</span>
<span class="cm"> *</span>
<span class="cm"> * cmd: MMUEXT_TLB_FLUSH_MULTI</span>
<span class="cm"> * vcpumask: Pointer to bitmap of VCPUs to be flushed.</span>
<span class="cm"> *</span>
<span class="cm"> * cmd: MMUEXT_INVLPG_MULTI</span>
<span class="cm"> * linear_addr: Linear address to be flushed.</span>
<span class="cm"> * vcpumask: Pointer to bitmap of VCPUs to be flushed.</span>
<span class="cm"> *</span>
<span class="cm"> * cmd: MMUEXT_TLB_FLUSH_ALL</span>
<span class="cm"> * No additional arguments. Flushes all VCPUs&#39; TLBs.</span>
<span class="cm"> *</span>
<span class="cm"> * cmd: MMUEXT_INVLPG_ALL</span>
<span class="cm"> * linear_addr: Linear address to be flushed from all VCPUs&#39; TLBs.</span>
<span class="cm"> *</span>
<span class="cm"> * cmd: MMUEXT_FLUSH_CACHE</span>
<span class="cm"> * No additional arguments. Writes back and flushes cache contents.</span>
<span class="cm"> *</span>
<span class="cm"> * cmd: MMUEXT_SET_LDT</span>
<span class="cm"> * linear_addr: Linear address of LDT base (NB. must be page-aligned).</span>
<span class="cm"> * nr_ents: Number of entries in LDT.</span>
<span class="cm"> */</span>
<span class="cp">#define MMUEXT_PIN_L1_TABLE      0</span>
<span class="cp">#define MMUEXT_PIN_L2_TABLE      1</span>
<span class="cp">#define MMUEXT_PIN_L3_TABLE      2</span>
<span class="cp">#define MMUEXT_PIN_L4_TABLE      3</span>
<span class="cp">#define MMUEXT_UNPIN_TABLE       4</span>
<span class="cp">#define MMUEXT_NEW_BASEPTR       5</span>
<span class="cp">#define MMUEXT_TLB_FLUSH_LOCAL   6</span>
<span class="cp">#define MMUEXT_INVLPG_LOCAL      7</span>
<span class="cp">#define MMUEXT_TLB_FLUSH_MULTI   8</span>
<span class="cp">#define MMUEXT_INVLPG_MULTI      9</span>
<span class="cp">#define MMUEXT_TLB_FLUSH_ALL    10</span>
<span class="cp">#define MMUEXT_INVLPG_ALL       11</span>
<span class="cp">#define MMUEXT_FLUSH_CACHE      12</span>
<span class="cp">#define MMUEXT_SET_LDT          13</span>
<span class="cp">#define MMUEXT_NEW_USER_BASEPTR 15</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">struct</span> <span class="n">mmuext_op</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="cm">/* [UN]PIN_TABLE, NEW_BASEPTR, NEW_USER_BASEPTR */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">;</span>
		<span class="cm">/* INVLPG_LOCAL, INVLPG_ALL, SET_LDT */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">linear_addr</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">arg1</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="cm">/* SET_LDT */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_ents</span><span class="p">;</span>
		<span class="cm">/* TLB_FLUSH_MULTI, INVLPG_MULTI */</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">vcpumask</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">arg2</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">mmuext_op</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* These are passed as &#39;flags&#39; to update_va_mapping. They can be ORed. */</span>
<span class="cm">/* When specifying UVMF_MULTI, also OR in a pointer to a CPU bitmap.   */</span>
<span class="cm">/* UVMF_LOCAL is merely UVMF_MULTI with a NULL bitmap pointer.         */</span>
<span class="cp">#define UVMF_NONE               (0UL&lt;&lt;0) </span><span class="cm">/* No flushing at all.   */</span><span class="cp"></span>
<span class="cp">#define UVMF_TLB_FLUSH          (1UL&lt;&lt;0) </span><span class="cm">/* Flush entire TLB(s).  */</span><span class="cp"></span>
<span class="cp">#define UVMF_INVLPG             (2UL&lt;&lt;0) </span><span class="cm">/* Flush only one entry. */</span><span class="cp"></span>
<span class="cp">#define UVMF_FLUSHTYPE_MASK     (3UL&lt;&lt;0)</span>
<span class="cp">#define UVMF_MULTI              (0UL&lt;&lt;2) </span><span class="cm">/* Flush subset of TLBs. */</span><span class="cp"></span>
<span class="cp">#define UVMF_LOCAL              (0UL&lt;&lt;2) </span><span class="cm">/* Flush local TLB.      */</span><span class="cp"></span>
<span class="cp">#define UVMF_ALL                (1UL&lt;&lt;2) </span><span class="cm">/* Flush all TLBs.       */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Commands to HYPERVISOR_console_io().</span>
<span class="cm"> */</span>
<span class="cp">#define CONSOLEIO_write         0</span>
<span class="cp">#define CONSOLEIO_read          1</span>

<span class="cm">/*</span>
<span class="cm"> * Commands to HYPERVISOR_vm_assist().</span>
<span class="cm"> */</span>
<span class="cp">#define VMASST_CMD_enable                0</span>
<span class="cp">#define VMASST_CMD_disable               1</span>
<span class="cp">#define VMASST_TYPE_4gb_segments         0</span>
<span class="cp">#define VMASST_TYPE_4gb_segments_notify  1</span>
<span class="cp">#define VMASST_TYPE_writable_pagetables  2</span>
<span class="cp">#define VMASST_TYPE_pae_extended_cr3     3</span>
<span class="cp">#define MAX_VMASST_TYPE 3</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="k">typedef</span> <span class="kt">uint16_t</span> <span class="n">domid_t</span><span class="p">;</span>

<span class="cm">/* Domain ids &gt;= DOMID_FIRST_RESERVED cannot be used for ordinary domains. */</span>
<span class="cp">#define DOMID_FIRST_RESERVED (0x7FF0U)</span>

<span class="cm">/* DOMID_SELF is used in certain contexts to refer to oneself. */</span>
<span class="cp">#define DOMID_SELF (0x7FF0U)</span>

<span class="cm">/*</span>
<span class="cm"> * DOMID_IO is used to restrict page-table updates to mapping I/O memory.</span>
<span class="cm"> * Although no Foreign Domain need be specified to map I/O pages, DOMID_IO</span>
<span class="cm"> * is useful to ensure that no mappings to the OS&#39;s own heap are accidentally</span>
<span class="cm"> * installed. (e.g., in Linux this could cause havoc as reference counts</span>
<span class="cm"> * aren&#39;t adjusted on the I/O-mapping code path).</span>
<span class="cm"> * This only makes sense in MMUEXT_SET_FOREIGNDOM, but in that context can</span>
<span class="cm"> * be specified by any calling domain.</span>
<span class="cm"> */</span>
<span class="cp">#define DOMID_IO   (0x7FF1U)</span>

<span class="cm">/*</span>
<span class="cm"> * DOMID_XEN is used to allow privileged domains to map restricted parts of</span>
<span class="cm"> * Xen&#39;s heap space (e.g., the machine_to_phys table).</span>
<span class="cm"> * This only makes sense in MMUEXT_SET_FOREIGNDOM, and is only permitted if</span>
<span class="cm"> * the caller is privileged.</span>
<span class="cm"> */</span>
<span class="cp">#define DOMID_XEN  (0x7FF2U)</span>

<span class="cm">/*</span>
<span class="cm"> * Send an array of these to HYPERVISOR_mmu_update().</span>
<span class="cm"> * NB. The fields are natural pointer/address size for this architecture.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mmu_update</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">ptr</span><span class="p">;</span>       <span class="cm">/* Machine address of PTE. */</span>
    <span class="kt">uint64_t</span> <span class="n">val</span><span class="p">;</span>       <span class="cm">/* New contents of PTE.    */</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">mmu_update</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Send an array of these to HYPERVISOR_multicall().</span>
<span class="cm"> * NB. The fields are natural register size for this architecture.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">multicall_entry</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">op</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">result</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">args</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">multicall_entry</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Event channel endpoints per domain:</span>
<span class="cm"> *  1024 if a long is 32 bits; 4096 if a long is 64 bits.</span>
<span class="cm"> */</span>
<span class="cp">#define NR_EVENT_CHANNELS (sizeof(unsigned long) * sizeof(unsigned long) * 64)</span>

<span class="k">struct</span> <span class="n">vcpu_time_info</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Updates to the following values are preceded and followed</span>
<span class="cm">	 * by an increment of &#39;version&#39;. The guest can therefore</span>
<span class="cm">	 * detect updates by looking for changes to &#39;version&#39;. If the</span>
<span class="cm">	 * least-significant bit of the version number is set then an</span>
<span class="cm">	 * update is in progress and the guest must wait to read a</span>
<span class="cm">	 * consistent set of values.  The correct way to interact with</span>
<span class="cm">	 * the version number is similar to Linux&#39;s seqlock: see the</span>
<span class="cm">	 * implementations of read_seqbegin/read_seqretry.</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span> <span class="n">version</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pad0</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">tsc_timestamp</span><span class="p">;</span>   <span class="cm">/* TSC at last update of time vals.  */</span>
	<span class="kt">uint64_t</span> <span class="n">system_time</span><span class="p">;</span>     <span class="cm">/* Time, in nanosecs, since boot.    */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Current system time:</span>
<span class="cm">	 *   system_time + ((tsc - tsc_timestamp) &lt;&lt; tsc_shift) * tsc_to_system_mul</span>
<span class="cm">	 * CPU frequency (Hz):</span>
<span class="cm">	 *   ((10^9 &lt;&lt; 32) / tsc_to_system_mul) &gt;&gt; tsc_shift</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span> <span class="n">tsc_to_system_mul</span><span class="p">;</span>
	<span class="kt">int8_t</span>   <span class="n">tsc_shift</span><span class="p">;</span>
	<span class="kt">int8_t</span>   <span class="n">pad1</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span> <span class="cm">/* 32 bytes */</span>

<span class="k">struct</span> <span class="n">vcpu_info</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * &#39;evtchn_upcall_pending&#39; is written non-zero by Xen to indicate</span>
<span class="cm">	 * a pending notification for a particular VCPU. It is then cleared</span>
<span class="cm">	 * by the guest OS /before/ checking for pending work, thus avoiding</span>
<span class="cm">	 * a set-and-check race. Note that the mask is only accessed by Xen</span>
<span class="cm">	 * on the CPU that is currently hosting the VCPU. This means that the</span>
<span class="cm">	 * pending and mask flags can be updated by the guest without special</span>
<span class="cm">	 * synchronisation (i.e., no need for the x86 LOCK prefix).</span>
<span class="cm">	 * This may seem suboptimal because if the pending flag is set by</span>
<span class="cm">	 * a different CPU then an IPI may be scheduled even when the mask</span>
<span class="cm">	 * is set. However, note:</span>
<span class="cm">	 *  1. The task of &#39;interrupt holdoff&#39; is covered by the per-event-</span>
<span class="cm">	 *     channel mask bits. A &#39;noisy&#39; event that is continually being</span>
<span class="cm">	 *     triggered can be masked at source at this very precise</span>
<span class="cm">	 *     granularity.</span>
<span class="cm">	 *  2. The main purpose of the per-VCPU mask is therefore to restrict</span>
<span class="cm">	 *     reentrant execution: whether for concurrency control, or to</span>
<span class="cm">	 *     prevent unbounded stack usage. Whatever the purpose, we expect</span>
<span class="cm">	 *     that the mask will be asserted only for short periods at a time,</span>
<span class="cm">	 *     and so the likelihood of a &#39;spurious&#39; IPI is suitably small.</span>
<span class="cm">	 * The mask is read before making an event upcall to the guest: a</span>
<span class="cm">	 * non-zero mask therefore guarantees that the VCPU will not receive</span>
<span class="cm">	 * an upcall activation. The mask is cleared when the VCPU requests</span>
<span class="cm">	 * to block: this avoids wakeup-waiting races.</span>
<span class="cm">	 */</span>
	<span class="kt">uint8_t</span> <span class="n">evtchn_upcall_pending</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">evtchn_upcall_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">evtchn_pending_sel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">arch_vcpu_info</span> <span class="n">arch</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pvclock_vcpu_time_info</span> <span class="n">time</span><span class="p">;</span>
<span class="p">};</span> <span class="cm">/* 64 bytes (x86) */</span>

<span class="cm">/*</span>
<span class="cm"> * Xen/kernel shared data -- pointer provided in start_info.</span>
<span class="cm"> * NB. We expect that this struct is smaller than a page.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">shared_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_info</span> <span class="n">vcpu_info</span><span class="p">[</span><span class="n">MAX_VIRT_CPUS</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * A domain can create &quot;event channels&quot; on which it can send and receive</span>
<span class="cm">	 * asynchronous event notifications. There are three classes of event that</span>
<span class="cm">	 * are delivered by this mechanism:</span>
<span class="cm">	 *  1. Bi-directional inter- and intra-domain connections. Domains must</span>
<span class="cm">	 *     arrange out-of-band to set up a connection (usually by allocating</span>
<span class="cm">	 *     an unbound &#39;listener&#39; port and avertising that via a storage service</span>
<span class="cm">	 *     such as xenstore).</span>
<span class="cm">	 *  2. Physical interrupts. A domain with suitable hardware-access</span>
<span class="cm">	 *     privileges can bind an event-channel port to a physical interrupt</span>
<span class="cm">	 *     source.</span>
<span class="cm">	 *  3. Virtual interrupts (&#39;events&#39;). A domain can bind an event-channel</span>
<span class="cm">	 *     port to a virtual interrupt source, such as the virtual-timer</span>
<span class="cm">	 *     device or the emergency console.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Event channels are addressed by a &quot;port index&quot;. Each channel is</span>
<span class="cm">	 * associated with two bits of information:</span>
<span class="cm">	 *  1. PENDING -- notifies the domain that there is a pending notification</span>
<span class="cm">	 *     to be processed. This bit is cleared by the guest.</span>
<span class="cm">	 *  2. MASK -- if this bit is clear then a 0-&gt;1 transition of PENDING</span>
<span class="cm">	 *     will cause an asynchronous upcall to be scheduled. This bit is only</span>
<span class="cm">	 *     updated by the guest. It is read-only within Xen. If a channel</span>
<span class="cm">	 *     becomes pending while the channel is masked then the &#39;edge&#39; is lost</span>
<span class="cm">	 *     (i.e., when the channel is unmasked, the guest must manually handle</span>
<span class="cm">	 *     pending notifications as no upcall will be scheduled by Xen).</span>
<span class="cm">	 *</span>
<span class="cm">	 * To expedite scanning of pending notifications, any 0-&gt;1 pending</span>
<span class="cm">	 * transition on an unmasked channel causes a corresponding bit in a</span>
<span class="cm">	 * per-vcpu selector word to be set. Each bit in the selector covers a</span>
<span class="cm">	 * &#39;C long&#39; in the PENDING bitfield array.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">evtchn_pending</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">evtchn_mask</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wallclock time: updated only by control software. Guests should base</span>
<span class="cm">	 * their gettimeofday() syscall on this wallclock-base value.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">pvclock_wall_clock</span> <span class="n">wc</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">arch_shared_info</span> <span class="n">arch</span><span class="p">;</span>

<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Start-of-day memory layout for the initial domain (DOM0):</span>
<span class="cm"> *  1. The domain is started within contiguous virtual-memory region.</span>
<span class="cm"> *  2. The contiguous region begins and ends on an aligned 4MB boundary.</span>
<span class="cm"> *  3. The region start corresponds to the load address of the OS image.</span>
<span class="cm"> *     If the load address is not 4MB aligned then the address is rounded down.</span>
<span class="cm"> *  4. This the order of bootstrap elements in the initial virtual region:</span>
<span class="cm"> *      a. relocated kernel image</span>
<span class="cm"> *      b. initial ram disk              [mod_start, mod_len]</span>
<span class="cm"> *      c. list of allocated page frames [mfn_list, nr_pages]</span>
<span class="cm"> *      d. start_info_t structure        [register ESI (x86)]</span>
<span class="cm"> *      e. bootstrap page tables         [pt_base, CR3 (x86)]</span>
<span class="cm"> *      f. bootstrap stack               [register ESP (x86)]</span>
<span class="cm"> *  5. Bootstrap elements are packed together, but each is 4kB-aligned.</span>
<span class="cm"> *  6. The initial ram disk may be omitted.</span>
<span class="cm"> *  7. The list of page frames forms a contiguous &#39;pseudo-physical&#39; memory</span>
<span class="cm"> *     layout for the domain. In particular, the bootstrap virtual-memory</span>
<span class="cm"> *     region is a 1:1 mapping to the first section of the pseudo-physical map.</span>
<span class="cm"> *  8. All bootstrap elements are mapped read-writable for the guest OS. The</span>
<span class="cm"> *     only exception is the bootstrap page table, which is mapped read-only.</span>
<span class="cm"> *  9. There is guaranteed to be at least 512kB padding after the final</span>
<span class="cm"> *     bootstrap element. If necessary, the bootstrap virtual region is</span>
<span class="cm"> *     extended by an extra 4MB to ensure this.</span>
<span class="cm"> */</span>

<span class="cp">#define MAX_GUEST_CMDLINE 1024</span>
<span class="k">struct</span> <span class="n">start_info</span> <span class="p">{</span>
	<span class="cm">/* THE FOLLOWING ARE FILLED IN BOTH ON INITIAL BOOT AND ON RESUME.    */</span>
	<span class="kt">char</span> <span class="n">magic</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>             <span class="cm">/* &quot;xen-&lt;version&gt;-&lt;platform&gt;&quot;.            */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">;</span>     <span class="cm">/* Total pages allocated to this domain.  */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shared_info</span><span class="p">;</span>  <span class="cm">/* MACHINE address of shared info struct. */</span>
	<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>             <span class="cm">/* SIF_xxx flags.                         */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">store_mfn</span><span class="p">;</span>    <span class="cm">/* MACHINE page number of shared page.    */</span>
	<span class="kt">uint32_t</span> <span class="n">store_evtchn</span><span class="p">;</span>      <span class="cm">/* Event channel for store communication. */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">;</span>  <span class="cm">/* MACHINE page number of console page.   */</span>
			<span class="kt">uint32_t</span>  <span class="n">evtchn</span><span class="p">;</span>   <span class="cm">/* Event channel for console page.        */</span>
		<span class="p">}</span> <span class="n">domU</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="n">info_off</span><span class="p">;</span>  <span class="cm">/* Offset of console_info struct.         */</span>
			<span class="kt">uint32_t</span> <span class="n">info_size</span><span class="p">;</span> <span class="cm">/* Size of console_info struct from start.*/</span>
		<span class="p">}</span> <span class="n">dom0</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">console</span><span class="p">;</span>
	<span class="cm">/* THE FOLLOWING ARE ONLY FILLED IN ON INITIAL BOOT (NOT RESUME).     */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pt_base</span><span class="p">;</span>      <span class="cm">/* VIRTUAL address of page directory.     */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pt_frames</span><span class="p">;</span> <span class="cm">/* Number of bootstrap p.t. frames.       */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn_list</span><span class="p">;</span>     <span class="cm">/* VIRTUAL address of page-frame list.    */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mod_start</span><span class="p">;</span>    <span class="cm">/* VIRTUAL address of pre-loaded module.  */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mod_len</span><span class="p">;</span>      <span class="cm">/* Size (bytes) of pre-loaded module.     */</span>
	<span class="kt">int8_t</span> <span class="n">cmd_line</span><span class="p">[</span><span class="n">MAX_GUEST_CMDLINE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dom0_vga_console_info</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">video_type</span><span class="p">;</span>
<span class="cp">#define XEN_VGATYPE_TEXT_MODE_3 0x03</span>
<span class="cp">#define XEN_VGATYPE_VESA_LFB    0x23</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="cm">/* Font height, in pixels. */</span>
			<span class="kt">uint16_t</span> <span class="n">font_height</span><span class="p">;</span>
			<span class="cm">/* Cursor location (column, row). */</span>
			<span class="kt">uint16_t</span> <span class="n">cursor_x</span><span class="p">,</span> <span class="n">cursor_y</span><span class="p">;</span>
			<span class="cm">/* Number of rows and columns (dimensions in characters). */</span>
			<span class="kt">uint16_t</span> <span class="n">rows</span><span class="p">,</span> <span class="n">columns</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">text_mode_3</span><span class="p">;</span>

		<span class="k">struct</span> <span class="p">{</span>
			<span class="cm">/* Width and height, in pixels. */</span>
			<span class="kt">uint16_t</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>
			<span class="cm">/* Bytes per scan line. */</span>
			<span class="kt">uint16_t</span> <span class="n">bytes_per_line</span><span class="p">;</span>
			<span class="cm">/* Bits per pixel. */</span>
			<span class="kt">uint16_t</span> <span class="n">bits_per_pixel</span><span class="p">;</span>
			<span class="cm">/* LFB physical address, and size (in units of 64kB). */</span>
			<span class="kt">uint32_t</span> <span class="n">lfb_base</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">lfb_size</span><span class="p">;</span>
			<span class="cm">/* RGB mask offsets and sizes, as defined by VBE 1.2+ */</span>
			<span class="kt">uint8_t</span>  <span class="n">red_pos</span><span class="p">,</span> <span class="n">red_size</span><span class="p">;</span>
			<span class="kt">uint8_t</span>  <span class="n">green_pos</span><span class="p">,</span> <span class="n">green_size</span><span class="p">;</span>
			<span class="kt">uint8_t</span>  <span class="n">blue_pos</span><span class="p">,</span> <span class="n">blue_size</span><span class="p">;</span>
			<span class="kt">uint8_t</span>  <span class="n">rsvd_pos</span><span class="p">,</span> <span class="n">rsvd_size</span><span class="p">;</span>

			<span class="cm">/* VESA capabilities (offset 0xa, VESA command 0x4f00). */</span>
			<span class="kt">uint32_t</span> <span class="n">gbl_caps</span><span class="p">;</span>
			<span class="cm">/* Mode attributes (offset 0x0, VESA command 0x4f01). */</span>
			<span class="kt">uint16_t</span> <span class="n">mode_attrs</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">vesa_lfb</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* These flags are passed in the &#39;flags&#39; field of start_info_t. */</span>
<span class="cp">#define SIF_PRIVILEGED    (1&lt;&lt;0)  </span><span class="cm">/* Is the domain privileged? */</span><span class="cp"></span>
<span class="cp">#define SIF_INITDOMAIN    (1&lt;&lt;1)  </span><span class="cm">/* Is this the initial control domain? */</span><span class="cp"></span>
<span class="cp">#define SIF_PM_MASK       (0xFF&lt;&lt;8) </span><span class="cm">/* reserve 1 byte for xen-pm options */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="kt">uint64_t</span> <span class="n">cpumap_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">uint8_t</span> <span class="n">xen_domain_handle_t</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="cm">/* Turn a plain number into a C unsigned long constant. */</span>
<span class="cp">#define __mk_unsigned_long(x) x ## UL</span>
<span class="cp">#define mk_unsigned_long(x) __mk_unsigned_long(x)</span>

<span class="cp">#define TMEM_SPEC_VERSION 1</span>

<span class="k">struct</span> <span class="n">tmem_op</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">pool_id</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>  <span class="cm">/* for cmd == TMEM_NEW_POOL */</span>
			<span class="kt">uint64_t</span> <span class="n">uuid</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
			<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">new</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint64_t</span> <span class="n">oid</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
			<span class="kt">uint32_t</span> <span class="n">index</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">tmem_offset</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">pfn_offset</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">GUEST_HANDLE</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">gmfn</span><span class="p">;</span> <span class="cm">/* guest machine page frame */</span>
		<span class="p">}</span> <span class="n">gen</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">DEFINE_GUEST_HANDLE</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cm">/* In assembly code we cannot use C numeric constant suffixes. */</span>
<span class="cp">#define mk_unsigned_long(x) x</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __XEN_PUBLIC_XEN_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
