<!DOCTYPE html>
<html><head><title>joekychen/linux » include › xen › interface › grant_table.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>grant_table.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> * grant_table.h</span>
<span class="cm"> *</span>
<span class="cm"> * Interface for granting foreign access to page frames, and receiving</span>
<span class="cm"> * page-ownership transfers.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="cm"> * of this software and associated documentation files (the &quot;Software&quot;), to</span>
<span class="cm"> * deal in the Software without restriction, including without limitation the</span>
<span class="cm"> * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or</span>
<span class="cm"> * sell copies of the Software, and to permit persons to whom the Software is</span>
<span class="cm"> * furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be included in</span>
<span class="cm"> * all copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="cm"> * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="cm"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="cm"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span>
<span class="cm"> * DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2004, K A Fraser</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __XEN_PUBLIC_GRANT_TABLE_H__</span>
<span class="cp">#define __XEN_PUBLIC_GRANT_TABLE_H__</span>

<span class="cp">#include &lt;xen/interface/xen.h&gt;</span>

<span class="cm">/***********************************</span>
<span class="cm"> * GRANT TABLE REPRESENTATION</span>
<span class="cm"> */</span>

<span class="cm">/* Some rough guidelines on accessing and updating grant-table entries</span>
<span class="cm"> * in a concurrency-safe manner. For more information, Linux contains a</span>
<span class="cm"> * reference implementation for guest OSes (arch/xen/kernel/grant_table.c).</span>
<span class="cm"> *</span>
<span class="cm"> * NB. WMB is a no-op on current-generation x86 processors. However, a</span>
<span class="cm"> *     compiler barrier will still be required.</span>
<span class="cm"> *</span>
<span class="cm"> * Introducing a valid entry into the grant table:</span>
<span class="cm"> *  1. Write ent-&gt;domid.</span>
<span class="cm"> *  2. Write ent-&gt;frame:</span>
<span class="cm"> *      GTF_permit_access:   Frame to which access is permitted.</span>
<span class="cm"> *      GTF_accept_transfer: Pseudo-phys frame slot being filled by new</span>
<span class="cm"> *                           frame, or zero if none.</span>
<span class="cm"> *  3. Write memory barrier (WMB).</span>
<span class="cm"> *  4. Write ent-&gt;flags, inc. valid type.</span>
<span class="cm"> *</span>
<span class="cm"> * Invalidating an unused GTF_permit_access entry:</span>
<span class="cm"> *  1. flags = ent-&gt;flags.</span>
<span class="cm"> *  2. Observe that !(flags &amp; (GTF_reading|GTF_writing)).</span>
<span class="cm"> *  3. Check result of SMP-safe CMPXCHG(&amp;ent-&gt;flags, flags, 0).</span>
<span class="cm"> *  NB. No need for WMB as reuse of entry is control-dependent on success of</span>
<span class="cm"> *      step 3, and all architectures guarantee ordering of ctrl-dep writes.</span>
<span class="cm"> *</span>
<span class="cm"> * Invalidating an in-use GTF_permit_access entry:</span>
<span class="cm"> *  This cannot be done directly. Request assistance from the domain controller</span>
<span class="cm"> *  which can set a timeout on the use of a grant entry and take necessary</span>
<span class="cm"> *  action. (NB. This is not yet implemented!).</span>
<span class="cm"> *</span>
<span class="cm"> * Invalidating an unused GTF_accept_transfer entry:</span>
<span class="cm"> *  1. flags = ent-&gt;flags.</span>
<span class="cm"> *  2. Observe that !(flags &amp; GTF_transfer_committed). [*]</span>
<span class="cm"> *  3. Check result of SMP-safe CMPXCHG(&amp;ent-&gt;flags, flags, 0).</span>
<span class="cm"> *  NB. No need for WMB as reuse of entry is control-dependent on success of</span>
<span class="cm"> *      step 3, and all architectures guarantee ordering of ctrl-dep writes.</span>
<span class="cm"> *  [*] If GTF_transfer_committed is set then the grant entry is &#39;committed&#39;.</span>
<span class="cm"> *      The guest must /not/ modify the grant entry until the address of the</span>
<span class="cm"> *      transferred frame is written. It is safe for the guest to spin waiting</span>
<span class="cm"> *      for this to occur (detect by observing GTF_transfer_completed in</span>
<span class="cm"> *      ent-&gt;flags).</span>
<span class="cm"> *</span>
<span class="cm"> * Invalidating a committed GTF_accept_transfer entry:</span>
<span class="cm"> *  1. Wait for (ent-&gt;flags &amp; GTF_transfer_completed).</span>
<span class="cm"> *</span>
<span class="cm"> * Changing a GTF_permit_access from writable to read-only:</span>
<span class="cm"> *  Use SMP-safe CMPXCHG to set GTF_readonly, while checking !GTF_writing.</span>
<span class="cm"> *</span>
<span class="cm"> * Changing a GTF_permit_access from read-only to writable:</span>
<span class="cm"> *  Use SMP-safe bit-setting instruction.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Reference to a grant entry in a specified domain&#39;s grant table.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">grant_ref_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * A grant table comprises a packed array of grant entries in one or more</span>
<span class="cm"> * page frames shared between Xen and a guest.</span>
<span class="cm"> * [XEN]: This field is written by Xen and read by the sharing guest.</span>
<span class="cm"> * [GST]: This field is written by the guest and read by Xen.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Version 1 of the grant table entry structure is maintained purely</span>
<span class="cm"> * for backwards compatibility.  New guests should use version 2.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">grant_entry_v1</span> <span class="p">{</span>
    <span class="cm">/* GTF_xxx: various type and flag information.  [XEN,GST] */</span>
    <span class="kt">uint16_t</span> <span class="n">flags</span><span class="p">;</span>
    <span class="cm">/* The domain being granted foreign privileges. [GST] */</span>
    <span class="n">domid_t</span>  <span class="n">domid</span><span class="p">;</span>
    <span class="cm">/*</span>
<span class="cm">     * GTF_permit_access: Frame that @domid is allowed to map and access. [GST]</span>
<span class="cm">     * GTF_accept_transfer: Frame whose ownership transferred by @domid. [XEN]</span>
<span class="cm">     */</span>
    <span class="kt">uint32_t</span> <span class="n">frame</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Type of grant entry.</span>
<span class="cm"> *  GTF_invalid: This grant entry grants no privileges.</span>
<span class="cm"> *  GTF_permit_access: Allow @domid to map/access @frame.</span>
<span class="cm"> *  GTF_accept_transfer: Allow @domid to transfer ownership of one page frame</span>
<span class="cm"> *                       to this guest. Xen writes the page number to @frame.</span>
<span class="cm"> *  GTF_transitive: Allow @domid to transitively access a subrange of</span>
<span class="cm"> *                  @trans_grant in @trans_domid.  No mappings are allowed.</span>
<span class="cm"> */</span>
<span class="cp">#define GTF_invalid         (0U&lt;&lt;0)</span>
<span class="cp">#define GTF_permit_access   (1U&lt;&lt;0)</span>
<span class="cp">#define GTF_accept_transfer (2U&lt;&lt;0)</span>
<span class="cp">#define GTF_transitive      (3U&lt;&lt;0)</span>
<span class="cp">#define GTF_type_mask       (3U&lt;&lt;0)</span>

<span class="cm">/*</span>
<span class="cm"> * Subflags for GTF_permit_access.</span>
<span class="cm"> *  GTF_readonly: Restrict @domid to read-only mappings and accesses. [GST]</span>
<span class="cm"> *  GTF_reading: Grant entry is currently mapped for reading by @domid. [XEN]</span>
<span class="cm"> *  GTF_writing: Grant entry is currently mapped for writing by @domid. [XEN]</span>
<span class="cm"> *  GTF_sub_page: Grant access to only a subrange of the page.  @domid</span>
<span class="cm"> *                will only be allowed to copy from the grant, and not</span>
<span class="cm"> *                map it. [GST]</span>
<span class="cm"> */</span>
<span class="cp">#define _GTF_readonly       (2)</span>
<span class="cp">#define GTF_readonly        (1U&lt;&lt;_GTF_readonly)</span>
<span class="cp">#define _GTF_reading        (3)</span>
<span class="cp">#define GTF_reading         (1U&lt;&lt;_GTF_reading)</span>
<span class="cp">#define _GTF_writing        (4)</span>
<span class="cp">#define GTF_writing         (1U&lt;&lt;_GTF_writing)</span>
<span class="cp">#define _GTF_sub_page       (8)</span>
<span class="cp">#define GTF_sub_page        (1U&lt;&lt;_GTF_sub_page)</span>

<span class="cm">/*</span>
<span class="cm"> * Subflags for GTF_accept_transfer:</span>
<span class="cm"> *  GTF_transfer_committed: Xen sets this flag to indicate that it is committed</span>
<span class="cm"> *      to transferring ownership of a page frame. When a guest sees this flag</span>
<span class="cm"> *      it must /not/ modify the grant entry until GTF_transfer_completed is</span>
<span class="cm"> *      set by Xen.</span>
<span class="cm"> *  GTF_transfer_completed: It is safe for the guest to spin-wait on this flag</span>
<span class="cm"> *      after reading GTF_transfer_committed. Xen will always write the frame</span>
<span class="cm"> *      address, followed by ORing this flag, in a timely manner.</span>
<span class="cm"> */</span>
<span class="cp">#define _GTF_transfer_committed (2)</span>
<span class="cp">#define GTF_transfer_committed  (1U&lt;&lt;_GTF_transfer_committed)</span>
<span class="cp">#define _GTF_transfer_completed (3)</span>
<span class="cp">#define GTF_transfer_completed  (1U&lt;&lt;_GTF_transfer_completed)</span>

<span class="cm">/*</span>
<span class="cm"> * Version 2 grant table entries.  These fulfil the same role as</span>
<span class="cm"> * version 1 entries, but can represent more complicated operations.</span>
<span class="cm"> * Any given domain will have either a version 1 or a version 2 table,</span>
<span class="cm"> * and every entry in the table will be the same version.</span>
<span class="cm"> *</span>
<span class="cm"> * The interface by which domains use grant references does not depend</span>
<span class="cm"> * on the grant table version in use by the other domain.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Version 1 and version 2 grant entries share a common prefix.  The</span>
<span class="cm"> * fields of the prefix are documented as part of struct</span>
<span class="cm"> * grant_entry_v1.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">grant_entry_header</span> <span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">domid_t</span>  <span class="n">domid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Version 2 of the grant entry structure, here is an union because three</span>
<span class="cm"> * different types are suppotted: full_page, sub_page and transitive.</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">grant_entry_v2</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">grant_entry_header</span> <span class="n">hdr</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * This member is used for V1-style full page grants, where either:</span>
<span class="cm">     *</span>
<span class="cm">     * -- hdr.type is GTF_accept_transfer, or</span>
<span class="cm">     * -- hdr.type is GTF_permit_access and GTF_sub_page is not set.</span>
<span class="cm">     *</span>
<span class="cm">     * In that case, the frame field has the same semantics as the</span>
<span class="cm">     * field of the same name in the V1 entry structure.</span>
<span class="cm">     */</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">grant_entry_header</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pad0</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">frame</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">full_page</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * If the grant type is GTF_grant_access and GTF_sub_page is set,</span>
<span class="cm">     * @domid is allowed to access bytes [@page_off,@page_off+@length)</span>
<span class="cm">     * in frame @frame.</span>
<span class="cm">     */</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">grant_entry_header</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">page_off</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">frame</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">sub_page</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * If the grant is GTF_transitive, @domid is allowed to use the</span>
<span class="cm">     * grant @gref in domain @trans_domid, as if it was the local</span>
<span class="cm">     * domain.  Obviously, the transitive access must be compatible</span>
<span class="cm">     * with the original grant.</span>
<span class="cm">     */</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">grant_entry_header</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">domid_t</span> <span class="n">trans_domid</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">pad0</span><span class="p">;</span>
	<span class="n">grant_ref_t</span> <span class="n">gref</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">transitive</span><span class="p">;</span>

    <span class="kt">uint32_t</span> <span class="n">__spacer</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="cm">/* Pad to a power of two */</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">uint16_t</span> <span class="n">grant_status_t</span><span class="p">;</span>

<span class="cm">/***********************************</span>
<span class="cm"> * GRANT TABLE QUERIES AND USES</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Handle to track a mapping created via a grant reference.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">grant_handle_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * GNTTABOP_map_grant_ref: Map the grant entry (&lt;dom&gt;,&lt;ref&gt;) for access</span>
<span class="cm"> * by devices and/or host CPUs. If successful, &lt;handle&gt; is a tracking number</span>
<span class="cm"> * that must be presented later to destroy the mapping(s). On error, &lt;handle&gt;</span>
<span class="cm"> * is a negative status code.</span>
<span class="cm"> * NOTES:</span>
<span class="cm"> *  1. If GNTMAP_device_map is specified then &lt;dev_bus_addr&gt; is the address</span>
<span class="cm"> *     via which I/O devices may access the granted frame.</span>
<span class="cm"> *  2. If GNTMAP_host_map is specified then a mapping will be added at</span>
<span class="cm"> *     either a host virtual address in the current address space, or at</span>
<span class="cm"> *     a PTE at the specified machine address.  The type of mapping to</span>
<span class="cm"> *     perform is selected through the GNTMAP_contains_pte flag, and the</span>
<span class="cm"> *     address is specified in &lt;host_addr&gt;.</span>
<span class="cm"> *  3. Mappings should only be destroyed via GNTTABOP_unmap_grant_ref. If a</span>
<span class="cm"> *     host mapping is destroyed by other means then it is *NOT* guaranteed</span>
<span class="cm"> *     to be accounted to the correct grant reference!</span>
<span class="cm"> */</span>
<span class="cp">#define GNTTABOP_map_grant_ref        0</span>
<span class="k">struct</span> <span class="n">gnttab_map_grant_ref</span> <span class="p">{</span>
    <span class="cm">/* IN parameters. */</span>
    <span class="kt">uint64_t</span> <span class="n">host_addr</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>               <span class="cm">/* GNTMAP_* */</span>
    <span class="n">grant_ref_t</span> <span class="n">ref</span><span class="p">;</span>
    <span class="n">domid_t</span>  <span class="n">dom</span><span class="p">;</span>
    <span class="cm">/* OUT parameters. */</span>
    <span class="kt">int16_t</span>  <span class="n">status</span><span class="p">;</span>              <span class="cm">/* GNTST_* */</span>
    <span class="n">grant_handle_t</span> <span class="n">handle</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">dev_bus_addr</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">gnttab_map_grant_ref</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * GNTTABOP_unmap_grant_ref: Destroy one or more grant-reference mappings</span>
<span class="cm"> * tracked by &lt;handle&gt;. If &lt;host_addr&gt; or &lt;dev_bus_addr&gt; is zero, that</span>
<span class="cm"> * field is ignored. If non-zero, they must refer to a device/host mapping</span>
<span class="cm"> * that is tracked by &lt;handle&gt;</span>
<span class="cm"> * NOTES:</span>
<span class="cm"> *  1. The call may fail in an undefined manner if either mapping is not</span>
<span class="cm"> *     tracked by &lt;handle&gt;.</span>
<span class="cm"> *  3. After executing a batch of unmaps, it is guaranteed that no stale</span>
<span class="cm"> *     mappings will remain in the device or host TLBs.</span>
<span class="cm"> */</span>
<span class="cp">#define GNTTABOP_unmap_grant_ref      1</span>
<span class="k">struct</span> <span class="n">gnttab_unmap_grant_ref</span> <span class="p">{</span>
    <span class="cm">/* IN parameters. */</span>
    <span class="kt">uint64_t</span> <span class="n">host_addr</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">dev_bus_addr</span><span class="p">;</span>
    <span class="n">grant_handle_t</span> <span class="n">handle</span><span class="p">;</span>
    <span class="cm">/* OUT parameters. */</span>
    <span class="kt">int16_t</span>  <span class="n">status</span><span class="p">;</span>              <span class="cm">/* GNTST_* */</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">gnttab_unmap_grant_ref</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * GNTTABOP_setup_table: Set up a grant table for &lt;dom&gt; comprising at least</span>
<span class="cm"> * &lt;nr_frames&gt; pages. The frame addresses are written to the &lt;frame_list&gt;.</span>
<span class="cm"> * Only &lt;nr_frames&gt; addresses are written, even if the table is larger.</span>
<span class="cm"> * NOTES:</span>
<span class="cm"> *  1. &lt;dom&gt; may be specified as DOMID_SELF.</span>
<span class="cm"> *  2. Only a sufficiently-privileged domain may specify &lt;dom&gt; != DOMID_SELF.</span>
<span class="cm"> *  3. Xen may not support more than a single grant-table page per domain.</span>
<span class="cm"> */</span>
<span class="cp">#define GNTTABOP_setup_table          2</span>
<span class="k">struct</span> <span class="n">gnttab_setup_table</span> <span class="p">{</span>
    <span class="cm">/* IN parameters. */</span>
    <span class="n">domid_t</span>  <span class="n">dom</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">nr_frames</span><span class="p">;</span>
    <span class="cm">/* OUT parameters. */</span>
    <span class="kt">int16_t</span>  <span class="n">status</span><span class="p">;</span>              <span class="cm">/* GNTST_* */</span>
    <span class="n">GUEST_HANDLE</span><span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">frame_list</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">gnttab_setup_table</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * GNTTABOP_dump_table: Dump the contents of the grant table to the</span>
<span class="cm"> * xen console. Debugging use only.</span>
<span class="cm"> */</span>
<span class="cp">#define GNTTABOP_dump_table           3</span>
<span class="k">struct</span> <span class="n">gnttab_dump_table</span> <span class="p">{</span>
    <span class="cm">/* IN parameters. */</span>
    <span class="n">domid_t</span> <span class="n">dom</span><span class="p">;</span>
    <span class="cm">/* OUT parameters. */</span>
    <span class="kt">int16_t</span> <span class="n">status</span><span class="p">;</span>               <span class="cm">/* GNTST_* */</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">gnttab_dump_table</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * GNTTABOP_transfer_grant_ref: Transfer &lt;frame&gt; to a foreign domain. The</span>
<span class="cm"> * foreign domain has previously registered its interest in the transfer via</span>
<span class="cm"> * &lt;domid, ref&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, even if the transfer fails, the specified page no longer belongs</span>
<span class="cm"> * to the calling domain *unless* the error is GNTST_bad_page.</span>
<span class="cm"> */</span>
<span class="cp">#define GNTTABOP_transfer                4</span>
<span class="k">struct</span> <span class="n">gnttab_transfer</span> <span class="p">{</span>
    <span class="cm">/* IN parameters. */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">;</span>
    <span class="n">domid_t</span>       <span class="n">domid</span><span class="p">;</span>
    <span class="n">grant_ref_t</span>   <span class="n">ref</span><span class="p">;</span>
    <span class="cm">/* OUT parameters. */</span>
    <span class="kt">int16_t</span>       <span class="n">status</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">gnttab_transfer</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * GNTTABOP_copy: Hypervisor based copy</span>
<span class="cm"> * source and destinations can be eithers MFNs or, for foreign domains,</span>
<span class="cm"> * grant references. the foreign domain has to grant read/write access</span>
<span class="cm"> * in its grant table.</span>
<span class="cm"> *</span>
<span class="cm"> * The flags specify what type source and destinations are (either MFN</span>
<span class="cm"> * or grant reference).</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this can also be used to copy data between two domains</span>
<span class="cm"> * via a third party if the source and destination domains had previously</span>
<span class="cm"> * grant appropriate access to their pages to the third party.</span>
<span class="cm"> *</span>
<span class="cm"> * source_offset specifies an offset in the source frame, dest_offset</span>
<span class="cm"> * the offset in the target frame and  len specifies the number of</span>
<span class="cm"> * bytes to be copied.</span>
<span class="cm"> */</span>

<span class="cp">#define _GNTCOPY_source_gref      (0)</span>
<span class="cp">#define GNTCOPY_source_gref       (1&lt;&lt;_GNTCOPY_source_gref)</span>
<span class="cp">#define _GNTCOPY_dest_gref        (1)</span>
<span class="cp">#define GNTCOPY_dest_gref         (1&lt;&lt;_GNTCOPY_dest_gref)</span>

<span class="cp">#define GNTTABOP_copy                 5</span>
<span class="k">struct</span> <span class="n">gnttab_copy</span> <span class="p">{</span>
	<span class="cm">/* IN parameters. */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">union</span> <span class="p">{</span>
			<span class="n">grant_ref_t</span> <span class="n">ref</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">gmfn</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
		<span class="n">domid_t</span>  <span class="n">domid</span><span class="p">;</span>
		<span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">;</span>
	<span class="kt">uint16_t</span>      <span class="n">len</span><span class="p">;</span>
	<span class="kt">uint16_t</span>      <span class="n">flags</span><span class="p">;</span>          <span class="cm">/* GNTCOPY_* */</span>
	<span class="cm">/* OUT parameters. */</span>
	<span class="kt">int16_t</span>       <span class="n">status</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">gnttab_copy</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * GNTTABOP_query_size: Query the current and maximum sizes of the shared</span>
<span class="cm"> * grant table.</span>
<span class="cm"> * NOTES:</span>
<span class="cm"> *  1. &lt;dom&gt; may be specified as DOMID_SELF.</span>
<span class="cm"> *  2. Only a sufficiently-privileged domain may specify &lt;dom&gt; != DOMID_SELF.</span>
<span class="cm"> */</span>
<span class="cp">#define GNTTABOP_query_size           6</span>
<span class="k">struct</span> <span class="n">gnttab_query_size</span> <span class="p">{</span>
    <span class="cm">/* IN parameters. */</span>
    <span class="n">domid_t</span>  <span class="n">dom</span><span class="p">;</span>
    <span class="cm">/* OUT parameters. */</span>
    <span class="kt">uint32_t</span> <span class="n">nr_frames</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">max_nr_frames</span><span class="p">;</span>
    <span class="kt">int16_t</span>  <span class="n">status</span><span class="p">;</span>              <span class="cm">/* GNTST_* */</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">gnttab_query_size</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * GNTTABOP_unmap_and_replace: Destroy one or more grant-reference mappings</span>
<span class="cm"> * tracked by &lt;handle&gt; but atomically replace the page table entry with one</span>
<span class="cm"> * pointing to the machine address under &lt;new_addr&gt;.  &lt;new_addr&gt; will be</span>
<span class="cm"> * redirected to the null entry.</span>
<span class="cm"> * NOTES:</span>
<span class="cm"> *  1. The call may fail in an undefined manner if either mapping is not</span>
<span class="cm"> *     tracked by &lt;handle&gt;.</span>
<span class="cm"> *  2. After executing a batch of unmaps, it is guaranteed that no stale</span>
<span class="cm"> *     mappings will remain in the device or host TLBs.</span>
<span class="cm"> */</span>
<span class="cp">#define GNTTABOP_unmap_and_replace    7</span>
<span class="k">struct</span> <span class="n">gnttab_unmap_and_replace</span> <span class="p">{</span>
    <span class="cm">/* IN parameters. */</span>
    <span class="kt">uint64_t</span> <span class="n">host_addr</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">new_addr</span><span class="p">;</span>
    <span class="n">grant_handle_t</span> <span class="n">handle</span><span class="p">;</span>
    <span class="cm">/* OUT parameters. */</span>
    <span class="kt">int16_t</span>  <span class="n">status</span><span class="p">;</span>              <span class="cm">/* GNTST_* */</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">gnttab_unmap_and_replace</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * GNTTABOP_set_version: Request a particular version of the grant</span>
<span class="cm"> * table shared table structure.  This operation can only be performed</span>
<span class="cm"> * once in any given domain.  It must be performed before any grants</span>
<span class="cm"> * are activated; otherwise, the domain will be stuck with version 1.</span>
<span class="cm"> * The only defined versions are 1 and 2.</span>
<span class="cm"> */</span>
<span class="cp">#define GNTTABOP_set_version          8</span>
<span class="k">struct</span> <span class="n">gnttab_set_version</span> <span class="p">{</span>
    <span class="cm">/* IN parameters */</span>
    <span class="kt">uint32_t</span> <span class="n">version</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">gnttab_set_version</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * GNTTABOP_get_status_frames: Get the list of frames used to store grant</span>
<span class="cm"> * status for &lt;dom&gt;. In grant format version 2, the status is separated</span>
<span class="cm"> * from the other shared grant fields to allow more efficient synchronization</span>
<span class="cm"> * using barriers instead of atomic cmpexch operations.</span>
<span class="cm"> * &lt;nr_frames&gt; specify the size of vector &lt;frame_list&gt;.</span>
<span class="cm"> * The frame addresses are returned in the &lt;frame_list&gt;.</span>
<span class="cm"> * Only &lt;nr_frames&gt; addresses are returned, even if the table is larger.</span>
<span class="cm"> * NOTES:</span>
<span class="cm"> *  1. &lt;dom&gt; may be specified as DOMID_SELF.</span>
<span class="cm"> *  2. Only a sufficiently-privileged domain may specify &lt;dom&gt; != DOMID_SELF.</span>
<span class="cm"> */</span>
<span class="cp">#define GNTTABOP_get_status_frames     9</span>
<span class="k">struct</span> <span class="n">gnttab_get_status_frames</span> <span class="p">{</span>
    <span class="cm">/* IN parameters. */</span>
    <span class="kt">uint32_t</span> <span class="n">nr_frames</span><span class="p">;</span>
    <span class="n">domid_t</span>  <span class="n">dom</span><span class="p">;</span>
    <span class="cm">/* OUT parameters. */</span>
    <span class="kt">int16_t</span>  <span class="n">status</span><span class="p">;</span>              <span class="cm">/* GNTST_* */</span>
    <span class="n">GUEST_HANDLE</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">frame_list</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">gnttab_get_status_frames</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * GNTTABOP_get_version: Get the grant table version which is in</span>
<span class="cm"> * effect for domain &lt;dom&gt;.</span>
<span class="cm"> */</span>
<span class="cp">#define GNTTABOP_get_version          10</span>
<span class="k">struct</span> <span class="n">gnttab_get_version</span> <span class="p">{</span>
    <span class="cm">/* IN parameters */</span>
    <span class="n">domid_t</span> <span class="n">dom</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">pad</span><span class="p">;</span>
    <span class="cm">/* OUT parameters */</span>
    <span class="kt">uint32_t</span> <span class="n">version</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">gnttab_get_version</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Bitfield values for update_pin_status.flags.</span>
<span class="cm"> */</span>
 <span class="cm">/* Map the grant entry for access by I/O devices. */</span>
<span class="cp">#define _GNTMAP_device_map      (0)</span>
<span class="cp">#define GNTMAP_device_map       (1&lt;&lt;_GNTMAP_device_map)</span>
 <span class="cm">/* Map the grant entry for access by host CPUs. */</span>
<span class="cp">#define _GNTMAP_host_map        (1)</span>
<span class="cp">#define GNTMAP_host_map         (1&lt;&lt;_GNTMAP_host_map)</span>
 <span class="cm">/* Accesses to the granted frame will be restricted to read-only access. */</span>
<span class="cp">#define _GNTMAP_readonly        (2)</span>
<span class="cp">#define GNTMAP_readonly         (1&lt;&lt;_GNTMAP_readonly)</span>
 <span class="cm">/*</span>
<span class="cm">  * GNTMAP_host_map subflag:</span>
<span class="cm">  *  0 =&gt; The host mapping is usable only by the guest OS.</span>
<span class="cm">  *  1 =&gt; The host mapping is usable by guest OS + current application.</span>
<span class="cm">  */</span>
<span class="cp">#define _GNTMAP_application_map (3)</span>
<span class="cp">#define GNTMAP_application_map  (1&lt;&lt;_GNTMAP_application_map)</span>

 <span class="cm">/*</span>
<span class="cm">  * GNTMAP_contains_pte subflag:</span>
<span class="cm">  *  0 =&gt; This map request contains a host virtual address.</span>
<span class="cm">  *  1 =&gt; This map request contains the machine addess of the PTE to update.</span>
<span class="cm">  */</span>
<span class="cp">#define _GNTMAP_contains_pte    (4)</span>
<span class="cp">#define GNTMAP_contains_pte     (1&lt;&lt;_GNTMAP_contains_pte)</span>

<span class="cm">/*</span>
<span class="cm"> * Values for error status returns. All errors are -ve.</span>
<span class="cm"> */</span>
<span class="cp">#define GNTST_okay             (0)  </span><span class="cm">/* Normal return.                        */</span><span class="cp"></span>
<span class="cp">#define GNTST_general_error    (-1) </span><span class="cm">/* General undefined error.              */</span><span class="cp"></span>
<span class="cp">#define GNTST_bad_domain       (-2) </span><span class="cm">/* Unrecognsed domain id.                */</span><span class="cp"></span>
<span class="cp">#define GNTST_bad_gntref       (-3) </span><span class="cm">/* Unrecognised or inappropriate gntref. */</span><span class="cp"></span>
<span class="cp">#define GNTST_bad_handle       (-4) </span><span class="cm">/* Unrecognised or inappropriate handle. */</span><span class="cp"></span>
<span class="cp">#define GNTST_bad_virt_addr    (-5) </span><span class="cm">/* Inappropriate virtual address to map. */</span><span class="cp"></span>
<span class="cp">#define GNTST_bad_dev_addr     (-6) </span><span class="cm">/* Inappropriate device address to unmap.*/</span><span class="cp"></span>
<span class="cp">#define GNTST_no_device_space  (-7) </span><span class="cm">/* Out of space in I/O MMU.              */</span><span class="cp"></span>
<span class="cp">#define GNTST_permission_denied (-8) </span><span class="cm">/* Not enough privilege for operation.  */</span><span class="cp"></span>
<span class="cp">#define GNTST_bad_page         (-9) </span><span class="cm">/* Specified page was invalid for op.    */</span><span class="cp"></span>
<span class="cp">#define GNTST_bad_copy_arg    (-10) </span><span class="cm">/* copy arguments cross page boundary */</span><span class="cp"></span>

<span class="cp">#define GNTTABOP_error_msgs {                   \</span>
<span class="cp">    &quot;okay&quot;,                                     \</span>
<span class="cp">    &quot;undefined error&quot;,                          \</span>
<span class="cp">    &quot;unrecognised domain id&quot;,                   \</span>
<span class="cp">    &quot;invalid grant reference&quot;,                  \</span>
<span class="cp">    &quot;invalid mapping handle&quot;,                   \</span>
<span class="cp">    &quot;invalid virtual address&quot;,                  \</span>
<span class="cp">    &quot;invalid device address&quot;,                   \</span>
<span class="cp">    &quot;no spare translation slot in the I/O MMU&quot;, \</span>
<span class="cp">    &quot;permission denied&quot;,                        \</span>
<span class="cp">    &quot;bad page&quot;,                                 \</span>
<span class="cp">    &quot;copy arguments cross page boundary&quot;        \</span>
<span class="cp">}</span>

<span class="cp">#endif </span><span class="cm">/* __XEN_PUBLIC_GRANT_TABLE_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
