<!DOCTYPE html>
<html><head><title>joekychen/linux » include › xen › interface › vcpu.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>vcpu.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> * vcpu.h</span>
<span class="cm"> *</span>
<span class="cm"> * VCPU initialisation, query, and hotplug.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="cm"> * of this software and associated documentation files (the &quot;Software&quot;), to</span>
<span class="cm"> * deal in the Software without restriction, including without limitation the</span>
<span class="cm"> * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or</span>
<span class="cm"> * sell copies of the Software, and to permit persons to whom the Software is</span>
<span class="cm"> * furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be included in</span>
<span class="cm"> * all copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="cm"> * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="cm"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="cm"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span>
<span class="cm"> * DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2005, Keir Fraser &lt;keir@xensource.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __XEN_PUBLIC_VCPU_H__</span>
<span class="cp">#define __XEN_PUBLIC_VCPU_H__</span>

<span class="cm">/*</span>
<span class="cm"> * Prototype for this hypercall is:</span>
<span class="cm"> *	int vcpu_op(int cmd, int vcpuid, void *extra_args)</span>
<span class="cm"> * @cmd		   == VCPUOP_??? (VCPU operation).</span>
<span class="cm"> * @vcpuid	   == VCPU to operate on.</span>
<span class="cm"> * @extra_args == Operation-specific extra arguments (NULL if none).</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Initialise a VCPU. Each VCPU can be initialised only once. A</span>
<span class="cm"> * newly-initialised VCPU will not run until it is brought up by VCPUOP_up.</span>
<span class="cm"> *</span>
<span class="cm"> * @extra_arg == pointer to vcpu_guest_context structure containing initial</span>
<span class="cm"> *				 state for the VCPU.</span>
<span class="cm"> */</span>
<span class="cp">#define VCPUOP_initialise			 0</span>

<span class="cm">/*</span>
<span class="cm"> * Bring up a VCPU. This makes the VCPU runnable. This operation will fail</span>
<span class="cm"> * if the VCPU has not been initialised (VCPUOP_initialise).</span>
<span class="cm"> */</span>
<span class="cp">#define VCPUOP_up					 1</span>

<span class="cm">/*</span>
<span class="cm"> * Bring down a VCPU (i.e., make it non-runnable).</span>
<span class="cm"> * There are a few caveats that callers should observe:</span>
<span class="cm"> *	1. This operation may return, and VCPU_is_up may return false, before the</span>
<span class="cm"> *	   VCPU stops running (i.e., the command is asynchronous). It is a good</span>
<span class="cm"> *	   idea to ensure that the VCPU has entered a non-critical loop before</span>
<span class="cm"> *	   bringing it down. Alternatively, this operation is guaranteed</span>
<span class="cm"> *	   synchronous if invoked by the VCPU itself.</span>
<span class="cm"> *	2. After a VCPU is initialised, there is currently no way to drop all its</span>
<span class="cm"> *	   references to domain memory. Even a VCPU that is down still holds</span>
<span class="cm"> *	   memory references via its pagetable base pointer and GDT. It is good</span>
<span class="cm"> *	   practise to move a VCPU onto an &#39;idle&#39; or default page table, LDT and</span>
<span class="cm"> *	   GDT before bringing it down.</span>
<span class="cm"> */</span>
<span class="cp">#define VCPUOP_down					 2</span>

<span class="cm">/* Returns 1 if the given VCPU is up. */</span>
<span class="cp">#define VCPUOP_is_up				 3</span>

<span class="cm">/*</span>
<span class="cm"> * Return information about the state and running time of a VCPU.</span>
<span class="cm"> * @extra_arg == pointer to vcpu_runstate_info structure.</span>
<span class="cm"> */</span>
<span class="cp">#define VCPUOP_get_runstate_info	 4</span>
<span class="k">struct</span> <span class="n">vcpu_runstate_info</span> <span class="p">{</span>
		<span class="cm">/* VCPU&#39;s current state (RUNSTATE_*). */</span>
		<span class="kt">int</span>		 <span class="n">state</span><span class="p">;</span>
		<span class="cm">/* When was current state entered (system time, ns)? */</span>
		<span class="kt">uint64_t</span> <span class="n">state_entry_time</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Time spent in each RUNSTATE_* (ns). The sum of these times is</span>
<span class="cm">		 * guaranteed not to drift from system time.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">time</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">vcpu_runstate_info</span><span class="p">);</span>

<span class="cm">/* VCPU is currently running on a physical CPU. */</span>
<span class="cp">#define RUNSTATE_running  0</span>

<span class="cm">/* VCPU is runnable, but not currently scheduled on any physical CPU. */</span>
<span class="cp">#define RUNSTATE_runnable 1</span>

<span class="cm">/* VCPU is blocked (a.k.a. idle). It is therefore not runnable. */</span>
<span class="cp">#define RUNSTATE_blocked  2</span>

<span class="cm">/*</span>
<span class="cm"> * VCPU is not runnable, but it is not blocked.</span>
<span class="cm"> * This is a &#39;catch all&#39; state for things like hotplug and pauses by the</span>
<span class="cm"> * system administrator (or for critical sections in the hypervisor).</span>
<span class="cm"> * RUNSTATE_blocked dominates this state (it is the preferred state).</span>
<span class="cm"> */</span>
<span class="cp">#define RUNSTATE_offline  3</span>

<span class="cm">/*</span>
<span class="cm"> * Register a shared memory area from which the guest may obtain its own</span>
<span class="cm"> * runstate information without needing to execute a hypercall.</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	1. The registered address may be virtual or physical, depending on the</span>
<span class="cm"> *	   platform. The virtual address should be registered on x86 systems.</span>
<span class="cm"> *	2. Only one shared area may be registered per VCPU. The shared area is</span>
<span class="cm"> *	   updated by the hypervisor each time the VCPU is scheduled. Thus</span>
<span class="cm"> *	   runstate.state will always be RUNSTATE_running and</span>
<span class="cm"> *	   runstate.state_entry_time will indicate the system time at which the</span>
<span class="cm"> *	   VCPU was last scheduled to run.</span>
<span class="cm"> * @extra_arg == pointer to vcpu_register_runstate_memory_area structure.</span>
<span class="cm"> */</span>
<span class="cp">#define VCPUOP_register_runstate_memory_area 5</span>
<span class="k">struct</span> <span class="n">vcpu_register_runstate_memory_area</span> <span class="p">{</span>
		<span class="k">union</span> <span class="p">{</span>
				<span class="n">GUEST_HANDLE</span><span class="p">(</span><span class="n">vcpu_runstate_info</span><span class="p">)</span> <span class="n">h</span><span class="p">;</span>
				<span class="k">struct</span> <span class="n">vcpu_runstate_info</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
				<span class="kt">uint64_t</span> <span class="n">p</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Set or stop a VCPU&#39;s periodic timer. Every VCPU has one periodic timer</span>
<span class="cm"> * which can be set via these commands. Periods smaller than one millisecond</span>
<span class="cm"> * may not be supported.</span>
<span class="cm"> */</span>
<span class="cp">#define VCPUOP_set_periodic_timer	 6 </span><span class="cm">/* arg == vcpu_set_periodic_timer_t */</span><span class="cp"></span>
<span class="cp">#define VCPUOP_stop_periodic_timer	 7 </span><span class="cm">/* arg == NULL */</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">vcpu_set_periodic_timer</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">period_ns</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">vcpu_set_periodic_timer</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Set or stop a VCPU&#39;s single-shot timer. Every VCPU has one single-shot</span>
<span class="cm"> * timer which can be set via these commands.</span>
<span class="cm"> */</span>
<span class="cp">#define VCPUOP_set_singleshot_timer	 8 </span><span class="cm">/* arg == vcpu_set_singleshot_timer_t */</span><span class="cp"></span>
<span class="cp">#define VCPUOP_stop_singleshot_timer 9 </span><span class="cm">/* arg == NULL */</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">vcpu_set_singleshot_timer</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">timeout_abs_ns</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>			   <span class="cm">/* VCPU_SSHOTTMR_??? */</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">vcpu_set_singleshot_timer</span><span class="p">);</span>

<span class="cm">/* Flags to VCPUOP_set_singleshot_timer. */</span>
 <span class="cm">/* Require the timeout to be in the future (return -ETIME if it&#39;s passed). */</span>
<span class="cp">#define _VCPU_SSHOTTMR_future (0)</span>
<span class="cp">#define VCPU_SSHOTTMR_future  (1U &lt;&lt; _VCPU_SSHOTTMR_future)</span>

<span class="cm">/*</span>
<span class="cm"> * Register a memory location in the guest address space for the</span>
<span class="cm"> * vcpu_info structure.  This allows the guest to place the vcpu_info</span>
<span class="cm"> * structure in a convenient place, such as in a per-cpu data area.</span>
<span class="cm"> * The pointer need not be page aligned, but the structure must not</span>
<span class="cm"> * cross a page boundary.</span>
<span class="cm"> */</span>
<span class="cp">#define VCPUOP_register_vcpu_info   10  </span><span class="cm">/* arg == struct vcpu_info */</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">vcpu_register_vcpu_info</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">mfn</span><span class="p">;</span>    <span class="cm">/* mfn of page to place vcpu_info */</span>
    <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">;</span> <span class="cm">/* offset within page */</span>
    <span class="kt">uint32_t</span> <span class="n">rsvd</span><span class="p">;</span>   <span class="cm">/* unused */</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">vcpu_register_vcpu_info</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __XEN_PUBLIC_VCPU_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
