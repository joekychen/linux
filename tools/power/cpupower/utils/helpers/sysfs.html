<!DOCTYPE html>
<html><head><title>joekychen/linux » tools › power › cpupower › utils › helpers › sysfs.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>sysfs.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  (C) 2004-2009  Dominik Brodowski &lt;linux@dominikbrodowski.de&gt;</span>
<span class="cm"> *  (C) 2011       Thomas Renninger &lt;trenn@novell.com&gt; Novell Inc.</span>
<span class="cm"> *</span>
<span class="cm"> *  Licensed under the terms of the GNU GPL License version 2.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;errno.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;sys/stat.h&gt;</span>
<span class="cp">#include &lt;fcntl.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>

<span class="cp">#include &quot;helpers/sysfs.h&quot;</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sysfs_read_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">numread</span><span class="p">;</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">numread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">numread</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">buf</span><span class="p">[</span><span class="n">numread</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">numread</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sysfs_write_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">numwrite</span><span class="p">;</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">numwrite</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">numwrite</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">numwrite</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Detect whether a CPU is online</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *     1 -&gt; if CPU is online</span>
<span class="cm"> *     0 -&gt; if CPU is offline</span>
<span class="cm"> *     negative errno values in error case</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sysfs_is_cpu_online</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="n">SYSFS_PATH_MAX</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">numread</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">linebuf</span><span class="p">[</span><span class="n">MAX_LINE_LEN</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stat</span> <span class="n">statbuf</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">PATH_TO_CPU</span> <span class="s">&quot;cpu%u&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statbuf</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * kernel without CONFIG_HOTPLUG_CPU</span>
<span class="cm">	 * -&gt; cpuX directory exists, but not cpuX/online file</span>
<span class="cm">	 */</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">PATH_TO_CPU</span> <span class="s">&quot;cpu%u/online&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statbuf</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">errno</span><span class="p">;</span>

	<span class="n">numread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">linebuf</span><span class="p">,</span> <span class="n">MAX_LINE_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">numread</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">linebuf</span><span class="p">[</span><span class="n">numread</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

	<span class="n">value</span> <span class="o">=</span> <span class="n">strtoull</span><span class="p">(</span><span class="n">linebuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* CPUidle idlestate specific /sys/devices/system/cpu/cpuX/cpuidle/ access */</span>

<span class="cm">/*</span>
<span class="cm"> * helper function to read file from /sys into given buffer</span>
<span class="cm"> * fname is a relative path under &quot;cpuX/cpuidle/stateX/&quot; dir</span>
<span class="cm"> * cstates starting with 0, C0 is not counted as cstate.</span>
<span class="cm"> * This means if you want C1 info, pass 0 as idlestate param</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sysfs_idlestate_read_file</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idlestate</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="n">SYSFS_PATH_MAX</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">numread</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">PATH_TO_CPU</span> <span class="s">&quot;cpu%u/cpuidle/state%u/%s&quot;</span><span class="p">,</span>
		 <span class="n">cpu</span><span class="p">,</span> <span class="n">idlestate</span><span class="p">,</span> <span class="n">fname</span><span class="p">);</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">numread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">numread</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">buf</span><span class="p">[</span><span class="n">numread</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">numread</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* read access to files which contain one numeric value */</span>

<span class="k">enum</span> <span class="n">idlestate_value</span> <span class="p">{</span>
	<span class="n">IDLESTATE_USAGE</span><span class="p">,</span>
	<span class="n">IDLESTATE_POWER</span><span class="p">,</span>
	<span class="n">IDLESTATE_LATENCY</span><span class="p">,</span>
	<span class="n">IDLESTATE_TIME</span><span class="p">,</span>
	<span class="n">MAX_IDLESTATE_VALUE_FILES</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">idlestate_value_files</span><span class="p">[</span><span class="n">MAX_IDLESTATE_VALUE_FILES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">IDLESTATE_USAGE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;usage&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">IDLESTATE_POWER</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;power&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">IDLESTATE_LATENCY</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;latency&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">IDLESTATE_TIME</span><span class="p">]</span>  <span class="o">=</span> <span class="s">&quot;time&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">sysfs_idlestate_get_one_value</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
						     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idlestate</span><span class="p">,</span>
						     <span class="k">enum</span> <span class="n">idlestate_value</span> <span class="n">which</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">linebuf</span><span class="p">[</span><span class="n">MAX_LINE_LEN</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">&gt;=</span> <span class="n">MAX_IDLESTATE_VALUE_FILES</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">sysfs_idlestate_read_file</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">idlestate</span><span class="p">,</span>
					<span class="n">idlestate_value_files</span><span class="p">[</span><span class="n">which</span><span class="p">],</span>
					<span class="n">linebuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">linebuf</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">value</span> <span class="o">=</span> <span class="n">strtoull</span><span class="p">(</span><span class="n">linebuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">endp</span> <span class="o">==</span> <span class="n">linebuf</span> <span class="o">||</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">ERANGE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* read access to files which contain one string */</span>

<span class="k">enum</span> <span class="n">idlestate_string</span> <span class="p">{</span>
	<span class="n">IDLESTATE_DESC</span><span class="p">,</span>
	<span class="n">IDLESTATE_NAME</span><span class="p">,</span>
	<span class="n">MAX_IDLESTATE_STRING_FILES</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">idlestate_string_files</span><span class="p">[</span><span class="n">MAX_IDLESTATE_STRING_FILES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">IDLESTATE_DESC</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;desc&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">IDLESTATE_NAME</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;name&quot;</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">sysfs_idlestate_get_one_string</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idlestate</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">idlestate_string</span> <span class="n">which</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">linebuf</span><span class="p">[</span><span class="n">MAX_LINE_LEN</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">&gt;=</span> <span class="n">MAX_IDLESTATE_STRING_FILES</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">sysfs_idlestate_read_file</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">idlestate</span><span class="p">,</span>
					<span class="n">idlestate_string_files</span><span class="p">[</span><span class="n">which</span><span class="p">],</span>
					<span class="n">linebuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">linebuf</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">linebuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="n">result</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">sysfs_get_idlestate_latency</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idlestate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sysfs_idlestate_get_one_value</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">idlestate</span><span class="p">,</span> <span class="n">IDLESTATE_LATENCY</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">sysfs_get_idlestate_usage</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idlestate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sysfs_idlestate_get_one_value</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">idlestate</span><span class="p">,</span> <span class="n">IDLESTATE_USAGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">sysfs_get_idlestate_time</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idlestate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sysfs_idlestate_get_one_value</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">idlestate</span><span class="p">,</span> <span class="n">IDLESTATE_TIME</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">sysfs_get_idlestate_name</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idlestate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sysfs_idlestate_get_one_string</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">idlestate</span><span class="p">,</span> <span class="n">IDLESTATE_NAME</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">sysfs_get_idlestate_desc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idlestate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sysfs_idlestate_get_one_string</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">idlestate</span><span class="p">,</span> <span class="n">IDLESTATE_DESC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns number of supported C-states of CPU core cpu</span>
<span class="cm"> * Negativ in error case</span>
<span class="cm"> * Zero if cpuidle does not export any C-states</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sysfs_get_idlestate_count</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">file</span><span class="p">[</span><span class="n">SYSFS_PATH_MAX</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">stat</span> <span class="n">statbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idlestates</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>


	<span class="n">snprintf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">SYSFS_PATH_MAX</span><span class="p">,</span> <span class="n">PATH_TO_CPU</span> <span class="s">&quot;cpuidle&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statbuf</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">statbuf</span><span class="p">.</span><span class="n">st_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">SYSFS_PATH_MAX</span><span class="p">,</span> <span class="n">PATH_TO_CPU</span> <span class="s">&quot;cpu%u/cpuidle/state0&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statbuf</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">statbuf</span><span class="p">.</span><span class="n">st_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statbuf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">statbuf</span><span class="p">.</span><span class="n">st_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">SYSFS_PATH_MAX</span><span class="p">,</span> <span class="n">PATH_TO_CPU</span>
			 <span class="s">&quot;cpu%u/cpuidle/state%d&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">idlestates</span><span class="p">);</span>
		<span class="n">idlestates</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">idlestates</span><span class="o">--</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">idlestates</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* CPUidle general /sys/devices/system/cpu/cpuidle/ sysfs access ********/</span>

<span class="cm">/*</span>
<span class="cm"> * helper function to read file from /sys into given buffer</span>
<span class="cm"> * fname is a relative path under &quot;cpu/cpuidle/&quot; dir</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sysfs_cpuidle_read_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					    <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="n">SYSFS_PATH_MAX</span><span class="p">];</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">PATH_TO_CPU</span> <span class="s">&quot;cpuidle/%s&quot;</span><span class="p">,</span> <span class="n">fname</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sysfs_read_file</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/* read access to files which contain one string */</span>

<span class="k">enum</span> <span class="n">cpuidle_string</span> <span class="p">{</span>
	<span class="n">CPUIDLE_GOVERNOR</span><span class="p">,</span>
	<span class="n">CPUIDLE_GOVERNOR_RO</span><span class="p">,</span>
	<span class="n">CPUIDLE_DRIVER</span><span class="p">,</span>
	<span class="n">MAX_CPUIDLE_STRING_FILES</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cpuidle_string_files</span><span class="p">[</span><span class="n">MAX_CPUIDLE_STRING_FILES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">CPUIDLE_GOVERNOR</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;current_governor&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">CPUIDLE_GOVERNOR_RO</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;current_governor_ro&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">CPUIDLE_DRIVER</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;current_driver&quot;</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">sysfs_cpuidle_get_one_string</span><span class="p">(</span><span class="k">enum</span> <span class="n">cpuidle_string</span> <span class="n">which</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">linebuf</span><span class="p">[</span><span class="n">MAX_LINE_LEN</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">&gt;=</span> <span class="n">MAX_CPUIDLE_STRING_FILES</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">sysfs_cpuidle_read_file</span><span class="p">(</span><span class="n">cpuidle_string_files</span><span class="p">[</span><span class="n">which</span><span class="p">],</span>
				<span class="n">linebuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">linebuf</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">linebuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="n">result</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">sysfs_get_cpuidle_governor</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">sysfs_cpuidle_get_one_string</span><span class="p">(</span><span class="n">CPUIDLE_GOVERNOR_RO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sysfs_cpuidle_get_one_string</span><span class="p">(</span><span class="n">CPUIDLE_GOVERNOR</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">sysfs_get_cpuidle_driver</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sysfs_cpuidle_get_one_string</span><span class="p">(</span><span class="n">CPUIDLE_DRIVER</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* CPUidle idlestate specific /sys/devices/system/cpu/cpuX/cpuidle/ access */</span>

<span class="cm">/*</span>
<span class="cm"> * Get sched_mc or sched_smt settings</span>
<span class="cm"> * Pass &quot;mc&quot; or &quot;smt&quot; as argument</span>
<span class="cm"> *</span>
<span class="cm"> * Returns negative value on failure</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sysfs_get_sched</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">smt_mc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get sched_mc or sched_smt settings</span>
<span class="cm"> * Pass &quot;mc&quot; or &quot;smt&quot; as argument</span>
<span class="cm"> *</span>
<span class="cm"> * Returns negative value on failure</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sysfs_set_sched</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">smt_mc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
