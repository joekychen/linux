<!DOCTYPE html>
<html><head><title>joekychen/linux » tools › virtio › linux › virtio.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>virtio.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef LINUX_VIRTIO_H</span>
<span class="cp">#define LINUX_VIRTIO_H</span>

<span class="cp">#include &lt;stdbool.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;stddef.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;assert.h&gt;</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;errno.h&gt;</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">dma_addr_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">scatterlist</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">page_link</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">length</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	<span class="n">dma_address</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">page</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">dummy</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define BUG_ON(__BUG_ON_cond) assert(!(__BUG_ON_cond))</span>

<span class="cm">/* Physical == Virtual */</span>
<span class="cp">#define virt_to_phys(p) ((unsigned long)p)</span>
<span class="cp">#define phys_to_virt(a) ((void *)(unsigned long)(a))</span>
<span class="cm">/* Page address: Virtual / 4K */</span>
<span class="cp">#define virt_to_page(p) ((struct page*)((virt_to_phys(p) / 4096) * \</span>
<span class="cp">					sizeof(struct page)))</span>
<span class="cp">#define offset_in_page(p) (((unsigned long)p) % 4096)</span>
<span class="cp">#define sg_phys(sg) ((sg-&gt;page_link &amp; ~0x3) / sizeof(struct page) * 4096 + \</span>
<span class="cp">		     sg-&gt;offset)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sg_mark_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set termination bit, clear potential chain bit</span>
<span class="cm">	 */</span>
	<span class="n">sg</span><span class="o">-&gt;</span><span class="n">page_link</span> <span class="o">|=</span> <span class="mh">0x02</span><span class="p">;</span>
	<span class="n">sg</span><span class="o">-&gt;</span><span class="n">page_link</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x01</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sg_init_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sgl</span><span class="p">)</span> <span class="o">*</span> <span class="n">nents</span><span class="p">);</span>
	<span class="n">sg_mark_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgl</span><span class="p">[</span><span class="n">nents</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sg_assign_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_link</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">page_link</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In order for the low bit stealing approach to work, pages</span>
<span class="cm">	 * must be aligned at a 32-bit boundary as a minimum.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">page</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">);</span>
	<span class="n">sg</span><span class="o">-&gt;</span><span class="n">page_link</span> <span class="o">=</span> <span class="n">page_link</span> <span class="o">|</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sg_set_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sg_assign_page</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sg_set_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sg_set_page</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">buflen</span><span class="p">,</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sg_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sg_init_table</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sg_set_buf</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="n">__u16</span> <span class="n">u16</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">GFP_KERNEL</span><span class="p">,</span>
	<span class="n">GFP_ATOMIC</span><span class="p">,</span>
<span class="p">}</span> <span class="n">gfp_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">IRQ_NONE</span><span class="p">,</span>
	<span class="n">IRQ_HANDLED</span>
<span class="p">}</span> <span class="n">irqreturn_t</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">kmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">malloc</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kfree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define container_of(ptr, type, member) ({			\</span>
<span class="cp">	const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);	\</span>
<span class="cp">	(type *)( (char *)__mptr - offsetof(type,member) );})</span>

<span class="cp">#define uninitialized_var(x) x = x</span>

<span class="cp"># ifndef likely</span>
<span class="cp">#  define likely(x)	(__builtin_expect(!!(x), 1))</span>
<span class="cp"># endif</span>
<span class="cp"># ifndef unlikely</span>
<span class="cp">#  define unlikely(x)	(__builtin_expect(!!(x), 0))</span>
<span class="cp"># endif</span>

<span class="cp">#define pr_err(format, ...) fprintf (stderr, format, ## __VA_ARGS__)</span>
<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define pr_debug(format, ...) fprintf (stderr, format, ## __VA_ARGS__)</span>
<span class="cp">#else</span>
<span class="cp">#define pr_debug(format, ...) do {} while (0)</span>
<span class="cp">#endif</span>
<span class="cp">#define dev_err(dev, format, ...) fprintf (stderr, format, ## __VA_ARGS__)</span>
<span class="cp">#define dev_warn(dev, format, ...) fprintf (stderr, format, ## __VA_ARGS__)</span>

<span class="cm">/* TODO: empty stubs for now. Broken but enough for virtio_ring.c */</span>
<span class="cp">#define list_add_tail(a, b) do {} while (0)</span>
<span class="cp">#define list_del(a) do {} while (0)</span>

<span class="cp">#define BIT_WORD(nr)		((nr) / BITS_PER_LONG)</span>
<span class="cp">#define BITS_PER_BYTE		8</span>
<span class="cp">#define BITS_PER_LONG (sizeof(long) * BITS_PER_BYTE)</span>
<span class="cp">#define BIT_MASK(nr)		(1UL &lt;&lt; ((nr) % BITS_PER_LONG))</span>
<span class="cm">/* TODO: Not atomic as it should be:</span>
<span class="cm"> * we don&#39;t use this for anything important. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">BIT_MASK</span><span class="p">(</span><span class="n">nr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">BIT_WORD</span><span class="p">(</span><span class="n">nr</span><span class="p">);</span>

	<span class="o">*</span><span class="n">p</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">test_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">const</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="mi">1UL</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="n">BIT_WORD</span><span class="p">(</span><span class="n">nr</span><span class="p">)]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span><span class="o">-</span><span class="mi">1</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/* The only feature we care to support */</span>
<span class="cp">#define virtio_has_feature(dev, feature) \</span>
<span class="cp">	test_bit((feature), (dev)-&gt;features)</span>
<span class="cm">/* end of stubs */</span>

<span class="k">struct</span> <span class="n">virtio_device</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">features</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">virtqueue</span> <span class="p">{</span>
	<span class="cm">/* TODO: commented as list macros are empty stubs for now.</span>
<span class="cm">	 * Broken but enough for virtio_ring.c</span>
<span class="cm">	 * struct list_head list; */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define EXPORT_SYMBOL_GPL(__EXPORT_SYMBOL_GPL_name) \</span>
<span class="cp">	void __EXPORT_SYMBOL_GPL##__EXPORT_SYMBOL_GPL_name() { \</span>
<span class="cp">}</span>
<span class="cp">#define MODULE_LICENSE(__MODULE_LICENSE_value) \</span>
<span class="cp">	const char *__MODULE_LICENSE_name = __MODULE_LICENSE_value</span>

<span class="cp">#define CONFIG_SMP</span>

<span class="cp">#if defined(__i386__) || defined(__x86_64__)</span>
<span class="cp">#define barrier() asm volatile(&quot;&quot; ::: &quot;memory&quot;)</span>
<span class="cp">#define mb() __sync_synchronize()</span>

<span class="cp">#define smp_mb()	mb()</span>
<span class="cp"># define smp_rmb()	barrier()</span>
<span class="cp"># define smp_wmb()	barrier()</span>
<span class="cm">/* Weak barriers should be used. If not - it&#39;s a bug */</span>
<span class="cp"># define rmb()	abort()</span>
<span class="cp"># define wmb()	abort()</span>
<span class="cp">#else</span>
<span class="cp">#error Please fill in barrier macros</span>
<span class="cp">#endif</span>

<span class="cm">/* Interfaces exported by virtio_ring. */</span>
<span class="kt">int</span> <span class="n">virtqueue_add_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg</span><span class="p">[],</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">out_num</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">in_num</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		      <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">virtqueue_kick</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">virtqueue_get_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">virtqueue_disable_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">);</span>

<span class="n">bool</span> <span class="n">virtqueue_enable_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">virtqueue_enable_cb_delayed</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">virtqueue_detach_unused_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vring_new_virtqueue</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vring_align</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span>
				      <span class="n">bool</span> <span class="n">weak_barriers</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">notify</span><span class="p">)(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">),</span>
				      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">),</span>
				      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">vring_del_virtqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
