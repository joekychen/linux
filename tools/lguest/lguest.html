<!DOCTYPE html>
<html><head><title>joekychen/linux » tools › lguest › lguest.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>lguest.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*P:100</span>
<span class="cm"> * This is the Launcher code, a simple program which lays out the &quot;physical&quot;</span>
<span class="cm"> * memory for the new Guest by mapping the kernel image and the virtual</span>
<span class="cm"> * devices, then opens /dev/lguest to tell the kernel about the Guest and</span>
<span class="cm"> * control it.</span>
<span class="cm">:*/</span>
<span class="cp">#define _LARGEFILE64_SOURCE</span>
<span class="cp">#define _GNU_SOURCE</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;err.h&gt;</span>
<span class="cp">#include &lt;stdint.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;elf.h&gt;</span>
<span class="cp">#include &lt;sys/mman.h&gt;</span>
<span class="cp">#include &lt;sys/param.h&gt;</span>
<span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;sys/stat.h&gt;</span>
<span class="cp">#include &lt;sys/wait.h&gt;</span>
<span class="cp">#include &lt;sys/eventfd.h&gt;</span>
<span class="cp">#include &lt;fcntl.h&gt;</span>
<span class="cp">#include &lt;stdbool.h&gt;</span>
<span class="cp">#include &lt;errno.h&gt;</span>
<span class="cp">#include &lt;ctype.h&gt;</span>
<span class="cp">#include &lt;sys/socket.h&gt;</span>
<span class="cp">#include &lt;sys/ioctl.h&gt;</span>
<span class="cp">#include &lt;sys/time.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>
<span class="cp">#include &lt;netinet/in.h&gt;</span>
<span class="cp">#include &lt;net/if.h&gt;</span>
<span class="cp">#include &lt;linux/sockios.h&gt;</span>
<span class="cp">#include &lt;linux/if_tun.h&gt;</span>
<span class="cp">#include &lt;sys/uio.h&gt;</span>
<span class="cp">#include &lt;termios.h&gt;</span>
<span class="cp">#include &lt;getopt.h&gt;</span>
<span class="cp">#include &lt;assert.h&gt;</span>
<span class="cp">#include &lt;sched.h&gt;</span>
<span class="cp">#include &lt;limits.h&gt;</span>
<span class="cp">#include &lt;stddef.h&gt;</span>
<span class="cp">#include &lt;signal.h&gt;</span>
<span class="cp">#include &lt;pwd.h&gt;</span>
<span class="cp">#include &lt;grp.h&gt;</span>

<span class="cp">#include &lt;linux/virtio_config.h&gt;</span>
<span class="cp">#include &lt;linux/virtio_net.h&gt;</span>
<span class="cp">#include &lt;linux/virtio_blk.h&gt;</span>
<span class="cp">#include &lt;linux/virtio_console.h&gt;</span>
<span class="cp">#include &lt;linux/virtio_rng.h&gt;</span>
<span class="cp">#include &lt;linux/virtio_ring.h&gt;</span>
<span class="cp">#include &lt;asm/bootparam.h&gt;</span>
<span class="cp">#include &quot;../../include/linux/lguest_launcher.h&quot;</span>
<span class="cm">/*L:110</span>
<span class="cm"> * We can ignore the 43 include files we need for this program, but I do want</span>
<span class="cm"> * to draw attention to the use of kernel-style types.</span>
<span class="cm"> *</span>
<span class="cm"> * As Linus said, &quot;C is a Spartan language, and so should your naming be.&quot;  I</span>
<span class="cm"> * like these abbreviations, so we define them here.  Note that u64 is always</span>
<span class="cm"> * unsigned long long, which works on all Linux systems: this means that we can</span>
<span class="cm"> * use %llu in printf for any u64.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">u64</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">u32</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">uint16_t</span> <span class="n">u16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">uint8_t</span> <span class="n">u8</span><span class="p">;</span>
<span class="cm">/*:*/</span>

<span class="cp">#define BRIDGE_PFX &quot;bridge:&quot;</span>
<span class="cp">#ifndef SIOCBRADDIF</span>
<span class="cp">#define SIOCBRADDIF	0x89a2		</span><span class="cm">/* add interface to bridge      */</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cm">/* We can have up to 256 pages for devices. */</span>
<span class="cp">#define DEVICE_PAGES 256</span>
<span class="cm">/* This will occupy 3 pages: it must be a power of 2. */</span>
<span class="cp">#define VIRTQUEUE_NUM 256</span>

<span class="cm">/*L:120</span>
<span class="cm"> * verbose is both a global flag and a macro.  The C preprocessor allows</span>
<span class="cm"> * this, and although I wouldn&#39;t recommend it, it works quite nicely here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">verbose</span><span class="p">;</span>
<span class="cp">#define verbose(args...) \</span>
<span class="cp">	do { if (verbose) printf(args); } while(0)</span>
<span class="cm">/*:*/</span>

<span class="cm">/* The pointer to the start of guest memory. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">guest_base</span><span class="p">;</span>
<span class="cm">/* The maximum guest physical address allowed, and maximum possible. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">guest_limit</span><span class="p">,</span> <span class="n">guest_max</span><span class="p">;</span>
<span class="cm">/* The /dev/lguest file descriptor. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lguest_fd</span><span class="p">;</span>

<span class="cm">/* a per-cpu variable indicating whose vcpu is currently running */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__thread</span> <span class="n">cpu_id</span><span class="p">;</span>

<span class="cm">/* This is our list of devices. */</span>
<span class="k">struct</span> <span class="n">device_list</span> <span class="p">{</span>
	<span class="cm">/* Counter to assign interrupt numbers. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next_irq</span><span class="p">;</span>

	<span class="cm">/* Counter to print out convenient device numbers. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device_num</span><span class="p">;</span>

	<span class="cm">/* The descriptor page for the devices. */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">descpage</span><span class="p">;</span>

	<span class="cm">/* A single linked list of devices. */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="cm">/* And a pointer to the last device for easy append. */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">lastdev</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The list of Guest devices, based on command line arguments. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_list</span> <span class="n">devices</span><span class="p">;</span>

<span class="cm">/* The device structure describes a single device. */</span>
<span class="k">struct</span> <span class="n">device</span> <span class="p">{</span>
	<span class="cm">/* The linked-list pointer. */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/* The device&#39;s descriptor, as mapped into the Guest. */</span>
	<span class="k">struct</span> <span class="n">lguest_device_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>

	<span class="cm">/* We can&#39;t trust desc values once Guest has booted: we use these. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">feature_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_vq</span><span class="p">;</span>

	<span class="cm">/* The name of this device, for --verbose. */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/* Any queues attached to this device */</span>
	<span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">;</span>

	<span class="cm">/* Is it operational */</span>
	<span class="n">bool</span> <span class="n">running</span><span class="p">;</span>

	<span class="cm">/* Device-specific data. */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The virtqueue structure describes a queue attached to a device. */</span>
<span class="k">struct</span> <span class="n">virtqueue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/* Which device owns me. */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* The configuration for this queue. */</span>
	<span class="k">struct</span> <span class="n">lguest_vqconfig</span> <span class="n">config</span><span class="p">;</span>

	<span class="cm">/* The actual ring of buffers. */</span>
	<span class="k">struct</span> <span class="n">vring</span> <span class="n">vring</span><span class="p">;</span>

	<span class="cm">/* Last available index we saw. */</span>
	<span class="n">u16</span> <span class="n">last_avail_idx</span><span class="p">;</span>

	<span class="cm">/* How many are used since we sent last irq? */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pending_used</span><span class="p">;</span>

	<span class="cm">/* Eventfd where Guest notifications arrive. */</span>
	<span class="kt">int</span> <span class="n">eventfd</span><span class="p">;</span>

	<span class="cm">/* Function for the thread which is servicing this virtqueue. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">service</span><span class="p">)(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">);</span>
	<span class="n">pid_t</span> <span class="kr">thread</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Remember the arguments to the program so we can &quot;reboot&quot; */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">**</span><span class="n">main_args</span><span class="p">;</span>

<span class="cm">/* The original tty settings to restore on exit. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">termios</span> <span class="n">orig_term</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * We have to be careful with barriers: our devices are all run in separate</span>
<span class="cm"> * threads and so we need to make sure that changes visible to the Guest happen</span>
<span class="cm"> * in precise order.</span>
<span class="cm"> */</span>
<span class="cp">#define wmb() __asm__ __volatile__(&quot;&quot; : : : &quot;memory&quot;)</span>
<span class="cp">#define mb() __asm__ __volatile__(&quot;&quot; : : : &quot;memory&quot;)</span>

<span class="cm">/*</span>
<span class="cm"> * Convert an iovec element to the given type.</span>
<span class="cm"> *</span>
<span class="cm"> * This is a fairly ugly trick: we need to know the size of the type and</span>
<span class="cm"> * alignment requirement to check the pointer is kosher.  It&#39;s also nice to</span>
<span class="cm"> * have the name of the type in case we report failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Typing those three things all the time is cumbersome and error prone, so we</span>
<span class="cm"> * have a macro which sets them all up and passes to the real function.</span>
<span class="cm"> */</span>
<span class="cp">#define convert(iov, type) \</span>
<span class="cp">	((type *)_convert((iov), sizeof(type), __alignof__(type), #type))</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">_convert</span><span class="p">(</span><span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">align</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Bad iovec size %zu for %s&quot;</span><span class="p">,</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">%</span> <span class="n">align</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Bad alignment %p for %s&quot;</span><span class="p">,</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Wrapper for the last available index.  Makes it easier to change. */</span>
<span class="cp">#define lg_last_avail(vq)	((vq)-&gt;last_avail_idx)</span>

<span class="cm">/*</span>
<span class="cm"> * The virtio configuration space is defined to be little-endian.  x86 is</span>
<span class="cm"> * little-endian too, but it&#39;s nice to be explicit so we have these helpers.</span>
<span class="cm"> */</span>
<span class="cp">#define cpu_to_le16(v16) (v16)</span>
<span class="cp">#define cpu_to_le32(v32) (v32)</span>
<span class="cp">#define cpu_to_le64(v64) (v64)</span>
<span class="cp">#define le16_to_cpu(v16) (v16)</span>
<span class="cp">#define le32_to_cpu(v32) (v32)</span>
<span class="cp">#define le64_to_cpu(v64) (v64)</span>

<span class="cm">/* Is this iovec empty? */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">iov_empty</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_iov</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_iov</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Take len bytes from the front of this iovec. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iov_consume</span><span class="p">(</span><span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="n">num_iov</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_iov</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">used</span><span class="p">;</span>

		<span class="n">used</span> <span class="o">=</span> <span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">?</span> <span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">+=</span> <span class="n">used</span><span class="p">;</span>
		<span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">-=</span> <span class="n">used</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">used</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* The device virtqueue descriptors are followed by feature bitmasks. */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="o">*</span><span class="nf">get_feature_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">+</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_vq</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lguest_vqconfig</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*L:100</span>
<span class="cm"> * The Launcher code itself takes us out into userspace, that scary place where</span>
<span class="cm"> * pointers run wild and free!  Unfortunately, like most userspace programs,</span>
<span class="cm"> * it&#39;s quite boring (which is why everyone likes to hack on the kernel!).</span>
<span class="cm"> * Perhaps if you make up an Lguest Drinking Game at this point, it will get</span>
<span class="cm"> * you through this section.  Or, maybe not.</span>
<span class="cm"> *</span>
<span class="cm"> * The Launcher sets up a big chunk of memory to be the Guest&#39;s &quot;physical&quot;</span>
<span class="cm"> * memory and stores it in &quot;guest_base&quot;.  In other words, Guest physical ==</span>
<span class="cm"> * Launcher virtual with an offset.</span>
<span class="cm"> *</span>
<span class="cm"> * This can be tough to get your head around, but usually it just means that we</span>
<span class="cm"> * use these trivial conversion functions when the Guest gives us its</span>
<span class="cm"> * &quot;physical&quot; addresses:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">from_guest_phys</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">guest_base</span> <span class="o">+</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">to_guest_phys</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">addr</span> <span class="o">-</span> <span class="n">guest_base</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*L:130</span>
<span class="cm"> * Loading the Kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * We start with couple of simple helper routines.  open_or_die() avoids</span>
<span class="cm"> * error-checking code cluttering the callers:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">open_or_die</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Failed to open %s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* map_zeroed_pages() takes a number of pages. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">map_zeroed_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open_or_die</span><span class="p">(</span><span class="s">&quot;/dev/zero&quot;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We use a private mapping (ie. if we write to the page, it will be</span>
<span class="cm">	 * copied). We allocate an extra two pages PROT_NONE to act as guard</span>
<span class="cm">	 * pages against read/write attempts that exceed allocated space.</span>
<span class="cm">	 */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">getpagesize</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">num</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span>
		    <span class="n">PROT_NONE</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Mmapping %u pages of /dev/zero&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mprotect</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">getpagesize</span><span class="p">(),</span> <span class="n">getpagesize</span><span class="p">()</span> <span class="o">*</span> <span class="n">num</span><span class="p">,</span>
		     <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;mprotect rw %u pages failed&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * One neat mmap feature is that you can close the fd, and it</span>
<span class="cm">	 * stays mapped.</span>
<span class="cm">	 */</span>
	<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

	<span class="cm">/* Return address after PROT_NONE page */</span>
	<span class="k">return</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">getpagesize</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Get some more pages for a device. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">get_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">from_guest_phys</span><span class="p">(</span><span class="n">guest_limit</span><span class="p">);</span>

	<span class="n">guest_limit</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">*</span> <span class="n">getpagesize</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">guest_limit</span> <span class="o">&gt;</span> <span class="n">guest_max</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Not enough memory for devices&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine is used to load the kernel or initrd.  It tries mmap, but if</span>
<span class="cm"> * that fails (Plan 9&#39;s kernel file isn&#39;t nicely aligned on page boundaries),</span>
<span class="cm"> * it falls back to reading the memory in.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">map_at</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">r</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We map writable even though for some segments are marked read-only.</span>
<span class="cm">	 * The kernel really wants to be writable: it patches its own</span>
<span class="cm">	 * instructions.</span>
<span class="cm">	 *</span>
<span class="cm">	 * MAP_PRIVATE means that the page won&#39;t be copied until a write is</span>
<span class="cm">	 * done to it.  This allows us to share untouched memory between</span>
<span class="cm">	 * Guests.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmap</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span>
		 <span class="n">MAP_FIXED</span><span class="o">|</span><span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MAP_FAILED</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* pread does a seek and a read in one shot: saves a few lines. */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">pread</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Reading offset %lu len %lu gave %zi&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine takes an open vmlinux image, which is in ELF, and maps it into</span>
<span class="cm"> * the Guest memory.  ELF = Embedded Linking Format, which is the format used</span>
<span class="cm"> * by all modern binaries on Linux including the kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * The ELF headers give *two* addresses: a physical address, and a virtual</span>
<span class="cm"> * address.  We use the physical address; the Guest will map itself to the</span>
<span class="cm"> * virtual address.</span>
<span class="cm"> *</span>
<span class="cm"> * We return the starting address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">map_elf</span><span class="p">(</span><span class="kt">int</span> <span class="n">elf_fd</span><span class="p">,</span> <span class="k">const</span> <span class="n">Elf32_Ehdr</span> <span class="o">*</span><span class="n">ehdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf32_Phdr</span> <span class="n">phdr</span><span class="p">[</span><span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sanity checks on the main ELF header: an x86 executable with a</span>
<span class="cm">	 * reasonable number of correctly-sized program headers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">!=</span> <span class="n">ET_EXEC</span>
	    <span class="o">||</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_machine</span> <span class="o">!=</span> <span class="n">EM_386</span>
	    <span class="o">||</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_phentsize</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf32_Phdr</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_phnum</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_phnum</span> <span class="o">&gt;</span> <span class="mi">65536U</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Elf32_Phdr</span><span class="p">))</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Malformed elf header&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * An ELF executable contains an ELF header and a number of &quot;program&quot;</span>
<span class="cm">	 * headers which indicate which parts (&quot;segments&quot;) of the program to</span>
<span class="cm">	 * load where.</span>
<span class="cm">	 */</span>

	<span class="cm">/* We read in all the program headers at once: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lseek</span><span class="p">(</span><span class="n">elf_fd</span><span class="p">,</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_phoff</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Seeking to program headers&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">elf_fd</span><span class="p">,</span> <span class="n">phdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">phdr</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">phdr</span><span class="p">))</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Reading program headers&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try all the headers: there are usually only three.  A read-only one,</span>
<span class="cm">	 * a read-write one, and a &quot;note&quot; section which we don&#39;t load.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If this isn&#39;t a loadable segment, we ignore it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_type</span> <span class="o">!=</span> <span class="n">PT_LOAD</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;Section %i: size %i addr %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span> <span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_memsz</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_paddr</span><span class="p">);</span>

		<span class="cm">/* We map this section of the file at its physical address. */</span>
		<span class="n">map_at</span><span class="p">(</span><span class="n">elf_fd</span><span class="p">,</span> <span class="n">from_guest_phys</span><span class="p">(</span><span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_paddr</span><span class="p">),</span>
		       <span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_offset</span><span class="p">,</span> <span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_filesz</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* The entry point is given in the ELF header. */</span>
	<span class="k">return</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*L:150</span>
<span class="cm"> * A bzImage, unlike an ELF file, is not meant to be loaded.  You&#39;re supposed</span>
<span class="cm"> * to jump into it and it will unpack itself.  We used to have to perform some</span>
<span class="cm"> * hairy magic because the unpacking code scared me.</span>
<span class="cm"> *</span>
<span class="cm"> * Fortunately, Jeremy Fitzhardinge convinced me it wasn&#39;t that hard and wrote</span>
<span class="cm"> * a small patch to jump over the tricky bits in the Guest, so now we just read</span>
<span class="cm"> * the funky header so we know where in the file to load, and away we go!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">load_bzimage</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">boot_params</span> <span class="n">boot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="cm">/* Modern bzImages get loaded at 1M. */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">from_guest_phys</span><span class="p">(</span><span class="mh">0x100000</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Go back to the start of the file and read the header.  It should be</span>
<span class="cm">	 * a Linux boot header (see Documentation/x86/boot.txt)</span>
<span class="cm">	 */</span>
	<span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
	<span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">boot</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">boot</span><span class="p">));</span>

	<span class="cm">/* Inside the setup_hdr, we expect the magic &quot;HdrS&quot; */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boot</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">header</span><span class="p">,</span> <span class="s">&quot;HdrS&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;This doesn&#39;t look like a bzImage to me&quot;</span><span class="p">);</span>

	<span class="cm">/* Skip over the extra sectors of the header. */</span>
	<span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="n">boot</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">setup_sects</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">512</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>

	<span class="cm">/* Now read everything into memory. in nice big chunks. */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">65536</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span>

	<span class="cm">/* Finally, code32_start tells us where to enter the kernel. */</span>
	<span class="k">return</span> <span class="n">boot</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">code32_start</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*L:140</span>
<span class="cm"> * Loading the kernel is easy when it&#39;s a &quot;vmlinux&quot;, but most kernels</span>
<span class="cm"> * come wrapped up in the self-decompressing &quot;bzImage&quot; format.  With a little</span>
<span class="cm"> * work, we can load those, too.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">load_kernel</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf32_Ehdr</span> <span class="n">hdr</span><span class="p">;</span>

	<span class="cm">/* Read in the first few bytes. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="p">))</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Reading kernel&quot;</span><span class="p">);</span>

	<span class="cm">/* If it&#39;s an ELF file, it starts with &quot;\177ELF&quot; */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">e_ident</span><span class="p">,</span> <span class="n">ELFMAG</span><span class="p">,</span> <span class="n">SELFMAG</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">map_elf</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="p">);</span>

	<span class="cm">/* Otherwise we assume it&#39;s a bzImage, and try to load it. */</span>
	<span class="k">return</span> <span class="n">load_bzimage</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is a trivial little helper to align pages.  Andi Kleen hated it because</span>
<span class="cm"> * it calls getpagesize() twice: &quot;it&#39;s dumb code.&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * Kernel guys get really het up about optimization, even when it&#39;s not</span>
<span class="cm"> * necessary.  I leave this code as a reaction against that.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">page_align</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Add upwards and truncate downwards. */</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">addr</span> <span class="o">+</span> <span class="n">getpagesize</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">getpagesize</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*L:180</span>
<span class="cm"> * An &quot;initial ram disk&quot; is a disk image loaded into memory along with the</span>
<span class="cm"> * kernel which the kernel can use to boot from without needing any drivers.</span>
<span class="cm"> * Most distributions now use this as standard: the initrd contains the code to</span>
<span class="cm"> * load the appropriate driver modules for the current machine.</span>
<span class="cm"> *</span>
<span class="cm"> * Importantly, James Morris works for RedHat, and Fedora uses initrds for its</span>
<span class="cm"> * kernels.  He sent me this (and tells me when I break it).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">load_initrd</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ifd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">ifd</span> <span class="o">=</span> <span class="n">open_or_die</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
	<span class="cm">/* fstat() is needed to get the file size. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fstat</span><span class="p">(</span><span class="n">ifd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;fstat() on initrd &#39;%s&#39;&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We map the initrd at the top of memory, but mmap wants it to be</span>
<span class="cm">	 * page-aligned, so we round the size up for that.</span>
<span class="cm">	 */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">page_align</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">st_size</span><span class="p">);</span>
	<span class="n">map_at</span><span class="p">(</span><span class="n">ifd</span><span class="p">,</span> <span class="n">from_guest_phys</span><span class="p">(</span><span class="n">mem</span> <span class="o">-</span> <span class="n">len</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">st</span><span class="p">.</span><span class="n">st_size</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Once a file is mapped, you can close the file descriptor.  It&#39;s a</span>
<span class="cm">	 * little odd, but quite useful.</span>
<span class="cm">	 */</span>
	<span class="n">close</span><span class="p">(</span><span class="n">ifd</span><span class="p">);</span>
	<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;mapped initrd %s size=%lu @ %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">mem</span><span class="o">-</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/* We return the initrd size. */</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*:*/</span>

<span class="cm">/*</span>
<span class="cm"> * Simple routine to roll all the commandline arguments together with spaces</span>
<span class="cm"> * between them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">concat</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">strcat</span><span class="p">(</span><span class="n">dst</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
			<span class="n">len</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">dst</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="cm">/* In case it&#39;s empty. */</span>
	<span class="n">dst</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*L:185</span>
<span class="cm"> * This is where we actually tell the kernel to initialize the Guest.  We</span>
<span class="cm"> * saw the arguments it expects when we looked at initialize() in lguest_user.c:</span>
<span class="cm"> * the base of Guest &quot;physical&quot; memory, the top physical page to allow and the</span>
<span class="cm"> * entry point for the Guest.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tell_kernel</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">LHREQ_INITIALIZE</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">guest_base</span><span class="p">,</span>
				 <span class="n">guest_limit</span> <span class="o">/</span> <span class="n">getpagesize</span><span class="p">(),</span> <span class="n">start</span> <span class="p">};</span>
	<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;Guest: %p - %p (%#lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">guest_base</span><span class="p">,</span> <span class="n">guest_base</span> <span class="o">+</span> <span class="n">guest_limit</span><span class="p">,</span> <span class="n">guest_limit</span><span class="p">);</span>
	<span class="n">lguest_fd</span> <span class="o">=</span> <span class="n">open_or_die</span><span class="p">(</span><span class="s">&quot;/dev/lguest&quot;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">lguest_fd</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Writing to /dev/lguest&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*:*/</span>

<span class="cm">/*L:200</span>
<span class="cm"> * Device Handling.</span>
<span class="cm"> *</span>
<span class="cm"> * When the Guest gives us a buffer, it sends an array of addresses and sizes.</span>
<span class="cm"> * We need to make sure it&#39;s not trying to reach into the Launcher itself, so</span>
<span class="cm"> * we have a convenient routine which checks it and exits with an error message</span>
<span class="cm"> * if something funny is going on:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">_check_pointer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check if the requested address and size exceeds the allocated memory,</span>
<span class="cm">	 * or addr + size wraps around.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">guest_limit</span> <span class="o">||</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">addr</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s:%i: Invalid address %#lx&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We return a pointer for the caller&#39;s convenience, now we know it&#39;s</span>
<span class="cm">	 * safe to use.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">from_guest_phys</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* A macro which transparently hands the line number to the real function. */</span>
<span class="cp">#define check_pointer(addr,size) _check_pointer(addr, size, __LINE__)</span>

<span class="cm">/*</span>
<span class="cm"> * Each buffer in the virtqueues is actually a chain of descriptors.  This</span>
<span class="cm"> * function returns the next descriptor in the chain, or vq-&gt;vring.num if we&#39;re</span>
<span class="cm"> * at the end.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">next_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">vring_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next</span><span class="p">;</span>

	<span class="cm">/* If this descriptor says it doesn&#39;t chain, we&#39;re done. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VRING_DESC_F_NEXT</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">max</span><span class="p">;</span>

	<span class="cm">/* Check they&#39;re not leading us off end of descriptors. */</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
	<span class="cm">/* Make sure compiler knows to grab that: we don&#39;t want it changing! */</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Desc next is %u&quot;</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This actually sends the interrupt for this virtqueue, if we&#39;ve used a</span>
<span class="cm"> * buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">trigger_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buf</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">LHREQ_IRQ</span><span class="p">,</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">irq</span> <span class="p">};</span>

	<span class="cm">/* Don&#39;t inform them if nothing used. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">pending_used</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">pending_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If they don&#39;t want an interrupt, don&#39;t send one... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">avail</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VRING_AVAIL_F_NO_INTERRUPT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Send the Guest an interrupt tell them we used something up. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">lguest_fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Triggering irq %i&quot;</span><span class="p">,</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This looks in the virtqueue for the first available buffer, and converts</span>
<span class="cm"> * it to an iovec for convenient access.  Since descriptors consist of some</span>
<span class="cm"> * number of output then some number of input descriptors, it&#39;s actually two</span>
<span class="cm"> * iovecs, but we pack them into one and note how many of each there were.</span>
<span class="cm"> *</span>
<span class="cm"> * This function waits if necessary, and returns the descriptor number found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">wait_for_vq_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">[],</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">out_num</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">in_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vring_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">last_avail</span> <span class="o">=</span> <span class="n">lg_last_avail</span><span class="p">(</span><span class="n">vq</span><span class="p">);</span>

	<span class="cm">/* There&#39;s nothing available? */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">last_avail</span> <span class="o">==</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">avail</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">event</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Since we&#39;re about to sleep, now is a good time to tell the</span>
<span class="cm">		 * Guest about what we&#39;ve used up to now.</span>
<span class="cm">		 */</span>
		<span class="n">trigger_irq</span><span class="p">(</span><span class="n">vq</span><span class="p">);</span>

		<span class="cm">/* OK, now we need to know about added descriptors. */</span>
		<span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">used</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VRING_USED_F_NO_NOTIFY</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * They could have slipped one in as we were doing that: make</span>
<span class="cm">		 * sure it&#39;s written, then check again.</span>
<span class="cm">		 */</span>
		<span class="n">mb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_avail</span> <span class="o">!=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">avail</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">used</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">VRING_USED_F_NO_NOTIFY</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Nothing new?  Wait for eventfd to tell us they refilled. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">eventfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
			<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Event read failed?&quot;</span><span class="p">);</span>

		<span class="cm">/* We don&#39;t need to be notified again. */</span>
		<span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">used</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">VRING_USED_F_NO_NOTIFY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check it isn&#39;t doing very strange things with descriptor numbers. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">u16</span><span class="p">)(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">avail</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">-</span> <span class="n">last_avail</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">num</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Guest moved used index from %u to %u&quot;</span><span class="p">,</span>
		     <span class="n">last_avail</span><span class="p">,</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">avail</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Grab the next descriptor number they&#39;re advertising, and increment</span>
<span class="cm">	 * the index we&#39;ve seen.</span>
<span class="cm">	 */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">avail</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">last_avail</span> <span class="o">%</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">num</span><span class="p">];</span>
	<span class="n">lg_last_avail</span><span class="p">(</span><span class="n">vq</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* If their number is silly, that&#39;s a fatal mistake. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">&gt;=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">num</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Guest says index %u is available&quot;</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

	<span class="cm">/* When we start there are none of either input nor output. */</span>
	<span class="o">*</span><span class="n">out_num</span> <span class="o">=</span> <span class="o">*</span><span class="n">in_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">max</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">num</span><span class="p">;</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">desc</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is an indirect entry, then this buffer contains a descriptor</span>
<span class="cm">	 * table which we handle as if it&#39;s any normal descriptor chain.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VRING_DESC_F_INDIRECT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vring_desc</span><span class="p">))</span>
			<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Invalid size for indirect buffer table&quot;</span><span class="p">);</span>

		<span class="n">max</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vring_desc</span><span class="p">);</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">check_pointer</span><span class="p">(</span><span class="n">desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">,</span> <span class="n">desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Grab the first descriptor, and check it&#39;s OK. */</span>
		<span class="n">iov</span><span class="p">[</span><span class="o">*</span><span class="n">out_num</span> <span class="o">+</span> <span class="o">*</span><span class="n">in_num</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
		<span class="n">iov</span><span class="p">[</span><span class="o">*</span><span class="n">out_num</span> <span class="o">+</span> <span class="o">*</span><span class="n">in_num</span><span class="p">].</span><span class="n">iov_base</span>
			<span class="o">=</span> <span class="n">check_pointer</span><span class="p">(</span><span class="n">desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">,</span> <span class="n">desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
		<span class="cm">/* If this is an input descriptor, increment that count. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VRING_DESC_F_WRITE</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">in_num</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If it&#39;s an output descriptor, they&#39;re all supposed</span>
<span class="cm">			 * to come before any input descriptors.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">in_num</span><span class="p">)</span>
				<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Descriptor has out after in&quot;</span><span class="p">);</span>
			<span class="p">(</span><span class="o">*</span><span class="n">out_num</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If we&#39;ve got too many, that implies a descriptor loop. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">out_num</span> <span class="o">+</span> <span class="o">*</span><span class="n">in_num</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
			<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Looped descriptor&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">next_desc</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">max</span><span class="p">))</span> <span class="o">!=</span> <span class="n">max</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * After we&#39;ve used one of their buffers, we tell the Guest about it.  Sometime</span>
<span class="cm"> * later we&#39;ll want to send them an interrupt using trigger_irq(); note that</span>
<span class="cm"> * wait_for_vq_desc() does that for us if it has to wait.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vring_used_elem</span> <span class="o">*</span><span class="n">used</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The virtqueue contains a ring of used buffers.  Get a pointer to the</span>
<span class="cm">	 * next entry in that used ring.</span>
<span class="cm">	 */</span>
	<span class="n">used</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">used</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">used</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">%</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">num</span><span class="p">];</span>
	<span class="n">used</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">used</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="cm">/* Make sure buffer is written before we update index. */</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">used</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">++</span><span class="p">;</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">pending_used</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* And here&#39;s the combo meal deal.  Supersize me! */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_used_and_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">add_used</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">trigger_irq</span><span class="p">(</span><span class="n">vq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The Console</span>
<span class="cm"> *</span>
<span class="cm"> * We associate some data with the console for our exit hack.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">console_abort</span> <span class="p">{</span>
	<span class="cm">/* How many times have they hit ^C? */</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="cm">/* When did they start? */</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">start</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* This is the routine which handles console input (ie. stdin). */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">console_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="n">in_num</span><span class="p">,</span> <span class="n">out_num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">console_abort</span> <span class="o">*</span><span class="n">abort</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">[</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">num</span><span class="p">];</span>

	<span class="cm">/* Make sure there&#39;s a descriptor available. */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">wait_for_vq_desc</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">out_num</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Output buffers in console in queue?&quot;</span><span class="p">);</span>

	<span class="cm">/* Read into it.  This is where we usually wait. */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">readv</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">in_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Ran out of input? */</span>
		<span class="n">warnx</span><span class="p">(</span><span class="s">&quot;Failed to get console input, ignoring console.&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * For simplicity, dying threads kill the whole Launcher.  So</span>
<span class="cm">		 * just nap here.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(;;)</span>
			<span class="n">pause</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Tell the Guest we used a buffer. */</span>
	<span class="n">add_used_and_trigger</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Three ^C within one second?  Exit.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is such a hack, but works surprisingly well.  Each ^C has to</span>
<span class="cm">	 * be in a buffer by itself, so they can&#39;t be too fast.  But we check</span>
<span class="cm">	 * that we get three within about a second, so they can&#39;t be too</span>
<span class="cm">	 * slow.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">iov</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">abort</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">abort</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">abort</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">abort</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">abort</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">timeval</span> <span class="n">now</span><span class="p">;</span>
		<span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/* Kill all Launcher processes with SIGINT, like normal ^C */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">&lt;=</span> <span class="n">abort</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">.</span><span class="n">tv_sec</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">kill</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">);</span>
		<span class="n">abort</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This is the routine which handles console output (ie. stdout). */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">console_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">in</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">[</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">num</span><span class="p">];</span>

	<span class="cm">/* We usually wait in here, for the Guest to give us something. */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">wait_for_vq_desc</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Input buffers in console output queue?&quot;</span><span class="p">);</span>

	<span class="cm">/* writev can return a partial write, so we loop here. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">iov_empty</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">out</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">writev</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">warn</span><span class="p">(</span><span class="s">&quot;Write to stdout gave %i (%d)&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iov_consume</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re finished with that buffer: if we&#39;re going to sleep,</span>
<span class="cm">	 * wait_for_vq_desc() will prod the Guest with an interrupt.</span>
<span class="cm">	 */</span>
	<span class="n">add_used</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The Network</span>
<span class="cm"> *</span>
<span class="cm"> * Handling output for network is also simple: we get all the output buffers</span>
<span class="cm"> * and write them to /dev/net/tun.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">net_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">tunfd</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">net_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_info</span> <span class="o">*</span><span class="n">net_info</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">in</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">[</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">num</span><span class="p">];</span>

	<span class="cm">/* We usually wait in here for the Guest to give us a packet. */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">wait_for_vq_desc</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Input buffers in net output queue?&quot;</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Send the whole thing through to /dev/net/tun.  It expects the exact</span>
<span class="cm">	 * same format: what a coincidence!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">writev</span><span class="p">(</span><span class="n">net_info</span><span class="o">-&gt;</span><span class="n">tunfd</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">warnx</span><span class="p">(</span><span class="s">&quot;Write to tun failed (%d)?&quot;</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Done with that one; wait_for_vq_desc() will send the interrupt if</span>
<span class="cm">	 * all packets are processed.</span>
<span class="cm">	 */</span>
	<span class="n">add_used</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handling network input is a bit trickier, because I&#39;ve tried to optimize it.</span>
<span class="cm"> *</span>
<span class="cm"> * First we have a helper routine which tells is if from this file descriptor</span>
<span class="cm"> * (ie. the /dev/net/tun device) will block:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">will_block</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fd_set</span> <span class="n">fdset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">zero</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdset</span><span class="p">);</span>
	<span class="n">FD_SET</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdset</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">select</span><span class="p">(</span><span class="n">fd</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdset</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zero</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This handles packets coming in from the tun device to our Guest.  Like all</span>
<span class="cm"> * service routines, it gets called again as soon as it returns, so you don&#39;t</span>
<span class="cm"> * see a while(1) loop here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">net_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">in</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">[</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">num</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">net_info</span> <span class="o">*</span><span class="n">net_info</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get a descriptor to write an incoming packet into.  This will also</span>
<span class="cm">	 * send an interrupt if they&#39;re out of descriptors.</span>
<span class="cm">	 */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">wait_for_vq_desc</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Output buffers in net input queue?&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If it looks like we&#39;ll block reading from the tun device, send them</span>
<span class="cm">	 * an interrupt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">pending_used</span> <span class="o">&amp;&amp;</span> <span class="n">will_block</span><span class="p">(</span><span class="n">net_info</span><span class="o">-&gt;</span><span class="n">tunfd</span><span class="p">))</span>
		<span class="n">trigger_irq</span><span class="p">(</span><span class="n">vq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read in the packet.  This is where we normally wait (when there&#39;s no</span>
<span class="cm">	 * incoming network traffic).</span>
<span class="cm">	 */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">readv</span><span class="p">(</span><span class="n">net_info</span><span class="o">-&gt;</span><span class="n">tunfd</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">in</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">warn</span><span class="p">(</span><span class="s">&quot;Failed to read from tun (%d).&quot;</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mark that packet buffer as used, but don&#39;t interrupt here.  We want</span>
<span class="cm">	 * to wait until we&#39;ve done as much work as we can.</span>
<span class="cm">	 */</span>
	<span class="n">add_used</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*:*/</span>

<span class="cm">/* This is the helper to create threads: run the service routine in a loop. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_vq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span> <span class="o">=</span> <span class="n">_vq</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span>
		<span class="n">vq</span><span class="o">-&gt;</span><span class="n">service</span><span class="p">(</span><span class="n">vq</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When a child dies, we kill our entire process group with SIGTERM.  This</span>
<span class="cm"> * also has the side effect that the shell restores the console for us!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kill_launcher</span><span class="p">(</span><span class="kt">int</span> <span class="n">signal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kill</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">;</span>

	<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;Resetting device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* Clear any features they&#39;ve acked. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">get_feature_bits</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">+</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">feature_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">feature_len</span><span class="p">);</span>

	<span class="cm">/* We&#39;re going to be explicitly killing threads, so ignore them. */</span>
	<span class="n">signal</span><span class="p">(</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">);</span>

	<span class="cm">/* Zero out the virtqueues, get rid of their threads */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vq</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vq</span><span class="p">;</span> <span class="n">vq</span><span class="p">;</span> <span class="n">vq</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">!=</span> <span class="p">(</span><span class="n">pid_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kill</span><span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span>
			<span class="n">waitpid</span><span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">vq</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="p">(</span><span class="n">pid_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="n">vring_size</span><span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">num</span><span class="p">,</span> <span class="n">LGUEST_VRING_ALIGN</span><span class="p">));</span>
		<span class="n">lg_last_avail</span><span class="p">(</span><span class="n">vq</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Now we care if threads die. */</span>
	<span class="n">signal</span><span class="p">(</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">kill_launcher</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*L:216</span>
<span class="cm"> * This actually creates the thread which services the virtqueue for a device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">create_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Create stack for thread.  Since the stack grows upwards, we point</span>
<span class="cm">	 * the stack pointer to the end of this region.</span>
<span class="cm">	 */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">stack</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">32768</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">LHREQ_EVENTFD</span><span class="p">,</span>
				 <span class="n">vq</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">pfn</span><span class="o">*</span><span class="n">getpagesize</span><span class="p">(),</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="cm">/* Create a zero-initialized eventfd. */</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">eventfd</span> <span class="o">=</span> <span class="n">eventfd</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">eventfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Creating eventfd&quot;</span><span class="p">);</span>
	<span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">eventfd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Attach an eventfd to this virtqueue: it will go off when the Guest</span>
<span class="cm">	 * does an LHCALL_NOTIFY for this vq.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">lguest_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Attaching eventfd&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * CLONE_VM: because it has to access the Guest memory, and SIGCHLD so</span>
<span class="cm">	 * we get a signal if it dies.</span>
<span class="cm">	 */</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="n">do_thread</span><span class="p">,</span> <span class="n">stack</span> <span class="o">+</span> <span class="mi">32768</span><span class="p">,</span> <span class="n">CLONE_VM</span> <span class="o">|</span> <span class="n">SIGCHLD</span><span class="p">,</span> <span class="n">vq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">==</span> <span class="p">(</span><span class="n">pid_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Creating clone&quot;</span><span class="p">);</span>

	<span class="cm">/* We close our local copy now the child has it. */</span>
	<span class="n">close</span><span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">eventfd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">;</span>

	<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;Device %s OK: offered&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">feature_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">verbose</span><span class="p">(</span><span class="s">&quot; %02x&quot;</span><span class="p">,</span> <span class="n">get_feature_bits</span><span class="p">(</span><span class="n">dev</span><span class="p">)[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;, accepted&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">feature_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">verbose</span><span class="p">(</span><span class="s">&quot; %02x&quot;</span><span class="p">,</span> <span class="n">get_feature_bits</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
			<span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">feature_len</span><span class="o">+</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">vq</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vq</span><span class="p">;</span> <span class="n">vq</span><span class="p">;</span> <span class="n">vq</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">service</span><span class="p">)</span>
			<span class="n">create_thread</span><span class="p">(</span><span class="n">vq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup_devices</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">dev</span> <span class="o">=</span> <span class="n">devices</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span> <span class="n">dev</span><span class="p">;</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="n">reset_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* If we saved off the original terminal settings, restore them now. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">orig_term</span><span class="p">.</span><span class="n">c_lflag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ISIG</span><span class="o">|</span><span class="n">ICANON</span><span class="o">|</span><span class="n">ECHO</span><span class="p">))</span>
		<span class="n">tcsetattr</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">TCSANOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_term</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* When the Guest tells us they updated the status field, we handle it. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_device_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* A zero status is a reset, otherwise it&#39;s a set of flags. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">reset_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">VIRTIO_CONFIG_S_FAILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">warnx</span><span class="p">(</span><span class="s">&quot;Device %s configuration FAILED&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span>
			<span class="n">reset_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span>
			<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Device %s features finalized twice&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">start_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*L:215</span>
<span class="cm"> * This is the generic routine we call when the Guest uses LHCALL_NOTIFY.  In</span>
<span class="cm"> * particular, it&#39;s used to notify us of device status changes during boot.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_output</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Check each device. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">devices</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span> <span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Notifications to device descriptors mean they updated the</span>
<span class="cm">		 * device status.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">from_guest_phys</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">update_device_status</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Devices should not be used before features are finalized. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">vq</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">vq</span><span class="p">;</span> <span class="n">vq</span><span class="p">;</span> <span class="n">vq</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">pfn</span><span class="o">*</span><span class="n">getpagesize</span><span class="p">())</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Notification on %s before setup!&quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Early console write is done using notify on a nul-terminated string</span>
<span class="cm">	 * in Guest memory.  It&#39;s also great for hacking debugging messages</span>
<span class="cm">	 * into a Guest.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">guest_limit</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Bad NOTIFY %#lx&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">from_guest_phys</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span>
	      <span class="n">strnlen</span><span class="p">(</span><span class="n">from_guest_phys</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="n">guest_limit</span> <span class="o">-</span> <span class="n">addr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*L:190</span>
<span class="cm"> * Device Setup</span>
<span class="cm"> *</span>
<span class="cm"> * All devices need a descriptor so the Guest knows it exists, and a &quot;struct</span>
<span class="cm"> * device&quot; so the Launcher can keep track of it.  We have common helper</span>
<span class="cm"> * routines to allocate and manage them.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The layout of the device page is a &quot;struct lguest_device_desc&quot; followed by a</span>
<span class="cm"> * number of virtqueue descriptors, then two sets of feature bits, then an</span>
<span class="cm"> * array of configuration bytes.  This routine returns the configuration</span>
<span class="cm"> * pointer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="o">*</span><span class="nf">device_config</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">+</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_vq</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lguest_vqconfig</span><span class="p">)</span>
		<span class="o">+</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">feature_len</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine allocates a new &quot;struct lguest_device_desc&quot; from descriptor</span>
<span class="cm"> * table page just above the Guest&#39;s normal memory.  It returns a pointer to</span>
<span class="cm"> * that descriptor.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lguest_device_desc</span> <span class="o">*</span><span class="nf">new_dev_desc</span><span class="p">(</span><span class="n">u16</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lguest_device_desc</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span> <span class="p">};</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/* Figure out where the next device config is, based on the last one. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devices</span><span class="p">.</span><span class="n">lastdev</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">device_config</span><span class="p">(</span><span class="n">devices</span><span class="p">.</span><span class="n">lastdev</span><span class="p">)</span>
			<span class="o">+</span> <span class="n">devices</span><span class="p">.</span><span class="n">lastdev</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">config_len</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">devices</span><span class="p">.</span><span class="n">descpage</span><span class="p">;</span>

	<span class="cm">/* We only have one page for all the descriptors. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">devices</span><span class="p">.</span><span class="n">descpage</span> <span class="o">+</span> <span class="n">getpagesize</span><span class="p">())</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Too many devices&quot;</span><span class="p">);</span>

	<span class="cm">/* p might not be aligned, so we memcpy in. */</span>
	<span class="k">return</span> <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Each device descriptor is followed by the description of its virtqueues.  We</span>
<span class="cm"> * specify how many descriptors the virtqueue is to have.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_virtqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_descs</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">service</span><span class="p">)(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">**</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">vq</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vq</span><span class="p">));</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/* First we need some memory for this virtqueue. */</span>
	<span class="n">pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">vring_size</span><span class="p">(</span><span class="n">num_descs</span><span class="p">,</span> <span class="n">LGUEST_VRING_ALIGN</span><span class="p">)</span> <span class="o">+</span> <span class="n">getpagesize</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">/</span> <span class="n">getpagesize</span><span class="p">();</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">get_pages</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>

	<span class="cm">/* Initialize the virtqueue */</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">last_avail_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is the routine the service thread will run, and its Process ID</span>
<span class="cm">	 * once it&#39;s running.</span>
<span class="cm">	 */</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">service</span> <span class="o">=</span> <span class="n">service</span><span class="p">;</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="p">(</span><span class="n">pid_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Initialize the configuration. */</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">num_descs</span><span class="p">;</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">devices</span><span class="p">.</span><span class="n">next_irq</span><span class="o">++</span><span class="p">;</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">to_guest_phys</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">getpagesize</span><span class="p">();</span>

	<span class="cm">/* Initialize the vring. */</span>
	<span class="n">vring_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">,</span> <span class="n">num_descs</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">LGUEST_VRING_ALIGN</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Append virtqueue to this device&#39;s descriptor.  We use</span>
<span class="cm">	 * device_config() to get the end of the device&#39;s current virtqueues;</span>
<span class="cm">	 * we check that we haven&#39;t added any config or feature information</span>
<span class="cm">	 * yet, otherwise we&#39;d be overwriting them.</span>
<span class="cm">	 */</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">config_len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">feature_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">device_config</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">));</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_vq</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">num_vq</span><span class="o">++</span><span class="p">;</span>

	<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;Virtqueue page %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">to_guest_phys</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add to tail of list, so dev-&gt;vq is first vq, dev-&gt;vq-&gt;next is</span>
<span class="cm">	 * second.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vq</span><span class="p">;</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
	<span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">vq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The first half of the feature bitmask is for us to advertise features.  The</span>
<span class="cm"> * second half is for the Guest to accept features.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_feature</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">features</span> <span class="o">=</span> <span class="n">get_feature_bits</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* We can&#39;t extend the feature bits once we&#39;ve added config bytes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">feature_len</span> <span class="o">&lt;=</span> <span class="n">bit</span> <span class="o">/</span> <span class="n">CHAR_BIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">assert</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">config_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">feature_len</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">feature_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">bit</span><span class="o">/</span><span class="n">CHAR_BIT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">features</span><span class="p">[</span><span class="n">bit</span> <span class="o">/</span> <span class="n">CHAR_BIT</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bit</span> <span class="o">%</span> <span class="n">CHAR_BIT</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine sets the configuration fields for an existing device&#39;s</span>
<span class="cm"> * descriptor.  It only works for the last device, but that&#39;s OK because that&#39;s</span>
<span class="cm"> * how we use it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">conf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Check we haven&#39;t overflowed our single page. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_config</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">devices</span><span class="p">.</span><span class="n">descpage</span> <span class="o">+</span> <span class="n">getpagesize</span><span class="p">())</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Too many devices&quot;</span><span class="p">);</span>

	<span class="cm">/* Copy in the config information, and store the length. */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">device_config</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">conf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">config_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* Size must fit in config_len field (8 bits)! */</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">config_len</span> <span class="o">==</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine does all the creation and setup of a new device, including</span>
<span class="cm"> * calling new_dev_desc() to allocate the descriptor and device memory.  We</span>
<span class="cm"> * don&#39;t actually start the service threads until later.</span>
<span class="cm"> *</span>
<span class="cm"> * See what I mean about userspace being boring?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">new_device</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">u16</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dev</span><span class="p">));</span>

	<span class="cm">/* Now we populate the fields one at a time. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">new_dev_desc</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">feature_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_vq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Append to device list.  Prepending to a single-linked list is</span>
<span class="cm">	 * easier, but the user expects the devices to be arranged on the bus</span>
<span class="cm">	 * in command-line order.  The first network device on the command line</span>
<span class="cm">	 * is eth0, the first block device /dev/vda, etc.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devices</span><span class="p">.</span><span class="n">lastdev</span><span class="p">)</span>
		<span class="n">devices</span><span class="p">.</span><span class="n">lastdev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">devices</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">devices</span><span class="p">.</span><span class="n">lastdev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Our first setup routine is the console.  It&#39;s a fairly simple device, but</span>
<span class="cm"> * UNIX tty handling makes it uglier than it could be.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_console</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* If we can save the initial standard input settings... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcgetattr</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_term</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">termios</span> <span class="n">term</span> <span class="o">=</span> <span class="n">orig_term</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Then we turn off echo, line buffering and ^C etc: We want a</span>
<span class="cm">		 * raw input stream to the Guest.</span>
<span class="cm">		 */</span>
		<span class="n">term</span><span class="p">.</span><span class="n">c_lflag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ISIG</span><span class="o">|</span><span class="n">ICANON</span><span class="o">|</span><span class="n">ECHO</span><span class="p">);</span>
		<span class="n">tcsetattr</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">TCSANOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">new_device</span><span class="p">(</span><span class="s">&quot;console&quot;</span><span class="p">,</span> <span class="n">VIRTIO_ID_CONSOLE</span><span class="p">);</span>

	<span class="cm">/* We store the console state in dev-&gt;priv, and initialize it. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">console_abort</span><span class="p">));</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">console_abort</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The console needs two virtqueues: the input then the output.  When</span>
<span class="cm">	 * they put something the input queue, we make sure we&#39;re listening to</span>
<span class="cm">	 * stdin.  When they put something in the output queue, we write it to</span>
<span class="cm">	 * stdout.</span>
<span class="cm">	 */</span>
	<span class="n">add_virtqueue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTQUEUE_NUM</span><span class="p">,</span> <span class="n">console_input</span><span class="p">);</span>
	<span class="n">add_virtqueue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTQUEUE_NUM</span><span class="p">,</span> <span class="n">console_output</span><span class="p">);</span>

	<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;device %u: console</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">++</span><span class="n">devices</span><span class="p">.</span><span class="n">device_num</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*:*/</span>

<span class="cm">/*M:010</span>
<span class="cm"> * Inter-guest networking is an interesting area.  Simplest is to have a</span>
<span class="cm"> * --sharenet=&lt;name&gt; option which opens or creates a named pipe.  This can be</span>
<span class="cm"> * used to send packets to another guest in a 1:1 manner.</span>
<span class="cm"> *</span>
<span class="cm"> * More sophisticated is to use one of the tools developed for project like UML</span>
<span class="cm"> * to do networking.</span>
<span class="cm"> *</span>
<span class="cm"> * Faster is to do virtio bonding in kernel.  Doing this 1:1 would be</span>
<span class="cm"> * completely generic (&quot;here&#39;s my vring, attach to your vring&quot;) and would work</span>
<span class="cm"> * for any traffic.  Of course, namespace and permissions issues need to be</span>
<span class="cm"> * dealt with.  A more sophisticated &quot;multi-channel&quot; virtio_net.c could hide</span>
<span class="cm"> * multiple inter-guest channels behind one interface, although it would</span>
<span class="cm"> * require some manner of hotplugging new virtio channels.</span>
<span class="cm"> *</span>
<span class="cm"> * Finally, we could use a virtio network switch in the kernel, ie. vhost.</span>
<span class="cm">:*/</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">str2ip</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ipaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">ipaddr</span><span class="p">,</span> <span class="s">&quot;%u.%u.%u.%u&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Failed to parse IP address &#39;%s&#39;&quot;</span><span class="p">,</span> <span class="n">ipaddr</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">str2mac</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">macaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mac</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">macaddr</span><span class="p">,</span> <span class="s">&quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;</span><span class="p">,</span>
		   <span class="o">&amp;</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Failed to parse mac address &#39;%s&#39;&quot;</span><span class="p">,</span> <span class="n">macaddr</span><span class="p">);</span>
	<span class="n">mac</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">mac</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">mac</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">mac</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">mac</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">mac</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This code is &quot;adapted&quot; from libbridge: it attaches the Host end of the</span>
<span class="cm"> * network device to the bridge device specified by the command line.</span>
<span class="cm"> *</span>
<span class="cm"> * This is yet another James Morris contribution (I&#39;m an IP-level guy, so I</span>
<span class="cm"> * dislike bridging), and I just try not to break it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_to_bridge</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">if_name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">br_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ifidx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">ifr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">br_name</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;must specify bridge name&quot;</span><span class="p">);</span>

	<span class="n">ifidx</span> <span class="o">=</span> <span class="n">if_nametoindex</span><span class="p">(</span><span class="n">if_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ifidx</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;interface %s does not exist!&quot;</span><span class="p">,</span> <span class="n">if_name</span><span class="p">);</span>

	<span class="n">strncpy</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">,</span> <span class="n">br_name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>
	<span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">ifr</span><span class="p">.</span><span class="n">ifr_ifindex</span> <span class="o">=</span> <span class="n">ifidx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">SIOCBRADDIF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;can&#39;t add %s to bridge %s&quot;</span><span class="p">,</span> <span class="n">if_name</span><span class="p">,</span> <span class="n">br_name</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This sets up the Host end of the network device with an IP address, brings</span>
<span class="cm"> * it up so packets will flow, the copies the MAC address into the hwaddr</span>
<span class="cm"> * pointer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">configure_device</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tapif</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ipaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">ifr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">sin</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ifr</span><span class="p">));</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">,</span> <span class="n">tapif</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t read these incantations.  Just cut &amp; paste them like I did! */</span>
	<span class="n">sin</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">sin</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">ipaddr</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sin</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sin</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">SIOCSIFADDR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Setting %s interface address&quot;</span><span class="p">,</span> <span class="n">tapif</span><span class="p">);</span>
	<span class="n">ifr</span><span class="p">.</span><span class="n">ifr_flags</span> <span class="o">=</span> <span class="n">IFF_UP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">SIOCSIFFLAGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Bringing interface %s up&quot;</span><span class="p">,</span> <span class="n">tapif</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_tun_device</span><span class="p">(</span><span class="kt">char</span> <span class="n">tapif</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">ifr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">netfd</span><span class="p">;</span>

	<span class="cm">/* Start with this zeroed.  Messy but sure. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ifr</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * We open the /dev/net/tun device and tell it we want a tap device.  A</span>
<span class="cm">	 * tap device is like a tun device, only somehow different.  To tell</span>
<span class="cm">	 * the truth, I completely blundered my way through this code, but it</span>
<span class="cm">	 * works now!</span>
<span class="cm">	 */</span>
	<span class="n">netfd</span> <span class="o">=</span> <span class="n">open_or_die</span><span class="p">(</span><span class="s">&quot;/dev/net/tun&quot;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
	<span class="n">ifr</span><span class="p">.</span><span class="n">ifr_flags</span> <span class="o">=</span> <span class="n">IFF_TAP</span> <span class="o">|</span> <span class="n">IFF_NO_PI</span> <span class="o">|</span> <span class="n">IFF_VNET_HDR</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">,</span> <span class="s">&quot;tap%d&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">netfd</span><span class="p">,</span> <span class="n">TUNSETIFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;configuring /dev/net/tun&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">netfd</span><span class="p">,</span> <span class="n">TUNSETOFFLOAD</span><span class="p">,</span>
		  <span class="n">TUN_F_CSUM</span><span class="o">|</span><span class="n">TUN_F_TSO4</span><span class="o">|</span><span class="n">TUN_F_TSO6</span><span class="o">|</span><span class="n">TUN_F_TSO_ECN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Could not set features for tun device&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t need checksums calculated for packets coming in this</span>
<span class="cm">	 * device: trust us!</span>
<span class="cm">	 */</span>
	<span class="n">ioctl</span><span class="p">(</span><span class="n">netfd</span><span class="p">,</span> <span class="n">TUNSETNOCSUM</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">tapif</span><span class="p">,</span> <span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">netfd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*L:195</span>
<span class="cm"> * Our network is a Host&lt;-&gt;Guest network.  This can either use bridging or</span>
<span class="cm"> * routing, but the principle is the same: it uses the &quot;tun&quot; device to inject</span>
<span class="cm"> * packets into the Host as if they came in from a normal network card.  We</span>
<span class="cm"> * just shunt packets between the Guest and the tun device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_tun_net</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_info</span> <span class="o">*</span><span class="n">net_info</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">net_info</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">ipfd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">INADDR_ANY</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bridging</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tapif</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">],</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtio_net_config</span> <span class="n">conf</span><span class="p">;</span>

	<span class="n">net_info</span><span class="o">-&gt;</span><span class="n">tunfd</span> <span class="o">=</span> <span class="n">get_tun_device</span><span class="p">(</span><span class="n">tapif</span><span class="p">);</span>

	<span class="cm">/* First we create a new network device. */</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">new_device</span><span class="p">(</span><span class="s">&quot;net&quot;</span><span class="p">,</span> <span class="n">VIRTIO_ID_NET</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">net_info</span><span class="p">;</span>

	<span class="cm">/* Network devices need a recv and a send queue, just like console. */</span>
	<span class="n">add_virtqueue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTQUEUE_NUM</span><span class="p">,</span> <span class="n">net_input</span><span class="p">);</span>
	<span class="n">add_virtqueue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTQUEUE_NUM</span><span class="p">,</span> <span class="n">net_output</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need a socket to perform the magic network ioctls to bring up the</span>
<span class="cm">	 * tap interface, connect to the bridge etc.  Any socket will do!</span>
<span class="cm">	 */</span>
	<span class="n">ipfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="n">IPPROTO_IP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;opening IP socket&quot;</span><span class="p">);</span>

	<span class="cm">/* If the command line was --tunnet=bridge:&lt;name&gt; do bridging. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">BRIDGE_PFX</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">BRIDGE_PFX</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">arg</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">BRIDGE_PFX</span><span class="p">);</span>
		<span class="n">bridging</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* A mac address may follow the bridge name or IP address */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">str2mac</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">conf</span><span class="p">.</span><span class="n">mac</span><span class="p">);</span>
		<span class="n">add_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTIO_NET_F_MAC</span><span class="p">);</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* arg is now either an IP address or a bridge name */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bridging</span><span class="p">)</span>
		<span class="n">add_to_bridge</span><span class="p">(</span><span class="n">ipfd</span><span class="p">,</span> <span class="n">tapif</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ip</span> <span class="o">=</span> <span class="n">str2ip</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>

	<span class="cm">/* Set up the tun device. */</span>
	<span class="n">configure_device</span><span class="p">(</span><span class="n">ipfd</span><span class="p">,</span> <span class="n">tapif</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

	<span class="cm">/* Expect Guest to handle everything except UFO */</span>
	<span class="n">add_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTIO_NET_F_CSUM</span><span class="p">);</span>
	<span class="n">add_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTIO_NET_F_GUEST_CSUM</span><span class="p">);</span>
	<span class="n">add_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTIO_NET_F_GUEST_TSO4</span><span class="p">);</span>
	<span class="n">add_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTIO_NET_F_GUEST_TSO6</span><span class="p">);</span>
	<span class="n">add_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTIO_NET_F_GUEST_ECN</span><span class="p">);</span>
	<span class="n">add_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTIO_NET_F_HOST_TSO4</span><span class="p">);</span>
	<span class="n">add_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTIO_NET_F_HOST_TSO6</span><span class="p">);</span>
	<span class="n">add_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTIO_NET_F_HOST_ECN</span><span class="p">);</span>
	<span class="cm">/* We handle indirect ring entries */</span>
	<span class="n">add_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTIO_RING_F_INDIRECT_DESC</span><span class="p">);</span>
	<span class="n">set_config</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">conf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>

	<span class="cm">/* We don&#39;t need the socket any more; setup is done. */</span>
	<span class="n">close</span><span class="p">(</span><span class="n">ipfd</span><span class="p">);</span>

	<span class="n">devices</span><span class="p">.</span><span class="n">device_num</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bridging</span><span class="p">)</span>
		<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;device %u: tun %s attached to bridge: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">devices</span><span class="p">.</span><span class="n">device_num</span><span class="p">,</span> <span class="n">tapif</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;device %u: tun %s: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">devices</span><span class="p">.</span><span class="n">device_num</span><span class="p">,</span> <span class="n">tapif</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*:*/</span>

<span class="cm">/* This hangs off device-&gt;priv. */</span>
<span class="k">struct</span> <span class="n">vblk_info</span> <span class="p">{</span>
	<span class="cm">/* The size of the file. */</span>
	<span class="n">off64_t</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* The file descriptor for the file. */</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

<span class="p">};</span>

<span class="cm">/*L:210</span>
<span class="cm"> * The Disk</span>
<span class="cm"> *</span>
<span class="cm"> * The disk only has one virtqueue, so it only has one thread.  It is really</span>
<span class="cm"> * simple: the Guest asks for a block number and we read or write that position</span>
<span class="cm"> * in the file.</span>
<span class="cm"> *</span>
<span class="cm"> * Before we serviced each virtqueue in a separate thread, that was unacceptably</span>
<span class="cm"> * slow: the Guest waits until the read is finished before running anything</span>
<span class="cm"> * else, even if it could have been doing useful work.</span>
<span class="cm"> *</span>
<span class="cm"> * We could have used async I/O, except it&#39;s reputed to suck so hard that</span>
<span class="cm"> * characters actually go missing from your code when you try to use it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">blk_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vblk_info</span> <span class="o">*</span><span class="n">vblk</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="n">out_num</span><span class="p">,</span> <span class="n">in_num</span><span class="p">,</span> <span class="n">wlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">in</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtio_blk_outhdr</span> <span class="o">*</span><span class="n">out</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">[</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">num</span><span class="p">];</span>
	<span class="n">off64_t</span> <span class="n">off</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the next request, where we normally wait.  It triggers the</span>
<span class="cm">	 * interrupt to acknowledge previously serviced requests (if any).</span>
<span class="cm">	 */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">wait_for_vq_desc</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in_num</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Every block request should contain at least one output buffer</span>
<span class="cm">	 * (detailing the location on disk and the type of request) and one</span>
<span class="cm">	 * input buffer (to hold the result).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">out_num</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">in_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Bad virtblk cmd %u out=%u in=%u&quot;</span><span class="p">,</span>
		     <span class="n">head</span><span class="p">,</span> <span class="n">out_num</span><span class="p">,</span> <span class="n">in_num</span><span class="p">);</span>

	<span class="n">out</span> <span class="o">=</span> <span class="n">convert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iov</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">struct</span> <span class="n">virtio_blk_outhdr</span><span class="p">);</span>
	<span class="n">in</span> <span class="o">=</span> <span class="n">convert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iov</span><span class="p">[</span><span class="n">out_num</span><span class="o">+</span><span class="n">in_num</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">u8</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * For historical reasons, block operations are expressed in 512 byte</span>
<span class="cm">	 * &quot;sectors&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">off</span> <span class="o">=</span> <span class="n">out</span><span class="o">-&gt;</span><span class="n">sector</span> <span class="o">*</span> <span class="mi">512</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In general the virtio block driver is allowed to try SCSI commands.</span>
<span class="cm">	 * It&#39;d be nice if we supported eject, for example, but we don&#39;t.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">VIRTIO_BLK_T_SCSI_CMD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Scsi commands unsupported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="n">in</span> <span class="o">=</span> <span class="n">VIRTIO_BLK_S_UNSUPP</span><span class="p">;</span>
		<span class="n">wlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">VIRTIO_BLK_T_OUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Write</span>
<span class="cm">		 *</span>
<span class="cm">		 * Move to the right location in the block file.  This can fail</span>
<span class="cm">		 * if they try to write past end.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lseek64</span><span class="p">(</span><span class="n">vblk</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">)</span> <span class="o">!=</span> <span class="n">off</span><span class="p">)</span>
			<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Bad seek to sector %llu&quot;</span><span class="p">,</span> <span class="n">out</span><span class="o">-&gt;</span><span class="n">sector</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">writev</span><span class="p">(</span><span class="n">vblk</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">iov</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">out_num</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;WRITE to sector %llu: %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">out</span><span class="o">-&gt;</span><span class="n">sector</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Grr... Now we know how long the descriptor they sent was, we</span>
<span class="cm">		 * make sure they didn&#39;t try to write over the end of the block</span>
<span class="cm">		 * file (possibly extending it).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">off</span> <span class="o">+</span> <span class="n">ret</span> <span class="o">&gt;</span> <span class="n">vblk</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Trim it back to the correct length */</span>
			<span class="n">ftruncate64</span><span class="p">(</span><span class="n">vblk</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">vblk</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="cm">/* Die, bad Guest, die. */</span>
			<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Write past end %llu+%u&quot;</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">wlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">);</span>
		<span class="o">*</span><span class="n">in</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">VIRTIO_BLK_S_OK</span> <span class="o">:</span> <span class="n">VIRTIO_BLK_S_IOERR</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">VIRTIO_BLK_T_FLUSH</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Flush */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">fdatasync</span><span class="p">(</span><span class="n">vblk</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>
		<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;FLUSH fdatasync: %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">wlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">);</span>
		<span class="o">*</span><span class="n">in</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">VIRTIO_BLK_S_OK</span> <span class="o">:</span> <span class="n">VIRTIO_BLK_S_IOERR</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Read</span>
<span class="cm">		 *</span>
<span class="cm">		 * Move to the right location in the block file.  This can fail</span>
<span class="cm">		 * if they try to read past end.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lseek64</span><span class="p">(</span><span class="n">vblk</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">)</span> <span class="o">!=</span> <span class="n">off</span><span class="p">)</span>
			<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Bad seek to sector %llu&quot;</span><span class="p">,</span> <span class="n">out</span><span class="o">-&gt;</span><span class="n">sector</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">readv</span><span class="p">(</span><span class="n">vblk</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">iov</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">in_num</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;READ from sector %llu: %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">out</span><span class="o">-&gt;</span><span class="n">sector</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">)</span> <span class="o">+</span> <span class="n">ret</span><span class="p">;</span>
			<span class="o">*</span><span class="n">in</span> <span class="o">=</span> <span class="n">VIRTIO_BLK_S_OK</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">wlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">);</span>
			<span class="o">*</span><span class="n">in</span> <span class="o">=</span> <span class="n">VIRTIO_BLK_S_IOERR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Finished that request. */</span>
	<span class="n">add_used</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">wlen</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*L:198 This actually sets up a virtual block device. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_block_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vblk_info</span> <span class="o">*</span><span class="n">vblk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtio_blk_config</span> <span class="n">conf</span><span class="p">;</span>

	<span class="cm">/* Creat the device. */</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">new_device</span><span class="p">(</span><span class="s">&quot;block&quot;</span><span class="p">,</span> <span class="n">VIRTIO_ID_BLOCK</span><span class="p">);</span>

	<span class="cm">/* The device has one virtqueue, where the Guest places requests. */</span>
	<span class="n">add_virtqueue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTQUEUE_NUM</span><span class="p">,</span> <span class="n">blk_request</span><span class="p">);</span>

	<span class="cm">/* Allocate the room for our own bookkeeping */</span>
	<span class="n">vblk</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vblk</span><span class="p">));</span>

	<span class="cm">/* First we open the file and store the length. */</span>
	<span class="n">vblk</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">open_or_die</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="o">|</span><span class="n">O_LARGEFILE</span><span class="p">);</span>
	<span class="n">vblk</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">lseek64</span><span class="p">(</span><span class="n">vblk</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_END</span><span class="p">);</span>

	<span class="cm">/* We support FLUSH. */</span>
	<span class="n">add_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTIO_BLK_F_FLUSH</span><span class="p">);</span>

	<span class="cm">/* Tell Guest how many sectors this device has. */</span>
	<span class="n">conf</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">vblk</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">/</span> <span class="mi">512</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tell Guest not to put in too many descriptors at once: two are used</span>
<span class="cm">	 * for the in and out elements.</span>
<span class="cm">	 */</span>
	<span class="n">add_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTIO_BLK_F_SEG_MAX</span><span class="p">);</span>
	<span class="n">conf</span><span class="p">.</span><span class="n">seg_max</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">VIRTQUEUE_NUM</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t try to put whole struct: we have 8 bit limit. */</span>
	<span class="n">set_config</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_blk_config</span><span class="p">,</span> <span class="n">geometry</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>

	<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;device %u: virtblock %llu sectors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="o">++</span><span class="n">devices</span><span class="p">.</span><span class="n">device_num</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">conf</span><span class="p">.</span><span class="n">capacity</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*L:211</span>
<span class="cm"> * Our random number generator device reads from /dev/random into the Guest&#39;s</span>
<span class="cm"> * input buffers.  The usual case is that the Guest doesn&#39;t want random numbers</span>
<span class="cm"> * and so has no buffers although /dev/random is still readable, whereas</span>
<span class="cm"> * console is the reverse.</span>
<span class="cm"> *</span>
<span class="cm"> * The same logic applies, however.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rng_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">rfd</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rng_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="n">in_num</span><span class="p">,</span> <span class="n">out_num</span><span class="p">,</span> <span class="n">totlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rng_info</span> <span class="o">*</span><span class="n">rng_info</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">[</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vring</span><span class="p">.</span><span class="n">num</span><span class="p">];</span>

	<span class="cm">/* First we need a buffer from the Guests&#39;s virtqueue. */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">wait_for_vq_desc</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">out_num</span><span class="p">)</span>
		<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Output buffers in rng?&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Just like the console write, we loop to cover the whole iovec.</span>
<span class="cm">	 * In this case, short reads actually happen quite a bit.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">iov_empty</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">in_num</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">readv</span><span class="p">(</span><span class="n">rng_info</span><span class="o">-&gt;</span><span class="n">rfd</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">in_num</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Read from /dev/random gave %i&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">iov_consume</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">in_num</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">totlen</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Tell the Guest about the new input. */</span>
	<span class="n">add_used</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">totlen</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*L:199</span>
<span class="cm"> * This creates a &quot;hardware&quot; random number device for the Guest.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_rng</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rng_info</span> <span class="o">*</span><span class="n">rng_info</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rng_info</span><span class="p">));</span>

	<span class="cm">/* Our device&#39;s privat info simply contains the /dev/random fd. */</span>
	<span class="n">rng_info</span><span class="o">-&gt;</span><span class="n">rfd</span> <span class="o">=</span> <span class="n">open_or_die</span><span class="p">(</span><span class="s">&quot;/dev/random&quot;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>

	<span class="cm">/* Create the new device. */</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">new_device</span><span class="p">(</span><span class="s">&quot;rng&quot;</span><span class="p">,</span> <span class="n">VIRTIO_ID_RNG</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">rng_info</span><span class="p">;</span>

	<span class="cm">/* The device has one virtqueue, where the Guest places inbufs. */</span>
	<span class="n">add_virtqueue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VIRTQUEUE_NUM</span><span class="p">,</span> <span class="n">rng_input</span><span class="p">);</span>

	<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;device %u: rng</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devices</span><span class="p">.</span><span class="n">device_num</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* That&#39;s the end of device setup. */</span>

<span class="cm">/*L:230 Reboot is pretty easy: clean up and exec() the Launcher afresh. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">noreturn</span><span class="p">))</span> <span class="n">restart_guest</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we don&#39;t track all open fds, we simply close everything beyond</span>
<span class="cm">	 * stderr.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FD_SETSIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">close</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

	<span class="cm">/* Reset all the devices (kills all threads). */</span>
	<span class="n">cleanup_devices</span><span class="p">();</span>

	<span class="n">execv</span><span class="p">(</span><span class="n">main_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">main_args</span><span class="p">);</span>
	<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Could not exec %s&quot;</span><span class="p">,</span> <span class="n">main_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*L:220</span>
<span class="cm"> * Finally we reach the core of the Launcher which runs the Guest, serves</span>
<span class="cm"> * its input and output, and finally, lays it to rest.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">noreturn</span><span class="p">))</span> <span class="n">run_guest</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">notify_addr</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">readval</span><span class="p">;</span>

		<span class="cm">/* We read from the /dev/lguest device to run the Guest. */</span>
		<span class="n">readval</span> <span class="o">=</span> <span class="n">pread</span><span class="p">(</span><span class="n">lguest_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">notify_addr</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">notify_addr</span><span class="p">),</span> <span class="n">cpu_id</span><span class="p">);</span>

		<span class="cm">/* One unsigned long means the Guest did HCALL_NOTIFY */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readval</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">notify_addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;Notify on address %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">notify_addr</span><span class="p">);</span>
			<span class="n">handle_output</span><span class="p">(</span><span class="n">notify_addr</span><span class="p">);</span>
		<span class="cm">/* ENOENT means the Guest died.  Reading tells us why. */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="n">reason</span><span class="p">[</span><span class="mi">1024</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
			<span class="n">pread</span><span class="p">(</span><span class="n">lguest_fd</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">reason</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>
			<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
		<span class="cm">/* ERESTART means that we need to reboot the guest */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">ERESTART</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">restart_guest</span><span class="p">();</span>
		<span class="cm">/* Anything else means a bug or incompatible change. */</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Running guest failed&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*L:240</span>
<span class="cm"> * This is the end of the Launcher.  The good news: we are over halfway</span>
<span class="cm"> * through!  The bad news: the most fiendish part of the code still lies ahead</span>
<span class="cm"> * of us.</span>
<span class="cm"> *</span>
<span class="cm"> * Are you ready?  Take a deep breath and join me in the core of the Host, in</span>
<span class="cm"> * &quot;make Host&quot;.</span>
<span class="cm">:*/</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">option</span> <span class="n">opts</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;verbose&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="sc">&#39;v&#39;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;tunnet&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;block&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rng&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;initrd&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;username&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;chroot&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">};</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usage</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Usage: lguest [--verbose] &quot;</span>
	     <span class="s">&quot;[--tunnet=(&lt;ipaddr&gt;:&lt;macaddr&gt;|bridge:&lt;bridgename&gt;:&lt;macaddr&gt;)</span><span class="se">\n</span><span class="s">&quot;</span>
	     <span class="s">&quot;|--block=&lt;filename&gt;|--initrd=&lt;filename&gt;]...</span><span class="se">\n</span><span class="s">&quot;</span>
	     <span class="s">&quot;&lt;mem-in-mb&gt; vmlinux [args...]&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*L:105 The main routine is where the real work begins: */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="cm">/* Memory, code startpoint and size of the (optional) initrd. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">initrd_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Two temporaries. */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
	<span class="cm">/* The boot information for the Guest. */</span>
	<span class="k">struct</span> <span class="n">boot_params</span> <span class="o">*</span><span class="n">boot</span><span class="p">;</span>
	<span class="cm">/* If they specify an initrd file to load. */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">initrd_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Password structure for initgroups/setres[gu]id */</span>
	<span class="k">struct</span> <span class="n">passwd</span> <span class="o">*</span><span class="n">user_details</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Directory to chroot to */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">chroot_path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Save the args: we &quot;reboot&quot; by execing ourselves again. */</span>
	<span class="n">main_args</span> <span class="o">=</span> <span class="n">argv</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First we initialize the device list.  We keep a pointer to the last</span>
<span class="cm">	 * device, and the next interrupt number to use for devices (1:</span>
<span class="cm">	 * remember that 0 is used by the timer).</span>
<span class="cm">	 */</span>
	<span class="n">devices</span><span class="p">.</span><span class="n">lastdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">devices</span><span class="p">.</span><span class="n">next_irq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* We&#39;re CPU 0.  In fact, that&#39;s the only CPU possible right now. */</span>
	<span class="n">cpu_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to know how much memory so we can set up the device</span>
<span class="cm">	 * descriptor and memory pages for the devices as we parse the command</span>
<span class="cm">	 * line.  So we quickly look through the arguments to find the amount</span>
<span class="cm">	 * of memory now.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mem</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * We start by mapping anonymous pages over all of</span>
<span class="cm">			 * guest-physical memory range.  This fills it with 0,</span>
<span class="cm">			 * and ensures that the Guest won&#39;t be killed when it</span>
<span class="cm">			 * tries to access it.</span>
<span class="cm">			 */</span>
			<span class="n">guest_base</span> <span class="o">=</span> <span class="n">map_zeroed_pages</span><span class="p">(</span><span class="n">mem</span> <span class="o">/</span> <span class="n">getpagesize</span><span class="p">()</span>
						      <span class="o">+</span> <span class="n">DEVICE_PAGES</span><span class="p">);</span>
			<span class="n">guest_limit</span> <span class="o">=</span> <span class="n">mem</span><span class="p">;</span>
			<span class="n">guest_max</span> <span class="o">=</span> <span class="n">mem</span> <span class="o">+</span> <span class="n">DEVICE_PAGES</span><span class="o">*</span><span class="n">getpagesize</span><span class="p">();</span>
			<span class="n">devices</span><span class="p">.</span><span class="n">descpage</span> <span class="o">=</span> <span class="n">get_pages</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* The options are fairly straight-forward */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">getopt_long</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;v&#39;</span>:
			<span class="n">verbose</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;t&#39;</span>:
			<span class="n">setup_tun_net</span><span class="p">(</span><span class="n">optarg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;b&#39;</span>:
			<span class="n">setup_block_file</span><span class="p">(</span><span class="n">optarg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;r&#39;</span>:
			<span class="n">setup_rng</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;i&#39;</span>:
			<span class="n">initrd_name</span> <span class="o">=</span> <span class="n">optarg</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;u&#39;</span>:
			<span class="n">user_details</span> <span class="o">=</span> <span class="n">getpwnam</span><span class="p">(</span><span class="n">optarg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_details</span><span class="p">)</span>
				<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;getpwnam failed, incorrect username?&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;c&#39;</span>:
			<span class="n">chroot_path</span> <span class="o">=</span> <span class="n">optarg</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">warnx</span><span class="p">(</span><span class="s">&quot;Unknown argument %s&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">optind</span><span class="p">]);</span>
			<span class="n">usage</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * After the other arguments we expect memory and kernel image name,</span>
<span class="cm">	 * followed by command line arguments for the kernel.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">optind</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">argc</span><span class="p">)</span>
		<span class="n">usage</span><span class="p">();</span>

	<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;Guest base is at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">guest_base</span><span class="p">);</span>

	<span class="cm">/* We always have a console device */</span>
	<span class="n">setup_console</span><span class="p">();</span>

	<span class="cm">/* Now we load the kernel */</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">load_kernel</span><span class="p">(</span><span class="n">open_or_die</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">optind</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">));</span>

	<span class="cm">/* Boot information is stashed at physical address 0 */</span>
	<span class="n">boot</span> <span class="o">=</span> <span class="n">from_guest_phys</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Map the initrd image if requested (at top of physical memory) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">initrd_name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">initrd_size</span> <span class="o">=</span> <span class="n">load_initrd</span><span class="p">(</span><span class="n">initrd_name</span><span class="p">,</span> <span class="n">mem</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * These are the location in the Linux boot header where the</span>
<span class="cm">		 * start and size of the initrd are expected to be found.</span>
<span class="cm">		 */</span>
		<span class="n">boot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">ramdisk_image</span> <span class="o">=</span> <span class="n">mem</span> <span class="o">-</span> <span class="n">initrd_size</span><span class="p">;</span>
		<span class="n">boot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">ramdisk_size</span> <span class="o">=</span> <span class="n">initrd_size</span><span class="p">;</span>
		<span class="cm">/* The bootloader type 0xFF means &quot;unknown&quot;; that&#39;s OK. */</span>
		<span class="n">boot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">type_of_loader</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The Linux boot header contains an &quot;E820&quot; memory map: ours is a</span>
<span class="cm">	 * simple, single region.</span>
<span class="cm">	 */</span>
	<span class="n">boot</span><span class="o">-&gt;</span><span class="n">e820_entries</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">boot</span><span class="o">-&gt;</span><span class="n">e820_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">e820entry</span><span class="p">)</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">E820_RAM</span> <span class="p">});</span>
	<span class="cm">/*</span>
<span class="cm">	 * The boot header contains a command line pointer: we put the command</span>
<span class="cm">	 * line after the boot header.</span>
<span class="cm">	 */</span>
	<span class="n">boot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd_line_ptr</span> <span class="o">=</span> <span class="n">to_guest_phys</span><span class="p">(</span><span class="n">boot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* We use a simple helper to copy the arguments separated by spaces. */</span>
	<span class="n">concat</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">boot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">argv</span><span class="o">+</span><span class="n">optind</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* Set kernel alignment to 16M (CONFIG_PHYSICAL_ALIGN) */</span>
	<span class="n">boot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">kernel_alignment</span> <span class="o">=</span> <span class="mh">0x1000000</span><span class="p">;</span>

	<span class="cm">/* Boot protocol version: 2.07 supports the fields for lguest. */</span>
	<span class="n">boot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="mh">0x207</span><span class="p">;</span>

	<span class="cm">/* The hardware_subarch value of &quot;1&quot; tells the Guest it&#39;s an lguest. */</span>
	<span class="n">boot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">hardware_subarch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Tell the entry path not to try to reload segment registers. */</span>
	<span class="n">boot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">loadflags</span> <span class="o">|=</span> <span class="n">KEEP_SEGMENTS</span><span class="p">;</span>

	<span class="cm">/* We tell the kernel to initialize the Guest. */</span>
	<span class="n">tell_kernel</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>

	<span class="cm">/* Ensure that we terminate if a device-servicing child dies. */</span>
	<span class="n">signal</span><span class="p">(</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="n">kill_launcher</span><span class="p">);</span>

	<span class="cm">/* If we exit via err(), this kills all the threads, restores tty. */</span>
	<span class="n">atexit</span><span class="p">(</span><span class="n">cleanup_devices</span><span class="p">);</span>

	<span class="cm">/* If requested, chroot to a directory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chroot_path</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chroot</span><span class="p">(</span><span class="n">chroot_path</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;chroot(</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">) failed&quot;</span><span class="p">,</span> <span class="n">chroot_path</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chdir</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;chdir(</span><span class="se">\&quot;</span><span class="s">/</span><span class="se">\&quot;</span><span class="s">) failed&quot;</span><span class="p">);</span>

		<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;chroot done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If requested, drop privileges */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_details</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uid_t</span> <span class="n">u</span><span class="p">;</span>
		<span class="n">gid_t</span> <span class="n">g</span><span class="p">;</span>

		<span class="n">u</span> <span class="o">=</span> <span class="n">user_details</span><span class="o">-&gt;</span><span class="n">pw_uid</span><span class="p">;</span>
		<span class="n">g</span> <span class="o">=</span> <span class="n">user_details</span><span class="o">-&gt;</span><span class="n">pw_gid</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">initgroups</span><span class="p">(</span><span class="n">user_details</span><span class="o">-&gt;</span><span class="n">pw_name</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;initgroups failed&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">setresgid</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;setresgid failed&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">setresuid</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">err</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;setresuid failed&quot;</span><span class="p">);</span>

		<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;Dropping privileges completed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Finally, run the Guest.  This doesn&#39;t return. */</span>
	<span class="n">run_guest</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*:*/</span>

<span class="cm">/*M:999</span>
<span class="cm"> * Mastery is done: you now know everything I do.</span>
<span class="cm"> *</span>
<span class="cm"> * But surely you have seen code, features and bugs in your wanderings which</span>
<span class="cm"> * you now yearn to attack?  That is the real game, and I look forward to you</span>
<span class="cm"> * patching and forking lguest into the Your-Name-Here-visor.</span>
<span class="cm"> *</span>
<span class="cm"> * Farewell, and good coding!</span>
<span class="cm"> * Rusty Russell.</span>
<span class="cm"> */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
