<!DOCTYPE html>
<html><head><title>joekychen/linux » tools › perf › builtin-lock.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>builtin-lock.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &quot;builtin.h&quot;</span>
<span class="cp">#include &quot;perf.h&quot;</span>

<span class="cp">#include &quot;util/util.h&quot;</span>
<span class="cp">#include &quot;util/cache.h&quot;</span>
<span class="cp">#include &quot;util/symbol.h&quot;</span>
<span class="cp">#include &quot;util/thread.h&quot;</span>
<span class="cp">#include &quot;util/header.h&quot;</span>

<span class="cp">#include &quot;util/parse-options.h&quot;</span>
<span class="cp">#include &quot;util/trace-event.h&quot;</span>

<span class="cp">#include &quot;util/debug.h&quot;</span>
<span class="cp">#include &quot;util/session.h&quot;</span>
<span class="cp">#include &quot;util/tool.h&quot;</span>

<span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;sys/prctl.h&gt;</span>
<span class="cp">#include &lt;semaphore.h&gt;</span>
<span class="cp">#include &lt;pthread.h&gt;</span>
<span class="cp">#include &lt;math.h&gt;</span>
<span class="cp">#include &lt;limits.h&gt;</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">perf_session</span> <span class="o">*</span><span class="n">session</span><span class="p">;</span>

<span class="cm">/* based on kernel/lockdep.c */</span>
<span class="cp">#define LOCKHASH_BITS		12</span>
<span class="cp">#define LOCKHASH_SIZE		(1UL &lt;&lt; LOCKHASH_BITS)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">lockhash_table</span><span class="p">[</span><span class="n">LOCKHASH_SIZE</span><span class="p">];</span>

<span class="cp">#define __lockhashfn(key)	hash_long((unsigned long)key, LOCKHASH_BITS)</span>
<span class="cp">#define lockhashentry(key)	(lockhash_table + __lockhashfn((key)))</span>

<span class="k">struct</span> <span class="n">lock_stat</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">hash_entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">rb</span><span class="p">;</span>		<span class="cm">/* used for sorting */</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME: raw_field_value() returns unsigned long long,</span>
<span class="cm">	 * so address of lockdep_map should be dealed as 64bit.</span>
<span class="cm">	 * Is there more better solution?</span>
<span class="cm">	 */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">addr</span><span class="p">;</span>		<span class="cm">/* address of lockdep_map, used as ID */</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>		<span class="cm">/* for strcpy(), we cannot use const */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nr_acquire</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nr_acquired</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nr_contended</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nr_release</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nr_readlock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nr_trylock</span><span class="p">;</span>
	<span class="cm">/* these times are in nano sec. */</span>
	<span class="n">u64</span>			<span class="n">wait_time_total</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">wait_time_min</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">wait_time_max</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">discard</span><span class="p">;</span> <span class="cm">/* flag of blacklist */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * States of lock_seq_stat</span>
<span class="cm"> *</span>
<span class="cm"> * UNINITIALIZED is required for detecting first event of acquire.</span>
<span class="cm"> * As the nature of lock events, there is no guarantee</span>
<span class="cm"> * that the first event for the locks are acquire,</span>
<span class="cm"> * it can be acquired, contended or release.</span>
<span class="cm"> */</span>
<span class="cp">#define SEQ_STATE_UNINITIALIZED      0	       </span><span class="cm">/* initial state */</span><span class="cp"></span>
<span class="cp">#define SEQ_STATE_RELEASED	1</span>
<span class="cp">#define SEQ_STATE_ACQUIRING	2</span>
<span class="cp">#define SEQ_STATE_ACQUIRED	3</span>
<span class="cp">#define SEQ_STATE_READ_ACQUIRED	4</span>
<span class="cp">#define SEQ_STATE_CONTENDED	5</span>

<span class="cm">/*</span>
<span class="cm"> * MAX_LOCK_DEPTH</span>
<span class="cm"> * Imported from include/linux/sched.h.</span>
<span class="cm"> * Should this be synchronized?</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_LOCK_DEPTH 48</span>

<span class="cm">/*</span>
<span class="cm"> * struct lock_seq_stat:</span>
<span class="cm"> * Place to put on state of one lock sequence</span>
<span class="cm"> * 1) acquire -&gt; acquired -&gt; release</span>
<span class="cm"> * 2) acquire -&gt; contended -&gt; acquired -&gt; release</span>
<span class="cm"> * 3) acquire (with read or try) -&gt; release</span>
<span class="cm"> * 4) Are there other patterns?</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lock_seq_stat</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>        <span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">state</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">prev_event_time</span><span class="p">;</span>
	<span class="kt">void</span>                    <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

	<span class="kt">int</span>                     <span class="n">read_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">thread_stat</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">rb</span><span class="p">;</span>

	<span class="n">u32</span>                     <span class="n">tid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>        <span class="n">seq_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rb_root</span>		<span class="n">thread_stats</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">thread_stat</span> <span class="o">*</span><span class="nf">thread_stat_find</span><span class="p">(</span><span class="n">u32</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thread_stat</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">thread_stats</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">st</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">thread_stat</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">==</span> <span class="n">tid</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">st</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">&lt;</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">)</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">thread_stat_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_stat</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">rb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">thread_stats</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thread_stat</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">rb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="o">*</span><span class="n">rb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">thread_stat</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">rb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">)</span>
			<span class="n">rb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">rb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">&gt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">)</span>
			<span class="n">rb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">rb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="s">&quot;inserting invalid thread_stat</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_stats</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">thread_stat</span> <span class="o">*</span><span class="nf">thread_stat_findnew_after_first</span><span class="p">(</span><span class="n">u32</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_stat</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>

	<span class="n">st</span> <span class="o">=</span> <span class="n">thread_stat_find</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">st</span><span class="p">;</span>

	<span class="n">st</span> <span class="o">=</span> <span class="n">zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_stat</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">)</span>
		<span class="n">die</span><span class="p">(</span><span class="s">&quot;memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">st</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">seq_list</span><span class="p">);</span>

	<span class="n">thread_stat_insert</span><span class="p">(</span><span class="n">st</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">st</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">thread_stat</span> <span class="o">*</span><span class="n">thread_stat_findnew_first</span><span class="p">(</span><span class="n">u32</span> <span class="n">tid</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">thread_stat</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">thread_stat_findnew</span><span class="p">)(</span><span class="n">u32</span> <span class="n">tid</span><span class="p">)</span> <span class="o">=</span>
	<span class="n">thread_stat_findnew_first</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">thread_stat</span> <span class="o">*</span><span class="nf">thread_stat_findnew_first</span><span class="p">(</span><span class="n">u32</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_stat</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>

	<span class="n">st</span> <span class="o">=</span> <span class="n">zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_stat</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">)</span>
		<span class="n">die</span><span class="p">(</span><span class="s">&quot;memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">seq_list</span><span class="p">);</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_stats</span><span class="p">.</span><span class="n">rb_node</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_stats</span><span class="p">);</span>

	<span class="n">thread_stat_findnew</span> <span class="o">=</span> <span class="n">thread_stat_findnew_after_first</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">st</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* build simple key function one is bigger than two */</span>
<span class="cp">#define SINGLE_KEY(member)						\</span>
<span class="cp">	static int lock_stat_key_ ## member(struct lock_stat *one,	\</span>
<span class="cp">					 struct lock_stat *two)		\</span>
<span class="cp">	{								\</span>
<span class="cp">		return one-&gt;member &gt; two-&gt;member;			\</span>
<span class="cp">	}</span>

<span class="n">SINGLE_KEY</span><span class="p">(</span><span class="n">nr_acquired</span><span class="p">)</span>
<span class="n">SINGLE_KEY</span><span class="p">(</span><span class="n">nr_contended</span><span class="p">)</span>
<span class="n">SINGLE_KEY</span><span class="p">(</span><span class="n">wait_time_total</span><span class="p">)</span>
<span class="n">SINGLE_KEY</span><span class="p">(</span><span class="n">wait_time_max</span><span class="p">)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">lock_stat_key_wait_time_min</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="n">one</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="n">two</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">one</span><span class="o">-&gt;</span><span class="n">wait_time_min</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">two</span><span class="o">-&gt;</span><span class="n">wait_time_min</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">ULLONG_MAX</span><span class="p">)</span>
		<span class="n">s1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s2</span> <span class="o">==</span> <span class="n">ULLONG_MAX</span><span class="p">)</span>
		<span class="n">s2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">lock_key</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * name: the value for specify by user</span>
<span class="cm">	 * this should be simpler than raw name of member</span>
<span class="cm">	 * e.g. nr_acquired -&gt; acquired, wait_time_total -&gt; wait_total</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)(</span><span class="k">struct</span> <span class="n">lock_stat</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lock_stat</span><span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">sort_key</span> <span class="o">=</span> <span class="s">&quot;acquired&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rb_root</span>		<span class="n">result</span><span class="p">;</span>	<span class="cm">/* place to store sorted data */</span>

<span class="cp">#define DEF_KEY_LOCK(name, fn_suffix)	\</span>
<span class="cp">	{ #name, lock_stat_key_ ## fn_suffix }</span>
<span class="k">struct</span> <span class="n">lock_key</span> <span class="n">keys</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">DEF_KEY_LOCK</span><span class="p">(</span><span class="n">acquired</span><span class="p">,</span> <span class="n">nr_acquired</span><span class="p">),</span>
	<span class="n">DEF_KEY_LOCK</span><span class="p">(</span><span class="n">contended</span><span class="p">,</span> <span class="n">nr_contended</span><span class="p">),</span>
	<span class="n">DEF_KEY_LOCK</span><span class="p">(</span><span class="n">wait_total</span><span class="p">,</span> <span class="n">wait_time_total</span><span class="p">),</span>
	<span class="n">DEF_KEY_LOCK</span><span class="p">(</span><span class="n">wait_min</span><span class="p">,</span> <span class="n">wait_time_min</span><span class="p">),</span>
	<span class="n">DEF_KEY_LOCK</span><span class="p">(</span><span class="n">wait_max</span><span class="p">,</span> <span class="n">wait_time_max</span><span class="p">),</span>

	<span class="cm">/* extra comparisons much complicated should be here */</span>

	<span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">select_key</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">sort_key</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">compare</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">die</span><span class="p">(</span><span class="s">&quot;Unknown compare key:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sort_key</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">insert_to_result</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="n">st</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bigger</span><span class="p">)(</span><span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">rb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">rb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="o">*</span><span class="n">rb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lock_stat</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">rb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bigger</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="n">rb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">rb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">rb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">rb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* returns left most element of result, and erase it */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="nf">pop_from_result</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">)</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>

	<span class="n">rb_erase</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lock_stat</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="nf">lock_stat_findnew</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">lockhashentry</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="n">ret</span><span class="p">,</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">hash_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_stat</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">alloc_failed</span><span class="p">;</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">alloc_failed</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">wait_time_min</span> <span class="o">=</span> <span class="n">ULLONG_MAX</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">hash_entry</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">new</span><span class="p">;</span>

<span class="nl">alloc_failed:</span>
	<span class="n">die</span><span class="p">(</span><span class="s">&quot;memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">input_name</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">raw_event_sample</span> <span class="p">{</span>
	<span class="n">u32</span>			<span class="n">size</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">trace_acquire_event</span> <span class="p">{</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">flag</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">trace_acquired_event</span> <span class="p">{</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">trace_contended_event</span> <span class="p">{</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">trace_release_event</span> <span class="p">{</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">trace_lock_handler</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">acquire_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">trace_acquire_event</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">event_format</span> <span class="o">*</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
			      <span class="n">u64</span> <span class="n">timestamp</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">acquired_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">trace_acquired_event</span> <span class="o">*</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">event_format</span> <span class="o">*</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
			       <span class="n">u64</span> <span class="n">timestamp</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">contended_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">trace_contended_event</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">event_format</span> <span class="o">*</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">timestamp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">trace_release_event</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">event_format</span> <span class="o">*</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
			      <span class="n">u64</span> <span class="n">timestamp</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_seq_stat</span> <span class="o">*</span><span class="nf">get_seq</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_stat</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_seq_stat</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">seq_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">seq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="n">zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_seq_stat</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seq</span><span class="p">)</span>
		<span class="n">die</span><span class="p">(</span><span class="s">&quot;Not enough memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SEQ_STATE_UNINITIALIZED</span><span class="p">;</span>
	<span class="n">seq</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">seq_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">seq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">broken_state</span> <span class="p">{</span>
	<span class="n">BROKEN_ACQUIRE</span><span class="p">,</span>
	<span class="n">BROKEN_ACQUIRED</span><span class="p">,</span>
	<span class="n">BROKEN_CONTENDED</span><span class="p">,</span>
	<span class="n">BROKEN_RELEASE</span><span class="p">,</span>
	<span class="n">BROKEN_MAX</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">bad_hist</span><span class="p">[</span><span class="n">BROKEN_MAX</span><span class="p">];</span>

<span class="k">enum</span> <span class="n">acquire_flags</span> <span class="p">{</span>
	<span class="n">TRY_LOCK</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">READ_LOCK</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">report_lock_acquire_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_acquire_event</span> <span class="o">*</span><span class="n">acquire_event</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">event_format</span> <span class="o">*</span><span class="n">__event</span> <span class="n">__used</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">cpu</span> <span class="n">__used</span><span class="p">,</span>
			<span class="n">u64</span> <span class="n">timestamp</span> <span class="n">__used</span><span class="p">,</span>
			<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="kr">thread</span> <span class="n">__used</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="n">ls</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thread_stat</span> <span class="o">*</span><span class="n">ts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_seq_stat</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>

	<span class="n">ls</span> <span class="o">=</span> <span class="n">lock_stat_findnew</span><span class="p">(</span><span class="n">acquire_event</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">acquire_event</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">discard</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ts</span> <span class="o">=</span> <span class="n">thread_stat_findnew</span><span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">get_seq</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">acquire_event</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SEQ_STATE_UNINITIALIZED</span>:
	<span class="k">case</span> <span class="n">SEQ_STATE_RELEASED</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">acquire_event</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seq</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SEQ_STATE_ACQUIRING</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">acquire_event</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">TRY_LOCK</span><span class="p">)</span>
				<span class="n">ls</span><span class="o">-&gt;</span><span class="n">nr_trylock</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">acquire_event</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">READ_LOCK</span><span class="p">)</span>
				<span class="n">ls</span><span class="o">-&gt;</span><span class="n">nr_readlock</span><span class="o">++</span><span class="p">;</span>
			<span class="n">seq</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SEQ_STATE_READ_ACQUIRED</span><span class="p">;</span>
			<span class="n">seq</span><span class="o">-&gt;</span><span class="n">read_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ls</span><span class="o">-&gt;</span><span class="n">nr_acquired</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEQ_STATE_READ_ACQUIRED</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">acquire_event</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">READ_LOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seq</span><span class="o">-&gt;</span><span class="n">read_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ls</span><span class="o">-&gt;</span><span class="n">nr_acquired</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">broken</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEQ_STATE_ACQUIRED</span>:
	<span class="k">case</span> <span class="n">SEQ_STATE_ACQUIRING</span>:
	<span class="k">case</span> <span class="n">SEQ_STATE_CONTENDED</span>:
<span class="nl">broken:</span>
		<span class="cm">/* broken lock sequence, discard it */</span>
		<span class="n">ls</span><span class="o">-&gt;</span><span class="n">discard</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bad_hist</span><span class="p">[</span><span class="n">BROKEN_ACQUIRE</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="s">&quot;Unknown state of lock sequence found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">nr_acquire</span><span class="o">++</span><span class="p">;</span>
	<span class="n">seq</span><span class="o">-&gt;</span><span class="n">prev_event_time</span> <span class="o">=</span> <span class="n">timestamp</span><span class="p">;</span>
<span class="nl">end:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">report_lock_acquired_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_acquired_event</span> <span class="o">*</span><span class="n">acquired_event</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">event_format</span> <span class="o">*</span><span class="n">__event</span> <span class="n">__used</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">cpu</span> <span class="n">__used</span><span class="p">,</span>
			 <span class="n">u64</span> <span class="n">timestamp</span> <span class="n">__used</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="kr">thread</span> <span class="n">__used</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="n">ls</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thread_stat</span> <span class="o">*</span><span class="n">ts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_seq_stat</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">contended_term</span><span class="p">;</span>

	<span class="n">ls</span> <span class="o">=</span> <span class="n">lock_stat_findnew</span><span class="p">(</span><span class="n">acquired_event</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">acquired_event</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">discard</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ts</span> <span class="o">=</span> <span class="n">thread_stat_findnew</span><span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">get_seq</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">acquired_event</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SEQ_STATE_UNINITIALIZED</span>:
		<span class="cm">/* orphan event, do nothing */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEQ_STATE_ACQUIRING</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEQ_STATE_CONTENDED</span>:
		<span class="n">contended_term</span> <span class="o">=</span> <span class="n">timestamp</span> <span class="o">-</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">prev_event_time</span><span class="p">;</span>
		<span class="n">ls</span><span class="o">-&gt;</span><span class="n">wait_time_total</span> <span class="o">+=</span> <span class="n">contended_term</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">contended_term</span> <span class="o">&lt;</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">wait_time_min</span><span class="p">)</span>
			<span class="n">ls</span><span class="o">-&gt;</span><span class="n">wait_time_min</span> <span class="o">=</span> <span class="n">contended_term</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">wait_time_max</span> <span class="o">&lt;</span> <span class="n">contended_term</span><span class="p">)</span>
			<span class="n">ls</span><span class="o">-&gt;</span><span class="n">wait_time_max</span> <span class="o">=</span> <span class="n">contended_term</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEQ_STATE_RELEASED</span>:
	<span class="k">case</span> <span class="n">SEQ_STATE_ACQUIRED</span>:
	<span class="k">case</span> <span class="n">SEQ_STATE_READ_ACQUIRED</span>:
		<span class="cm">/* broken lock sequence, discard it */</span>
		<span class="n">ls</span><span class="o">-&gt;</span><span class="n">discard</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bad_hist</span><span class="p">[</span><span class="n">BROKEN_ACQUIRED</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="s">&quot;Unknown state of lock sequence found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">seq</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SEQ_STATE_ACQUIRED</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">nr_acquired</span><span class="o">++</span><span class="p">;</span>
	<span class="n">seq</span><span class="o">-&gt;</span><span class="n">prev_event_time</span> <span class="o">=</span> <span class="n">timestamp</span><span class="p">;</span>
<span class="nl">end:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">report_lock_contended_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_contended_event</span> <span class="o">*</span><span class="n">contended_event</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">event_format</span> <span class="o">*</span><span class="n">__event</span> <span class="n">__used</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">cpu</span> <span class="n">__used</span><span class="p">,</span>
			  <span class="n">u64</span> <span class="n">timestamp</span> <span class="n">__used</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="kr">thread</span> <span class="n">__used</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="n">ls</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thread_stat</span> <span class="o">*</span><span class="n">ts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_seq_stat</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>

	<span class="n">ls</span> <span class="o">=</span> <span class="n">lock_stat_findnew</span><span class="p">(</span><span class="n">contended_event</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">contended_event</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">discard</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ts</span> <span class="o">=</span> <span class="n">thread_stat_findnew</span><span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">get_seq</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">contended_event</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SEQ_STATE_UNINITIALIZED</span>:
		<span class="cm">/* orphan event, do nothing */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEQ_STATE_ACQUIRING</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEQ_STATE_RELEASED</span>:
	<span class="k">case</span> <span class="n">SEQ_STATE_ACQUIRED</span>:
	<span class="k">case</span> <span class="n">SEQ_STATE_READ_ACQUIRED</span>:
	<span class="k">case</span> <span class="n">SEQ_STATE_CONTENDED</span>:
		<span class="cm">/* broken lock sequence, discard it */</span>
		<span class="n">ls</span><span class="o">-&gt;</span><span class="n">discard</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bad_hist</span><span class="p">[</span><span class="n">BROKEN_CONTENDED</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="s">&quot;Unknown state of lock sequence found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">seq</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SEQ_STATE_CONTENDED</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">nr_contended</span><span class="o">++</span><span class="p">;</span>
	<span class="n">seq</span><span class="o">-&gt;</span><span class="n">prev_event_time</span> <span class="o">=</span> <span class="n">timestamp</span><span class="p">;</span>
<span class="nl">end:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">report_lock_release_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">trace_release_event</span> <span class="o">*</span><span class="n">release_event</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">event_format</span> <span class="o">*</span><span class="n">__event</span> <span class="n">__used</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">cpu</span> <span class="n">__used</span><span class="p">,</span>
			<span class="n">u64</span> <span class="n">timestamp</span> <span class="n">__used</span><span class="p">,</span>
			<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="kr">thread</span> <span class="n">__used</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="n">ls</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thread_stat</span> <span class="o">*</span><span class="n">ts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_seq_stat</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>

	<span class="n">ls</span> <span class="o">=</span> <span class="n">lock_stat_findnew</span><span class="p">(</span><span class="n">release_event</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">release_event</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">discard</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ts</span> <span class="o">=</span> <span class="n">thread_stat_findnew</span><span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">get_seq</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">release_event</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SEQ_STATE_UNINITIALIZED</span>:
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEQ_STATE_ACQUIRED</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEQ_STATE_READ_ACQUIRED</span>:
		<span class="n">seq</span><span class="o">-&gt;</span><span class="n">read_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">read_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">read_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ls</span><span class="o">-&gt;</span><span class="n">nr_release</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEQ_STATE_ACQUIRING</span>:
	<span class="k">case</span> <span class="n">SEQ_STATE_CONTENDED</span>:
	<span class="k">case</span> <span class="n">SEQ_STATE_RELEASED</span>:
		<span class="cm">/* broken lock sequence, discard it */</span>
		<span class="n">ls</span><span class="o">-&gt;</span><span class="n">discard</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bad_hist</span><span class="p">[</span><span class="n">BROKEN_RELEASE</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_seq</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="s">&quot;Unknown state of lock sequence found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">nr_release</span><span class="o">++</span><span class="p">;</span>
<span class="nl">free_seq:</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
<span class="nl">end:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* lock oriented handlers */</span>
<span class="cm">/* TODO: handlers for CPU oriented, thread oriented */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">trace_lock_handler</span> <span class="n">report_lock_ops</span>  <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">acquire_event</span>		<span class="o">=</span> <span class="n">report_lock_acquire_event</span><span class="p">,</span>
	<span class="p">.</span><span class="n">acquired_event</span>		<span class="o">=</span> <span class="n">report_lock_acquired_event</span><span class="p">,</span>
	<span class="p">.</span><span class="n">contended_event</span>	<span class="o">=</span> <span class="n">report_lock_contended_event</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release_event</span>		<span class="o">=</span> <span class="n">report_lock_release_event</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">trace_lock_handler</span> <span class="o">*</span><span class="n">trace_handler</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">process_lock_acquire_event</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">event_format</span> <span class="o">*</span><span class="n">event</span> <span class="n">__used</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">cpu</span> <span class="n">__used</span><span class="p">,</span>
			   <span class="n">u64</span> <span class="n">timestamp</span> <span class="n">__used</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="kr">thread</span> <span class="n">__used</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_acquire_event</span> <span class="n">acquire_event</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tmp</span><span class="p">;</span>		<span class="cm">/* this is required for casting... */</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">raw_field_value</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&quot;lockdep_addr&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acquire_event</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
	<span class="n">acquire_event</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_field_ptr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">acquire_event</span><span class="p">.</span><span class="n">flag</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">raw_field_value</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&quot;flag&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_handler</span><span class="o">-&gt;</span><span class="n">acquire_event</span><span class="p">)</span>
		<span class="n">trace_handler</span><span class="o">-&gt;</span><span class="n">acquire_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acquire_event</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">process_lock_acquired_event</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">event_format</span> <span class="o">*</span><span class="n">event</span> <span class="n">__used</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">cpu</span> <span class="n">__used</span><span class="p">,</span>
			    <span class="n">u64</span> <span class="n">timestamp</span> <span class="n">__used</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="kr">thread</span> <span class="n">__used</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_acquired_event</span> <span class="n">acquired_event</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tmp</span><span class="p">;</span>		<span class="cm">/* this is required for casting... */</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">raw_field_value</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&quot;lockdep_addr&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acquired_event</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
	<span class="n">acquired_event</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_field_ptr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_handler</span><span class="o">-&gt;</span><span class="n">acquire_event</span><span class="p">)</span>
		<span class="n">trace_handler</span><span class="o">-&gt;</span><span class="n">acquired_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acquired_event</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">process_lock_contended_event</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">event_format</span> <span class="o">*</span><span class="n">event</span> <span class="n">__used</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">cpu</span> <span class="n">__used</span><span class="p">,</span>
			     <span class="n">u64</span> <span class="n">timestamp</span> <span class="n">__used</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="kr">thread</span> <span class="n">__used</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_contended_event</span> <span class="n">contended_event</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tmp</span><span class="p">;</span>		<span class="cm">/* this is required for casting... */</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">raw_field_value</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&quot;lockdep_addr&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">contended_event</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
	<span class="n">contended_event</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_field_ptr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_handler</span><span class="o">-&gt;</span><span class="n">acquire_event</span><span class="p">)</span>
		<span class="n">trace_handler</span><span class="o">-&gt;</span><span class="n">contended_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">contended_event</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">process_lock_release_event</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">event_format</span> <span class="o">*</span><span class="n">event</span> <span class="n">__used</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">cpu</span> <span class="n">__used</span><span class="p">,</span>
			   <span class="n">u64</span> <span class="n">timestamp</span> <span class="n">__used</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="kr">thread</span> <span class="n">__used</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_release_event</span> <span class="n">release_event</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tmp</span><span class="p">;</span>		<span class="cm">/* this is required for casting... */</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">raw_field_value</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&quot;lockdep_addr&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">release_event</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
	<span class="n">release_event</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_field_ptr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trace_handler</span><span class="o">-&gt;</span><span class="n">acquire_event</span><span class="p">)</span>
		<span class="n">trace_handler</span><span class="o">-&gt;</span><span class="n">release_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">release_event</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">process_raw_event</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">timestamp</span><span class="p">,</span> <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_format</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">trace_parse_common_type</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">trace_find_event</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;lock_acquire&quot;</span><span class="p">))</span>
		<span class="n">process_lock_acquire_event</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;lock_acquired&quot;</span><span class="p">))</span>
		<span class="n">process_lock_acquired_event</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;lock_contended&quot;</span><span class="p">))</span>
		<span class="n">process_lock_contended_event</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;lock_release&quot;</span><span class="p">))</span>
		<span class="n">process_lock_release_event</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_bad_events</span><span class="p">(</span><span class="kt">int</span> <span class="n">bad</span><span class="p">,</span> <span class="kt">int</span> <span class="n">total</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Output for debug, this have to be removed */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
		<span class="p">{</span> <span class="s">&quot;acquire&quot;</span><span class="p">,</span> <span class="s">&quot;acquired&quot;</span><span class="p">,</span> <span class="s">&quot;contended&quot;</span><span class="p">,</span> <span class="s">&quot;release&quot;</span> <span class="p">};</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">=== output for debug===</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;bad: %d, total: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bad</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;bad rate: %f %%</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">bad</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">total</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;histogram of events caused bad sequence</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BROKEN_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; %10s: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bad_hist</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/* TODO: various way to print, coloring, nano or milli sec */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_result</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">cut_name</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">bad</span><span class="p">,</span> <span class="n">total</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%20s &quot;</span><span class="p">,</span> <span class="s">&quot;Name&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%10s &quot;</span><span class="p">,</span> <span class="s">&quot;acquired&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%10s &quot;</span><span class="p">,</span> <span class="s">&quot;contended&quot;</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%15s &quot;</span><span class="p">,</span> <span class="s">&quot;total wait (ns)&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%15s &quot;</span><span class="p">,</span> <span class="s">&quot;max wait (ns)&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%15s &quot;</span><span class="p">,</span> <span class="s">&quot;min wait (ns)&quot;</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">bad</span> <span class="o">=</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">st</span> <span class="o">=</span> <span class="n">pop_from_result</span><span class="p">()))</span> <span class="p">{</span>
		<span class="n">total</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">discard</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bad</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bzero</span><span class="p">(</span><span class="n">cut_name</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* output raw name */</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%20s &quot;</span><span class="p">,</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">strncpy</span><span class="p">(</span><span class="n">cut_name</span><span class="p">,</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">cut_name</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;.&#39;</span><span class="p">;</span>
			<span class="n">cut_name</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;.&#39;</span><span class="p">;</span>
			<span class="n">cut_name</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;.&#39;</span><span class="p">;</span>
			<span class="n">cut_name</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="cm">/* cut off name for saving output style */</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%20s &quot;</span><span class="p">,</span> <span class="n">cut_name</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%10u &quot;</span><span class="p">,</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">nr_acquired</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%10u &quot;</span><span class="p">,</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">nr_contended</span><span class="p">);</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%15&quot;</span> <span class="n">PRIu64</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">wait_time_total</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%15&quot;</span> <span class="n">PRIu64</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">wait_time_max</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%15&quot;</span> <span class="n">PRIu64</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">wait_time_min</span> <span class="o">==</span> <span class="n">ULLONG_MAX</span> <span class="o">?</span>
		       <span class="mi">0</span> <span class="o">:</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">wait_time_min</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">print_bad_events</span><span class="p">(</span><span class="n">bad</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">info_threads</span><span class="p">,</span> <span class="n">info_map</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_threads</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_stat</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%10s: comm</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;Thread ID&quot;</span><span class="p">);</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_stats</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">st</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">thread_stat</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">perf_session__findnew</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%10d: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="p">};</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_map</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Address of instance: name of class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LOCKHASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lockhash_table</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hash_entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; %p: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_info</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info_threads</span><span class="p">)</span>
		<span class="n">dump_threads</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">info_map</span><span class="p">)</span>
		<span class="n">dump_map</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">die</span><span class="p">(</span><span class="s">&quot;Unknown type of information</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_sample_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_tool</span> <span class="o">*</span><span class="n">tool</span> <span class="n">__used</span><span class="p">,</span>
				<span class="k">union</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">perf_sample</span> <span class="o">*</span><span class="n">sample</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">perf_evsel</span> <span class="o">*</span><span class="n">evsel</span> <span class="n">__used</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">machine__findnew_thread</span><span class="p">(</span><span class="n">machine</span><span class="p">,</span> <span class="n">sample</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="kr">thread</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;problem processing %d event, skipping it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">process_raw_event</span><span class="p">(</span><span class="n">sample</span><span class="o">-&gt;</span><span class="n">raw_data</span><span class="p">,</span> <span class="n">sample</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sample</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">perf_tool</span> <span class="n">eops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sample</span>			<span class="o">=</span> <span class="n">process_sample_event</span><span class="p">,</span>
	<span class="p">.</span><span class="n">comm</span>			<span class="o">=</span> <span class="n">perf_event__process_comm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ordered_samples</span>	<span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_events</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">session</span> <span class="o">=</span> <span class="n">perf_session__new</span><span class="p">(</span><span class="n">input_name</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">session</span><span class="p">)</span>
		<span class="n">die</span><span class="p">(</span><span class="s">&quot;Initializing perf session failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">perf_session__process_events</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sort_result</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_stat</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LOCKHASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lockhash_table</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hash_entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">insert_to_result</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">compare</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__cmd_report</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setup_pager</span><span class="p">();</span>
	<span class="n">select_key</span><span class="p">();</span>
	<span class="n">read_events</span><span class="p">();</span>
	<span class="n">sort_result</span><span class="p">();</span>
	<span class="n">print_result</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">report_usage</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;perf lock report [&lt;options&gt;]&quot;</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">option</span> <span class="n">report_options</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">OPT_STRING</span><span class="p">(</span><span class="sc">&#39;k&#39;</span><span class="p">,</span> <span class="s">&quot;key&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sort_key</span><span class="p">,</span> <span class="s">&quot;acquired&quot;</span><span class="p">,</span>
		    <span class="s">&quot;key for sorting (acquired / contended / wait_total / wait_max / wait_min)&quot;</span><span class="p">),</span>
	<span class="cm">/* TODO: type */</span>
	<span class="n">OPT_END</span><span class="p">()</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">info_usage</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;perf lock info [&lt;options&gt;]&quot;</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">option</span> <span class="n">info_options</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">OPT_BOOLEAN</span><span class="p">(</span><span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="s">&quot;threads&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info_threads</span><span class="p">,</span>
		    <span class="s">&quot;dump thread list in perf.data&quot;</span><span class="p">),</span>
	<span class="n">OPT_BOOLEAN</span><span class="p">(</span><span class="sc">&#39;m&#39;</span><span class="p">,</span> <span class="s">&quot;map&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info_map</span><span class="p">,</span>
		    <span class="s">&quot;map of lock instances (address:name table)&quot;</span><span class="p">),</span>
	<span class="n">OPT_END</span><span class="p">()</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">lock_usage</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;perf lock [&lt;options&gt;] {record|report|script|info}&quot;</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">option</span> <span class="n">lock_options</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">OPT_STRING</span><span class="p">(</span><span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="s">&quot;input&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input_name</span><span class="p">,</span> <span class="s">&quot;file&quot;</span><span class="p">,</span> <span class="s">&quot;input file name&quot;</span><span class="p">),</span>
	<span class="n">OPT_INCR</span><span class="p">(</span><span class="sc">&#39;v&#39;</span><span class="p">,</span> <span class="s">&quot;verbose&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">verbose</span><span class="p">,</span> <span class="s">&quot;be more verbose (show symbol address, etc)&quot;</span><span class="p">),</span>
	<span class="n">OPT_BOOLEAN</span><span class="p">(</span><span class="sc">&#39;D&#39;</span><span class="p">,</span> <span class="s">&quot;dump-raw-trace&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dump_trace</span><span class="p">,</span> <span class="s">&quot;dump raw trace in ASCII&quot;</span><span class="p">),</span>
	<span class="n">OPT_END</span><span class="p">()</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">record_args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;record&quot;</span><span class="p">,</span>
	<span class="s">&quot;-R&quot;</span><span class="p">,</span>
	<span class="s">&quot;-f&quot;</span><span class="p">,</span>
	<span class="s">&quot;-m&quot;</span><span class="p">,</span> <span class="s">&quot;1024&quot;</span><span class="p">,</span>
	<span class="s">&quot;-c&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">,</span>
	<span class="s">&quot;-e&quot;</span><span class="p">,</span> <span class="s">&quot;lock:lock_acquire&quot;</span><span class="p">,</span>
	<span class="s">&quot;-e&quot;</span><span class="p">,</span> <span class="s">&quot;lock:lock_acquired&quot;</span><span class="p">,</span>
	<span class="s">&quot;-e&quot;</span><span class="p">,</span> <span class="s">&quot;lock:lock_contended&quot;</span><span class="p">,</span>
	<span class="s">&quot;-e&quot;</span><span class="p">,</span> <span class="s">&quot;lock:lock_release&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__cmd_record</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rec_argc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">rec_argv</span><span class="p">;</span>

	<span class="n">rec_argc</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">record_args</span><span class="p">)</span> <span class="o">+</span> <span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">rec_argv</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">rec_argc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rec_argv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">record_args</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">rec_argv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">record_args</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">argc</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">rec_argv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">rec_argc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cmd_record</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rec_argv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cmd_lock</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span> <span class="n">__used</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">symbol__init</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LOCKHASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">lockhash_table</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">argc</span> <span class="o">=</span> <span class="n">parse_options</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">lock_options</span><span class="p">,</span> <span class="n">lock_usage</span><span class="p">,</span>
			     <span class="n">PARSE_OPT_STOP_AT_NON_OPTION</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">argc</span><span class="p">)</span>
		<span class="n">usage_with_options</span><span class="p">(</span><span class="n">lock_usage</span><span class="p">,</span> <span class="n">lock_options</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;rec&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">__cmd_record</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;report&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trace_handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">report_lock_ops</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">argc</span> <span class="o">=</span> <span class="n">parse_options</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span>
					     <span class="n">report_options</span><span class="p">,</span> <span class="n">report_usage</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">argc</span><span class="p">)</span>
				<span class="n">usage_with_options</span><span class="p">(</span><span class="n">report_usage</span><span class="p">,</span> <span class="n">report_options</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">__cmd_report</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;script&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Aliased to &#39;perf script&#39; */</span>
		<span class="k">return</span> <span class="n">cmd_script</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">prefix</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;info&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">argc</span> <span class="o">=</span> <span class="n">parse_options</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span>
					     <span class="n">info_options</span><span class="p">,</span> <span class="n">info_usage</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">argc</span><span class="p">)</span>
				<span class="n">usage_with_options</span><span class="p">(</span><span class="n">info_usage</span><span class="p">,</span> <span class="n">info_options</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* recycling report_lock_ops */</span>
		<span class="n">trace_handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">report_lock_ops</span><span class="p">;</span>
		<span class="n">setup_pager</span><span class="p">();</span>
		<span class="n">read_events</span><span class="p">();</span>
		<span class="n">dump_info</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">usage_with_options</span><span class="p">(</span><span class="n">lock_usage</span><span class="p">,</span> <span class="n">lock_options</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
