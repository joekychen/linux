<!DOCTYPE html>
<html><head><title>joekychen/linux » tools › perf › util › symbol.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>symbol.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;dirent.h&gt;</span>
<span class="cp">#include &lt;errno.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;sys/stat.h&gt;</span>
<span class="cp">#include &lt;sys/param.h&gt;</span>
<span class="cp">#include &lt;fcntl.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;inttypes.h&gt;</span>
<span class="cp">#include &quot;build-id.h&quot;</span>
<span class="cp">#include &quot;util.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>
<span class="cp">#include &quot;symbol.h&quot;</span>
<span class="cp">#include &quot;strlist.h&quot;</span>

<span class="cp">#include &lt;libelf.h&gt;</span>
<span class="cp">#include &lt;gelf.h&gt;</span>
<span class="cp">#include &lt;elf.h&gt;</span>
<span class="cp">#include &lt;limits.h&gt;</span>
<span class="cp">#include &lt;sys/utsname.h&gt;</span>

<span class="cp">#ifndef KSYM_NAME_LEN</span>
<span class="cp">#define KSYM_NAME_LEN 256</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef NT_GNU_BUILD_ID</span>
<span class="cp">#define NT_GNU_BUILD_ID 3</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">dso__build_id_equal</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">build_id</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">elf_read_build_id</span><span class="p">(</span><span class="n">Elf</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">bf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dsos__add</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map__new2</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dso__load_kernel_sym</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
				<span class="n">symbol_filter_t</span> <span class="n">filter</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dso__load_guest_kernel_sym</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
			<span class="n">symbol_filter_t</span> <span class="n">filter</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">vmlinux_path__nr_entries</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">**</span><span class="n">vmlinux_path</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">symbol_conf</span> <span class="n">symbol_conf</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">exclude_other</span>	  <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_modules</span>	  <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
	<span class="p">.</span><span class="n">try_vmlinux_path</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
	<span class="p">.</span><span class="n">annotate_src</span>	  <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symfs</span>            <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">dso__name_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dso</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;[unknown]&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">long_name_len</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">short_name_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">dso__loaded</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">loaded</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">type</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">dso__sorted_by_name</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">sorted_by_name</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dso__set_sorted_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dso</span><span class="o">-&gt;</span><span class="n">sorted_by_name</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">type</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">symbol_type__is_a</span><span class="p">(</span><span class="kt">char</span> <span class="n">symbol_type</span><span class="p">,</span> <span class="k">enum</span> <span class="n">map_type</span> <span class="n">map_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">symbol_type</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">symbol_type</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">map_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MAP__FUNCTION</span>:
		<span class="k">return</span> <span class="n">symbol_type</span> <span class="o">==</span> <span class="sc">&#39;T&#39;</span> <span class="o">||</span> <span class="n">symbol_type</span> <span class="o">==</span> <span class="sc">&#39;W&#39;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MAP__VARIABLE</span>:
		<span class="k">return</span> <span class="n">symbol_type</span> <span class="o">==</span> <span class="sc">&#39;D&#39;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">prefix_underscores_count</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">tail</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span><span class="p">)</span>
		<span class="n">tail</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tail</span> <span class="o">-</span> <span class="n">str</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define SYMBOL_A 0</span>
<span class="cp">#define SYMBOL_B 1</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">choose_best_symbol</span><span class="p">(</span><span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">syma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">symb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">b</span><span class="p">;</span>

	<span class="cm">/* Prefer a symbol with non zero length */</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">syma</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">syma</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">symb</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">symb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">SYMBOL_A</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">SYMBOL_B</span><span class="p">;</span>

	<span class="cm">/* Prefer a non weak symbol over a weak one */</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">syma</span><span class="o">-&gt;</span><span class="n">binding</span> <span class="o">==</span> <span class="n">STB_WEAK</span><span class="p">;</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">symb</span><span class="o">-&gt;</span><span class="n">binding</span> <span class="o">==</span> <span class="n">STB_WEAK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">a</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SYMBOL_A</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">b</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SYMBOL_B</span><span class="p">;</span>

	<span class="cm">/* Prefer a global symbol over a non global one */</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">syma</span><span class="o">-&gt;</span><span class="n">binding</span> <span class="o">==</span> <span class="n">STB_GLOBAL</span><span class="p">;</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">symb</span><span class="o">-&gt;</span><span class="n">binding</span> <span class="o">==</span> <span class="n">STB_GLOBAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">b</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SYMBOL_A</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">a</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SYMBOL_B</span><span class="p">;</span>

	<span class="cm">/* Prefer a symbol with less underscores */</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">prefix_underscores_count</span><span class="p">(</span><span class="n">syma</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">prefix_underscores_count</span><span class="p">(</span><span class="n">symb</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SYMBOL_A</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SYMBOL_B</span><span class="p">;</span>

	<span class="cm">/* If all else fails, choose the symbol with the longest name */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">syma</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">symb</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">SYMBOL_A</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">SYMBOL_B</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">symbols__fixup_duplicate</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">nd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">nd</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="n">symbols</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">nd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
<span class="nl">again:</span>
		<span class="n">nd</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nd</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">!=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">choose_best_symbol</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="o">==</span> <span class="n">SYMBOL_A</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">symbols</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">nd</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
			<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">symbols</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">symbols__fixup_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="o">*</span><span class="n">prevnd</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="n">symbols</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prevnd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">curr</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">prevnd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">nd</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">prevnd</span><span class="p">);</span> <span class="n">nd</span><span class="p">;</span> <span class="n">nd</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">==</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">!=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span>
			<span class="n">prev</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Last entry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">==</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__map_groups__fixup_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_groups</span> <span class="o">*</span><span class="n">mg</span><span class="p">,</span> <span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="o">*</span><span class="n">prevnd</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mg</span><span class="o">-&gt;</span><span class="n">maps</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prevnd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">curr</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">prevnd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">map</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">nd</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">prevnd</span><span class="p">);</span> <span class="n">nd</span><span class="p">;</span> <span class="n">nd</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">map</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="n">prev</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We still haven&#39;t the actual symbols, so guess the</span>
<span class="cm">	 * last map final address.</span>
<span class="cm">	 */</span>
	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0ULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">map_groups__fixup_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_groups</span> <span class="o">*</span><span class="n">mg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAP__NR_TYPES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">__map_groups__fixup_end</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="nf">symbol__new</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span> <span class="n">u8</span> <span class="n">binding</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">namelen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">sym</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">priv_size</span> <span class="o">+</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sym</span><span class="p">)</span> <span class="o">+</span> <span class="n">namelen</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">priv_size</span><span class="p">)</span>
		<span class="n">sym</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sym</span><span class="p">)</span> <span class="o">+</span> <span class="n">symbol_conf</span><span class="p">.</span><span class="n">priv_size</span><span class="p">;</span>

	<span class="n">sym</span><span class="o">-&gt;</span><span class="n">start</span>   <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">sym</span><span class="o">-&gt;</span><span class="n">end</span>     <span class="o">=</span> <span class="n">len</span> <span class="o">?</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">sym</span><span class="o">-&gt;</span><span class="n">binding</span> <span class="o">=</span> <span class="n">binding</span><span class="p">;</span>
	<span class="n">sym</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">namelen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pr_debug4</span><span class="p">(</span><span class="s">&quot;%s: %s %#&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot;-%#&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">__func__</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sym</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">symbol__delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">sym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free</span><span class="p">(((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sym</span><span class="p">)</span> <span class="o">-</span> <span class="n">symbol_conf</span><span class="p">.</span><span class="n">priv_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">symbol__fprintf</span><span class="p">(</span><span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">sym</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&quot; %&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot;-%&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; %c %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">sym</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">,</span>
		       <span class="n">sym</span><span class="o">-&gt;</span><span class="n">binding</span> <span class="o">==</span> <span class="n">STB_GLOBAL</span> <span class="o">?</span> <span class="sc">&#39;g&#39;</span> <span class="o">:</span>
		       <span class="n">sym</span><span class="o">-&gt;</span><span class="n">binding</span> <span class="o">==</span> <span class="n">STB_LOCAL</span>  <span class="o">?</span> <span class="sc">&#39;l&#39;</span> <span class="o">:</span> <span class="sc">&#39;w&#39;</span><span class="p">,</span>
		       <span class="n">sym</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">symbol__fprintf_symname_offs</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">sym</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">addr_location</span> <span class="o">*</span><span class="n">al</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sym</span> <span class="o">&amp;&amp;</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">al</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">al</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">-</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
			<span class="n">length</span> <span class="o">+=</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&quot;+0x%lx&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&quot;[unknown]&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">symbol__fprintf_symname</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">sym</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">symbol__fprintf_symname_offs</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dso__set_long_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dso</span><span class="o">-&gt;</span><span class="n">long_name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">dso</span><span class="o">-&gt;</span><span class="n">long_name_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dso__set_short_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dso</span><span class="o">-&gt;</span><span class="n">short_name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">dso</span><span class="o">-&gt;</span><span class="n">short_name_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dso__set_basename</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dso__set_short_name</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">basename</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">long_name</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="nf">dso__new</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dso</span><span class="p">)</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dso</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="n">dso__set_long_name</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">dso__set_short_name</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAP__NR_TYPES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbol_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
		<span class="n">dso</span><span class="o">-&gt;</span><span class="n">symtab_type</span> <span class="o">=</span> <span class="n">SYMTAB__NOT_FOUND</span><span class="p">;</span>
		<span class="n">dso</span><span class="o">-&gt;</span><span class="n">loaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dso</span><span class="o">-&gt;</span><span class="n">sorted_by_name</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dso</span><span class="o">-&gt;</span><span class="n">has_build_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dso</span><span class="o">-&gt;</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">DSO_TYPE_USER</span><span class="p">;</span>
		<span class="n">dso</span><span class="o">-&gt;</span><span class="n">needs_swap</span> <span class="o">=</span> <span class="n">DSO_SWAP__UNSET</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dso</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">symbols__delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="n">symbols</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">symbols</span><span class="p">);</span>
		<span class="n">symbol__delete</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dso__delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAP__NR_TYPES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">symbols__delete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">sname_alloc</span><span class="p">)</span>
		<span class="n">free</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">short_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">lname_alloc</span><span class="p">)</span>
		<span class="n">free</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">long_name</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">dso</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dso__set_build_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">build_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">build_id</span><span class="p">,</span> <span class="n">build_id</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">build_id</span><span class="p">));</span>
	<span class="n">dso</span><span class="o">-&gt;</span><span class="n">has_build_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">symbols__insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">sym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">symbols</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u64</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">symbols</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="nf">symbols__find</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">symbols</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">symbols</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">symbol_name_rb_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span>	<span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">symbol</span>	<span class="n">sym</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">symbols__insert_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">sym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">symbols</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">symbol_name_rb_node</span> <span class="o">*</span><span class="n">symn</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="n">symn</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol_name_rb_node</span><span class="p">,</span> <span class="n">sym</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol_name_rb_node</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sym</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">symn</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">symn</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">symbols</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">symbols__sort_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">nd</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">nd</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="n">source</span><span class="p">);</span> <span class="n">nd</span><span class="p">;</span> <span class="n">nd</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="n">symbols__insert_by_name</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="nf">symbols__find_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">symbols</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">symbols</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">symbol_name_rb_node</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">cmp</span><span class="p">;</span>

		<span class="n">s</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol_name_rb_node</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="n">cmp</span> <span class="o">=</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sym</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sym</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="nf">dso__find_symbol</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">,</span> <span class="n">u64</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">symbols__find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbols</span><span class="p">[</span><span class="n">type</span><span class="p">],</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="nf">dso__find_symbol_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">symbols__find_by_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbol_names</span><span class="p">[</span><span class="n">type</span><span class="p">],</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dso__sort_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dso__set_sorted_by_name</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">symbols__sort_by_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbol_names</span><span class="p">[</span><span class="n">type</span><span class="p">],</span>
				     <span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbols</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">build_id__sprintf</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">build_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">bid</span> <span class="o">=</span> <span class="n">bf</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">raw</span> <span class="o">=</span> <span class="n">build_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">bid</span><span class="p">,</span> <span class="s">&quot;%02x&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">raw</span><span class="p">);</span>
		<span class="o">++</span><span class="n">raw</span><span class="p">;</span>
		<span class="n">bid</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">raw</span> <span class="o">-</span> <span class="n">build_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">dso__fprintf_buildid</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">sbuild_id</span><span class="p">[</span><span class="n">BUILD_ID_SIZE</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="n">build_id__sprintf</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">build_id</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">build_id</span><span class="p">),</span> <span class="n">sbuild_id</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">sbuild_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">dso__fprintf_symbols_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span>
				    <span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">nd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">symbol_name_rb_node</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">nd</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbol_names</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span> <span class="n">nd</span><span class="p">;</span> <span class="n">nd</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol_name_rb_node</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">sym</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">dso__fprintf</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">nd</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&quot;dso: %s (&quot;</span><span class="p">,</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">short_name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">short_name</span> <span class="o">!=</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">long_name</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&quot;%s, &quot;</span><span class="p">,</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">long_name</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&quot;%s, %sloaded, &quot;</span><span class="p">,</span> <span class="n">map_type__name</span><span class="p">[</span><span class="n">type</span><span class="p">],</span>
		       <span class="n">dso</span><span class="o">-&gt;</span><span class="n">loaded</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;NOT &quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="n">dso__fprintf_buildid</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">nd</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbols</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span> <span class="n">nd</span><span class="p">;</span> <span class="n">nd</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">symbol__fprintf</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kallsyms__parse</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">process_symbol</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					  <span class="kt">char</span> <span class="n">type</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">line</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_failure</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">feof</span><span class="p">(</span><span class="n">file</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">start</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">line_len</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">symbol_type</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">symbol_name</span><span class="p">;</span>

		<span class="n">line_len</span> <span class="o">=</span> <span class="n">getline</span><span class="p">(</span><span class="o">&amp;</span><span class="n">line</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">line_len</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">line</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">line</span><span class="p">[</span><span class="o">--</span><span class="n">line_len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="cm">/* \n */</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">hex2u64</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>

		<span class="n">len</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="n">line_len</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">symbol_type</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">len</span><span class="p">];</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">symbol_name</span> <span class="o">=</span> <span class="n">line</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">line_len</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">KSYM_NAME_LEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * module symbols are not sorted so we add all</span>
<span class="cm">		 * symbols with zero length and rely on</span>
<span class="cm">		 * symbols__fixup_end() to fix it up.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">process_symbol</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">symbol_name</span><span class="p">,</span>
				     <span class="n">symbol_type</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">free</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
	<span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_failure:</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">process_kallsyms_args</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">kallsyms2elf_type</span><span class="p">(</span><span class="kt">char</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="sc">&#39;W&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">STB_WEAK</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">isupper</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="o">?</span> <span class="n">STB_GLOBAL</span> <span class="o">:</span> <span class="n">STB_LOCAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">map__process_kallsym_symbol</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				       <span class="kt">char</span> <span class="n">type</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">process_kallsyms_args</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbols</span><span class="p">[</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">symbol_type__is_a</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sym</span> <span class="o">=</span> <span class="n">symbol__new</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			  <span class="n">kallsyms2elf_type</span><span class="p">(</span><span class="n">type</span><span class="p">),</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We will pass the symbols to the filter later, in</span>
<span class="cm">	 * map__split_kallsyms, when we have split the maps per module</span>
<span class="cm">	 */</span>
	<span class="n">symbols__insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">sym</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Loads the function entries in /proc/kallsyms into kernel_map-&gt;dso,</span>
<span class="cm"> * so that we can in the next step set the symbol -&gt;end address and then</span>
<span class="cm"> * call kernel_maps__split_kallsyms.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dso__load_all_kallsyms</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">process_kallsyms_args</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">map</span><span class="p">,</span> <span class="p">.</span><span class="n">dso</span> <span class="o">=</span> <span class="n">dso</span><span class="p">,</span> <span class="p">};</span>
	<span class="k">return</span> <span class="n">kallsyms__parse</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">map__process_kallsym_symbol</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Split the symbols into maps, making sure there are no overlaps, i.e. the</span>
<span class="cm"> * kernel range is broken in several maps, named [kernel].N, as we don&#39;t have</span>
<span class="cm"> * the original ELF section names vmlinux have.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dso__split_kallsyms</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
			       <span class="n">symbol_filter_t</span> <span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_groups</span> <span class="o">*</span><span class="n">kmaps</span> <span class="o">=</span> <span class="n">map__kmap</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kmaps</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span> <span class="o">=</span> <span class="n">kmaps</span><span class="o">-&gt;</span><span class="n">machine</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">curr_map</span> <span class="o">=</span> <span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">moved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbols</span><span class="p">[</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">kernel_range</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">module</span><span class="p">;</span>

		<span class="n">pos</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>

		<span class="n">module</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="sc">&#39;\t&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">module</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">use_modules</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">discard_symbol</span><span class="p">;</span>

			<span class="o">*</span><span class="n">module</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">curr_map</span><span class="o">-&gt;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">short_name</span><span class="p">,</span> <span class="n">module</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">curr_map</span> <span class="o">!=</span> <span class="n">map</span> <span class="o">&amp;&amp;</span>
				    <span class="n">dso</span><span class="o">-&gt;</span><span class="n">kernel</span> <span class="o">==</span> <span class="n">DSO_TYPE_GUEST_KERNEL</span> <span class="o">&amp;&amp;</span>
				    <span class="n">machine__is_default_guest</span><span class="p">(</span><span class="n">machine</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * We assume all symbols of a module are</span>
<span class="cm">					 * continuous in * kallsyms, so curr_map</span>
<span class="cm">					 * points to a module and all its</span>
<span class="cm">					 * symbols are in its kmap. Mark it as</span>
<span class="cm">					 * loaded.</span>
<span class="cm">					 */</span>
					<span class="n">dso__set_loaded</span><span class="p">(</span><span class="n">curr_map</span><span class="o">-&gt;</span><span class="n">dso</span><span class="p">,</span>
							<span class="n">curr_map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">curr_map</span> <span class="o">=</span> <span class="n">map_groups__find_by_name</span><span class="p">(</span><span class="n">kmaps</span><span class="p">,</span>
							<span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">module</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">curr_map</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s/proc/{kallsyms,modules} &quot;</span>
					         <span class="s">&quot;inconsistency while looking &quot;</span>
						 <span class="s">&quot;for </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> module!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						 <span class="n">machine</span><span class="o">-&gt;</span><span class="n">root_dir</span><span class="p">,</span> <span class="n">module</span><span class="p">);</span>
					<span class="n">curr_map</span> <span class="o">=</span> <span class="n">map</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">discard_symbol</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">curr_map</span><span class="o">-&gt;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">loaded</span> <span class="o">&amp;&amp;</span>
				    <span class="o">!</span><span class="n">machine__is_default_guest</span><span class="p">(</span><span class="n">machine</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">discard_symbol</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * So that we look just like we get from .ko files,</span>
<span class="cm">			 * i.e. not prelinked, relative to map-&gt;start.</span>
<span class="cm">			 */</span>
			<span class="n">pos</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">curr_map</span><span class="o">-&gt;</span><span class="n">map_ip</span><span class="p">(</span><span class="n">curr_map</span><span class="p">,</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
			<span class="n">pos</span><span class="o">-&gt;</span><span class="n">end</span>   <span class="o">=</span> <span class="n">curr_map</span><span class="o">-&gt;</span><span class="n">map_ip</span><span class="p">(</span><span class="n">curr_map</span><span class="p">,</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">curr_map</span> <span class="o">!=</span> <span class="n">map</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="n">dso_name</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">ndso</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">curr_map</span> <span class="o">=</span> <span class="n">map</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">filter_symbol</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">kernel</span> <span class="o">==</span> <span class="n">DSO_TYPE_GUEST_KERNEL</span><span class="p">)</span>
				<span class="n">snprintf</span><span class="p">(</span><span class="n">dso_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dso_name</span><span class="p">),</span>
					<span class="s">&quot;[guest.kernel].%d&quot;</span><span class="p">,</span>
					<span class="n">kernel_range</span><span class="o">++</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">snprintf</span><span class="p">(</span><span class="n">dso_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dso_name</span><span class="p">),</span>
					<span class="s">&quot;[kernel].%d&quot;</span><span class="p">,</span>
					<span class="n">kernel_range</span><span class="o">++</span><span class="p">);</span>

			<span class="n">ndso</span> <span class="o">=</span> <span class="n">dso__new</span><span class="p">(</span><span class="n">dso_name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndso</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

			<span class="n">ndso</span><span class="o">-&gt;</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">kernel</span><span class="p">;</span>

			<span class="n">curr_map</span> <span class="o">=</span> <span class="n">map__new2</span><span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">ndso</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr_map</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dso__delete</span><span class="p">(</span><span class="n">ndso</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">curr_map</span><span class="o">-&gt;</span><span class="n">map_ip</span> <span class="o">=</span> <span class="n">curr_map</span><span class="o">-&gt;</span><span class="n">unmap_ip</span> <span class="o">=</span> <span class="n">identity__map_ip</span><span class="p">;</span>
			<span class="n">map_groups__insert</span><span class="p">(</span><span class="n">kmaps</span><span class="p">,</span> <span class="n">curr_map</span><span class="p">);</span>
			<span class="o">++</span><span class="n">kernel_range</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">filter_symbol:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filter</span> <span class="o">&amp;&amp;</span> <span class="n">filter</span><span class="p">(</span><span class="n">curr_map</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span> <span class="p">{</span>
<span class="nl">discard_symbol:</span>		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
			<span class="n">symbol__delete</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr_map</span> <span class="o">!=</span> <span class="n">map</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
				<span class="n">symbols__insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr_map</span><span class="o">-&gt;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbols</span><span class="p">[</span><span class="n">curr_map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">],</span> <span class="n">pos</span><span class="p">);</span>
				<span class="o">++</span><span class="n">moved</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="o">++</span><span class="n">count</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curr_map</span> <span class="o">!=</span> <span class="n">map</span> <span class="o">&amp;&amp;</span>
	    <span class="n">dso</span><span class="o">-&gt;</span><span class="n">kernel</span> <span class="o">==</span> <span class="n">DSO_TYPE_GUEST_KERNEL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">machine__is_default_guest</span><span class="p">(</span><span class="n">kmaps</span><span class="o">-&gt;</span><span class="n">machine</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dso__set_loaded</span><span class="p">(</span><span class="n">curr_map</span><span class="o">-&gt;</span><span class="n">dso</span><span class="p">,</span> <span class="n">curr_map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span> <span class="o">+</span> <span class="n">moved</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">symbol__restricted_filename</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">restricted_filename</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="k">restricted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">kptr_restrict</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">realpath</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">restricted</span> <span class="o">=</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">restricted_filename</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">free</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
			<span class="k">return</span> <span class="k">restricted</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="k">restricted</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dso__load_kallsyms</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">symbol_filter_t</span> <span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">symbol__restricted_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;/proc/kallsyms&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dso__load_all_kallsyms</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">map</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">symbols__fixup_duplicate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbols</span><span class="p">[</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">]);</span>
	<span class="n">symbols__fixup_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbols</span><span class="p">[</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">kernel</span> <span class="o">==</span> <span class="n">DSO_TYPE_GUEST_KERNEL</span><span class="p">)</span>
		<span class="n">dso</span><span class="o">-&gt;</span><span class="n">symtab_type</span> <span class="o">=</span> <span class="n">SYMTAB__GUEST_KALLSYMS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dso</span><span class="o">-&gt;</span><span class="n">symtab_type</span> <span class="o">=</span> <span class="n">SYMTAB__KALLSYMS</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dso__split_kallsyms</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dso__load_perf_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
			      <span class="n">symbol_filter_t</span> <span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">line</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_syms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">long_name</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_failure</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">feof</span><span class="p">(</span><span class="n">file</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">line_len</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">line_len</span> <span class="o">=</span> <span class="n">getline</span><span class="p">(</span><span class="o">&amp;</span><span class="n">line</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">line_len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">line</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_failure</span><span class="p">;</span>

		<span class="n">line</span><span class="p">[</span><span class="o">--</span><span class="n">line_len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="cm">/* \n */</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">hex2u64</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>

		<span class="n">len</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="n">line_len</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">hex2u64</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>

		<span class="n">len</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="n">line_len</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">sym</span> <span class="o">=</span> <span class="n">symbol__new</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">STB_GLOBAL</span><span class="p">,</span> <span class="n">line</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sym</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_delete_line</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">filter</span> <span class="o">&amp;&amp;</span> <span class="n">filter</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">sym</span><span class="p">))</span>
			<span class="n">symbol__delete</span><span class="p">(</span><span class="n">sym</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">symbols__insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbols</span><span class="p">[</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">],</span> <span class="n">sym</span><span class="p">);</span>
			<span class="n">nr_syms</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">free</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
	<span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nr_syms</span><span class="p">;</span>

<span class="nl">out_delete_line:</span>
	<span class="n">free</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
<span class="nl">out_failure:</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * elf_symtab__for_each_symbol - iterate thru all the symbols</span>
<span class="cm"> *</span>
<span class="cm"> * @syms: struct elf_symtab instance to iterate</span>
<span class="cm"> * @idx: uint32_t idx</span>
<span class="cm"> * @sym: GElf_Sym iterator</span>
<span class="cm"> */</span>
<span class="cp">#define elf_symtab__for_each_symbol(syms, nr_syms, idx, sym) \</span>
<span class="cp">	for (idx = 0, gelf_getsym(syms, idx, &amp;sym);\</span>
<span class="cp">	     idx &lt; nr_syms; \</span>
<span class="cp">	     idx++, gelf_getsym(syms, idx, &amp;sym))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint8_t</span> <span class="nf">elf_sym__type</span><span class="p">(</span><span class="k">const</span> <span class="n">GElf_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">GELF_ST_TYPE</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">elf_sym__is_function</span><span class="p">(</span><span class="k">const</span> <span class="n">GElf_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">elf_sym__type</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="o">==</span> <span class="n">STT_FUNC</span> <span class="o">&amp;&amp;</span>
	       <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	       <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span> <span class="o">!=</span> <span class="n">SHN_UNDEF</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">elf_sym__is_object</span><span class="p">(</span><span class="k">const</span> <span class="n">GElf_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">elf_sym__type</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="o">==</span> <span class="n">STT_OBJECT</span> <span class="o">&amp;&amp;</span>
		<span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		<span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span> <span class="o">!=</span> <span class="n">SHN_UNDEF</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">elf_sym__is_label</span><span class="p">(</span><span class="k">const</span> <span class="n">GElf_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">elf_sym__type</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="o">==</span> <span class="n">STT_NOTYPE</span> <span class="o">&amp;&amp;</span>
		<span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		<span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span> <span class="o">!=</span> <span class="n">SHN_UNDEF</span> <span class="o">&amp;&amp;</span>
		<span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span> <span class="o">!=</span> <span class="n">SHN_ABS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">elf_sec__name</span><span class="p">(</span><span class="k">const</span> <span class="n">GElf_Shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">Elf_Data</span> <span class="o">*</span><span class="n">secstrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">secstrs</span><span class="o">-&gt;</span><span class="n">d_buf</span> <span class="o">+</span> <span class="n">shdr</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">elf_sec__is_text</span><span class="p">(</span><span class="k">const</span> <span class="n">GElf_Shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">Elf_Data</span> <span class="o">*</span><span class="n">secstrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">strstr</span><span class="p">(</span><span class="n">elf_sec__name</span><span class="p">(</span><span class="n">shdr</span><span class="p">,</span> <span class="n">secstrs</span><span class="p">),</span> <span class="s">&quot;text&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">elf_sec__is_data</span><span class="p">(</span><span class="k">const</span> <span class="n">GElf_Shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">Elf_Data</span> <span class="o">*</span><span class="n">secstrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">strstr</span><span class="p">(</span><span class="n">elf_sec__name</span><span class="p">(</span><span class="n">shdr</span><span class="p">,</span> <span class="n">secstrs</span><span class="p">),</span> <span class="s">&quot;data&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">elf_sym__name</span><span class="p">(</span><span class="k">const</span> <span class="n">GElf_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">Elf_Data</span> <span class="o">*</span><span class="n">symstrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">symstrs</span><span class="o">-&gt;</span><span class="n">d_buf</span> <span class="o">+</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Elf_Scn</span> <span class="o">*</span><span class="nf">elf_section_by_name</span><span class="p">(</span><span class="n">Elf</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="n">GElf_Ehdr</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				    <span class="n">GElf_Shdr</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="o">*</span><span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf_Scn</span> <span class="o">*</span><span class="n">sec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">sec</span> <span class="o">=</span> <span class="n">elf_nextscn</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sec</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>

		<span class="n">gelf_getshdr</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">shp</span><span class="p">);</span>
		<span class="n">str</span> <span class="o">=</span> <span class="n">elf_strptr</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">e_shstrndx</span><span class="p">,</span> <span class="n">shp</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">str</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">idx</span><span class="p">)</span>
				<span class="o">*</span><span class="n">idx</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">++</span><span class="n">cnt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sec</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define elf_section__for_each_rel(reldata, pos, pos_mem, idx, nr_entries) \</span>
<span class="cp">	for (idx = 0, pos = gelf_getrel(reldata, 0, &amp;pos_mem); \</span>
<span class="cp">	     idx &lt; nr_entries; \</span>
<span class="cp">	     ++idx, pos = gelf_getrel(reldata, idx, &amp;pos_mem))</span>

<span class="cp">#define elf_section__for_each_rela(reldata, pos, pos_mem, idx, nr_entries) \</span>
<span class="cp">	for (idx = 0, pos = gelf_getrela(reldata, 0, &amp;pos_mem); \</span>
<span class="cp">	     idx &lt; nr_entries; \</span>
<span class="cp">	     ++idx, pos = gelf_getrela(reldata, idx, &amp;pos_mem))</span>

<span class="cm">/*</span>
<span class="cm"> * We need to check if we have a .dynsym, so that we can handle the</span>
<span class="cm"> * .plt, synthesizing its symbols, that aren&#39;t on the symtabs (be it</span>
<span class="cm"> * .dynsym or .symtab).</span>
<span class="cm"> * And always look at the original dso, not at debuginfo packages, that</span>
<span class="cm"> * have the PLT data stripped out (shdr_rel_plt.sh_type == SHT_NOBITS).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">dso__synthesize_plt_symbols</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
			    <span class="n">symbol_filter_t</span> <span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">nr_rel_entries</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">GElf_Sym</span> <span class="n">sym</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">plt_offset</span><span class="p">;</span>
	<span class="n">GElf_Shdr</span> <span class="n">shdr_plt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="n">GElf_Shdr</span> <span class="n">shdr_rel_plt</span><span class="p">,</span> <span class="n">shdr_dynsym</span><span class="p">;</span>
	<span class="n">Elf_Data</span> <span class="o">*</span><span class="n">reldata</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">,</span> <span class="o">*</span><span class="n">symstrs</span><span class="p">;</span>
	<span class="n">Elf_Scn</span> <span class="o">*</span><span class="n">scn_plt_rel</span><span class="p">,</span> <span class="o">*</span><span class="n">scn_symstrs</span><span class="p">,</span> <span class="o">*</span><span class="n">scn_dynsym</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">dynsym_idx</span><span class="p">;</span>
	<span class="n">GElf_Ehdr</span> <span class="n">ehdr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">sympltname</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
	<span class="n">Elf</span> <span class="o">*</span><span class="n">elf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">symidx</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">elf</span> <span class="o">=</span> <span class="n">elf_begin</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">PERF_ELF_C_READ_MMAP</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">elf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_close</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gelf_getehdr</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehdr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

	<span class="n">scn_dynsym</span> <span class="o">=</span> <span class="n">elf_section_by_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr_dynsym</span><span class="p">,</span>
					 <span class="s">&quot;.dynsym&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dynsym_idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scn_dynsym</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

	<span class="n">scn_plt_rel</span> <span class="o">=</span> <span class="n">elf_section_by_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr_rel_plt</span><span class="p">,</span>
					  <span class="s">&quot;.rela.plt&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scn_plt_rel</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scn_plt_rel</span> <span class="o">=</span> <span class="n">elf_section_by_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr_rel_plt</span><span class="p">,</span>
						  <span class="s">&quot;.rel.plt&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scn_plt_rel</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_rel_plt</span><span class="p">.</span><span class="n">sh_link</span> <span class="o">!=</span> <span class="n">dynsym_idx</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">elf_section_by_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr_plt</span><span class="p">,</span> <span class="s">&quot;.plt&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fetch the relocation section to find the idxes to the GOT</span>
<span class="cm">	 * and the symbols in the .dynsym they refer to.</span>
<span class="cm">	 */</span>
	<span class="n">reldata</span> <span class="o">=</span> <span class="n">elf_getdata</span><span class="p">(</span><span class="n">scn_plt_rel</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reldata</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

	<span class="n">syms</span> <span class="o">=</span> <span class="n">elf_getdata</span><span class="p">(</span><span class="n">scn_dynsym</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">syms</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

	<span class="n">scn_symstrs</span> <span class="o">=</span> <span class="n">elf_getscn</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">shdr_dynsym</span><span class="p">.</span><span class="n">sh_link</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scn_symstrs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

	<span class="n">symstrs</span> <span class="o">=</span> <span class="n">elf_getdata</span><span class="p">(</span><span class="n">scn_symstrs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">symstrs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

	<span class="n">nr_rel_entries</span> <span class="o">=</span> <span class="n">shdr_rel_plt</span><span class="p">.</span><span class="n">sh_size</span> <span class="o">/</span> <span class="n">shdr_rel_plt</span><span class="p">.</span><span class="n">sh_entsize</span><span class="p">;</span>
	<span class="n">plt_offset</span> <span class="o">=</span> <span class="n">shdr_plt</span><span class="p">.</span><span class="n">sh_offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_rel_plt</span><span class="p">.</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_RELA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">GElf_Rela</span> <span class="n">pos_mem</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

		<span class="n">elf_section__for_each_rela</span><span class="p">(</span><span class="n">reldata</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">pos_mem</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span>
					   <span class="n">nr_rel_entries</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">symidx</span> <span class="o">=</span> <span class="n">GELF_R_SYM</span><span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">);</span>
			<span class="n">plt_offset</span> <span class="o">+=</span> <span class="n">shdr_plt</span><span class="p">.</span><span class="n">sh_entsize</span><span class="p">;</span>
			<span class="n">gelf_getsym</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">symidx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sym</span><span class="p">);</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">sympltname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sympltname</span><span class="p">),</span>
				 <span class="s">&quot;%s@plt&quot;</span><span class="p">,</span> <span class="n">elf_sym__name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym</span><span class="p">,</span> <span class="n">symstrs</span><span class="p">));</span>

			<span class="n">f</span> <span class="o">=</span> <span class="n">symbol__new</span><span class="p">(</span><span class="n">plt_offset</span><span class="p">,</span> <span class="n">shdr_plt</span><span class="p">.</span><span class="n">sh_entsize</span><span class="p">,</span>
					<span class="n">STB_GLOBAL</span><span class="p">,</span> <span class="n">sympltname</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">filter</span> <span class="o">&amp;&amp;</span> <span class="n">filter</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
				<span class="n">symbol__delete</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">symbols__insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbols</span><span class="p">[</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">],</span> <span class="n">f</span><span class="p">);</span>
				<span class="o">++</span><span class="n">nr</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">shdr_rel_plt</span><span class="p">.</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_REL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">GElf_Rel</span> <span class="n">pos_mem</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
		<span class="n">elf_section__for_each_rel</span><span class="p">(</span><span class="n">reldata</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">pos_mem</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span>
					  <span class="n">nr_rel_entries</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">symidx</span> <span class="o">=</span> <span class="n">GELF_R_SYM</span><span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">);</span>
			<span class="n">plt_offset</span> <span class="o">+=</span> <span class="n">shdr_plt</span><span class="p">.</span><span class="n">sh_entsize</span><span class="p">;</span>
			<span class="n">gelf_getsym</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">symidx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sym</span><span class="p">);</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">sympltname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sympltname</span><span class="p">),</span>
				 <span class="s">&quot;%s@plt&quot;</span><span class="p">,</span> <span class="n">elf_sym__name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym</span><span class="p">,</span> <span class="n">symstrs</span><span class="p">));</span>

			<span class="n">f</span> <span class="o">=</span> <span class="n">symbol__new</span><span class="p">(</span><span class="n">plt_offset</span><span class="p">,</span> <span class="n">shdr_plt</span><span class="p">.</span><span class="n">sh_entsize</span><span class="p">,</span>
					<span class="n">STB_GLOBAL</span><span class="p">,</span> <span class="n">sympltname</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">filter</span> <span class="o">&amp;&amp;</span> <span class="n">filter</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
				<span class="n">symbol__delete</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">symbols__insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbols</span><span class="p">[</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">],</span> <span class="n">f</span><span class="p">);</span>
				<span class="o">++</span><span class="n">nr</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_elf_end:</span>
	<span class="n">elf_end</span><span class="p">(</span><span class="n">elf</span><span class="p">);</span>
<span class="nl">out_close:</span>
	<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">nr</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: problems reading %s PLT info.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">__func__</span><span class="p">,</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">long_name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">elf_sym__is_a</span><span class="p">(</span><span class="n">GElf_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">,</span> <span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MAP__FUNCTION</span>:
		<span class="k">return</span> <span class="n">elf_sym__is_function</span><span class="p">(</span><span class="n">sym</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">MAP__VARIABLE</span>:
		<span class="k">return</span> <span class="n">elf_sym__is_object</span><span class="p">(</span><span class="n">sym</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">elf_sec__is_a</span><span class="p">(</span><span class="n">GElf_Shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">,</span> <span class="n">Elf_Data</span> <span class="o">*</span><span class="n">secstrs</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MAP__FUNCTION</span>:
		<span class="k">return</span> <span class="n">elf_sec__is_text</span><span class="p">(</span><span class="n">shdr</span><span class="p">,</span> <span class="n">secstrs</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">MAP__VARIABLE</span>:
		<span class="k">return</span> <span class="n">elf_sec__is_data</span><span class="p">(</span><span class="n">shdr</span><span class="p">,</span> <span class="n">secstrs</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">elf_addr_to_index</span><span class="p">(</span><span class="n">Elf</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="n">GElf_Addr</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf_Scn</span> <span class="o">*</span><span class="n">sec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">GElf_Shdr</span> <span class="n">shdr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">sec</span> <span class="o">=</span> <span class="n">elf_nextscn</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sec</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gelf_getshdr</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">shdr</span><span class="p">.</span><span class="n">sh_addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">shdr</span><span class="p">.</span><span class="n">sh_addr</span> <span class="o">+</span> <span class="n">shdr</span><span class="p">.</span><span class="n">sh_size</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>

		<span class="o">++</span><span class="n">cnt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dso__swap_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">eidata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">endian</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dso</span><span class="o">-&gt;</span><span class="n">needs_swap</span> <span class="o">=</span> <span class="n">DSO_SWAP__NO</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">eidata</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ELFDATA2LSB</span>:
		<span class="cm">/* We are big endian, DSO is little endian. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">endian</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">dso</span><span class="o">-&gt;</span><span class="n">needs_swap</span> <span class="o">=</span> <span class="n">DSO_SWAP__YES</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ELFDATA2MSB</span>:
		<span class="cm">/* We are little endian, DSO is big endian. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">endian</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dso</span><span class="o">-&gt;</span><span class="n">needs_swap</span> <span class="o">=</span> <span class="n">DSO_SWAP__YES</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;unrecognized DSO data encoding %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">eidata</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dso__load_sym</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">symbol_filter_t</span> <span class="n">filter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kmodule</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">want_symtab</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmap</span> <span class="o">*</span><span class="n">kmap</span> <span class="o">=</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">kernel</span> <span class="o">?</span> <span class="n">map__kmap</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">curr_map</span> <span class="o">=</span> <span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">curr_dso</span> <span class="o">=</span> <span class="n">dso</span><span class="p">;</span>
	<span class="n">Elf_Data</span> <span class="o">*</span><span class="n">symstrs</span><span class="p">,</span> <span class="o">*</span><span class="n">secstrs</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">nr_syms</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">GElf_Ehdr</span> <span class="n">ehdr</span><span class="p">;</span>
	<span class="n">GElf_Shdr</span> <span class="n">shdr</span><span class="p">,</span> <span class="n">opdshdr</span><span class="p">;</span>
	<span class="n">Elf_Data</span> <span class="o">*</span><span class="n">syms</span><span class="p">,</span> <span class="o">*</span><span class="n">opddata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">GElf_Sym</span> <span class="n">sym</span><span class="p">;</span>
	<span class="n">Elf_Scn</span> <span class="o">*</span><span class="n">sec</span><span class="p">,</span> <span class="o">*</span><span class="n">sec_strndx</span><span class="p">,</span> <span class="o">*</span><span class="n">opdsec</span><span class="p">;</span>
	<span class="n">Elf</span> <span class="o">*</span><span class="n">elf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">opdidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">elf</span> <span class="o">=</span> <span class="n">elf_begin</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">PERF_ELF_C_READ_MMAP</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">elf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: cannot read %s ELF file.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_close</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gelf_getehdr</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehdr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: cannot get elf header.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dso__swap_init</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">ehdr</span><span class="p">.</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_DATA</span><span class="p">]))</span>
		<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

	<span class="cm">/* Always reject images with a mismatched build-id: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">has_build_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">build_id</span><span class="p">[</span><span class="n">BUILD_ID_SIZE</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">elf_read_build_id</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">build_id</span><span class="p">,</span> <span class="n">BUILD_ID_SIZE</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dso__build_id_equal</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">build_id</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sec</span> <span class="o">=</span> <span class="n">elf_section_by_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="p">,</span> <span class="s">&quot;.symtab&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sec</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">want_symtab</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

		<span class="n">sec</span> <span class="o">=</span> <span class="n">elf_section_by_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="p">,</span> <span class="s">&quot;.dynsym&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sec</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">opdsec</span> <span class="o">=</span> <span class="n">elf_section_by_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opdshdr</span><span class="p">,</span> <span class="s">&quot;.opd&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opdidx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opdshdr</span><span class="p">.</span><span class="n">sh_type</span> <span class="o">!=</span> <span class="n">SHT_PROGBITS</span><span class="p">)</span>
		<span class="n">opdsec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opdsec</span><span class="p">)</span>
		<span class="n">opddata</span> <span class="o">=</span> <span class="n">elf_rawdata</span><span class="p">(</span><span class="n">opdsec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">syms</span> <span class="o">=</span> <span class="n">elf_getdata</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">syms</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

	<span class="n">sec</span> <span class="o">=</span> <span class="n">elf_getscn</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">shdr</span><span class="p">.</span><span class="n">sh_link</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sec</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

	<span class="n">symstrs</span> <span class="o">=</span> <span class="n">elf_getdata</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">symstrs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

	<span class="n">sec_strndx</span> <span class="o">=</span> <span class="n">elf_getscn</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">ehdr</span><span class="p">.</span><span class="n">e_shstrndx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sec_strndx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

	<span class="n">secstrs</span> <span class="o">=</span> <span class="n">elf_getdata</span><span class="p">(</span><span class="n">sec_strndx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">secstrs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

	<span class="n">nr_syms</span> <span class="o">=</span> <span class="n">shdr</span><span class="p">.</span><span class="n">sh_size</span> <span class="o">/</span> <span class="n">shdr</span><span class="p">.</span><span class="n">sh_entsize</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sym</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">kernel</span> <span class="o">==</span> <span class="n">DSO_TYPE_USER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dso</span><span class="o">-&gt;</span><span class="n">adjust_symbols</span> <span class="o">=</span> <span class="p">(</span><span class="n">ehdr</span><span class="p">.</span><span class="n">e_type</span> <span class="o">==</span> <span class="n">ET_EXEC</span> <span class="o">||</span>
				<span class="n">elf_section_by_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="p">,</span>
						     <span class="s">&quot;.gnu.prelink_undo&quot;</span><span class="p">,</span>
						     <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dso</span><span class="o">-&gt;</span><span class="n">adjust_symbols</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">elf_symtab__for_each_symbol</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">nr_syms</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">elf_name</span> <span class="o">=</span> <span class="n">elf_sym__name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym</span><span class="p">,</span> <span class="n">symstrs</span><span class="p">);</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">demangled</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">is_label</span> <span class="o">=</span> <span class="n">elf_sym__is_label</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym</span><span class="p">);</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">section_name</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">kmap</span> <span class="o">&amp;&amp;</span> <span class="n">kmap</span><span class="o">-&gt;</span><span class="n">ref_reloc_sym</span> <span class="o">&amp;&amp;</span> <span class="n">kmap</span><span class="o">-&gt;</span><span class="n">ref_reloc_sym</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&amp;&amp;</span>
		    <span class="n">strcmp</span><span class="p">(</span><span class="n">elf_name</span><span class="p">,</span> <span class="n">kmap</span><span class="o">-&gt;</span><span class="n">ref_reloc_sym</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">kmap</span><span class="o">-&gt;</span><span class="n">ref_reloc_sym</span><span class="o">-&gt;</span><span class="n">unrelocated_addr</span> <span class="o">=</span> <span class="n">sym</span><span class="p">.</span><span class="n">st_value</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_label</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">elf_sym__is_a</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Reject ARM ELF &quot;mapping symbols&quot;: these aren&#39;t unique and</span>
<span class="cm">		 * don&#39;t identify functions, so will confuse the profile</span>
<span class="cm">		 * output: */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ehdr</span><span class="p">.</span><span class="n">e_machine</span> <span class="o">==</span> <span class="n">EM_ARM</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">elf_name</span><span class="p">,</span> <span class="s">&quot;$a&quot;</span><span class="p">)</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">elf_name</span><span class="p">,</span> <span class="s">&quot;$d&quot;</span><span class="p">)</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">elf_name</span><span class="p">,</span> <span class="s">&quot;$t&quot;</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">opdsec</span> <span class="o">&amp;&amp;</span> <span class="n">sym</span><span class="p">.</span><span class="n">st_shndx</span> <span class="o">==</span> <span class="n">opdidx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">sym</span><span class="p">.</span><span class="n">st_value</span> <span class="o">-</span> <span class="n">opdshdr</span><span class="p">.</span><span class="n">sh_addr</span><span class="p">;</span>
			<span class="n">u64</span> <span class="o">*</span><span class="n">opd</span> <span class="o">=</span> <span class="n">opddata</span><span class="o">-&gt;</span><span class="n">d_buf</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
			<span class="n">sym</span><span class="p">.</span><span class="n">st_value</span> <span class="o">=</span> <span class="n">DSO__SWAP</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="o">*</span><span class="n">opd</span><span class="p">);</span>
			<span class="n">sym</span><span class="p">.</span><span class="n">st_shndx</span> <span class="o">=</span> <span class="n">elf_addr_to_index</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sym</span><span class="p">.</span><span class="n">st_value</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">sec</span> <span class="o">=</span> <span class="n">elf_getscn</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sym</span><span class="p">.</span><span class="n">st_shndx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sec</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

		<span class="n">gelf_getshdr</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_label</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">elf_sec__is_a</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shdr</span><span class="p">,</span> <span class="n">secstrs</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">section_name</span> <span class="o">=</span> <span class="n">elf_sec__name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shdr</span><span class="p">,</span> <span class="n">secstrs</span><span class="p">);</span>

		<span class="cm">/* On ARM, symbols for thumb functions have 1 added to</span>
<span class="cm">		 * the symbol address as a flag - remove it */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ehdr</span><span class="p">.</span><span class="n">e_machine</span> <span class="o">==</span> <span class="n">EM_ARM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">MAP__FUNCTION</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">sym</span><span class="p">.</span><span class="n">st_value</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
			<span class="o">--</span><span class="n">sym</span><span class="p">.</span><span class="n">st_value</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">kernel</span> <span class="o">!=</span> <span class="n">DSO_TYPE_USER</span> <span class="o">||</span> <span class="n">kmodule</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="n">dso_name</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">section_name</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">curr_dso</span><span class="o">-&gt;</span><span class="n">short_name</span> <span class="o">+</span>
				    <span class="n">dso</span><span class="o">-&gt;</span><span class="n">short_name_len</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">new_symbol</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">section_name</span><span class="p">,</span> <span class="s">&quot;.text&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">curr_map</span> <span class="o">=</span> <span class="n">map</span><span class="p">;</span>
				<span class="n">curr_dso</span> <span class="o">=</span> <span class="n">dso</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">new_symbol</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">snprintf</span><span class="p">(</span><span class="n">dso_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dso_name</span><span class="p">),</span>
				 <span class="s">&quot;%s%s&quot;</span><span class="p">,</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">short_name</span><span class="p">,</span> <span class="n">section_name</span><span class="p">);</span>

			<span class="n">curr_map</span> <span class="o">=</span> <span class="n">map_groups__find_by_name</span><span class="p">(</span><span class="n">kmap</span><span class="o">-&gt;</span><span class="n">kmaps</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">dso_name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr_map</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u64</span> <span class="n">start</span> <span class="o">=</span> <span class="n">sym</span><span class="p">.</span><span class="n">st_value</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">kmodule</span><span class="p">)</span>
					<span class="n">start</span> <span class="o">+=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">shdr</span><span class="p">.</span><span class="n">sh_offset</span><span class="p">;</span>

				<span class="n">curr_dso</span> <span class="o">=</span> <span class="n">dso__new</span><span class="p">(</span><span class="n">dso_name</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">curr_dso</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>
				<span class="n">curr_dso</span><span class="o">-&gt;</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">kernel</span><span class="p">;</span>
				<span class="n">curr_dso</span><span class="o">-&gt;</span><span class="n">long_name</span> <span class="o">=</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">long_name</span><span class="p">;</span>
				<span class="n">curr_dso</span><span class="o">-&gt;</span><span class="n">long_name_len</span> <span class="o">=</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">long_name_len</span><span class="p">;</span>
				<span class="n">curr_map</span> <span class="o">=</span> <span class="n">map__new2</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">curr_dso</span><span class="p">,</span>
						     <span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">curr_map</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dso__delete</span><span class="p">(</span><span class="n">curr_dso</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">curr_map</span><span class="o">-&gt;</span><span class="n">map_ip</span> <span class="o">=</span> <span class="n">identity__map_ip</span><span class="p">;</span>
				<span class="n">curr_map</span><span class="o">-&gt;</span><span class="n">unmap_ip</span> <span class="o">=</span> <span class="n">identity__map_ip</span><span class="p">;</span>
				<span class="n">curr_dso</span><span class="o">-&gt;</span><span class="n">symtab_type</span> <span class="o">=</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">symtab_type</span><span class="p">;</span>
				<span class="n">map_groups__insert</span><span class="p">(</span><span class="n">kmap</span><span class="o">-&gt;</span><span class="n">kmaps</span><span class="p">,</span> <span class="n">curr_map</span><span class="p">);</span>
				<span class="n">dsos__add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">curr_dso</span><span class="p">);</span>
				<span class="n">dso__set_loaded</span><span class="p">(</span><span class="n">curr_dso</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">curr_dso</span> <span class="o">=</span> <span class="n">curr_map</span><span class="o">-&gt;</span><span class="n">dso</span><span class="p">;</span>

			<span class="k">goto</span> <span class="n">new_symbol</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">curr_dso</span><span class="o">-&gt;</span><span class="n">adjust_symbols</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug4</span><span class="p">(</span><span class="s">&quot;%s: adjusting symbol: st_value: %#&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; &quot;</span>
				  <span class="s">&quot;sh_addr: %#&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; sh_offset: %#&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				  <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">sym</span><span class="p">.</span><span class="n">st_value</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">shdr</span><span class="p">.</span><span class="n">sh_addr</span><span class="p">,</span>
				  <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">shdr</span><span class="p">.</span><span class="n">sh_offset</span><span class="p">);</span>
			<span class="n">sym</span><span class="p">.</span><span class="n">st_value</span> <span class="o">-=</span> <span class="n">shdr</span><span class="p">.</span><span class="n">sh_addr</span> <span class="o">-</span> <span class="n">shdr</span><span class="p">.</span><span class="n">sh_offset</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * We need to figure out if the object was created from C++ sources</span>
<span class="cm">		 * DWARF DW_compile_unit has this, but we don&#39;t always have access</span>
<span class="cm">		 * to it...</span>
<span class="cm">		 */</span>
		<span class="n">demangled</span> <span class="o">=</span> <span class="n">bfd_demangle</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">elf_name</span><span class="p">,</span> <span class="n">DMGL_PARAMS</span> <span class="o">|</span> <span class="n">DMGL_ANSI</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">demangled</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">elf_name</span> <span class="o">=</span> <span class="n">demangled</span><span class="p">;</span>
<span class="nl">new_symbol:</span>
		<span class="n">f</span> <span class="o">=</span> <span class="n">symbol__new</span><span class="p">(</span><span class="n">sym</span><span class="p">.</span><span class="n">st_value</span><span class="p">,</span> <span class="n">sym</span><span class="p">.</span><span class="n">st_size</span><span class="p">,</span>
				<span class="n">GELF_ST_BIND</span><span class="p">(</span><span class="n">sym</span><span class="p">.</span><span class="n">st_info</span><span class="p">),</span> <span class="n">elf_name</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">demangled</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_elf_end</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">filter</span> <span class="o">&amp;&amp;</span> <span class="n">filter</span><span class="p">(</span><span class="n">curr_map</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
			<span class="n">symbol__delete</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">symbols__insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr_dso</span><span class="o">-&gt;</span><span class="n">symbols</span><span class="p">[</span><span class="n">curr_map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">],</span> <span class="n">f</span><span class="p">);</span>
			<span class="n">nr</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For misannotated, zeroed, ASM function sizes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">symbols__fixup_duplicate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbols</span><span class="p">[</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">]);</span>
		<span class="n">symbols__fixup_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symbols</span><span class="p">[</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kmap</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We need to fixup this here too because we create new</span>
<span class="cm">			 * maps here, for things like vsyscall sections.</span>
<span class="cm">			 */</span>
			<span class="n">__map_groups__fixup_end</span><span class="p">(</span><span class="n">kmap</span><span class="o">-&gt;</span><span class="n">kmaps</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nr</span><span class="p">;</span>
<span class="nl">out_elf_end:</span>
	<span class="n">elf_end</span><span class="p">(</span><span class="n">elf</span><span class="p">);</span>
<span class="nl">out_close:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">dso__build_id_equal</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">build_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">build_id</span><span class="p">,</span> <span class="n">build_id</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">build_id</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">__dsos__read_build_ids</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="n">bool</span> <span class="n">with_hits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">have_build_id</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">with_hits</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">hit</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">has_build_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">have_build_id</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filename__read_build_id</span><span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">long_name</span><span class="p">,</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">build_id</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">build_id</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">have_build_id</span>	  <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">pos</span><span class="o">-&gt;</span><span class="n">has_build_id</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">have_build_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Align offset to 4 bytes as needed for note name and descriptor data.</span>
<span class="cm"> */</span>
<span class="cp">#define NOTE_ALIGN(n) (((n) + 3) &amp; -4U)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">elf_read_build_id</span><span class="p">(</span><span class="n">Elf</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">bf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">GElf_Ehdr</span> <span class="n">ehdr</span><span class="p">;</span>
	<span class="n">GElf_Shdr</span> <span class="n">shdr</span><span class="p">;</span>
	<span class="n">Elf_Data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">Elf_Scn</span> <span class="o">*</span><span class="n">sec</span><span class="p">;</span>
	<span class="n">Elf_Kind</span> <span class="n">ek</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">BUILD_ID_SIZE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ek</span> <span class="o">=</span> <span class="n">elf_kind</span><span class="p">(</span><span class="n">elf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ek</span> <span class="o">!=</span> <span class="n">ELF_K_ELF</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gelf_getehdr</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehdr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: cannot get elf header.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sec</span> <span class="o">=</span> <span class="n">elf_section_by_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="p">,</span>
				  <span class="s">&quot;.note.gnu.build-id&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sec</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sec</span> <span class="o">=</span> <span class="n">elf_section_by_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="p">,</span>
					  <span class="s">&quot;.notes&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sec</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">elf_getdata</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">d_buf</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">d_buf</span> <span class="o">+</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">d_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">GElf_Nhdr</span> <span class="o">*</span><span class="n">nhdr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">namesz</span> <span class="o">=</span> <span class="n">NOTE_ALIGN</span><span class="p">(</span><span class="n">nhdr</span><span class="o">-&gt;</span><span class="n">n_namesz</span><span class="p">),</span>
		       <span class="n">descsz</span> <span class="o">=</span> <span class="n">NOTE_ALIGN</span><span class="p">(</span><span class="n">nhdr</span><span class="o">-&gt;</span><span class="n">n_descsz</span><span class="p">);</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

		<span class="n">ptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nhdr</span><span class="p">);</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">namesz</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nhdr</span><span class="o">-&gt;</span><span class="n">n_type</span> <span class="o">==</span> <span class="n">NT_GNU_BUILD_ID</span> <span class="o">&amp;&amp;</span>
		    <span class="n">nhdr</span><span class="o">-&gt;</span><span class="n">n_namesz</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;GNU&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;GNU&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;GNU&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">descsz</span><span class="p">);</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">bf</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">bf</span> <span class="o">+</span> <span class="n">sz</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="n">sz</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">descsz</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">descsz</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">filename__read_build_id</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">bf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">Elf</span> <span class="o">*</span><span class="n">elf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">BUILD_ID_SIZE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">elf</span> <span class="o">=</span> <span class="n">elf_begin</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">PERF_ELF_C_READ_MMAP</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">elf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug2</span><span class="p">(</span><span class="s">&quot;%s: cannot read %s ELF file.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_close</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">elf_read_build_id</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">bf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">elf_end</span><span class="p">(</span><span class="n">elf</span><span class="p">);</span>
<span class="nl">out_close:</span>
	<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sysfs__read_build_id</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">build_id</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">BUILD_ID_SIZE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">bf</span><span class="p">[</span><span class="n">BUFSIZ</span><span class="p">];</span>
		<span class="n">GElf_Nhdr</span> <span class="n">nhdr</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">namesz</span><span class="p">,</span> <span class="n">descsz</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nhdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nhdr</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nhdr</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">namesz</span> <span class="o">=</span> <span class="n">NOTE_ALIGN</span><span class="p">(</span><span class="n">nhdr</span><span class="p">.</span><span class="n">n_namesz</span><span class="p">);</span>
		<span class="n">descsz</span> <span class="o">=</span> <span class="n">NOTE_ALIGN</span><span class="p">(</span><span class="n">nhdr</span><span class="p">.</span><span class="n">n_descsz</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nhdr</span><span class="p">.</span><span class="n">n_type</span> <span class="o">==</span> <span class="n">NT_GNU_BUILD_ID</span> <span class="o">&amp;&amp;</span>
		    <span class="n">nhdr</span><span class="p">.</span><span class="n">n_namesz</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;GNU&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">bf</span><span class="p">,</span> <span class="n">namesz</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">namesz</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">bf</span><span class="p">,</span> <span class="s">&quot;GNU&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;GNU&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">descsz</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">build_id</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">memset</span><span class="p">(</span><span class="n">build_id</span> <span class="o">+</span> <span class="n">sz</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="n">sz</span><span class="p">);</span>
					<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">bf</span><span class="p">,</span> <span class="n">descsz</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">descsz</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">namesz</span> <span class="o">+</span> <span class="n">descsz</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">bf</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="nf">dso__symtab_origin</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">origin</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="n">SYMTAB__KALLSYMS</span><span class="p">]</span>	      <span class="o">=</span> <span class="sc">&#39;k&#39;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">SYMTAB__JAVA_JIT</span><span class="p">]</span>	      <span class="o">=</span> <span class="sc">&#39;j&#39;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">SYMTAB__BUILD_ID_CACHE</span><span class="p">]</span>      <span class="o">=</span> <span class="sc">&#39;B&#39;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">SYMTAB__FEDORA_DEBUGINFO</span><span class="p">]</span>    <span class="o">=</span> <span class="sc">&#39;f&#39;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">SYMTAB__UBUNTU_DEBUGINFO</span><span class="p">]</span>    <span class="o">=</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">SYMTAB__BUILDID_DEBUGINFO</span><span class="p">]</span>   <span class="o">=</span> <span class="sc">&#39;b&#39;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">SYMTAB__SYSTEM_PATH_DSO</span><span class="p">]</span>     <span class="o">=</span> <span class="sc">&#39;d&#39;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">SYMTAB__SYSTEM_PATH_KMODULE</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;K&#39;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">SYMTAB__GUEST_KALLSYMS</span><span class="p">]</span>      <span class="o">=</span>  <span class="sc">&#39;g&#39;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">SYMTAB__GUEST_KMODULE</span><span class="p">]</span>	      <span class="o">=</span>  <span class="sc">&#39;G&#39;</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dso</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">symtab_type</span> <span class="o">==</span> <span class="n">SYMTAB__NOT_FOUND</span><span class="p">)</span>
		<span class="k">return</span> <span class="sc">&#39;!&#39;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">origin</span><span class="p">[</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symtab_type</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dso__load</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">symbol_filter_t</span> <span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">PATH_MAX</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">root_dir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">want_symtab</span><span class="p">;</span>

	<span class="n">dso__set_loaded</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">kernel</span> <span class="o">==</span> <span class="n">DSO_TYPE_KERNEL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dso__load_kernel_sym</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">kernel</span> <span class="o">==</span> <span class="n">DSO_TYPE_GUEST_KERNEL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dso__load_guest_kernel_sym</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">groups</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">groups</span><span class="o">-&gt;</span><span class="n">machine</span><span class="p">)</span>
		<span class="n">machine</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">groups</span><span class="o">-&gt;</span><span class="n">machine</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">machine</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">dso</span><span class="o">-&gt;</span><span class="n">adjust_symbols</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;/tmp/perf-&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lstat</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">st_uid</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">st_uid</span> <span class="o">!=</span> <span class="n">geteuid</span><span class="p">()))</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;File %s not owned by current user or root, &quot;</span>
				<span class="s">&quot;ignoring it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">dso__load_perf_map</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
		<span class="n">dso</span><span class="o">-&gt;</span><span class="n">symtab_type</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">SYMTAB__JAVA_JIT</span> <span class="o">:</span>
					      <span class="n">SYMTAB__NOT_FOUND</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Iterate over candidate debug images.</span>
<span class="cm">	 * On the first pass, only load images if they have a full symtab.</span>
<span class="cm">	 * Failing that, do a second pass where we accept .dynsym also</span>
<span class="cm">	 */</span>
	<span class="n">want_symtab</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">restart:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symtab_type</span> <span class="o">=</span> <span class="n">SYMTAB__BUILD_ID_CACHE</span><span class="p">;</span>
	     <span class="n">dso</span><span class="o">-&gt;</span><span class="n">symtab_type</span> <span class="o">!=</span> <span class="n">SYMTAB__NOT_FOUND</span><span class="p">;</span>
	     <span class="n">dso</span><span class="o">-&gt;</span><span class="n">symtab_type</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">symtab_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SYMTAB__BUILD_ID_CACHE</span>:
			<span class="cm">/* skip the locally configured cache if a symfs is given */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">symfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">dso__build_id_filename</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SYMTAB__FEDORA_DEBUGINFO</span>:
			<span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;%s/usr/lib/debug%s.debug&quot;</span><span class="p">,</span>
				 <span class="n">symbol_conf</span><span class="p">.</span><span class="n">symfs</span><span class="p">,</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">long_name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SYMTAB__UBUNTU_DEBUGINFO</span>:
			<span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;%s/usr/lib/debug%s&quot;</span><span class="p">,</span>
				 <span class="n">symbol_conf</span><span class="p">.</span><span class="n">symfs</span><span class="p">,</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">long_name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SYMTAB__BUILDID_DEBUGINFO</span>: <span class="p">{</span>
			<span class="kt">char</span> <span class="n">build_id_hex</span><span class="p">[</span><span class="n">BUILD_ID_SIZE</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">has_build_id</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">build_id__sprintf</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">build_id</span><span class="p">,</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">build_id</span><span class="p">),</span>
					  <span class="n">build_id_hex</span><span class="p">);</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
				 <span class="s">&quot;%s/usr/lib/debug/.build-id/%.2s/%s.debug&quot;</span><span class="p">,</span>
				 <span class="n">symbol_conf</span><span class="p">.</span><span class="n">symfs</span><span class="p">,</span> <span class="n">build_id_hex</span><span class="p">,</span> <span class="n">build_id_hex</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SYMTAB__SYSTEM_PATH_DSO</span>:
			<span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;%s%s&quot;</span><span class="p">,</span>
			     <span class="n">symbol_conf</span><span class="p">.</span><span class="n">symfs</span><span class="p">,</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">long_name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SYMTAB__GUEST_KMODULE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">groups</span> <span class="o">&amp;&amp;</span> <span class="n">machine</span><span class="p">)</span>
				<span class="n">root_dir</span> <span class="o">=</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">root_dir</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">root_dir</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;%s%s%s&quot;</span><span class="p">,</span> <span class="n">symbol_conf</span><span class="p">.</span><span class="n">symfs</span><span class="p">,</span>
				 <span class="n">root_dir</span><span class="p">,</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">long_name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SYMTAB__SYSTEM_PATH_KMODULE</span>:
			<span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;%s%s&quot;</span><span class="p">,</span> <span class="n">symbol_conf</span><span class="p">.</span><span class="n">symfs</span><span class="p">,</span>
				 <span class="n">dso</span><span class="o">-&gt;</span><span class="n">long_name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Name is now the name of the next image to try */</span>
		<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">dso__load_sym</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">filter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				    <span class="n">want_symtab</span><span class="p">);</span>
		<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Some people seem to have debuginfo files _WITHOUT_ debug</span>
<span class="cm">		 * info!?!?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">nr_plt</span><span class="p">;</span>

			<span class="n">nr_plt</span> <span class="o">=</span> <span class="n">dso__synthesize_plt_symbols</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr_plt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">+=</span> <span class="n">nr_plt</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we wanted a full symtab but no image had one,</span>
<span class="cm">	 * relax our requirements and repeat the search.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">want_symtab</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">want_symtab</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">free</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">strstr</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot; (deleted)&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="nf">map_groups__find_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_groups</span> <span class="o">*</span><span class="n">mg</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">nd</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">nd</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mg</span><span class="o">-&gt;</span><span class="n">maps</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span> <span class="n">nd</span><span class="p">;</span> <span class="n">nd</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">map</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">dso</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">short_name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">map</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dso__kernel_module_get_build_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span>
					   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">root_dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">filename</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * kernel module short names are of the form &quot;[module]&quot; and</span>
<span class="cm">	 * we need just &quot;module&quot; here.</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">short_name</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span>
		 <span class="s">&quot;%s/sys/module/%.*s/notes/.note.gnu.build-id&quot;</span><span class="p">,</span>
		 <span class="n">root_dir</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sysfs__read_build_id</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">build_id</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">build_id</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dso</span><span class="o">-&gt;</span><span class="n">has_build_id</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">map_groups__set_modules_path_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_groups</span> <span class="o">*</span><span class="n">mg</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dir_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dirent</span> <span class="o">*</span><span class="n">dent</span><span class="p">;</span>
	<span class="kt">DIR</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">opendir</span><span class="p">(</span><span class="n">dir_name</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: cannot open %s dir</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">dir_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">dent</span> <span class="o">=</span> <span class="n">readdir</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span>

		<span class="cm">/*sshfs might return bad dent-&gt;d_type, so we have to stat*/</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="s">&quot;%s/%s&quot;</span><span class="p">,</span> <span class="n">dir_name</span><span class="p">,</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">st_mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">)</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="s">&quot;..&quot;</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">map_groups__set_modules_path_dir</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">dot</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">),</span>
			     <span class="n">dso_name</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">long_name</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dot</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">dot</span><span class="p">,</span> <span class="s">&quot;.ko&quot;</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">dso_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dso_name</span><span class="p">),</span> <span class="s">&quot;[%.*s]&quot;</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">dot</span> <span class="o">-</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">),</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>

			<span class="n">strxfrchar</span><span class="p">(</span><span class="n">dso_name</span><span class="p">,</span> <span class="sc">&#39;-&#39;</span><span class="p">,</span> <span class="sc">&#39;_&#39;</span><span class="p">);</span>
			<span class="n">map</span> <span class="o">=</span> <span class="n">map_groups__find_by_name</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">MAP__FUNCTION</span><span class="p">,</span>
						       <span class="n">dso_name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">long_name</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">long_name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dso__set_long_name</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">dso</span><span class="p">,</span> <span class="n">long_name</span><span class="p">);</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">lname_alloc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">dso__kernel_module_get_build_id</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">dso</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">closedir</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_kernel_version</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">root_dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">version</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>
	<span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span> <span class="o">=</span> <span class="s">&quot;Linux version &quot;</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="s">&quot;%s/proc/version&quot;</span><span class="p">,</span> <span class="n">root_dir</span><span class="p">);</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">fgets</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">version</span><span class="p">),</span> <span class="n">file</span><span class="p">);</span>
	<span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">prefix</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">name</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">prefix</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">strdup</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">machine__set_modules_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">version</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">modules_path</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>

	<span class="n">version</span> <span class="o">=</span> <span class="n">get_kernel_version</span><span class="p">(</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">root_dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">version</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">modules_path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">modules_path</span><span class="p">),</span> <span class="s">&quot;%s/lib/modules/%s/kernel&quot;</span><span class="p">,</span>
		 <span class="n">machine</span><span class="o">-&gt;</span><span class="n">root_dir</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">version</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">map_groups__set_modules_path_dir</span><span class="p">(</span><span class="o">&amp;</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">kmaps</span><span class="p">,</span> <span class="n">modules_path</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Constructor variant for modules (where we know from /proc/modules where</span>
<span class="cm"> * they are loaded) and for vmlinux, where only after we load all the</span>
<span class="cm"> * symbols we&#39;ll know where it starts and ends.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="nf">map__new2</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">map</span><span class="p">)</span> <span class="o">+</span>
				     <span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">kernel</span> <span class="o">?</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmap</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * -&gt;end will be filled after we load all the symbols</span>
<span class="cm">		 */</span>
		<span class="n">map__init</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dso</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">map</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="nf">machine__new_module</span><span class="p">(</span><span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span> <span class="o">=</span> <span class="n">__dsos__findnew</span><span class="p">(</span><span class="o">&amp;</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">kernel_dsos</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dso</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">map</span> <span class="o">=</span> <span class="n">map__new2</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dso</span><span class="p">,</span> <span class="n">MAP__FUNCTION</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">machine__is_host</span><span class="p">(</span><span class="n">machine</span><span class="p">))</span>
		<span class="n">dso</span><span class="o">-&gt;</span><span class="n">symtab_type</span> <span class="o">=</span> <span class="n">SYMTAB__SYSTEM_PATH_KMODULE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dso</span><span class="o">-&gt;</span><span class="n">symtab_type</span> <span class="o">=</span> <span class="n">SYMTAB__GUEST_KMODULE</span><span class="p">;</span>
	<span class="n">map_groups__insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">kmaps</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">map</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">machine__create_modules</span><span class="p">(</span><span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">line</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modules</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">machine__is_default_guest</span><span class="p">(</span><span class="n">machine</span><span class="p">))</span>
		<span class="n">modules</span> <span class="o">=</span> <span class="n">symbol_conf</span><span class="p">.</span><span class="n">default_guest_modules</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;%s/proc/modules&quot;</span><span class="p">,</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">root_dir</span><span class="p">);</span>
		<span class="n">modules</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">symbol__restricted_filename</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;/proc/modules&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">modules</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">feof</span><span class="p">(</span><span class="n">file</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>
		<span class="n">u64</span> <span class="n">start</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">sep</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">line_len</span><span class="p">;</span>

		<span class="n">line_len</span> <span class="o">=</span> <span class="n">getline</span><span class="p">(</span><span class="o">&amp;</span><span class="n">line</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">line_len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">line</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_failure</span><span class="p">;</span>

		<span class="n">line</span><span class="p">[</span><span class="o">--</span><span class="n">line_len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="cm">/* \n */</span>

		<span class="n">sep</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">hex2u64</span><span class="p">(</span><span class="n">sep</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>

		<span class="n">sep</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

		<span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;[%s]&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
		<span class="n">map</span> <span class="o">=</span> <span class="n">machine__new_module</span><span class="p">(</span><span class="n">machine</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_delete_line</span><span class="p">;</span>
		<span class="n">dso__kernel_module_get_build_id</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">dso</span><span class="p">,</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">root_dir</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">free</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
	<span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">machine__set_modules_path</span><span class="p">(</span><span class="n">machine</span><span class="p">);</span>

<span class="nl">out_delete_line:</span>
	<span class="n">free</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
<span class="nl">out_failure:</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dso__load_vmlinux</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vmlinux</span><span class="p">,</span> <span class="n">symbol_filter_t</span> <span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">fd</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">symfs_vmlinux</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">symfs_vmlinux</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">symfs_vmlinux</span><span class="p">),</span> <span class="s">&quot;%s%s&quot;</span><span class="p">,</span>
		 <span class="n">symbol_conf</span><span class="p">.</span><span class="n">symfs</span><span class="p">,</span> <span class="n">vmlinux</span><span class="p">);</span>
	<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">symfs_vmlinux</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">dso__set_long_name</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">vmlinux</span><span class="p">);</span>
	<span class="n">dso__set_loaded</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dso__load_sym</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">symfs_vmlinux</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">filter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Using %s for symbols</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">symfs_vmlinux</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dso__load_vmlinux_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
			   <span class="n">symbol_filter_t</span> <span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Looking at the vmlinux_path (%d entries long)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">vmlinux_path__nr_entries</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">filename</span> <span class="o">=</span> <span class="n">dso__build_id_filename</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filename</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dso__load_vmlinux</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dso__set_long_name</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">free</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vmlinux_path__nr_entries</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dso__load_vmlinux</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">vmlinux_path</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">filter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dso__set_long_name</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">strdup</span><span class="p">(</span><span class="n">vmlinux_path</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dso__load_kernel_sym</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
				<span class="n">symbol_filter_t</span> <span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kallsyms_filename</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kallsyms_allocated_filename</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Step 1: if the user specified a kallsyms or vmlinux filename, use</span>
<span class="cm">	 * it and only it, reporting errors to the user if it cannot be used.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For instance, try to analyse an ARM perf.data file _without_ a</span>
<span class="cm">	 * build-id, or if the user specifies the wrong path to the right</span>
<span class="cm">	 * vmlinux file, obviously we can&#39;t fallback to another vmlinux (a</span>
<span class="cm">	 * x86_86 one, on the machine where analysis is being performed, say),</span>
<span class="cm">	 * or worse, /proc/kallsyms.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the specified file _has_ a build-id and there is a build-id</span>
<span class="cm">	 * section in the perf.data file, we will still do the expected</span>
<span class="cm">	 * validation in dso__load_vmlinux and will bail out if they don&#39;t</span>
<span class="cm">	 * match.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">kallsyms_name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kallsyms_filename</span> <span class="o">=</span> <span class="n">symbol_conf</span><span class="p">.</span><span class="n">kallsyms_name</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">do_kallsyms</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">vmlinux_name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dso__load_vmlinux</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span>
					<span class="n">symbol_conf</span><span class="p">.</span><span class="n">vmlinux_name</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dso__set_long_name</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span>
					   <span class="n">strdup</span><span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">vmlinux_name</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">out_fixup</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmlinux_path</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dso__load_vmlinux_path</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_fixup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* do not try local files if a symfs was given */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">symfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Say the kernel DSO was created when processing the build-id header table,</span>
<span class="cm">	 * we have a build-id, so check if it is the same as the running kernel,</span>
<span class="cm">	 * using it if it is.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">has_build_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">kallsyms_build_id</span><span class="p">[</span><span class="n">BUILD_ID_SIZE</span><span class="p">];</span>
		<span class="kt">char</span> <span class="n">sbuild_id</span><span class="p">[</span><span class="n">BUILD_ID_SIZE</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sysfs__read_build_id</span><span class="p">(</span><span class="s">&quot;/sys/kernel/notes&quot;</span><span class="p">,</span> <span class="n">kallsyms_build_id</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="n">kallsyms_build_id</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dso__build_id_equal</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">kallsyms_build_id</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">kallsyms_filename</span> <span class="o">=</span> <span class="s">&quot;/proc/kallsyms&quot;</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">do_kallsyms</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Now look if we have it on the build-id cache in</span>
<span class="cm">		 * $HOME/.debug/[kernel.kallsyms].</span>
<span class="cm">		 */</span>
		<span class="n">build_id__sprintf</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">build_id</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">build_id</span><span class="p">),</span>
				  <span class="n">sbuild_id</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">asprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kallsyms_allocated_filename</span><span class="p">,</span>
			     <span class="s">&quot;%s/.debug/[kernel.kallsyms]/%s&quot;</span><span class="p">,</span>
			     <span class="n">getenv</span><span class="p">(</span><span class="s">&quot;HOME&quot;</span><span class="p">),</span> <span class="n">sbuild_id</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Not enough memory for kallsyms file lookup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">kallsyms_filename</span> <span class="o">=</span> <span class="n">kallsyms_allocated_filename</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">access</span><span class="p">(</span><span class="n">kallsyms_filename</span><span class="p">,</span> <span class="n">F_OK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;No kallsyms or vmlinux with build-id %s &quot;</span>
			       <span class="s">&quot;was found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sbuild_id</span><span class="p">);</span>
			<span class="n">free</span><span class="p">(</span><span class="n">kallsyms_allocated_filename</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Last resort, if we don&#39;t have a build-id and couldn&#39;t find</span>
<span class="cm">		 * any vmlinux file, try the running kernel kallsyms table.</span>
<span class="cm">		 */</span>
		<span class="n">kallsyms_filename</span> <span class="o">=</span> <span class="s">&quot;/proc/kallsyms&quot;</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">do_kallsyms:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dso__load_kallsyms</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">kallsyms_filename</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Using %s for symbols</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">kallsyms_filename</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">kallsyms_allocated_filename</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">out_fixup:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kallsyms_filename</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">dso__set_long_name</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">strdup</span><span class="p">(</span><span class="s">&quot;[kernel.kallsyms]&quot;</span><span class="p">));</span>
		<span class="n">map__fixup_start</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
		<span class="n">map__fixup_end</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dso__load_guest_kernel_sym</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
				      <span class="n">symbol_filter_t</span> <span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kallsyms_filename</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Guest kernel map hasn&#39;t the point to groups</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">machine</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">groups</span><span class="o">-&gt;</span><span class="n">machine</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">machine__is_default_guest</span><span class="p">(</span><span class="n">machine</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if the user specified a vmlinux filename, use it and only</span>
<span class="cm">		 * it, reporting errors to the user if it cannot be used.</span>
<span class="cm">		 * Or use file guest_kallsyms inputted by user on commandline</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">default_guest_vmlinux_name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">dso__load_vmlinux</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span>
				<span class="n">symbol_conf</span><span class="p">.</span><span class="n">default_guest_vmlinux_name</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_try_fixup</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">kallsyms_filename</span> <span class="o">=</span> <span class="n">symbol_conf</span><span class="p">.</span><span class="n">default_guest_kallsyms</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kallsyms_filename</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;%s/proc/kallsyms&quot;</span><span class="p">,</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">root_dir</span><span class="p">);</span>
		<span class="n">kallsyms_filename</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dso__load_kallsyms</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">kallsyms_filename</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Using %s for symbols</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">kallsyms_filename</span><span class="p">);</span>

<span class="nl">out_try_fixup:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kallsyms_filename</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">machine__mmap_name</span><span class="p">(</span><span class="n">machine</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">path</span><span class="p">));</span>
			<span class="n">dso__set_long_name</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">strdup</span><span class="p">(</span><span class="n">path</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">map__fixup_start</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
		<span class="n">map__fixup_end</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dsos__add</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="nf">dsos__find</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">long_name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="nf">__dsos__findnew</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span> <span class="o">=</span> <span class="n">dsos__find</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dso</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dso</span> <span class="o">=</span> <span class="n">dso__new</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dso</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dsos__add</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">dso</span><span class="p">);</span>
			<span class="n">dso__set_basename</span><span class="p">(</span><span class="n">dso</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dso</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">__dsos__fprintf</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAP__NR_TYPES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">+=</span> <span class="n">dso__fprintf</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">machines__fprintf_dsos</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">machines</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">nd</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">nd</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="n">machines</span><span class="p">);</span> <span class="n">nd</span><span class="p">;</span> <span class="n">nd</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">machine</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">__dsos__fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">kernel_dsos</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">__dsos__fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">user_dsos</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">__dsos__fprintf_buildid</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span>
				      <span class="n">bool</span> <span class="n">with_hits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">with_hits</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">hit</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">dso__fprintf_buildid</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&quot; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">long_name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">machine__fprintf_dsos_buildid</span><span class="p">(</span><span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span>
				     <span class="n">bool</span> <span class="n">with_hits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__dsos__fprintf_buildid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">kernel_dsos</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">with_hits</span><span class="p">)</span> <span class="o">+</span>
	       <span class="n">__dsos__fprintf_buildid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">user_dsos</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">with_hits</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">machines__fprintf_dsos_buildid</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">machines</span><span class="p">,</span>
				      <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="n">bool</span> <span class="n">with_hits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">nd</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">nd</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="n">machines</span><span class="p">);</span> <span class="n">nd</span><span class="p">;</span> <span class="n">nd</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">machine</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">machine__fprintf_dsos_buildid</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">with_hits</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dso</span><span class="o">*</span>
<span class="nf">dso__kernel_findnew</span><span class="p">(</span><span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">short_name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dso_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The kernel dso could be created by build_id processing.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span> <span class="o">=</span> <span class="n">__dsos__findnew</span><span class="p">(</span><span class="o">&amp;</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">kernel_dsos</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to run this in all cases, since during the build_id</span>
<span class="cm">	 * processing we had no idea this was the kernel dso.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dso</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dso__set_short_name</span><span class="p">(</span><span class="n">dso</span><span class="p">,</span> <span class="n">short_name</span><span class="p">);</span>
		<span class="n">dso</span><span class="o">-&gt;</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">dso_type</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dso</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dso__read_running_kernel_build_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">machine__is_default_guest</span><span class="p">(</span><span class="n">machine</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;%s/sys/kernel/notes&quot;</span><span class="p">,</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">root_dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysfs__read_build_id</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">dso</span><span class="o">-&gt;</span><span class="n">build_id</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">build_id</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dso</span><span class="o">-&gt;</span><span class="n">has_build_id</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="nf">machine__get_kernel</span><span class="p">(</span><span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vmlinux_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">kernel</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">machine__is_host</span><span class="p">(</span><span class="n">machine</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vmlinux_name</span> <span class="o">=</span> <span class="n">symbol_conf</span><span class="p">.</span><span class="n">vmlinux_name</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmlinux_name</span><span class="p">)</span>
			<span class="n">vmlinux_name</span> <span class="o">=</span> <span class="s">&quot;[kernel.kallsyms]&quot;</span><span class="p">;</span>

		<span class="n">kernel</span> <span class="o">=</span> <span class="n">dso__kernel_findnew</span><span class="p">(</span><span class="n">machine</span><span class="p">,</span> <span class="n">vmlinux_name</span><span class="p">,</span>
					     <span class="s">&quot;[kernel]&quot;</span><span class="p">,</span>
					     <span class="n">DSO_TYPE_KERNEL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">bf</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">machine__is_default_guest</span><span class="p">(</span><span class="n">machine</span><span class="p">))</span>
			<span class="n">vmlinux_name</span> <span class="o">=</span> <span class="n">symbol_conf</span><span class="p">.</span><span class="n">default_guest_vmlinux_name</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmlinux_name</span><span class="p">)</span>
			<span class="n">vmlinux_name</span> <span class="o">=</span> <span class="n">machine__mmap_name</span><span class="p">(</span><span class="n">machine</span><span class="p">,</span> <span class="n">bf</span><span class="p">,</span>
							  <span class="k">sizeof</span><span class="p">(</span><span class="n">bf</span><span class="p">));</span>

		<span class="n">kernel</span> <span class="o">=</span> <span class="n">dso__kernel_findnew</span><span class="p">(</span><span class="n">machine</span><span class="p">,</span> <span class="n">vmlinux_name</span><span class="p">,</span>
					     <span class="s">&quot;[guest.kernel]&quot;</span><span class="p">,</span>
					     <span class="n">DSO_TYPE_GUEST_KERNEL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kernel</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">kernel</span><span class="o">-&gt;</span><span class="n">has_build_id</span><span class="p">))</span>
		<span class="n">dso__read_running_kernel_build_id</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">machine</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">kernel</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">process_args</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">start</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">symbol__in_kernel</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="n">type</span> <span class="n">__used</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span> <span class="n">__used</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">process_args</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="sc">&#39;[&#39;</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">args</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Figure out the start address of kernel map from /proc/kallsyms */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">machine__get_kernel_start_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">process_args</span> <span class="n">args</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">machine__is_host</span><span class="p">(</span><span class="n">machine</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">filename</span> <span class="o">=</span> <span class="s">&quot;/proc/kallsyms&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">machine__is_default_guest</span><span class="p">(</span><span class="n">machine</span><span class="p">))</span>
			<span class="n">filename</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">default_guest_kallsyms</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;%s/proc/kallsyms&quot;</span><span class="p">,</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">root_dir</span><span class="p">);</span>
			<span class="n">filename</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">symbol__restricted_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;/proc/kallsyms&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kallsyms__parse</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">symbol__in_kernel</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">args</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__machine__create_kernel_maps</span><span class="p">(</span><span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">kernel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">start</span> <span class="o">=</span> <span class="n">machine__get_kernel_start_addr</span><span class="p">(</span><span class="n">machine</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">type</span> <span class="o">&lt;</span> <span class="n">MAP__NR_TYPES</span><span class="p">;</span> <span class="o">++</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kmap</span> <span class="o">*</span><span class="n">kmap</span><span class="p">;</span>

		<span class="n">machine</span><span class="o">-&gt;</span><span class="n">vmlinux_maps</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">=</span> <span class="n">map__new2</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">vmlinux_maps</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="n">machine</span><span class="o">-&gt;</span><span class="n">vmlinux_maps</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">map_ip</span> <span class="o">=</span>
			<span class="n">machine</span><span class="o">-&gt;</span><span class="n">vmlinux_maps</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">unmap_ip</span> <span class="o">=</span>
				<span class="n">identity__map_ip</span><span class="p">;</span>
		<span class="n">kmap</span> <span class="o">=</span> <span class="n">map__kmap</span><span class="p">(</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">vmlinux_maps</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>
		<span class="n">kmap</span><span class="o">-&gt;</span><span class="n">kmaps</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">kmaps</span><span class="p">;</span>
		<span class="n">map_groups__insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">kmaps</span><span class="p">,</span>
				   <span class="n">machine</span><span class="o">-&gt;</span><span class="n">vmlinux_maps</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">machine__destroy_kernel_maps</span><span class="p">(</span><span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">type</span> <span class="o">&lt;</span> <span class="n">MAP__NR_TYPES</span><span class="p">;</span> <span class="o">++</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kmap</span> <span class="o">*</span><span class="n">kmap</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">vmlinux_maps</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">kmap</span> <span class="o">=</span> <span class="n">map__kmap</span><span class="p">(</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">vmlinux_maps</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>
		<span class="n">map_groups__remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">kmaps</span><span class="p">,</span>
				   <span class="n">machine</span><span class="o">-&gt;</span><span class="n">vmlinux_maps</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kmap</span><span class="o">-&gt;</span><span class="n">ref_reloc_sym</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * ref_reloc_sym is shared among all maps, so free just</span>
<span class="cm">			 * on one of them.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">MAP__FUNCTION</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">kmap</span><span class="o">-&gt;</span><span class="n">ref_reloc_sym</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="n">kmap</span><span class="o">-&gt;</span><span class="n">ref_reloc_sym</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">free</span><span class="p">(</span><span class="n">kmap</span><span class="o">-&gt;</span><span class="n">ref_reloc_sym</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">kmap</span><span class="o">-&gt;</span><span class="n">ref_reloc_sym</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">map__delete</span><span class="p">(</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">vmlinux_maps</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>
		<span class="n">machine</span><span class="o">-&gt;</span><span class="n">vmlinux_maps</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">machine__create_kernel_maps</span><span class="p">(</span><span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">machine__get_kernel</span><span class="p">(</span><span class="n">machine</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kernel</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
	    <span class="n">__machine__create_kernel_maps</span><span class="p">(</span><span class="n">machine</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">use_modules</span> <span class="o">&amp;&amp;</span> <span class="n">machine__create_modules</span><span class="p">(</span><span class="n">machine</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Problems creating module maps, continuing anyway...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now that we have all the maps created, just set the -&gt;end of them:</span>
<span class="cm">	 */</span>
	<span class="n">map_groups__fixup_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">kmaps</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmlinux_path__exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">vmlinux_path__nr_entries</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free</span><span class="p">(</span><span class="n">vmlinux_path</span><span class="p">[</span><span class="n">vmlinux_path__nr_entries</span><span class="p">]);</span>
		<span class="n">vmlinux_path</span><span class="p">[</span><span class="n">vmlinux_path__nr_entries</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">free</span><span class="p">(</span><span class="n">vmlinux_path</span><span class="p">);</span>
	<span class="n">vmlinux_path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmlinux_path__init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">utsname</span> <span class="n">uts</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">bf</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>

	<span class="n">vmlinux_path</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmlinux_path</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">vmlinux_path</span><span class="p">[</span><span class="n">vmlinux_path__nr_entries</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="s">&quot;vmlinux&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmlinux_path</span><span class="p">[</span><span class="n">vmlinux_path__nr_entries</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
	<span class="o">++</span><span class="n">vmlinux_path__nr_entries</span><span class="p">;</span>
	<span class="n">vmlinux_path</span><span class="p">[</span><span class="n">vmlinux_path__nr_entries</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="s">&quot;/boot/vmlinux&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmlinux_path</span><span class="p">[</span><span class="n">vmlinux_path__nr_entries</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
	<span class="o">++</span><span class="n">vmlinux_path__nr_entries</span><span class="p">;</span>

	<span class="cm">/* only try running kernel version if no symfs was given */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">symfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uname</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uts</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">bf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bf</span><span class="p">),</span> <span class="s">&quot;/boot/vmlinux-%s&quot;</span><span class="p">,</span> <span class="n">uts</span><span class="p">.</span><span class="n">release</span><span class="p">);</span>
	<span class="n">vmlinux_path</span><span class="p">[</span><span class="n">vmlinux_path__nr_entries</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">bf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmlinux_path</span><span class="p">[</span><span class="n">vmlinux_path__nr_entries</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
	<span class="o">++</span><span class="n">vmlinux_path__nr_entries</span><span class="p">;</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">bf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bf</span><span class="p">),</span> <span class="s">&quot;/lib/modules/%s/build/vmlinux&quot;</span><span class="p">,</span> <span class="n">uts</span><span class="p">.</span><span class="n">release</span><span class="p">);</span>
	<span class="n">vmlinux_path</span><span class="p">[</span><span class="n">vmlinux_path__nr_entries</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">bf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmlinux_path</span><span class="p">[</span><span class="n">vmlinux_path__nr_entries</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
	<span class="o">++</span><span class="n">vmlinux_path__nr_entries</span><span class="p">;</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">bf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bf</span><span class="p">),</span> <span class="s">&quot;/usr/lib/debug/lib/modules/%s/vmlinux&quot;</span><span class="p">,</span>
		 <span class="n">uts</span><span class="p">.</span><span class="n">release</span><span class="p">);</span>
	<span class="n">vmlinux_path</span><span class="p">[</span><span class="n">vmlinux_path__nr_entries</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">bf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmlinux_path</span><span class="p">[</span><span class="n">vmlinux_path__nr_entries</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
	<span class="o">++</span><span class="n">vmlinux_path__nr_entries</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_fail:</span>
	<span class="n">vmlinux_path__exit</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">machine__fprintf_vmlinux_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">printed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">kdso</span> <span class="o">=</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">vmlinux_maps</span><span class="p">[</span><span class="n">MAP__FUNCTION</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dso</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kdso</span><span class="o">-&gt;</span><span class="n">has_build_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">filename</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dso__build_id_filename</span><span class="p">(</span><span class="n">kdso</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">filename</span><span class="p">)))</span>
			<span class="n">printed</span> <span class="o">+=</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&quot;[0] %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vmlinux_path__nr_entries</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">printed</span> <span class="o">+=</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&quot;[%d] %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">i</span> <span class="o">+</span> <span class="n">kdso</span><span class="o">-&gt;</span><span class="n">has_build_id</span><span class="p">,</span> <span class="n">vmlinux_path</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">printed</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">strlist</span> <span class="o">**</span><span class="n">list</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">list_str</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">list_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_str</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">strlist__new</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">list_str</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;problems parsing %s list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">list_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">symbol__read_kptr_restrict</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">geteuid</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">&quot;/proc/sys/kernel/kptr_restrict&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">value</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">symbol__init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symfs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">initialized</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">symbol_conf</span><span class="p">.</span><span class="n">priv_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">priv_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>

	<span class="n">elf_version</span><span class="p">(</span><span class="n">EV_CURRENT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">sort_by_name</span><span class="p">)</span>
		<span class="n">symbol_conf</span><span class="p">.</span><span class="n">priv_size</span> <span class="o">+=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">symbol_name_rb_node</span><span class="p">)</span> <span class="o">-</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">symbol</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">try_vmlinux_path</span> <span class="o">&amp;&amp;</span> <span class="n">vmlinux_path__init</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">field_sep</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">field_sep</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;&#39;.&#39; is the only non valid --field-separator argument</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">setup_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">dso_list</span><span class="p">,</span>
		       <span class="n">symbol_conf</span><span class="p">.</span><span class="n">dso_list_str</span><span class="p">,</span> <span class="s">&quot;dso&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">setup_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">comm_list</span><span class="p">,</span>
		       <span class="n">symbol_conf</span><span class="p">.</span><span class="n">comm_list_str</span><span class="p">,</span> <span class="s">&quot;comm&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_dso_list</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">setup_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">sym_list</span><span class="p">,</span>
		       <span class="n">symbol_conf</span><span class="p">.</span><span class="n">sym_list_str</span><span class="p">,</span> <span class="s">&quot;symbol&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_comm_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A path to symbols of &quot;/&quot; is identical to &quot;&quot;</span>
<span class="cm">	 * reset here for simplicity.</span>
<span class="cm">	 */</span>
	<span class="n">symfs</span> <span class="o">=</span> <span class="n">realpath</span><span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">symfs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">symfs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">symfs</span> <span class="o">=</span> <span class="n">symbol_conf</span><span class="p">.</span><span class="n">symfs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">symfs</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">symbol_conf</span><span class="p">.</span><span class="n">symfs</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">symfs</span> <span class="o">!=</span> <span class="n">symbol_conf</span><span class="p">.</span><span class="n">symfs</span><span class="p">)</span>
		<span class="n">free</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">symfs</span><span class="p">);</span>

	<span class="n">symbol_conf</span><span class="p">.</span><span class="n">kptr_restrict</span> <span class="o">=</span> <span class="n">symbol__read_kptr_restrict</span><span class="p">();</span>

	<span class="n">symbol_conf</span><span class="p">.</span><span class="n">initialized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_comm_list:</span>
	<span class="n">strlist__delete</span><span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">comm_list</span><span class="p">);</span>
<span class="nl">out_free_dso_list:</span>
	<span class="n">strlist__delete</span><span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">dso_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">symbol__exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">initialized</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">strlist__delete</span><span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">sym_list</span><span class="p">);</span>
	<span class="n">strlist__delete</span><span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">dso_list</span><span class="p">);</span>
	<span class="n">strlist__delete</span><span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">comm_list</span><span class="p">);</span>
	<span class="n">vmlinux_path__exit</span><span class="p">();</span>
	<span class="n">symbol_conf</span><span class="p">.</span><span class="n">sym_list</span> <span class="o">=</span> <span class="n">symbol_conf</span><span class="p">.</span><span class="n">dso_list</span> <span class="o">=</span> <span class="n">symbol_conf</span><span class="p">.</span><span class="n">comm_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">symbol_conf</span><span class="p">.</span><span class="n">initialized</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">machines__create_kernel_maps</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">machines</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span> <span class="o">=</span> <span class="n">machines__findnew</span><span class="p">(</span><span class="n">machines</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">machine</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">machine__create_kernel_maps</span><span class="p">(</span><span class="n">machine</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hex</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ch</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ch</span> <span class="o">&gt;=</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&lt;=</span> <span class="sc">&#39;f&#39;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ch</span> <span class="o">&gt;=</span> <span class="sc">&#39;A&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&lt;=</span> <span class="sc">&#39;F&#39;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * While we find nice hex chars, build a long_val.</span>
<span class="cm"> * Return number of chars processed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">hex2u64</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">long_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="o">*</span><span class="n">long_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">hex_val</span> <span class="o">=</span> <span class="n">hex</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hex_val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="o">*</span><span class="n">long_val</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">long_val</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">hex_val</span><span class="p">;</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">strxfrchar</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">from</span><span class="p">,</span> <span class="kt">char</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">from</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">machines__create_guest_kernel_maps</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">machines</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dirent</span> <span class="o">**</span><span class="n">namelist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">items</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>
	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">default_guest_vmlinux_name</span> <span class="o">||</span>
	    <span class="n">symbol_conf</span><span class="p">.</span><span class="n">default_guest_modules</span> <span class="o">||</span>
	    <span class="n">symbol_conf</span><span class="p">.</span><span class="n">default_guest_kallsyms</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">machines__create_kernel_maps</span><span class="p">(</span><span class="n">machines</span><span class="p">,</span> <span class="n">DEFAULT_GUEST_KERNEL_ID</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">guestmount</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">items</span> <span class="o">=</span> <span class="n">scandir</span><span class="p">(</span><span class="n">symbol_conf</span><span class="p">.</span><span class="n">guestmount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">namelist</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">items</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">items</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="n">namelist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
				<span class="cm">/* Filter out . and .. */</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">pid</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">namelist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;%s/%s/proc/kallsyms&quot;</span><span class="p">,</span>
				<span class="n">symbol_conf</span><span class="p">.</span><span class="n">guestmount</span><span class="p">,</span>
				<span class="n">namelist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">access</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">R_OK</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Can&#39;t access file %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">machines__create_kernel_maps</span><span class="p">(</span><span class="n">machines</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
		<span class="p">}</span>
<span class="nl">failure:</span>
		<span class="n">free</span><span class="p">(</span><span class="n">namelist</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">machines__destroy_guest_kernel_maps</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">machines</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="n">machines</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">machine</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="n">next</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">machines</span><span class="p">);</span>
		<span class="n">machine__delete</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">machine__load_kallsyms</span><span class="p">(</span><span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span>
			   <span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">,</span> <span class="n">symbol_filter_t</span> <span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">vmlinux_maps</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">dso__load_kallsyms</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">dso</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dso__set_loaded</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">dso</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Since /proc/kallsyms will have multiple sessions for the</span>
<span class="cm">		 * kernel, with modules between them, fixup the end of all</span>
<span class="cm">		 * sections.</span>
<span class="cm">		 */</span>
		<span class="n">__map_groups__fixup_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">machine</span><span class="o">-&gt;</span><span class="n">kmaps</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">machine__load_vmlinux_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span> <span class="k">enum</span> <span class="n">map_type</span> <span class="n">type</span><span class="p">,</span>
			       <span class="n">symbol_filter_t</span> <span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">vmlinux_maps</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">dso__load_vmlinux_path</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">dso</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dso__set_loaded</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">dso</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="n">map__reloc_vmlinux</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="nf">dso__new_map</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span> <span class="o">=</span> <span class="n">dso__new</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dso</span><span class="p">)</span>
		<span class="n">map</span> <span class="o">=</span> <span class="n">map__new2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dso</span><span class="p">,</span> <span class="n">MAP__FUNCTION</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">map</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
