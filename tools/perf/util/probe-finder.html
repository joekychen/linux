<!DOCTYPE html>
<html><head><title>joekychen/linux » tools › perf › util › probe-finder.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>probe-finder.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * probe-finder.c : C expression to kprobe event converter</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Masami Hiramatsu &lt;mhiramat@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;sys/utsname.h&gt;</span>
<span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;sys/stat.h&gt;</span>
<span class="cp">#include &lt;fcntl.h&gt;</span>
<span class="cp">#include &lt;errno.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;getopt.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;stdarg.h&gt;</span>
<span class="cp">#include &lt;dwarf-regs.h&gt;</span>

<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &quot;event.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>
<span class="cp">#include &quot;util.h&quot;</span>
<span class="cp">#include &quot;symbol.h&quot;</span>
<span class="cp">#include &quot;probe-finder.h&quot;</span>

<span class="cm">/* Kprobe tracer basic type is up to u64 */</span>
<span class="cp">#define MAX_BASIC_TYPE_BITS	64</span>

<span class="cm">/* Line number list operations */</span>

<span class="cm">/* Add a line to line number list */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">line_list__add_line</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">line_node</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/* Reverse search, because new line will be the last one */</span>
	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ln</span><span class="o">-&gt;</span><span class="n">line</span> <span class="o">&lt;</span> <span class="n">line</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ln</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ln</span><span class="o">-&gt;</span><span class="n">line</span> <span class="o">==</span> <span class="n">line</span><span class="p">)</span>	<span class="cm">/* Already exist */</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* List is empty, or the smallest entry */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;line list: add a line %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
	<span class="n">ln</span> <span class="o">=</span> <span class="n">zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">line_node</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ln</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">ln</span><span class="o">-&gt;</span><span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ln</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ln</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check if the line in line number list */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">line_list__has_line</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">line_node</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>

	<span class="cm">/* Reverse search, because new line will be the last one */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ln</span><span class="o">-&gt;</span><span class="n">line</span> <span class="o">==</span> <span class="n">line</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Init line number list */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">line_list__init</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Free line number list */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">line_list__free</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">line_node</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ln</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">line_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ln</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">ln</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Dwarf FL wrappers */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">debuginfo_path</span><span class="p">;</span>	<span class="cm">/* Currently dummy */</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">Dwfl_Callbacks</span> <span class="n">offline_callbacks</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">find_debuginfo</span> <span class="o">=</span> <span class="n">dwfl_standard_find_debuginfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">debuginfo_path</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">debuginfo_path</span><span class="p">,</span>

	<span class="p">.</span><span class="n">section_address</span> <span class="o">=</span> <span class="n">dwfl_offline_section_address</span><span class="p">,</span>

	<span class="cm">/* We use this table for core files too.  */</span>
	<span class="p">.</span><span class="n">find_elf</span> <span class="o">=</span> <span class="n">dwfl_build_id_find_elf</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Get a Dwarf from offline image */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">debuginfo__init_offline_dwarf</span><span class="p">(</span><span class="k">struct</span> <span class="n">debuginfo</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Dwfl_Module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">dwfl</span> <span class="o">=</span> <span class="n">dwfl_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">offline_callbacks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dwfl</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">mod</span> <span class="o">=</span> <span class="n">dwfl_report_offline</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dwfl</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">dbg</span> <span class="o">=</span> <span class="n">dwfl_module_getdwarf</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">bias</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dwfl</span><span class="p">)</span>
		<span class="n">dwfl_end</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dwfl</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">self</span><span class="p">));</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if _ELFUTILS_PREREQ(0, 148)</span>
<span class="cm">/* This method is buggy if elfutils is older than 0.148 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__linux_kernel_find_elf</span><span class="p">(</span><span class="n">Dwfl_Module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
				   <span class="kt">void</span> <span class="o">**</span><span class="n">userdata</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">module_name</span><span class="p">,</span>
				   <span class="n">Dwarf_Addr</span> <span class="n">base</span><span class="p">,</span>
				   <span class="kt">char</span> <span class="o">**</span><span class="n">file_name</span><span class="p">,</span> <span class="n">Elf</span> <span class="o">**</span><span class="n">elfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">kernel_get_module_path</span><span class="p">(</span><span class="n">module_name</span><span class="p">);</span>

	<span class="n">pr_debug2</span><span class="p">(</span><span class="s">&quot;Use file %s for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">module_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">file_name</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* If failed, try to call standard method */</span>
	<span class="k">return</span> <span class="n">dwfl_linux_kernel_find_elf</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">userdata</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span>
					  <span class="n">file_name</span><span class="p">,</span> <span class="n">elfp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">Dwfl_Callbacks</span> <span class="n">kernel_callbacks</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">find_debuginfo</span> <span class="o">=</span> <span class="n">dwfl_standard_find_debuginfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">debuginfo_path</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">debuginfo_path</span><span class="p">,</span>

	<span class="p">.</span><span class="n">find_elf</span> <span class="o">=</span> <span class="n">__linux_kernel_find_elf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">section_address</span> <span class="o">=</span> <span class="n">dwfl_linux_kernel_module_section_address</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Get a Dwarf from live kernel image */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">debuginfo__init_online_kernel_dwarf</span><span class="p">(</span><span class="k">struct</span> <span class="n">debuginfo</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
					       <span class="n">Dwarf_Addr</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">dwfl</span> <span class="o">=</span> <span class="n">dwfl_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel_callbacks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dwfl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Load the kernel dwarves: Don&#39;t care the result here */</span>
	<span class="n">dwfl_linux_kernel_report_kernel</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dwfl</span><span class="p">);</span>
	<span class="n">dwfl_linux_kernel_report_modules</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dwfl</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">dbg</span> <span class="o">=</span> <span class="n">dwfl_addrdwarf</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dwfl</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">bias</span><span class="p">);</span>
	<span class="cm">/* Here, check whether we could get a real dwarf */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Failed to find kernel dwarf at %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">dwfl_end</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dwfl</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">self</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cm">/* With older elfutils, this just support kernel module... */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">debuginfo__init_online_kernel_dwarf</span><span class="p">(</span><span class="k">struct</span> <span class="n">debuginfo</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
					       <span class="n">Dwarf_Addr</span> <span class="n">addr</span> <span class="n">__used</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">kernel_get_module_path</span><span class="p">(</span><span class="s">&quot;kernel&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to find vmlinux path</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug2</span><span class="p">(</span><span class="s">&quot;Use file %s for debuginfo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">debuginfo__init_offline_dwarf</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">debuginfo</span> <span class="o">*</span><span class="nf">debuginfo__new</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">debuginfo</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">debuginfo</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debuginfo__init_offline_dwarf</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="n">self</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">debuginfo</span> <span class="o">*</span><span class="nf">debuginfo__new_online_kernel</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">debuginfo</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">debuginfo</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debuginfo__init_online_kernel_dwarf</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="p">(</span><span class="n">Dwarf_Addr</span><span class="p">)</span><span class="n">addr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="n">self</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">debuginfo__delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">debuginfo</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dwfl</span><span class="p">)</span>
			<span class="n">dwfl_end</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dwfl</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Probe finder related functions</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">probe_trace_arg_ref</span> <span class="o">*</span><span class="nf">alloc_trace_arg_ref</span><span class="p">(</span><span class="kt">long</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">probe_trace_arg_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="n">ref</span> <span class="o">=</span> <span class="n">zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">probe_trace_arg_ref</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">ref</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ref</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert a location into trace_arg.</span>
<span class="cm"> * If tvar == NULL, this just checks variable can be converted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">convert_variable_location</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">vr_die</span><span class="p">,</span> <span class="n">Dwarf_Addr</span> <span class="n">addr</span><span class="p">,</span>
				     <span class="n">Dwarf_Op</span> <span class="o">*</span><span class="n">fb_ops</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">probe_trace_arg</span> <span class="o">*</span><span class="n">tvar</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Dwarf_Attribute</span> <span class="n">attr</span><span class="p">;</span>
	<span class="n">Dwarf_Op</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">nops</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">regn</span><span class="p">;</span>
	<span class="n">Dwarf_Word</span> <span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ref</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dwarf_attr</span><span class="p">(</span><span class="n">vr_die</span><span class="p">,</span> <span class="n">DW_AT_external</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">static_var</span><span class="p">;</span>

	<span class="cm">/* TODO: handle more than 1 exprs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dwarf_attr</span><span class="p">(</span><span class="n">vr_die</span><span class="p">,</span> <span class="n">DW_AT_location</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
	    <span class="n">dwarf_getlocation_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nops</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">nops</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* TODO: Support const_value */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">atom</span> <span class="o">==</span> <span class="n">DW_OP_addr</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">static_var:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tvar</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Static variables on memory (not stack), make @varname */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">dwarf_diename</span><span class="p">(</span><span class="n">vr_die</span><span class="p">));</span>
		<span class="n">tvar</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">zalloc</span><span class="p">(</span><span class="n">ret</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">ret</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;@%s&quot;</span><span class="p">,</span> <span class="n">dwarf_diename</span><span class="p">(</span><span class="n">vr_die</span><span class="p">));</span>
		<span class="n">tvar</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">=</span> <span class="n">alloc_trace_arg_ref</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">offs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If this is based on frame buffer, set the offset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">atom</span> <span class="o">==</span> <span class="n">DW_OP_fbreg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fb_ops</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUP</span><span class="p">;</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">offs</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
		<span class="n">op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fb_ops</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">atom</span> <span class="o">&gt;=</span> <span class="n">DW_OP_breg0</span> <span class="o">&amp;&amp;</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">atom</span> <span class="o">&lt;=</span> <span class="n">DW_OP_breg31</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regn</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">atom</span> <span class="o">-</span> <span class="n">DW_OP_breg0</span><span class="p">;</span>
		<span class="n">offs</span> <span class="o">+=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">atom</span> <span class="o">&gt;=</span> <span class="n">DW_OP_reg0</span> <span class="o">&amp;&amp;</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">atom</span> <span class="o">&lt;=</span> <span class="n">DW_OP_reg31</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regn</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">atom</span> <span class="o">-</span> <span class="n">DW_OP_reg0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">atom</span> <span class="o">==</span> <span class="n">DW_OP_bregx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regn</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
		<span class="n">offs</span> <span class="o">+=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">number2</span><span class="p">;</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">atom</span> <span class="o">==</span> <span class="n">DW_OP_regx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regn</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;DW_OP %x is not supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">atom</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tvar</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">get_arch_regstr</span><span class="p">(</span><span class="n">regn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This should be a bug in DWARF or this tool */</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Mapping for the register number %u &quot;</span>
			   <span class="s">&quot;missing on this architecture.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regn</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tvar</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tvar</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">=</span> <span class="n">alloc_trace_arg_ref</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">offs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define BYTES_TO_BITS(nb)	((nb) * BITS_PER_LONG / sizeof(long))</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">convert_variable_type</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">vr_die</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">probe_trace_arg</span> <span class="o">*</span><span class="n">tvar</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cast</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">probe_trace_arg_ref</span> <span class="o">**</span><span class="n">ref_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">;</span>
	<span class="n">Dwarf_Die</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">bsize</span><span class="p">,</span> <span class="n">boffs</span><span class="p">,</span> <span class="n">total</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* TODO: check all types */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cast</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">cast</span><span class="p">,</span> <span class="s">&quot;string&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Non string type is OK */</span>
		<span class="n">tvar</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">cast</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">ENOMEM</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bsize</span> <span class="o">=</span> <span class="n">dwarf_bitsize</span><span class="p">(</span><span class="n">vr_die</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is a bitfield */</span>
		<span class="n">boffs</span> <span class="o">=</span> <span class="n">dwarf_bitoffset</span><span class="p">(</span><span class="n">vr_die</span><span class="p">);</span>
		<span class="n">total</span> <span class="o">=</span> <span class="n">dwarf_bytesize</span><span class="p">(</span><span class="n">vr_die</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">boffs</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">total</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="s">&quot;b%d@%d/%zd&quot;</span><span class="p">,</span> <span class="n">bsize</span><span class="p">,</span> <span class="n">boffs</span><span class="p">,</span>
				<span class="n">BYTES_TO_BITS</span><span class="p">(</span><span class="n">total</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">formatted</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">die_get_real_type</span><span class="p">(</span><span class="n">vr_die</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to get a type information of %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dwarf_diename</span><span class="p">(</span><span class="n">vr_die</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s type is %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">dwarf_diename</span><span class="p">(</span><span class="n">vr_die</span><span class="p">),</span> <span class="n">dwarf_diename</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cast</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">cast</span><span class="p">,</span> <span class="s">&quot;string&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* String type */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dwarf_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">DW_TAG_pointer_type</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ret</span> <span class="o">!=</span> <span class="n">DW_TAG_array_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to cast into string: &quot;</span>
				   <span class="s">&quot;%s(%s) is not a pointer nor array.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dwarf_diename</span><span class="p">(</span><span class="n">vr_die</span><span class="p">),</span> <span class="n">dwarf_diename</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">DW_TAG_pointer_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">die_get_real_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to get a type&quot;</span>
					   <span class="s">&quot; information.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">ref_ptr</span><span class="p">)</span>
				<span class="n">ref_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">ref_ptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="cm">/* Add new reference with offset +0 */</span>
			<span class="o">*</span><span class="n">ref_ptr</span> <span class="o">=</span> <span class="n">zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">probe_trace_arg_ref</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ref_ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Out of memory error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">die_compare_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;char&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">die_compare_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;unsigned char&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to cast into string: &quot;</span>
				   <span class="s">&quot;%s is not (unsigned) char *.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dwarf_diename</span><span class="p">(</span><span class="n">vr_die</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tvar</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">cast</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">ENOMEM</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dwarf_bytesize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* No size ... try to use default type */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">BYTES_TO_BITS</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="cm">/* Check the bitwidth */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="n">MAX_BASIC_TYPE_BITS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s exceeds max-bitwidth. Cut down to %d bits.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dwarf_diename</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">),</span> <span class="n">MAX_BASIC_TYPE_BITS</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">MAX_BASIC_TYPE_BITS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="s">&quot;%c%d&quot;</span><span class="p">,</span>
		       <span class="n">die_is_signed_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;s&#39;</span> <span class="o">:</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

<span class="nl">formatted:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to convert variable type: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">strerror</span><span class="p">(</span><span class="o">-</span><span class="n">ret</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tvar</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">convert_variable_fields</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">vr_die</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">varname</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">perf_probe_arg_field</span> <span class="o">*</span><span class="n">field</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">probe_trace_arg_ref</span> <span class="o">**</span><span class="n">ref_ptr</span><span class="p">,</span>
				    <span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">die_mem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">probe_trace_arg_ref</span> <span class="o">*</span><span class="n">ref</span> <span class="o">=</span> <span class="o">*</span><span class="n">ref_ptr</span><span class="p">;</span>
	<span class="n">Dwarf_Die</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">Dwarf_Word</span> <span class="n">offs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">tag</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;converting %s in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">varname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">die_get_real_type</span><span class="p">(</span><span class="n">vr_die</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to get the type of %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">varname</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug2</span><span class="p">(</span><span class="s">&quot;Var real type: (%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">dwarf_dieoffset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">));</span>
	<span class="n">tag</span> <span class="o">=</span> <span class="n">dwarf_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;[&#39;</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">DW_TAG_array_type</span> <span class="o">||</span> <span class="n">tag</span> <span class="o">==</span> <span class="n">DW_TAG_pointer_type</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="cm">/* Save original type for next field */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">die_mem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">die_mem</span><span class="p">));</span>
		<span class="cm">/* Get the type of this array */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">die_get_real_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to get the type of %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">varname</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pr_debug2</span><span class="p">(</span><span class="s">&quot;Array real type: (%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">dwarf_dieoffset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">DW_TAG_pointer_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ref</span> <span class="o">=</span> <span class="n">zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">probe_trace_arg_ref</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ref_ptr</span><span class="p">)</span>
				<span class="p">(</span><span class="o">*</span><span class="n">ref_ptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ref</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="o">*</span><span class="n">ref_ptr</span> <span class="o">=</span> <span class="n">ref</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ref</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">dwarf_bytesize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span> <span class="o">*</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="cm">/* Save vr_die for converting types */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">die_mem</span><span class="p">,</span> <span class="n">vr_die</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">die_mem</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">DW_TAG_pointer_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check the pointer and dereference */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Semantic error: %s must be referred by &#39;-&gt;&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Get the type pointed by this pointer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">die_get_real_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to get the type of %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">varname</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Verify it is a data structure  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dwarf_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DW_TAG_structure_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s is not a data structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">varname</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ref</span> <span class="o">=</span> <span class="n">zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">probe_trace_arg_ref</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ref_ptr</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">ref_ptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ref</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">ref_ptr</span> <span class="o">=</span> <span class="n">ref</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Verify it is a data structure  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">DW_TAG_structure_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s is not a data structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">varname</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;[&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Semantic error: %s is not a pointor&quot;</span>
			       <span class="s">&quot; nor array.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">varname</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Semantic error: %s must be referred by &#39;.&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Structure on a register is not &quot;</span>
				   <span class="s">&quot;supported yet.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUP</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">die_find_member</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">die_mem</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s(tyep:%s) has no member %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">varname</span><span class="p">,</span>
			   <span class="n">dwarf_diename</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type</span><span class="p">),</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the offset of the field */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">die_get_data_member_location</span><span class="p">(</span><span class="n">die_mem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to get the offset of %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ref</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">offs</span><span class="p">;</span>

<span class="nl">next:</span>
	<span class="cm">/* Converting next field */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">convert_variable_fields</span><span class="p">(</span><span class="n">die_mem</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					<span class="n">field</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">,</span> <span class="n">die_mem</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Show a variables in kprobe event format */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">convert_variable</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">vr_die</span><span class="p">,</span> <span class="k">struct</span> <span class="n">probe_finder</span> <span class="o">*</span><span class="n">pf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Dwarf_Die</span> <span class="n">die_mem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Converting variable %s into trace event.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">dwarf_diename</span><span class="p">(</span><span class="n">vr_die</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">convert_variable_location</span><span class="p">(</span><span class="n">vr_die</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">fb_ops</span><span class="p">,</span>
					<span class="n">pf</span><span class="o">-&gt;</span><span class="n">tvar</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to find the location of %s at this address.</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot; Perhaps, it has been optimized out.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOTSUP</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Sorry, we don&#39;t support this variable location yet.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">convert_variable_fields</span><span class="p">(</span><span class="n">vr_die</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">,</span>
					      <span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">die_mem</span><span class="p">);</span>
		<span class="n">vr_die</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">die_mem</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">convert_variable_type</span><span class="p">(</span><span class="n">vr_die</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">tvar</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="cm">/* *expr will be cached in libdw. Don&#39;t free it. */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find a variable in a scope DIE */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_variable</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">sc_die</span><span class="p">,</span> <span class="k">struct</span> <span class="n">probe_finder</span> <span class="o">*</span><span class="n">pf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Dwarf_Die</span> <span class="n">vr_die</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_c_varname</span><span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Copy raw parameters */</span>
		<span class="n">pf</span><span class="o">-&gt;</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pf</span><span class="o">-&gt;</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pf</span><span class="o">-&gt;</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">pf</span><span class="o">-&gt;</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
		<span class="n">pf</span><span class="o">-&gt;</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">synthesize_perf_probe_arg</span><span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">);</span>	<span class="cm">/* Change type separator to _ */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
			<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="sc">&#39;_&#39;</span><span class="p">;</span>
		<span class="n">pf</span><span class="o">-&gt;</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">tvar</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Searching &#39;%s&#39; variable in context.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">);</span>
	<span class="cm">/* Search child die for local variables and parameters. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">die_find_variable_at</span><span class="p">(</span><span class="n">sc_die</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vr_die</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Search again in global variables */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">die_find_variable_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">cu_die</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vr_die</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">convert_variable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vr_die</span><span class="p">,</span> <span class="n">pf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to find &#39;%s&#39; in this function.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert subprogram DIE to trace point */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">convert_to_trace_point</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">sp_die</span><span class="p">,</span> <span class="n">Dwarf_Addr</span> <span class="n">paddr</span><span class="p">,</span>
				  <span class="n">bool</span> <span class="n">retprobe</span><span class="p">,</span> <span class="k">struct</span> <span class="n">probe_trace_point</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Dwarf_Addr</span> <span class="n">eaddr</span><span class="p">,</span> <span class="n">highaddr</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/* Copy the name of probe point */</span>
	<span class="n">name</span> <span class="o">=</span> <span class="n">dwarf_diename</span><span class="p">(</span><span class="n">sp_die</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dwarf_entrypc</span><span class="p">(</span><span class="n">sp_die</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eaddr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to get entry address of %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dwarf_diename</span><span class="p">(</span><span class="n">sp_die</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dwarf_highpc</span><span class="p">(</span><span class="n">sp_die</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">highaddr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to get end address of %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dwarf_diename</span><span class="p">(</span><span class="n">sp_die</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">paddr</span> <span class="o">&gt;</span> <span class="n">highaddr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Offset specified is greater than size of %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dwarf_diename</span><span class="p">(</span><span class="n">sp_die</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">symbol</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">symbol</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">paddr</span> <span class="o">-</span> <span class="n">eaddr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* This function has no name. */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">paddr</span><span class="p">;</span>

	<span class="cm">/* Return probe must be on the head of a subprogram */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retprobe</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eaddr</span> <span class="o">!=</span> <span class="n">paddr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Return probe must be on the head of&quot;</span>
				   <span class="s">&quot; a real function.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retprobe</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Call probe_finder callback with scope DIE */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">call_probe_finder</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">sc_die</span><span class="p">,</span> <span class="k">struct</span> <span class="n">probe_finder</span> <span class="o">*</span><span class="n">pf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Dwarf_Attribute</span> <span class="n">fb_attr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">nops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc_die</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Caller must pass a scope DIE. Program error.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If not a real subprogram, find a real one */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dwarf_tag</span><span class="p">(</span><span class="n">sc_die</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DW_TAG_subprogram</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">die_find_realfunc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">cu_die</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">sp_die</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to find probe point in any &quot;</span>
				   <span class="s">&quot;functions.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">sp_die</span><span class="p">,</span> <span class="n">sc_die</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Dwarf_Die</span><span class="p">));</span>

	<span class="cm">/* Get the frame base attribute/ops from subprogram */</span>
	<span class="n">dwarf_attr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">sp_die</span><span class="p">,</span> <span class="n">DW_AT_frame_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fb_attr</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dwarf_getlocation_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fb_attr</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">fb_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nops</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nops</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pf</span><span class="o">-&gt;</span><span class="n">fb_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#if _ELFUTILS_PREREQ(0, 142)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nops</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">fb_ops</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">atom</span> <span class="o">==</span> <span class="n">DW_OP_call_frame_cfa</span> <span class="o">&amp;&amp;</span>
		   <span class="n">pf</span><span class="o">-&gt;</span><span class="n">cfi</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Dwarf_Frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dwarf_cfi_addrframe</span><span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">cfi</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">dwarf_frame_cfa</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">fb_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nops</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to get call frame on 0x%jx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">uintmax_t</span><span class="p">)</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/* Call finder&#39;s callback handler */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">sc_die</span><span class="p">,</span> <span class="n">pf</span><span class="p">);</span>

	<span class="cm">/* *pf-&gt;fb_ops will be cached in libdw. Don&#39;t free it. */</span>
	<span class="n">pf</span><span class="o">-&gt;</span><span class="n">fb_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">find_scope_param</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">line</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">diff</span><span class="p">;</span>
	<span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">die_mem</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">found</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_best_scope_cb</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">fn_die</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">find_scope_param</span> <span class="o">*</span><span class="n">fsp</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lno</span><span class="p">;</span>

	<span class="cm">/* Skip if declared file name does not match */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">file</span> <span class="o">=</span> <span class="n">dwarf_decl_file</span><span class="p">(</span><span class="n">fn_die</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span> <span class="o">||</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* If the function name is given, that&#39;s what user expects */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">die_compare_name</span><span class="p">(</span><span class="n">fn_die</span><span class="p">,</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">die_mem</span><span class="p">,</span> <span class="n">fn_die</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Dwarf_Die</span><span class="p">));</span>
			<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* With the line number, find the nearest declared DIE */</span>
		<span class="n">dwarf_decl_line</span><span class="p">(</span><span class="n">fn_die</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lno</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lno</span> <span class="o">&lt;</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">line</span> <span class="o">&amp;&amp;</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">line</span> <span class="o">-</span> <span class="n">lno</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Keep a candidate and continue */</span>
			<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">diff</span> <span class="o">=</span> <span class="n">fsp</span><span class="o">-&gt;</span><span class="n">line</span> <span class="o">-</span> <span class="n">lno</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">fsp</span><span class="o">-&gt;</span><span class="n">die_mem</span><span class="p">,</span> <span class="n">fn_die</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Dwarf_Die</span><span class="p">));</span>
			<span class="n">fsp</span><span class="o">-&gt;</span><span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find an appropriate scope fits to given conditions */</span>
<span class="k">static</span> <span class="n">Dwarf_Die</span> <span class="o">*</span><span class="nf">find_best_scope</span><span class="p">(</span><span class="k">struct</span> <span class="n">probe_finder</span> <span class="o">*</span><span class="n">pf</span><span class="p">,</span> <span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">die_mem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">find_scope_param</span> <span class="n">fsp</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">pev</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">.</span><span class="n">function</span><span class="p">,</span>
		<span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">,</span>
		<span class="p">.</span><span class="n">line</span> <span class="o">=</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">lno</span><span class="p">,</span>
		<span class="p">.</span><span class="n">diff</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">,</span>
		<span class="p">.</span><span class="n">die_mem</span> <span class="o">=</span> <span class="n">die_mem</span><span class="p">,</span>
		<span class="p">.</span><span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">cu_walk_functions_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">cu_die</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">find_best_scope_cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fsp</span><span class="p">.</span><span class="n">found</span> <span class="o">?</span> <span class="n">die_mem</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">probe_point_line_walker</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lineno</span><span class="p">,</span>
				   <span class="n">Dwarf_Addr</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">probe_finder</span> <span class="o">*</span><span class="n">pf</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">sc_die</span><span class="p">,</span> <span class="n">die_mem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lineno</span> <span class="o">!=</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">lno</span> <span class="o">||</span> <span class="n">strtailcmp</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pf</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">sc_die</span> <span class="o">=</span> <span class="n">find_best_scope</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">die_mem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc_die</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to find scope of probe point.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_probe_finder</span><span class="p">(</span><span class="n">sc_die</span><span class="p">,</span> <span class="n">pf</span><span class="p">);</span>

	<span class="cm">/* Continue if no error, because the line will be in inline function */</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find probe point from its line number */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_probe_point_by_line</span><span class="p">(</span><span class="k">struct</span> <span class="n">probe_finder</span> <span class="o">*</span><span class="n">pf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">die_walk_lines</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">cu_die</span><span class="p">,</span> <span class="n">probe_point_line_walker</span><span class="p">,</span> <span class="n">pf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Find lines which match lazy pattern */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_lazy_match_lines</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">line</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">line_len</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">linenum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to open %s: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">errno</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">getline</span><span class="p">(</span><span class="o">&amp;</span><span class="n">line</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">line_len</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
			<span class="n">line</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strlazymatch</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">pat</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">line_list__add_line</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">linenum</span><span class="p">);</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">linenum</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ferror</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span>
		<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="n">errno</span><span class="p">;</span>
	<span class="n">free</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
	<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;No matched lines found in %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fname</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">probe_point_lazy_walker</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lineno</span><span class="p">,</span>
				   <span class="n">Dwarf_Addr</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">probe_finder</span> <span class="o">*</span><span class="n">pf</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">sc_die</span><span class="p">,</span> <span class="n">die_mem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">line_list__has_line</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">lcache</span><span class="p">,</span> <span class="n">lineno</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">strtailcmp</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Probe line found: line:%d addr:0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">lineno</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">pf</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">pf</span><span class="o">-&gt;</span><span class="n">lno</span> <span class="o">=</span> <span class="n">lineno</span><span class="p">;</span>
	<span class="n">sc_die</span> <span class="o">=</span> <span class="n">find_best_scope</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">die_mem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc_die</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to find scope of probe point.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_probe_finder</span><span class="p">(</span><span class="n">sc_die</span><span class="p">,</span> <span class="n">pf</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Continue if no error, because the lazy pattern will match</span>
<span class="cm">	 * to other lines</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find probe points from lazy pattern  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_probe_point_lazy</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">sp_die</span><span class="p">,</span> <span class="k">struct</span> <span class="n">probe_finder</span> <span class="o">*</span><span class="n">pf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">lcache</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Matching lazy line pattern */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">find_lazy_match_lines</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">lcache</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">,</span>
					    <span class="n">pf</span><span class="o">-&gt;</span><span class="n">pev</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">.</span><span class="n">lazy_line</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">die_walk_lines</span><span class="p">(</span><span class="n">sp_die</span><span class="p">,</span> <span class="n">probe_point_lazy_walker</span><span class="p">,</span> <span class="n">pf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">probe_point_inline_cb</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">in_die</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">probe_finder</span> <span class="o">*</span><span class="n">pf</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_probe_point</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">pev</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">;</span>
	<span class="n">Dwarf_Addr</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lazy_line</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">find_probe_point_lazy</span><span class="p">(</span><span class="n">in_die</span><span class="p">,</span> <span class="n">pf</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Get probe address */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dwarf_entrypc</span><span class="p">(</span><span class="n">in_die</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to get entry address of %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dwarf_diename</span><span class="p">(</span><span class="n">in_die</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pf</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">pf</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;found inline addr: 0x%jx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">uintmax_t</span><span class="p">)</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">call_probe_finder</span><span class="p">(</span><span class="n">in_die</span><span class="p">,</span> <span class="n">pf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Callback parameter with return value for libdw */</span>
<span class="k">struct</span> <span class="n">dwarf_callback_param</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Search function from function name */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">probe_point_search_cb</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">sp_die</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dwarf_callback_param</span> <span class="o">*</span><span class="n">param</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">probe_finder</span> <span class="o">*</span><span class="n">pf</span> <span class="o">=</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_probe_point</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">pev</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">;</span>
	<span class="n">Dwarf_Attribute</span> <span class="n">attr</span><span class="p">;</span>

	<span class="cm">/* Check tag and diename */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dwarf_tag</span><span class="p">(</span><span class="n">sp_die</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DW_TAG_subprogram</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">die_compare_name</span><span class="p">(</span><span class="n">sp_die</span><span class="p">,</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">dwarf_attr</span><span class="p">(</span><span class="n">sp_die</span><span class="p">,</span> <span class="n">DW_AT_declaration</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">DWARF_CB_OK</span><span class="p">;</span>

	<span class="cm">/* Check declared file */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">&amp;&amp;</span> <span class="n">strtailcmp</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">dwarf_decl_file</span><span class="p">(</span><span class="n">sp_die</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">DWARF_CB_OK</span><span class="p">;</span>

	<span class="n">pf</span><span class="o">-&gt;</span><span class="n">fname</span> <span class="o">=</span> <span class="n">dwarf_decl_file</span><span class="p">(</span><span class="n">sp_die</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Function relative line */</span>
		<span class="n">dwarf_decl_line</span><span class="p">(</span><span class="n">sp_die</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">lno</span><span class="p">);</span>
		<span class="n">pf</span><span class="o">-&gt;</span><span class="n">lno</span> <span class="o">+=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">;</span>
		<span class="n">param</span><span class="o">-&gt;</span><span class="n">retval</span> <span class="o">=</span> <span class="n">find_probe_point_by_line</span><span class="p">(</span><span class="n">pf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dwarf_func_inline</span><span class="p">(</span><span class="n">sp_die</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Real function */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lazy_line</span><span class="p">)</span>
			<span class="n">param</span><span class="o">-&gt;</span><span class="n">retval</span> <span class="o">=</span> <span class="n">find_probe_point_lazy</span><span class="p">(</span><span class="n">sp_die</span><span class="p">,</span> <span class="n">pf</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dwarf_entrypc</span><span class="p">(</span><span class="n">sp_die</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to get entry address of &quot;</span>
					   <span class="s">&quot;%s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dwarf_diename</span><span class="p">(</span><span class="n">sp_die</span><span class="p">));</span>
				<span class="n">param</span><span class="o">-&gt;</span><span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">DWARF_CB_ABORT</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">pf</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
			<span class="cm">/* TODO: Check the address in this function */</span>
			<span class="n">param</span><span class="o">-&gt;</span><span class="n">retval</span> <span class="o">=</span> <span class="n">call_probe_finder</span><span class="p">(</span><span class="n">sp_die</span><span class="p">,</span> <span class="n">pf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* Inlined function: search instances */</span>
		<span class="n">param</span><span class="o">-&gt;</span><span class="n">retval</span> <span class="o">=</span> <span class="n">die_walk_instances</span><span class="p">(</span><span class="n">sp_die</span><span class="p">,</span>
					<span class="n">probe_point_inline_cb</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">DWARF_CB_ABORT</span><span class="p">;</span> <span class="cm">/* Exit; no same symbol in this CU. */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_probe_point_by_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">probe_finder</span> <span class="o">*</span><span class="n">pf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dwarf_callback_param</span> <span class="n">_param</span> <span class="o">=</span> <span class="p">{.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pf</span><span class="p">,</span>
					      <span class="p">.</span><span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">};</span>
	<span class="n">dwarf_getfuncs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">cu_die</span><span class="p">,</span> <span class="n">probe_point_search_cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">_param</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">_param</span><span class="p">.</span><span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">pubname_callback_param</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">cu_die</span><span class="p">;</span>
	<span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">sp_die</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pubname_search_cb</span><span class="p">(</span><span class="n">Dwarf</span> <span class="o">*</span><span class="n">dbg</span><span class="p">,</span> <span class="n">Dwarf_Global</span> <span class="o">*</span><span class="n">gl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pubname_callback_param</span> <span class="o">*</span><span class="n">param</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dwarf_offdie</span><span class="p">(</span><span class="n">dbg</span><span class="p">,</span> <span class="n">gl</span><span class="o">-&gt;</span><span class="n">die_offset</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sp_die</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dwarf_tag</span><span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">sp_die</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DW_TAG_subprogram</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">DWARF_CB_OK</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">die_compare_name</span><span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">sp_die</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dwarf_offdie</span><span class="p">(</span><span class="n">dbg</span><span class="p">,</span> <span class="n">gl</span><span class="o">-&gt;</span><span class="n">cu_offset</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">cu_die</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">DWARF_CB_OK</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">&amp;&amp;</span>
			    <span class="n">strtailcmp</span><span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">dwarf_decl_file</span><span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">sp_die</span><span class="p">)))</span>
				<span class="k">return</span> <span class="n">DWARF_CB_OK</span><span class="p">;</span>

			<span class="n">param</span><span class="o">-&gt;</span><span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">DWARF_CB_ABORT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">DWARF_CB_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find probe points from debuginfo */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">debuginfo__find_probes</span><span class="p">(</span><span class="k">struct</span> <span class="n">debuginfo</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">probe_finder</span> <span class="o">*</span><span class="n">pf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_probe_point</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">pev</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">;</span>
	<span class="n">Dwarf_Off</span> <span class="n">off</span><span class="p">,</span> <span class="n">noff</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">cuhl</span><span class="p">;</span>
	<span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">diep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#if _ELFUTILS_PREREQ(0, 142)</span>
	<span class="cm">/* Get the call frame information from this dwarf */</span>
	<span class="n">pf</span><span class="o">-&gt;</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">dwarf_getcfi</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">line_list__init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">lcache</span><span class="p">);</span>

	<span class="cm">/* Fastpath: lookup by function name from .debug_pubnames section */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pubname_callback_param</span> <span class="n">pubname_param</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">,</span>
			<span class="p">.</span><span class="n">file</span>	  <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span>
			<span class="p">.</span><span class="n">cu_die</span>	  <span class="o">=</span> <span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">cu_die</span><span class="p">,</span>
			<span class="p">.</span><span class="n">sp_die</span>	  <span class="o">=</span> <span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">sp_die</span><span class="p">,</span>
			<span class="p">.</span><span class="n">found</span>	  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">};</span>
		<span class="k">struct</span> <span class="n">dwarf_callback_param</span> <span class="n">probe_param</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">pf</span><span class="p">,</span>
		<span class="p">};</span>

		<span class="n">dwarf_getpubnames</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">,</span> <span class="n">pubname_search_cb</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">pubname_param</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pubname_param</span><span class="p">.</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">probe_point_search_cb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">sp_die</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">probe_param</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Loop on CUs (Compilation Unit) */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">dwarf_nextcu</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">noff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cuhl</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Get the DIE(Debugging Information Entry) of this CU */</span>
		<span class="n">diep</span> <span class="o">=</span> <span class="n">dwarf_offdie</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">,</span> <span class="n">off</span> <span class="o">+</span> <span class="n">cuhl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">cu_die</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">diep</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Check if target file is included. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">)</span>
			<span class="n">pf</span><span class="o">-&gt;</span><span class="n">fname</span> <span class="o">=</span> <span class="n">cu_find_realpath</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">cu_die</span><span class="p">,</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pf</span><span class="o">-&gt;</span><span class="n">fname</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">||</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">find_probe_point_by_func</span><span class="p">(</span><span class="n">pf</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lazy_line</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">find_probe_point_lazy</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">pf</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">pf</span><span class="o">-&gt;</span><span class="n">lno</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">;</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">find_probe_point_by_line</span><span class="p">(</span><span class="n">pf</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">off</span> <span class="o">=</span> <span class="n">noff</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">found:</span>
	<span class="n">line_list__free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">lcache</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Add a found probe point into trace event list */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_probe_trace_event</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">sc_die</span><span class="p">,</span> <span class="k">struct</span> <span class="n">probe_finder</span> <span class="o">*</span><span class="n">pf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_event_finder</span> <span class="o">*</span><span class="n">tf</span> <span class="o">=</span>
			<span class="n">container_of</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">trace_event_finder</span><span class="p">,</span> <span class="n">pf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">probe_trace_event</span> <span class="o">*</span><span class="n">tev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Check number of tevs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">ntevs</span> <span class="o">==</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">max_tevs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Too many( &gt; %d) probe point found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">tf</span><span class="o">-&gt;</span><span class="n">max_tevs</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">tevs</span><span class="p">[</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">ntevs</span><span class="o">++</span><span class="p">];</span>

	<span class="cm">/* Trace point should be converted from subprogram DIE */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">convert_to_trace_point</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">sp_die</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
				     <span class="n">pf</span><span class="o">-&gt;</span><span class="n">pev</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">.</span><span class="n">retprobe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tev</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Probe point found: %s+%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tev</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">.</span><span class="n">symbol</span><span class="p">,</span>
		 <span class="n">tev</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>

	<span class="cm">/* Find each argument */</span>
	<span class="n">tev</span><span class="o">-&gt;</span><span class="n">nargs</span> <span class="o">=</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">pev</span><span class="o">-&gt;</span><span class="n">nargs</span><span class="p">;</span>
	<span class="n">tev</span><span class="o">-&gt;</span><span class="n">args</span> <span class="o">=</span> <span class="n">zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">probe_trace_arg</span><span class="p">)</span> <span class="o">*</span> <span class="n">tev</span><span class="o">-&gt;</span><span class="n">nargs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tev</span><span class="o">-&gt;</span><span class="n">args</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">pev</span><span class="o">-&gt;</span><span class="n">nargs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pf</span><span class="o">-&gt;</span><span class="n">pvar</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">pev</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">pf</span><span class="o">-&gt;</span><span class="n">tvar</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tev</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="cm">/* Variable should be found from scope DIE */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">find_variable</span><span class="p">(</span><span class="n">sc_die</span><span class="p">,</span> <span class="n">pf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find probe_trace_events specified by perf_probe_event from debuginfo */</span>
<span class="kt">int</span> <span class="nf">debuginfo__find_trace_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">debuginfo</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">perf_probe_event</span> <span class="o">*</span><span class="n">pev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">probe_trace_event</span> <span class="o">**</span><span class="n">tevs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_tevs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trace_event_finder</span> <span class="n">tf</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">pf</span> <span class="o">=</span> <span class="p">{.</span><span class="n">pev</span> <span class="o">=</span> <span class="n">pev</span><span class="p">,</span> <span class="p">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">add_probe_trace_event</span><span class="p">},</span>
			<span class="p">.</span><span class="n">max_tevs</span> <span class="o">=</span> <span class="n">max_tevs</span><span class="p">};</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Allocate result tevs array */</span>
	<span class="o">*</span><span class="n">tevs</span> <span class="o">=</span> <span class="n">zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">probe_trace_event</span><span class="p">)</span> <span class="o">*</span> <span class="n">max_tevs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">tevs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">tf</span><span class="p">.</span><span class="n">tevs</span> <span class="o">=</span> <span class="o">*</span><span class="n">tevs</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">ntevs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">debuginfo__find_probes</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">.</span><span class="n">pf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">tevs</span><span class="p">);</span>
		<span class="o">*</span><span class="n">tevs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">tf</span><span class="p">.</span><span class="n">ntevs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define MAX_VAR_LEN 64</span>

<span class="cm">/* Collect available variables in this scope */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">collect_variables_cb</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">die_mem</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">available_var_finder</span> <span class="o">*</span><span class="n">af</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">variable_list</span> <span class="o">*</span><span class="n">vl</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAX_VAR_LEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">tag</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">vl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">vls</span><span class="p">[</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">nvls</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

	<span class="n">tag</span> <span class="o">=</span> <span class="n">dwarf_tag</span><span class="p">(</span><span class="n">die_mem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">DW_TAG_formal_parameter</span> <span class="o">||</span>
	    <span class="n">tag</span> <span class="o">==</span> <span class="n">DW_TAG_variable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">convert_variable_location</span><span class="p">(</span><span class="n">die_mem</span><span class="p">,</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
						<span class="n">af</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">fb_ops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">die_get_varname</span><span class="p">(</span><span class="n">die_mem</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAX_VAR_LEN</span><span class="p">);</span>
			<span class="n">pr_debug2</span><span class="p">(</span><span class="s">&quot;Add new var: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">strlist__add</span><span class="p">(</span><span class="n">vl</span><span class="o">-&gt;</span><span class="n">vars</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">child</span> <span class="o">&amp;&amp;</span> <span class="n">dwarf_haspc</span><span class="p">(</span><span class="n">die_mem</span><span class="p">,</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">.</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">DIE_FIND_CB_CONTINUE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">DIE_FIND_CB_SIBLING</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Add a found vars into available variables list */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_available_vars</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">sc_die</span><span class="p">,</span> <span class="k">struct</span> <span class="n">probe_finder</span> <span class="o">*</span><span class="n">pf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">available_var_finder</span> <span class="o">*</span><span class="n">af</span> <span class="o">=</span>
			<span class="n">container_of</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">available_var_finder</span><span class="p">,</span> <span class="n">pf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">variable_list</span> <span class="o">*</span><span class="n">vl</span><span class="p">;</span>
	<span class="n">Dwarf_Die</span> <span class="n">die_mem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Check number of tevs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">nvls</span> <span class="o">==</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">max_vls</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Too many( &gt; %d) probe point found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">af</span><span class="o">-&gt;</span><span class="n">max_vls</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">vls</span><span class="p">[</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">nvls</span><span class="o">++</span><span class="p">];</span>

	<span class="cm">/* Trace point should be converted from subprogram DIE */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">convert_to_trace_point</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">sp_die</span><span class="p">,</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
				     <span class="n">pf</span><span class="o">-&gt;</span><span class="n">pev</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">.</span><span class="n">retprobe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vl</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Probe point found: %s+%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vl</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">.</span><span class="n">symbol</span><span class="p">,</span>
		 <span class="n">vl</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>

	<span class="cm">/* Find local variables */</span>
	<span class="n">vl</span><span class="o">-&gt;</span><span class="n">vars</span> <span class="o">=</span> <span class="n">strlist__new</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vl</span><span class="o">-&gt;</span><span class="n">vars</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">af</span><span class="o">-&gt;</span><span class="n">child</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">die_find_child</span><span class="p">(</span><span class="n">sc_die</span><span class="p">,</span> <span class="n">collect_variables_cb</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">die_mem</span><span class="p">);</span>

	<span class="cm">/* Find external variables */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af</span><span class="o">-&gt;</span><span class="n">externs</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/* Don&#39;t need to search child DIE for externs. */</span>
	<span class="n">af</span><span class="o">-&gt;</span><span class="n">child</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">die_find_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">cu_die</span><span class="p">,</span> <span class="n">collect_variables_cb</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">af</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">die_mem</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strlist__empty</span><span class="p">(</span><span class="n">vl</span><span class="o">-&gt;</span><span class="n">vars</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">strlist__delete</span><span class="p">(</span><span class="n">vl</span><span class="o">-&gt;</span><span class="n">vars</span><span class="p">);</span>
		<span class="n">vl</span><span class="o">-&gt;</span><span class="n">vars</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find available variables at given probe point */</span>
<span class="kt">int</span> <span class="nf">debuginfo__find_available_vars_at</span><span class="p">(</span><span class="k">struct</span> <span class="n">debuginfo</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">perf_probe_event</span> <span class="o">*</span><span class="n">pev</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">variable_list</span> <span class="o">**</span><span class="n">vls</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">max_vls</span><span class="p">,</span> <span class="n">bool</span> <span class="n">externs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">available_var_finder</span> <span class="n">af</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">pf</span> <span class="o">=</span> <span class="p">{.</span><span class="n">pev</span> <span class="o">=</span> <span class="n">pev</span><span class="p">,</span> <span class="p">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">add_available_vars</span><span class="p">},</span>
			<span class="p">.</span><span class="n">max_vls</span> <span class="o">=</span> <span class="n">max_vls</span><span class="p">,</span> <span class="p">.</span><span class="n">externs</span> <span class="o">=</span> <span class="n">externs</span><span class="p">};</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Allocate result vls array */</span>
	<span class="o">*</span><span class="n">vls</span> <span class="o">=</span> <span class="n">zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">variable_list</span><span class="p">)</span> <span class="o">*</span> <span class="n">max_vls</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">vls</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">af</span><span class="p">.</span><span class="n">vls</span> <span class="o">=</span> <span class="o">*</span><span class="n">vls</span><span class="p">;</span>
	<span class="n">af</span><span class="p">.</span><span class="n">nvls</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">debuginfo__find_probes</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">af</span><span class="p">.</span><span class="n">pf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Free vlist for error */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">af</span><span class="p">.</span><span class="n">nvls</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">af</span><span class="p">.</span><span class="n">vls</span><span class="p">[</span><span class="n">af</span><span class="p">.</span><span class="n">nvls</span><span class="p">].</span><span class="n">point</span><span class="p">.</span><span class="n">symbol</span><span class="p">)</span>
				<span class="n">free</span><span class="p">(</span><span class="n">af</span><span class="p">.</span><span class="n">vls</span><span class="p">[</span><span class="n">af</span><span class="p">.</span><span class="n">nvls</span><span class="p">].</span><span class="n">point</span><span class="p">.</span><span class="n">symbol</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">af</span><span class="p">.</span><span class="n">vls</span><span class="p">[</span><span class="n">af</span><span class="p">.</span><span class="n">nvls</span><span class="p">].</span><span class="n">vars</span><span class="p">)</span>
				<span class="n">strlist__delete</span><span class="p">(</span><span class="n">af</span><span class="p">.</span><span class="n">vls</span><span class="p">[</span><span class="n">af</span><span class="p">.</span><span class="n">nvls</span><span class="p">].</span><span class="n">vars</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">free</span><span class="p">(</span><span class="n">af</span><span class="p">.</span><span class="n">vls</span><span class="p">);</span>
		<span class="o">*</span><span class="n">vls</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">af</span><span class="p">.</span><span class="n">nvls</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Reverse search */</span>
<span class="kt">int</span> <span class="nf">debuginfo__find_probe_point</span><span class="p">(</span><span class="k">struct</span> <span class="n">debuginfo</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">perf_probe_point</span> <span class="o">*</span><span class="n">ppt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Dwarf_Die</span> <span class="n">cudie</span><span class="p">,</span> <span class="n">spdie</span><span class="p">,</span> <span class="n">indie</span><span class="p">;</span>
	<span class="n">Dwarf_Addr</span> <span class="n">_addr</span><span class="p">,</span> <span class="n">baseaddr</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">baseline</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lineno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Adjust address with bias */</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">bias</span><span class="p">;</span>

	<span class="cm">/* Find cu die */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dwarf_addrdie</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">,</span> <span class="p">(</span><span class="n">Dwarf_Addr</span><span class="p">)</span><span class="n">addr</span> <span class="o">-</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">bias</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cudie</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Failed to find debug information for address %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">addr</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Find a corresponding line (filename and lineno) */</span>
	<span class="n">cu_find_lineinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cudie</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lineno</span><span class="p">);</span>
	<span class="cm">/* Don&#39;t care whether it failed or not */</span>

	<span class="cm">/* Find a corresponding function (name, baseline and baseaddr) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">die_find_realfunc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cudie</span><span class="p">,</span> <span class="p">(</span><span class="n">Dwarf_Addr</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spdie</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Get function entry information */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">dwarf_diename</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spdie</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span> <span class="o">||</span>
		    <span class="n">dwarf_entrypc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spdie</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">baseaddr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">dwarf_decl_line</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spdie</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">baseline</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">post</span><span class="p">;</span>
		<span class="n">func</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">baseaddr</span><span class="p">)</span>
			<span class="cm">/* Function entry - Relative line number is 0 */</span>
			<span class="n">lineno</span> <span class="o">=</span> <span class="n">baseline</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">die_find_inlinefunc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spdie</span><span class="p">,</span> <span class="p">(</span><span class="n">Dwarf_Addr</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">indie</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dwarf_entrypc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">indie</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">_addr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="n">_addr</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span>
				<span class="cm">/*</span>
<span class="cm">				 * addr is at an inline function entry.</span>
<span class="cm">				 * In this case, lineno should be the call-site</span>
<span class="cm">				 * line number.</span>
<span class="cm">				 */</span>
				<span class="n">lineno</span> <span class="o">=</span> <span class="n">die_get_call_lineno</span><span class="p">(</span><span class="o">&amp;</span><span class="n">indie</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * addr is in an inline function body.</span>
<span class="cm">				 * Since lineno points one of the lines</span>
<span class="cm">				 * of the inline function, baseline should</span>
<span class="cm">				 * be the entry line of the inline function.</span>
<span class="cm">				 */</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="n">dwarf_diename</span><span class="p">(</span><span class="o">&amp;</span><span class="n">indie</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;&amp;</span>
				    <span class="n">dwarf_decl_line</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spdie</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">baseline</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">func</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">post:</span>
	<span class="cm">/* Make a relative line number or an offset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lineno</span><span class="p">)</span>
		<span class="n">ppt</span><span class="o">-&gt;</span><span class="n">line</span> <span class="o">=</span> <span class="n">lineno</span> <span class="o">-</span> <span class="n">baseline</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">func</span><span class="p">)</span>
		<span class="n">ppt</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">baseaddr</span><span class="p">;</span>

	<span class="cm">/* Duplicate strings */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppt</span><span class="o">-&gt;</span><span class="n">function</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ppt</span><span class="o">-&gt;</span><span class="n">function</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fname</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppt</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">fname</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ppt</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ppt</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free</span><span class="p">(</span><span class="n">ppt</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">);</span>
				<span class="n">ppt</span><span class="o">-&gt;</span><span class="n">function</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">end:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fname</span> <span class="o">||</span> <span class="n">func</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Found a point */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Add a line and store the src path */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">line_range_add_line</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lineno</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">line_range</span> <span class="o">*</span><span class="n">lr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Copy source path */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lr</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">line_list__add_line</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">line_list</span><span class="p">,</span> <span class="n">lineno</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">line_range_walk_cb</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lineno</span><span class="p">,</span>
			      <span class="n">Dwarf_Addr</span> <span class="n">addr</span> <span class="n">__used</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">line_finder</span> <span class="o">*</span><span class="n">lf</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">strtailcmp</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">lf</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">lf</span><span class="o">-&gt;</span><span class="n">lno_s</span> <span class="o">&gt;</span> <span class="n">lineno</span> <span class="o">||</span> <span class="n">lf</span><span class="o">-&gt;</span><span class="n">lno_e</span> <span class="o">&lt;</span> <span class="n">lineno</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">line_range_add_line</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">lf</span><span class="o">-&gt;</span><span class="n">lr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find line range from its line number */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_line_range_by_line</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">sp_die</span><span class="p">,</span> <span class="k">struct</span> <span class="n">line_finder</span> <span class="o">*</span><span class="n">lf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">die_walk_lines</span><span class="p">(</span><span class="n">sp_die</span> <span class="o">?:</span> <span class="o">&amp;</span><span class="n">lf</span><span class="o">-&gt;</span><span class="n">cu_die</span><span class="p">,</span> <span class="n">line_range_walk_cb</span><span class="p">,</span> <span class="n">lf</span><span class="p">);</span>

	<span class="cm">/* Update status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lf</span><span class="o">-&gt;</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">line_list</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">lf</span><span class="o">-&gt;</span><span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Lines are not found */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">free</span><span class="p">(</span><span class="n">lf</span><span class="o">-&gt;</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
		<span class="n">lf</span><span class="o">-&gt;</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">line_range_inline_cb</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">in_die</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">find_line_range_by_line</span><span class="p">(</span><span class="n">in_die</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to check all instances of inlined function, because</span>
<span class="cm">	 * some execution paths can be optimized out depends on the</span>
<span class="cm">	 * function argument of instances</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Search function from function name */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">line_range_search_cb</span><span class="p">(</span><span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">sp_die</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dwarf_callback_param</span> <span class="o">*</span><span class="n">param</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">line_finder</span> <span class="o">*</span><span class="n">lf</span> <span class="o">=</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">line_range</span> <span class="o">*</span><span class="n">lr</span> <span class="o">=</span> <span class="n">lf</span><span class="o">-&gt;</span><span class="n">lr</span><span class="p">;</span>

	<span class="cm">/* Check declared file */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">&amp;&amp;</span> <span class="n">strtailcmp</span><span class="p">(</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">dwarf_decl_file</span><span class="p">(</span><span class="n">sp_die</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">DWARF_CB_OK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dwarf_tag</span><span class="p">(</span><span class="n">sp_die</span><span class="p">)</span> <span class="o">==</span> <span class="n">DW_TAG_subprogram</span> <span class="o">&amp;&amp;</span>
	    <span class="n">die_compare_name</span><span class="p">(</span><span class="n">sp_die</span><span class="p">,</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lf</span><span class="o">-&gt;</span><span class="n">fname</span> <span class="o">=</span> <span class="n">dwarf_decl_file</span><span class="p">(</span><span class="n">sp_die</span><span class="p">);</span>
		<span class="n">dwarf_decl_line</span><span class="p">(</span><span class="n">sp_die</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;fname: %s, lineno:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lf</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">,</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">lf</span><span class="o">-&gt;</span><span class="n">lno_s</span> <span class="o">=</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lf</span><span class="o">-&gt;</span><span class="n">lno_s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* Overflow */</span>
			<span class="n">lf</span><span class="o">-&gt;</span><span class="n">lno_s</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
		<span class="n">lf</span><span class="o">-&gt;</span><span class="n">lno_e</span> <span class="o">=</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lf</span><span class="o">-&gt;</span><span class="n">lno_e</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* Overflow */</span>
			<span class="n">lf</span><span class="o">-&gt;</span><span class="n">lno_e</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;New line range: %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lf</span><span class="o">-&gt;</span><span class="n">lno_s</span><span class="p">,</span> <span class="n">lf</span><span class="o">-&gt;</span><span class="n">lno_e</span><span class="p">);</span>
		<span class="n">lr</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">lf</span><span class="o">-&gt;</span><span class="n">lno_s</span><span class="p">;</span>
		<span class="n">lr</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">lf</span><span class="o">-&gt;</span><span class="n">lno_e</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dwarf_func_inline</span><span class="p">(</span><span class="n">sp_die</span><span class="p">))</span>
			<span class="n">param</span><span class="o">-&gt;</span><span class="n">retval</span> <span class="o">=</span> <span class="n">die_walk_instances</span><span class="p">(</span><span class="n">sp_die</span><span class="p">,</span>
						<span class="n">line_range_inline_cb</span><span class="p">,</span> <span class="n">lf</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">param</span><span class="o">-&gt;</span><span class="n">retval</span> <span class="o">=</span> <span class="n">find_line_range_by_line</span><span class="p">(</span><span class="n">sp_die</span><span class="p">,</span> <span class="n">lf</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DWARF_CB_ABORT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">DWARF_CB_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_line_range_by_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">line_finder</span> <span class="o">*</span><span class="n">lf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dwarf_callback_param</span> <span class="n">param</span> <span class="o">=</span> <span class="p">{.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">lf</span><span class="p">,</span> <span class="p">.</span><span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">};</span>
	<span class="n">dwarf_getfuncs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lf</span><span class="o">-&gt;</span><span class="n">cu_die</span><span class="p">,</span> <span class="n">line_range_search_cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">param</span><span class="p">.</span><span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">debuginfo__find_line_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">debuginfo</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">line_range</span> <span class="o">*</span><span class="n">lr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">line_finder</span> <span class="n">lf</span> <span class="o">=</span> <span class="p">{.</span><span class="n">lr</span> <span class="o">=</span> <span class="n">lr</span><span class="p">,</span> <span class="p">.</span><span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">};</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">Dwarf_Off</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">noff</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">cuhl</span><span class="p">;</span>
	<span class="n">Dwarf_Die</span> <span class="o">*</span><span class="n">diep</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">comp_dir</span><span class="p">;</span>

	<span class="cm">/* Fastpath: lookup by function name from .debug_pubnames section */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pubname_callback_param</span> <span class="n">pubname_param</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">,</span> <span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span>
			<span class="p">.</span><span class="n">cu_die</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lf</span><span class="p">.</span><span class="n">cu_die</span><span class="p">,</span> <span class="p">.</span><span class="n">sp_die</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lf</span><span class="p">.</span><span class="n">sp_die</span><span class="p">,</span> <span class="p">.</span><span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">};</span>
		<span class="k">struct</span> <span class="n">dwarf_callback_param</span> <span class="n">line_range_param</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">lf</span><span class="p">,</span> <span class="p">.</span><span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">};</span>

		<span class="n">dwarf_getpubnames</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">,</span> <span class="n">pubname_search_cb</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">pubname_param</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pubname_param</span><span class="p">.</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">line_range_search_cb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lf</span><span class="p">.</span><span class="n">sp_die</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">line_range_param</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lf</span><span class="p">.</span><span class="n">found</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Loop on CUs (Compilation Unit) */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">lf</span><span class="p">.</span><span class="n">found</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dwarf_nextcu</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">noff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cuhl</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Get the DIE(Debugging Information Entry) of this CU */</span>
		<span class="n">diep</span> <span class="o">=</span> <span class="n">dwarf_offdie</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">,</span> <span class="n">off</span> <span class="o">+</span> <span class="n">cuhl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lf</span><span class="p">.</span><span class="n">cu_die</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">diep</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Check if target file is included. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">)</span>
			<span class="n">lf</span><span class="p">.</span><span class="n">fname</span> <span class="o">=</span> <span class="n">cu_find_realpath</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lf</span><span class="p">.</span><span class="n">cu_die</span><span class="p">,</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">lf</span><span class="p">.</span><span class="n">fname</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">||</span> <span class="n">lf</span><span class="p">.</span><span class="n">fname</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">find_line_range_by_func</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lf</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">lf</span><span class="p">.</span><span class="n">lno_s</span> <span class="o">=</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
				<span class="n">lf</span><span class="p">.</span><span class="n">lno_e</span> <span class="o">=</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">find_line_range_by_line</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lf</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">off</span> <span class="o">=</span> <span class="n">noff</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">found:</span>
	<span class="cm">/* Store comp_dir */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lf</span><span class="p">.</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">comp_dir</span> <span class="o">=</span> <span class="n">cu_get_comp_dir</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lf</span><span class="p">.</span><span class="n">cu_die</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">comp_dir</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lr</span><span class="o">-&gt;</span><span class="n">comp_dir</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">comp_dir</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">comp_dir</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;path: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">lf</span><span class="p">.</span><span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
