<!DOCTYPE html>
<html><head><title>joekychen/linux » ipc › mqueue.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>mqueue.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * POSIX message queues filesystem for Linux.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2003,2004  Krzysztof Benedyczak    (golbi@mat.uni.torun.pl)</span>
<span class="cm"> *                          Michal Wronski          (michal.wronski@gmail.com)</span>
<span class="cm"> *</span>
<span class="cm"> * Spinlocks:               Mohamed Abbas           (abbas.mohamed@intel.com)</span>
<span class="cm"> * Lockless receive &amp; send, fd based notify:</span>
<span class="cm"> * 			    Manfred Spraul	    (manfred@colorfullife.com)</span>
<span class="cm"> *</span>
<span class="cm"> * Audit:                   George Wilson           (ltcgcw@us.ibm.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPL.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/mqueue.h&gt;</span>
<span class="cp">#include &lt;linux/msg.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/netlink.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>
<span class="cp">#include &lt;linux/pid.h&gt;</span>
<span class="cp">#include &lt;linux/ipc_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/user_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &quot;util.h&quot;</span>

<span class="cp">#define MQUEUE_MAGIC	0x19800202</span>
<span class="cp">#define DIRENT_SIZE	20</span>
<span class="cp">#define FILENT_SIZE	80</span>

<span class="cp">#define SEND		0</span>
<span class="cp">#define RECV		1</span>

<span class="cp">#define STATE_NONE	0</span>
<span class="cp">#define STATE_PENDING	1</span>
<span class="cp">#define STATE_READY	2</span>

<span class="k">struct</span> <span class="n">posix_msg_tree_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">msg_list</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">priority</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ext_wait_queue</span> <span class="p">{</span>		<span class="cm">/* queue of sleeping tasks */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>	<span class="cm">/* ptr of loaded message */</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>		<span class="cm">/* one of STATE_* values */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="n">vfs_inode</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wait_q</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">msg_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">posix_msg_tree_node</span> <span class="o">*</span><span class="n">node_cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sigevent</span> <span class="n">notify</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span><span class="o">*</span> <span class="n">notify_owner</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">notify_user_ns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>	<span class="cm">/* user who created, for accounting */</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">notify_sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">notify_cookie</span><span class="p">;</span>

	<span class="cm">/* for tasks waiting for free space and messages, respectively */</span>
	<span class="k">struct</span> <span class="n">ext_wait_queue</span> <span class="n">e_wait_q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">qsize</span><span class="p">;</span> <span class="cm">/* size of queue in memory (sum of all msgs) */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">mqueue_dir_inode_operations</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">mqueue_file_operations</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">mqueue_super_ops</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">remove_notification</span><span class="p">(</span><span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">mqueue_inode_cachep</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ctl_table_header</span> <span class="o">*</span> <span class="n">mq_sysctl_table</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="nf">MQUEUE_I</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mqueue_inode_info</span><span class="p">,</span> <span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine should be called with the mq_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="nf">__get_ns_from_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">get_ipc_ns</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="nf">get_ns_from_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mq_lock</span><span class="p">);</span>
	<span class="n">ns</span> <span class="o">=</span> <span class="n">__get_ns_from_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mq_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Auxiliary functions to manipulate messages&#39; list */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">msg_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">posix_msg_tree_node</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">msg_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">posix_msg_tree_node</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">==</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">insert_msg</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">m_type</span> <span class="o">&lt;</span> <span class="n">leaf</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">leaf</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">leaf</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">rb_init_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">msg_list</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">qsize</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">leaf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">leaf</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">;</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">msg_tree</span><span class="p">);</span>
<span class="nl">insert_msg:</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_curmsgs</span><span class="o">++</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">qsize</span> <span class="o">+=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">m_ts</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">m_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">msg_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="nf">msg_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">posix_msg_tree_node</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

<span class="nl">try_again:</span>
	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">msg_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * During insert, low priorities go to the left and high to the</span>
<span class="cm">		 * right.  On receive, we want the highest priorities first, so</span>
<span class="cm">		 * walk all the way to the right.</span>
<span class="cm">		 */</span>
		<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_curmsgs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn_once</span><span class="p">(</span><span class="s">&quot;Inconsistency in POSIX message queue, &quot;</span>
				     <span class="s">&quot;no tree element, but supposedly messages &quot;</span>
				     <span class="s">&quot;should exist!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_curmsgs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">posix_msg_tree_node</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">msg_list</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pr_warn_once</span><span class="p">(</span><span class="s">&quot;Inconsistency in POSIX message queue, &quot;</span>
			     <span class="s">&quot;empty leaf node but we haven&#39;t implemented &quot;</span>
			     <span class="s">&quot;lazy leaf delete!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">msg_tree</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">qsize</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">leaf</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span> <span class="o">=</span> <span class="n">leaf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">try_again</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">msg_list</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">msg_msg</span><span class="p">,</span> <span class="n">m_list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">m_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">msg_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">msg_tree</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">qsize</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">leaf</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span> <span class="o">=</span> <span class="n">leaf</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_curmsgs</span><span class="o">--</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">qsize</span> <span class="o">-=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">m_ts</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">msg</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">mqueue_get_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ipc_ns</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">mq_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">current_user</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">get_next_ino</span><span class="p">();</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">current_fsuid</span><span class="p">();</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">current_fsgid</span><span class="p">();</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mq_bytes</span><span class="p">,</span> <span class="n">mq_treesize</span><span class="p">;</span>

		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mqueue_file_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">FILENT_SIZE</span><span class="p">;</span>
		<span class="cm">/* mqueue specific info */</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">MQUEUE_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">wait_q</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">e_wait_q</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">e_wait_q</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">list</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_user_ns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">qsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* set when all is ok */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">msg_tree</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">));</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_maxmsg</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_msg_max</span><span class="p">,</span>
					   <span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_msg_default</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_msgsize_max</span><span class="p">,</span>
					    <span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_msgsize_default</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_maxmsg</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">mq_maxmsg</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">mq_msgsize</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * We used to allocate a static array of pointers and account</span>
<span class="cm">		 * the size of that array as well as one msg_msg struct per</span>
<span class="cm">		 * possible message into the queue size. That&#39;s no longer</span>
<span class="cm">		 * accurate as the queue is now an rbtree and will grow and</span>
<span class="cm">		 * shrink depending on usage patterns.  We can, however, still</span>
<span class="cm">		 * account one msg_msg struct per message, but the nodes are</span>
<span class="cm">		 * allocated depending on priority usage, and most programs</span>
<span class="cm">		 * only use one, or a handful, of priorities.  However, since</span>
<span class="cm">		 * this is pinned memory, we need to assume worst case, so</span>
<span class="cm">		 * that means the min(mq_maxmsg, max_priorities) * struct</span>
<span class="cm">		 * posix_msg_tree_node.</span>
<span class="cm">		 */</span>
		<span class="n">mq_treesize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_maxmsg</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_maxmsg</span><span class="p">,</span> <span class="n">MQ_PRIO_MAX</span><span class="p">)</span> <span class="o">*</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">posix_msg_tree_node</span><span class="p">);</span>

		<span class="n">mq_bytes</span> <span class="o">=</span> <span class="n">mq_treesize</span> <span class="o">+</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_maxmsg</span> <span class="o">*</span>
					  <span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mq_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">mq_bytes</span> <span class="o">+</span> <span class="n">mq_bytes</span> <span class="o">&lt;</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">mq_bytes</span> <span class="o">||</span>
		    <span class="n">u</span><span class="o">-&gt;</span><span class="n">mq_bytes</span> <span class="o">+</span> <span class="n">mq_bytes</span> <span class="o">&gt;</span> <span class="n">rlimit</span><span class="p">(</span><span class="n">RLIMIT_MSGQUEUE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mq_lock</span><span class="p">);</span>
			<span class="cm">/* mqueue_evict_inode() releases info-&gt;messages */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMFILE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_inode</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">u</span><span class="o">-&gt;</span><span class="n">mq_bytes</span> <span class="o">+=</span> <span class="n">mq_bytes</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mq_lock</span><span class="p">);</span>

		<span class="cm">/* all is ok */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">=</span> <span class="n">get_uid</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inc_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="cm">/* Some things misbehave if size == 0 on a directory */</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">DIRENT_SIZE</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mqueue_dir_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">simple_dir_operations</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="nl">out_inode:</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mqueue_fill_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">silent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_magic</span> <span class="o">=</span> <span class="n">MQUEUE_MAGIC</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mqueue_super_ops</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">mqueue_get_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">S_IFDIR</span> <span class="o">|</span> <span class="n">S_ISVTX</span> <span class="o">|</span> <span class="n">S_IRWXUGO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">=</span> <span class="n">d_make_root</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">mqueue_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_KERNMOUNT</span><span class="p">))</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">ipc_ns</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mount_ns</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mqueue_fill_super</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_once</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="p">)</span> <span class="n">foo</span><span class="p">;</span>

	<span class="n">inode_init_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">mqueue_alloc_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">mqueue_inode_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ei</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mqueue_i_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span><span class="p">,</span> <span class="n">i_rcu</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">mqueue_inode_cachep</span><span class="p">,</span> <span class="n">MQUEUE_I</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mqueue_destroy_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rcu</span><span class="p">,</span> <span class="n">mqueue_i_callback</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mqueue_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mq_bytes</span><span class="p">,</span> <span class="n">mq_treesize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ipc_ns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

	<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ipc_ns</span> <span class="o">=</span> <span class="n">get_ns_from_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">MQUEUE_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg_get</span><span class="p">(</span><span class="n">info</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">free_msg</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Total amount of bytes accounted for the mqueue */</span>
	<span class="n">mq_treesize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_maxmsg</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_maxmsg</span><span class="p">,</span> <span class="n">MQ_PRIO_MAX</span><span class="p">)</span> <span class="o">*</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">posix_msg_tree_node</span><span class="p">);</span>

	<span class="n">mq_bytes</span> <span class="o">=</span> <span class="n">mq_treesize</span> <span class="o">+</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_maxmsg</span> <span class="o">*</span>
				  <span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">);</span>

	<span class="n">user</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mq_lock</span><span class="p">);</span>
		<span class="n">user</span><span class="o">-&gt;</span><span class="n">mq_bytes</span> <span class="o">-=</span> <span class="n">mq_bytes</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * get_ns_from_inode() ensures that the</span>
<span class="cm">		 * (ipc_ns = sb-&gt;s_fs_info) is either a valid ipc_ns</span>
<span class="cm">		 * to which we now hold a reference, or it is NULL.</span>
<span class="cm">		 * We can&#39;t put it here under mq_lock, though.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ipc_ns</span><span class="p">)</span>
			<span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_queues_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mq_lock</span><span class="p">);</span>
		<span class="n">free_uid</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipc_ns</span><span class="p">)</span>
		<span class="n">put_ipc_ns</span><span class="p">(</span><span class="n">ipc_ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mqueue_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				<span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mq_attr</span> <span class="o">*</span><span class="n">attr</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ipc_ns</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mq_lock</span><span class="p">);</span>
	<span class="n">ipc_ns</span> <span class="o">=</span> <span class="n">__get_ns_from_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ipc_ns</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_queues_count</span> <span class="o">&gt;=</span> <span class="n">HARD_QUEUESMAX</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_queues_count</span> <span class="o">&gt;=</span> <span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_queues_max</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RESOURCE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_queues_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mq_lock</span><span class="p">);</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">mqueue_get_inode</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">ipc_ns</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mq_lock</span><span class="p">);</span>
		<span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_queues_count</span><span class="o">--</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">put_ipc_ns</span><span class="p">(</span><span class="n">ipc_ns</span><span class="p">);</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">DIRENT_SIZE</span><span class="p">;</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>

	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">dget</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mq_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipc_ns</span><span class="p">)</span>
		<span class="n">put_ipc_ns</span><span class="p">(</span><span class="n">ipc_ns</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mqueue_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
  	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-=</span> <span class="n">DIRENT_SIZE</span><span class="p">;</span>
  	<span class="n">drop_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
  	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
  	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">*	This is routine for system read from queue file.</span>
<span class="cm">*	To avoid mess with doing here some sort of mq_receive we allow</span>
<span class="cm">*	to read only queue size &amp; notification info (the only values</span>
<span class="cm">*	that are interesting from user point of view and aren&#39;t accessible</span>
<span class="cm">*	through std routines)</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mqueue_read_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_data</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">MQUEUE_I</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">FILENT_SIZE</span><span class="p">];</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span>
			<span class="s">&quot;QSIZE:%-10lu NOTIFY:%-5d SIGNO:%-5d NOTIFY_PID:%-6d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">qsize</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span> <span class="o">?</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span> <span class="o">&amp;&amp;</span>
			 <span class="n">info</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">==</span> <span class="n">SIGEV_SIGNAL</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">sigev_signo</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">pid_vnr</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">buffer</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">u_data</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span>
				<span class="n">strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mqueue_flush_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">fl_owner_t</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">MQUEUE_I</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task_tgid</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span><span class="p">)</span>
		<span class="n">remove_notification</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mqueue_poll_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="n">poll_tab</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">MQUEUE_I</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">wait_q</span><span class="p">,</span> <span class="n">poll_tab</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_curmsgs</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_curmsgs</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_maxmsg</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Adds current to info-&gt;e_wait_q[sr] before element with smaller prio */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wq_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sr</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ext_wait_queue</span> <span class="o">*</span><span class="n">ewp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext_wait_queue</span> <span class="o">*</span><span class="n">walk</span><span class="p">;</span>

	<span class="n">ewp</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">walk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">e_wait_q</span><span class="p">[</span><span class="n">sr</span><span class="p">].</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">walk</span><span class="o">-&gt;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">&lt;=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">static_prio</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ewp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">walk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ewp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">e_wait_q</span><span class="p">[</span><span class="n">sr</span><span class="p">].</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Puts current task to sleep. Caller must hold queue lock. After return</span>
<span class="cm"> * lock isn&#39;t held.</span>
<span class="cm"> * sr: SEND or RECV</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wq_sleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sr</span><span class="p">,</span>
		    <span class="n">ktime_t</span> <span class="o">*</span><span class="n">timeout</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext_wait_queue</span> <span class="o">*</span><span class="n">ewp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">signed</span> <span class="kt">long</span> <span class="n">time</span><span class="p">;</span>

	<span class="n">wq_add</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">ewp</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">time</span> <span class="o">=</span> <span class="n">schedule_hrtimeout_range_clock</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">HRTIMER_MODE_ABS</span><span class="p">,</span> <span class="n">CLOCK_REALTIME</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">ewp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">STATE_PENDING</span><span class="p">)</span>
			<span class="n">cpu_relax</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ewp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">STATE_READY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ewp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">STATE_READY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ewp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns waiting task that should be serviced first or NULL if none exists</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ext_wait_queue</span> <span class="o">*</span><span class="nf">wq_get_first_waiter</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">e_wait_q</span><span class="p">[</span><span class="n">sr</span><span class="p">].</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">e_wait_q</span><span class="p">[</span><span class="n">sr</span><span class="p">].</span><span class="n">list</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext_wait_queue</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_cookie</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">char</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="n">NOTIFY_COOKIE_LEN</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The next function is only to split too long sys_mq_timedsend</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__do_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* notification</span>
<span class="cm">	 * invoked when there is registered process and there isn&#39;t process</span>
<span class="cm">	 * waiting synchronously for message AND state of queue changed from</span>
<span class="cm">	 * empty to not empty. Here we are sure that no one is waiting</span>
<span class="cm">	 * synchronously. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span> <span class="o">&amp;&amp;</span>
	    <span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_curmsgs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">siginfo</span> <span class="n">sig_i</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">sigev_notify</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SIGEV_NONE</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SIGEV_SIGNAL</span>:
			<span class="cm">/* sends signal */</span>

			<span class="n">sig_i</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">sigev_signo</span><span class="p">;</span>
			<span class="n">sig_i</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sig_i</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">SI_MESGQ</span><span class="p">;</span>
			<span class="n">sig_i</span><span class="p">.</span><span class="n">si_value</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">sigev_value</span><span class="p">;</span>
			<span class="cm">/* map current pid/uid into info-&gt;owner&#39;s namespaces */</span>
			<span class="n">rcu_read_lock</span><span class="p">();</span>
			<span class="n">sig_i</span><span class="p">.</span><span class="n">si_pid</span> <span class="o">=</span> <span class="n">task_tgid_nr_ns</span><span class="p">(</span><span class="n">current</span><span class="p">,</span>
						<span class="n">ns_of_pid</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span><span class="p">));</span>
			<span class="n">sig_i</span><span class="p">.</span><span class="n">si_uid</span> <span class="o">=</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_user_ns</span><span class="p">,</span> <span class="n">current_uid</span><span class="p">());</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>

			<span class="n">kill_pid_info</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">sigev_signo</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">sig_i</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SIGEV_THREAD</span>:
			<span class="n">set_cookie</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_cookie</span><span class="p">,</span> <span class="n">NOTIFY_WOKENUP</span><span class="p">);</span>
			<span class="n">netlink_sendskb</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_sock</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_cookie</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* after notification unregisters process */</span>
		<span class="n">put_pid</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span><span class="p">);</span>
		<span class="n">put_user_ns</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_user_ns</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_user_ns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">wait_q</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">prepare_timeout</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_abs_timeout</span><span class="p">,</span>
			   <span class="n">ktime_t</span> <span class="o">*</span><span class="n">expires</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">u_abs_timeout</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timespec_valid</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="o">*</span><span class="n">expires</span> <span class="o">=</span> <span class="n">timespec_to_ktime</span><span class="p">(</span><span class="o">*</span><span class="n">ts</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_notification</span><span class="p">(</span><span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">info</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">==</span> <span class="n">SIGEV_THREAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_cookie</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_cookie</span><span class="p">,</span> <span class="n">NOTIFY_REMOVED</span><span class="p">);</span>
		<span class="n">netlink_sendskb</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_sock</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_cookie</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">put_pid</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span><span class="p">);</span>
	<span class="n">put_user_ns</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_user_ns</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_user_ns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mq_attr_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ipc_ns</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mq_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mq_treesize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">mq_maxmsg</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">mq_msgsize</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RESOURCE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">mq_maxmsg</span> <span class="o">&gt;</span> <span class="n">HARD_MSGMAX</span> <span class="o">||</span>
		    <span class="n">attr</span><span class="o">-&gt;</span><span class="n">mq_msgsize</span> <span class="o">&gt;</span> <span class="n">HARD_MSGSIZEMAX</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">mq_maxmsg</span> <span class="o">&gt;</span> <span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_msg_max</span> <span class="o">||</span>
				<span class="n">attr</span><span class="o">-&gt;</span><span class="n">mq_msgsize</span> <span class="o">&gt;</span> <span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_msgsize_max</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* check for overflow */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">mq_msgsize</span> <span class="o">&gt;</span> <span class="n">ULONG_MAX</span><span class="o">/</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">mq_maxmsg</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
	<span class="n">mq_treesize</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">mq_maxmsg</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">mq_maxmsg</span><span class="p">,</span> <span class="n">MQ_PRIO_MAX</span><span class="p">)</span> <span class="o">*</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">posix_msg_tree_node</span><span class="p">);</span>
	<span class="n">total_size</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">mq_maxmsg</span> <span class="o">*</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">mq_msgsize</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">total_size</span> <span class="o">+</span> <span class="n">mq_treesize</span> <span class="o">&lt;</span> <span class="n">total_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Invoked when creating a new queue via sys_mq_open</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">do_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ipc_ns</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">mq_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mq_attr_ok</span><span class="p">(</span><span class="n">ipc_ns</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="cm">/* store for use during create */</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span> <span class="o">=</span> <span class="n">attr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">def_attr</span><span class="p">;</span>

		<span class="n">def_attr</span><span class="p">.</span><span class="n">mq_maxmsg</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_msg_max</span><span class="p">,</span>
					 <span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_msg_default</span><span class="p">);</span>
		<span class="n">def_attr</span><span class="p">.</span><span class="n">mq_msgsize</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_msgsize_max</span><span class="p">,</span>
					  <span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_msgsize_default</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mq_attr_ok</span><span class="p">(</span><span class="n">ipc_ns</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">def_attr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">current_umask</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mnt_want_write</span><span class="p">(</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vfs_create</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_drop_write</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">dentry_open</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="p">,</span> <span class="n">oflag</span><span class="p">,</span> <span class="n">cred</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * dentry_open() took a persistent mnt_want_write(),</span>
<span class="cm">	 * so we can now drop this one.</span>
<span class="cm">	 */</span>
	<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

<span class="nl">out_drop_write:</span>
	<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">mntput</span><span class="p">(</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Opens existing queue */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">do_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ipc_ns</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>

	<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">oflag2acc</span><span class="p">[</span><span class="n">O_ACCMODE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">MAY_READ</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">,</span>
						  <span class="n">MAY_READ</span> <span class="o">|</span> <span class="n">MAY_WRITE</span> <span class="p">};</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">oflag</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_WRONLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode_permission</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">oflag2acc</span><span class="p">[</span><span class="n">oflag</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dentry_open</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="p">,</span> <span class="n">oflag</span><span class="p">,</span> <span class="n">cred</span><span class="p">);</span>

<span class="nl">err:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">mntput</span><span class="p">(</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">mq_open</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">u_name</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">oflag</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">u_attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ipc_ns</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">ipc_ns</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">u_attr</span> <span class="o">&amp;&amp;</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">u_attr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mq_attr</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">audit_mq_open</span><span class="p">(</span><span class="n">oflag</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">u_attr</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">attr</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">getname</span><span class="p">(</span><span class="n">u_name</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">get_unused_fd_flags</span><span class="p">(</span><span class="n">O_CLOEXEC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_putname</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">lookup_one_len</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_putfd</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mntget</span><span class="p">(</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oflag</span> <span class="o">&amp;</span> <span class="n">O_CREAT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* entry already exists */</span>
			<span class="n">audit_inode</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">oflag</span> <span class="o">&amp;</span> <span class="n">O_EXCL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">filp</span> <span class="o">=</span> <span class="n">do_open</span><span class="p">(</span><span class="n">ipc_ns</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">oflag</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">filp</span> <span class="o">=</span> <span class="n">do_create</span><span class="p">(</span><span class="n">ipc_ns</span><span class="p">,</span> <span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">,</span>
						<span class="n">dentry</span><span class="p">,</span> <span class="n">oflag</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
						<span class="n">u_attr</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">attr</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">audit_inode</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
		<span class="n">filp</span> <span class="o">=</span> <span class="n">do_open</span><span class="p">(</span><span class="n">ipc_ns</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">oflag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_putfd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fd_install</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out_upsem</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">mntput</span><span class="p">(</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="p">);</span>
<span class="nl">out_putfd:</span>
	<span class="n">put_unused_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="n">fd</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_upsem:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
<span class="nl">out_putname:</span>
	<span class="n">putname</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">mq_unlink</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">u_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ipc_ns</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">ipc_ns</span><span class="p">;</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">getname</span><span class="p">(</span><span class="n">u_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span>
			<span class="n">I_MUTEX_PARENT</span><span class="p">);</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">lookup_one_len</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">mnt_want_write</span><span class="p">(</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vfs_unlink</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="p">);</span>
<span class="nl">out_err:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipc_ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">putname</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Pipelined send and receive functions.</span>
<span class="cm"> *</span>
<span class="cm"> * If a receiver finds no waiting message, then it registers itself in the</span>
<span class="cm"> * list of waiting receivers. A sender checks that list before adding the new</span>
<span class="cm"> * message into the message array. If there is a waiting receiver, then it</span>
<span class="cm"> * bypasses the message array and directly hands the message over to the</span>
<span class="cm"> * receiver.</span>
<span class="cm"> * The receiver accepts the message and returns without grabbing the queue</span>
<span class="cm"> * spinlock. Therefore an intermediate STATE_PENDING state and memory barriers</span>
<span class="cm"> * are necessary. The same algorithm is used for sysv semaphores, see</span>
<span class="cm"> * ipc/sem.c for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * The same algorithm is used for senders.</span>
<span class="cm"> */</span>

<span class="cm">/* pipelined_send() - send a message directly to the task waiting in</span>
<span class="cm"> * sys_mq_timedreceive() (without inserting message into a queue).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">pipelined_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ext_wait_queue</span> <span class="o">*</span><span class="n">receiver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">receiver</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="n">message</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">receiver</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">receiver</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_PENDING</span><span class="p">;</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">receiver</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">receiver</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_READY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* pipelined_receive() - if there is task waiting in sys_mq_timedsend()</span>
<span class="cm"> * gets its message and put to the queue (we have one free place for sure). */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">pipelined_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext_wait_queue</span> <span class="o">*</span><span class="n">sender</span> <span class="o">=</span> <span class="n">wq_get_first_waiter</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">SEND</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sender</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* for poll */</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">wait_q</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg_insert</span><span class="p">(</span><span class="n">sender</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">,</span> <span class="n">info</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sender</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">sender</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_PENDING</span><span class="p">;</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">sender</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">sender</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_READY</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">mq_timedsend</span><span class="p">,</span> <span class="n">mqd_t</span><span class="p">,</span> <span class="n">mqdes</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">u_msg_ptr</span><span class="p">,</span>
		<span class="kt">size_t</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">msg_prio</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">u_abs_timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext_wait_queue</span> <span class="n">wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext_wait_queue</span> <span class="o">*</span><span class="n">receiver</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">expires</span><span class="p">,</span> <span class="o">*</span><span class="n">timeout</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">posix_msg_tree_node</span> <span class="o">*</span><span class="n">new_leaf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">u_abs_timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">prepare_timeout</span><span class="p">(</span><span class="n">u_abs_timeout</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">expires</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">expires</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">msg_prio</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">MQ_PRIO_MAX</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">audit_mq_sendrecv</span><span class="p">(</span><span class="n">mqdes</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">,</span> <span class="n">msg_prio</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">ts</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">filp</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">mqdes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">mqueue_file_operations</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">MQUEUE_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">audit_inode</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">msg_len</span> <span class="o">&gt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* First try to allocate memory, before doing anything with</span>
<span class="cm">	 * existing queues. */</span>
	<span class="n">msg_ptr</span> <span class="o">=</span> <span class="n">load_msg</span><span class="p">(</span><span class="n">u_msg_ptr</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg_ptr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">msg_ptr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">msg_ptr</span><span class="o">-&gt;</span><span class="n">m_ts</span> <span class="o">=</span> <span class="n">msg_len</span><span class="p">;</span>
	<span class="n">msg_ptr</span><span class="o">-&gt;</span><span class="n">m_type</span> <span class="o">=</span> <span class="n">msg_prio</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * msg_insert really wants us to have a valid, spare node struct so</span>
<span class="cm">	 * it doesn&#39;t have to kmalloc a GFP_ATOMIC allocation, but it will</span>
<span class="cm">	 * fall back to that if necessary.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span><span class="p">)</span>
		<span class="n">new_leaf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_leaf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span> <span class="o">&amp;&amp;</span> <span class="n">new_leaf</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Save our speculative allocation into the cache */</span>
		<span class="n">rb_init_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_leaf</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_leaf</span><span class="o">-&gt;</span><span class="n">msg_list</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span> <span class="o">=</span> <span class="n">new_leaf</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">qsize</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_leaf</span><span class="p">);</span>
		<span class="n">new_leaf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new_leaf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_curmsgs</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_maxmsg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">wait</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
			<span class="n">wait</span><span class="p">.</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">msg_ptr</span><span class="p">;</span>
			<span class="n">wait</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_NONE</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">wq_sleep</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">SEND</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * wq_sleep must be called with info-&gt;lock held, and</span>
<span class="cm">			 * returns with the lock released</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">receiver</span> <span class="o">=</span> <span class="n">wq_get_first_waiter</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RECV</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">receiver</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pipelined_send</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">msg_ptr</span><span class="p">,</span> <span class="n">receiver</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* adds message to the queue */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">msg_insert</span><span class="p">(</span><span class="n">msg_ptr</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="n">__do_notify</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span>
				<span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">free_msg</span><span class="p">(</span><span class="n">msg_ptr</span><span class="p">);</span>
<span class="nl">out_fput:</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">mq_timedreceive</span><span class="p">,</span> <span class="n">mqd_t</span><span class="p">,</span> <span class="n">mqdes</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">u_msg_ptr</span><span class="p">,</span>
		<span class="kt">size_t</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">u_msg_prio</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">u_abs_timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext_wait_queue</span> <span class="n">wait</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">expires</span><span class="p">,</span> <span class="o">*</span><span class="n">timeout</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">posix_msg_tree_node</span> <span class="o">*</span><span class="n">new_leaf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">u_abs_timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">prepare_timeout</span><span class="p">(</span><span class="n">u_abs_timeout</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">expires</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">expires</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">audit_mq_sendrecv</span><span class="p">(</span><span class="n">mqdes</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">ts</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">filp</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">mqdes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">mqueue_file_operations</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">MQUEUE_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">audit_inode</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* checks if buffer is big enough */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">msg_len</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * msg_insert really wants us to have a valid, spare node struct so</span>
<span class="cm">	 * it doesn&#39;t have to kmalloc a GFP_ATOMIC allocation, but it will</span>
<span class="cm">	 * fall back to that if necessary.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span><span class="p">)</span>
		<span class="n">new_leaf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_leaf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span> <span class="o">&amp;&amp;</span> <span class="n">new_leaf</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Save our speculative allocation into the cache */</span>
		<span class="n">rb_init_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_leaf</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_leaf</span><span class="o">-&gt;</span><span class="n">msg_list</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">node_cache</span> <span class="o">=</span> <span class="n">new_leaf</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">qsize</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_leaf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new_leaf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_curmsgs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">wait</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
			<span class="n">wait</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_NONE</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">wq_sleep</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RECV</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="n">msg_ptr</span> <span class="o">=</span> <span class="n">wait</span><span class="p">.</span><span class="n">msg</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">msg_ptr</span> <span class="o">=</span> <span class="n">msg_get</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span>
				<span class="n">CURRENT_TIME</span><span class="p">;</span>

		<span class="cm">/* There is now free space in queue. */</span>
		<span class="n">pipelined_receive</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">msg_ptr</span><span class="o">-&gt;</span><span class="n">m_ts</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">u_msg_prio</span> <span class="o">&amp;&amp;</span> <span class="n">put_user</span><span class="p">(</span><span class="n">msg_ptr</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">,</span> <span class="n">u_msg_prio</span><span class="p">))</span> <span class="o">||</span>
			<span class="n">store_msg</span><span class="p">(</span><span class="n">u_msg_ptr</span><span class="p">,</span> <span class="n">msg_ptr</span><span class="p">,</span> <span class="n">msg_ptr</span><span class="o">-&gt;</span><span class="n">m_ts</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">free_msg</span><span class="p">(</span><span class="n">msg_ptr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_fput:</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Notes: the case when user wants us to deregister (with NULL as pointer)</span>
<span class="cm"> * and he isn&#39;t currently owner of notification, will be silently discarded.</span>
<span class="cm"> * It isn&#39;t explicitly defined in the POSIX.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">mq_notify</span><span class="p">,</span> <span class="n">mqd_t</span><span class="p">,</span> <span class="n">mqdes</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sigevent</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">u_notification</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sigevent</span> <span class="n">notification</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">u_notification</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notification</span><span class="p">,</span> <span class="n">u_notification</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sigevent</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">audit_mq_notify</span><span class="p">(</span><span class="n">mqdes</span><span class="p">,</span> <span class="n">u_notification</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">notification</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">nc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">u_notification</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">!=</span> <span class="n">SIGEV_NONE</span> <span class="o">&amp;&amp;</span>
			     <span class="n">notification</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">!=</span> <span class="n">SIGEV_SIGNAL</span> <span class="o">&amp;&amp;</span>
			     <span class="n">notification</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">!=</span> <span class="n">SIGEV_THREAD</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">==</span> <span class="n">SIGEV_SIGNAL</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">valid_signal</span><span class="p">(</span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_signo</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">==</span> <span class="n">SIGEV_THREAD</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>

			<span class="cm">/* create the notify skb */</span>
			<span class="n">nc</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">NOTIFY_COOKIE_LEN</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">nc</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
					<span class="n">notification</span><span class="p">.</span><span class="n">sigev_value</span><span class="p">.</span><span class="n">sival_ptr</span><span class="p">,</span>
					<span class="n">NOTIFY_COOKIE_LEN</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* TODO: add a header? */</span>
			<span class="n">skb_put</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">NOTIFY_COOKIE_LEN</span><span class="p">);</span>
			<span class="cm">/* and attach it to the socket */</span>
<span class="nl">retry:</span>
			<span class="n">filp</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_signo</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sock</span> <span class="o">=</span> <span class="n">netlink_getsockbyfilp</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
			<span class="n">fput</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sock</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
				<span class="n">sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">timeo</span> <span class="o">=</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">netlink_attachskb</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeo</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">nc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">filp</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">mqdes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">mqueue_file_operations</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">MQUEUE_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">u_notification</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span> <span class="o">==</span> <span class="n">task_tgid</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">remove_notification</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">notification</span><span class="p">.</span><span class="n">sigev_notify</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SIGEV_NONE</span>:
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">=</span> <span class="n">SIGEV_NONE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SIGEV_THREAD</span>:
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_sock</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_cookie</span> <span class="o">=</span> <span class="n">nc</span><span class="p">;</span>
			<span class="n">sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">nc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">=</span> <span class="n">SIGEV_THREAD</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SIGEV_SIGNAL</span>:
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">sigev_signo</span> <span class="o">=</span> <span class="n">notification</span><span class="p">.</span><span class="n">sigev_signo</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">sigev_value</span> <span class="o">=</span> <span class="n">notification</span><span class="p">.</span><span class="n">sigev_value</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">=</span> <span class="n">SIGEV_SIGNAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_owner</span> <span class="o">=</span> <span class="n">get_pid</span><span class="p">(</span><span class="n">task_tgid</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">notify_user_ns</span> <span class="o">=</span> <span class="n">get_user_ns</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">());</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">out_fput:</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netlink_detachskb</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">nc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">nc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">mq_getsetattr</span><span class="p">,</span> <span class="n">mqd_t</span><span class="p">,</span> <span class="n">mqdes</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">u_mqstat</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">u_omqstat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">mqstat</span><span class="p">,</span> <span class="n">omqstat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mqueue_inode_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">u_mqstat</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mqstat</span><span class="p">,</span> <span class="n">u_mqstat</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mq_attr</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mqstat</span><span class="p">.</span><span class="n">mq_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">O_NONBLOCK</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">filp</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">mqdes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">mqueue_file_operations</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">MQUEUE_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">omqstat</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">;</span>
	<span class="n">omqstat</span><span class="p">.</span><span class="n">mq_flags</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">u_mqstat</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">audit_mq_getsetattr</span><span class="p">(</span><span class="n">mqdes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqstat</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mqstat</span><span class="p">.</span><span class="n">mq_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">|=</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">O_NONBLOCK</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>

		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">u_omqstat</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">u_omqstat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">omqstat</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mq_attr</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

<span class="nl">out_fput:</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">mqueue_dir_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lookup</span> <span class="o">=</span> <span class="n">simple_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">mqueue_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlink</span> <span class="o">=</span> <span class="n">mqueue_unlink</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">mqueue_file_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">flush</span> <span class="o">=</span> <span class="n">mqueue_flush_file</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span> <span class="n">mqueue_poll_file</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">mqueue_read_file</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">mqueue_super_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">alloc_inode</span> <span class="o">=</span> <span class="n">mqueue_alloc_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy_inode</span> <span class="o">=</span> <span class="n">mqueue_destroy_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">evict_inode</span> <span class="o">=</span> <span class="n">mqueue_evict_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">statfs</span> <span class="o">=</span> <span class="n">simple_statfs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">mqueue_fs_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;mqueue&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mount</span> <span class="o">=</span> <span class="n">mqueue_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kill_sb</span> <span class="o">=</span> <span class="n">kill_litter_super</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">mq_init_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">mq_queues_count</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">mq_queues_max</span>    <span class="o">=</span> <span class="n">DFLT_QUEUESMAX</span><span class="p">;</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">mq_msg_max</span>       <span class="o">=</span> <span class="n">DFLT_MSGMAX</span><span class="p">;</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">mq_msgsize_max</span>   <span class="o">=</span> <span class="n">DFLT_MSGSIZEMAX</span><span class="p">;</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">mq_msg_default</span>   <span class="o">=</span> <span class="n">DFLT_MSG</span><span class="p">;</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">mq_msgsize_default</span>  <span class="o">=</span> <span class="n">DFLT_MSGSIZE</span><span class="p">;</span>

	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span> <span class="o">=</span> <span class="n">kern_mount_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mqueue_fs_type</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="p">);</span>
		<span class="n">ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mq_clear_sbinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="o">-&gt;</span><span class="n">mnt_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mq_put_mnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kern_unmount</span><span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_mqueue_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">mqueue_inode_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;mqueue_inode_cache&quot;</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mqueue_inode_info</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="n">init_once</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mqueue_inode_cachep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* ignore failures - they are not fatal */</span>
	<span class="n">mq_sysctl_table</span> <span class="o">=</span> <span class="n">mq_register_sysctl_table</span><span class="p">();</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mqueue_fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_sysctl</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mq_lock</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">mq_init_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_ipc_ns</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_filesystem</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_filesystem:</span>
	<span class="n">unregister_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mqueue_fs_type</span><span class="p">);</span>
<span class="nl">out_sysctl:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mq_sysctl_table</span><span class="p">)</span>
		<span class="n">unregister_sysctl_table</span><span class="p">(</span><span class="n">mq_sysctl_table</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">mqueue_inode_cachep</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__initcall</span><span class="p">(</span><span class="n">init_mqueue_fs</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
