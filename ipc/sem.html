<!DOCTYPE html>
<html><head><title>joekychen/linux » ipc › sem.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>sem.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/ipc/sem.c</span>
<span class="cm"> * Copyright (C) 1992 Krishna Balasubramanian</span>
<span class="cm"> * Copyright (C) 1995 Eric Schenk, Bruno Haible</span>
<span class="cm"> *</span>
<span class="cm"> * /proc/sysvipc/sem support (c) 1999 Dragos Acostachioaie &lt;dragos@iname.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * SMP-threaded, sysctl&#39;s added</span>
<span class="cm"> * (c) 1999 Manfred Spraul &lt;manfred@colorfullife.com&gt;</span>
<span class="cm"> * Enforced range limit on SEM_UNDO</span>
<span class="cm"> * (c) 2001 Red Hat Inc</span>
<span class="cm"> * Lockless wakeup</span>
<span class="cm"> * (c) 2003 Manfred Spraul &lt;manfred@colorfullife.com&gt;</span>
<span class="cm"> * Further wakeup optimizations, documentation</span>
<span class="cm"> * (c) 2010 Manfred Spraul &lt;manfred@colorfullife.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * support for audit of ipc object properties and permission changes</span>
<span class="cm"> * Dustin Kirkland &lt;dustin.kirkland@us.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * namespaces support</span>
<span class="cm"> * OpenVZ, SWsoft Inc.</span>
<span class="cm"> * Pavel Emelianov &lt;xemul@openvz.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Implementation notes: (May 2010)</span>
<span class="cm"> * This file implements System V semaphores.</span>
<span class="cm"> *</span>
<span class="cm"> * User space visible behavior:</span>
<span class="cm"> * - FIFO ordering for semop() operations (just FIFO, not starvation</span>
<span class="cm"> *   protection)</span>
<span class="cm"> * - multiple semaphore operations that alter the same semaphore in</span>
<span class="cm"> *   one semop() are handled.</span>
<span class="cm"> * - sem_ctime (time of last semctl()) is updated in the IPC_SET, SETVAL and</span>
<span class="cm"> *   SETALL calls.</span>
<span class="cm"> * - two Linux specific semctl() commands: SEM_STAT, SEM_INFO.</span>
<span class="cm"> * - undo adjustments at process exit are limited to 0..SEMVMX.</span>
<span class="cm"> * - namespace are supported.</span>
<span class="cm"> * - SEMMSL, SEMMNS, SEMOPM and SEMMNI can be configured at runtine by writing</span>
<span class="cm"> *   to /proc/sys/kernel/sem.</span>
<span class="cm"> * - statistics about the usage are reported in /proc/sysvipc/sem.</span>
<span class="cm"> *</span>
<span class="cm"> * Internals:</span>
<span class="cm"> * - scalability:</span>
<span class="cm"> *   - all global variables are read-mostly.</span>
<span class="cm"> *   - semop() calls and semctl(RMID) are synchronized by RCU.</span>
<span class="cm"> *   - most operations do write operations (actually: spin_lock calls) to</span>
<span class="cm"> *     the per-semaphore array structure.</span>
<span class="cm"> *   Thus: Perfect SMP scaling between independent semaphore arrays.</span>
<span class="cm"> *         If multiple semaphores in one array are used, then cache line</span>
<span class="cm"> *         trashing on the semaphore array spinlock will limit the scaling.</span>
<span class="cm"> * - semncnt and semzcnt are calculated on demand in count_semncnt() and</span>
<span class="cm"> *   count_semzcnt()</span>
<span class="cm"> * - the task that performs a successful semop() scans the list of all</span>
<span class="cm"> *   sleeping tasks and completes any pending operations that can be fulfilled.</span>
<span class="cm"> *   Semaphores are actively given to waiting tasks (necessary for FIFO).</span>
<span class="cm"> *   (see update_queue())</span>
<span class="cm"> * - To improve the scalability, the actual wake-up calls are performed after</span>
<span class="cm"> *   dropping all locks. (see wake_up_sem_queue_prepare(),</span>
<span class="cm"> *   wake_up_sem_queue_do())</span>
<span class="cm"> * - All work is done by the waker, the woken up task does not have to do</span>
<span class="cm"> *   anything - not even acquiring a lock or dropping a refcount.</span>
<span class="cm"> * - A woken up task may not even touch the semaphore array anymore, it may</span>
<span class="cm"> *   have been destroyed already by a semctl(RMID).</span>
<span class="cm"> * - The synchronizations between wake-ups due to a timeout/signal and a</span>
<span class="cm"> *   wake-up due to a completed semaphore operation is achieved by using an</span>
<span class="cm"> *   intermediate state (IN_WAKEUP).</span>
<span class="cm"> * - UNDO values are stored in an array (one per process and per</span>
<span class="cm"> *   semaphore array, lazily allocated). For backwards compatibility, multiple</span>
<span class="cm"> *   modes for the UNDO variables are supported (per process, per thread)</span>
<span class="cm"> *   (see copy_semundo, CLONE_SYSVSEM)</span>
<span class="cm"> * - There are two lists of the pending operations: a per-array list</span>
<span class="cm"> *   and per-semaphore list (stored in the array). This allows to achieve FIFO</span>
<span class="cm"> *   ordering without always scanning all pending operations.</span>
<span class="cm"> *   The worst-case behavior is nevertheless O(N^2) for N wakeups.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>
<span class="cp">#include &lt;linux/ipc_namespace.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &quot;util.h&quot;</span>

<span class="cm">/* One semaphore structure for each semaphore in the system. */</span>
<span class="k">struct</span> <span class="n">sem</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">semval</span><span class="p">;</span>		<span class="cm">/* current value */</span>
	<span class="kt">int</span>	<span class="n">sempid</span><span class="p">;</span>		<span class="cm">/* pid of last operation */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">sem_pending</span><span class="p">;</span> <span class="cm">/* pending single-sop operations */</span>
<span class="p">};</span>

<span class="cm">/* One queue for each sleeping process in the system. */</span>
<span class="k">struct</span> <span class="n">sem_queue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">simple_list</span><span class="p">;</span> <span class="cm">/* queue of pending operations */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>	 <span class="cm">/* queue of pending operations */</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">sleeper</span><span class="p">;</span> <span class="cm">/* this process */</span>
	<span class="k">struct</span> <span class="n">sem_undo</span>		<span class="o">*</span><span class="n">undo</span><span class="p">;</span>	 <span class="cm">/* undo structure */</span>
	<span class="kt">int</span>			<span class="n">pid</span><span class="p">;</span>	 <span class="cm">/* process id of requesting process */</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>	 <span class="cm">/* completion status of operation */</span>
	<span class="k">struct</span> <span class="n">sembuf</span>		<span class="o">*</span><span class="n">sops</span><span class="p">;</span>	 <span class="cm">/* array of pending operations */</span>
	<span class="kt">int</span>			<span class="n">nsops</span><span class="p">;</span>	 <span class="cm">/* number of operations */</span>
	<span class="kt">int</span>			<span class="n">alter</span><span class="p">;</span>	 <span class="cm">/* does *sops alter the array? */</span>
<span class="p">};</span>

<span class="cm">/* Each task has a list of undo requests. They are executed automatically</span>
<span class="cm"> * when the process exits.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sem_undo</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list_proc</span><span class="p">;</span>	<span class="cm">/* per-process list: *</span>
<span class="cm">						 * all undos from one process</span>
<span class="cm">						 * rcu protected */</span>
	<span class="k">struct</span> <span class="n">rcu_head</span>		<span class="n">rcu</span><span class="p">;</span>		<span class="cm">/* rcu struct for sem_undo */</span>
	<span class="k">struct</span> <span class="n">sem_undo_list</span>	<span class="o">*</span><span class="n">ulp</span><span class="p">;</span>		<span class="cm">/* back ptr to sem_undo_list */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list_id</span><span class="p">;</span>	<span class="cm">/* per semaphore array list:</span>
<span class="cm">						 * all undos for one array */</span>
	<span class="kt">int</span>			<span class="n">semid</span><span class="p">;</span>		<span class="cm">/* semaphore set identifier */</span>
	<span class="kt">short</span>			<span class="o">*</span><span class="n">semadj</span><span class="p">;</span>	<span class="cm">/* array of adjustments */</span>
						<span class="cm">/* one per semaphore */</span>
<span class="p">};</span>

<span class="cm">/* sem_undo_list controls shared access to the list of sem_undo structures</span>
<span class="cm"> * that may be shared among all a CLONE_SYSVSEM task group.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sem_undo_list</span> <span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">refcnt</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list_proc</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp">#define sem_ids(ns)	((ns)-&gt;ids[IPC_SEM_IDS])</span>

<span class="cp">#define sem_unlock(sma)		ipc_unlock(&amp;(sma)-&gt;sem_perm)</span>
<span class="cp">#define sem_checkid(sma, semid)	ipc_checkid(&amp;sma-&gt;sem_perm, semid)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">newary</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ipc_params</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">freeary</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sysvipc_sem_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#define SEMMSL_FAST	256 </span><span class="cm">/* 512 bytes on stack */</span><span class="cp"></span>
<span class="cp">#define SEMOPM_FAST	64  </span><span class="cm">/* ~ 372 bytes on stack */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * linked list protection:</span>
<span class="cm"> *	sem_undo.id_next,</span>
<span class="cm"> *	sem_array.sem_pending{,last},</span>
<span class="cm"> *	sem_array.sem_undo: sem_lock() for read/write</span>
<span class="cm"> *	sem_undo.proc_next: only &quot;current&quot; is allowed to read/write that field.</span>
<span class="cm"> *	</span>
<span class="cm"> */</span>

<span class="cp">#define sc_semmsl	sem_ctls[0]</span>
<span class="cp">#define sc_semmns	sem_ctls[1]</span>
<span class="cp">#define sc_semopm	sem_ctls[2]</span>
<span class="cp">#define sc_semmni	sem_ctls[3]</span>

<span class="kt">void</span> <span class="nf">sem_init_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">sc_semmsl</span> <span class="o">=</span> <span class="n">SEMMSL</span><span class="p">;</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">sc_semmns</span> <span class="o">=</span> <span class="n">SEMMNS</span><span class="p">;</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">sc_semopm</span> <span class="o">=</span> <span class="n">SEMOPM</span><span class="p">;</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">sc_semmni</span> <span class="o">=</span> <span class="n">SEMMNI</span><span class="p">;</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">used_sems</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ipc_init_ids</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">ids</span><span class="p">[</span><span class="n">IPC_SEM_IDS</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IPC_NS</span>
<span class="kt">void</span> <span class="nf">sem_exit_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_ipcs</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sem_ids</span><span class="p">(</span><span class="n">ns</span><span class="p">),</span> <span class="n">freeary</span><span class="p">);</span>
	<span class="n">idr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">ids</span><span class="p">[</span><span class="n">IPC_SEM_IDS</span><span class="p">].</span><span class="n">ipcs_idr</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">sem_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sem_init_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_ipc_ns</span><span class="p">);</span>
	<span class="n">ipc_init_proc_interface</span><span class="p">(</span><span class="s">&quot;sysvipc/sem&quot;</span><span class="p">,</span>
				<span class="s">&quot;       key      semid perms      nsems   uid   gid  cuid  cgid      otime      ctime</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">IPC_SEM_IDS</span><span class="p">,</span> <span class="n">sysvipc_sem_proc_show</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sem_lock_(check_) routines are called in the paths where the rw_mutex</span>
<span class="cm"> * is not held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="nf">sem_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipcp</span> <span class="o">=</span> <span class="n">ipc_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem_ids</span><span class="p">(</span><span class="n">ns</span><span class="p">),</span> <span class="n">id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ipcp</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="p">)</span><span class="n">ipcp</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ipcp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sem_array</span><span class="p">,</span> <span class="n">sem_perm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="nf">sem_lock_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipcp</span> <span class="o">=</span> <span class="n">ipc_lock_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem_ids</span><span class="p">(</span><span class="n">ns</span><span class="p">),</span> <span class="n">id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ipcp</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="p">)</span><span class="n">ipcp</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ipcp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sem_array</span><span class="p">,</span> <span class="n">sem_perm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sem_lock_and_putref</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ipc_lock_by_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">);</span>
	<span class="n">ipc_rcu_putref</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sem_getref_and_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ipc_rcu_getref</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
	<span class="n">ipc_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sma</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sem_putref</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ipc_lock_by_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">);</span>
	<span class="n">ipc_rcu_putref</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
	<span class="n">ipc_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sma</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sem_rmid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ipc_rmid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem_ids</span><span class="p">(</span><span class="n">ns</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Lockless wakeup algorithm:</span>
<span class="cm"> * Without the check/retry algorithm a lockless wakeup is possible:</span>
<span class="cm"> * - queue.status is initialized to -EINTR before blocking.</span>
<span class="cm"> * - wakeup is performed by</span>
<span class="cm"> *	* unlinking the queue entry from sma-&gt;sem_pending</span>
<span class="cm"> *	* setting queue.status to IN_WAKEUP</span>
<span class="cm"> *	  This is the notification for the blocked thread that a</span>
<span class="cm"> *	  result value is imminent.</span>
<span class="cm"> *	* call wake_up_process</span>
<span class="cm"> *	* set queue.status to the final value.</span>
<span class="cm"> * - the previously blocked thread checks queue.status:</span>
<span class="cm"> *   	* if it&#39;s IN_WAKEUP, then it must wait until the value changes</span>
<span class="cm"> *   	* if it&#39;s not -EINTR, then the operation was completed by</span>
<span class="cm"> *   	  update_queue. semtimedop can return queue.status without</span>
<span class="cm"> *   	  performing any operation on the sem array.</span>
<span class="cm"> *   	* otherwise it must acquire the spinlock and check what&#39;s up.</span>
<span class="cm"> *</span>
<span class="cm"> * The two-stage algorithm is necessary to protect against the following</span>
<span class="cm"> * races:</span>
<span class="cm"> * - if queue.status is set after wake_up_process, then the woken up idle</span>
<span class="cm"> *   thread could race forward and try (and fail) to acquire sma-&gt;lock</span>
<span class="cm"> *   before update_queue had a chance to set queue.status</span>
<span class="cm"> * - if queue.status is written before wake_up_process and if the</span>
<span class="cm"> *   blocked process is woken up by a signal between writing</span>
<span class="cm"> *   queue.status and the wake_up_process, then the woken up</span>
<span class="cm"> *   process could return from semtimedop and die by calling</span>
<span class="cm"> *   sys_exit before wake_up_process is called. Then wake_up_process</span>
<span class="cm"> *   will oops, because the task structure is already invalid.</span>
<span class="cm"> *   (yes, this happened on s390 with sysv msg).</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define IN_WAKEUP	1</span>

<span class="cm">/**</span>
<span class="cm"> * newary - Create a new semaphore set</span>
<span class="cm"> * @ns: namespace</span>
<span class="cm"> * @params: ptr to the structure that contains key, semflg and nsems</span>
<span class="cm"> *</span>
<span class="cm"> * Called with sem_ids.rw_mutex held (as a writer)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">newary</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ipc_params</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">key_t</span> <span class="n">key</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nsems</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">nsems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">semflg</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">flg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nsems</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">used_sems</span> <span class="o">+</span> <span class="n">nsems</span> <span class="o">&gt;</span> <span class="n">ns</span><span class="o">-&gt;</span><span class="n">sc_semmns</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="o">*</span><span class="n">sma</span><span class="p">)</span> <span class="o">+</span> <span class="n">nsems</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sem</span><span class="p">);</span>
	<span class="n">sma</span> <span class="o">=</span> <span class="n">ipc_rcu_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span> <span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">semflg</span> <span class="o">&amp;</span> <span class="n">S_IRWXUGO</span><span class="p">);</span>
	<span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>

	<span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">security</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_sem_alloc</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ipc_rcu_putref</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">id</span> <span class="o">=</span> <span class="n">ipc_addid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem_ids</span><span class="p">(</span><span class="n">ns</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">,</span> <span class="n">ns</span><span class="o">-&gt;</span><span class="n">sc_semmni</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">security_sem_free</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
		<span class="n">ipc_rcu_putref</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">used_sems</span> <span class="o">+=</span> <span class="n">nsems</span><span class="p">;</span>

	<span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_base</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sem</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">sma</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nsems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_base</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sem_pending</span><span class="p">);</span>

	<span class="n">sma</span><span class="o">-&gt;</span><span class="n">complex_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_pending</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">list_id</span><span class="p">);</span>
	<span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_nsems</span> <span class="o">=</span> <span class="n">nsems</span><span class="p">;</span>
	<span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_ctime</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
	<span class="n">sem_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Called with sem_ids.rw_mutex and ipcp locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sem_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">;</span>

	<span class="n">sma</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ipcp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sem_array</span><span class="p">,</span> <span class="n">sem_perm</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">security_sem_associate</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="n">semflg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called with sem_ids.rw_mutex and ipcp locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sem_more_checks</span><span class="p">(</span><span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipcp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ipc_params</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">;</span>

	<span class="n">sma</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ipcp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sem_array</span><span class="p">,</span> <span class="n">sem_perm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">nsems</span> <span class="o">&gt;</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_nsems</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">semget</span><span class="p">,</span> <span class="n">key_t</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">nsems</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">semflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipc_ops</span> <span class="n">sem_ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipc_params</span> <span class="n">sem_params</span><span class="p">;</span>

	<span class="n">ns</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">ipc_ns</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nsems</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nsems</span> <span class="o">&gt;</span> <span class="n">ns</span><span class="o">-&gt;</span><span class="n">sc_semmsl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">sem_ops</span><span class="p">.</span><span class="n">getnew</span> <span class="o">=</span> <span class="n">newary</span><span class="p">;</span>
	<span class="n">sem_ops</span><span class="p">.</span><span class="n">associate</span> <span class="o">=</span> <span class="n">sem_security</span><span class="p">;</span>
	<span class="n">sem_ops</span><span class="p">.</span><span class="n">more_checks</span> <span class="o">=</span> <span class="n">sem_more_checks</span><span class="p">;</span>

	<span class="n">sem_params</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">sem_params</span><span class="p">.</span><span class="n">flg</span> <span class="o">=</span> <span class="n">semflg</span><span class="p">;</span>
	<span class="n">sem_params</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">nsems</span> <span class="o">=</span> <span class="n">nsems</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ipcget</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sem_ids</span><span class="p">(</span><span class="n">ns</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">sem_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sem_params</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine whether a sequence of semaphore operations would succeed</span>
<span class="cm"> * all at once. Return 0 if yes, 1 if need to sleep, else return error code.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">try_atomic_semop</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span> <span class="n">sma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span> <span class="n">sops</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">nsops</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sem_undo</span> <span class="o">*</span><span class="n">un</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">sem_op</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span><span class="n">sop</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sem</span> <span class="o">*</span> <span class="n">curr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">sop</span> <span class="o">=</span> <span class="n">sops</span><span class="p">;</span> <span class="n">sop</span> <span class="o">&lt;</span> <span class="n">sops</span> <span class="o">+</span> <span class="n">nsops</span><span class="p">;</span> <span class="n">sop</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_base</span> <span class="o">+</span> <span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_num</span><span class="p">;</span>
		<span class="n">sem_op</span> <span class="o">=</span> <span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_op</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">semval</span><span class="p">;</span>
  
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sem_op</span> <span class="o">&amp;&amp;</span> <span class="n">result</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">would_block</span><span class="p">;</span>

		<span class="n">result</span> <span class="o">+=</span> <span class="n">sem_op</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">would_block</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="n">SEMVMX</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_of_range</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_flg</span> <span class="o">&amp;</span> <span class="n">SEM_UNDO</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">undo</span> <span class="o">=</span> <span class="n">un</span><span class="o">-&gt;</span><span class="n">semadj</span><span class="p">[</span><span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_num</span><span class="p">]</span> <span class="o">-</span> <span class="n">sem_op</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">	 		 *	Exceeding the undo range is an error.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">undo</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">-</span><span class="n">SEMAEM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="n">undo</span> <span class="o">&gt;</span> <span class="n">SEMAEM</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_of_range</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">semval</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sop</span><span class="o">--</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sop</span> <span class="o">&gt;=</span> <span class="n">sops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_base</span><span class="p">[</span><span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_num</span><span class="p">].</span><span class="n">sempid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_flg</span> <span class="o">&amp;</span> <span class="n">SEM_UNDO</span><span class="p">)</span>
			<span class="n">un</span><span class="o">-&gt;</span><span class="n">semadj</span><span class="p">[</span><span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_num</span><span class="p">]</span> <span class="o">-=</span> <span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_op</span><span class="p">;</span>
		<span class="n">sop</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_of_range:</span>
	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">undo</span><span class="p">;</span>

<span class="nl">would_block:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_flg</span> <span class="o">&amp;</span> <span class="n">IPC_NOWAIT</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">undo:</span>
	<span class="n">sop</span><span class="o">--</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sop</span> <span class="o">&gt;=</span> <span class="n">sops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_base</span><span class="p">[</span><span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_num</span><span class="p">].</span><span class="n">semval</span> <span class="o">-=</span> <span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_op</span><span class="p">;</span>
		<span class="n">sop</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** wake_up_sem_queue_prepare(q, error): Prepare wake-up</span>
<span class="cm"> * @q: queue entry that must be signaled</span>
<span class="cm"> * @error: Error value for the signal</span>
<span class="cm"> *</span>
<span class="cm"> * Prepare the wake-up of the queue entry q.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">wake_up_sem_queue_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sem_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">pt</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Hold preempt off so that we don&#39;t get preempted and have the</span>
<span class="cm">		 * wakee busy-wait until we&#39;re scheduled back on.</span>
<span class="cm">		 */</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">IN_WAKEUP</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">simple_list</span><span class="p">,</span> <span class="n">pt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wake_up_sem_queue_do(pt) - do the actual wake-up</span>
<span class="cm"> * @pt: list of tasks to be woken up</span>
<span class="cm"> *</span>
<span class="cm"> * Do the actual wake-up.</span>
<span class="cm"> * The function is called without any locks held, thus the semaphore array</span>
<span class="cm"> * could be destroyed already and the tasks can disappear as soon as the</span>
<span class="cm"> * status is set to the actual return code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">wake_up_sem_queue_do</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sem_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">did_something</span><span class="p">;</span>

	<span class="n">did_something</span> <span class="o">=</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">simple_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sleeper</span><span class="p">);</span>
		<span class="cm">/* q can disappear immediately after writing q-&gt;status. */</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">did_something</span><span class="p">)</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">unlink_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sem_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">nsops</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">simple_list</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sma</span><span class="o">-&gt;</span><span class="n">complex_count</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** check_restart(sma, q)</span>
<span class="cm"> * @sma: semaphore array</span>
<span class="cm"> * @q: the operation that just completed</span>
<span class="cm"> *</span>
<span class="cm"> * update_queue is O(N^2) when it restarts scanning the whole queue of</span>
<span class="cm"> * waiting operations. Therefore this function checks if the restart is</span>
<span class="cm"> * really necessary. It is called after a previously waiting operation</span>
<span class="cm"> * was completed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">check_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sem_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sem</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sem_queue</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>

	<span class="cm">/* if the operation didn&#39;t modify the array, then no restart */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">alter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* pending complex operations are too difficult to analyse */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">complex_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* we were a sleeping complex operation. Too difficult */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">nsops</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">curr</span> <span class="o">=</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_base</span> <span class="o">+</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sops</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sem_num</span><span class="p">;</span>

	<span class="cm">/* No-one waits on this queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sem_pending</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* the new semaphore value */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">semval</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* It is impossible that someone waits for the new value:</span>
<span class="cm">		 * - q is a previously sleeping simple operation that</span>
<span class="cm">		 *   altered the array. It must be a decrement, because</span>
<span class="cm">		 *   simple increments never sleep.</span>
<span class="cm">		 * - The value is not 0, thus wait-for-zero won&#39;t proceed.</span>
<span class="cm">		 * - If there are older (higher priority) decrements</span>
<span class="cm">		 *   in the queue, then they have observed the original</span>
<span class="cm">		 *   semval value and couldn&#39;t proceed. The operation</span>
<span class="cm">		 *   decremented to value - thus they won&#39;t proceed either.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sops</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sem_op</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * semval is 0. Check if there are wait-for-zero semops.</span>
<span class="cm">	 * They must be the first entries in the per-semaphore simple queue</span>
<span class="cm">	 */</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sem_pending</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sem_queue</span><span class="p">,</span> <span class="n">simple_list</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">nsops</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">sops</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sem_num</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sops</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sem_num</span><span class="p">);</span>

	<span class="cm">/* Yes, there is a wait-for-zero semop. Restart */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">sops</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sem_op</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Again - no-one is waiting for the new value. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * update_queue(sma, semnum): Look for tasks that can be completed.</span>
<span class="cm"> * @sma: semaphore array.</span>
<span class="cm"> * @semnum: semaphore that was modified.</span>
<span class="cm"> * @pt: list head for the tasks that must be woken up.</span>
<span class="cm"> *</span>
<span class="cm"> * update_queue must be called after a semaphore in a semaphore array</span>
<span class="cm"> * was modified. If multiple semaphore were modified, then @semnum</span>
<span class="cm"> * must be set to -1.</span>
<span class="cm"> * The tasks that must be woken up are added to @pt. The return code</span>
<span class="cm"> * is stored in q-&gt;pid.</span>
<span class="cm"> * The function return 1 if at least one semop was completed successfully.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">update_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semnum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sem_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">walk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pending_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">semop_completed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* if there are complex operations around, then knowing the semaphore</span>
<span class="cm">	 * that was modified doesn&#39;t help us. Assume that multiple semaphores</span>
<span class="cm">	 * were modified.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">complex_count</span><span class="p">)</span>
		<span class="n">semnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">semnum</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pending_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_pending</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_queue</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pending_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_base</span><span class="p">[</span><span class="n">semnum</span><span class="p">].</span><span class="n">sem_pending</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_queue</span><span class="p">,</span> <span class="n">simple_list</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">again:</span>
	<span class="n">walk</span> <span class="o">=</span> <span class="n">pending_list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">walk</span> <span class="o">!=</span> <span class="n">pending_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">restart</span><span class="p">;</span>

		<span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sem_queue</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">walk</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">walk</span> <span class="o">=</span> <span class="n">walk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="cm">/* If we are scanning the single sop, per-semaphore list of</span>
<span class="cm">		 * one semaphore and that semaphore is 0, then it is not</span>
<span class="cm">		 * necessary to scan the &quot;alter&quot; entries: simple increments</span>
<span class="cm">		 * that affect only one entry succeed immediately and cannot</span>
<span class="cm">		 * be in the  per semaphore pending queue, and decrements</span>
<span class="cm">		 * cannot be successful if the value is already 0.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">semnum</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_base</span><span class="p">[</span><span class="n">semnum</span><span class="p">].</span><span class="n">semval</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">alter</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">try_atomic_semop</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sops</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">nsops</span><span class="p">,</span>
					 <span class="n">q</span><span class="o">-&gt;</span><span class="n">undo</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

		<span class="cm">/* Does q-&gt;sleeper still need to sleep? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">unlink_queue</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">restart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">semop_completed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">restart</span> <span class="o">=</span> <span class="n">check_restart</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">wake_up_sem_queue_prepare</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">restart</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">semop_completed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_smart_update(sma, sops, nsops, otime, pt) - optimized update_queue</span>
<span class="cm"> * @sma: semaphore array</span>
<span class="cm"> * @sops: operations that were performed</span>
<span class="cm"> * @nsops: number of operations</span>
<span class="cm"> * @otime: force setting otime</span>
<span class="cm"> * @pt: list head of the tasks that must be woken up.</span>
<span class="cm"> *</span>
<span class="cm"> * do_smart_update() does the required called to update_queue, based on the</span>
<span class="cm"> * actual changes that were performed on the semaphore array.</span>
<span class="cm"> * Note that the function does not do the actual wake-up: the caller is</span>
<span class="cm"> * responsible for calling wake_up_sem_queue_do(@pt).</span>
<span class="cm"> * It is safe to perform this call after dropping all locks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">do_smart_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span><span class="n">sops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nsops</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">otime</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">complex_count</span> <span class="o">||</span> <span class="n">sops</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">update_queue</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">pt</span><span class="p">))</span>
			<span class="n">otime</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nsops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sem_op</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">sops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sem_op</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				<span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_base</span><span class="p">[</span><span class="n">sops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sem_num</span><span class="p">].</span><span class="n">semval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">update_queue</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="n">sops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sem_num</span><span class="p">,</span> <span class="n">pt</span><span class="p">))</span>
				<span class="n">otime</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">otime</span><span class="p">)</span>
		<span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_otime</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
<span class="p">}</span>


<span class="cm">/* The following counts are associated to each semaphore:</span>
<span class="cm"> *   semncnt        number of tasks waiting on semval being nonzero</span>
<span class="cm"> *   semzcnt        number of tasks waiting on semval being zero</span>
<span class="cm"> * This model assumes that a task waits on exactly one semaphore.</span>
<span class="cm"> * Since semaphore operations are to be performed atomically, tasks actually</span>
<span class="cm"> * wait on a whole sequence of semaphores simultaneously.</span>
<span class="cm"> * The counts we return here are a rough approximation, but still</span>
<span class="cm"> * warrant that semncnt+semzcnt&gt;0 if the task is on the pending queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">count_semncnt</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span> <span class="n">sma</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">semnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">semncnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sem_queue</span> <span class="o">*</span> <span class="n">q</span><span class="p">;</span>

	<span class="n">semncnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_pending</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span> <span class="n">sops</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sops</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nsops</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">nsops</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nsops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sem_num</span> <span class="o">==</span> <span class="n">semnum</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sem_op</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">sops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sem_flg</span> <span class="o">&amp;</span> <span class="n">IPC_NOWAIT</span><span class="p">))</span>
				<span class="n">semncnt</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">semncnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">count_semzcnt</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span> <span class="n">sma</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">semnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">semzcnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sem_queue</span> <span class="o">*</span> <span class="n">q</span><span class="p">;</span>

	<span class="n">semzcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_pending</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span> <span class="n">sops</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">sops</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nsops</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">nsops</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nsops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sem_num</span> <span class="o">==</span> <span class="n">semnum</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sem_op</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">sops</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sem_flg</span> <span class="o">&amp;</span> <span class="n">IPC_NOWAIT</span><span class="p">))</span>
				<span class="n">semzcnt</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">semzcnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free a semaphore set. freeary() is called with sem_ids.rw_mutex locked</span>
<span class="cm"> * as a writer and the spinlock for this semaphore set hold. sem_ids.rw_mutex</span>
<span class="cm"> * remains locked on exit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">freeary</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sem_undo</span> <span class="o">*</span><span class="n">un</span><span class="p">,</span> <span class="o">*</span><span class="n">tu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sem_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">tq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ipcp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sem_array</span><span class="p">,</span> <span class="n">sem_perm</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tasks</span><span class="p">;</span>

	<span class="cm">/* Free the existing undo structures for this semaphore set.  */</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">un</span><span class="p">,</span> <span class="n">tu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">list_id</span><span class="p">,</span> <span class="n">list_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">list_id</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">ulp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">un</span><span class="o">-&gt;</span><span class="n">semid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">list_proc</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">ulp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">un</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Wake up all pending processes and let them fail with EIDRM. */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasks</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_pending</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlink_queue</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="n">wake_up_sem_queue_prepare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasks</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Remove the semaphore set from the IDR */</span>
	<span class="n">sem_rmid</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">sma</span><span class="p">);</span>
	<span class="n">sem_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>

	<span class="n">wake_up_sem_queue_do</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasks</span><span class="p">);</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">used_sems</span> <span class="o">-=</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_nsems</span><span class="p">;</span>
	<span class="n">security_sem_free</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
	<span class="n">ipc_rcu_putref</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">copy_semid_to_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">semid64_ds</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">int</span> <span class="n">version</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">version</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPC_64</span>:
		<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">));</span>
	<span class="k">case</span> <span class="n">IPC_OLD</span>:
	    <span class="p">{</span>
		<span class="k">struct</span> <span class="n">semid_ds</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">));</span>

		<span class="n">ipc64_perm_to_ipc_perm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">.</span><span class="n">sem_perm</span><span class="p">);</span>

		<span class="n">out</span><span class="p">.</span><span class="n">sem_otime</span>	<span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">sem_otime</span><span class="p">;</span>
		<span class="n">out</span><span class="p">.</span><span class="n">sem_ctime</span>	<span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">sem_ctime</span><span class="p">;</span>
		<span class="n">out</span><span class="p">.</span><span class="n">sem_nsems</span>	<span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">sem_nsems</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">));</span>
	    <span class="p">}</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">semctl_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semid</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">version</span><span class="p">,</span> <span class="k">union</span> <span class="n">semun</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPC_INFO</span>:
	<span class="k">case</span> <span class="n">SEM_INFO</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">seminfo</span> <span class="n">seminfo</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">max_id</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">security_sem_semctl</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seminfo</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">seminfo</span><span class="p">));</span>
		<span class="n">seminfo</span><span class="p">.</span><span class="n">semmni</span> <span class="o">=</span> <span class="n">ns</span><span class="o">-&gt;</span><span class="n">sc_semmni</span><span class="p">;</span>
		<span class="n">seminfo</span><span class="p">.</span><span class="n">semmns</span> <span class="o">=</span> <span class="n">ns</span><span class="o">-&gt;</span><span class="n">sc_semmns</span><span class="p">;</span>
		<span class="n">seminfo</span><span class="p">.</span><span class="n">semmsl</span> <span class="o">=</span> <span class="n">ns</span><span class="o">-&gt;</span><span class="n">sc_semmsl</span><span class="p">;</span>
		<span class="n">seminfo</span><span class="p">.</span><span class="n">semopm</span> <span class="o">=</span> <span class="n">ns</span><span class="o">-&gt;</span><span class="n">sc_semopm</span><span class="p">;</span>
		<span class="n">seminfo</span><span class="p">.</span><span class="n">semvmx</span> <span class="o">=</span> <span class="n">SEMVMX</span><span class="p">;</span>
		<span class="n">seminfo</span><span class="p">.</span><span class="n">semmnu</span> <span class="o">=</span> <span class="n">SEMMNU</span><span class="p">;</span>
		<span class="n">seminfo</span><span class="p">.</span><span class="n">semmap</span> <span class="o">=</span> <span class="n">SEMMAP</span><span class="p">;</span>
		<span class="n">seminfo</span><span class="p">.</span><span class="n">semume</span> <span class="o">=</span> <span class="n">SEMUME</span><span class="p">;</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem_ids</span><span class="p">(</span><span class="n">ns</span><span class="p">).</span><span class="n">rw_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">SEM_INFO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seminfo</span><span class="p">.</span><span class="n">semusz</span> <span class="o">=</span> <span class="n">sem_ids</span><span class="p">(</span><span class="n">ns</span><span class="p">).</span><span class="n">in_use</span><span class="p">;</span>
			<span class="n">seminfo</span><span class="p">.</span><span class="n">semaem</span> <span class="o">=</span> <span class="n">ns</span><span class="o">-&gt;</span><span class="n">used_sems</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">seminfo</span><span class="p">.</span><span class="n">semusz</span> <span class="o">=</span> <span class="n">SEMUSZ</span><span class="p">;</span>
			<span class="n">seminfo</span><span class="p">.</span><span class="n">semaem</span> <span class="o">=</span> <span class="n">SEMAEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">max_id</span> <span class="o">=</span> <span class="n">ipc_get_maxid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem_ids</span><span class="p">(</span><span class="n">ns</span><span class="p">));</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem_ids</span><span class="p">(</span><span class="n">ns</span><span class="p">).</span><span class="n">rw_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span> <span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">__buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seminfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">seminfo</span><span class="p">)))</span> 
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">max_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span> <span class="n">max_id</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">IPC_STAT</span>:
	<span class="k">case</span> <span class="n">SEM_STAT</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">semid64_ds</span> <span class="n">tbuf</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">SEM_STAT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sma</span> <span class="o">=</span> <span class="n">sem_lock</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">semid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sma</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
			<span class="n">id</span> <span class="o">=</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sma</span> <span class="o">=</span> <span class="n">sem_lock_check</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">semid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sma</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
			<span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ipcperms</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">security_sem_semctl</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tbuf</span><span class="p">));</span>

		<span class="n">kernel_to_ipc64_perm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tbuf</span><span class="p">.</span><span class="n">sem_perm</span><span class="p">);</span>
		<span class="n">tbuf</span><span class="p">.</span><span class="n">sem_otime</span>  <span class="o">=</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_otime</span><span class="p">;</span>
		<span class="n">tbuf</span><span class="p">.</span><span class="n">sem_ctime</span>  <span class="o">=</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_ctime</span><span class="p">;</span>
		<span class="n">tbuf</span><span class="p">.</span><span class="n">sem_nsems</span>  <span class="o">=</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_nsems</span><span class="p">;</span>
		<span class="n">sem_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_semid_to_user</span> <span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tbuf</span><span class="p">,</span> <span class="n">version</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">sem_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">semctl_main</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semnum</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">version</span><span class="p">,</span> <span class="k">union</span> <span class="n">semun</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sem</span><span class="o">*</span> <span class="n">curr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">ushort</span> <span class="n">fast_sem_io</span><span class="p">[</span><span class="n">SEMMSL_FAST</span><span class="p">];</span>
	<span class="n">ushort</span><span class="o">*</span> <span class="n">sem_io</span> <span class="o">=</span> <span class="n">fast_sem_io</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nsems</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tasks</span><span class="p">;</span>

	<span class="n">sma</span> <span class="o">=</span> <span class="n">sem_lock_check</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">semid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sma</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasks</span><span class="p">);</span>
	<span class="n">nsems</span> <span class="o">=</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_nsems</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipcperms</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">,</span>
			<span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">SETVAL</span> <span class="o">||</span> <span class="n">cmd</span> <span class="o">==</span> <span class="n">SETALL</span><span class="p">)</span> <span class="o">?</span> <span class="n">S_IWUGO</span> <span class="o">:</span> <span class="n">S_IRUGO</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">security_sem_semctl</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GETALL</span>:
	<span class="p">{</span>
		<span class="n">ushort</span> <span class="n">__user</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="n">arg</span><span class="p">.</span><span class="n">array</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span><span class="n">nsems</span> <span class="o">&gt;</span> <span class="n">SEMMSL_FAST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sem_getref_and_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>

			<span class="n">sem_io</span> <span class="o">=</span> <span class="n">ipc_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="o">*</span><span class="n">nsems</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">sem_io</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sem_putref</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">sem_lock_and_putref</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">deleted</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sem_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_nsems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">sem_io</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_base</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">semval</span><span class="p">;</span>
		<span class="n">sem_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">sem_io</span><span class="p">,</span> <span class="n">nsems</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ushort</span><span class="p">)))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">SETALL</span>:
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sem_undo</span> <span class="o">*</span><span class="n">un</span><span class="p">;</span>

		<span class="n">sem_getref_and_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="n">nsems</span> <span class="o">&gt;</span> <span class="n">SEMMSL_FAST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sem_io</span> <span class="o">=</span> <span class="n">ipc_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="o">*</span><span class="n">nsems</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">sem_io</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sem_putref</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span> <span class="p">(</span><span class="n">sem_io</span><span class="p">,</span> <span class="n">arg</span><span class="p">.</span><span class="n">array</span><span class="p">,</span> <span class="n">nsems</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ushort</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">sem_putref</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nsems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sem_io</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">SEMVMX</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sem_putref</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">sem_lock_and_putref</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">deleted</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sem_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nsems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_base</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">semval</span> <span class="o">=</span> <span class="n">sem_io</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">un</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">list_id</span><span class="p">,</span> <span class="n">list_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nsems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">un</span><span class="o">-&gt;</span><span class="n">semadj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_ctime</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
		<span class="cm">/* maybe some queued-up processes were waiting for this */</span>
		<span class="n">do_smart_update</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tasks</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* GETVAL, GETPID, GETNCTN, GETZCNT, SETVAL: fall-through */</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">semnum</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">semnum</span> <span class="o">&gt;=</span> <span class="n">nsems</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">curr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_base</span><span class="p">[</span><span class="n">semnum</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GETVAL</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">semval</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GETPID</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">sempid</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GETNCNT</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">count_semncnt</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span><span class="n">semnum</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GETZCNT</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">count_semzcnt</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span><span class="n">semnum</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SETVAL</span>:
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">arg</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sem_undo</span> <span class="o">*</span><span class="n">un</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">SEMVMX</span> <span class="o">||</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

		<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">un</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">list_id</span><span class="p">,</span> <span class="n">list_id</span><span class="p">)</span>
			<span class="n">un</span><span class="o">-&gt;</span><span class="n">semadj</span><span class="p">[</span><span class="n">semnum</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">semval</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">sempid</span> <span class="o">=</span> <span class="n">task_tgid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_ctime</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
		<span class="cm">/* maybe some queued-up processes were waiting for this */</span>
		<span class="n">do_smart_update</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tasks</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">sem_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
	<span class="n">wake_up_sem_queue_do</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasks</span><span class="p">);</span>

<span class="nl">out_free:</span>
	<span class="k">if</span><span class="p">(</span><span class="n">sem_io</span> <span class="o">!=</span> <span class="n">fast_sem_io</span><span class="p">)</span>
		<span class="n">ipc_free</span><span class="p">(</span><span class="n">sem_io</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ushort</span><span class="p">)</span><span class="o">*</span><span class="n">nsems</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="n">copy_semid_from_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">semid64_ds</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">version</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">version</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPC_64</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">out</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPC_OLD</span>:
	    <span class="p">{</span>
		<span class="k">struct</span> <span class="n">semid_ds</span> <span class="n">tbuf_old</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tbuf_old</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tbuf_old</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">out</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">uid</span>	<span class="o">=</span> <span class="n">tbuf_old</span><span class="p">.</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">uid</span><span class="p">;</span>
		<span class="n">out</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">gid</span>	<span class="o">=</span> <span class="n">tbuf_old</span><span class="p">.</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">gid</span><span class="p">;</span>
		<span class="n">out</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">mode</span>	<span class="o">=</span> <span class="n">tbuf_old</span><span class="p">.</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">mode</span><span class="p">;</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	    <span class="p">}</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function handles some semctl commands which require the rw_mutex</span>
<span class="cm"> * to be held in write mode.</span>
<span class="cm"> * NOTE: no locks must be held, the rw_mutex is taken inside this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">semctl_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semid</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">version</span><span class="p">,</span> <span class="k">union</span> <span class="n">semun</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">semid64_ds</span> <span class="n">semid64</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipcp</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">IPC_SET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_semid_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">semid64</span><span class="p">,</span> <span class="n">arg</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">version</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ipcp</span> <span class="o">=</span> <span class="n">ipcctl_pre_down</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sem_ids</span><span class="p">(</span><span class="n">ns</span><span class="p">),</span> <span class="n">semid</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">semid64</span><span class="p">.</span><span class="n">sem_perm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ipcp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ipcp</span><span class="p">);</span>

	<span class="n">sma</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ipcp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sem_array</span><span class="p">,</span> <span class="n">sem_perm</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">security_sem_semctl</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">){</span>
	<span class="k">case</span> <span class="n">IPC_RMID</span>:
		<span class="n">freeary</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">ipcp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_up</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPC_SET</span>:
		<span class="n">ipc_update_perm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">semid64</span><span class="p">.</span><span class="n">sem_perm</span><span class="p">,</span> <span class="n">ipcp</span><span class="p">);</span>
		<span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_ctime</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">sem_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
<span class="nl">out_up:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem_ids</span><span class="p">(</span><span class="n">ns</span><span class="p">).</span><span class="n">rw_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE</span><span class="p">(</span><span class="n">semctl</span><span class="p">)(</span><span class="kt">int</span> <span class="n">semid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">union</span> <span class="n">semun</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">version</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">semid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">version</span> <span class="o">=</span> <span class="n">ipc_parse_version</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">ns</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">ipc_ns</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPC_INFO</span>:
	<span class="k">case</span> <span class="n">SEM_INFO</span>:
	<span class="k">case</span> <span class="n">IPC_STAT</span>:
	<span class="k">case</span> <span class="n">SEM_STAT</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">semctl_nolock</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">semid</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GETALL</span>:
	<span class="k">case</span> <span class="n">GETVAL</span>:
	<span class="k">case</span> <span class="n">GETPID</span>:
	<span class="k">case</span> <span class="n">GETNCNT</span>:
	<span class="k">case</span> <span class="n">GETZCNT</span>:
	<span class="k">case</span> <span class="n">SETVAL</span>:
	<span class="k">case</span> <span class="n">SETALL</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">semctl_main</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span><span class="n">semid</span><span class="p">,</span><span class="n">semnum</span><span class="p">,</span><span class="n">cmd</span><span class="p">,</span><span class="n">version</span><span class="p">,</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IPC_RMID</span>:
	<span class="k">case</span> <span class="n">IPC_SET</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">semctl_down</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">semid</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#ifdef CONFIG_HAVE_SYSCALL_WRAPPERS</span>
<span class="n">asmlinkage</span> <span class="kt">long</span> <span class="n">SyS_semctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">union</span> <span class="n">semun</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">SYSC_semctl</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">semid</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">semnum</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SYSCALL_ALIAS</span><span class="p">(</span><span class="n">sys_semctl</span><span class="p">,</span> <span class="n">SyS_semctl</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* If the task doesn&#39;t already have a undo_list, then allocate one</span>
<span class="cm"> * here.  We guarantee there is only one thread using this undo list,</span>
<span class="cm"> * and current is THE ONE</span>
<span class="cm"> *</span>
<span class="cm"> * If this allocation and assignment succeeds, but later</span>
<span class="cm"> * portions of this code fail, there is no need to free the sem_undo_list.</span>
<span class="cm"> * Just let it stay associated with the task, and it&#39;ll be freed later</span>
<span class="cm"> * at exit time.</span>
<span class="cm"> *</span>
<span class="cm"> * This can block, so callers must hold no locks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_undo_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_undo_list</span> <span class="o">**</span><span class="n">undo_listp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sem_undo_list</span> <span class="o">*</span><span class="n">undo_list</span><span class="p">;</span>

	<span class="n">undo_list</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sysvsem</span><span class="p">.</span><span class="n">undo_list</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">undo_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">undo_list</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">undo_list</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">undo_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">undo_list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">undo_list</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">undo_list</span><span class="o">-&gt;</span><span class="n">list_proc</span><span class="p">);</span>

		<span class="n">current</span><span class="o">-&gt;</span><span class="n">sysvsem</span><span class="p">.</span><span class="n">undo_list</span> <span class="o">=</span> <span class="n">undo_list</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">undo_listp</span> <span class="o">=</span> <span class="n">undo_list</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sem_undo</span> <span class="o">*</span><span class="nf">__lookup_undo</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_undo_list</span> <span class="o">*</span><span class="n">ulp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sem_undo</span> <span class="o">*</span><span class="n">un</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">un</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ulp</span><span class="o">-&gt;</span><span class="n">list_proc</span><span class="p">,</span> <span class="n">list_proc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">semid</span> <span class="o">==</span> <span class="n">semid</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">un</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sem_undo</span> <span class="o">*</span><span class="nf">lookup_undo</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_undo_list</span> <span class="o">*</span><span class="n">ulp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sem_undo</span> <span class="o">*</span><span class="n">un</span><span class="p">;</span>

  	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">un</span> <span class="o">=</span> <span class="n">__lookup_undo</span><span class="p">(</span><span class="n">ulp</span><span class="p">,</span> <span class="n">semid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">un</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">list_proc</span><span class="p">);</span>
		<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">list_proc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ulp</span><span class="o">-&gt;</span><span class="n">list_proc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">un</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_alloc_undo - Lookup (and if not present create) undo array</span>
<span class="cm"> * @ns: namespace</span>
<span class="cm"> * @semid: semaphore array id</span>
<span class="cm"> *</span>
<span class="cm"> * The function looks up (and if not present creates) the undo structure.</span>
<span class="cm"> * The size of the undo structure depends on the size of the semaphore</span>
<span class="cm"> * array, thus the alloc path is not that straightforward.</span>
<span class="cm"> * Lifetime-rules: sem_undo is rcu-protected, on success, the function</span>
<span class="cm"> * performs a rcu_read_lock().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sem_undo</span> <span class="o">*</span><span class="nf">find_alloc_undo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sem_undo_list</span> <span class="o">*</span><span class="n">ulp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sem_undo</span> <span class="o">*</span><span class="n">un</span><span class="p">,</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nsems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">get_undo_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">un</span> <span class="o">=</span> <span class="n">lookup_undo</span><span class="p">(</span><span class="n">ulp</span><span class="p">,</span> <span class="n">semid</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">un</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="cm">/* no undo structure around - allocate one. */</span>
	<span class="cm">/* step 1: figure out the size of the semaphore array */</span>
	<span class="n">sma</span> <span class="o">=</span> <span class="n">sem_lock_check</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">semid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sma</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>

	<span class="n">nsems</span> <span class="o">=</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_nsems</span><span class="p">;</span>
	<span class="n">sem_getref_and_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>

	<span class="cm">/* step 2: allocate new undo structure */</span>
	<span class="n">new</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_undo</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">)</span><span class="o">*</span><span class="n">nsems</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sem_putref</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* step 3: Acquire the lock on semaphore array */</span>
	<span class="n">sem_lock_and_putref</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">deleted</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sem_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="n">un</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EIDRM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * step 4: check for races: did someone else allocate the undo struct?</span>
<span class="cm">	 */</span>
	<span class="n">un</span> <span class="o">=</span> <span class="n">lookup_undo</span><span class="p">(</span><span class="n">ulp</span><span class="p">,</span> <span class="n">semid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">un</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">success</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* step 5: initialize &amp; link new undo structure */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">semadj</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">ulp</span> <span class="o">=</span> <span class="n">ulp</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">semid</span> <span class="o">=</span> <span class="n">semid</span><span class="p">;</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">list_proc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ulp</span><span class="o">-&gt;</span><span class="n">list_proc</span><span class="p">);</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">list_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">list_id</span><span class="p">);</span>
	<span class="n">un</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>

<span class="nl">success:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">sem_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">un</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * get_queue_result - Retrieve the result code from sem_queue</span>
<span class="cm"> * @q: Pointer to queue structure</span>
<span class="cm"> *</span>
<span class="cm"> * Retrieve the return code from the pending queue. If IN_WAKEUP is found in</span>
<span class="cm"> * q-&gt;status, then we must loop until the value is replaced with the final</span>
<span class="cm"> * value: This may happen if a task is woken up by an unrelated event (e.g.</span>
<span class="cm"> * signal) and in parallel the task is woken up by another task because it got</span>
<span class="cm"> * the requested semaphores.</span>
<span class="cm"> *</span>
<span class="cm"> * The function can be called with or without holding the semaphore spinlock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_queue_result</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">IN_WAKEUP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">semtimedop</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">semid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">tsops</span><span class="p">,</span>
		<span class="kt">unsigned</span><span class="p">,</span> <span class="n">nsops</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sembuf</span> <span class="n">fast_sops</span><span class="p">[</span><span class="n">SEMOPM_FAST</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sembuf</span><span class="o">*</span> <span class="n">sops</span> <span class="o">=</span> <span class="n">fast_sops</span><span class="p">,</span> <span class="o">*</span><span class="n">sop</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sem_undo</span> <span class="o">*</span><span class="n">un</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">undos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sem_queue</span> <span class="n">queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffies_left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tasks</span><span class="p">;</span>

	<span class="n">ns</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">ipc_ns</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nsops</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">semid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nsops</span> <span class="o">&gt;</span> <span class="n">ns</span><span class="o">-&gt;</span><span class="n">sc_semopm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">nsops</span> <span class="o">&gt;</span> <span class="n">SEMOPM_FAST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sops</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sops</span><span class="p">)</span><span class="o">*</span><span class="n">nsops</span><span class="p">,</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">sops</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span> <span class="p">(</span><span class="n">sops</span><span class="p">,</span> <span class="n">tsops</span><span class="p">,</span> <span class="n">nsops</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tsops</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">error</span><span class="o">=-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">timespec</span> <span class="n">_timeout</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_timeout</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">timeout</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">_timeout</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">_timeout</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
			<span class="n">_timeout</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">&gt;=</span> <span class="mi">1000000000L</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">jiffies_left</span> <span class="o">=</span> <span class="n">timespec_to_jiffies</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_timeout</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">sop</span> <span class="o">=</span> <span class="n">sops</span><span class="p">;</span> <span class="n">sop</span> <span class="o">&lt;</span> <span class="n">sops</span> <span class="o">+</span> <span class="n">nsops</span><span class="p">;</span> <span class="n">sop</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_num</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="p">)</span>
			<span class="n">max</span> <span class="o">=</span> <span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_num</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_flg</span> <span class="o">&amp;</span> <span class="n">SEM_UNDO</span><span class="p">)</span>
			<span class="n">undos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sop</span><span class="o">-&gt;</span><span class="n">sem_op</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">alter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">undos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">un</span> <span class="o">=</span> <span class="n">find_alloc_undo</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">semid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">un</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">un</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">un</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasks</span><span class="p">);</span>

	<span class="n">sma</span> <span class="o">=</span> <span class="n">sem_lock_check</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">semid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sma</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">un</span><span class="p">)</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * semid identifiers are not unique - find_alloc_undo may have</span>
<span class="cm">	 * allocated an undo structure, it was invalidated by an RMID</span>
<span class="cm">	 * and now a new array with received the same id. Check and fail.</span>
<span class="cm">	 * This case can be detected checking un-&gt;semid. The existence of</span>
<span class="cm">	 * &quot;un&quot; itself is guaranteed by rcu.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIDRM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">un</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">semid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">out_unlock_free</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * rcu lock can be released, &quot;un&quot; cannot disappear:</span>
<span class="cm">			 * - sem_lock is acquired, thus IPC_RMID is</span>
<span class="cm">			 *   impossible.</span>
<span class="cm">			 * - exit_sem is impossible, it always operates on</span>
<span class="cm">			 *   current (or a dead task).</span>
<span class="cm">			 */</span>

			<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&gt;=</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_nsems</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock_free</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipcperms</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">,</span> <span class="n">alter</span> <span class="o">?</span> <span class="n">S_IWUGO</span> <span class="o">:</span> <span class="n">S_IRUGO</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock_free</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_sem_semop</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="n">sops</span><span class="p">,</span> <span class="n">nsops</span><span class="p">,</span> <span class="n">alter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock_free</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">try_atomic_semop</span> <span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="n">sops</span><span class="p">,</span> <span class="n">nsops</span><span class="p">,</span> <span class="n">un</span><span class="p">,</span> <span class="n">task_tgid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">alter</span> <span class="o">&amp;&amp;</span> <span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">do_smart_update</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="n">sops</span><span class="p">,</span> <span class="n">nsops</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tasks</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">out_unlock_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We need to sleep on this operation, so we put the current</span>
<span class="cm">	 * task into the pending queue and go to sleep.</span>
<span class="cm">	 */</span>
		
	<span class="n">queue</span><span class="p">.</span><span class="n">sops</span> <span class="o">=</span> <span class="n">sops</span><span class="p">;</span>
	<span class="n">queue</span><span class="p">.</span><span class="n">nsops</span> <span class="o">=</span> <span class="n">nsops</span><span class="p">;</span>
	<span class="n">queue</span><span class="p">.</span><span class="n">undo</span> <span class="o">=</span> <span class="n">un</span><span class="p">;</span>
	<span class="n">queue</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">task_tgid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">queue</span><span class="p">.</span><span class="n">alter</span> <span class="o">=</span> <span class="n">alter</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alter</span><span class="p">)</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_pending</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_pending</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nsops</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sem</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_base</span><span class="p">[</span><span class="n">sops</span><span class="o">-&gt;</span><span class="n">sem_num</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">alter</span><span class="p">)</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">.</span><span class="n">simple_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sem_pending</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">.</span><span class="n">simple_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sem_pending</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">.</span><span class="n">simple_list</span><span class="p">);</span>
		<span class="n">sma</span><span class="o">-&gt;</span><span class="n">complex_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">queue</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
	<span class="n">queue</span><span class="p">.</span><span class="n">sleeper</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

<span class="nl">sleep_again:</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">;</span>
	<span class="n">sem_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
		<span class="n">jiffies_left</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">jiffies_left</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">schedule</span><span class="p">();</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">get_queue_result</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* fast path: update_queue already obtained all requested</span>
<span class="cm">		 * resources.</span>
<span class="cm">		 * Perform a smp_mb(): User space could assume that semop()</span>
<span class="cm">		 * is a memory barrier: Without the mb(), the cpu could</span>
<span class="cm">		 * speculatively read in user space stale data that was</span>
<span class="cm">		 * overwritten by the previous owner of the semaphore.</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb</span><span class="p">();</span>

		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sma</span> <span class="o">=</span> <span class="n">sem_lock</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">semid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait until it&#39;s guaranteed that no wakeup_sem_queue_do() is ongoing.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">get_queue_result</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Array removed? If yes, leave without sem_unlock().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sma</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/*</span>
<span class="cm">	 * If queue.status != -EINTR we are woken up by another process.</span>
<span class="cm">	 * Leave without unlink_queue(), but with sem_unlock().</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">out_unlock_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If an interrupt occurred we have to clean up the queue</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&amp;&amp;</span> <span class="n">jiffies_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the wakeup was spurious, just retry</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">sleep_again</span><span class="p">;</span>

	<span class="n">unlink_queue</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>

<span class="nl">out_unlock_free:</span>
	<span class="n">sem_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>

	<span class="n">wake_up_sem_queue_do</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasks</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="k">if</span><span class="p">(</span><span class="n">sops</span> <span class="o">!=</span> <span class="n">fast_sops</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sops</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">semop</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">semid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">tsops</span><span class="p">,</span>
		<span class="kt">unsigned</span><span class="p">,</span> <span class="n">nsops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sys_semtimedop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="n">tsops</span><span class="p">,</span> <span class="n">nsops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* If CLONE_SYSVSEM is set, establish sharing of SEM_UNDO state between</span>
<span class="cm"> * parent and child tasks.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">copy_semundo</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sem_undo_list</span> <span class="o">*</span><span class="n">undo_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_SYSVSEM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">get_undo_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">undo_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">undo_list</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sysvsem</span><span class="p">.</span><span class="n">undo_list</span> <span class="o">=</span> <span class="n">undo_list</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> 
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sysvsem</span><span class="p">.</span><span class="n">undo_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * add semadj values to semaphores, free undo structures.</span>
<span class="cm"> * undo structures are not freed when semaphore arrays are destroyed</span>
<span class="cm"> * so some of them may be out of date.</span>
<span class="cm"> * IMPLEMENTATION NOTE: There is some confusion over whether the</span>
<span class="cm"> * set of adjustments that needs to be done should be done in an atomic</span>
<span class="cm"> * manner or not. That is, if we are attempting to decrement the semval</span>
<span class="cm"> * should we queue up and wait until we can do so legally?</span>
<span class="cm"> * The original implementation attempted to do this (queue and wait).</span>
<span class="cm"> * The current implementation does not do so. The POSIX standard</span>
<span class="cm"> * and SVID should be consulted to determine what behavior is mandated.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">exit_sem</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sem_undo_list</span> <span class="o">*</span><span class="n">ulp</span><span class="p">;</span>

	<span class="n">ulp</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sysvsem</span><span class="p">.</span><span class="n">undo_list</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ulp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sysvsem</span><span class="p">.</span><span class="n">undo_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulp</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sem_undo</span> <span class="o">*</span><span class="n">un</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tasks</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">semid</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">un</span> <span class="o">=</span> <span class="n">list_entry_rcu</span><span class="p">(</span><span class="n">ulp</span><span class="o">-&gt;</span><span class="n">list_proc</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sem_undo</span><span class="p">,</span> <span class="n">list_proc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">list_proc</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ulp</span><span class="o">-&gt;</span><span class="n">list_proc</span><span class="p">)</span>
			<span class="n">semid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		 <span class="k">else</span>
			<span class="n">semid</span> <span class="o">=</span> <span class="n">un</span><span class="o">-&gt;</span><span class="n">semid</span><span class="p">;</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">semid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">sma</span> <span class="o">=</span> <span class="n">sem_lock_check</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">ipc_ns</span><span class="p">,</span> <span class="n">un</span><span class="o">-&gt;</span><span class="n">semid</span><span class="p">);</span>

		<span class="cm">/* exit_sem raced with IPC_RMID, nothing to do */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sma</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">un</span> <span class="o">=</span> <span class="n">__lookup_undo</span><span class="p">(</span><span class="n">ulp</span><span class="p">,</span> <span class="n">semid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">un</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* exit_sem raced with IPC_RMID+semget() that created</span>
<span class="cm">			 * exactly the same semid. Nothing to do.</span>
<span class="cm">			 */</span>
			<span class="n">sem_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* remove un from the linked lists */</span>
		<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">list_id</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">list_proc</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ulp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/* perform adjustments registered in un */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_nsems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sem</span> <span class="o">*</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_base</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">semadj</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">semaphore</span><span class="o">-&gt;</span><span class="n">semval</span> <span class="o">+=</span> <span class="n">un</span><span class="o">-&gt;</span><span class="n">semadj</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="cm">/*</span>
<span class="cm">				 * Range checks of the new semaphore value,</span>
<span class="cm">				 * not defined by sus:</span>
<span class="cm">				 * - Some unices ignore the undo entirely</span>
<span class="cm">				 *   (e.g. HP UX 11i 11.22, Tru64 V5.1)</span>
<span class="cm">				 * - some cap the value (e.g. FreeBSD caps</span>
<span class="cm">				 *   at 0, but doesn&#39;t enforce SEMVMX)</span>
<span class="cm">				 *</span>
<span class="cm">				 * Linux caps the semaphore value, both at 0</span>
<span class="cm">				 * and at SEMVMX.</span>
<span class="cm">				 *</span>
<span class="cm">				 * 	Manfred &lt;manfred@colorfullife.com&gt;</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">semaphore</span><span class="o">-&gt;</span><span class="n">semval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">semaphore</span><span class="o">-&gt;</span><span class="n">semval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">semaphore</span><span class="o">-&gt;</span><span class="n">semval</span> <span class="o">&gt;</span> <span class="n">SEMVMX</span><span class="p">)</span>
					<span class="n">semaphore</span><span class="o">-&gt;</span><span class="n">semval</span> <span class="o">=</span> <span class="n">SEMVMX</span><span class="p">;</span>
				<span class="n">semaphore</span><span class="o">-&gt;</span><span class="n">sempid</span> <span class="o">=</span> <span class="n">task_tgid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* maybe some queued-up processes were waiting for this */</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasks</span><span class="p">);</span>
		<span class="n">do_smart_update</span><span class="p">(</span><span class="n">sma</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tasks</span><span class="p">);</span>
		<span class="n">sem_unlock</span><span class="p">(</span><span class="n">sma</span><span class="p">);</span>
		<span class="n">wake_up_sem_queue_do</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasks</span><span class="p">);</span>

		<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">un</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ulp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sysvipc_sem_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span> <span class="o">=</span> <span class="n">it</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
			  <span class="s">&quot;%10d %10d  %4o %10u %5u %5u %5u %5u %10lu %10lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">key</span><span class="p">,</span>
			  <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
			  <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">mode</span><span class="p">,</span>
			  <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_nsems</span><span class="p">,</span>
			  <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span>
			  <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">gid</span><span class="p">,</span>
			  <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">cuid</span><span class="p">,</span>
			  <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_perm</span><span class="p">.</span><span class="n">cgid</span><span class="p">,</span>
			  <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_otime</span><span class="p">,</span>
			  <span class="n">sma</span><span class="o">-&gt;</span><span class="n">sem_ctime</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
