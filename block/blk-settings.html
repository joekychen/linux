<!DOCTYPE html>
<html><head><title>joekychen/linux » block › blk-settings.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>blk-settings.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Functions related to setting various queue properties from drivers</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;	</span><span class="cm">/* for max_pfn/max_low_pfn */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/gcd.h&gt;</span>
<span class="cp">#include &lt;linux/lcm.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>

<span class="cp">#include &quot;blk.h&quot;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blk_max_low_pfn</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_max_low_pfn</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blk_max_pfn</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_prep_rq - set a prepare_request function for queue</span>
<span class="cm"> * @q:		queue</span>
<span class="cm"> * @pfn:	prepare_request function</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s possible for a queue to register a prepare_request callback which</span>
<span class="cm"> * is invoked before the request is handed to the request_fn. The goal of</span>
<span class="cm"> * the function is to prepare a request for I/O, it can be used to build a</span>
<span class="cm"> * cdb from the request data for instance.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_queue_prep_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">prep_rq_fn</span> <span class="o">*</span><span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">prep_rq_fn</span> <span class="o">=</span> <span class="n">pfn</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_prep_rq</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_unprep_rq - set an unprepare_request function for queue</span>
<span class="cm"> * @q:		queue</span>
<span class="cm"> * @ufn:	unprepare_request function</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s possible for a queue to register an unprepare_request callback</span>
<span class="cm"> * which is invoked before the request is finally completed. The goal</span>
<span class="cm"> * of the function is to deallocate any data that was allocated in the</span>
<span class="cm"> * prepare_request callback.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_queue_unprep_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">unprep_rq_fn</span> <span class="o">*</span><span class="n">ufn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">unprep_rq_fn</span> <span class="o">=</span> <span class="n">ufn</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_unprep_rq</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_merge_bvec - set a merge_bvec function for queue</span>
<span class="cm"> * @q:		queue</span>
<span class="cm"> * @mbfn:	merge_bvec_fn</span>
<span class="cm"> *</span>
<span class="cm"> * Usually queues have static limitations on the max sectors or segments that</span>
<span class="cm"> * we can put in a request. Stacking drivers may have some settings that</span>
<span class="cm"> * are dynamic, and thus we have to query the queue whether it is ok to</span>
<span class="cm"> * add a new bio_vec to a bio at a given offset or not. If the block device</span>
<span class="cm"> * has such limitations, it needs to register a merge_bvec_fn to control</span>
<span class="cm"> * the size of bio&#39;s sent to it. Note that a block device *must* allow a</span>
<span class="cm"> * single page to be added to an empty bio. The block device driver may want</span>
<span class="cm"> * to use the bio_split() function to deal with these bio&#39;s. By default</span>
<span class="cm"> * no merge_bvec_fn is defined for a queue, and only the fixed limits are</span>
<span class="cm"> * honored.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_queue_merge_bvec</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">merge_bvec_fn</span> <span class="o">*</span><span class="n">mbfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">merge_bvec_fn</span> <span class="o">=</span> <span class="n">mbfn</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_merge_bvec</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">blk_queue_softirq_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">softirq_done_fn</span> <span class="o">*</span><span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">softirq_done_fn</span> <span class="o">=</span> <span class="n">fn</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_softirq_done</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">blk_queue_rq_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">rq_timeout</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_queue_rq_timeout</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">blk_queue_rq_timed_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">rq_timed_out_fn</span> <span class="o">*</span><span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">rq_timed_out_fn</span> <span class="o">=</span> <span class="n">fn</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_queue_rq_timed_out</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">blk_queue_lld_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">lld_busy_fn</span> <span class="o">*</span><span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">lld_busy_fn</span> <span class="o">=</span> <span class="n">fn</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_queue_lld_busy</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_set_default_limits - reset limits to default values</span>
<span class="cm"> * @lim:  the queue_limits structure to reset</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Returns a queue_limit struct to its default state.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_set_default_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">lim</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">max_segments</span> <span class="o">=</span> <span class="n">BLK_MAX_SEGMENTS</span><span class="p">;</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">max_integrity_segments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">seg_boundary_mask</span> <span class="o">=</span> <span class="n">BLK_SEG_BOUNDARY_MASK</span><span class="p">;</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">max_segment_size</span> <span class="o">=</span> <span class="n">BLK_MAX_SEGMENT_SIZE</span><span class="p">;</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="n">lim</span><span class="o">-&gt;</span><span class="n">max_hw_sectors</span> <span class="o">=</span> <span class="n">BLK_SAFE_MAX_SECTORS</span><span class="p">;</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">max_discard_sectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">discard_granularity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">discard_alignment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">discard_misaligned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">discard_zeroes_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">logical_block_size</span> <span class="o">=</span> <span class="n">lim</span><span class="o">-&gt;</span><span class="n">physical_block_size</span> <span class="o">=</span> <span class="n">lim</span><span class="o">-&gt;</span><span class="n">io_min</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">bounce_pfn</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">BLK_BOUNCE_ANY</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">alignment_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">io_opt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">misaligned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">cluster</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_set_default_limits</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_set_stacking_limits - set default limits for stacking devices</span>
<span class="cm"> * @lim:  the queue_limits structure to reset</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Returns a queue_limit struct to its default state. Should be used</span>
<span class="cm"> *   by stacking drivers like DM that have no internal limits.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_set_stacking_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">lim</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blk_set_default_limits</span><span class="p">(</span><span class="n">lim</span><span class="p">);</span>

	<span class="cm">/* Inherit limits from component devices */</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">discard_zeroes_data</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">max_segments</span> <span class="o">=</span> <span class="n">USHRT_MAX</span><span class="p">;</span>
	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">max_hw_sectors</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>

	<span class="n">lim</span><span class="o">-&gt;</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="n">BLK_DEF_MAX_SECTORS</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_set_stacking_limits</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_make_request - define an alternate make_request function for a device</span>
<span class="cm"> * @q:  the request queue for the device to be affected</span>
<span class="cm"> * @mfn: the alternate make_request function</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    The normal way for &amp;struct bios to be passed to a device</span>
<span class="cm"> *    driver is for them to be collected into requests on a request</span>
<span class="cm"> *    queue, and then to allow the device driver to select requests</span>
<span class="cm"> *    off that queue when it is ready.  This works well for many block</span>
<span class="cm"> *    devices. However some block devices (typically virtual devices</span>
<span class="cm"> *    such as md or lvm) do not benefit from the processing on the</span>
<span class="cm"> *    request queue, and are served best by having the requests passed</span>
<span class="cm"> *    directly to them.  This can be achieved by providing a function</span>
<span class="cm"> *    to blk_queue_make_request().</span>
<span class="cm"> *</span>
<span class="cm"> * Caveat:</span>
<span class="cm"> *    The driver that does this *must* be able to deal appropriately</span>
<span class="cm"> *    with buffers in &quot;highmemory&quot;. This can be accomplished by either calling</span>
<span class="cm"> *    __bio_kmap_atomic() to get a temporary kernel mapping, or by calling</span>
<span class="cm"> *    blk_queue_bounce() to create a buffer in normal memory.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">blk_queue_make_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">make_request_fn</span> <span class="o">*</span><span class="n">mfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * set defaults</span>
<span class="cm">	 */</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_requests</span> <span class="o">=</span> <span class="n">BLKDEV_MAX_RQ</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">make_request_fn</span> <span class="o">=</span> <span class="n">mfn</span><span class="p">;</span>
	<span class="n">blk_queue_dma_alignment</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">511</span><span class="p">);</span>
	<span class="n">blk_queue_congestion_threshold</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_batching</span> <span class="o">=</span> <span class="n">BLK_BATCH_REQ</span><span class="p">;</span>

	<span class="n">blk_set_default_limits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * by default assume old behaviour and bounce for any highmem page</span>
<span class="cm">	 */</span>
	<span class="n">blk_queue_bounce_limit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">BLK_BOUNCE_HIGH</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_make_request</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_bounce_limit - set bounce buffer limit for queue</span>
<span class="cm"> * @q: the request queue for the device</span>
<span class="cm"> * @dma_mask: the maximum address the device can handle</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    Different hardware can have different requirements as to what pages</span>
<span class="cm"> *    it can do I/O directly to. A low level driver can call</span>
<span class="cm"> *    blk_queue_bounce_limit to have lower memory pages allocated as bounce</span>
<span class="cm"> *    buffers for doing I/O to pages residing above @dma_mask.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">blk_queue_bounce_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">u64</span> <span class="n">dma_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b_pfn</span> <span class="o">=</span> <span class="n">dma_mask</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">bounce_gfp</span> <span class="o">=</span> <span class="n">GFP_NOIO</span><span class="p">;</span>
<span class="cp">#if BITS_PER_LONG == 64</span>
	<span class="cm">/*</span>
<span class="cm">	 * Assume anything &lt;= 4GB can be handled by IOMMU.  Actually</span>
<span class="cm">	 * some IOMMUs can handle everything, but I don&#39;t know of a</span>
<span class="cm">	 * way to test this here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b_pfn</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="mh">0xffffffffUL</span><span class="p">,</span> <span class="n">BLK_BOUNCE_HIGH</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span>
		<span class="n">dma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">bounce_pfn</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_low_pfn</span><span class="p">,</span> <span class="n">b_pfn</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b_pfn</span> <span class="o">&lt;</span> <span class="n">blk_max_low_pfn</span><span class="p">)</span>
		<span class="n">dma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">bounce_pfn</span> <span class="o">=</span> <span class="n">b_pfn</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">init_emergency_isa_pool</span><span class="p">();</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">bounce_gfp</span> <span class="o">=</span> <span class="n">GFP_NOIO</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">bounce_pfn</span> <span class="o">=</span> <span class="n">b_pfn</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_bounce_limit</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_limits_max_hw_sectors - set hard and soft limit of max sectors for request</span>
<span class="cm"> * @limits: the queue limits</span>
<span class="cm"> * @max_hw_sectors:  max hardware sectors in the usual 512b unit</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    Enables a low level driver to set a hard upper limit,</span>
<span class="cm"> *    max_hw_sectors, on the size of requests.  max_hw_sectors is set by</span>
<span class="cm"> *    the device driver based upon the combined capabilities of I/O</span>
<span class="cm"> *    controller and storage device.</span>
<span class="cm"> *</span>
<span class="cm"> *    max_sectors is a soft limit imposed by the block layer for</span>
<span class="cm"> *    filesystem type requests.  This value can be overridden on a</span>
<span class="cm"> *    per-device basis in /sys/block/&lt;device&gt;/queue/max_sectors_kb.</span>
<span class="cm"> *    The soft limit can not exceed max_hw_sectors.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">blk_limits_max_hw_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">limits</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_hw_sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">max_hw_sectors</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">max_hw_sectors</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="mi">9</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: set to minimum %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">max_hw_sectors</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">limits</span><span class="o">-&gt;</span><span class="n">max_hw_sectors</span> <span class="o">=</span> <span class="n">max_hw_sectors</span><span class="p">;</span>
	<span class="n">limits</span><span class="o">-&gt;</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">max_hw_sectors</span><span class="p">,</span>
				    <span class="n">BLK_DEF_MAX_SECTORS</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_limits_max_hw_sectors</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_max_hw_sectors - set max sectors for a request for this queue</span>
<span class="cm"> * @q:  the request queue for the device</span>
<span class="cm"> * @max_hw_sectors:  max hardware sectors in the usual 512b unit</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    See description for blk_limits_max_hw_sectors().</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">blk_queue_max_hw_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_hw_sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blk_limits_max_hw_sectors</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">,</span> <span class="n">max_hw_sectors</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_max_hw_sectors</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_max_discard_sectors - set max sectors for a single discard</span>
<span class="cm"> * @q:  the request queue for the device</span>
<span class="cm"> * @max_discard_sectors: maximum number of sectors to discard</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">blk_queue_max_discard_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_discard_sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">max_discard_sectors</span> <span class="o">=</span> <span class="n">max_discard_sectors</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_max_discard_sectors</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_max_segments - set max hw segments for a request for this queue</span>
<span class="cm"> * @q:  the request queue for the device</span>
<span class="cm"> * @max_segments:  max number of segments</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    Enables a low level driver to set an upper limit on the number of</span>
<span class="cm"> *    hw data segments in a request.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">blk_queue_max_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">max_segments</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_segments</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">max_segments</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: set to minimum %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">max_segments</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">max_segments</span> <span class="o">=</span> <span class="n">max_segments</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_max_segments</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_max_segment_size - set max segment size for blk_rq_map_sg</span>
<span class="cm"> * @q:  the request queue for the device</span>
<span class="cm"> * @max_size:  max size of segment in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    Enables a low level driver to set an upper limit on the size of a</span>
<span class="cm"> *    coalesced segment</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">blk_queue_max_segment_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_size</span> <span class="o">&lt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">max_size</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: set to minimum %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">max_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">max_segment_size</span> <span class="o">=</span> <span class="n">max_size</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_max_segment_size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_logical_block_size - set logical block size for the queue</span>
<span class="cm"> * @q:  the request queue for the device</span>
<span class="cm"> * @size:  the logical block size, in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   This should be set to the lowest possible block size that the</span>
<span class="cm"> *   storage device can address.  The default of 512 covers most</span>
<span class="cm"> *   hardware.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">blk_queue_logical_block_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">logical_block_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">physical_block_size</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">physical_block_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">io_min</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">physical_block_size</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">io_min</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">physical_block_size</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_logical_block_size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_physical_block_size - set physical block size for the queue</span>
<span class="cm"> * @q:  the request queue for the device</span>
<span class="cm"> * @size:  the physical block size, in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   This should be set to the lowest possible sector size that the</span>
<span class="cm"> *   hardware can operate on without reverting to read-modify-write</span>
<span class="cm"> *   operations.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_queue_physical_block_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">physical_block_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">physical_block_size</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">logical_block_size</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">physical_block_size</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">logical_block_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">io_min</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">physical_block_size</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">io_min</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">physical_block_size</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_physical_block_size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_alignment_offset - set physical block alignment offset</span>
<span class="cm"> * @q:	the request queue for the device</span>
<span class="cm"> * @offset: alignment offset in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Some devices are naturally misaligned to compensate for things like</span>
<span class="cm"> *   the legacy DOS partition table 63-sector offset.  Low-level drivers</span>
<span class="cm"> *   should call this function for devices whose first sector is not</span>
<span class="cm"> *   naturally aligned.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_queue_alignment_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">alignment_offset</span> <span class="o">=</span>
		<span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">physical_block_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">misaligned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_alignment_offset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_limits_io_min - set minimum request size for a device</span>
<span class="cm"> * @limits: the queue limits</span>
<span class="cm"> * @min:  smallest I/O size in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Some devices have an internal block size bigger than the reported</span>
<span class="cm"> *   hardware sector size.  This function can be used to signal the</span>
<span class="cm"> *   smallest I/O the device can perform without incurring a performance</span>
<span class="cm"> *   penalty.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_limits_io_min</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">limits</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">limits</span><span class="o">-&gt;</span><span class="n">io_min</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">limits</span><span class="o">-&gt;</span><span class="n">io_min</span> <span class="o">&lt;</span> <span class="n">limits</span><span class="o">-&gt;</span><span class="n">logical_block_size</span><span class="p">)</span>
		<span class="n">limits</span><span class="o">-&gt;</span><span class="n">io_min</span> <span class="o">=</span> <span class="n">limits</span><span class="o">-&gt;</span><span class="n">logical_block_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">limits</span><span class="o">-&gt;</span><span class="n">io_min</span> <span class="o">&lt;</span> <span class="n">limits</span><span class="o">-&gt;</span><span class="n">physical_block_size</span><span class="p">)</span>
		<span class="n">limits</span><span class="o">-&gt;</span><span class="n">io_min</span> <span class="o">=</span> <span class="n">limits</span><span class="o">-&gt;</span><span class="n">physical_block_size</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_limits_io_min</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_io_min - set minimum request size for the queue</span>
<span class="cm"> * @q:	the request queue for the device</span>
<span class="cm"> * @min:  smallest I/O size in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Storage devices may report a granularity or preferred minimum I/O</span>
<span class="cm"> *   size which is the smallest request the device can perform without</span>
<span class="cm"> *   incurring a performance penalty.  For disk drives this is often the</span>
<span class="cm"> *   physical block size.  For RAID arrays it is often the stripe chunk</span>
<span class="cm"> *   size.  A properly aligned multiple of minimum_io_size is the</span>
<span class="cm"> *   preferred request size for workloads where a high number of I/O</span>
<span class="cm"> *   operations is desired.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_queue_io_min</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blk_limits_io_min</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">,</span> <span class="n">min</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_io_min</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_limits_io_opt - set optimal request size for a device</span>
<span class="cm"> * @limits: the queue limits</span>
<span class="cm"> * @opt:  smallest I/O size in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Storage devices may report an optimal I/O size, which is the</span>
<span class="cm"> *   device&#39;s preferred unit for sustained I/O.  This is rarely reported</span>
<span class="cm"> *   for disk drives.  For RAID arrays it is usually the stripe width or</span>
<span class="cm"> *   the internal track size.  A properly aligned multiple of</span>
<span class="cm"> *   optimal_io_size is the preferred request size for workloads where</span>
<span class="cm"> *   sustained throughput is desired.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_limits_io_opt</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">limits</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">limits</span><span class="o">-&gt;</span><span class="n">io_opt</span> <span class="o">=</span> <span class="n">opt</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_limits_io_opt</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_io_opt - set optimal request size for the queue</span>
<span class="cm"> * @q:	the request queue for the device</span>
<span class="cm"> * @opt:  optimal request size in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Storage devices may report an optimal I/O size, which is the</span>
<span class="cm"> *   device&#39;s preferred unit for sustained I/O.  This is rarely reported</span>
<span class="cm"> *   for disk drives.  For RAID arrays it is usually the stripe width or</span>
<span class="cm"> *   the internal track size.  A properly aligned multiple of</span>
<span class="cm"> *   optimal_io_size is the preferred request size for workloads where</span>
<span class="cm"> *   sustained throughput is desired.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_queue_io_opt</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blk_limits_io_opt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">,</span> <span class="n">opt</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_io_opt</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_stack_limits - inherit underlying queue limits for stacked drivers</span>
<span class="cm"> * @t:	the stacking driver (top)</span>
<span class="cm"> * @b:  the underlying device (bottom)</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">blk_queue_stack_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blk_stack_limits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_stack_limits</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_stack_limits - adjust queue_limits for stacked devices</span>
<span class="cm"> * @t:	the stacking driver limits (top device)</span>
<span class="cm"> * @b:  the underlying queue limits (bottom, component device)</span>
<span class="cm"> * @start:  first data sector within component device</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    This function is used by stacking drivers like MD and DM to ensure</span>
<span class="cm"> *    that all component devices have compatible block sizes and</span>
<span class="cm"> *    alignments.  The stacking driver must provide a queue_limits</span>
<span class="cm"> *    struct (top) and then iteratively call the stacking function for</span>
<span class="cm"> *    all component (bottom) devices.  The stacking function will</span>
<span class="cm"> *    attempt to combine the values and ensure proper alignment.</span>
<span class="cm"> *</span>
<span class="cm"> *    Returns 0 if the top and bottom queue_limits are compatible.  The</span>
<span class="cm"> *    top device&#39;s block sizes and alignment offsets may be adjusted to</span>
<span class="cm"> *    ensure alignment with the bottom device. If no compatible sizes</span>
<span class="cm"> *    and alignments exist, -1 is returned and the resulting top</span>
<span class="cm"> *    queue_limits will have the misaligned flag set to indicate that</span>
<span class="cm"> *    the alignment_offset is undefined.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">blk_stack_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span>
		     <span class="n">sector_t</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">alignment</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="n">min_not_zero</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">max_sectors</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">max_sectors</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">max_hw_sectors</span> <span class="o">=</span> <span class="n">min_not_zero</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">max_hw_sectors</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">max_hw_sectors</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">bounce_pfn</span> <span class="o">=</span> <span class="n">min_not_zero</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">bounce_pfn</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bounce_pfn</span><span class="p">);</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">seg_boundary_mask</span> <span class="o">=</span> <span class="n">min_not_zero</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">seg_boundary_mask</span><span class="p">,</span>
					    <span class="n">b</span><span class="o">-&gt;</span><span class="n">seg_boundary_mask</span><span class="p">);</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">max_segments</span> <span class="o">=</span> <span class="n">min_not_zero</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">max_segments</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">max_segments</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">max_integrity_segments</span> <span class="o">=</span> <span class="n">min_not_zero</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">max_integrity_segments</span><span class="p">,</span>
						 <span class="n">b</span><span class="o">-&gt;</span><span class="n">max_integrity_segments</span><span class="p">);</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">max_segment_size</span> <span class="o">=</span> <span class="n">min_not_zero</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">max_segment_size</span><span class="p">,</span>
					   <span class="n">b</span><span class="o">-&gt;</span><span class="n">max_segment_size</span><span class="p">);</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">misaligned</span> <span class="o">|=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">misaligned</span><span class="p">;</span>

	<span class="n">alignment</span> <span class="o">=</span> <span class="n">queue_limit_alignment_offset</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>

	<span class="cm">/* Bottom device has different alignment.  Check that it is</span>
<span class="cm">	 * compatible with the current top alignment.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">alignment_offset</span> <span class="o">!=</span> <span class="n">alignment</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">top</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">physical_block_size</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">io_min</span><span class="p">)</span>
			<span class="o">+</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">alignment_offset</span><span class="p">;</span>
		<span class="n">bottom</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">physical_block_size</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">io_min</span><span class="p">)</span> <span class="o">+</span> <span class="n">alignment</span><span class="p">;</span>

		<span class="cm">/* Verify that top and bottom intervals line up */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">misaligned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">logical_block_size</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">logical_block_size</span><span class="p">,</span>
				    <span class="n">b</span><span class="o">-&gt;</span><span class="n">logical_block_size</span><span class="p">);</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">physical_block_size</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">physical_block_size</span><span class="p">,</span>
				     <span class="n">b</span><span class="o">-&gt;</span><span class="n">physical_block_size</span><span class="p">);</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">io_min</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">io_min</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">io_min</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">io_opt</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">io_opt</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">io_opt</span><span class="p">);</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">cluster</span> <span class="o">&amp;=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">cluster</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">discard_zeroes_data</span> <span class="o">&amp;=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">discard_zeroes_data</span><span class="p">;</span>

	<span class="cm">/* Physical block size a multiple of the logical block size? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">physical_block_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">logical_block_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">physical_block_size</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">logical_block_size</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">misaligned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Minimum I/O a multiple of the physical block size? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">io_min</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">physical_block_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">io_min</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">physical_block_size</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">misaligned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Optimal I/O a multiple of the physical block size? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">io_opt</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">physical_block_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">io_opt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">misaligned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Find lowest common alignment_offset */</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">alignment_offset</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">alignment_offset</span><span class="p">,</span> <span class="n">alignment</span><span class="p">)</span>
		<span class="o">&amp;</span> <span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">physical_block_size</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">io_min</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Verify that new alignment_offset is on a logical block boundary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">alignment_offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">logical_block_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">misaligned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Discard alignment and granularity */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">discard_granularity</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">alignment</span> <span class="o">=</span> <span class="n">queue_limit_discard_alignment</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">discard_granularity</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">t</span><span class="o">-&gt;</span><span class="n">discard_alignment</span> <span class="o">!=</span> <span class="n">alignment</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">top</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">discard_granularity</span> <span class="o">+</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">discard_alignment</span><span class="p">;</span>
			<span class="n">bottom</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">discard_granularity</span> <span class="o">+</span> <span class="n">alignment</span><span class="p">;</span>

			<span class="cm">/* Verify that top and bottom intervals line up */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
				<span class="n">t</span><span class="o">-&gt;</span><span class="n">discard_misaligned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">t</span><span class="o">-&gt;</span><span class="n">max_discard_sectors</span> <span class="o">=</span> <span class="n">min_not_zero</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">max_discard_sectors</span><span class="p">,</span>
						      <span class="n">b</span><span class="o">-&gt;</span><span class="n">max_discard_sectors</span><span class="p">);</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">discard_granularity</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">discard_granularity</span><span class="p">,</span>
					     <span class="n">b</span><span class="o">-&gt;</span><span class="n">discard_granularity</span><span class="p">);</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">discard_alignment</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">discard_alignment</span><span class="p">,</span> <span class="n">alignment</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">discard_granularity</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_stack_limits</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bdev_stack_limits - adjust queue limits for stacked drivers</span>
<span class="cm"> * @t:	the stacking driver limits (top device)</span>
<span class="cm"> * @bdev:  the component block_device (bottom)</span>
<span class="cm"> * @start:  first data sector within component device</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    Merges queue limits for a top device and a block_device.  Returns</span>
<span class="cm"> *    0 if alignment didn&#39;t change.  Returns -1 if adding the bottom</span>
<span class="cm"> *    device caused misalignment.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bdev_stack_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_limits</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
		      <span class="n">sector_t</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">bq</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>

	<span class="n">start</span> <span class="o">+=</span> <span class="n">get_start_sect</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">blk_stack_limits</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bq</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bdev_stack_limits</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * disk_stack_limits - adjust queue limits for stacked drivers</span>
<span class="cm"> * @disk:  MD/DM gendisk (top)</span>
<span class="cm"> * @bdev:  the underlying block device (bottom)</span>
<span class="cm"> * @offset:  offset to beginning of data within component device</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    Merges the limits for a top level gendisk and a bottom level</span>
<span class="cm"> *    block_device.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">disk_stack_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
		       <span class="n">sector_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bdev_stack_limits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">,</span> <span class="n">bdev</span><span class="p">,</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">top</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">],</span> <span class="n">bottom</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

		<span class="n">disk_name</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">top</span><span class="p">);</span>
		<span class="n">bdevname</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">bottom</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: Warning: Device %s is misaligned</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">disk_stack_limits</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_dma_pad - set pad mask</span>
<span class="cm"> * @q:     the request queue for the device</span>
<span class="cm"> * @mask:  pad mask</span>
<span class="cm"> *</span>
<span class="cm"> * Set dma pad mask.</span>
<span class="cm"> *</span>
<span class="cm"> * Appending pad buffer to a request modifies the last entry of a</span>
<span class="cm"> * scatter list such that it includes the pad buffer.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">blk_queue_dma_pad</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_pad_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_dma_pad</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_update_dma_pad - update pad mask</span>
<span class="cm"> * @q:     the request queue for the device</span>
<span class="cm"> * @mask:  pad mask</span>
<span class="cm"> *</span>
<span class="cm"> * Update dma pad mask.</span>
<span class="cm"> *</span>
<span class="cm"> * Appending pad buffer to a request modifies the last entry of a</span>
<span class="cm"> * scatter list such that it includes the pad buffer.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">blk_queue_update_dma_pad</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_pad_mask</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_pad_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_update_dma_pad</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_dma_drain - Set up a drain buffer for excess dma.</span>
<span class="cm"> * @q:  the request queue for the device</span>
<span class="cm"> * @dma_drain_needed: fn which returns non-zero if drain is necessary</span>
<span class="cm"> * @buf:	physically contiguous buffer</span>
<span class="cm"> * @size:	size of the buffer in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Some devices have excess DMA problems and can&#39;t simply discard (or</span>
<span class="cm"> * zero fill) the unwanted piece of the transfer.  They have to have a</span>
<span class="cm"> * real area of memory to transfer it into.  The use case for this is</span>
<span class="cm"> * ATAPI devices in DMA mode.  If the packet command causes a transfer</span>
<span class="cm"> * bigger than the transfer size some HBAs will lock up if there</span>
<span class="cm"> * aren&#39;t DMA elements to contain the excess transfer.  What this API</span>
<span class="cm"> * does is adjust the queue so that the buf is always appended</span>
<span class="cm"> * silently to the scatterlist.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: This routine adjusts max_hw_segments to make room for appending</span>
<span class="cm"> * the drain buffer.  If you call blk_queue_max_segments() after calling</span>
<span class="cm"> * this routine, you must set the limit to one fewer than your device</span>
<span class="cm"> * can support otherwise there won&#39;t be room for the drain buffer.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">blk_queue_dma_drain</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			       <span class="n">dma_drain_needed_fn</span> <span class="o">*</span><span class="n">dma_drain_needed</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue_max_segments</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/* make room for appending the drain */</span>
	<span class="n">blk_queue_max_segments</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">queue_max_segments</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_drain_needed</span> <span class="o">=</span> <span class="n">dma_drain_needed</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_drain_buffer</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_drain_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_queue_dma_drain</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_segment_boundary - set boundary rules for segment merging</span>
<span class="cm"> * @q:  the request queue for the device</span>
<span class="cm"> * @mask:  the memory boundary mask</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">blk_queue_segment_boundary</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&lt;</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: set to minimum %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">seg_boundary_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_segment_boundary</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_dma_alignment - set dma length and memory alignment</span>
<span class="cm"> * @q:     the request queue for the device</span>
<span class="cm"> * @mask:  alignment mask</span>
<span class="cm"> *</span>
<span class="cm"> * description:</span>
<span class="cm"> *    set required memory and length alignment for direct dma transactions.</span>
<span class="cm"> *    this is used when building direct io requests for the queue.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">blk_queue_dma_alignment</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_alignment</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_dma_alignment</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_update_dma_alignment - update dma length and memory alignment</span>
<span class="cm"> * @q:     the request queue for the device</span>
<span class="cm"> * @mask:  alignment mask</span>
<span class="cm"> *</span>
<span class="cm"> * description:</span>
<span class="cm"> *    update required memory and length alignment for direct dma transactions.</span>
<span class="cm"> *    If the requested alignment is larger than the current alignment, then</span>
<span class="cm"> *    the current queue alignment is updated to the new value, otherwise it</span>
<span class="cm"> *    is left alone.  The design of this is to allow multiple objects</span>
<span class="cm"> *    (driver, device, transport etc) to set their respective</span>
<span class="cm"> *    alignments without having them interfere.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">blk_queue_update_dma_alignment</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_alignment</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_alignment</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_queue_update_dma_alignment</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_flush - configure queue&#39;s cache flush capability</span>
<span class="cm"> * @q:		the request queue for the device</span>
<span class="cm"> * @flush:	0, REQ_FLUSH or REQ_FLUSH | REQ_FUA</span>
<span class="cm"> *</span>
<span class="cm"> * Tell block layer cache flush capability of @q.  If it supports</span>
<span class="cm"> * flushing, REQ_FLUSH should be set.  If it supports bypassing</span>
<span class="cm"> * write cache for individual writes, REQ_FUA should be set.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_queue_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flush</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">flush</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">REQ_FLUSH</span> <span class="o">|</span> <span class="n">REQ_FUA</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flush</span> <span class="o">&amp;</span> <span class="n">REQ_FLUSH</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flush</span> <span class="o">&amp;</span> <span class="n">REQ_FUA</span><span class="p">)))</span>
		<span class="n">flush</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REQ_FUA</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">flush_flags</span> <span class="o">=</span> <span class="n">flush</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REQ_FLUSH</span> <span class="o">|</span> <span class="n">REQ_FUA</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_queue_flush</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">blk_queue_flush_queueable</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">bool</span> <span class="n">queueable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">flush_not_queueable</span> <span class="o">=</span> <span class="o">!</span><span class="n">queueable</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_queue_flush_queueable</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">blk_settings_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blk_max_low_pfn</span> <span class="o">=</span> <span class="n">max_low_pfn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">blk_max_pfn</span> <span class="o">=</span> <span class="n">max_pfn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">blk_settings_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
