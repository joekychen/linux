<!DOCTYPE html>
<html><head><title>joekychen/linux » block › elevator.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>elevator.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Block device elevator/IO-scheduler.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2000 Andrea Arcangeli &lt;andrea@suse.de&gt; SuSE</span>
<span class="cm"> *</span>
<span class="cm"> * 30042000 Jens Axboe &lt;axboe@kernel.dk&gt; :</span>
<span class="cm"> *</span>
<span class="cm"> * Split the elevator a bit so that it is possible to choose a different</span>
<span class="cm"> * one or even write a new &quot;plug in&quot;. There are three pieces:</span>
<span class="cm"> * - elevator_fn, inserts a new request in the queue list</span>
<span class="cm"> * - elevator_merge_fn, decides whether a new buffer can be merged with</span>
<span class="cm"> *   an existing request</span>
<span class="cm"> * - elevator_dequeue_fn, called when a request is taken off the active list</span>
<span class="cm"> *</span>
<span class="cm"> * 20082000 Dave Jones &lt;davej@suse.de&gt; :</span>
<span class="cm"> * Removed tests for max-bomb-segments, which was breaking elvtune</span>
<span class="cm"> *  when run without -bN</span>
<span class="cm"> *</span>
<span class="cm"> * Jens:</span>
<span class="cm"> * - Rework again to work with bio instead of buffer_heads</span>
<span class="cm"> * - loose bi_dev comparisons, partition handling is right now</span>
<span class="cm"> * - completely modularize elevator setup and teardown</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/elevator.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/blktrace_api.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>

<span class="cp">#include &lt;trace/events/block.h&gt;</span>

<span class="cp">#include &quot;blk.h&quot;</span>
<span class="cp">#include &quot;blk-cgroup.h&quot;</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">elv_list_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">elv_list</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Merge hash stuff.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">elv_hash_shift</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="cp">#define ELV_HASH_BLOCK(sec)	((sec) &gt;&gt; 3)</span>
<span class="cp">#define ELV_HASH_FN(sec)	\</span>
<span class="cp">		(hash_long(ELV_HASH_BLOCK((sec)), elv_hash_shift))</span>
<span class="cp">#define ELV_HASH_ENTRIES	(1 &lt;&lt; elv_hash_shift)</span>
<span class="cp">#define rq_hash_key(rq)		(blk_rq_pos(rq) + blk_rq_sectors(rq))</span>

<span class="cm">/*</span>
<span class="cm"> * Query io scheduler to see if the current process issuing bio may be</span>
<span class="cm"> * merged with rq.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">elv_iosched_allow_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_allow_merge_fn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_allow_merge_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * can we safely merge with this request?</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">elv_rq_merge_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blk_rq_merge_ok</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">bio</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elv_iosched_allow_merge</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">bio</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">elv_rq_merge_ok</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">elevator_type</span> <span class="o">*</span><span class="nf">elevator_find</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_type</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">elv_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">elevator_name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">e</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">elevator_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">elevator_type</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">elevator_owner</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">elevator_type</span> <span class="o">*</span><span class="nf">elevator_get</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_type</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elv_list_lock</span><span class="p">);</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">elevator_find</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elv_list_lock</span><span class="p">);</span>
		<span class="n">request_module</span><span class="p">(</span><span class="s">&quot;%s-iosched&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elv_list_lock</span><span class="p">);</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">elevator_find</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">elevator_owner</span><span class="p">))</span>
		<span class="n">e</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elv_list_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">chosen_elevator</span><span class="p">[</span><span class="n">ELV_NAME_MAX</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">elevator_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Be backwards-compatible with previous kernels, so users</span>
<span class="cm">	 * won&#39;t get the wrong elevator.</span>
<span class="cm">	 */</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">chosen_elevator</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chosen_elevator</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;elevator=&quot;</span><span class="p">,</span> <span class="n">elevator_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">elv_ktype</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="nf">elevator_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">elevator_type</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">eq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">eq</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">eq</span><span class="p">),</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">eq</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">eq</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
	<span class="n">kobject_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">elv_ktype</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="n">eq</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">)</span> <span class="o">*</span> <span class="n">ELV_HASH_ENTRIES</span><span class="p">,</span>
					<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ELV_HASH_ENTRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">eq</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">eq</span><span class="p">);</span>
	<span class="n">elevator_put</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">elevator_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elevator_queue</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
	<span class="n">elevator_put</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">elevator_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_type</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_head</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">last_merge</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">end_sector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">boundary_rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">elevator_get</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">chosen_elevator</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">elevator_get</span><span class="p">(</span><span class="n">chosen_elevator</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;I/O scheduler %s not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">chosen_elevator</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">elevator_get</span><span class="p">(</span><span class="n">CONFIG_DEFAULT_IOSCHED</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;Default I/O scheduler not found. &quot;</span> \
				<span class="s">&quot;Using noop.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">e</span> <span class="o">=</span> <span class="n">elevator_get</span><span class="p">(</span><span class="s">&quot;noop&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span> <span class="o">=</span> <span class="n">elevator_alloc</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_init_fn</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">elevator_init</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">elevator_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sysfs_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_exit_fn</span><span class="p">)</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_exit_fn</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">elevator_exit</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__elv_rqhash_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hlist_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">elv_rqhash_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ELV_ON_HASH</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
		<span class="n">__elv_rqhash_del</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">elv_rqhash_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ELV_ON_HASH</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">ELV_HASH_FN</span><span class="p">(</span><span class="n">rq_hash_key</span><span class="p">(</span><span class="n">rq</span><span class="p">))]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">elv_rqhash_reposition</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__elv_rqhash_del</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">elv_rqhash_add</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">elv_rqhash_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hash_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">ELV_HASH_FN</span><span class="p">(</span><span class="n">offset</span><span class="p">)];</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">hash_list</span><span class="p">,</span> <span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ELV_ON_HASH</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">rq_mergeable</span><span class="p">(</span><span class="n">rq</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">__elv_rqhash_del</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rq_hash_key</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">==</span> <span class="n">offset</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * RB-tree support functions for inserting/lookup/removal of requests</span>
<span class="cm"> * in a sorted RB tree.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">elv_rb_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">__rq</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">__rq</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">__rq</span><span class="p">))</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">__rq</span><span class="p">))</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">elv_rb_add</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">elv_rb_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">RB_EMPTY_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">));</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="n">RB_CLEAR_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">elv_rb_del</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">elv_rb_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">sector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rq</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sector</span> <span class="o">&lt;</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sector</span> <span class="o">&gt;</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">elv_rb_find</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Insert rq into dispatch queue of q.  Queue lock must be held on</span>
<span class="cm"> * entry.  rq is sort instead into the dispatch queue. To be used by</span>
<span class="cm"> * specific elevators.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">elv_dispatch_sort</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span> <span class="n">boundary</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stop_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">last_merge</span> <span class="o">==</span> <span class="n">rq</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">last_merge</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">elv_rqhash_del</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_sorted</span><span class="o">--</span><span class="p">;</span>

	<span class="n">boundary</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">end_sector</span><span class="p">;</span>
	<span class="n">stop_flags</span> <span class="o">=</span> <span class="n">REQ_SOFTBARRIER</span> <span class="o">|</span> <span class="n">REQ_STARTED</span><span class="p">;</span>
	<span class="n">list_for_each_prev</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">list_entry_rq</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq_data_dir</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rq_data_dir</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">stop_flags</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">boundary</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">boundary</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">boundary</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">queuelist</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">elv_dispatch_sort</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Insert rq into dispatch queue of q.  Queue lock must be held on</span>
<span class="cm"> * entry.  rq is added to the back of the dispatch queue. To be used by</span>
<span class="cm"> * specific elevators.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">elv_dispatch_add_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">last_merge</span> <span class="o">==</span> <span class="n">rq</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">last_merge</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">elv_rqhash_del</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_sorted</span><span class="o">--</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">end_sector</span> <span class="o">=</span> <span class="n">rq_end_sector</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">boundary_rq</span> <span class="o">=</span> <span class="n">rq</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">queuelist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_head</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">elv_dispatch_add_tail</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">elv_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">**</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">__rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Levels of merges:</span>
<span class="cm">	 * 	nomerges:  No merges at all attempted</span>
<span class="cm">	 * 	noxmerges: Only simple one-hit cache try</span>
<span class="cm">	 * 	merges:	   All merge tries attempted</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_queue_nomerges</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ELEVATOR_NO_MERGE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First try one-hit cache.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">last_merge</span> <span class="o">&amp;&amp;</span> <span class="n">elv_rq_merge_ok</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">last_merge</span><span class="p">,</span> <span class="n">bio</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">blk_try_merge</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">last_merge</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">ELEVATOR_NO_MERGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">last_merge</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_queue_noxmerges</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ELEVATOR_NO_MERGE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * See if our hash lookup can find a potential backmerge.</span>
<span class="cm">	 */</span>
	<span class="n">__rq</span> <span class="o">=</span> <span class="n">elv_rqhash_find</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__rq</span> <span class="o">&amp;&amp;</span> <span class="n">elv_rq_merge_ok</span><span class="p">(</span><span class="n">__rq</span><span class="p">,</span> <span class="n">bio</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">__rq</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ELEVATOR_BACK_MERGE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_merge_fn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_merge_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ELEVATOR_NO_MERGE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attempt to do an insertion back merge. Only check for the case where</span>
<span class="cm"> * we can append &#39;rq&#39; to an existing request, so we can throw &#39;rq&#39; away</span>
<span class="cm"> * afterwards.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if we merged, false otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">elv_attempt_insert_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">__rq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_queue_nomerges</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First try one-hit cache.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">last_merge</span> <span class="o">&amp;&amp;</span> <span class="n">blk_attempt_req_merge</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">last_merge</span><span class="p">,</span> <span class="n">rq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_queue_noxmerges</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * See if our hash lookup can find a potential backmerge.</span>
<span class="cm">	 */</span>
	<span class="n">__rq</span> <span class="o">=</span> <span class="n">elv_rqhash_find</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__rq</span> <span class="o">&amp;&amp;</span> <span class="n">blk_attempt_req_merge</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">__rq</span><span class="p">,</span> <span class="n">rq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">elv_merged_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_merged_fn</span><span class="p">)</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_merged_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">ELEVATOR_BACK_MERGE</span><span class="p">)</span>
		<span class="n">elv_rqhash_reposition</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">last_merge</span> <span class="o">=</span> <span class="n">rq</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">elv_merge_requests</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">next_sorted</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_SORTED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next_sorted</span> <span class="o">&amp;&amp;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_merge_req_fn</span><span class="p">)</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_merge_req_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

	<span class="n">elv_rqhash_reposition</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next_sorted</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">elv_rqhash_del</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_sorted</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">last_merge</span> <span class="o">=</span> <span class="n">rq</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">elv_bio_merged</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_bio_merged_fn</span><span class="p">)</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_bio_merged_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">elv_requeue_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * it already went through dequeue, we need to decrement the</span>
<span class="cm">	 * in_flight count again</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_account_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">[</span><span class="n">rq_is_sync</span><span class="p">(</span><span class="n">rq</span><span class="p">)]</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_SORTED</span><span class="p">)</span>
			<span class="n">elv_deactivate_rq</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REQ_STARTED</span><span class="p">;</span>

	<span class="n">__elv_add_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">ELEVATOR_INSERT_REQUEUE</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">elv_drain_elevator</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">printed</span><span class="p">;</span>

	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_dispatch_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_sorted</span> <span class="o">&amp;&amp;</span> <span class="n">printed</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: forced dispatching is broken &quot;</span>
		       <span class="s">&quot;(nr_sorted=%u), please report this</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">elevator_name</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_sorted</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__elv_add_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_block_rq_insert</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_SOFTBARRIER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* barriers are scheduling boundary, update end_sector */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_FS</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">end_sector</span> <span class="o">=</span> <span class="n">rq_end_sector</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">boundary_rq</span> <span class="o">=</span> <span class="n">rq</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_ELVPRIV</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">where</span> <span class="o">==</span> <span class="n">ELEVATOR_INSERT_SORT</span> <span class="o">||</span>
		     <span class="n">where</span> <span class="o">==</span> <span class="n">ELEVATOR_INSERT_SORT_MERGE</span><span class="p">))</span>
		<span class="n">where</span> <span class="o">=</span> <span class="n">ELEVATOR_INSERT_BACK</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">where</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ELEVATOR_INSERT_REQUEUE</span>:
	<span class="k">case</span> <span class="n">ELEVATOR_INSERT_FRONT</span>:
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">|=</span> <span class="n">REQ_SOFTBARRIER</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">queuelist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_head</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ELEVATOR_INSERT_BACK</span>:
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">|=</span> <span class="n">REQ_SOFTBARRIER</span><span class="p">;</span>
		<span class="n">elv_drain_elevator</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">queuelist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_head</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We kick the queue here for the following reasons.</span>
<span class="cm">		 * - The elevator might have returned NULL previously</span>
<span class="cm">		 *   to delay requests and returned them now.  As the</span>
<span class="cm">		 *   queue wasn&#39;t empty before this request, ll_rw_blk</span>
<span class="cm">		 *   won&#39;t run the queue on return, resulting in hang.</span>
<span class="cm">		 * - Usually, back inserted requests won&#39;t be merged</span>
<span class="cm">		 *   with anything.  There&#39;s no point in delaying queue</span>
<span class="cm">		 *   processing.</span>
<span class="cm">		 */</span>
		<span class="n">__blk_run_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ELEVATOR_INSERT_SORT_MERGE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * If we succeed in merging this request with one in the</span>
<span class="cm">		 * queue already, we are done - rq has now been freed,</span>
<span class="cm">		 * so no need to do anything further.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">elv_attempt_insert_merge</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELEVATOR_INSERT_SORT</span>:
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">!=</span> <span class="n">REQ_TYPE_FS</span> <span class="o">&amp;&amp;</span>
		       <span class="o">!</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">));</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">|=</span> <span class="n">REQ_SORTED</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_sorted</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq_mergeable</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">elv_rqhash_add</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">last_merge</span><span class="p">)</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">last_merge</span> <span class="o">=</span> <span class="n">rq</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Some ioscheds (cfq) run q-&gt;request_fn directly, so</span>
<span class="cm">		 * rq cannot be accessed after calling</span>
<span class="cm">		 * elevator_add_req_fn.</span>
<span class="cm">		 */</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_add_req_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ELEVATOR_INSERT_FLUSH</span>:
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">|=</span> <span class="n">REQ_SOFTBARRIER</span><span class="p">;</span>
		<span class="n">blk_insert_flush</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: bad insertion point %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__elv_add_request</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">elv_add_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__elv_add_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">elv_add_request</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">elv_latter_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_latter_req_fn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_latter_req_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">elv_former_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_former_req_fn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_former_req_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">elv_set_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_set_req_fn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_set_req_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">elv_put_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_put_req_fn</span><span class="p">)</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_put_req_fn</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">elv_may_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_may_queue_fn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_may_queue_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ELV_MQUEUE_MAY</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">elv_abort_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="n">blk_abort_flushes</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rq</span> <span class="o">=</span> <span class="n">list_entry_rq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_head</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">|=</span> <span class="n">REQ_QUIET</span><span class="p">;</span>
		<span class="n">trace_block_rq_abort</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Mark this request as started so we don&#39;t trigger</span>
<span class="cm">		 * any debug logic in the end I/O path.</span>
<span class="cm">		 */</span>
		<span class="n">blk_start_request</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="n">__blk_end_request_all</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">elv_abort_queue</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">elv_completed_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * request is released from the driver, io must be done</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_account_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">[</span><span class="n">rq_is_sync</span><span class="p">(</span><span class="n">rq</span><span class="p">)]</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_SORTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_completed_req_fn</span><span class="p">)</span>
			<span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_completed_req_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define to_elv(atr) container_of((atr), struct elv_fs_entry, attr)</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">elv_attr_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elv_fs_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">to_elv</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elevator_queue</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sysfs_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">?</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">page</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sysfs_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">elv_attr_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
	       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elv_fs_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">to_elv</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elevator_queue</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sysfs_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">?</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">sysfs_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sysfs_ops</span> <span class="n">elv_sysfs_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">elv_attr_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span>	<span class="o">=</span> <span class="n">elv_attr_store</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">elv_ktype</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sysfs_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">elv_sysfs_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">elevator_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">elv_register_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">kobject_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="s">&quot;iosched&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">elv_fs_entry</span> <span class="o">*</span><span class="n">attr</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">elevator_attrs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sysfs_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">attr</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">elv_register_queue</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">elv_unregister_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>

		<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_REMOVE</span><span class="p">);</span>
		<span class="n">kobject_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">elv_unregister_queue</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">elv_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">elevator_type</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">def</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

	<span class="cm">/* create icq_cache if requested */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">icq_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">icq_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_cq</span><span class="p">))</span> <span class="o">||</span>
		    <span class="n">WARN_ON</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">icq_align</span> <span class="o">&lt;</span> <span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_cq</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">snprintf</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">icq_cache_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">icq_cache_name</span><span class="p">),</span>
			 <span class="s">&quot;%s_io_cq&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">elevator_name</span><span class="p">);</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">icq_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">icq_cache_name</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">icq_size</span><span class="p">,</span>
						 <span class="n">e</span><span class="o">-&gt;</span><span class="n">icq_align</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">icq_cache</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* register, don&#39;t allow duplicate names */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elv_list_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">elevator_find</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">elevator_name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elv_list_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">icq_cache</span><span class="p">)</span>
			<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">icq_cache</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">elv_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elv_list_lock</span><span class="p">);</span>

	<span class="cm">/* print pretty message */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">elevator_name</span><span class="p">,</span> <span class="n">chosen_elevator</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="o">!*</span><span class="n">chosen_elevator</span> <span class="o">&amp;&amp;</span>
			 <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">elevator_name</span><span class="p">,</span> <span class="n">CONFIG_DEFAULT_IOSCHED</span><span class="p">)))</span>
				<span class="n">def</span> <span class="o">=</span> <span class="s">&quot; (default)&quot;</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;io scheduler %s registered%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">elevator_name</span><span class="p">,</span>
								<span class="n">def</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">elv_register</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">elv_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">elevator_type</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* unregister */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elv_list_lock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elv_list_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Destroy icq_cache if it exists.  icq&#39;s are RCU managed.  Make</span>
<span class="cm">	 * sure all RCU operations are complete before proceeding.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">icq_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_barrier</span><span class="p">();</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">icq_cache</span><span class="p">);</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">icq_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">elv_unregister</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * switch to new_e io scheduler. be careful not to introduce deadlocks -</span>
<span class="cm"> * we don&#39;t free the old io scheduler, before we have allocated what we</span>
<span class="cm"> * need for the new one. this way we have a chance of going back to the old</span>
<span class="cm"> * one, if the new one fails init for some reason.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">elevator_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elevator_type</span> <span class="o">*</span><span class="n">new_e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">registered</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Turn on BYPASS and drain all requests w/ elevator private data.</span>
<span class="cm">	 * Block layer doesn&#39;t call into a quiesced elevator - all requests</span>
<span class="cm">	 * are directly put on the dispatch list without elevator data</span>
<span class="cm">	 * using INSERT_BACK.  All requests have SOFTBARRIER set and no</span>
<span class="cm">	 * merge happens either.</span>
<span class="cm">	 */</span>
	<span class="n">blk_queue_bypass_start</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="cm">/* unregister and clear all auxiliary data of the old elevator */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">registered</span><span class="p">)</span>
		<span class="n">elv_unregister_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">ioc_clear_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="cm">/* allocate, init and register new elevator */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span> <span class="o">=</span> <span class="n">elevator_alloc</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">new_e</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_init</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">new_e</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_init_fn</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_init</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">registered</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">elv_register_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_register</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* done, kill the old one and finish */</span>
	<span class="n">elevator_exit</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
	<span class="n">blk_queue_bypass_end</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="n">blk_add_trace_msg</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="s">&quot;elv switch: %s&quot;</span><span class="p">,</span> <span class="n">new_e</span><span class="o">-&gt;</span><span class="n">elevator_name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_register:</span>
	<span class="n">elevator_exit</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">);</span>
<span class="nl">fail_init:</span>
	<span class="cm">/* switch failed, restore and re-register old elevator */</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
	<span class="n">elv_register_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="n">blk_queue_bypass_end</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Switch this queue to the given IO scheduler.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">elevator_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">elevator_name</span><span class="p">[</span><span class="n">ELV_NAME_MAX</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">elevator_type</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">elevator_name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">elevator_name</span><span class="p">));</span>
	<span class="n">e</span> <span class="o">=</span> <span class="n">elevator_get</span><span class="p">(</span><span class="n">strstrip</span><span class="p">(</span><span class="n">elevator_name</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;elevator: type %s not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">elevator_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">elevator_name</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">elevator_name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">elevator_put</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">elevator_switch</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">elevator_change</span><span class="p">);</span>

<span class="kt">ssize_t</span> <span class="nf">elv_iosched_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">elevator_change</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;elevator: switch to %s failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">ssize_t</span> <span class="nf">elv_iosched_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elevator_type</span> <span class="o">*</span><span class="n">elv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elevator_type</span> <span class="o">*</span><span class="n">__e</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span> <span class="o">||</span> <span class="o">!</span><span class="n">blk_queue_stackable</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;none</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">elv</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elv_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">__e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">elv_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">elv</span><span class="o">-&gt;</span><span class="n">elevator_name</span><span class="p">,</span> <span class="n">__e</span><span class="o">-&gt;</span><span class="n">elevator_name</span><span class="p">))</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;[%s] &quot;</span><span class="p">,</span> <span class="n">elv</span><span class="o">-&gt;</span><span class="n">elevator_name</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">__e</span><span class="o">-&gt;</span><span class="n">elevator_name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elv_list_lock</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">elv_rb_former_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rbprev</span> <span class="o">=</span> <span class="n">rb_prev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rbprev</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rb_entry_rq</span><span class="p">(</span><span class="n">rbprev</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">elv_rb_former_request</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">elv_rb_latter_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rbnext</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rbnext</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rb_entry_rq</span><span class="p">(</span><span class="n">rbnext</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">elv_rb_latter_request</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
