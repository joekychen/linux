<!DOCTYPE html>
<html><head><title>joekychen/linux » block › blk.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>blk.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef BLK_INTERNAL_H</span>
<span class="cp">#define BLK_INTERNAL_H</span>

<span class="cp">#include &lt;linux/idr.h&gt;</span>

<span class="cm">/* Amount of time in which a process may batch requests */</span>
<span class="cp">#define BLK_BATCH_TIME	(HZ/50UL)</span>

<span class="cm">/* Number of requests a &quot;batching&quot; process may submit */</span>
<span class="cp">#define BLK_BATCH_REQ	32</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">blk_requestq_cachep</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">blk_queue_ktype</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ida</span> <span class="n">blk_queue_ida</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__blk_get_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kobject_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">init_request_from_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">blk_rq_bio_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">blk_rq_append_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">blk_queue_bypass_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">blk_queue_bypass_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">blk_dequeue_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__blk_queue_free_tags</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">__blk_end_bidi_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_bytes</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bidi_bytes</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">blk_rq_timed_out_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">blk_delete_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">blk_add_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__generic_unplug_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Internal atomic flags for request handling</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">rq_atomic_flags</span> <span class="p">{</span>
	<span class="n">REQ_ATOM_COMPLETE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * EH timer and IO completion will both attempt to &#39;grab&#39; the request, make</span>
<span class="cm"> * sure that only one of them succeeds</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blk_mark_rq_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">REQ_ATOM_COMPLETE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">atomic_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_clear_rq_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">REQ_ATOM_COMPLETE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">atomic_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Internal elevator interface</span>
<span class="cm"> */</span>
<span class="cp">#define ELV_ON_HASH(rq)		(!hlist_unhashed(&amp;(rq)-&gt;hash))</span>

<span class="kt">void</span> <span class="n">blk_insert_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">blk_abort_flushes</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">__elv_next_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_head</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rq</span> <span class="o">=</span> <span class="n">list_entry_rq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_head</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Flush request is running and flush request isn&#39;t queueable</span>
<span class="cm">		 * in the drive, we can hold the queue till flush request is</span>
<span class="cm">		 * finished. Even we don&#39;t do this, driver can&#39;t dispatch next</span>
<span class="cm">		 * requests and will requeue them. And this can improve</span>
<span class="cm">		 * throughput too. For example, we have request flush1, write1,</span>
<span class="cm">		 * flush 2. flush1 is dispatched, then queue is hold, write1</span>
<span class="cm">		 * isn&#39;t inserted to queue. After flush1 is finished, flush2</span>
<span class="cm">		 * will be dispatched. Since disk cache is already clean,</span>
<span class="cm">		 * flush2 will be finished very soon, so looks like flush2 is</span>
<span class="cm">		 * folded to flush1.</span>
<span class="cm">		 * Since the queue is hold, a flag is set to indicate the queue</span>
<span class="cm">		 * should be restarted later. Please see flush_end_io() for</span>
<span class="cm">		 * details.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flush_pending_idx</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">flush_running_idx</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="n">queue_flush_queueable</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">flush_queue_delayed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">blk_queue_dead</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_dispatch_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">elv_activate_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_activate_req_fn</span><span class="p">)</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_activate_req_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">elv_deactivate_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_deactivate_req_fn</span><span class="p">)</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">elevator_deactivate_req_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_FAIL_IO_TIMEOUT</span>
<span class="kt">int</span> <span class="n">blk_should_fake_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">part_timeout_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">part_timeout_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blk_should_fake_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">ll_back_merge_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ll_front_merge_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> 
		      <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">attempt_back_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">attempt_front_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">blk_attempt_req_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">next</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">blk_recalc_rq_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">blk_rq_set_mixed_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">blk_rq_merge_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">blk_try_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">blk_queue_congestion_threshold</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">blk_dev_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Return the threshold (number of used requests) at which the queue is</span>
<span class="cm"> * considered to be congested.  It include a little hysteresis to keep the</span>
<span class="cm"> * context switch rate down.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">queue_congestion_on_threshold</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_congestion_on</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The threshold at which a queue is considered to be uncongested</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">queue_congestion_off_threshold</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_congestion_off</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Contribute to IO statistics IFF:</span>
<span class="cm"> *</span>
<span class="cm"> *	a) it&#39;s attached to a gendisk, and</span>
<span class="cm"> *	b) the queue had IO stats enabled when this request was started, and</span>
<span class="cm"> *	c) it&#39;s a file system request or a discard request</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blk_do_io_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rq_disk</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_IO_STAT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_FS</span> <span class="o">||</span>
	        <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Internal io_context interface</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">get_io_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">ioc</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">io_cq</span> <span class="o">*</span><span class="n">ioc_lookup_icq</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">io_cq</span> <span class="o">*</span><span class="n">ioc_create_icq</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			     <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ioc_clear_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">create_task_io_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * create_io_context - try to create task-&gt;io_context</span>
<span class="cm"> * @gfp_mask: allocation mask</span>
<span class="cm"> * @node: allocation node</span>
<span class="cm"> *</span>
<span class="cm"> * If %current-&gt;io_context is %NULL, allocate a new io_context and install</span>
<span class="cm"> * it.  Returns the current %current-&gt;io_context which may be %NULL if</span>
<span class="cm"> * allocation failed.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function can&#39;t be called with IRQ disabled because</span>
<span class="cm"> * task_lock which protects %current-&gt;io_context is IRQ-unsafe.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="nf">create_io_context</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">irqs_disabled</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">io_context</span><span class="p">))</span>
		<span class="n">create_task_io_context</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">io_context</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Internal throttling interface</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_BLK_DEV_THROTTLING</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">blk_throtl_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_throtl_drain</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blk_throtl_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blk_throtl_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_BLK_DEV_THROTTLING */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">blk_throtl_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_throtl_drain</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blk_throtl_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_throtl_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_BLK_DEV_THROTTLING */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* BLK_INTERNAL_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
