<!DOCTYPE html>
<html><head><title>joekychen/linux » block › blk-cgroup.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>blk-cgroup.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _BLK_CGROUP_H</span>
<span class="cp">#define _BLK_CGROUP_H</span>
<span class="cm">/*</span>
<span class="cm"> * Common Block IO controller cgroup interface</span>
<span class="cm"> *</span>
<span class="cm"> * Based on ideas and code from CFQ, CFS and BFQ:</span>
<span class="cm"> * Copyright (C) 2003 Jens Axboe &lt;axboe@kernel.dk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008 Fabio Checconi &lt;fabio@gandalf.sssup.it&gt;</span>
<span class="cm"> *		      Paolo Valente &lt;paolo.valente@unimore.it&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009 Vivek Goyal &lt;vgoyal@redhat.com&gt;</span>
<span class="cm"> * 	              Nauman Rafique &lt;nauman@google.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/cgroup.h&gt;</span>
<span class="cp">#include &lt;linux/u64_stats_sync.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/radix-tree.h&gt;</span>

<span class="cm">/* Max limits for throttle policy */</span>
<span class="cp">#define THROTL_IOPS_MAX		UINT_MAX</span>

<span class="cm">/* CFQ specific, out here for blkcg-&gt;cfq_weight */</span>
<span class="cp">#define CFQ_WEIGHT_MIN		10</span>
<span class="cp">#define CFQ_WEIGHT_MAX		1000</span>
<span class="cp">#define CFQ_WEIGHT_DEFAULT	500</span>

<span class="cp">#ifdef CONFIG_BLK_CGROUP</span>

<span class="k">enum</span> <span class="n">blkg_rwstat_type</span> <span class="p">{</span>
	<span class="n">BLKG_RWSTAT_READ</span><span class="p">,</span>
	<span class="n">BLKG_RWSTAT_WRITE</span><span class="p">,</span>
	<span class="n">BLKG_RWSTAT_SYNC</span><span class="p">,</span>
	<span class="n">BLKG_RWSTAT_ASYNC</span><span class="p">,</span>

	<span class="n">BLKG_RWSTAT_NR</span><span class="p">,</span>
	<span class="n">BLKG_RWSTAT_TOTAL</span> <span class="o">=</span> <span class="n">BLKG_RWSTAT_NR</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">blkcg_gq</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">blkcg</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span>	<span class="n">css</span><span class="p">;</span>
	<span class="n">spinlock_t</span>			<span class="n">lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">radix_tree_root</span>		<span class="n">blkg_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blkcg_gq</span>			<span class="o">*</span><span class="n">blkg_hint</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>		<span class="n">blkg_list</span><span class="p">;</span>

	<span class="cm">/* for policies to test whether associated blkcg has changed */</span>
	<span class="kt">uint64_t</span>			<span class="n">id</span><span class="p">;</span>

	<span class="cm">/* TODO: per-policy storage in blkcg */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">cfq_weight</span><span class="p">;</span>	<span class="cm">/* belongs to cfq */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">blkg_stat</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">u64_stats_sync</span>		<span class="n">syncp</span><span class="p">;</span>
	<span class="kt">uint64_t</span>			<span class="n">cnt</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">blkg_rwstat</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">u64_stats_sync</span>		<span class="n">syncp</span><span class="p">;</span>
	<span class="kt">uint64_t</span>			<span class="n">cnt</span><span class="p">[</span><span class="n">BLKG_RWSTAT_NR</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * A blkcg_gq (blkg) is association between a block cgroup (blkcg) and a</span>
<span class="cm"> * request_queue (q).  This is used by blkcg policies which need to track</span>
<span class="cm"> * information per blkcg - q pair.</span>
<span class="cm"> *</span>
<span class="cm"> * There can be multiple active blkcg policies and each has its private</span>
<span class="cm"> * data on each blkg, the size of which is determined by</span>
<span class="cm"> * blkcg_policy-&gt;pd_size.  blkcg core allocates and frees such areas</span>
<span class="cm"> * together with blkg and invokes pd_init/exit_fn() methods.</span>
<span class="cm"> *</span>
<span class="cm"> * Such private data must embed struct blkg_policy_data (pd) at the</span>
<span class="cm"> * beginning and pd_size can&#39;t be smaller than pd.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">blkg_policy_data</span> <span class="p">{</span>
	<span class="cm">/* the blkg this per-policy data belongs to */</span>
	<span class="k">struct</span> <span class="n">blkcg_gq</span>			<span class="o">*</span><span class="n">blkg</span><span class="p">;</span>

	<span class="cm">/* used during policy activation */</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">alloc_node</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* association between a blk cgroup and a request queue */</span>
<span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="p">{</span>
	<span class="cm">/* Pointer to the associated request_queue */</span>
	<span class="k">struct</span> <span class="n">request_queue</span>		<span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">q_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>		<span class="n">blkcg_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blkcg</span>			<span class="o">*</span><span class="n">blkcg</span><span class="p">;</span>
	<span class="cm">/* reference count */</span>
	<span class="kt">int</span>				<span class="n">refcnt</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">blkg_policy_data</span>		<span class="o">*</span><span class="n">pd</span><span class="p">[</span><span class="n">BLKCG_MAX_POLS</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">rcu_head</span>			<span class="n">rcu_head</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">blkcg_pol_init_pd_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">blkcg_pol_exit_pd_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">blkcg_pol_reset_pd_stats_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">blkcg_policy</span> <span class="p">{</span>
	<span class="kt">int</span>				<span class="n">plid</span><span class="p">;</span>
	<span class="cm">/* policy specific private data size */</span>
	<span class="kt">size_t</span>				<span class="n">pd_size</span><span class="p">;</span>
	<span class="cm">/* cgroup files for the policy */</span>
	<span class="k">struct</span> <span class="n">cftype</span>			<span class="o">*</span><span class="n">cftypes</span><span class="p">;</span>

	<span class="cm">/* operations */</span>
	<span class="n">blkcg_pol_init_pd_fn</span>		<span class="o">*</span><span class="n">pd_init_fn</span><span class="p">;</span>
	<span class="n">blkcg_pol_exit_pd_fn</span>		<span class="o">*</span><span class="n">pd_exit_fn</span><span class="p">;</span>
	<span class="n">blkcg_pol_reset_pd_stats_fn</span>	<span class="o">*</span><span class="n">pd_reset_stats_fn</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">blkcg</span> <span class="n">blkcg_root</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="n">cgroup_to_blkcg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgroup</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="n">bio_blkcg</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="n">blkcg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg_lookup_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="n">blkcg</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">blkcg_init_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">blkcg_drain_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">blkcg_exit_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

<span class="cm">/* Blkio controller policy registration */</span>
<span class="kt">int</span> <span class="n">blkcg_policy_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">blkcg_policy_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">blkcg_activate_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">blkcg_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">blkcg_deactivate_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">blkcg_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">blkcg_print_blkgs</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="n">blkcg</span><span class="p">,</span>
		       <span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">prfill</span><span class="p">)(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">blkg_policy_data</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">blkcg_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span><span class="p">,</span>
		       <span class="n">bool</span> <span class="n">show_total</span><span class="p">);</span>
<span class="n">u64</span> <span class="n">__blkg_prfill_u64</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">blkg_policy_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span> <span class="n">u64</span> <span class="n">v</span><span class="p">);</span>
<span class="n">u64</span> <span class="n">__blkg_prfill_rwstat</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">blkg_policy_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">blkg_rwstat</span> <span class="o">*</span><span class="n">rwstat</span><span class="p">);</span>
<span class="n">u64</span> <span class="n">blkg_prfill_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">blkg_policy_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">);</span>
<span class="n">u64</span> <span class="n">blkg_prfill_rwstat</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">blkg_policy_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">off</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">blkg_conf_ctx</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span>			<span class="o">*</span><span class="n">disk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blkcg_gq</span>			<span class="o">*</span><span class="n">blkg</span><span class="p">;</span>
	<span class="n">u64</span>				<span class="n">v</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">blkg_conf_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="n">blkcg</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">blkcg_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span> <span class="k">struct</span> <span class="n">blkg_conf_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">blkg_conf_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkg_conf_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * blkg_to_pdata - get policy private data</span>
<span class="cm"> * @blkg: blkg of interest</span>
<span class="cm"> * @pol: policy of interest</span>
<span class="cm"> *</span>
<span class="cm"> * Return pointer to private data associated with the @blkg-@pol pair.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">blkg_policy_data</span> <span class="o">*</span><span class="nf">blkg_to_pd</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">blkcg_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blkg</span> <span class="o">?</span> <span class="n">blkg</span><span class="o">-&gt;</span><span class="n">pd</span><span class="p">[</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">plid</span><span class="p">]</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdata_to_blkg - get blkg associated with policy private data</span>
<span class="cm"> * @pd: policy private data of interest</span>
<span class="cm"> *</span>
<span class="cm"> * @pd is policy private data.  Determine the blkg it&#39;s associated with.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="nf">pd_to_blkg</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkg_policy_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pd</span> <span class="o">?</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">blkg</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blkg_path - format cgroup path of blkg</span>
<span class="cm"> * @blkg: blkg of interest</span>
<span class="cm"> * @buf: target buffer</span>
<span class="cm"> * @buflen: target buffer length</span>
<span class="cm"> *</span>
<span class="cm"> * Format the path of the cgroup of @blkg into @buf.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blkg_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">cgroup_path</span><span class="p">(</span><span class="n">blkg</span><span class="o">-&gt;</span><span class="n">blkcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;&lt;unavailable&gt;&quot;</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blkg_get - get a blkg reference</span>
<span class="cm"> * @blkg: blkg to get</span>
<span class="cm"> *</span>
<span class="cm"> * The caller should be holding queue_lock and an existing reference.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blkg_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="n">blkg</span><span class="o">-&gt;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">blkg</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="n">blkg</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__blkg_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blkg_put - put a blkg reference</span>
<span class="cm"> * @blkg: blkg to put</span>
<span class="cm"> *</span>
<span class="cm"> * The caller should be holding queue_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blkg_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="n">blkg</span><span class="o">-&gt;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">blkg</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">blkg</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">)</span>
		<span class="n">__blkg_release</span><span class="p">(</span><span class="n">blkg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blkg_stat_add - add a value to a blkg_stat</span>
<span class="cm"> * @stat: target blkg_stat</span>
<span class="cm"> * @val: value to add</span>
<span class="cm"> *</span>
<span class="cm"> * Add @val to @stat.  The caller is responsible for synchronizing calls to</span>
<span class="cm"> * this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blkg_stat_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkg_stat</span> <span class="o">*</span><span class="n">stat</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64_stats_update_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">u64_stats_update_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blkg_stat_read - read the current value of a blkg_stat</span>
<span class="cm"> * @stat: blkg_stat to read</span>
<span class="cm"> *</span>
<span class="cm"> * Read the current value of @stat.  This function can be called without</span>
<span class="cm"> * synchroniztion and takes care of u64 atomicity.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">blkg_stat_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkg_stat</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">u64_stats_fetch_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">u64_stats_fetch_retry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">,</span> <span class="n">start</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blkg_stat_reset - reset a blkg_stat</span>
<span class="cm"> * @stat: blkg_stat to reset</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blkg_stat_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkg_stat</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blkg_rwstat_add - add a value to a blkg_rwstat</span>
<span class="cm"> * @rwstat: target blkg_rwstat</span>
<span class="cm"> * @rw: mask of REQ_{WRITE|SYNC}</span>
<span class="cm"> * @val: value to add</span>
<span class="cm"> *</span>
<span class="cm"> * Add @val to @rwstat.  The counters are chosen according to @rw.  The</span>
<span class="cm"> * caller is responsible for synchronizing calls to this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blkg_rwstat_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkg_rwstat</span> <span class="o">*</span><span class="n">rwstat</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64_stats_update_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwstat</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">REQ_WRITE</span><span class="p">)</span>
		<span class="n">rwstat</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">[</span><span class="n">BLKG_RWSTAT_WRITE</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rwstat</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">[</span><span class="n">BLKG_RWSTAT_READ</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">REQ_SYNC</span><span class="p">)</span>
		<span class="n">rwstat</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">[</span><span class="n">BLKG_RWSTAT_SYNC</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rwstat</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">[</span><span class="n">BLKG_RWSTAT_ASYNC</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">u64_stats_update_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwstat</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blkg_rwstat_read - read the current values of a blkg_rwstat</span>
<span class="cm"> * @rwstat: blkg_rwstat to read</span>
<span class="cm"> *</span>
<span class="cm"> * Read the current snapshot of @rwstat and return it as the return value.</span>
<span class="cm"> * This function can be called without synchronization and takes care of</span>
<span class="cm"> * u64 atomicity.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">blkg_rwstat</span> <span class="nf">blkg_rwstat_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkg_rwstat</span> <span class="o">*</span><span class="n">rwstat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blkg_rwstat</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">u64_stats_fetch_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwstat</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">rwstat</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">u64_stats_fetch_retry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwstat</span><span class="o">-&gt;</span><span class="n">syncp</span><span class="p">,</span> <span class="n">start</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blkg_rwstat_sum - read the total count of a blkg_rwstat</span>
<span class="cm"> * @rwstat: blkg_rwstat to read</span>
<span class="cm"> *</span>
<span class="cm"> * Return the total count of @rwstat regardless of the IO direction.  This</span>
<span class="cm"> * function can be called without synchronization and takes care of u64</span>
<span class="cm"> * atomicity.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">blkg_rwstat_sum</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkg_rwstat</span> <span class="o">*</span><span class="n">rwstat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blkg_rwstat</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">blkg_rwstat_read</span><span class="p">(</span><span class="n">rwstat</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">tmp</span><span class="p">.</span><span class="n">cnt</span><span class="p">[</span><span class="n">BLKG_RWSTAT_READ</span><span class="p">]</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">.</span><span class="n">cnt</span><span class="p">[</span><span class="n">BLKG_RWSTAT_WRITE</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blkg_rwstat_reset - reset a blkg_rwstat</span>
<span class="cm"> * @rwstat: blkg_rwstat to reset</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blkg_rwstat_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkg_rwstat</span> <span class="o">*</span><span class="n">rwstat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rwstat</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rwstat</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#else	</span><span class="cm">/* CONFIG_BLK_CGROUP */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">cgroup</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">blkg_policy_data</span> <span class="p">{</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="p">{</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">blkcg_policy</span> <span class="p">{</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="nf">cgroup_to_blkcg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgroup</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="nf">bio_blkcg</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="nf">blkg_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="n">blkcg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blkcg_init_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blkcg_drain_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blkcg_exit_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blkcg_policy_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blkcg_policy_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blkcg_activate_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">blkcg_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blkcg_deactivate_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">blkcg_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">blkg_policy_data</span> <span class="o">*</span><span class="nf">blkg_to_pd</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">blkcg_policy</span> <span class="o">*</span><span class="n">pol</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="nf">pd_to_blkg</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkg_policy_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">blkg_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blkg_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blkg_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_BLK_CGROUP */</span><span class="cp"></span>
<span class="cp">#endif	</span><span class="cm">/* _BLK_CGROUP_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
