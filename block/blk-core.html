<!DOCTYPE html>
<html><head><title>joekychen/linux » block › blk-core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>blk-core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 1991, 1992 Linus Torvalds</span>
<span class="cm"> * Copyright (C) 1994,      Karl Keyte: Added support for disk statistics</span>
<span class="cm"> * Elevator latency, (C) 2000  Andrea Arcangeli &lt;andrea@suse.de&gt; SuSE</span>
<span class="cm"> * Queue request tables / lock, selectable elevator, Jens Axboe &lt;axboe@suse.de&gt;</span>
<span class="cm"> * kernel-doc documentation started by NeilBrown &lt;neilb@cse.unsw.edu.au&gt;</span>
<span class="cm"> *	-  July2000</span>
<span class="cm"> * bio rewrite, highmem i/o, etc, Jens Axboe &lt;axboe@suse.de&gt; - may 2001</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This handles all read/write requests to block devices</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/task_io_accounting_ops.h&gt;</span>
<span class="cp">#include &lt;linux/fault-inject.h&gt;</span>
<span class="cp">#include &lt;linux/list_sort.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/block.h&gt;</span>

<span class="cp">#include &quot;blk.h&quot;</span>
<span class="cp">#include &quot;blk-cgroup.h&quot;</span>

<span class="n">EXPORT_TRACEPOINT_SYMBOL_GPL</span><span class="p">(</span><span class="n">block_bio_remap</span><span class="p">);</span>
<span class="n">EXPORT_TRACEPOINT_SYMBOL_GPL</span><span class="p">(</span><span class="n">block_rq_remap</span><span class="p">);</span>
<span class="n">EXPORT_TRACEPOINT_SYMBOL_GPL</span><span class="p">(</span><span class="n">block_bio_complete</span><span class="p">);</span>

<span class="n">DEFINE_IDA</span><span class="p">(</span><span class="n">blk_queue_ida</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * For the allocated request tables</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">request_cachep</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * For queue allocation</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">blk_requestq_cachep</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Controlling structure to kblockd</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">kblockd_workqueue</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">drive_stat_acct</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_io</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rw</span> <span class="o">=</span> <span class="n">rq_data_dir</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blk_do_io_stat</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">part_stat_lock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_io</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">part</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">part</span><span class="p">;</span>
		<span class="n">part_stat_inc</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">merges</span><span class="p">[</span><span class="n">rw</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">part</span> <span class="o">=</span> <span class="n">disk_map_sector_rcu</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rq_disk</span><span class="p">,</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hd_struct_try_get</span><span class="p">(</span><span class="n">part</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The partition is already being removed,</span>
<span class="cm">			 * the request will be accounted on the disk only</span>
<span class="cm">			 *</span>
<span class="cm">			 * We take a reference on disk-&gt;part0 although that</span>
<span class="cm">			 * partition will never be deleted, so we can treat</span>
<span class="cm">			 * it as any other partition.</span>
<span class="cm">			 */</span>
			<span class="n">part</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rq_disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">;</span>
			<span class="n">hd_struct_get</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">part_round_stats</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">part</span><span class="p">);</span>
		<span class="n">part_inc_in_flight</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">rw</span><span class="p">);</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">part</span> <span class="o">=</span> <span class="n">part</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">part_stat_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">blk_queue_congestion_threshold</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>

	<span class="n">nr</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_requests</span> <span class="o">-</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_requests</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_requests</span><span class="p">)</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_requests</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_congestion_on</span> <span class="o">=</span> <span class="n">nr</span><span class="p">;</span>

	<span class="n">nr</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_requests</span> <span class="o">-</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_requests</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_requests</span> <span class="o">/</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_congestion_off</span> <span class="o">=</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blk_get_backing_dev_info - get the address of a queue&#39;s backing_dev_info</span>
<span class="cm"> * @bdev:	device</span>
<span class="cm"> *</span>
<span class="cm"> * Locates the passed device&#39;s request queue and returns the address of its</span>
<span class="cm"> * backing_dev_info</span>
<span class="cm"> *</span>
<span class="cm"> * Will return NULL if the request queue cannot be located.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="nf">blk_get_backing_dev_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_get_backing_dev_info</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">blk_rq_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rq</span><span class="p">));</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">queuelist</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">timeout_list</span><span class="p">);</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">__sector</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector_t</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
	<span class="n">RB_CLEAR_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">__cmd</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">=</span> <span class="n">BLK_MAX_CDB</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">ref_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">set_start_time_ns</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">part</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_rq_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">req_bio_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nbytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">BIO_UPTODATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BIO_UPTODATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nbytes</span> <span class="o">&gt;</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: want %u bytes done, %u left</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">);</span>
		<span class="n">nbytes</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_QUIET</span><span class="p">))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BIO_QUIET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">);</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span> <span class="o">-=</span> <span class="n">nbytes</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_integrity</span><span class="p">(</span><span class="n">bio</span><span class="p">))</span>
		<span class="n">bio_integrity_advance</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>

	<span class="cm">/* don&#39;t actually finish bio if it&#39;s part of flush sequence */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_FLUSH_SEQ</span><span class="p">))</span>
		<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">blk_dump_rq_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: dev %s: type=%x, flags=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rq_disk</span> <span class="o">?</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rq_disk</span><span class="o">-&gt;</span><span class="n">disk_name</span> <span class="o">:</span> <span class="s">&quot;?&quot;</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span><span class="p">,</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;  sector %llu, nr/cnr %u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span>
	       <span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">blk_rq_cur_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;  bio %p, biotail %p, buffer %p, len %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">rq</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">biotail</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_BLOCK_PC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;  cdb: &quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bit</span> <span class="o">&lt;</span> <span class="n">BLK_MAX_CDB</span><span class="p">;</span> <span class="n">bit</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">[</span><span class="n">bit</span><span class="p">]);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_dump_rq_flags</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">blk_delay_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="n">q</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request_queue</span><span class="p">,</span> <span class="n">delay_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">__blk_run_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blk_delay_queue - restart queueing after defined interval</span>
<span class="cm"> * @q:		The &amp;struct request_queue in question</span>
<span class="cm"> * @msecs:	Delay in msecs</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Sometimes queueing needs to be postponed for a little while, to allow</span>
<span class="cm"> *   resources to come back. This function will make sure that queueing is</span>
<span class="cm"> *   restarted around the specified time.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_delay_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">kblockd_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">delay_work</span><span class="p">,</span>
				<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">msecs</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_delay_queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_start_queue - restart a previously stopped queue</span>
<span class="cm"> * @q:    The &amp;struct request_queue in question</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   blk_start_queue() will clear the stop flag on the queue, and call</span>
<span class="cm"> *   the request_fn for the queue if it was in a stopped state when</span>
<span class="cm"> *   entered. Also see blk_stop_queue(). Queue lock must be held.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">blk_start_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="n">queue_flag_clear</span><span class="p">(</span><span class="n">QUEUE_FLAG_STOPPED</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="n">__blk_run_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_start_queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_stop_queue - stop a queue</span>
<span class="cm"> * @q:    The &amp;struct request_queue in question</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   The Linux block layer assumes that a block driver will consume all</span>
<span class="cm"> *   entries on the request queue when the request_fn strategy is called.</span>
<span class="cm"> *   Often this will not happen, because of hardware limitations (queue</span>
<span class="cm"> *   depth settings). If a device driver gets a &#39;queue full&#39; response,</span>
<span class="cm"> *   or if it simply chooses not to queue more I/O at one point, it can</span>
<span class="cm"> *   call this function to prevent the request_fn from being called until</span>
<span class="cm"> *   the driver has signalled it&#39;s ready to go again. This happens by calling</span>
<span class="cm"> *   blk_start_queue() to restart queue operations. Queue lock must be held.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">blk_stop_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">delay_work</span><span class="p">);</span>
	<span class="n">queue_flag_set</span><span class="p">(</span><span class="n">QUEUE_FLAG_STOPPED</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_stop_queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_sync_queue - cancel any pending callbacks on a queue</span>
<span class="cm"> * @q: the queue</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     The block layer may perform asynchronous callback activity</span>
<span class="cm"> *     on a queue, such as calling the unplug function after a timeout.</span>
<span class="cm"> *     A block device may call blk_sync_queue to ensure that any</span>
<span class="cm"> *     such activity is cancelled, thus allowing it to release resources</span>
<span class="cm"> *     that the callbacks might use. The caller must already have made sure</span>
<span class="cm"> *     that its -&gt;make_request_fn will not re-add plugging prior to calling</span>
<span class="cm"> *     this function.</span>
<span class="cm"> *</span>
<span class="cm"> *     This function does not cancel any asynchronous activity arising</span>
<span class="cm"> *     out of elevator or throttling code. That would require elevaotor_exit()</span>
<span class="cm"> *     and blkcg_exit_queue() to be called with queue lock initialized.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_sync_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">delay_work</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_sync_queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __blk_run_queue - run a single device queue</span>
<span class="cm"> * @q:	The queue to run</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    See @blk_run_queue. This variant must be called with the queue lock</span>
<span class="cm"> *    held and interrupts disabled.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__blk_run_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">blk_queue_stopped</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">request_fn</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__blk_run_queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_run_queue_async - run a single device queue in workqueue context</span>
<span class="cm"> * @q:	The queue to run</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    Tells kblockd to perform the equivalent of @blk_run_queue on behalf</span>
<span class="cm"> *    of us.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_run_queue_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">blk_queue_stopped</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">__cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">delay_work</span><span class="p">);</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">kblockd_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">delay_work</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_run_queue_async</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_run_queue - run a single device queue</span>
<span class="cm"> * @q: The queue to run</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    Invoke request handling on this queue, if it has pending work to do.</span>
<span class="cm"> *    May be used to restart queueing when a request has completed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_run_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__blk_run_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_run_queue</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">blk_put_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_put_queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_drain_queue - drain requests from request_queue</span>
<span class="cm"> * @q: queue to drain</span>
<span class="cm"> * @drain_all: whether to drain all requests or only the ones w/ ELVPRIV</span>
<span class="cm"> *</span>
<span class="cm"> * Drain requests from @q.  If @drain_all is set, all requests are drained.</span>
<span class="cm"> * If not, only ELVPRIV requests are drained.  The caller is responsible</span>
<span class="cm"> * for ensuring that no new requests which need to be drained are queued.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_drain_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">bool</span> <span class="n">drain_all</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">drain</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The caller might be trying to drain @q before its</span>
<span class="cm">		 * elevator is initialized.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">)</span>
			<span class="n">elv_drain_elevator</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

		<span class="n">blkcg_drain_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * This function might be called on a queue which failed</span>
<span class="cm">		 * driver init after queue creation or is not yet fully</span>
<span class="cm">		 * active yet.  Some drivers (e.g. fd and loop) get unhappy</span>
<span class="cm">		 * in such cases.  Kick queue iff dispatch queue has</span>
<span class="cm">		 * something on it and @q has request_fn set.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_head</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">request_fn</span><span class="p">)</span>
			<span class="n">__blk_run_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

		<span class="n">drain</span> <span class="o">|=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">.</span><span class="n">elvpriv</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Unfortunately, requests are queued at and tracked from</span>
<span class="cm">		 * multiple places and there&#39;s no single counter which can</span>
<span class="cm">		 * be drained.  Check all the queues and counters.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drain_all</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">drain</span> <span class="o">|=</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_head</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">drain</span> <span class="o">|=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">drain</span> <span class="o">|=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">drain</span> <span class="o">|=</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flush_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drain</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * With queue marked dead, any woken up waiter will fail the</span>
<span class="cm">	 * allocation path, so the wakeup chaining is lost and we&#39;re</span>
<span class="cm">	 * left with hung waiters. We need to wake up those waiters.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">request_fn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">.</span><span class="n">wait</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">.</span><span class="n">wait</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_bypass_start - enter queue bypass mode</span>
<span class="cm"> * @q: queue of interest</span>
<span class="cm"> *</span>
<span class="cm"> * In bypass mode, only the dispatch FIFO queue of @q is used.  This</span>
<span class="cm"> * function makes @q enter bypass mode and drains all requests which were</span>
<span class="cm"> * throttled or issued before.  On return, it&#39;s guaranteed that no request</span>
<span class="cm"> * is being throttled or has ELVPRIV set and blk_queue_bypass() %true</span>
<span class="cm"> * inside queue or RCU read lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_queue_bypass_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">drain</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">drain</span> <span class="o">=</span> <span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">bypass_depth</span><span class="o">++</span><span class="p">;</span>
	<span class="n">queue_flag_set</span><span class="p">(</span><span class="n">QUEUE_FLAG_BYPASS</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blk_drain_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="cm">/* ensure blk_queue_bypass() is %true inside RCU read lock */</span>
		<span class="n">synchronize_rcu</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_queue_bypass_start</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_queue_bypass_end - leave queue bypass mode</span>
<span class="cm"> * @q: queue of interest</span>
<span class="cm"> *</span>
<span class="cm"> * Leave bypass mode and restore the normal queueing behavior.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_queue_bypass_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">bypass_depth</span><span class="p">)</span>
		<span class="n">queue_flag_clear</span><span class="p">(</span><span class="n">QUEUE_FLAG_BYPASS</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">bypass_depth</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_queue_bypass_end</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_cleanup_queue - shutdown a request queue</span>
<span class="cm"> * @q: request queue to shutdown</span>
<span class="cm"> *</span>
<span class="cm"> * Mark @q DEAD, drain all pending requests, destroy and put it.  All</span>
<span class="cm"> * future requests will be failed immediately with -ENODEV.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_cleanup_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">;</span>

	<span class="cm">/* mark @q DEAD, no new request or merges will be allowed afterwards */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sysfs_lock</span><span class="p">);</span>
	<span class="n">queue_flag_set_unlocked</span><span class="p">(</span><span class="n">QUEUE_FLAG_DEAD</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Dead queue is permanently in bypass mode till released.  Note</span>
<span class="cm">	 * that, unlike blk_queue_bypass_start(), we aren&#39;t performing</span>
<span class="cm">	 * synchronize_rcu() after entering bypass mode to avoid the delay</span>
<span class="cm">	 * as some drivers create and destroy a lot of queues while</span>
<span class="cm">	 * probing.  This is still safe because blk_release_queue() will be</span>
<span class="cm">	 * called only after the queue refcnt drops to zero and nothing,</span>
<span class="cm">	 * RCU or not, would be traversing the queue by then.</span>
<span class="cm">	 */</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">bypass_depth</span><span class="o">++</span><span class="p">;</span>
	<span class="n">queue_flag_set</span><span class="p">(</span><span class="n">QUEUE_FLAG_BYPASS</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

	<span class="n">queue_flag_set</span><span class="p">(</span><span class="n">QUEUE_FLAG_NOMERGES</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="n">queue_flag_set</span><span class="p">(</span><span class="n">QUEUE_FLAG_NOXMERGES</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="n">queue_flag_set</span><span class="p">(</span><span class="n">QUEUE_FLAG_DEAD</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="cm">/* drain all requests queued before DEAD marking */</span>
	<span class="n">blk_drain_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="cm">/* @q won&#39;t process any more request, flush async actions */</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">.</span><span class="n">laptop_mode_wb_timer</span><span class="p">);</span>
	<span class="n">blk_sync_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">__queue_lock</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">__queue_lock</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* @q is and will stay empty, shutdown and put */</span>
	<span class="n">blk_put_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_cleanup_queue</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">blk_init_free_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_list</span> <span class="o">*</span><span class="n">rl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">rq_pool</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rl</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">BLK_RW_SYNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">rl</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">BLK_RW_ASYNC</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rl</span><span class="o">-&gt;</span><span class="n">starved</span><span class="p">[</span><span class="n">BLK_RW_SYNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">rl</span><span class="o">-&gt;</span><span class="n">starved</span><span class="p">[</span><span class="n">BLK_RW_ASYNC</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rl</span><span class="o">-&gt;</span><span class="n">elvpriv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">[</span><span class="n">BLK_RW_SYNC</span><span class="p">]);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">[</span><span class="n">BLK_RW_ASYNC</span><span class="p">]);</span>

	<span class="n">rl</span><span class="o">-&gt;</span><span class="n">rq_pool</span> <span class="o">=</span> <span class="n">mempool_create_node</span><span class="p">(</span><span class="n">BLKDEV_MIN_RQ</span><span class="p">,</span> <span class="n">mempool_alloc_slab</span><span class="p">,</span>
				<span class="n">mempool_free_slab</span><span class="p">,</span> <span class="n">request_cachep</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">rq_pool</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="nf">blk_alloc_queue</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blk_alloc_queue_node</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_alloc_queue</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="nf">blk_alloc_queue_node</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">q</span> <span class="o">=</span> <span class="n">kmem_cache_alloc_node</span><span class="p">(</span><span class="n">blk_requestq_cachep</span><span class="p">,</span>
				<span class="n">gfp_mask</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">,</span> <span class="n">node_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">ida_simple_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blk_queue_ida</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_q</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">.</span><span class="n">ra_pages</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">VM_MAX_READAHEAD</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">/</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">.</span><span class="n">capabilities</span> <span class="o">=</span> <span class="n">BDI_CAP_MAP_COPY</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;block&quot;</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">node_id</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">bdi_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_id</span><span class="p">;</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">.</span><span class="n">laptop_mode_wb_timer</span><span class="p">,</span>
		    <span class="n">laptop_mode_timer_fn</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">q</span><span class="p">);</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">,</span> <span class="n">blk_rq_timed_out_timer</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">q</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_head</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">timeout_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">icq_list</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_BLK_CGROUP</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">blkg_list</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flush_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flush_queue</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flush_data_in_flight</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">delay_work</span><span class="p">,</span> <span class="n">blk_delay_work</span><span class="p">);</span>

	<span class="n">kobject_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk_queue_ktype</span><span class="p">);</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sysfs_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">__queue_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * By default initialize queue_lock to internal lock and driver can</span>
<span class="cm">	 * override it later if need be.</span>
<span class="cm">	 */</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">__queue_lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A queue starts its life with bypass turned on to avoid</span>
<span class="cm">	 * unnecessary bypass on/off overhead and nasty surprises during</span>
<span class="cm">	 * init.  The initial bypass will be finished at the end of</span>
<span class="cm">	 * blk_init_allocated_queue().</span>
<span class="cm">	 */</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">bypass_depth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">QUEUE_FLAG_BYPASS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blkcg_init_queue</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_id</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">q</span><span class="p">;</span>

<span class="nl">fail_id:</span>
	<span class="n">ida_simple_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blk_queue_ida</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
<span class="nl">fail_q:</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">blk_requestq_cachep</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_alloc_queue_node</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_init_queue  - prepare a request queue for use with a block device</span>
<span class="cm"> * @rfn:  The function to be called to process requests that have been</span>
<span class="cm"> *        placed on the queue.</span>
<span class="cm"> * @lock: Request queue spin lock</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    If a block device wishes to use the standard request handling procedures,</span>
<span class="cm"> *    which sorts requests and coalesces adjacent requests, then it must</span>
<span class="cm"> *    call blk_init_queue().  The function @rfn will be called when there</span>
<span class="cm"> *    are requests on the queue that need to be processed.  If the device</span>
<span class="cm"> *    supports plugging, then @rfn may not be called immediately when requests</span>
<span class="cm"> *    are available on the queue, but may be called at some time later instead.</span>
<span class="cm"> *    Plugged queues are generally unplugged when a buffer belonging to one</span>
<span class="cm"> *    of the requests on the queue is needed, or due to memory pressure.</span>
<span class="cm"> *</span>
<span class="cm"> *    @rfn is not required, or even expected, to remove all requests off the</span>
<span class="cm"> *    queue, but only as many as it can handle at a time.  If it does leave</span>
<span class="cm"> *    requests on the queue, it is responsible for arranging that the requests</span>
<span class="cm"> *    get dealt with eventually.</span>
<span class="cm"> *</span>
<span class="cm"> *    The queue spin lock must be held while manipulating the requests on the</span>
<span class="cm"> *    request queue; this lock will be taken also from interrupt context, so irq</span>
<span class="cm"> *    disabling is needed for it.</span>
<span class="cm"> *</span>
<span class="cm"> *    Function returns a pointer to the initialized request queue, or %NULL if</span>
<span class="cm"> *    it didn&#39;t succeed.</span>
<span class="cm"> *</span>
<span class="cm"> * Note:</span>
<span class="cm"> *    blk_init_queue() must be paired with a blk_cleanup_queue() call</span>
<span class="cm"> *    when the block device is deactivated (such as at module unload).</span>
<span class="cm"> **/</span>

<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="nf">blk_init_queue</span><span class="p">(</span><span class="n">request_fn_proc</span> <span class="o">*</span><span class="n">rfn</span><span class="p">,</span> <span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blk_init_queue_node</span><span class="p">(</span><span class="n">rfn</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_init_queue</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span>
<span class="nf">blk_init_queue_node</span><span class="p">(</span><span class="n">request_fn_proc</span> <span class="o">*</span><span class="n">rfn</span><span class="p">,</span> <span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">uninit_q</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="n">uninit_q</span> <span class="o">=</span> <span class="n">blk_alloc_queue_node</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">node_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uninit_q</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">q</span> <span class="o">=</span> <span class="n">blk_init_allocated_queue</span><span class="p">(</span><span class="n">uninit_q</span><span class="p">,</span> <span class="n">rfn</span><span class="p">,</span> <span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">)</span>
		<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">uninit_q</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">q</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_init_queue_node</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span>
<span class="nf">blk_init_allocated_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">request_fn_proc</span> <span class="o">*</span><span class="n">rfn</span><span class="p">,</span>
			 <span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_init_free_list</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">request_fn</span>		<span class="o">=</span> <span class="n">rfn</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">prep_rq_fn</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">unprep_rq_fn</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_flags</span>		<span class="o">=</span> <span class="n">QUEUE_FLAG_DEFAULT</span><span class="p">;</span>

	<span class="cm">/* Override internal queue lock with supplied lock pointer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span>		<span class="o">=</span> <span class="n">lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This also sets hw/phys segments, boundary and size</span>
<span class="cm">	 */</span>
	<span class="n">blk_queue_make_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">blk_queue_bio</span><span class="p">);</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">sg_reserved_size</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>

	<span class="cm">/* init elevator */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">elevator_init</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">blk_queue_congestion_threshold</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="cm">/* all done, end the initial bypass */</span>
	<span class="n">blk_queue_bypass_end</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">q</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_init_allocated_queue</span><span class="p">);</span>

<span class="n">bool</span> <span class="nf">blk_get_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">blk_queue_dead</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">__blk_get_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_get_queue</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_free_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_ELVPRIV</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">elv_put_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">elv</span><span class="p">.</span><span class="n">icq</span><span class="p">)</span>
			<span class="n">put_io_context</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">elv</span><span class="p">.</span><span class="n">icq</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">.</span><span class="n">rq_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ioc_batching returns true if the ioc is a valid batching request and</span>
<span class="cm"> * should be given priority access to a request.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ioc_batching</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">ioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure the process is able to allocate at least 1 request</span>
<span class="cm">	 * even if the batch times out, otherwise we could theoretically</span>
<span class="cm">	 * lose wakeups.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">nr_batch_requests</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_batching</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">nr_batch_requests</span> <span class="o">&gt;</span> <span class="mi">0</span>
		<span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">last_waited</span> <span class="o">+</span> <span class="n">BLK_BATCH_TIME</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ioc_set_batching sets ioc to be a new &quot;batcher&quot; if it is not one. This</span>
<span class="cm"> * will cause the process to be a &quot;batcher&quot; on all queues in the system. This</span>
<span class="cm"> * is the behaviour we want though - once it gets a wakeup it should be given</span>
<span class="cm"> * a nice run.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ioc_set_batching</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">ioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span> <span class="o">||</span> <span class="n">ioc_batching</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">ioc</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">nr_batch_requests</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_batching</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">last_waited</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__freed_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_list</span> <span class="o">*</span><span class="n">rl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">sync</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">queue_congestion_off_threshold</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
		<span class="n">blk_clear_queue_congested</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">sync</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">sync</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_requests</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">[</span><span class="n">sync</span><span class="p">]))</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">[</span><span class="n">sync</span><span class="p">]);</span>

		<span class="n">blk_clear_queue_full</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">sync</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A request has just been released.  Account for it, update the full and</span>
<span class="cm"> * congestion status, wake up any waiters.   Called under q-&gt;queue_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">freed_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_list</span> <span class="o">*</span><span class="n">rl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sync</span> <span class="o">=</span> <span class="n">rw_is_sync</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">rl</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">sync</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REQ_ELVPRIV</span><span class="p">)</span>
		<span class="n">rl</span><span class="o">-&gt;</span><span class="n">elvpriv</span><span class="o">--</span><span class="p">;</span>

	<span class="n">__freed_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">sync</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">starved</span><span class="p">[</span><span class="n">sync</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]))</span>
		<span class="n">__freed_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">sync</span> <span class="o">^</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine if elevator data should be initialized when allocating the</span>
<span class="cm"> * request associated with @bio.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">blk_rq_should_init_elevator</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Flush requests do not use the elevator so skip initialization.</span>
<span class="cm">	 * This allows a request to share the flush and elevator data.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REQ_FLUSH</span> <span class="o">|</span> <span class="n">REQ_FUA</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rq_ioc - determine io_context for request allocation</span>
<span class="cm"> * @bio: request being allocated is for this bio (can be %NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Determine io_context to use for request allocation for @bio.  May return</span>
<span class="cm"> * %NULL if %current-&gt;io_context doesn&#39;t exist.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="nf">rq_ioc</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_BLK_CGROUP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span> <span class="o">&amp;&amp;</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_ioc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_ioc</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">io_context</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_request - get a free request</span>
<span class="cm"> * @q: request_queue to allocate request from</span>
<span class="cm"> * @rw_flags: RW and SYNC flags</span>
<span class="cm"> * @bio: bio to allocate request for (can be %NULL)</span>
<span class="cm"> * @gfp_mask: allocation mask</span>
<span class="cm"> *</span>
<span class="cm"> * Get a free request from @q.  This function may fail under memory</span>
<span class="cm"> * pressure or if @q is dead.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be callled with @q-&gt;queue_lock held and,</span>
<span class="cm"> * Returns %NULL on failure, with @q-&gt;queue_lock held.</span>
<span class="cm"> * Returns !%NULL on success, with @q-&gt;queue_lock *not held*.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">get_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw_flags</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_list</span> <span class="o">*</span><span class="n">rl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elevator_type</span> <span class="o">*</span><span class="n">et</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_cq</span> <span class="o">*</span><span class="n">icq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">bool</span> <span class="n">is_sync</span> <span class="o">=</span> <span class="n">rw_is_sync</span><span class="p">(</span><span class="n">rw_flags</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">retried</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">may_queue</span><span class="p">;</span>
<span class="nl">retry:</span>
	<span class="n">et</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">ioc</span> <span class="o">=</span> <span class="n">rq_ioc</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">blk_queue_dead</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">may_queue</span> <span class="o">=</span> <span class="n">elv_may_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rw_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">may_queue</span> <span class="o">==</span> <span class="n">ELV_MQUEUE_NO</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">rq_starved</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">is_sync</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">queue_congestion_on_threshold</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">is_sync</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_requests</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We want ioc to record batching state.  If it&#39;s</span>
<span class="cm">			 * not already there, creating a new one requires</span>
<span class="cm">			 * dropping queue_lock, which in turn requires</span>
<span class="cm">			 * retesting conditions to avoid queue hang.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">retried</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
				<span class="n">create_io_context</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
				<span class="n">retried</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * The queue will fill after this allocation, so set</span>
<span class="cm">			 * it as full, and mark this process as &quot;batching&quot;.</span>
<span class="cm">			 * This process will be allowed to complete a batch of</span>
<span class="cm">			 * requests, others will be blocked.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blk_queue_full</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">is_sync</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ioc_set_batching</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">ioc</span><span class="p">);</span>
				<span class="n">blk_set_queue_full</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">is_sync</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">may_queue</span> <span class="o">!=</span> <span class="n">ELV_MQUEUE_MUST</span>
						<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ioc_batching</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">ioc</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * The queue is full and the allocating</span>
<span class="cm">					 * process is not a &quot;batcher&quot;, and not</span>
<span class="cm">					 * exempted by the IO scheduler</span>
<span class="cm">					 */</span>
					<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">blk_set_queue_congested</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">is_sync</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only allow batching queuers to allocate up to 50% over the defined</span>
<span class="cm">	 * limit of requests, otherwise we could have thousands of requests</span>
<span class="cm">	 * allocated with any setting of -&gt;nr_requests</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">is_sync</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">nr_requests</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rl</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">is_sync</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">rl</span><span class="o">-&gt;</span><span class="n">starved</span><span class="p">[</span><span class="n">is_sync</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Decide whether the new request will be managed by elevator.  If</span>
<span class="cm">	 * so, mark @rw_flags and increment elvpriv.  Non-zero elvpriv will</span>
<span class="cm">	 * prevent the current elevator from being destroyed until the new</span>
<span class="cm">	 * request is freed.  This guarantees icq&#39;s won&#39;t be destroyed and</span>
<span class="cm">	 * makes creating new ones safe.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Also, lookup icq while holding queue_lock.  If it doesn&#39;t exist,</span>
<span class="cm">	 * it will be created after releasing queue_lock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_should_init_elevator</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">blk_queue_bypass</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rw_flags</span> <span class="o">|=</span> <span class="n">REQ_ELVPRIV</span><span class="p">;</span>
		<span class="n">rl</span><span class="o">-&gt;</span><span class="n">elvpriv</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">et</span><span class="o">-&gt;</span><span class="n">icq_cache</span> <span class="o">&amp;&amp;</span> <span class="n">ioc</span><span class="p">)</span>
			<span class="n">icq</span> <span class="o">=</span> <span class="n">ioc_lookup_icq</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_queue_io_stat</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
		<span class="n">rw_flags</span> <span class="o">|=</span> <span class="n">REQ_IO_STAT</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="cm">/* allocate and init request */</span>
	<span class="n">rq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">.</span><span class="n">rq_pool</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_alloc</span><span class="p">;</span>

	<span class="n">blk_rq_init</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">=</span> <span class="n">rw_flags</span> <span class="o">|</span> <span class="n">REQ_ALLOCED</span><span class="p">;</span>

	<span class="cm">/* init elvpriv */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rw_flags</span> <span class="o">&amp;</span> <span class="n">REQ_ELVPRIV</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">et</span><span class="o">-&gt;</span><span class="n">icq_cache</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">icq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">create_io_context</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="n">ioc</span> <span class="o">=</span> <span class="n">rq_ioc</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">fail_elvpriv</span><span class="p">;</span>

			<span class="n">icq</span> <span class="o">=</span> <span class="n">ioc_create_icq</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">icq</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">fail_elvpriv</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">elv</span><span class="p">.</span><span class="n">icq</span> <span class="o">=</span> <span class="n">icq</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">elv_set_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">fail_elvpriv</span><span class="p">;</span>

		<span class="cm">/* @rq-&gt;elv.icq holds io_context until @rq is freed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">icq</span><span class="p">)</span>
			<span class="n">get_io_context</span><span class="p">(</span><span class="n">icq</span><span class="o">-&gt;</span><span class="n">ioc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="cm">/*</span>
<span class="cm">	 * ioc may be NULL here, and ioc_batching will be false. That&#39;s</span>
<span class="cm">	 * OK, if the queue is under the request limit then requests need</span>
<span class="cm">	 * not count toward the nr_batch_requests limit. There will always</span>
<span class="cm">	 * be some limit enforced by BLK_BATCH_TIME.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc_batching</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">ioc</span><span class="p">))</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">nr_batch_requests</span><span class="o">--</span><span class="p">;</span>

	<span class="n">trace_block_getrq</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">rw_flags</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>

<span class="nl">fail_elvpriv:</span>
	<span class="cm">/*</span>
<span class="cm">	 * elvpriv init failed.  ioc, icq and elvpriv aren&#39;t mempool backed</span>
<span class="cm">	 * and may fail indefinitely under memory pressure and thus</span>
<span class="cm">	 * shouldn&#39;t stall IO.  Treat this request as !elvpriv.  This will</span>
<span class="cm">	 * disturb iosched and blkcg but weird is bettern than dead.</span>
<span class="cm">	 */</span>
	<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: request aux data allocation failed, iosched may be disturbed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev_name</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">.</span><span class="n">dev</span><span class="p">));</span>

	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REQ_ELVPRIV</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">elv</span><span class="p">.</span><span class="n">icq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">rl</span><span class="o">-&gt;</span><span class="n">elvpriv</span><span class="o">--</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">fail_alloc:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allocation failed presumably due to memory. Undo anything we</span>
<span class="cm">	 * might have messed up.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Allocating task should really be put onto the front of the wait</span>
<span class="cm">	 * queue, but this is pretty rare.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">freed_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rw_flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * in the very unlikely event that allocation failed and no</span>
<span class="cm">	 * requests for this direction was pending, mark us starved so that</span>
<span class="cm">	 * freeing of a request in the other direction will notice</span>
<span class="cm">	 * us. another possible fix would be to split the rq mempool into</span>
<span class="cm">	 * READ and WRITE</span>
<span class="cm">	 */</span>
<span class="nl">rq_starved:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">is_sync</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">rl</span><span class="o">-&gt;</span><span class="n">starved</span><span class="p">[</span><span class="n">is_sync</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_request_wait - get a free request with retry</span>
<span class="cm"> * @q: request_queue to allocate request from</span>
<span class="cm"> * @rw_flags: RW and SYNC flags</span>
<span class="cm"> * @bio: bio to allocate request for (can be %NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Get a free request from @q.  This function keeps retrying under memory</span>
<span class="cm"> * pressure and fails iff @q is dead.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be callled with @q-&gt;queue_lock held and,</span>
<span class="cm"> * Returns %NULL on failure, with @q-&gt;queue_lock held.</span>
<span class="cm"> * Returns !%NULL on success, with @q-&gt;queue_lock *not held*.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">get_request_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw_flags</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">bool</span> <span class="n">is_sync</span> <span class="o">=</span> <span class="n">rw_is_sync</span><span class="p">(</span><span class="n">rw_flags</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">get_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rw_flags</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">request_list</span> <span class="o">*</span><span class="n">rl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">blk_queue_dead</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">prepare_to_wait_exclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">[</span><span class="n">is_sync</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span>
				<span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>

		<span class="n">trace_block_sleeprq</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">rw_flags</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">io_schedule</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * After sleeping, we become a &quot;batching&quot; process and</span>
<span class="cm">		 * will be able to allocate at least one request, and</span>
<span class="cm">		 * up to a big batch of them for a small period time.</span>
<span class="cm">		 * See ioc_batching, ioc_set_batching</span>
<span class="cm">		 */</span>
		<span class="n">create_io_context</span><span class="p">(</span><span class="n">GFP_NOIO</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">ioc_set_batching</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">io_context</span><span class="p">);</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">[</span><span class="n">is_sync</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

		<span class="n">rq</span> <span class="o">=</span> <span class="n">get_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rw_flags</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">blk_get_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rw</span> <span class="o">!=</span> <span class="n">READ</span> <span class="o">&amp;&amp;</span> <span class="n">rw</span> <span class="o">!=</span> <span class="n">WRITE</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">)</span>
		<span class="n">rq</span> <span class="o">=</span> <span class="n">get_request_wait</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rq</span> <span class="o">=</span> <span class="n">get_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="p">)</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* q-&gt;queue_lock is unlocked at this point */</span>

	<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_get_request</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_make_request - given a bio, allocate a corresponding struct request.</span>
<span class="cm"> * @q: target request queue</span>
<span class="cm"> * @bio:  The bio describing the memory mappings that will be submitted for IO.</span>
<span class="cm"> *        It may be a chained-bio properly constructed by block/bio layer.</span>
<span class="cm"> * @gfp_mask: gfp flags to be used for memory allocation</span>
<span class="cm"> *</span>
<span class="cm"> * blk_make_request is the parallel of generic_make_request for BLOCK_PC</span>
<span class="cm"> * type commands. Where the struct request needs to be farther initialized by</span>
<span class="cm"> * the caller. It is passed a &amp;struct bio, which describes the memory info of</span>
<span class="cm"> * the I/O transfer.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller of blk_make_request must make sure that bi_io_vec</span>
<span class="cm"> * are set to describe the memory buffers. That bio_data_dir() will return</span>
<span class="cm"> * the needed direction of the request. (And all bio&#39;s in the passed bio-chain</span>
<span class="cm"> * are properly set accordingly)</span>
<span class="cm"> *</span>
<span class="cm"> * If called under none-sleepable conditions, mapped bio buffers must not</span>
<span class="cm"> * need bouncing, by calling the appropriate masked or flagged allocator,</span>
<span class="cm"> * suitable for the target device. Otherwise the call to blk_queue_bounce will</span>
<span class="cm"> * BUG.</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING: When allocating/cloning a bio-chain, careful consideration should be</span>
<span class="cm"> * given to how you allocate bios. In particular, you cannot use __GFP_WAIT for</span>
<span class="cm"> * anything but the first bio in the chain. Otherwise you risk waiting for IO</span>
<span class="cm"> * completion of a bio that hasn&#39;t been submitted yet, thus resulting in a</span>
<span class="cm"> * deadlock. Alternatively bios should be allocated using bio_kmalloc() instead</span>
<span class="cm"> * of bio_alloc(), as that avoids the mempool deadlock.</span>
<span class="cm"> * If possible a big IO should be split into smaller parts when allocation</span>
<span class="cm"> * fails. Partial allocation should not be an error, or you risk a live-lock.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">blk_make_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
				 <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">blk_get_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">),</span> <span class="n">gfp_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">for_each_bio</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bounce_bio</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">blk_queue_bounce</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bounce_bio</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">blk_rq_append_bio</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">bounce_bio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">blk_put_request</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_make_request</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_requeue_request - put a request back on queue</span>
<span class="cm"> * @q:		request queue where request should be inserted</span>
<span class="cm"> * @rq:		request to be inserted</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    Drivers often keep queueing requests until the hardware cannot accept</span>
<span class="cm"> *    more, when that condition happens we need to put the request back</span>
<span class="cm"> *    on the queue. Must be called with queue lock held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_requeue_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blk_delete_timer</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">blk_clear_rq_complete</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">trace_block_rq_requeue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_tagged</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
		<span class="n">blk_queue_end_tag</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">blk_queued_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>

	<span class="n">elv_requeue_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_requeue_request</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_acct_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">where</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">drive_stat_acct</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">__elv_add_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">part_round_stats_single</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">==</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">stamp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">part_in_flight</span><span class="p">(</span><span class="n">part</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__part_stat_add</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">time_in_queue</span><span class="p">,</span>
				<span class="n">part_in_flight</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">stamp</span><span class="p">));</span>
		<span class="n">__part_stat_add</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">io_ticks</span><span class="p">,</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">stamp</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">part</span><span class="o">-&gt;</span><span class="n">stamp</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * part_round_stats() - Round off the performance stats on a struct disk_stats.</span>
<span class="cm"> * @cpu: cpu number for stats access</span>
<span class="cm"> * @part: target partition</span>
<span class="cm"> *</span>
<span class="cm"> * The average IO queue length and utilisation statistics are maintained</span>
<span class="cm"> * by observing the current state of the queue length and the amount of</span>
<span class="cm"> * time it has been in this state for.</span>
<span class="cm"> *</span>
<span class="cm"> * Normally, that accounting is done on IO completion, but that can result</span>
<span class="cm"> * in more than a second&#39;s worth of IO being accounted for within any one</span>
<span class="cm"> * second, leading to &gt;100% utilisation.  To deal with that, we call this</span>
<span class="cm"> * function to do a round-off before returning the results when reading</span>
<span class="cm"> * /proc/diskstats.  This accounts immediately for all queue usage up to</span>
<span class="cm"> * the current jiffies and restarts the counters again.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">part_round_stats</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">part</span><span class="o">-&gt;</span><span class="n">partno</span><span class="p">)</span>
		<span class="n">part_round_stats_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">part_to_disk</span><span class="p">(</span><span class="n">part</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
	<span class="n">part_round_stats_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">part_round_stats</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * queue lock must be held</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__blk_put_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">--</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">elv_completed_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

	<span class="cm">/* this is a bio leak */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Request may not have originated from ll_rw_blk. if not,</span>
<span class="cm">	 * it didn&#39;t come out of our reserved rq pools</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_ALLOCED</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queuelist</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">));</span>

		<span class="n">blk_free_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="n">freed_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__blk_put_request</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">blk_put_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__blk_put_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_put_request</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_add_request_payload - add a payload to a request</span>
<span class="cm"> * @rq: request to update</span>
<span class="cm"> * @page: page backing the payload</span>
<span class="cm"> * @len: length of the payload.</span>
<span class="cm"> *</span>
<span class="cm"> * This allows to later add a payload to an already submitted request by</span>
<span class="cm"> * a block driver.  The driver needs to take care of freeing the payload</span>
<span class="cm"> * itself.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this is a quite horrible hack and nothing but handling of</span>
<span class="cm"> * discard requests should ever use it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_add_request_payload</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">;</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="o">-&gt;</span><span class="n">bv_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="o">-&gt;</span><span class="n">bv_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="o">-&gt;</span><span class="n">bv_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_phys_segments</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">__data_len</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">resid_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_phys_segments</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">bio_data</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_add_request_payload</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">bio_attempt_back_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">ff</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_FAILFAST_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ll_back_merge_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">bio</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">trace_block_bio_backmerge</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_FAILFAST_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ff</span><span class="p">)</span>
		<span class="n">blk_rq_set_mixed_merge</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">biotail</span><span class="o">-&gt;</span><span class="n">bi_next</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">biotail</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">__data_len</span> <span class="o">+=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ioprio</span> <span class="o">=</span> <span class="n">ioprio_best</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ioprio</span><span class="p">,</span> <span class="n">bio_prio</span><span class="p">(</span><span class="n">bio</span><span class="p">));</span>

	<span class="n">drive_stat_acct</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">bio_attempt_front_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">ff</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_FAILFAST_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ll_front_merge_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">bio</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">trace_block_bio_frontmerge</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_FAILFAST_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ff</span><span class="p">)</span>
		<span class="n">blk_rq_set_mixed_merge</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * may not be valid. if the low level driver said</span>
<span class="cm">	 * it didn&#39;t need a bounce buffer then it better</span>
<span class="cm">	 * not touch req-&gt;buffer either...</span>
<span class="cm">	 */</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">bio_data</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">__sector</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">__data_len</span> <span class="o">+=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ioprio</span> <span class="o">=</span> <span class="n">ioprio_best</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ioprio</span><span class="p">,</span> <span class="n">bio_prio</span><span class="p">(</span><span class="n">bio</span><span class="p">));</span>

	<span class="n">drive_stat_acct</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * attempt_plug_merge - try to merge with %current&#39;s plugged list</span>
<span class="cm"> * @q: request_queue new bio is being queued at</span>
<span class="cm"> * @bio: new bio being queued</span>
<span class="cm"> * @request_count: out parameter for number of traversed plugged requests</span>
<span class="cm"> *</span>
<span class="cm"> * Determine whether @bio being queued on @q can be merged with a request</span>
<span class="cm"> * on %current&#39;s plugged list.  Returns %true if merge was successful,</span>
<span class="cm"> * otherwise %false.</span>
<span class="cm"> *</span>
<span class="cm"> * Plugging coalesces IOs from the same issuer for the same purpose without</span>
<span class="cm"> * going through @q-&gt;queue_lock.  As such it&#39;s more of an issuing mechanism</span>
<span class="cm"> * than scheduling, and the request, while may have elvpriv data, is not</span>
<span class="cm"> * added on the elevator at this point.  In addition, we don&#39;t have</span>
<span class="cm"> * reliable access to the elevator outside queue lock.  Only check basic</span>
<span class="cm"> * merging parameters without querying the elevator.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">attempt_plug_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">request_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blk_plug</span> <span class="o">*</span><span class="n">plug</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">plug</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">plug</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">plug</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="o">*</span><span class="n">request_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">plug</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">queuelist</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">el_ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span> <span class="o">==</span> <span class="n">q</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">request_count</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span> <span class="o">!=</span> <span class="n">q</span> <span class="o">||</span> <span class="o">!</span><span class="n">blk_rq_merge_ok</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">bio</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">el_ret</span> <span class="o">=</span> <span class="n">blk_try_merge</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">el_ret</span> <span class="o">==</span> <span class="n">ELEVATOR_BACK_MERGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">bio_attempt_back_merge</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">el_ret</span> <span class="o">==</span> <span class="n">ELEVATOR_FRONT_MERGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">bio_attempt_front_merge</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_request_from_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">=</span> <span class="n">REQ_TYPE_FS</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">|=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_COMMON_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_RAHEAD</span><span class="p">)</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">|=</span> <span class="n">REQ_FAILFAST_MASK</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">__sector</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ioprio</span> <span class="o">=</span> <span class="n">bio_prio</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="n">blk_rq_bio_prep</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">blk_queue_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">bool</span> <span class="n">sync</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_SYNC</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">blk_plug</span> <span class="o">*</span><span class="n">plug</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">el_ret</span><span class="p">,</span> <span class="n">rw_flags</span><span class="p">,</span> <span class="n">where</span> <span class="o">=</span> <span class="n">ELEVATOR_INSERT_SORT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">request_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * low level driver can indicate that it wants pages above a</span>
<span class="cm">	 * certain limit bounced to low memory (ie for highmem, or even</span>
<span class="cm">	 * ISA dma in theory)</span>
<span class="cm">	 */</span>
	<span class="n">blk_queue_bounce</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REQ_FLUSH</span> <span class="o">|</span> <span class="n">REQ_FUA</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">where</span> <span class="o">=</span> <span class="n">ELEVATOR_INSERT_FLUSH</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">get_rq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if we can merge with the plugged list before grabbing</span>
<span class="cm">	 * any locks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attempt_plug_merge</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">request_count</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="n">el_ret</span> <span class="o">=</span> <span class="n">elv_merge</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">el_ret</span> <span class="o">==</span> <span class="n">ELEVATOR_BACK_MERGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bio_attempt_back_merge</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">bio</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">elv_bio_merged</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attempt_back_merge</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">))</span>
				<span class="n">elv_merged_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">el_ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">el_ret</span> <span class="o">==</span> <span class="n">ELEVATOR_FRONT_MERGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bio_attempt_front_merge</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">bio</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">elv_bio_merged</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attempt_front_merge</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">))</span>
				<span class="n">elv_merged_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">el_ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">get_rq:</span>
	<span class="cm">/*</span>
<span class="cm">	 * This sync check and mask will be re-done in init_request_from_bio(),</span>
<span class="cm">	 * but we need to set it earlier to expose the sync flag to the</span>
<span class="cm">	 * rq allocator and io schedulers.</span>
<span class="cm">	 */</span>
	<span class="n">rw_flags</span> <span class="o">=</span> <span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sync</span><span class="p">)</span>
		<span class="n">rw_flags</span> <span class="o">|=</span> <span class="n">REQ_SYNC</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Grab a free request. This is might sleep but can not fail.</span>
<span class="cm">	 * Returns with the queue unlocked.</span>
<span class="cm">	 */</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">get_request_wait</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rw_flags</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>	<span class="cm">/* @q is dead */</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * After dropping the lock and possibly sleeping here, our request</span>
<span class="cm">	 * may now be mergeable after it had proven unmergeable (above).</span>
<span class="cm">	 * We don&#39;t worry about that case for efficiency. It won&#39;t happen</span>
<span class="cm">	 * often, and the elevators are able to handle it.</span>
<span class="cm">	 */</span>
	<span class="n">init_request_from_bio</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">QUEUE_FLAG_SAME_COMP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_flags</span><span class="p">))</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>

	<span class="n">plug</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">plug</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">plug</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this is the first request added after a plug, fire</span>
<span class="cm">		 * of a plug trace. If others have been added before, check</span>
<span class="cm">		 * if we have multiple devices in this plug. If so, make a</span>
<span class="cm">		 * note to sort the list before dispatch.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
			<span class="n">trace_block_plug</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">plug</span><span class="o">-&gt;</span><span class="n">should_sort</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">__rq</span><span class="p">;</span>

				<span class="n">__rq</span> <span class="o">=</span> <span class="n">list_entry_rq</span><span class="p">(</span><span class="n">plug</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">__rq</span><span class="o">-&gt;</span><span class="n">q</span> <span class="o">!=</span> <span class="n">q</span><span class="p">)</span>
					<span class="n">plug</span><span class="o">-&gt;</span><span class="n">should_sort</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">request_count</span> <span class="o">&gt;=</span> <span class="n">BLK_MAX_REQUEST_COUNT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">blk_flush_plug_list</span><span class="p">(</span><span class="n">plug</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
				<span class="n">trace_block_plug</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">queuelist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">plug</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">drive_stat_acct</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">add_acct_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>
		<span class="n">__blk_run_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_queue_bio</span><span class="p">);</span>	<span class="cm">/* for device mapper only */</span>

<span class="cm">/*</span>
<span class="cm"> * If bio-&gt;bi_dev is a partition, remap the location</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">blk_partition_remap</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_sectors</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bdev</span> <span class="o">!=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_contains</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_part</span><span class="p">;</span>

		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">start_sect</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_contains</span><span class="p">;</span>

		<span class="n">trace_block_bio_remap</span><span class="p">(</span><span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">),</span> <span class="n">bio</span><span class="p">,</span>
				      <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">,</span>
				      <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">-</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">start_sect</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_bad_sector</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;attempt to access beyond end of device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: rw=%ld, want=%Lu, limit=%Lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bdevname</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
			<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">+</span> <span class="n">bio_sectors</span><span class="p">(</span><span class="n">bio</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">));</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">BIO_EOF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_FAIL_MAKE_REQUEST</span>

<span class="k">static</span> <span class="n">DECLARE_FAULT_ATTR</span><span class="p">(</span><span class="n">fail_make_request</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_fail_make_request</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">setup_fault_attr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fail_make_request</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;fail_make_request=&quot;</span><span class="p">,</span> <span class="n">setup_fail_make_request</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">should_fail_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">make_it_fail</span> <span class="o">&amp;&amp;</span> <span class="n">should_fail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fail_make_request</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">fail_make_request_debugfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">fault_create_debugfs_attr</span><span class="p">(</span><span class="s">&quot;fail_make_request&quot;</span><span class="p">,</span>
						<span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fail_make_request</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="o">?</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">late_initcall</span><span class="p">(</span><span class="n">fail_make_request_debugfs</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_FAIL_MAKE_REQUEST */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">should_fail_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_FAIL_MAKE_REQUEST */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Check whether this bio extends beyond the end of the device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bio_check_eod</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span> <span class="n">maxsector</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_sectors</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Test device or partition size, when known. */</span>
	<span class="n">maxsector</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxsector</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sector_t</span> <span class="n">sector</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">maxsector</span> <span class="o">&lt;</span> <span class="n">nr_sectors</span> <span class="o">||</span> <span class="n">maxsector</span> <span class="o">-</span> <span class="n">nr_sectors</span> <span class="o">&lt;</span> <span class="n">sector</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This may well happen - the kernel calls bread()</span>
<span class="cm">			 * without checking the size of the device, e.g., when</span>
<span class="cm">			 * mounting a device.</span>
<span class="cm">			 */</span>
			<span class="n">handle_bad_sector</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline_for_stack</span> <span class="n">bool</span>
<span class="nf">generic_make_request_checks</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_sectors</span> <span class="o">=</span> <span class="n">bio_sectors</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_check_eod</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">nr_sectors</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">end_io</span><span class="p">;</span>

	<span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;generic_make_request: Trying to access &quot;</span>
			<span class="s">&quot;nonexistent block-device %s (%Lu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bdevname</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">end_io</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="n">nr_sectors</span> <span class="o">&gt;</span> <span class="n">queue_max_hw_sectors</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;bio too big device %s (%u &gt; %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">bdevname</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
		       <span class="n">bio_sectors</span><span class="p">(</span><span class="n">bio</span><span class="p">),</span>
		       <span class="n">queue_max_hw_sectors</span><span class="p">(</span><span class="n">q</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">end_io</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">part</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="o">-&gt;</span><span class="n">bd_part</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">should_fail_request</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">should_fail_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part_to_disk</span><span class="p">(</span><span class="n">part</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">,</span>
				<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">end_io</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this device has partitions, remap block n</span>
<span class="cm">	 * of partition p to block n+start(p) of the disk.</span>
<span class="cm">	 */</span>
	<span class="n">blk_partition_remap</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_integrity_enabled</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bio_integrity_prep</span><span class="p">(</span><span class="n">bio</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">end_io</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_check_eod</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">nr_sectors</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">end_io</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Filter flush bio&#39;s early so that make_request based</span>
<span class="cm">	 * drivers without flush support don&#39;t have to worry</span>
<span class="cm">	 * about them.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REQ_FLUSH</span> <span class="o">|</span> <span class="n">REQ_FUA</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flush_flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">REQ_FLUSH</span> <span class="o">|</span> <span class="n">REQ_FUA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_sectors</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">end_io</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">blk_queue_discard</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">((</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_SECURE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	      <span class="o">!</span><span class="n">blk_queue_secdiscard</span><span class="p">(</span><span class="n">q</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end_io</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_throtl_bio</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>	<span class="cm">/* throttled, will be resubmitted later */</span>

	<span class="n">trace_block_bio_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

<span class="nl">end_io:</span>
	<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * generic_make_request - hand a buffer to its device driver for I/O</span>
<span class="cm"> * @bio:  The bio describing the location in memory and on the device.</span>
<span class="cm"> *</span>
<span class="cm"> * generic_make_request() is used to make I/O requests of block</span>
<span class="cm"> * devices. It is passed a &amp;struct bio, which describes the I/O that needs</span>
<span class="cm"> * to be done.</span>
<span class="cm"> *</span>
<span class="cm"> * generic_make_request() does not return any status.  The</span>
<span class="cm"> * success/failure status of the request, along with notification of</span>
<span class="cm"> * completion, is delivered asynchronously through the bio-&gt;bi_end_io</span>
<span class="cm"> * function described (one day) else where.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller of generic_make_request must make sure that bi_io_vec</span>
<span class="cm"> * are set to describe the memory buffer, and that bi_dev and bi_sector are</span>
<span class="cm"> * set to describe the device address, and the</span>
<span class="cm"> * bi_end_io and optionally bi_private are set to describe how</span>
<span class="cm"> * completion notification should be signaled.</span>
<span class="cm"> *</span>
<span class="cm"> * generic_make_request and the drivers it calls may use bi_next if this</span>
<span class="cm"> * bio happens to be merged with someone else, and may resubmit the bio to</span>
<span class="cm"> * a lower device by calling into generic_make_request recursively, which</span>
<span class="cm"> * means the bio should NOT be touched after the call to -&gt;make_request_fn.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">generic_make_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="n">bio_list_on_stack</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">generic_make_request_checks</span><span class="p">(</span><span class="n">bio</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We only want one -&gt;make_request_fn to be active at a time, else</span>
<span class="cm">	 * stack usage with stacked devices could be a problem.  So use</span>
<span class="cm">	 * current-&gt;bio_list to keep a list of requests submited by a</span>
<span class="cm">	 * make_request_fn function.  current-&gt;bio_list is also used as a</span>
<span class="cm">	 * flag to say if generic_make_request is currently active in this</span>
<span class="cm">	 * task or not.  If it is NULL, then no make_request is active.  If</span>
<span class="cm">	 * it is non-NULL, then a make_request is active, and new requests</span>
<span class="cm">	 * should be added at the tail</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">bio_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio_list_add</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">bio_list</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* following loop may be a bit non-obvious, and so deserves some</span>
<span class="cm">	 * explanation.</span>
<span class="cm">	 * Before entering the loop, bio-&gt;bi_next is NULL (as all callers</span>
<span class="cm">	 * ensure that) so we have a list with a single bio.</span>
<span class="cm">	 * We pretend that we have just taken it off a longer list, so</span>
<span class="cm">	 * we assign bio_list to a pointer to the bio_list_on_stack,</span>
<span class="cm">	 * thus initialising the bio_list of new bios to be</span>
<span class="cm">	 * added.  -&gt;make_request() may indeed add some more bios</span>
<span class="cm">	 * through a recursive call to generic_make_request.  If it</span>
<span class="cm">	 * did, we find a non-NULL value in bio_list and re-enter the loop</span>
<span class="cm">	 * from the top.  In this case we really did just take the bio</span>
<span class="cm">	 * of the top of the list (no pretending) and so remove it from</span>
<span class="cm">	 * bio_list, and call into -&gt;make_request() again.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span><span class="p">);</span>
	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bio_list_on_stack</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">bio_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bio_list_on_stack</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">);</span>

		<span class="n">q</span><span class="o">-&gt;</span><span class="n">make_request_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

		<span class="n">bio</span> <span class="o">=</span> <span class="n">bio_list_pop</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">bio_list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">bio_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* deactivate */</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_make_request</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * submit_bio - submit a bio to the block device layer for I/O</span>
<span class="cm"> * @rw: whether to %READ or %WRITE, or maybe to %READA (read ahead)</span>
<span class="cm"> * @bio: The &amp;struct bio which describes the I/O</span>
<span class="cm"> *</span>
<span class="cm"> * submit_bio() is very similar in purpose to generic_make_request(), and</span>
<span class="cm"> * uses that function to do most of the work. Both are fairly rough</span>
<span class="cm"> * interfaces; @bio must be presetup and ready for I/O.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">submit_bio</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bio_sectors</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">|=</span> <span class="n">rw</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If it&#39;s a regular read/write or a barrier with data attached,</span>
<span class="cm">	 * go through the normal accounting stuff before submission.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio_has_data</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">count_vm_events</span><span class="p">(</span><span class="n">PGPGOUT</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">task_io_account_read</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">);</span>
			<span class="n">count_vm_events</span><span class="p">(</span><span class="n">PGPGIN</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">block_dump</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s(%d): %s block %Lu on %s (%u sectors)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span>
				<span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;WRITE&quot;</span> <span class="o">:</span> <span class="s">&quot;READ&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">,</span>
				<span class="n">bdevname</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
				<span class="n">count</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">generic_make_request</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">submit_bio</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_rq_check_limits - Helper function to check a request for the queue limit</span>
<span class="cm"> * @q:  the queue</span>
<span class="cm"> * @rq: the request being checked</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    @rq may have been made based on weaker limitations of upper-level queues</span>
<span class="cm"> *    in request stacking drivers, and it may violate the limitation of @q.</span>
<span class="cm"> *    Since the block layer and the underlying device driver trust @rq</span>
<span class="cm"> *    after it is inserted to @q, it should be checked against @q before</span>
<span class="cm"> *    the insertion using this generic function.</span>
<span class="cm"> *</span>
<span class="cm"> *    This function should also be useful for request stacking drivers</span>
<span class="cm"> *    in some cases below, so export this function.</span>
<span class="cm"> *    Request stacking drivers like request-based dm may change the queue</span>
<span class="cm"> *    limits while requests are in the queue (e.g. dm&#39;s table swapping).</span>
<span class="cm"> *    Such request stacking drivers should check those requests agaist</span>
<span class="cm"> *    the new queue limits again when they dispatch those requests,</span>
<span class="cm"> *    although such checkings are also done against the old queue limits</span>
<span class="cm"> *    when submitting requests.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">blk_rq_check_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">queue_max_sectors</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">queue_max_hw_sectors</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: over max size limit.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * queue&#39;s settings related to segment counting like q-&gt;bounce_pfn</span>
<span class="cm">	 * may differ from that of other stacking queues.</span>
<span class="cm">	 * Recalculate it to check the request correctly on this queue&#39;s</span>
<span class="cm">	 * limitation.</span>
<span class="cm">	 */</span>
	<span class="n">blk_recalc_rq_segments</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_phys_segments</span> <span class="o">&gt;</span> <span class="n">queue_max_segments</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: over max segments limit.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_rq_check_limits</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_insert_cloned_request - Helper for stacking drivers to submit a request</span>
<span class="cm"> * @q:  the queue to submit the request</span>
<span class="cm"> * @rq: the request being queued</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">blk_insert_cloned_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">where</span> <span class="o">=</span> <span class="n">ELEVATOR_INSERT_BACK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_check_limits</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rq_disk</span> <span class="o">&amp;&amp;</span>
	    <span class="n">should_fail_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rq_disk</span><span class="o">-&gt;</span><span class="n">part0</span><span class="p">,</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">blk_queue_dead</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Submitting request must be dequeued before calling this function</span>
<span class="cm">	 * because it will be linked to another request_queue</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">blk_queued_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REQ_FLUSH</span><span class="o">|</span><span class="n">REQ_FUA</span><span class="p">))</span>
		<span class="n">where</span> <span class="o">=</span> <span class="n">ELEVATOR_INSERT_FLUSH</span><span class="p">;</span>

	<span class="n">add_acct_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">where</span> <span class="o">==</span> <span class="n">ELEVATOR_INSERT_FLUSH</span><span class="p">)</span>
		<span class="n">__blk_run_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_insert_cloned_request</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_rq_err_bytes - determine number of bytes till the next failure boundary</span>
<span class="cm"> * @rq: request to examine</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     A request could be merge of IOs which require different failure</span>
<span class="cm"> *     handling.  This function determines the number of bytes which</span>
<span class="cm"> *     can be failed from the beginning of the request without</span>
<span class="cm"> *     crossing into area which need to be retried further.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *     The number of bytes to fail.</span>
<span class="cm"> *</span>
<span class="cm"> * Context:</span>
<span class="cm"> *     queue_lock must be held.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">blk_rq_err_bytes</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ff</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_FAILFAST_MASK</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_MIXED_MERGE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Currently the only &#39;mixing&#39; which can happen is between</span>
<span class="cm">	 * different fastfail types.  We can safely fail portions</span>
<span class="cm">	 * which have all the failfast bits that the first one has -</span>
<span class="cm">	 * the ones which are at least as eager to fail as the first</span>
<span class="cm">	 * one.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bio</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">;</span> <span class="n">bio</span><span class="p">;</span> <span class="n">bio</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">ff</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ff</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">bytes</span> <span class="o">+=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* this could lead to infinite loop */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">bytes</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bytes</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_rq_err_bytes</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">blk_account_io_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_do_io_stat</span><span class="p">(</span><span class="n">req</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">rw</span> <span class="o">=</span> <span class="n">rq_data_dir</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

		<span class="n">cpu</span> <span class="o">=</span> <span class="n">part_stat_lock</span><span class="p">();</span>
		<span class="n">part</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">part</span><span class="p">;</span>
		<span class="n">part_stat_add</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">sectors</span><span class="p">[</span><span class="n">rw</span><span class="p">],</span> <span class="n">bytes</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">);</span>
		<span class="n">part_stat_unlock</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">blk_account_io_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Account IO completion.  flush_rq isn&#39;t accounted as a</span>
<span class="cm">	 * normal IO on queueing nor completion.  Accounting the</span>
<span class="cm">	 * containing request is enough.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_do_io_stat</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_FLUSH_SEQ</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">start_time</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">rw</span> <span class="o">=</span> <span class="n">rq_data_dir</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

		<span class="n">cpu</span> <span class="o">=</span> <span class="n">part_stat_lock</span><span class="p">();</span>
		<span class="n">part</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">part</span><span class="p">;</span>

		<span class="n">part_stat_inc</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">ios</span><span class="p">[</span><span class="n">rw</span><span class="p">]);</span>
		<span class="n">part_stat_add</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">ticks</span><span class="p">[</span><span class="n">rw</span><span class="p">],</span> <span class="n">duration</span><span class="p">);</span>
		<span class="n">part_round_stats</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">part</span><span class="p">);</span>
		<span class="n">part_dec_in_flight</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">rw</span><span class="p">);</span>

		<span class="n">hd_struct_put</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
		<span class="n">part_stat_unlock</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blk_peek_request - peek at the top of a request queue</span>
<span class="cm"> * @q: request queue to peek at</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Return the request at the top of @q.  The returned request</span>
<span class="cm"> *     should be started using blk_start_request() before LLD starts</span>
<span class="cm"> *     processing it.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *     Pointer to the request at the top of @q if available.  Null</span>
<span class="cm"> *     otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Context:</span>
<span class="cm"> *     queue_lock must be held.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">blk_peek_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">rq</span> <span class="o">=</span> <span class="n">__elv_next_request</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_STARTED</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is the first time the device driver</span>
<span class="cm">			 * sees this request (possibly after</span>
<span class="cm">			 * requeueing).  Notify IO scheduler.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_SORTED</span><span class="p">)</span>
				<span class="n">elv_activate_rq</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * just mark as started even if we don&#39;t start</span>
<span class="cm">			 * it, a request that has been delayed should</span>
<span class="cm">			 * not be passed by new incoming requests</span>
<span class="cm">			 */</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">|=</span> <span class="n">REQ_STARTED</span><span class="p">;</span>
			<span class="n">trace_block_rq_issue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">boundary_rq</span> <span class="o">||</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">boundary_rq</span> <span class="o">==</span> <span class="n">rq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">end_sector</span> <span class="o">=</span> <span class="n">rq_end_sector</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">boundary_rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_DONTPREP</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_drain_size</span> <span class="o">&amp;&amp;</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * make sure space for the drain appears we</span>
<span class="cm">			 * know we can do this because max_hw_segments</span>
<span class="cm">			 * has been adjusted to be one fewer than the</span>
<span class="cm">			 * device can handle</span>
<span class="cm">			 */</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_phys_segments</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">prep_rq_fn</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">prep_rq_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">BLKPREP_OK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">BLKPREP_DEFER</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * the request may have been (partially) prepped.</span>
<span class="cm">			 * we need to keep this request in the front to</span>
<span class="cm">			 * avoid resource deadlock.  REQ_STARTED will</span>
<span class="cm">			 * prevent other fs requests from passing this one.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_drain_size</span> <span class="o">&amp;&amp;</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_DONTPREP</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * remove the space for the drain we added</span>
<span class="cm">				 * so that we don&#39;t add it again</span>
<span class="cm">				 */</span>
				<span class="o">--</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_phys_segments</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">BLKPREP_KILL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">|=</span> <span class="n">REQ_QUIET</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Mark this request as started so we don&#39;t trigger</span>
<span class="cm">			 * any debug logic in the end I/O path.</span>
<span class="cm">			 */</span>
			<span class="n">blk_start_request</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
			<span class="n">__blk_end_request_all</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: bad return=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_peek_request</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">blk_dequeue_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">queuelist</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ELV_ON_HASH</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">queuelist</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * the time frame between a request being removed from the lists</span>
<span class="cm">	 * and to it is freed is accounted as io that is in progress at</span>
<span class="cm">	 * the driver side.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_account_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">[</span><span class="n">rq_is_sync</span><span class="p">(</span><span class="n">rq</span><span class="p">)]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">set_io_start_time_ns</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blk_start_request - start request processing on the driver</span>
<span class="cm"> * @req: request to dequeue</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Dequeue @req and start timeout timer on it.  This hands off the</span>
<span class="cm"> *     request to the driver.</span>
<span class="cm"> *</span>
<span class="cm"> *     Block internal functions which don&#39;t want to start timer should</span>
<span class="cm"> *     call blk_dequeue_request().</span>
<span class="cm"> *</span>
<span class="cm"> * Context:</span>
<span class="cm"> *     queue_lock must be held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_start_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blk_dequeue_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are now handing the request to the hardware, initialize</span>
<span class="cm">	 * resid_len to full count and add the timeout handler.</span>
<span class="cm">	 */</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">resid_len</span> <span class="o">=</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">blk_bidi_rq</span><span class="p">(</span><span class="n">req</span><span class="p">)))</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="o">-&gt;</span><span class="n">resid_len</span> <span class="o">=</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">);</span>

	<span class="n">blk_add_timer</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_start_request</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_fetch_request - fetch a request from a request queue</span>
<span class="cm"> * @q: request queue to fetch a request from</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Return the request at the top of @q.  The request is started on</span>
<span class="cm"> *     return and LLD can start processing it immediately.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *     Pointer to the request at the top of @q if available.  Null</span>
<span class="cm"> *     otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Context:</span>
<span class="cm"> *     queue_lock must be held.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">blk_fetch_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">blk_peek_request</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="p">)</span>
		<span class="n">blk_start_request</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_fetch_request</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_update_request - Special helper function for request stacking drivers</span>
<span class="cm"> * @req:      the request being processed</span>
<span class="cm"> * @error:    %0 for success, &lt; %0 for error</span>
<span class="cm"> * @nr_bytes: number of bytes to complete @req</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Ends I/O on a number of bytes attached to @req, but doesn&#39;t complete</span>
<span class="cm"> *     the request structure even if @req doesn&#39;t have leftover.</span>
<span class="cm"> *     If @req has leftover, sets it up for the next range of segments.</span>
<span class="cm"> *</span>
<span class="cm"> *     This special helper function is only for request stacking drivers</span>
<span class="cm"> *     (e.g. request-based dm) so that they can handle partial completion.</span>
<span class="cm"> *     Actual device drivers should use blk_end_request instead.</span>
<span class="cm"> *</span>
<span class="cm"> *     Passing the result of blk_rq_bytes() as @nr_bytes guarantees</span>
<span class="cm"> *     %false return from this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *     %false - this request doesn&#39;t have any more data</span>
<span class="cm"> *     %true  - this request has more data</span>
<span class="cm"> **/</span>
<span class="n">bool</span> <span class="nf">blk_update_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">total_bytes</span><span class="p">,</span> <span class="n">bio_nbytes</span><span class="p">,</span> <span class="n">next_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">trace_block_rq_complete</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * For fs requests, rq is just carrier of independent bio&#39;s</span>
<span class="cm">	 * and each partial completion should be handled separately.</span>
<span class="cm">	 * Reset per-request error on each partial completion.</span>
<span class="cm">	 *</span>
<span class="cm">	 * TODO: tj: This is too subtle.  It would be better to let</span>
<span class="cm">	 * low level drivers do what they see fit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_FS</span><span class="p">)</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_FS</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_QUIET</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">error_type</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ENOLINK</span>:
			<span class="n">error_type</span> <span class="o">=</span> <span class="s">&quot;recoverable transport&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EREMOTEIO</span>:
			<span class="n">error_type</span> <span class="o">=</span> <span class="s">&quot;critical target&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EBADE</span>:
			<span class="n">error_type</span> <span class="o">=</span> <span class="s">&quot;critical nexus&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EIO</span>:
		<span class="nl">default:</span>
			<span class="n">error_type</span> <span class="o">=</span> <span class="s">&quot;I/O&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;end_request: %s error, dev %s, sector %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">error_type</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_disk</span> <span class="o">?</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_disk</span><span class="o">-&gt;</span><span class="n">disk_name</span> <span class="o">:</span> <span class="s">&quot;?&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">req</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">blk_account_io_completion</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">nr_bytes</span><span class="p">);</span>

	<span class="n">total_bytes</span> <span class="o">=</span> <span class="n">bio_nbytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">bio</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nbytes</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nr_bytes</span> <span class="o">&gt;=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span><span class="p">;</span>
			<span class="n">nbytes</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">;</span>
			<span class="n">req_bio_endio</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="n">next_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">bio_nbytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_idx</span> <span class="o">+</span> <span class="n">next_idx</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">blk_dump_rq_flags</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="s">&quot;__end_that&quot;</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: bio idx %d &gt;= vcnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">__func__</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">nbytes</span> <span class="o">=</span> <span class="n">bio_iovec_idx</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">;</span>
			<span class="n">BIO_BUG_ON</span><span class="p">(</span><span class="n">nbytes</span> <span class="o">&gt;</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * not a complete bvec done</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nbytes</span> <span class="o">&gt;</span> <span class="n">nr_bytes</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">bio_nbytes</span> <span class="o">+=</span> <span class="n">nr_bytes</span><span class="p">;</span>
				<span class="n">total_bytes</span> <span class="o">+=</span> <span class="n">nr_bytes</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * advance to the next vector</span>
<span class="cm">			 */</span>
			<span class="n">next_idx</span><span class="o">++</span><span class="p">;</span>
			<span class="n">bio_nbytes</span> <span class="o">+=</span> <span class="n">nbytes</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">total_bytes</span> <span class="o">+=</span> <span class="n">nbytes</span><span class="p">;</span>
		<span class="n">nr_bytes</span> <span class="o">-=</span> <span class="n">nbytes</span><span class="p">;</span>

		<span class="n">bio</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * end more in this run, or just return &#39;not-done&#39;</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nr_bytes</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * completely done</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Reset counters so that the request stacking driver</span>
<span class="cm">		 * can find how many bytes remain in the request</span>
<span class="cm">		 * later.</span>
<span class="cm">		 */</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">__data_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * if the request wasn&#39;t completed, update state</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio_nbytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req_bio_endio</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">bio_nbytes</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_idx</span> <span class="o">+=</span> <span class="n">next_idx</span><span class="p">;</span>
		<span class="n">bio_iovec</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bv_offset</span> <span class="o">+=</span> <span class="n">nr_bytes</span><span class="p">;</span>
		<span class="n">bio_iovec</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bv_len</span> <span class="o">-=</span> <span class="n">nr_bytes</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">__data_len</span> <span class="o">-=</span> <span class="n">total_bytes</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">bio_data</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">);</span>

	<span class="cm">/* update sector only for requests with clear definition of sector */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_FS</span> <span class="o">||</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">))</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">__sector</span> <span class="o">+=</span> <span class="n">total_bytes</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>

	<span class="cm">/* mixed attributes always follow the first bio */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_MIXED_MERGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REQ_FAILFAST_MASK</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">|=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_FAILFAST_MASK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If total number of sectors is less than the first segment</span>
<span class="cm">	 * size, something has gone terribly wrong.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">blk_rq_cur_bytes</span><span class="p">(</span><span class="n">req</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">blk_dump_rq_flags</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="s">&quot;request botched&quot;</span><span class="p">);</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">__data_len</span> <span class="o">=</span> <span class="n">blk_rq_cur_bytes</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* recalculate the number of segments */</span>
	<span class="n">blk_recalc_rq_segments</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_update_request</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">blk_update_bidi_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_bytes</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bidi_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_update_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">nr_bytes</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Bidi request must be completed as a whole */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">blk_bidi_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">blk_update_request</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">bidi_bytes</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_queue_add_random</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">))</span>
		<span class="n">add_disk_randomness</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rq_disk</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blk_unprep_request - unprepare a request</span>
<span class="cm"> * @req:	the request</span>
<span class="cm"> *</span>
<span class="cm"> * This function makes a request ready for complete resubmission (or</span>
<span class="cm"> * completion).  It happens only after all error handling is complete,</span>
<span class="cm"> * so represents the appropriate moment to deallocate any resources</span>
<span class="cm"> * that were allocated to the request in the prep_rq_fn.  The queue</span>
<span class="cm"> * lock is held when calling this.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_unprep_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REQ_DONTPREP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">unprep_rq_fn</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">unprep_rq_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_unprep_request</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * queue lock must be held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">blk_finish_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_tagged</span><span class="p">(</span><span class="n">req</span><span class="p">))</span>
		<span class="n">blk_queue_end_tag</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">blk_queued_rq</span><span class="p">(</span><span class="n">req</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">laptop_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">REQ_TYPE_FS</span><span class="p">)</span>
		<span class="n">laptop_io_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">);</span>

	<span class="n">blk_delete_timer</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_DONTPREP</span><span class="p">)</span>
		<span class="n">blk_unprep_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>


	<span class="n">blk_account_io_done</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">end_io</span><span class="p">)</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">end_io</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk_bidi_rq</span><span class="p">(</span><span class="n">req</span><span class="p">))</span>
			<span class="n">__blk_put_request</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">);</span>

		<span class="n">__blk_put_request</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blk_end_bidi_request - Complete a bidi request</span>
<span class="cm"> * @rq:         the request to complete</span>
<span class="cm"> * @error:      %0 for success, &lt; %0 for error</span>
<span class="cm"> * @nr_bytes:   number of bytes to complete @rq</span>
<span class="cm"> * @bidi_bytes: number of bytes to complete @rq-&gt;next_rq</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Ends I/O on a number of bytes attached to @rq and @rq-&gt;next_rq.</span>
<span class="cm"> *     Drivers that supports bidi can safely call this member for any</span>
<span class="cm"> *     type of request, bidi or uni.  In the later case @bidi_bytes is</span>
<span class="cm"> *     just ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *     %false - we are done with this request</span>
<span class="cm"> *     %true  - still buffers pending for this request</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">blk_end_bidi_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_bytes</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bidi_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_update_bidi_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">nr_bytes</span><span class="p">,</span> <span class="n">bidi_bytes</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">blk_finish_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __blk_end_bidi_request - Complete a bidi request with queue lock held</span>
<span class="cm"> * @rq:         the request to complete</span>
<span class="cm"> * @error:      %0 for success, &lt; %0 for error</span>
<span class="cm"> * @nr_bytes:   number of bytes to complete @rq</span>
<span class="cm"> * @bidi_bytes: number of bytes to complete @rq-&gt;next_rq</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Identical to blk_end_bidi_request() except that queue lock is</span>
<span class="cm"> *     assumed to be locked on entry and remains so on return.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *     %false - we are done with this request</span>
<span class="cm"> *     %true  - still buffers pending for this request</span>
<span class="cm"> **/</span>
<span class="n">bool</span> <span class="nf">__blk_end_bidi_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_bytes</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bidi_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_update_bidi_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">nr_bytes</span><span class="p">,</span> <span class="n">bidi_bytes</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">blk_finish_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blk_end_request - Helper function for drivers to complete the request.</span>
<span class="cm"> * @rq:       the request being processed</span>
<span class="cm"> * @error:    %0 for success, &lt; %0 for error</span>
<span class="cm"> * @nr_bytes: number of bytes to complete</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Ends I/O on a number of bytes attached to @rq.</span>
<span class="cm"> *     If @rq has leftover, sets it up for the next range of segments.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *     %false - we are done with this request</span>
<span class="cm"> *     %true  - still buffers pending for this request</span>
<span class="cm"> **/</span>
<span class="n">bool</span> <span class="nf">blk_end_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blk_end_bidi_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">nr_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_end_request</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_end_request_all - Helper function for drives to finish the request.</span>
<span class="cm"> * @rq: the request to finish</span>
<span class="cm"> * @error: %0 for success, &lt; %0 for error</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Completely finish @rq.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_end_request_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">pending</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bidi_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">blk_bidi_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">)))</span>
		<span class="n">bidi_bytes</span> <span class="o">=</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">);</span>

	<span class="n">pending</span> <span class="o">=</span> <span class="n">blk_end_bidi_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">bidi_bytes</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pending</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_end_request_all</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_end_request_cur - Helper function to finish the current request chunk.</span>
<span class="cm"> * @rq: the request to finish the current chunk for</span>
<span class="cm"> * @error: %0 for success, &lt; %0 for error</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Complete the current consecutively mapped chunk from @rq.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *     %false - we are done with this request</span>
<span class="cm"> *     %true  - still buffers pending for this request</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">blk_end_request_cur</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blk_end_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">blk_rq_cur_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_end_request_cur</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_end_request_err - Finish a request till the next failure boundary.</span>
<span class="cm"> * @rq: the request to finish till the next failure boundary for</span>
<span class="cm"> * @error: must be negative errno</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Complete @rq till the next failure boundary.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *     %false - we are done with this request</span>
<span class="cm"> *     %true  - still buffers pending for this request</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">blk_end_request_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">error</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">blk_end_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">blk_rq_err_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_end_request_err</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __blk_end_request - Helper function for drivers to complete the request.</span>
<span class="cm"> * @rq:       the request being processed</span>
<span class="cm"> * @error:    %0 for success, &lt; %0 for error</span>
<span class="cm"> * @nr_bytes: number of bytes to complete</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Must be called with queue lock held unlike blk_end_request().</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *     %false - we are done with this request</span>
<span class="cm"> *     %true  - still buffers pending for this request</span>
<span class="cm"> **/</span>
<span class="n">bool</span> <span class="nf">__blk_end_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__blk_end_bidi_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">nr_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__blk_end_request</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __blk_end_request_all - Helper function for drives to finish the request.</span>
<span class="cm"> * @rq: the request to finish</span>
<span class="cm"> * @error: %0 for success, &lt; %0 for error</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Completely finish @rq.  Must be called with queue lock held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__blk_end_request_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">pending</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bidi_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">blk_bidi_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">)))</span>
		<span class="n">bidi_bytes</span> <span class="o">=</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">);</span>

	<span class="n">pending</span> <span class="o">=</span> <span class="n">__blk_end_bidi_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">bidi_bytes</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pending</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__blk_end_request_all</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __blk_end_request_cur - Helper function to finish the current request chunk.</span>
<span class="cm"> * @rq: the request to finish the current chunk for</span>
<span class="cm"> * @error: %0 for success, &lt; %0 for error</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Complete the current consecutively mapped chunk from @rq.  Must</span>
<span class="cm"> *     be called with queue lock held.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *     %false - we are done with this request</span>
<span class="cm"> *     %true  - still buffers pending for this request</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">__blk_end_request_cur</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__blk_end_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">blk_rq_cur_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__blk_end_request_cur</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __blk_end_request_err - Finish a request till the next failure boundary.</span>
<span class="cm"> * @rq: the request to finish till the next failure boundary for</span>
<span class="cm"> * @error: must be negative errno</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Complete @rq till the next failure boundary.  Must be called</span>
<span class="cm"> *     with queue lock held.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *     %false - we are done with this request</span>
<span class="cm"> *     %true  - still buffers pending for this request</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">__blk_end_request_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">error</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__blk_end_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">blk_rq_err_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__blk_end_request_err</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">blk_rq_bio_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Bit 0 (R/W) is identical in rq-&gt;cmd_flags and bio-&gt;bi_rw */</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">|=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_WRITE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_has_data</span><span class="p">(</span><span class="n">bio</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_phys_segments</span> <span class="o">=</span> <span class="n">bio_phys_segments</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">bio_data</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">__data_len</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">biotail</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">)</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rq_disk</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE</span>
<span class="cm">/**</span>
<span class="cm"> * rq_flush_dcache_pages - Helper function to flush all pages in a request</span>
<span class="cm"> * @rq: the request to be flushed</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Flush all pages in @rq.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rq_flush_dcache_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">req_iterator</span> <span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">;</span>

	<span class="n">rq_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">iter</span><span class="p">)</span>
		<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rq_flush_dcache_pages</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * blk_lld_busy - Check if underlying low-level drivers of a device are busy</span>
<span class="cm"> * @q : the queue of the device being checked</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    Check if underlying low-level drivers of a device are busy.</span>
<span class="cm"> *    If the drivers want to export their busy state, they must set own</span>
<span class="cm"> *    exporting function using blk_queue_lld_busy() first.</span>
<span class="cm"> *</span>
<span class="cm"> *    Basically, this function is used only by request stacking drivers</span>
<span class="cm"> *    to stop dispatching requests to underlying devices when underlying</span>
<span class="cm"> *    devices are busy.  This behavior helps more I/O merging on the queue</span>
<span class="cm"> *    of the request stacking driver and prevents I/O throughput regression</span>
<span class="cm"> *    on burst I/O load.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *    0 - Not busy (The request stacking driver should dispatch request)</span>
<span class="cm"> *    1 - Busy (The request stacking driver should stop dispatching request)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">blk_lld_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lld_busy_fn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">lld_busy_fn</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_lld_busy</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * blk_rq_unprep_clone - Helper function to free all bios in a cloned request</span>
<span class="cm"> * @rq: the clone request to be cleaned up</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Free all bios in @rq for a cloned request.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_rq_unprep_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">bio</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span><span class="p">;</span>

		<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_rq_unprep_clone</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Copy attributes of the original request to the clone request.</span>
<span class="cm"> * The actual data parts (e.g. -&gt;cmd, -&gt;buffer, -&gt;sense) are not copied.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__blk_rq_prep_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_CLONE_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">REQ_NOMERGE</span><span class="p">;</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">cmd_type</span><span class="p">;</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">__sector</span> <span class="o">=</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">__data_len</span> <span class="o">=</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">nr_phys_segments</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">nr_phys_segments</span><span class="p">;</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">ioprio</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">ioprio</span><span class="p">;</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">extra_len</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">extra_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * blk_rq_prep_clone - Helper function to setup clone request</span>
<span class="cm"> * @rq: the request to be setup</span>
<span class="cm"> * @rq_src: original request to be cloned</span>
<span class="cm"> * @bs: bio_set that bios for clone are allocated from</span>
<span class="cm"> * @gfp_mask: memory allocation mask for bio</span>
<span class="cm"> * @bio_ctr: setup function to be called for each clone bio.</span>
<span class="cm"> *           Returns %0 for success, non %0 for failure.</span>
<span class="cm"> * @data: private data to be passed to @bio_ctr</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *     Clones bios in @rq_src to @rq, and copies attributes of @rq_src to @rq.</span>
<span class="cm"> *     The actual data parts of @rq_src (e.g. -&gt;cmd, -&gt;buffer, -&gt;sense)</span>
<span class="cm"> *     are not copied, and copying such parts is the caller&#39;s responsibility.</span>
<span class="cm"> *     Also, pages which the original bios are pointing to are not copied</span>
<span class="cm"> *     and the cloned bios just point same pages.</span>
<span class="cm"> *     So cloned bios must be completed before original bios, which means</span>
<span class="cm"> *     the caller must complete @rq before @rq_src.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">blk_rq_prep_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq_src</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bio_ctr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="o">*</span><span class="n">bio_src</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bs</span><span class="p">)</span>
		<span class="n">bs</span> <span class="o">=</span> <span class="n">fs_bio_set</span><span class="p">;</span>

	<span class="n">blk_rq_init</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

	<span class="n">__rq_for_each_bio</span><span class="p">(</span><span class="n">bio_src</span><span class="p">,</span> <span class="n">rq_src</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc_bioset</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">bio_src</span><span class="o">-&gt;</span><span class="n">bi_max_vecs</span><span class="p">,</span> <span class="n">bs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_and_out</span><span class="p">;</span>

		<span class="n">__bio_clone</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">bio_src</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bio_integrity</span><span class="p">(</span><span class="n">bio_src</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">bio_integrity_clone</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">bio_src</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">bs</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">free_and_out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bio_ctr</span> <span class="o">&amp;&amp;</span> <span class="n">bio_ctr</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">bio_src</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">free_and_out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">biotail</span><span class="o">-&gt;</span><span class="n">bi_next</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">biotail</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">biotail</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">__blk_rq_prep_clone</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rq_src</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">free_and_out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span>
		<span class="n">bio_free</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">bs</span><span class="p">);</span>
	<span class="n">blk_rq_unprep_clone</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blk_rq_prep_clone</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kblockd_schedule_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_work</span><span class="p">(</span><span class="n">kblockd_workqueue</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kblockd_schedule_work</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kblockd_schedule_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">kblockd_workqueue</span><span class="p">,</span> <span class="n">dwork</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kblockd_schedule_delayed_work</span><span class="p">);</span>

<span class="cp">#define PLUG_MAGIC	0x91827364</span>

<span class="cm">/**</span>
<span class="cm"> * blk_start_plug - initialize blk_plug and track it inside the task_struct</span>
<span class="cm"> * @plug:	The &amp;struct blk_plug that needs to be initialized</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Tracking blk_plug inside the task_struct will help with auto-flushing the</span>
<span class="cm"> *   pending I/O should the task end up blocking between blk_start_plug() and</span>
<span class="cm"> *   blk_finish_plug(). This is important from a performance perspective, but</span>
<span class="cm"> *   also ensures that we don&#39;t deadlock. For instance, if the task is blocking</span>
<span class="cm"> *   for a memory allocation, memory reclaim could end up wanting to free a</span>
<span class="cm"> *   page belonging to that request that is currently residing in our private</span>
<span class="cm"> *   plug. By flushing the pending I/O when the process goes to sleep, we avoid</span>
<span class="cm"> *   this kind of deadlock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">blk_start_plug</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_plug</span> <span class="o">*</span><span class="n">plug</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="n">plug</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">PLUG_MAGIC</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="o">-&gt;</span><span class="n">cb_list</span><span class="p">);</span>
	<span class="n">plug</span><span class="o">-&gt;</span><span class="n">should_sort</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a nested plug, don&#39;t actually assign it. It will be</span>
<span class="cm">	 * flushed on its own.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">plug</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Store ordering should not be needed here, since a potential</span>
<span class="cm">		 * preempt will imply a full memory barrier</span>
<span class="cm">		 */</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">plug</span> <span class="o">=</span> <span class="n">plug</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_start_plug</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">plug_rq_cmp</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rqa</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span><span class="p">,</span> <span class="n">queuelist</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rqb</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span><span class="p">,</span> <span class="n">queuelist</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">rqa</span><span class="o">-&gt;</span><span class="n">q</span> <span class="o">&lt;=</span> <span class="n">rqb</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If &#39;from_schedule&#39; is true, then postpone the dispatch of requests</span>
<span class="cm"> * until a safe kblockd context. We due this to avoid accidental big</span>
<span class="cm"> * additional stack usage in driver dispatch, in places where the originally</span>
<span class="cm"> * plugger did not intend it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">queue_unplugged</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span>
			    <span class="n">bool</span> <span class="n">from_schedule</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_block_unplug</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="o">!</span><span class="n">from_schedule</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t mess with dead queue.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">blk_queue_dead</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are punting this to kblockd, then we can safely drop</span>
<span class="cm">	 * the queue_lock before waking kblockd (which needs to take</span>
<span class="cm">	 * this lock).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">from_schedule</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">blk_run_queue_async</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">__blk_run_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_plug_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_plug</span> <span class="o">*</span><span class="n">plug</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">callbacks</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="o">-&gt;</span><span class="n">cb_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="o">-&gt;</span><span class="n">cb_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callbacks</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callbacks</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">blk_plug_cb</span> <span class="o">*</span><span class="n">cb</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callbacks</span><span class="p">,</span>
							  <span class="k">struct</span> <span class="n">blk_plug_cb</span><span class="p">,</span>
							  <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">cb</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">blk_flush_plug_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_plug</span> <span class="o">*</span><span class="n">plug</span><span class="p">,</span> <span class="n">bool</span> <span class="n">from_schedule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">plug</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">PLUG_MAGIC</span><span class="p">);</span>

	<span class="n">flush_plug_callbacks</span><span class="p">(</span><span class="n">plug</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">plug</span><span class="o">-&gt;</span><span class="n">should_sort</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_sort</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">,</span> <span class="n">plug_rq_cmp</span><span class="p">);</span>
		<span class="n">plug</span><span class="o">-&gt;</span><span class="n">should_sort</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save and disable interrupts here, to avoid doing it for every</span>
<span class="cm">	 * queue lock we have to take.</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rq</span> <span class="o">=</span> <span class="n">list_entry_rq</span><span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">queuelist</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span> <span class="o">!=</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This drops the queue lock</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span>
				<span class="n">queue_unplugged</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">from_schedule</span><span class="p">);</span>
			<span class="n">q</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">;</span>
			<span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Short-circuit if @q is dead</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">blk_queue_dead</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">__blk_end_request_all</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * rq is already accounted, so use raw insert</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REQ_FLUSH</span> <span class="o">|</span> <span class="n">REQ_FUA</span><span class="p">))</span>
			<span class="n">__elv_add_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">ELEVATOR_INSERT_FLUSH</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">__elv_add_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">ELEVATOR_INSERT_SORT_MERGE</span><span class="p">);</span>

		<span class="n">depth</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This drops the queue lock</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span>
		<span class="n">queue_unplugged</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">from_schedule</span><span class="p">);</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">blk_finish_plug</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_plug</span> <span class="o">*</span><span class="n">plug</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blk_flush_plug_list</span><span class="p">(</span><span class="n">plug</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">plug</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">plug</span><span class="p">)</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">plug</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">blk_finish_plug</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">blk_dev_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">__REQ_NR_BITS</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="o">*</span>
			<span class="k">sizeof</span><span class="p">(((</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cmd_flags</span><span class="p">));</span>

	<span class="cm">/* used for unplugging and affects IO latency/throughput - HIGHPRI */</span>
	<span class="n">kblockd_workqueue</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;kblockd&quot;</span><span class="p">,</span>
					    <span class="n">WQ_MEM_RECLAIM</span> <span class="o">|</span> <span class="n">WQ_HIGHPRI</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kblockd_workqueue</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Failed to create kblockd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">request_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;blkdev_requests&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">blk_requestq_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;blkdev_queue&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
