<!DOCTYPE html>
<html><head><title>joekychen/linux » block › cfq-iosched.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>cfq-iosched.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  CFQ, or complete fairness queueing, disk scheduler.</span>
<span class="cm"> *</span>
<span class="cm"> *  Based on ideas from a previously unfinished io</span>
<span class="cm"> *  scheduler (round robin per-process disk scheduling) and Andrea Arcangeli.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2003 Jens Axboe &lt;axboe@kernel.dk&gt;</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/elevator.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/ioprio.h&gt;</span>
<span class="cp">#include &lt;linux/blktrace_api.h&gt;</span>
<span class="cp">#include &quot;blk.h&quot;</span>
<span class="cp">#include &quot;blk-cgroup.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * tunables</span>
<span class="cm"> */</span>
<span class="cm">/* max queue in one round of service */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">cfq_quantum</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">cfq_fifo_expire</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">8</span> <span class="p">};</span>
<span class="cm">/* maximum backwards seek, in KiB */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">cfq_back_max</span> <span class="o">=</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
<span class="cm">/* penalty of a backwards seek */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">cfq_back_penalty</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">cfq_slice_sync</span> <span class="o">=</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cfq_slice_async</span> <span class="o">=</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">25</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">cfq_slice_async_rq</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cfq_slice_idle</span> <span class="o">=</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">125</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cfq_group_idle</span> <span class="o">=</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">125</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">cfq_target_latency</span> <span class="o">=</span> <span class="n">HZ</span> <span class="o">*</span> <span class="mi">3</span><span class="o">/</span><span class="mi">10</span><span class="p">;</span> <span class="cm">/* 300 ms */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">cfq_hist_divisor</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * offset from end of service tree</span>
<span class="cm"> */</span>
<span class="cp">#define CFQ_IDLE_DELAY		(HZ / 5)</span>

<span class="cm">/*</span>
<span class="cm"> * below this threshold, we consider thinktime immediate</span>
<span class="cm"> */</span>
<span class="cp">#define CFQ_MIN_TT		(2)</span>

<span class="cp">#define CFQ_SLICE_SCALE		(5)</span>
<span class="cp">#define CFQ_HW_QUEUE_MIN	(5)</span>
<span class="cp">#define CFQ_SERVICE_SHIFT       12</span>

<span class="cp">#define CFQQ_SEEK_THR		(sector_t)(8 * 100)</span>
<span class="cp">#define CFQQ_CLOSE_THR		(sector_t)(8 * 1024)</span>
<span class="cp">#define CFQQ_SECT_THR_NONROT	(sector_t)(2 * 32)</span>
<span class="cp">#define CFQQ_SEEKY(cfqq)	(hweight32(cfqq-&gt;seek_history) &gt; 32/8)</span>

<span class="cp">#define RQ_CIC(rq)		icq_to_cic((rq)-&gt;elv.icq)</span>
<span class="cp">#define RQ_CFQQ(rq)		(struct cfq_queue *) ((rq)-&gt;elv.priv[0])</span>
<span class="cp">#define RQ_CFQG(rq)		(struct cfq_group *) ((rq)-&gt;elv.priv[1])</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cfq_pool</span><span class="p">;</span>

<span class="cp">#define CFQ_PRIO_LISTS		IOPRIO_BE_NR</span>
<span class="cp">#define cfq_class_idle(cfqq)	((cfqq)-&gt;ioprio_class == IOPRIO_CLASS_IDLE)</span>
<span class="cp">#define cfq_class_rt(cfqq)	((cfqq)-&gt;ioprio_class == IOPRIO_CLASS_RT)</span>

<span class="cp">#define sample_valid(samples)	((samples) &gt; 80)</span>
<span class="cp">#define rb_entry_cfqg(node)	rb_entry((node), struct cfq_group, rb_node)</span>

<span class="k">struct</span> <span class="n">cfq_ttime</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_end_request</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ttime_total</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ttime_samples</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ttime_mean</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Most of our rbtree usage is for sorting with min extraction, so</span>
<span class="cm"> * if we cache the leftmost node we don&#39;t have to walk down the tree</span>
<span class="cm"> * to find it. Idea borrowed from Ingo Molnars CFS scheduler. We should</span>
<span class="cm"> * move this into the elevator for the rq sorting as well.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">rb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">total_weight</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">min_vdisktime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_ttime</span> <span class="n">ttime</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define CFQ_RB_ROOT	(struct cfq_rb_root) { .rb = RB_ROOT, \</span>
<span class="cp">			.ttime = {.last_end_request = jiffies,},}</span>

<span class="cm">/*</span>
<span class="cm"> * Per process-grouping structure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="p">{</span>
	<span class="cm">/* reference count */</span>
	<span class="kt">int</span> <span class="n">ref</span><span class="p">;</span>
	<span class="cm">/* various state flags, see below */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="cm">/* parent cfq_data */</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">;</span>
	<span class="cm">/* service_tree member */</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb_node</span><span class="p">;</span>
	<span class="cm">/* service_tree key */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rb_key</span><span class="p">;</span>
	<span class="cm">/* prio tree member */</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">p_node</span><span class="p">;</span>
	<span class="cm">/* prio tree root we belong to, if any */</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">p_root</span><span class="p">;</span>
	<span class="cm">/* sorted list of pending requests */</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">sort_list</span><span class="p">;</span>
	<span class="cm">/* if fifo isn&#39;t expired, next request to serve */</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">next_rq</span><span class="p">;</span>
	<span class="cm">/* requests queued in sort_list */</span>
	<span class="kt">int</span> <span class="n">queued</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="cm">/* currently allocated requests */</span>
	<span class="kt">int</span> <span class="n">allocated</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="cm">/* fifo list of requests in sort_list */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">fifo</span><span class="p">;</span>

	<span class="cm">/* time when queue got scheduled in to dispatch first request. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dispatch_start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">allocated_slice</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slice_dispatch</span><span class="p">;</span>
	<span class="cm">/* time when first request from queue completed and slice started. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">slice_start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">slice_end</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">slice_resid</span><span class="p">;</span>

	<span class="cm">/* pending priority requests */</span>
	<span class="kt">int</span> <span class="n">prio_pending</span><span class="p">;</span>
	<span class="cm">/* number of requests that are on the dispatch list or inside driver */</span>
	<span class="kt">int</span> <span class="n">dispatched</span><span class="p">;</span>

	<span class="cm">/* io prio of this group */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ioprio</span><span class="p">,</span> <span class="n">org_ioprio</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ioprio_class</span><span class="p">;</span>

	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">seek_history</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">last_request_pos</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">service_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">new_cfqq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">;</span>
	<span class="cm">/* Number of sectors dispatched from queue in single dispatch round */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_sectors</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * First index in the service_trees.</span>
<span class="cm"> * IDLE is handled separately, so it has negative index</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">wl_prio_t</span> <span class="p">{</span>
	<span class="n">BE_WORKLOAD</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RT_WORKLOAD</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IDLE_WORKLOAD</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">CFQ_PRIO_NR</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Second index in the service_trees.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">wl_type_t</span> <span class="p">{</span>
	<span class="n">ASYNC_WORKLOAD</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SYNC_NOIDLE_WORKLOAD</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">SYNC_WORKLOAD</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cfqg_stats</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_CFQ_GROUP_IOSCHED</span>
	<span class="cm">/* total bytes transferred */</span>
	<span class="k">struct</span> <span class="n">blkg_rwstat</span>		<span class="n">service_bytes</span><span class="p">;</span>
	<span class="cm">/* total IOs serviced, post merge */</span>
	<span class="k">struct</span> <span class="n">blkg_rwstat</span>		<span class="n">serviced</span><span class="p">;</span>
	<span class="cm">/* number of ios merged */</span>
	<span class="k">struct</span> <span class="n">blkg_rwstat</span>		<span class="n">merged</span><span class="p">;</span>
	<span class="cm">/* total time spent on device in ns, may not be accurate w/ queueing */</span>
	<span class="k">struct</span> <span class="n">blkg_rwstat</span>		<span class="n">service_time</span><span class="p">;</span>
	<span class="cm">/* total time spent waiting in scheduler queue in ns */</span>
	<span class="k">struct</span> <span class="n">blkg_rwstat</span>		<span class="n">wait_time</span><span class="p">;</span>
	<span class="cm">/* number of IOs queued up */</span>
	<span class="k">struct</span> <span class="n">blkg_rwstat</span>		<span class="n">queued</span><span class="p">;</span>
	<span class="cm">/* total sectors transferred */</span>
	<span class="k">struct</span> <span class="n">blkg_stat</span>		<span class="n">sectors</span><span class="p">;</span>
	<span class="cm">/* total disk time and nr sectors dispatched by this group */</span>
	<span class="k">struct</span> <span class="n">blkg_stat</span>		<span class="n">time</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_DEBUG_BLK_CGROUP</span>
	<span class="cm">/* time not charged to this cgroup */</span>
	<span class="k">struct</span> <span class="n">blkg_stat</span>		<span class="n">unaccounted_time</span><span class="p">;</span>
	<span class="cm">/* sum of number of ios queued across all samples */</span>
	<span class="k">struct</span> <span class="n">blkg_stat</span>		<span class="n">avg_queue_size_sum</span><span class="p">;</span>
	<span class="cm">/* count of samples taken for average */</span>
	<span class="k">struct</span> <span class="n">blkg_stat</span>		<span class="n">avg_queue_size_samples</span><span class="p">;</span>
	<span class="cm">/* how many times this group has been removed from service tree */</span>
	<span class="k">struct</span> <span class="n">blkg_stat</span>		<span class="n">dequeue</span><span class="p">;</span>
	<span class="cm">/* total time spent waiting for it to be assigned a timeslice. */</span>
	<span class="k">struct</span> <span class="n">blkg_stat</span>		<span class="n">group_wait_time</span><span class="p">;</span>
	<span class="cm">/* time spent idling for this blkcg_gq */</span>
	<span class="k">struct</span> <span class="n">blkg_stat</span>		<span class="n">idle_time</span><span class="p">;</span>
	<span class="cm">/* total time with empty current active q with other requests queued */</span>
	<span class="k">struct</span> <span class="n">blkg_stat</span>		<span class="n">empty_time</span><span class="p">;</span>
	<span class="cm">/* fields after this shouldn&#39;t be cleared on stat reset */</span>
	<span class="kt">uint64_t</span>			<span class="n">start_group_wait_time</span><span class="p">;</span>
	<span class="kt">uint64_t</span>			<span class="n">start_idle_time</span><span class="p">;</span>
	<span class="kt">uint64_t</span>			<span class="n">start_empty_time</span><span class="p">;</span>
	<span class="kt">uint16_t</span>			<span class="n">flags</span><span class="p">;</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_DEBUG_BLK_CGROUP */</span><span class="cp"></span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_CFQ_GROUP_IOSCHED */</span><span class="cp"></span>
<span class="p">};</span>

<span class="cm">/* This is per cgroup per device grouping structure */</span>
<span class="k">struct</span> <span class="n">cfq_group</span> <span class="p">{</span>
	<span class="cm">/* must be the first member */</span>
	<span class="k">struct</span> <span class="n">blkg_policy_data</span> <span class="n">pd</span><span class="p">;</span>

	<span class="cm">/* group service_tree member */</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb_node</span><span class="p">;</span>

	<span class="cm">/* group service_tree key */</span>
	<span class="n">u64</span> <span class="n">vdisktime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">weight</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_weight</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dev_weight</span><span class="p">;</span>

	<span class="cm">/* number of cfqq currently on this group */</span>
	<span class="kt">int</span> <span class="n">nr_cfqq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Per group busy queues average. Useful for workload slice calc. We</span>
<span class="cm">	 * create the array for each prio class but at run time it is used</span>
<span class="cm">	 * only for RT and BE class and slot for IDLE class remains unused.</span>
<span class="cm">	 * This is primarily done to avoid confusion and a gcc warning.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">busy_queues_avg</span><span class="p">[</span><span class="n">CFQ_PRIO_NR</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * rr lists of queues with requests. We maintain service trees for</span>
<span class="cm">	 * RT and BE classes. These trees are subdivided in subclasses</span>
<span class="cm">	 * of SYNC, SYNC_NOIDLE and ASYNC based on workload type. For IDLE</span>
<span class="cm">	 * class there is no subclassification and all the cfq queues go on</span>
<span class="cm">	 * a single tree service_tree_idle.</span>
<span class="cm">	 * Counts are embedded in the cfq_rb_root</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="n">service_trees</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="n">service_tree_idle</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">saved_workload_slice</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">wl_type_t</span> <span class="n">saved_workload</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">wl_prio_t</span> <span class="n">saved_serving_prio</span><span class="p">;</span>

	<span class="cm">/* number of requests that are on the dispatch list or inside driver */</span>
	<span class="kt">int</span> <span class="n">dispatched</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_ttime</span> <span class="n">ttime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfqg_stats</span> <span class="n">stats</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">io_cq</span>		<span class="n">icq</span><span class="p">;</span>		<span class="cm">/* must be the first member */</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span>	<span class="o">*</span><span class="n">cfqq</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">cfq_ttime</span>	<span class="n">ttime</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ioprio</span><span class="p">;</span>		<span class="cm">/* the current ioprio */</span>
<span class="cp">#ifdef CONFIG_CFQ_GROUP_IOSCHED</span>
	<span class="kt">uint64_t</span>		<span class="n">blkcg_id</span><span class="p">;</span>	<span class="cm">/* the current blkcg ID */</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Per block device queue structure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfq_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="cm">/* Root service tree for cfq_groups */</span>
	<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="n">grp_service_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">root_group</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The priority currently being served</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">wl_prio_t</span> <span class="n">serving_prio</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">wl_type_t</span> <span class="n">serving_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">workload_expires</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">serving_group</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Each priority tree is sorted by next_request position.  These</span>
<span class="cm">	 * trees are used when determining if two or more queues are</span>
<span class="cm">	 * interleaving requests (see cfq_close_cooperator).</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">prio_trees</span><span class="p">[</span><span class="n">CFQ_PRIO_LISTS</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">busy_queues</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">busy_sync_queues</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">rq_in_driver</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rq_in_flight</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * queue-depth detection</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">rq_queued</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hw_tag</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * hw_tag can be</span>
<span class="cm">	 * -1 =&gt; indeterminate, (cfq will behave as if NCQ is present, to allow better detection)</span>
<span class="cm">	 *  1 =&gt; NCQ is present (hw_tag_est_depth is the estimated max depth)</span>
<span class="cm">	 *  0 =&gt; no NCQ</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">hw_tag_est_depth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hw_tag_samples</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * idle window management</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">idle_slice_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">unplug_work</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">active_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">active_cic</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * async queue for each priority case</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">async_cfqq</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">IOPRIO_BE_NR</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">async_idle_cfqq</span><span class="p">;</span>

	<span class="n">sector_t</span> <span class="n">last_position</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * tunables, see top of file</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cfq_quantum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cfq_fifo_expire</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cfq_back_penalty</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cfq_back_max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cfq_slice</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cfq_slice_async_rq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cfq_slice_idle</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cfq_group_idle</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cfq_latency</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cfq_target_latency</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fallback dummy cfqq for extreme OOM conditions</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="n">oom_cfqq</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_delayed_sync</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfq_get_next_cfqg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="nf">service_tree_for</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span>
					    <span class="k">enum</span> <span class="n">wl_prio_t</span> <span class="n">prio</span><span class="p">,</span>
					    <span class="k">enum</span> <span class="n">wl_type_t</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqg</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prio</span> <span class="o">==</span> <span class="n">IDLE_WORKLOAD</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">service_tree_idle</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">service_trees</span><span class="p">[</span><span class="n">prio</span><span class="p">][</span><span class="n">type</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">cfqq_state_flags</span> <span class="p">{</span>
	<span class="n">CFQ_CFQQ_FLAG_on_rr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* on round-robin busy list */</span>
	<span class="n">CFQ_CFQQ_FLAG_wait_request</span><span class="p">,</span>	<span class="cm">/* waiting for a request */</span>
	<span class="n">CFQ_CFQQ_FLAG_must_dispatch</span><span class="p">,</span>	<span class="cm">/* must be allowed a dispatch */</span>
	<span class="n">CFQ_CFQQ_FLAG_must_alloc_slice</span><span class="p">,</span>	<span class="cm">/* per-slice must_alloc flag */</span>
	<span class="n">CFQ_CFQQ_FLAG_fifo_expire</span><span class="p">,</span>	<span class="cm">/* FIFO checked in this slice */</span>
	<span class="n">CFQ_CFQQ_FLAG_idle_window</span><span class="p">,</span>	<span class="cm">/* slice idling enabled */</span>
	<span class="n">CFQ_CFQQ_FLAG_prio_changed</span><span class="p">,</span>	<span class="cm">/* task priority has changed */</span>
	<span class="n">CFQ_CFQQ_FLAG_slice_new</span><span class="p">,</span>	<span class="cm">/* no requests dispatched in slice */</span>
	<span class="n">CFQ_CFQQ_FLAG_sync</span><span class="p">,</span>		<span class="cm">/* synchronous queue */</span>
	<span class="n">CFQ_CFQQ_FLAG_coop</span><span class="p">,</span>		<span class="cm">/* cfqq is shared */</span>
	<span class="n">CFQ_CFQQ_FLAG_split_coop</span><span class="p">,</span>	<span class="cm">/* shared cfqq will be splitted */</span>
	<span class="n">CFQ_CFQQ_FLAG_deep</span><span class="p">,</span>		<span class="cm">/* sync cfqq experienced large depth */</span>
	<span class="n">CFQ_CFQQ_FLAG_wait_busy</span><span class="p">,</span>	<span class="cm">/* Waiting for next request */</span>
<span class="p">};</span>

<span class="cp">#define CFQ_CFQQ_FNS(name)						\</span>
<span class="cp">static inline void cfq_mark_cfqq_##name(struct cfq_queue *cfqq)		\</span>
<span class="cp">{									\</span>
<span class="cp">	(cfqq)-&gt;flags |= (1 &lt;&lt; CFQ_CFQQ_FLAG_##name);			\</span>
<span class="cp">}									\</span>
<span class="cp">static inline void cfq_clear_cfqq_##name(struct cfq_queue *cfqq)	\</span>
<span class="cp">{									\</span>
<span class="cp">	(cfqq)-&gt;flags &amp;= ~(1 &lt;&lt; CFQ_CFQQ_FLAG_##name);			\</span>
<span class="cp">}									\</span>
<span class="cp">static inline int cfq_cfqq_##name(const struct cfq_queue *cfqq)		\</span>
<span class="cp">{									\</span>
<span class="cp">	return ((cfqq)-&gt;flags &amp; (1 &lt;&lt; CFQ_CFQQ_FLAG_##name)) != 0;	\</span>
<span class="cp">}</span>

<span class="n">CFQ_CFQQ_FNS</span><span class="p">(</span><span class="n">on_rr</span><span class="p">);</span>
<span class="n">CFQ_CFQQ_FNS</span><span class="p">(</span><span class="n">wait_request</span><span class="p">);</span>
<span class="n">CFQ_CFQQ_FNS</span><span class="p">(</span><span class="n">must_dispatch</span><span class="p">);</span>
<span class="n">CFQ_CFQQ_FNS</span><span class="p">(</span><span class="n">must_alloc_slice</span><span class="p">);</span>
<span class="n">CFQ_CFQQ_FNS</span><span class="p">(</span><span class="n">fifo_expire</span><span class="p">);</span>
<span class="n">CFQ_CFQQ_FNS</span><span class="p">(</span><span class="n">idle_window</span><span class="p">);</span>
<span class="n">CFQ_CFQQ_FNS</span><span class="p">(</span><span class="n">prio_changed</span><span class="p">);</span>
<span class="n">CFQ_CFQQ_FNS</span><span class="p">(</span><span class="n">slice_new</span><span class="p">);</span>
<span class="n">CFQ_CFQQ_FNS</span><span class="p">(</span><span class="n">sync</span><span class="p">);</span>
<span class="n">CFQ_CFQQ_FNS</span><span class="p">(</span><span class="n">coop</span><span class="p">);</span>
<span class="n">CFQ_CFQQ_FNS</span><span class="p">(</span><span class="n">split_coop</span><span class="p">);</span>
<span class="n">CFQ_CFQQ_FNS</span><span class="p">(</span><span class="n">deep</span><span class="p">);</span>
<span class="n">CFQ_CFQQ_FNS</span><span class="p">(</span><span class="n">wait_busy</span><span class="p">);</span>
<span class="cp">#undef CFQ_CFQQ_FNS</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="nf">pd_to_cfqg</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkg_policy_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pd</span> <span class="o">?</span> <span class="n">container_of</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_group</span><span class="p">,</span> <span class="n">pd</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="nf">cfqg_to_blkg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pd_to_blkg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">pd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_CFQ_GROUP_IOSCHED) &amp;&amp; defined(CONFIG_DEBUG_BLK_CGROUP)</span>

<span class="cm">/* cfqg stats flags */</span>
<span class="k">enum</span> <span class="n">cfqg_stats_flags</span> <span class="p">{</span>
	<span class="n">CFQG_stats_waiting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">CFQG_stats_idling</span><span class="p">,</span>
	<span class="n">CFQG_stats_empty</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define CFQG_FLAG_FNS(name)						\</span>
<span class="cp">static inline void cfqg_stats_mark_##name(struct cfqg_stats *stats)	\</span>
<span class="cp">{									\</span>
<span class="cp">	stats-&gt;flags |= (1 &lt;&lt; CFQG_stats_##name);			\</span>
<span class="cp">}									\</span>
<span class="cp">static inline void cfqg_stats_clear_##name(struct cfqg_stats *stats)	\</span>
<span class="cp">{									\</span>
<span class="cp">	stats-&gt;flags &amp;= ~(1 &lt;&lt; CFQG_stats_##name);			\</span>
<span class="cp">}									\</span>
<span class="cp">static inline int cfqg_stats_##name(struct cfqg_stats *stats)		\</span>
<span class="cp">{									\</span>
<span class="cp">	return (stats-&gt;flags &amp; (1 &lt;&lt; CFQG_stats_##name)) != 0;		\</span>
<span class="cp">}									\</span>

<span class="n">CFQG_FLAG_FNS</span><span class="p">(</span><span class="n">waiting</span><span class="p">)</span>
<span class="n">CFQG_FLAG_FNS</span><span class="p">(</span><span class="n">idling</span><span class="p">)</span>
<span class="n">CFQG_FLAG_FNS</span><span class="p">(</span><span class="n">empty</span><span class="p">)</span>
<span class="cp">#undef CFQG_FLAG_FNS</span>

<span class="cm">/* This should be called with the queue_lock held. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">cfqg_stats_update_group_wait_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfqg_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">now</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqg_stats_waiting</span><span class="p">(</span><span class="n">stats</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">sched_clock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_after64</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">start_group_wait_time</span><span class="p">))</span>
		<span class="n">blkg_stat_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">group_wait_time</span><span class="p">,</span>
			      <span class="n">now</span> <span class="o">-</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">start_group_wait_time</span><span class="p">);</span>
	<span class="n">cfqg_stats_clear_waiting</span><span class="p">(</span><span class="n">stats</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This should be called with the queue_lock held. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">cfqg_stats_set_start_group_wait_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">curr_cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfqg_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqg_stats_waiting</span><span class="p">(</span><span class="n">stats</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqg</span> <span class="o">==</span> <span class="n">curr_cfqg</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">start_group_wait_time</span> <span class="o">=</span> <span class="n">sched_clock</span><span class="p">();</span>
	<span class="n">cfqg_stats_mark_waiting</span><span class="p">(</span><span class="n">stats</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This should be called with the queue_lock held. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">cfqg_stats_end_empty_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfqg_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">now</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqg_stats_empty</span><span class="p">(</span><span class="n">stats</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">sched_clock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_after64</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">start_empty_time</span><span class="p">))</span>
		<span class="n">blkg_stat_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">empty_time</span><span class="p">,</span>
			      <span class="n">now</span> <span class="o">-</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">start_empty_time</span><span class="p">);</span>
	<span class="n">cfqg_stats_clear_empty</span><span class="p">(</span><span class="n">stats</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">cfqg_stats_update_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blkg_stat_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">dequeue</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">cfqg_stats_set_start_empty_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfqg_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blkg_rwstat_sum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * group is already marked empty. This can happen if cfqq got new</span>
<span class="cm">	 * request in parent group and moved to this group while being added</span>
<span class="cm">	 * to service tree. Just ignore the event and move on.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqg_stats_empty</span><span class="p">(</span><span class="n">stats</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">start_empty_time</span> <span class="o">=</span> <span class="n">sched_clock</span><span class="p">();</span>
	<span class="n">cfqg_stats_mark_empty</span><span class="p">(</span><span class="n">stats</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">cfqg_stats_update_idle_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfqg_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqg_stats_idling</span><span class="p">(</span><span class="n">stats</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">sched_clock</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_after64</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">start_idle_time</span><span class="p">))</span>
			<span class="n">blkg_stat_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">idle_time</span><span class="p">,</span>
				      <span class="n">now</span> <span class="o">-</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">start_idle_time</span><span class="p">);</span>
		<span class="n">cfqg_stats_clear_idling</span><span class="p">(</span><span class="n">stats</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">cfqg_stats_set_start_idle_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfqg_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cfqg_stats_idling</span><span class="p">(</span><span class="n">stats</span><span class="p">));</span>

	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">start_idle_time</span> <span class="o">=</span> <span class="n">sched_clock</span><span class="p">();</span>
	<span class="n">cfqg_stats_mark_idling</span><span class="p">(</span><span class="n">stats</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">cfqg_stats_update_avg_queue_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfqg_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>

	<span class="n">blkg_stat_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">avg_queue_size_sum</span><span class="p">,</span>
		      <span class="n">blkg_rwstat_sum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">));</span>
	<span class="n">blkg_stat_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">avg_queue_size_samples</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">cfqg_stats_update_group_wait_time</span><span class="p">(</span><span class="n">stats</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else	</span><span class="cm">/* CONFIG_CFQ_GROUP_IOSCHED &amp;&amp; CONFIG_DEBUG_BLK_CGROUP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">cfqg_stats_set_start_group_wait_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">curr_cfqg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">cfqg_stats_end_empty_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfqg_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">cfqg_stats_update_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">cfqg_stats_set_start_empty_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">cfqg_stats_update_idle_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">cfqg_stats_set_start_idle_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">cfqg_stats_update_avg_queue_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_CFQ_GROUP_IOSCHED &amp;&amp; CONFIG_DEBUG_BLK_CGROUP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_CFQ_GROUP_IOSCHED</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">blkcg_policy</span> <span class="n">blkcg_policy_cfq</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="nf">blkg_to_cfqg</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pd_to_cfqg</span><span class="p">(</span><span class="n">blkg_to_pd</span><span class="p">(</span><span class="n">blkg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkcg_policy_cfq</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfqg_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blkg_get</span><span class="p">(</span><span class="n">cfqg_to_blkg</span><span class="p">(</span><span class="n">cfqg</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfqg_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blkg_put</span><span class="p">(</span><span class="n">cfqg_to_blkg</span><span class="p">(</span><span class="n">cfqg</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define cfq_log_cfqq(cfqd, cfqq, fmt, args...)	do {			\</span>
<span class="cp">	char __pbuf[128];						\</span>
<span class="cp">									\</span>
<span class="cp">	blkg_path(cfqg_to_blkg((cfqq)-&gt;cfqg), __pbuf, sizeof(__pbuf));	\</span>
<span class="cp">	blk_add_trace_msg((cfqd)-&gt;queue, &quot;cfq%d%c %s &quot; fmt, (cfqq)-&gt;pid, \</span>
<span class="cp">			  cfq_cfqq_sync((cfqq)) ? &#39;S&#39; : &#39;A&#39;,		\</span>
<span class="cp">			  __pbuf, ##args);				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define cfq_log_cfqg(cfqd, cfqg, fmt, args...)	do {			\</span>
<span class="cp">	char __pbuf[128];						\</span>
<span class="cp">									\</span>
<span class="cp">	blkg_path(cfqg_to_blkg(cfqg), __pbuf, sizeof(__pbuf));		\</span>
<span class="cp">	blk_add_trace_msg((cfqd)-&gt;queue, &quot;%s &quot; fmt, __pbuf, ##args);	\</span>
<span class="cp">} while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfqg_stats_update_io_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">curr_cfqg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blkg_rwstat_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">queued</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">cfqg_stats_end_empty_time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">);</span>
	<span class="n">cfqg_stats_set_start_group_wait_time</span><span class="p">(</span><span class="n">cfqg</span><span class="p">,</span> <span class="n">curr_cfqg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfqg_stats_update_timeslice_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unaccounted_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blkg_stat_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">time</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_DEBUG_BLK_CGROUP</span>
	<span class="n">blkg_stat_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">unaccounted_time</span><span class="p">,</span> <span class="n">unaccounted_time</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfqg_stats_update_io_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blkg_rwstat_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">queued</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfqg_stats_update_io_merged</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blkg_rwstat_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">merged</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfqg_stats_update_dispatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span>
					      <span class="kt">uint64_t</span> <span class="n">bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blkg_stat_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sectors</span><span class="p">,</span> <span class="n">bytes</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">blkg_rwstat_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">serviced</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">blkg_rwstat_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">service_bytes</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfqg_stats_update_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span>
			<span class="kt">uint64_t</span> <span class="n">start_time</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">io_start_time</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfqg_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">sched_clock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_after64</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">io_start_time</span><span class="p">))</span>
		<span class="n">blkg_rwstat_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">service_time</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="n">now</span> <span class="o">-</span> <span class="n">io_start_time</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_after64</span><span class="p">(</span><span class="n">io_start_time</span><span class="p">,</span> <span class="n">start_time</span><span class="p">))</span>
		<span class="n">blkg_rwstat_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">wait_time</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span>
				<span class="n">io_start_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_pd_reset_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span> <span class="o">=</span> <span class="n">blkg_to_cfqg</span><span class="p">(</span><span class="n">blkg</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cfqg_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>

	<span class="cm">/* queued stats shouldn&#39;t be cleared */</span>
	<span class="n">blkg_rwstat_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">service_bytes</span><span class="p">);</span>
	<span class="n">blkg_rwstat_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">serviced</span><span class="p">);</span>
	<span class="n">blkg_rwstat_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">merged</span><span class="p">);</span>
	<span class="n">blkg_rwstat_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">service_time</span><span class="p">);</span>
	<span class="n">blkg_rwstat_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">wait_time</span><span class="p">);</span>
	<span class="n">blkg_stat_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_DEBUG_BLK_CGROUP</span>
	<span class="n">blkg_stat_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">unaccounted_time</span><span class="p">);</span>
	<span class="n">blkg_stat_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">avg_queue_size_sum</span><span class="p">);</span>
	<span class="n">blkg_stat_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">avg_queue_size_samples</span><span class="p">);</span>
	<span class="n">blkg_stat_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">);</span>
	<span class="n">blkg_stat_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">group_wait_time</span><span class="p">);</span>
	<span class="n">blkg_stat_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">idle_time</span><span class="p">);</span>
	<span class="n">blkg_stat_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">empty_time</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#else	</span><span class="cm">/* CONFIG_CFQ_GROUP_IOSCHED */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfqg_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfqg_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="cp">#define cfq_log_cfqq(cfqd, cfqq, fmt, args...)	\</span>
<span class="cp">	blk_add_trace_msg((cfqd)-&gt;queue, &quot;cfq%d &quot; fmt, (cfqq)-&gt;pid, ##args)</span>
<span class="cp">#define cfq_log_cfqg(cfqd, cfqg, fmt, args...)		do {} while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfqg_stats_update_io_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">curr_cfqg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfqg_stats_update_timeslice_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unaccounted_time</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfqg_stats_update_io_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfqg_stats_update_io_merged</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfqg_stats_update_dispatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span>
					      <span class="kt">uint64_t</span> <span class="n">bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfqg_stats_update_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span>
			<span class="kt">uint64_t</span> <span class="n">start_time</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">io_start_time</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_CFQ_GROUP_IOSCHED */</span><span class="cp"></span>

<span class="cp">#define cfq_log(cfqd, fmt, args...)	\</span>
<span class="cp">	blk_add_trace_msg((cfqd)-&gt;queue, &quot;cfq &quot; fmt, ##args)</span>

<span class="cm">/* Traverses through cfq group service trees */</span>
<span class="cp">#define for_each_cfqg_st(cfqg, i, j, st) \</span>
<span class="cp">	for (i = 0; i &lt;= IDLE_WORKLOAD; i++) \</span>
<span class="cp">		for (j = 0, st = i &lt; IDLE_WORKLOAD ? &amp;cfqg-&gt;service_trees[i][j]\</span>
<span class="cp">			: &amp;cfqg-&gt;service_tree_idle; \</span>
<span class="cp">			(i &lt; IDLE_WORKLOAD &amp;&amp; j &lt;= SYNC_WORKLOAD) || \</span>
<span class="cp">			(i == IDLE_WORKLOAD &amp;&amp; j == 0); \</span>
<span class="cp">			j++, st = i &lt; IDLE_WORKLOAD ? \</span>
<span class="cp">			&amp;cfqg-&gt;service_trees[i][j]: NULL) \</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cfq_io_thinktime_big</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">cfq_ttime</span> <span class="o">*</span><span class="n">ttime</span><span class="p">,</span> <span class="n">bool</span> <span class="n">group_idle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">slice</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sample_valid</span><span class="p">(</span><span class="n">ttime</span><span class="o">-&gt;</span><span class="n">ttime_samples</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group_idle</span><span class="p">)</span>
		<span class="n">slice</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_group_idle</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">slice</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_idle</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ttime</span><span class="o">-&gt;</span><span class="n">ttime_mean</span> <span class="o">&gt;</span> <span class="n">slice</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">iops_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we are not idling on queues and it is a NCQ drive, parallel</span>
<span class="cm">	 * execution of requests is on and measuring time is not possible</span>
<span class="cm">	 * in most of the cases until and unless we drive shallower queue</span>
<span class="cm">	 * depths and that becomes a performance bottleneck. In such cases</span>
<span class="cm">	 * switch to start providing fairness in terms of number of IOs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_idle</span> <span class="o">&amp;&amp;</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">hw_tag</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">wl_prio_t</span> <span class="nf">cfqq_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_class_idle</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IDLE_WORKLOAD</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_class_rt</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">RT_WORKLOAD</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">BE_WORKLOAD</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">enum</span> <span class="n">wl_type_t</span> <span class="nf">cfqq_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ASYNC_WORKLOAD</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_cfqq_idle_window</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">SYNC_NOIDLE_WORKLOAD</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">SYNC_WORKLOAD</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cfq_group_busy_queues_wl</span><span class="p">(</span><span class="k">enum</span> <span class="n">wl_prio_t</span> <span class="n">wl</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wl</span> <span class="o">==</span> <span class="n">IDLE_WORKLOAD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">service_tree_idle</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">service_trees</span><span class="p">[</span><span class="n">wl</span><span class="p">][</span><span class="n">ASYNC_WORKLOAD</span><span class="p">].</span><span class="n">count</span>
		<span class="o">+</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">service_trees</span><span class="p">[</span><span class="n">wl</span><span class="p">][</span><span class="n">SYNC_NOIDLE_WORKLOAD</span><span class="p">].</span><span class="n">count</span>
		<span class="o">+</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">service_trees</span><span class="p">[</span><span class="n">wl</span><span class="p">][</span><span class="n">SYNC_WORKLOAD</span><span class="p">].</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cfqg_busy_async_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">service_trees</span><span class="p">[</span><span class="n">RT_WORKLOAD</span><span class="p">][</span><span class="n">ASYNC_WORKLOAD</span><span class="p">].</span><span class="n">count</span>
		<span class="o">+</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">service_trees</span><span class="p">[</span><span class="n">BE_WORKLOAD</span><span class="p">][</span><span class="n">ASYNC_WORKLOAD</span><span class="p">].</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">cfq_dispatch_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfq_get_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_sync</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
				       <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="nf">icq_to_cic</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_cq</span> <span class="o">*</span><span class="n">icq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* cic-&gt;icq is the first member, %NULL will convert to %NULL */</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">icq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_io_cq</span><span class="p">,</span> <span class="n">icq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="nf">cfq_cic_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">ioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">icq_to_cic</span><span class="p">(</span><span class="n">ioc_lookup_icq</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">));</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="nf">cic_to_cfqq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cic</span><span class="o">-&gt;</span><span class="n">cfqq</span><span class="p">[</span><span class="n">is_sync</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cic_set_cfqq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">is_sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cic</span><span class="o">-&gt;</span><span class="n">cfqq</span><span class="p">[</span><span class="n">is_sync</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfqq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="nf">cic_to_cfqd</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cic</span><span class="o">-&gt;</span><span class="n">icq</span><span class="p">.</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">elevator_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We regard a request as SYNC, if it&#39;s either a read or has the SYNC bit</span>
<span class="cm"> * set (in which case it could also be direct WRITE).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cfq_bio_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span> <span class="o">||</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_SYNC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * scheduler run of queue, if there are requests pending and no one in the</span>
<span class="cm"> * driver that will restart queueing</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfq_schedule_dispatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">busy_queues</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfq_log</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="s">&quot;schedule dispatch&quot;</span><span class="p">);</span>
		<span class="n">kblockd_schedule_work</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">unplug_work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scale schedule slice based on io priority. Use the sync time slice only</span>
<span class="cm"> * if a queue is marked sync and has sync io queued. A sync queue with async</span>
<span class="cm"> * io only, should not get full sync slice length.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cfq_prio_slice</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">bool</span> <span class="n">sync</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">prio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">base_slice</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice</span><span class="p">[</span><span class="n">sync</span><span class="p">];</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">prio</span> <span class="o">&gt;=</span> <span class="n">IOPRIO_BE_NR</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">base_slice</span> <span class="o">+</span> <span class="p">(</span><span class="n">base_slice</span><span class="o">/</span><span class="n">CFQ_SLICE_SCALE</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">-</span> <span class="n">prio</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">cfq_prio_to_slice</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cfq_prio_slice</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">),</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ioprio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">cfq_scale_slice</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">d</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">&lt;&lt;</span> <span class="n">CFQ_SERVICE_SHIFT</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">CFQ_WEIGHT_DEFAULT</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">max_vdisktime</span><span class="p">(</span><span class="n">u64</span> <span class="n">min_vdisktime</span><span class="p">,</span> <span class="n">u64</span> <span class="n">vdisktime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)(</span><span class="n">vdisktime</span> <span class="o">-</span> <span class="n">min_vdisktime</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">min_vdisktime</span> <span class="o">=</span> <span class="n">vdisktime</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">min_vdisktime</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">min_vdisktime</span><span class="p">(</span><span class="n">u64</span> <span class="n">min_vdisktime</span><span class="p">,</span> <span class="n">u64</span> <span class="n">vdisktime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)(</span><span class="n">vdisktime</span> <span class="o">-</span> <span class="n">min_vdisktime</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">min_vdisktime</span> <span class="o">=</span> <span class="n">vdisktime</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">min_vdisktime</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_min_vdisktime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfqg</span> <span class="o">=</span> <span class="n">rb_entry_cfqg</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">min_vdisktime</span> <span class="o">=</span> <span class="n">max_vdisktime</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">min_vdisktime</span><span class="p">,</span>
						  <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">vdisktime</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get averaged number of queues of RT/BE priority.</span>
<span class="cm"> * average is updated, with a formula that gives more weight to higher numbers,</span>
<span class="cm"> * to quickly follows sudden increases and decrease slowly</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">cfq_group_get_avg_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span> <span class="n">bool</span> <span class="n">rt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">min_q</span><span class="p">,</span> <span class="n">max_q</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">mult</span>  <span class="o">=</span> <span class="n">cfq_hist_divisor</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">round</span> <span class="o">=</span> <span class="n">cfq_hist_divisor</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">busy</span> <span class="o">=</span> <span class="n">cfq_group_busy_queues_wl</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span> <span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">);</span>

	<span class="n">min_q</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">busy_queues_avg</span><span class="p">[</span><span class="n">rt</span><span class="p">],</span> <span class="n">busy</span><span class="p">);</span>
	<span class="n">max_q</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">busy_queues_avg</span><span class="p">[</span><span class="n">rt</span><span class="p">],</span> <span class="n">busy</span><span class="p">);</span>
	<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">busy_queues_avg</span><span class="p">[</span><span class="n">rt</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mult</span> <span class="o">*</span> <span class="n">max_q</span> <span class="o">+</span> <span class="n">min_q</span> <span class="o">+</span> <span class="n">round</span><span class="p">)</span> <span class="o">/</span>
		<span class="n">cfq_hist_divisor</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">busy_queues_avg</span><span class="p">[</span><span class="n">rt</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span>
<span class="nf">cfq_group_slice</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">grp_service_tree</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_target_latency</span> <span class="o">*</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">/</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">total_weight</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span>
<span class="nf">cfq_scaled_cfqq_slice</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">slice</span> <span class="o">=</span> <span class="n">cfq_prio_to_slice</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_latency</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * interested queues (we consider only the ones with the same</span>
<span class="cm">		 * priority class in the cfq group)</span>
<span class="cm">		 */</span>
		<span class="kt">unsigned</span> <span class="n">iq</span> <span class="o">=</span> <span class="n">cfq_group_get_avg_queues</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">,</span>
						<span class="n">cfq_class_rt</span><span class="p">(</span><span class="n">cfqq</span><span class="p">));</span>
		<span class="kt">unsigned</span> <span class="n">sync_slice</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="n">expect_latency</span> <span class="o">=</span> <span class="n">sync_slice</span> <span class="o">*</span> <span class="n">iq</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">group_slice</span> <span class="o">=</span> <span class="n">cfq_group_slice</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">expect_latency</span> <span class="o">&gt;</span> <span class="n">group_slice</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="n">base_low_slice</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_idle</span><span class="p">;</span>
			<span class="cm">/* scale low_slice according to IO priority</span>
<span class="cm">			 * and sync vs async */</span>
			<span class="kt">unsigned</span> <span class="n">low_slice</span> <span class="o">=</span>
				<span class="n">min</span><span class="p">(</span><span class="n">slice</span><span class="p">,</span> <span class="n">base_low_slice</span> <span class="o">*</span> <span class="n">slice</span> <span class="o">/</span> <span class="n">sync_slice</span><span class="p">);</span>
			<span class="cm">/* the adapted slice value is scaled to fit all iqs</span>
<span class="cm">			 * into the target latency */</span>
			<span class="n">slice</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">slice</span> <span class="o">*</span> <span class="n">group_slice</span> <span class="o">/</span> <span class="n">expect_latency</span><span class="p">,</span>
				    <span class="n">low_slice</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">slice</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">cfq_set_prio_slice</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">slice</span> <span class="o">=</span> <span class="n">cfq_scaled_cfqq_slice</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>

	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_end</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">slice</span><span class="p">;</span>
	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">allocated_slice</span> <span class="o">=</span> <span class="n">slice</span><span class="p">;</span>
	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;set_slice=%lu&quot;</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_end</span> <span class="o">-</span> <span class="n">jiffies</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We need to wrap this check in cfq_cfqq_slice_new(), since -&gt;slice_end</span>
<span class="cm"> * isn&#39;t valid until the first request from the dispatch is activated</span>
<span class="cm"> * and the slice time set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cfq_slice_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_slice_new</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_end</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Lifted from AS - choose which of rq1 and rq2 that is best served now.</span>
<span class="cm"> * We choose the request that is closest to the head right now. Distance</span>
<span class="cm"> * behind the head is penalized and only allowed to a certain extent.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span>
<span class="nf">cfq_choose_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq2</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">back_max</span><span class="p">;</span>
<span class="cp">#define CFQ_RQ1_WRAP	0x01 </span><span class="cm">/* request 1 wraps */</span><span class="cp"></span>
<span class="cp">#define CFQ_RQ2_WRAP	0x02 </span><span class="cm">/* request 2 wraps */</span><span class="cp"></span>
	<span class="kt">unsigned</span> <span class="n">wrap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* bit mask: requests behind the disk head? */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq1</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">rq1</span> <span class="o">==</span> <span class="n">rq2</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rq2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rq1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rq_is_sync</span><span class="p">(</span><span class="n">rq1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rq_is_sync</span><span class="p">(</span><span class="n">rq2</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">rq_is_sync</span><span class="p">(</span><span class="n">rq1</span><span class="p">)</span> <span class="o">?</span> <span class="n">rq1</span> <span class="o">:</span> <span class="n">rq2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rq1</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">^</span> <span class="n">rq2</span><span class="o">-&gt;</span><span class="n">cmd_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">REQ_PRIO</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rq1</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_PRIO</span> <span class="o">?</span> <span class="n">rq1</span> <span class="o">:</span> <span class="n">rq2</span><span class="p">;</span>

	<span class="n">s1</span> <span class="o">=</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq1</span><span class="p">);</span>
	<span class="n">s2</span> <span class="o">=</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq2</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * by definition, 1KiB is 2 sectors</span>
<span class="cm">	 */</span>
	<span class="n">back_max</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_back_max</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Strict one way elevator _except_ in the case where we allow</span>
<span class="cm">	 * short backward seeks which are biased as twice the cost of a</span>
<span class="cm">	 * similar forward seek.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s1</span> <span class="o">&gt;=</span> <span class="n">last</span><span class="p">)</span>
		<span class="n">d1</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">-</span> <span class="n">last</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s1</span> <span class="o">+</span> <span class="n">back_max</span> <span class="o">&gt;=</span> <span class="n">last</span><span class="p">)</span>
		<span class="n">d1</span> <span class="o">=</span> <span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">s1</span><span class="p">)</span> <span class="o">*</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_back_penalty</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">wrap</span> <span class="o">|=</span> <span class="n">CFQ_RQ1_WRAP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s2</span> <span class="o">&gt;=</span> <span class="n">last</span><span class="p">)</span>
		<span class="n">d2</span> <span class="o">=</span> <span class="n">s2</span> <span class="o">-</span> <span class="n">last</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s2</span> <span class="o">+</span> <span class="n">back_max</span> <span class="o">&gt;=</span> <span class="n">last</span><span class="p">)</span>
		<span class="n">d2</span> <span class="o">=</span> <span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">s2</span><span class="p">)</span> <span class="o">*</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_back_penalty</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">wrap</span> <span class="o">|=</span> <span class="n">CFQ_RQ2_WRAP</span><span class="p">;</span>

	<span class="cm">/* Found required data */</span>

	<span class="cm">/*</span>
<span class="cm">	 * By doing switch() on the bit mask &quot;wrap&quot; we avoid having to</span>
<span class="cm">	 * check two variables for all permutations: --&gt; faster!</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">wrap</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* common case for CFQ: rq1 and rq2 not wrapped */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d1</span> <span class="o">&lt;</span> <span class="n">d2</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rq1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">d2</span> <span class="o">&lt;</span> <span class="n">d1</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rq2</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s1</span> <span class="o">&gt;=</span> <span class="n">s2</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">rq1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="n">rq2</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">case</span> <span class="n">CFQ_RQ2_WRAP</span>:
		<span class="k">return</span> <span class="n">rq1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CFQ_RQ1_WRAP</span>:
		<span class="k">return</span> <span class="n">rq2</span><span class="p">;</span>
	<span class="k">case</span> <span class="p">(</span><span class="n">CFQ_RQ1_WRAP</span><span class="o">|</span><span class="n">CFQ_RQ2_WRAP</span><span class="p">)</span>: <span class="cm">/* both rqs wrapped */</span>
	<span class="nl">default:</span>
		<span class="cm">/*</span>
<span class="cm">		 * Since both rqs are wrapped,</span>
<span class="cm">		 * start with the one that&#39;s further behind head</span>
<span class="cm">		 * (--&gt; only *one* back seek required),</span>
<span class="cm">		 * since back seek takes more time than forward.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s1</span> <span class="o">&lt;=</span> <span class="n">s2</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rq1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">rq2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The below is leftmost cache rbtree addon</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="nf">cfq_rb_first</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Service tree is empty */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="nf">cfq_rb_first_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rb_entry_cfqg</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rb_erase_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="n">RB_CLEAR_NODE</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_rb_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rb_erase_init</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
	<span class="o">--</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * would be nice to take fifo expire time into account as well</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span>
<span class="nf">cfq_find_next_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rbnext</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rbprev</span> <span class="o">=</span> <span class="n">rb_prev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">RB_EMPTY_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rbprev</span><span class="p">)</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">rb_entry_rq</span><span class="p">(</span><span class="n">rbprev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rbnext</span><span class="p">)</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">rb_entry_rq</span><span class="p">(</span><span class="n">rbnext</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">rbnext</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rbnext</span> <span class="o">&amp;&amp;</span> <span class="n">rbnext</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">)</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">rb_entry_rq</span><span class="p">(</span><span class="n">rbnext</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cfq_choose_req</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">last</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">cfq_slice_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * just an approximation, should be ok.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">nr_cfqq</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">cfq_prio_slice</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span>
		       <span class="n">cfq_prio_slice</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">),</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ioprio</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span>
<span class="nf">cfqg_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">st</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">vdisktime</span> <span class="o">-</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">min_vdisktime</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__cfq_group_service_tree_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">st</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">__cfqg</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">key</span> <span class="o">=</span> <span class="n">cfqg_key</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
		<span class="n">__cfqg</span> <span class="o">=</span> <span class="n">rb_entry_cfqg</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">cfqg_key</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">__cfqg</span><span class="p">))</span>
			<span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
			<span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cfq_update_group_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">RB_EMPTY_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">new_weight</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">new_weight</span><span class="p">;</span>
		<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">new_weight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cfq_group_service_tree_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">st</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">RB_EMPTY_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">));</span>

	<span class="n">cfq_update_group_weight</span><span class="p">(</span><span class="n">cfqg</span><span class="p">);</span>
	<span class="n">__cfq_group_service_tree_add</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">);</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">total_weight</span> <span class="o">+=</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cfq_group_notify_queue_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">grp_service_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">__cfqg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">nr_cfqq</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RB_EMPTY_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Currently put the group at the end. Later implement something</span>
<span class="cm">	 * so that groups get lesser vtime based on their weights, so that</span>
<span class="cm">	 * if group does not loose all if it was not continuously backlogged.</span>
<span class="cm">	 */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">rb_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__cfqg</span> <span class="o">=</span> <span class="n">rb_entry_cfqg</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
		<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">vdisktime</span> <span class="o">=</span> <span class="n">__cfqg</span><span class="o">-&gt;</span><span class="n">vdisktime</span> <span class="o">+</span> <span class="n">CFQ_IDLE_DELAY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">vdisktime</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">min_vdisktime</span><span class="p">;</span>
	<span class="n">cfq_group_service_tree_add</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cfq_group_service_tree_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">st</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">total_weight</span> <span class="o">-=</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RB_EMPTY_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">))</span>
		<span class="n">cfq_rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">st</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cfq_group_notify_queue_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">grp_service_tree</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">nr_cfqq</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">nr_cfqq</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* If there are other cfq queues under this group, don&#39;t delete it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">nr_cfqq</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cfq_log_cfqg</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">,</span> <span class="s">&quot;del_from_rr group&quot;</span><span class="p">);</span>
	<span class="n">cfq_group_service_tree_del</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">);</span>
	<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">saved_workload_slice</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cfqg_stats_update_dequeue</span><span class="p">(</span><span class="n">cfqg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cfq_cfqq_slice_usage</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">unaccounted_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slice_used</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Queue got expired before even a single request completed or</span>
<span class="cm">	 * got expired immediately after first request completion.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_start</span> <span class="o">||</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_start</span> <span class="o">==</span> <span class="n">jiffies</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Also charge the seek time incurred to the group, otherwise</span>
<span class="cm">		 * if there are mutiple queues in the group, each can dispatch</span>
<span class="cm">		 * a single request on seeky media and cause lots of seek time</span>
<span class="cm">		 * and group will never know it.</span>
<span class="cm">		 */</span>
		<span class="n">slice_used</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">dispatch_start</span><span class="p">),</span>
					<span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">slice_used</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slice_used</span> <span class="o">&gt;</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">allocated_slice</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">unaccounted_time</span> <span class="o">=</span> <span class="n">slice_used</span> <span class="o">-</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">allocated_slice</span><span class="p">;</span>
			<span class="n">slice_used</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">allocated_slice</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_start</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">dispatch_start</span><span class="p">))</span>
			<span class="o">*</span><span class="n">unaccounted_time</span> <span class="o">+=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_start</span> <span class="o">-</span>
					<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">dispatch_start</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">slice_used</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_group_served</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">grp_service_tree</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">used_sl</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">unaccounted_sl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_sync</span> <span class="o">=</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">nr_cfqq</span> <span class="o">-</span> <span class="n">cfqg_busy_async_queues</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">)</span>
			<span class="o">-</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">service_tree_idle</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nr_sync</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">used_sl</span> <span class="o">=</span> <span class="n">charge</span> <span class="o">=</span> <span class="n">cfq_cfqq_slice_usage</span><span class="p">(</span><span class="n">cfqq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unaccounted_sl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iops_mode</span><span class="p">(</span><span class="n">cfqd</span><span class="p">))</span>
		<span class="n">charge</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_dispatch</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nr_sync</span><span class="p">)</span>
		<span class="n">charge</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">allocated_slice</span><span class="p">;</span>

	<span class="cm">/* Can&#39;t update vdisktime while group is on service tree */</span>
	<span class="n">cfq_group_service_tree_del</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">);</span>
	<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">vdisktime</span> <span class="o">+=</span> <span class="n">cfq_scale_slice</span><span class="p">(</span><span class="n">charge</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">);</span>
	<span class="cm">/* If a new weight was requested, update now, off tree */</span>
	<span class="n">cfq_group_service_tree_add</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">);</span>

	<span class="cm">/* This group is being expired. Save the context */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">workload_expires</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">saved_workload_slice</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">workload_expires</span>
						<span class="o">-</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">saved_workload</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_type</span><span class="p">;</span>
		<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">saved_serving_prio</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_prio</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">saved_workload_slice</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cfq_log_cfqg</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">,</span> <span class="s">&quot;served: vt=%llu min_vt=%llu&quot;</span><span class="p">,</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">vdisktime</span><span class="p">,</span>
					<span class="n">st</span><span class="o">-&gt;</span><span class="n">min_vdisktime</span><span class="p">);</span>
	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span>
		     <span class="s">&quot;sl_used=%u disp=%u charge=%u iops=%u sect=%lu&quot;</span><span class="p">,</span>
		     <span class="n">used_sl</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_dispatch</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span>
		     <span class="n">iops_mode</span><span class="p">(</span><span class="n">cfqd</span><span class="p">),</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">nr_sectors</span><span class="p">);</span>
	<span class="n">cfqg_stats_update_timeslice_used</span><span class="p">(</span><span class="n">cfqg</span><span class="p">,</span> <span class="n">used_sl</span><span class="p">,</span> <span class="n">unaccounted_sl</span><span class="p">);</span>
	<span class="n">cfqg_stats_set_start_empty_time</span><span class="p">(</span><span class="n">cfqg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cfq_init_cfqg_base - initialize base part of a cfq_group</span>
<span class="cm"> * @cfqg: cfq_group to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize the base part which is used whether %CONFIG_CFQ_GROUP_IOSCHED</span>
<span class="cm"> * is enabled or not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_init_cfqg_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">for_each_cfqg_st</span><span class="p">(</span><span class="n">cfqg</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">st</span><span class="p">)</span>
		<span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="n">CFQ_RB_ROOT</span><span class="p">;</span>
	<span class="n">RB_CLEAR_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>

	<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">.</span><span class="n">last_end_request</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CFQ_GROUP_IOSCHED</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_pd_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span> <span class="o">=</span> <span class="n">blkg_to_cfqg</span><span class="p">(</span><span class="n">blkg</span><span class="p">);</span>

	<span class="n">cfq_init_cfqg_base</span><span class="p">(</span><span class="n">cfqg</span><span class="p">);</span>
	<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="n">blkg</span><span class="o">-&gt;</span><span class="n">blkcg</span><span class="o">-&gt;</span><span class="n">cfq_weight</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Search for the cfq group current task belongs to. request_queue lock must</span>
<span class="cm"> * be held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="nf">cfq_lookup_create_cfqg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="n">blkcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* avoid lookup for the common case where there&#39;s no blkcg */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blkcg</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">blkcg_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfqg</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">root_group</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">;</span>

		<span class="n">blkg</span> <span class="o">=</span> <span class="n">blkg_lookup_create</span><span class="p">(</span><span class="n">blkcg</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">blkg</span><span class="p">))</span>
			<span class="n">cfqg</span> <span class="o">=</span> <span class="n">blkg_to_cfqg</span><span class="p">(</span><span class="n">blkg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cfqg</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_link_cfqq_cfqg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Currently, all async queues are mapped to root group */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="n">cfqg</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">root_group</span><span class="p">;</span>

	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span> <span class="o">=</span> <span class="n">cfqg</span><span class="p">;</span>
	<span class="cm">/* cfqq reference on cfqg */</span>
	<span class="n">cfqg_get</span><span class="p">(</span><span class="n">cfqg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">cfqg_prfill_weight_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">blkg_policy_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span> <span class="o">=</span> <span class="n">pd_to_cfqg</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">dev_weight</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__blkg_prfill_u64</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="n">pd</span><span class="p">,</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">dev_weight</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfqg_print_weight_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blkcg_print_blkgs</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="n">cgroup_to_blkcg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">),</span>
			  <span class="n">cfqg_prfill_weight_device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkcg_policy_cfq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			  <span class="nb">false</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfq_print_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cgroup_to_blkcg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cfq_weight</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfqg_set_weight_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="n">blkcg</span> <span class="o">=</span> <span class="n">cgroup_to_blkcg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">blkg_conf_ctx</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">blkg_conf_prep</span><span class="p">(</span><span class="n">blkcg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkcg_policy_cfq</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">cfqg</span> <span class="o">=</span> <span class="n">blkg_to_cfqg</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">blkg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">.</span><span class="n">v</span> <span class="o">||</span> <span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="n">CFQ_WEIGHT_MIN</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="p">.</span><span class="n">v</span> <span class="o">&lt;=</span> <span class="n">CFQ_WEIGHT_MAX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">dev_weight</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">v</span><span class="p">;</span>
		<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">new_weight</span> <span class="o">=</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">dev_weight</span> <span class="o">?:</span> <span class="n">blkcg</span><span class="o">-&gt;</span><span class="n">cfq_weight</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">blkg_conf_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfq_set_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="n">blkcg</span> <span class="o">=</span> <span class="n">cgroup_to_blkcg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">CFQ_WEIGHT_MIN</span> <span class="o">||</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">CFQ_WEIGHT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blkcg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">blkcg</span><span class="o">-&gt;</span><span class="n">cfq_weight</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">val</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">blkg</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkcg</span><span class="o">-&gt;</span><span class="n">blkg_list</span><span class="p">,</span> <span class="n">blkcg_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span> <span class="o">=</span> <span class="n">blkg_to_cfqg</span><span class="p">(</span><span class="n">blkg</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cfqg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">dev_weight</span><span class="p">)</span>
			<span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">new_weight</span> <span class="o">=</span> <span class="n">blkcg</span><span class="o">-&gt;</span><span class="n">cfq_weight</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blkcg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfqg_print_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="n">blkcg</span> <span class="o">=</span> <span class="n">cgroup_to_blkcg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>

	<span class="n">blkcg_print_blkgs</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="n">blkcg</span><span class="p">,</span> <span class="n">blkg_prfill_stat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkcg_policy_cfq</span><span class="p">,</span>
			  <span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfqg_print_rwstat</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="n">blkcg</span> <span class="o">=</span> <span class="n">cgroup_to_blkcg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>

	<span class="n">blkcg_print_blkgs</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="n">blkcg</span><span class="p">,</span> <span class="n">blkg_prfill_rwstat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkcg_policy_cfq</span><span class="p">,</span>
			  <span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_BLK_CGROUP</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">cfqg_prfill_avg_queue_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">blkg_policy_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span> <span class="o">=</span> <span class="n">pd_to_cfqg</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">samples</span> <span class="o">=</span> <span class="n">blkg_stat_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">avg_queue_size_samples</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">blkg_stat_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">avg_queue_size_sum</span><span class="p">);</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">samples</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">__blkg_prfill_u64</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="n">pd</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* print avg_queue_size */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfqg_print_avg_queue_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="n">blkcg</span> <span class="o">=</span> <span class="n">cgroup_to_blkcg</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>

	<span class="n">blkcg_print_blkgs</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="n">blkcg</span><span class="p">,</span> <span class="n">cfqg_prfill_avg_queue_size</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">blkcg_policy_cfq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_DEBUG_BLK_CGROUP */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="n">cfq_blkcg_files</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;weight_device&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cfqg_print_weight_device</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_string</span> <span class="o">=</span> <span class="n">cfqg_set_weight_device</span><span class="p">,</span>
		<span class="p">.</span><span class="n">max_write_len</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;weight&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cfq_print_weight</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cfq_set_weight</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;time&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">time</span><span class="p">),</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cfqg_print_stat</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;sectors&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">sectors</span><span class="p">),</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cfqg_print_stat</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;io_service_bytes&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">service_bytes</span><span class="p">),</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cfqg_print_rwstat</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;io_serviced&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">serviced</span><span class="p">),</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cfqg_print_rwstat</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;io_service_time&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">service_time</span><span class="p">),</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cfqg_print_rwstat</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;io_wait_time&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">wait_time</span><span class="p">),</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cfqg_print_rwstat</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;io_merged&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">merged</span><span class="p">),</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cfqg_print_rwstat</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;io_queued&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">queued</span><span class="p">),</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cfqg_print_rwstat</span><span class="p">,</span>
	<span class="p">},</span>
<span class="cp">#ifdef CONFIG_DEBUG_BLK_CGROUP</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;avg_queue_size&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cfqg_print_avg_queue_size</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;group_wait_time&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">group_wait_time</span><span class="p">),</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cfqg_print_stat</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;idle_time&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">idle_time</span><span class="p">),</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cfqg_print_stat</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;empty_time&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">empty_time</span><span class="p">),</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cfqg_print_stat</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;dequeue&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">dequeue</span><span class="p">),</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cfqg_print_stat</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;unaccounted_time&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">unaccounted_time</span><span class="p">),</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cfqg_print_stat</span><span class="p">,</span>
	<span class="p">},</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_DEBUG_BLK_CGROUP */</span><span class="cp"></span>
	<span class="p">{</span> <span class="p">}</span>	<span class="cm">/* terminate */</span>
<span class="p">};</span>
<span class="cp">#else </span><span class="cm">/* GROUP_IOSCHED */</span><span class="cp"></span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="nf">cfq_lookup_create_cfqg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="n">blkcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">root_group</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">cfq_link_cfqq_cfqg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span> <span class="o">=</span> <span class="n">cfqg</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* GROUP_IOSCHED */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The cfqd-&gt;service_trees holds all pending cfq_queue&#39;s that have</span>
<span class="cm"> * requests waiting to be processed. It is sorted in the order that</span>
<span class="cm"> * we will service the queues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_service_tree_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span>
				 <span class="n">bool</span> <span class="n">add_front</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">__cfqq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rb_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">service_tree</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">left</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_cfqq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">service_tree</span> <span class="o">=</span> <span class="n">service_tree_for</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">,</span> <span class="n">cfqq_prio</span><span class="p">(</span><span class="n">cfqq</span><span class="p">),</span>
						<span class="n">cfqq_type</span><span class="p">(</span><span class="n">cfqq</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_class_idle</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rb_key</span> <span class="o">=</span> <span class="n">CFQ_IDLE_DELAY</span><span class="p">;</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">rb_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">service_tree</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__cfqq</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
			<span class="n">rb_key</span> <span class="o">+=</span> <span class="n">__cfqq</span><span class="o">-&gt;</span><span class="n">rb_key</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">rb_key</span> <span class="o">+=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">add_front</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Get our rb key offset. Subtract any residual slice</span>
<span class="cm">		 * value carried from last service. A negative resid</span>
<span class="cm">		 * count indicates slice overrun, and this should position</span>
<span class="cm">		 * the next service time further away in the tree.</span>
<span class="cm">		 */</span>
		<span class="n">rb_key</span> <span class="o">=</span> <span class="n">cfq_slice_offset</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">)</span> <span class="o">+</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">rb_key</span> <span class="o">-=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_resid</span><span class="p">;</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_resid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rb_key</span> <span class="o">=</span> <span class="o">-</span><span class="n">HZ</span><span class="p">;</span>
		<span class="n">__cfqq</span> <span class="o">=</span> <span class="n">cfq_rb_first</span><span class="p">(</span><span class="n">service_tree</span><span class="p">);</span>
		<span class="n">rb_key</span> <span class="o">+=</span> <span class="n">__cfqq</span> <span class="o">?</span> <span class="n">__cfqq</span><span class="o">-&gt;</span><span class="n">rb_key</span> <span class="o">:</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RB_EMPTY_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">new_cfqq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * same position, nothing more to do</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rb_key</span> <span class="o">==</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">rb_key</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">service_tree</span> <span class="o">==</span> <span class="n">service_tree</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">cfq_rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">service_tree</span><span class="p">);</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">service_tree</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">service_tree</span> <span class="o">=</span> <span class="n">service_tree</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">service_tree</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">n</span><span class="p">;</span>

		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">__cfqq</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * sort by key, that represents service time.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">rb_key</span><span class="p">,</span> <span class="n">__cfqq</span><span class="o">-&gt;</span><span class="n">rb_key</span><span class="p">))</span>
			<span class="n">n</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">n</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
			<span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">p</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span>
		<span class="n">service_tree</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>

	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">rb_key</span> <span class="o">=</span> <span class="n">rb_key</span><span class="p">;</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">service_tree</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
	<span class="n">service_tree</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">add_front</span> <span class="o">||</span> <span class="o">!</span><span class="n">new_cfqq</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">cfq_group_notify_queue_add</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span>
<span class="nf">cfq_prio_tree_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		     <span class="n">sector_t</span> <span class="n">sector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">ret_parent</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">***</span><span class="n">rb_link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">n</span><span class="p">;</span>

		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">cfqq</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span><span class="p">,</span> <span class="n">p_node</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Sort strictly based on sector.  Smallest to the left,</span>
<span class="cm">		 * largest to the right.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sector</span> <span class="o">&gt;</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">))</span>
			<span class="n">n</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sector</span> <span class="o">&lt;</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">))</span>
			<span class="n">n</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">cfqq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">ret_parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rb_link</span><span class="p">)</span>
		<span class="o">*</span><span class="n">rb_link</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cfqq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_prio_tree_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">__cfqq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_node</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_root</span><span class="p">);</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_class_idle</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">prio_trees</span><span class="p">[</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">org_ioprio</span><span class="p">];</span>
	<span class="n">__cfqq</span> <span class="o">=</span> <span class="n">cfq_prio_tree_lookup</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_root</span><span class="p">,</span>
				      <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__cfqq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_node</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_root</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update cfqq&#39;s position in the service tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_resort_rr_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Resorting requires the cfqq to be on the RR list already.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_on_rr</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cfq_service_tree_add</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cfq_prio_tree_add</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * add to busy list of queues for service, trying to be fair in ordering</span>
<span class="cm"> * the pending list according to last request service</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_add_cfqq_rr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;add_to_rr&quot;</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cfq_cfqq_on_rr</span><span class="p">(</span><span class="n">cfqq</span><span class="p">));</span>
	<span class="n">cfq_mark_cfqq_on_rr</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">busy_queues</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">busy_sync_queues</span><span class="o">++</span><span class="p">;</span>

	<span class="n">cfq_resort_rr_list</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when the cfqq no longer has requests pending, remove it from</span>
<span class="cm"> * the service tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_del_cfqq_rr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;del_from_rr&quot;</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cfq_cfqq_on_rr</span><span class="p">(</span><span class="n">cfqq</span><span class="p">));</span>
	<span class="n">cfq_clear_cfqq_on_rr</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RB_EMPTY_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cfq_rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">service_tree</span><span class="p">);</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">service_tree</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_node</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_root</span><span class="p">);</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cfq_group_notify_queue_del</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">busy_queues</span><span class="p">);</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">busy_queues</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">busy_sync_queues</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * rb tree support functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_del_rq_rb</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span> <span class="o">=</span> <span class="n">RQ_CFQQ</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">sync</span> <span class="o">=</span> <span class="n">rq_is_sync</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">[</span><span class="n">sync</span><span class="p">]);</span>
	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">[</span><span class="n">sync</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>

	<span class="n">elv_rb_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_on_rr</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Queue will be deleted from service tree when we actually</span>
<span class="cm">		 * expire it later. Right now just remove it from prio tree</span>
<span class="cm">		 * as it is empty.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_root</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_node</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_root</span><span class="p">);</span>
			<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_add_rq_rb</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span> <span class="o">=</span> <span class="n">RQ_CFQQ</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>

	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">[</span><span class="n">rq_is_sync</span><span class="p">(</span><span class="n">rq</span><span class="p">)]</span><span class="o">++</span><span class="p">;</span>

	<span class="n">elv_rb_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_cfqq_on_rr</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="n">cfq_add_cfqq_rr</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * check if this request is a better next-serve candidate</span>
<span class="cm">	 */</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">;</span>
	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span> <span class="o">=</span> <span class="n">cfq_choose_req</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">last_position</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * adjust priority tree position, if -&gt;next_rq changes</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">)</span>
		<span class="n">cfq_prio_tree_add</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_reposition_rq_rb</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">elv_rb_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">[</span><span class="n">rq_is_sync</span><span class="p">(</span><span class="n">rq</span><span class="p">)]</span><span class="o">--</span><span class="p">;</span>
	<span class="n">cfqg_stats_update_io_remove</span><span class="p">(</span><span class="n">RQ_CFQG</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span><span class="p">);</span>
	<span class="n">cfq_add_rq_rb</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">cfqg_stats_update_io_add</span><span class="p">(</span><span class="n">RQ_CFQG</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_group</span><span class="p">,</span>
				 <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span>
<span class="nf">cfq_find_rq_fmerge</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">;</span>

	<span class="n">cic</span> <span class="o">=</span> <span class="n">cfq_cic_lookup</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">io_context</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cic</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cic_to_cfqq</span><span class="p">(</span><span class="n">cic</span><span class="p">,</span> <span class="n">cfq_bio_sync</span><span class="p">(</span><span class="n">bio</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sector_t</span> <span class="n">sector</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">+</span> <span class="n">bio_sectors</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">elv_rb_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">,</span> <span class="n">sector</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_activate_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">elevator_data</span><span class="p">;</span>

	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_in_driver</span><span class="o">++</span><span class="p">;</span>
	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">RQ_CFQQ</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="s">&quot;activate rq, drv=%d&quot;</span><span class="p">,</span>
						<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_in_driver</span><span class="p">);</span>

	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">last_position</span> <span class="o">=</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">+</span> <span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_deactivate_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">elevator_data</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_in_driver</span><span class="p">);</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_in_driver</span><span class="o">--</span><span class="p">;</span>
	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">RQ_CFQQ</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="s">&quot;deactivate rq, drv=%d&quot;</span><span class="p">,</span>
						<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_in_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_remove_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span> <span class="o">=</span> <span class="n">RQ_CFQQ</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span> <span class="o">==</span> <span class="n">rq</span><span class="p">)</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span> <span class="o">=</span> <span class="n">cfq_find_next_rq</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">queuelist</span><span class="p">);</span>
	<span class="n">cfq_del_rq_rb</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_queued</span><span class="o">--</span><span class="p">;</span>
	<span class="n">cfqg_stats_update_io_remove</span><span class="p">(</span><span class="n">RQ_CFQG</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_PRIO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">prio_pending</span><span class="p">);</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">prio_pending</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfq_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">**</span><span class="n">req</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">elevator_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">__rq</span><span class="p">;</span>

	<span class="n">__rq</span> <span class="o">=</span> <span class="n">cfq_find_rq_fmerge</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__rq</span> <span class="o">&amp;&amp;</span> <span class="n">elv_rq_merge_ok</span><span class="p">(</span><span class="n">__rq</span><span class="p">,</span> <span class="n">bio</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">__rq</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ELEVATOR_FRONT_MERGE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ELEVATOR_NO_MERGE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_merged_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">ELEVATOR_FRONT_MERGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span> <span class="o">=</span> <span class="n">RQ_CFQQ</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

		<span class="n">cfq_reposition_rq_rb</span><span class="p">(</span><span class="n">cfqq</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_bio_merged</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cfqg_stats_update_io_merged</span><span class="p">(</span><span class="n">RQ_CFQG</span><span class="p">(</span><span class="n">req</span><span class="p">),</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cfq_merged_requests</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span> <span class="o">=</span> <span class="n">RQ_CFQQ</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">elevator_data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * reposition in fifo if next is older than rq</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">queuelist</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">queuelist</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">time_before</span><span class="p">(</span><span class="n">rq_fifo_time</span><span class="p">(</span><span class="n">next</span><span class="p">),</span> <span class="n">rq_fifo_time</span><span class="p">(</span><span class="n">rq</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">queuelist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">queuelist</span><span class="p">);</span>
		<span class="n">rq_set_fifo_time</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rq_fifo_time</span><span class="p">(</span><span class="n">next</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span> <span class="o">==</span> <span class="n">next</span><span class="p">)</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span> <span class="o">=</span> <span class="n">rq</span><span class="p">;</span>
	<span class="n">cfq_remove_request</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
	<span class="n">cfqg_stats_update_io_merged</span><span class="p">(</span><span class="n">RQ_CFQG</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">cmd_flags</span><span class="p">);</span>

	<span class="n">cfqq</span> <span class="o">=</span> <span class="n">RQ_CFQQ</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * all requests of this queue are merged to other queues, delete it</span>
<span class="cm">	 * from the service tree. If it&#39;s the active_queue,</span>
<span class="cm">	 * cfq_dispatch_requests() will choose to expire it or do idle</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_on_rr</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cfqq</span> <span class="o">!=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span><span class="p">)</span>
		<span class="n">cfq_del_cfqq_rr</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfq_allow_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">elevator_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disallow merge of a sync bio into an async request.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_bio_sync</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rq_is_sync</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Lookup the cfqq that this bio will be queued with and allow</span>
<span class="cm">	 * merge only if rq is queued there.</span>
<span class="cm">	 */</span>
	<span class="n">cic</span> <span class="o">=</span> <span class="n">cfq_cic_lookup</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">io_context</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cic</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cic_to_cfqq</span><span class="p">(</span><span class="n">cic</span><span class="p">,</span> <span class="n">cfq_bio_sync</span><span class="p">(</span><span class="n">bio</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">cfqq</span> <span class="o">==</span> <span class="n">RQ_CFQQ</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfq_del_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">idle_slice_timer</span><span class="p">);</span>
	<span class="n">cfqg_stats_update_idle_time</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__cfq_set_active_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;set_active wl_prio:%d wl_type:%d&quot;</span><span class="p">,</span>
				<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_prio</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_type</span><span class="p">);</span>
		<span class="n">cfqg_stats_update_avg_queue_size</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">);</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">dispatch_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">allocated_slice</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_dispatch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">nr_sectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">cfq_clear_cfqq_wait_request</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
		<span class="n">cfq_clear_cfqq_must_dispatch</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
		<span class="n">cfq_clear_cfqq_must_alloc_slice</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
		<span class="n">cfq_clear_cfqq_fifo_expire</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
		<span class="n">cfq_mark_cfqq_slice_new</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>

		<span class="n">cfq_del_timer</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span> <span class="o">=</span> <span class="n">cfqq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * current cfqq expired its slice (or was too idle), select new one</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__cfq_slice_expired</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span>
		    <span class="n">bool</span> <span class="n">timed_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;slice expired t=%d&quot;</span><span class="p">,</span> <span class="n">timed_out</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_wait_request</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="n">cfq_del_timer</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>

	<span class="n">cfq_clear_cfqq_wait_request</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
	<span class="n">cfq_clear_cfqq_wait_busy</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this cfqq is shared between multiple processes, check to</span>
<span class="cm">	 * make sure that those processes are still issuing I/Os within</span>
<span class="cm">	 * the mean seek distance.  If not, it may be time to break the</span>
<span class="cm">	 * queues apart again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_coop</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">CFQQ_SEEKY</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="n">cfq_mark_cfqq_split_coop</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * store what was left of this slice, if the queue idled/timed out</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timed_out</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_slice_new</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
			<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_resid</span> <span class="o">=</span> <span class="n">cfq_scaled_cfqq_slice</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_resid</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_end</span> <span class="o">-</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;resid=%ld&quot;</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_resid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cfq_group_served</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_on_rr</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">))</span>
		<span class="n">cfq_del_cfqq_rr</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>

	<span class="n">cfq_resort_rr_list</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span> <span class="o">==</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span><span class="p">)</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_cic</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_io_context</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_cic</span><span class="o">-&gt;</span><span class="n">icq</span><span class="p">.</span><span class="n">ioc</span><span class="p">);</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_cic</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfq_slice_expired</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">bool</span> <span class="n">timed_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="p">)</span>
		<span class="n">__cfq_slice_expired</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="n">timed_out</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get next queue for service. Unless we have a queue preemption,</span>
<span class="cm"> * we&#39;ll simply select the first cfqq in the service tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="nf">cfq_get_next_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">service_tree</span> <span class="o">=</span>
		<span class="n">service_tree_for</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_group</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_prio</span><span class="p">,</span>
					<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_queued</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* There is nothing to dispatch */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">service_tree</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">service_tree</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cfq_rb_first</span><span class="p">(</span><span class="n">service_tree</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="nf">cfq_get_next_queue_forced</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_queued</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cfqg</span> <span class="o">=</span> <span class="n">cfq_get_next_cfqg</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqg</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">for_each_cfqg_st</span><span class="p">(</span><span class="n">cfqg</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">st</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cfqq</span> <span class="o">=</span> <span class="n">cfq_rb_first</span><span class="p">(</span><span class="n">st</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cfqq</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get and set a new active queue for service.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="nf">cfq_set_active_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqq</span><span class="p">)</span>
		<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cfq_get_next_queue</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>

	<span class="n">__cfq_set_active_queue</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cfqq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">sector_t</span> <span class="nf">cfq_dist_from_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">last_position</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">-</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">last_position</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">last_position</span> <span class="o">-</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cfq_rq_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cfq_dist_from_last</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">rq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">CFQQ_CLOSE_THR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="nf">cfqq_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cur_cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">prio_trees</span><span class="p">[</span><span class="n">cur_cfqq</span><span class="o">-&gt;</span><span class="n">org_ioprio</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">__cfqq</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">sector</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">last_position</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First, if we find a request starting at the end of the last</span>
<span class="cm">	 * request, choose it.</span>
<span class="cm">	 */</span>
	<span class="n">__cfqq</span> <span class="o">=</span> <span class="n">cfq_prio_tree_lookup</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">sector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__cfqq</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">__cfqq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the exact sector wasn&#39;t found, the parent of the NULL leaf</span>
<span class="cm">	 * will contain the closest sector.</span>
<span class="cm">	 */</span>
	<span class="n">__cfqq</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span><span class="p">,</span> <span class="n">p_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_rq_close</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cur_cfqq</span><span class="p">,</span> <span class="n">__cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">__cfqq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">__cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sector</span><span class="p">)</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__cfqq</span><span class="o">-&gt;</span><span class="n">p_node</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">rb_prev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__cfqq</span><span class="o">-&gt;</span><span class="n">p_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">__cfqq</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span><span class="p">,</span> <span class="n">p_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_rq_close</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cur_cfqq</span><span class="p">,</span> <span class="n">__cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">__cfqq</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cfqd - obvious</span>
<span class="cm"> * cur_cfqq - passed in so that we don&#39;t decide that the current queue is</span>
<span class="cm"> * 	      closely cooperating with itself.</span>
<span class="cm"> *</span>
<span class="cm"> * So, basically we&#39;re assuming that that cur_cfqq has dispatched at least</span>
<span class="cm"> * one request, and that cfqd-&gt;last_position reflects a position on the disk</span>
<span class="cm"> * associated with the I/O issued by cur_cfqq.  I&#39;m not sure this is a valid</span>
<span class="cm"> * assumption.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="nf">cfq_close_cooperator</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cur_cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_class_idle</span><span class="p">(</span><span class="n">cur_cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cur_cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CFQQ_SEEKY</span><span class="p">(</span><span class="n">cur_cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t search priority tree if it&#39;s the only queue in the group.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur_cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">nr_cfqq</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We should notice if some of the queues are cooperating, eg</span>
<span class="cm">	 * working closely on the same area of the disk. In that case,</span>
<span class="cm">	 * we can group them together and don&#39;t waste time idling.</span>
<span class="cm">	 */</span>
	<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cfqq_close</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cur_cfqq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqq</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* If new queue belongs to different cfq_group, don&#39;t choose it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur_cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span> <span class="o">!=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It only makes sense to merge sync queues.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CFQQ_SEEKY</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do not merge queues of different priority classes</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_class_rt</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">cfq_class_rt</span><span class="p">(</span><span class="n">cur_cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cfqq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine whether we should enforce idle window for this queue.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">cfq_should_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">wl_prio_t</span> <span class="n">prio</span> <span class="o">=</span> <span class="n">cfqq_prio</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">service_tree</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">service_tree</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">service_tree</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">service_tree</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_idle</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* We never do for idle class queues. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prio</span> <span class="o">==</span> <span class="n">IDLE_WORKLOAD</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* We do for queues that were marked with idle window flag. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_idle_window</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="o">!</span><span class="p">(</span><span class="n">blk_queue_nonrot</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">hw_tag</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Otherwise, we do only if they are the last ones</span>
<span class="cm">	 * in their service tree.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">service_tree</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="o">!</span><span class="n">cfq_io_thinktime_big</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">service_tree</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;Not idling. st-&gt;count:%d&quot;</span><span class="p">,</span>
			<span class="n">service_tree</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_arm_slice_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sl</span><span class="p">,</span> <span class="n">group_idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * SSD device without seek penalty, disable idling. But only do so</span>
<span class="cm">	 * for devices that support queuing, otherwise we still have a problem</span>
<span class="cm">	 * with sync vs async workloads.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_queue_nonrot</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">hw_tag</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cfq_cfqq_slice_new</span><span class="p">(</span><span class="n">cfqq</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * idle is disabled, either manually or by past process history</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_should_idle</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* no queue idling. Check for group idling */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_group_idle</span><span class="p">)</span>
			<span class="n">group_idle</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_group_idle</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * still active requests from this queue, don&#39;t idle</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">dispatched</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * task has exited, don&#39;t wait</span>
<span class="cm">	 */</span>
	<span class="n">cic</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_cic</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cic</span> <span class="o">||</span> <span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">icq</span><span class="p">.</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">active_ref</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If our average think time is larger than the remaining time</span>
<span class="cm">	 * slice, then don&#39;t idle. This avoids overrunning the allotted</span>
<span class="cm">	 * time slice.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sample_valid</span><span class="p">(</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">.</span><span class="n">ttime_samples</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_end</span> <span class="o">-</span> <span class="n">jiffies</span> <span class="o">&lt;</span> <span class="n">cic</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">.</span><span class="n">ttime_mean</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;Not idling. think_time:%lu&quot;</span><span class="p">,</span>
			     <span class="n">cic</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">.</span><span class="n">ttime_mean</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* There are other queues in the group, don&#39;t do group idle */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group_idle</span> <span class="o">&amp;&amp;</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">nr_cfqq</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cfq_mark_cfqq_wait_request</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">group_idle</span><span class="p">)</span>
		<span class="n">sl</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_group_idle</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sl</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_idle</span><span class="p">;</span>

	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">idle_slice_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">sl</span><span class="p">);</span>
	<span class="n">cfqg_stats_set_start_idle_time</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">);</span>
	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;arm_idle: %lu group_idle: %d&quot;</span><span class="p">,</span> <span class="n">sl</span><span class="p">,</span>
			<span class="n">group_idle</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Move request from internal lists to the request queue dispatch list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_dispatch_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">elevator_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span> <span class="o">=</span> <span class="n">RQ_CFQQ</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;dispatch_insert&quot;</span><span class="p">);</span>

	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span> <span class="o">=</span> <span class="n">cfq_find_next_rq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="n">cfq_remove_request</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">dispatched</span><span class="o">++</span><span class="p">;</span>
	<span class="p">(</span><span class="n">RQ_CFQG</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">dispatched</span><span class="o">++</span><span class="p">;</span>
	<span class="n">elv_dispatch_sort</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_in_flight</span><span class="p">[</span><span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">nr_sectors</span> <span class="o">+=</span> <span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">cfqg_stats_update_dispatch</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">,</span> <span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * return expired entry, or NULL to just start from scratch in rbtree</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">cfq_check_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_fifo_expire</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cfq_mark_cfqq_fifo_expire</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">fifo</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">rq_entry_fifo</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">fifo</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">rq_fifo_time</span><span class="p">(</span><span class="n">rq</span><span class="p">)))</span>
		<span class="n">rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;fifo=%p&quot;</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">cfq_prio_to_maxrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">base_rq</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_async_rq</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ioprio</span> <span class="o">&gt;=</span> <span class="n">IOPRIO_BE_NR</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">base_rq</span> <span class="o">*</span> <span class="p">(</span><span class="n">IOPRIO_BE_NR</span> <span class="o">-</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ioprio</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Must be called with the queue_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfqq_process_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">process_refs</span><span class="p">,</span> <span class="n">io_refs</span><span class="p">;</span>

	<span class="n">io_refs</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">[</span><span class="n">READ</span><span class="p">]</span> <span class="o">+</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">[</span><span class="n">WRITE</span><span class="p">];</span>
	<span class="n">process_refs</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">-</span> <span class="n">io_refs</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">process_refs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">process_refs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_setup_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">new_cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">process_refs</span><span class="p">,</span> <span class="n">new_process_refs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">__cfqq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are no process references on the new_cfqq, then it is</span>
<span class="cm">	 * unsafe to follow the -&gt;new_cfqq chain as other cfqq&#39;s in the</span>
<span class="cm">	 * chain may have dropped their last reference (not just their</span>
<span class="cm">	 * last process reference).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqq_process_refs</span><span class="p">(</span><span class="n">new_cfqq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Avoid a circular list and skip interim queue merges */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">__cfqq</span> <span class="o">=</span> <span class="n">new_cfqq</span><span class="o">-&gt;</span><span class="n">new_cfqq</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__cfqq</span> <span class="o">==</span> <span class="n">cfqq</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">new_cfqq</span> <span class="o">=</span> <span class="n">__cfqq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">process_refs</span> <span class="o">=</span> <span class="n">cfqq_process_refs</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
	<span class="n">new_process_refs</span> <span class="o">=</span> <span class="n">cfqq_process_refs</span><span class="p">(</span><span class="n">new_cfqq</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the process for the cfqq has gone away, there is no</span>
<span class="cm">	 * sense in merging the queues.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">process_refs</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">new_process_refs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Merge in the direction of the lesser amount of work.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_process_refs</span> <span class="o">&gt;=</span> <span class="n">process_refs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">new_cfqq</span> <span class="o">=</span> <span class="n">new_cfqq</span><span class="p">;</span>
		<span class="n">new_cfqq</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">+=</span> <span class="n">process_refs</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">new_cfqq</span><span class="o">-&gt;</span><span class="n">new_cfqq</span> <span class="o">=</span> <span class="n">cfqq</span><span class="p">;</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">+=</span> <span class="n">new_process_refs</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">wl_type_t</span> <span class="nf">cfq_choose_wl</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">,</span> <span class="k">enum</span> <span class="n">wl_prio_t</span> <span class="n">prio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">key_valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lowest_key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">wl_type_t</span> <span class="n">cur_best</span> <span class="o">=</span> <span class="n">SYNC_NOIDLE_WORKLOAD</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">SYNC_WORKLOAD</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* select the one with lowest rb_key */</span>
		<span class="n">queue</span> <span class="o">=</span> <span class="n">cfq_rb_first</span><span class="p">(</span><span class="n">service_tree_for</span><span class="p">(</span><span class="n">cfqg</span><span class="p">,</span> <span class="n">prio</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">queue</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">key_valid</span> <span class="o">||</span> <span class="n">time_before</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">rb_key</span><span class="p">,</span> <span class="n">lowest_key</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">lowest_key</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">rb_key</span><span class="p">;</span>
			<span class="n">cur_best</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">key_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cur_best</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">choose_service_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">slice</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">group_slice</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">wl_prio_t</span> <span class="n">original_prio</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_prio</span><span class="p">;</span>

	<span class="cm">/* Choose next priority. RT &gt; BE &gt; IDLE */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_group_busy_queues_wl</span><span class="p">(</span><span class="n">RT_WORKLOAD</span><span class="p">,</span> <span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">))</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_prio</span> <span class="o">=</span> <span class="n">RT_WORKLOAD</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cfq_group_busy_queues_wl</span><span class="p">(</span><span class="n">BE_WORKLOAD</span><span class="p">,</span> <span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">))</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_prio</span> <span class="o">=</span> <span class="n">BE_WORKLOAD</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_prio</span> <span class="o">=</span> <span class="n">IDLE_WORKLOAD</span><span class="p">;</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">workload_expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">original_prio</span> <span class="o">!=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_prio</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">new_workload</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For RT and BE, we have to choose also the type</span>
<span class="cm">	 * (SYNC, SYNC_NOIDLE, ASYNC), and to compute a workload</span>
<span class="cm">	 * expiration time</span>
<span class="cm">	 */</span>
	<span class="n">st</span> <span class="o">=</span> <span class="n">service_tree_for</span><span class="p">(</span><span class="n">cfqg</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_prio</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_type</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * check workload expiration, and that we still have other queues ready</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">workload_expires</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

<span class="nl">new_workload:</span>
	<span class="cm">/* otherwise select new workload type */</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_type</span> <span class="o">=</span>
		<span class="n">cfq_choose_wl</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_prio</span><span class="p">);</span>
	<span class="n">st</span> <span class="o">=</span> <span class="n">service_tree_for</span><span class="p">(</span><span class="n">cfqg</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_prio</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_type</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * the workload slice is computed as a fraction of target latency</span>
<span class="cm">	 * proportional to the number of queues in that workload, over</span>
<span class="cm">	 * all the queues in the same priority class</span>
<span class="cm">	 */</span>
	<span class="n">group_slice</span> <span class="o">=</span> <span class="n">cfq_group_slice</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">);</span>

	<span class="n">slice</span> <span class="o">=</span> <span class="n">group_slice</span> <span class="o">*</span> <span class="n">count</span> <span class="o">/</span>
		<span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">busy_queues_avg</span><span class="p">[</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_prio</span><span class="p">],</span>
		      <span class="n">cfq_group_busy_queues_wl</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_prio</span><span class="p">,</span> <span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_type</span> <span class="o">==</span> <span class="n">ASYNC_WORKLOAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Async queues are currently system wide. Just taking</span>
<span class="cm">		 * proportion of queues with-in same group will lead to higher</span>
<span class="cm">		 * async ratio system wide as generally root group is going</span>
<span class="cm">		 * to have higher weight. A more accurate thing would be to</span>
<span class="cm">		 * calculate system wide asnc/sync ratio.</span>
<span class="cm">		 */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_target_latency</span> <span class="o">*</span>
			<span class="n">cfqg_busy_async_queues</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">/</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">busy_queues</span><span class="p">;</span>
		<span class="n">slice</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">slice</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

		<span class="cm">/* async workload slice is scaled down according to</span>
<span class="cm">		 * the sync/async slice ratio. */</span>
		<span class="n">slice</span> <span class="o">=</span> <span class="n">slice</span> <span class="o">*</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* sync workload slice is at least 2 * cfq_slice_idle */</span>
		<span class="n">slice</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">slice</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_idle</span><span class="p">);</span>

	<span class="n">slice</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">slice</span><span class="p">,</span> <span class="n">CFQ_MIN_TT</span><span class="p">);</span>
	<span class="n">cfq_log</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="s">&quot;workload slice:%d&quot;</span><span class="p">,</span> <span class="n">slice</span><span class="p">);</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">workload_expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">slice</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="nf">cfq_get_next_cfqg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">grp_service_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cfqg</span> <span class="o">=</span> <span class="n">cfq_rb_first_group</span><span class="p">(</span><span class="n">st</span><span class="p">);</span>
	<span class="n">update_min_vdisktime</span><span class="p">(</span><span class="n">st</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cfqg</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_choose_cfqg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span> <span class="o">=</span> <span class="n">cfq_get_next_cfqg</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>

	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_group</span> <span class="o">=</span> <span class="n">cfqg</span><span class="p">;</span>

	<span class="cm">/* Restore the workload type data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">saved_workload_slice</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">workload_expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">saved_workload_slice</span><span class="p">;</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_type</span> <span class="o">=</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">saved_workload</span><span class="p">;</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_prio</span> <span class="o">=</span> <span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">saved_serving_prio</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">workload_expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">choose_service_tree</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Select a queue for service. If we have a current active queue,</span>
<span class="cm"> * check whether to continue servicing it, or retrieve and set a new one.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="nf">cfq_select_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span> <span class="o">*</span><span class="n">new_cfqq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqq</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">new_queue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_queued</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We were waiting for group to get backlogged. Expire the queue</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_wait_busy</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">expire</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The active queue has run out of time, expire it and select new.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_slice_used</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cfq_cfqq_must_dispatch</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If slice had not expired at the completion of last request</span>
<span class="cm">		 * we might not have turned on wait_busy flag. Don&#39;t expire</span>
<span class="cm">		 * the queue yet. Allow the group to get backlogged.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The very fact that we have used the slice, that means we</span>
<span class="cm">		 * have been idling all along on this queue and it should be</span>
<span class="cm">		 * ok to wait for this request to complete.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">nr_cfqq</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">dispatched</span> <span class="o">&amp;&amp;</span> <span class="n">cfq_should_idle</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cfqq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">keep_queue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">goto</span> <span class="n">check_group_idle</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The active queue has requests and isn&#39;t expired, allow it to</span>
<span class="cm">	 * dispatch.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">keep_queue</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If another queue has a request waiting within our mean seek</span>
<span class="cm">	 * distance, let it run.  The expire code will check for close</span>
<span class="cm">	 * cooperators and put the close queue at the front of the service</span>
<span class="cm">	 * tree.  If possible, merge the expiring queue with the new cfqq.</span>
<span class="cm">	 */</span>
	<span class="n">new_cfqq</span> <span class="o">=</span> <span class="n">cfq_close_cooperator</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_cfqq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">new_cfqq</span><span class="p">)</span>
			<span class="n">cfq_setup_merge</span><span class="p">(</span><span class="n">cfqq</span><span class="p">,</span> <span class="n">new_cfqq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">expire</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * No requests pending. If the active queue still has requests in</span>
<span class="cm">	 * flight or is idling for a new request, allow either of these</span>
<span class="cm">	 * conditions to happen (or time out) before selecting a new queue.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">idle_slice_timer</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cfqq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">keep_queue</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a deep seek queue, but the device is much faster than</span>
<span class="cm">	 * the queue can deliver, don&#39;t idle</span>
<span class="cm">	 **/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CFQQ_SEEKY</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cfq_cfqq_idle_window</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">cfq_cfqq_slice_new</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_end</span> <span class="o">-</span> <span class="n">jiffies</span> <span class="o">&gt;</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_start</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">cfq_clear_cfqq_deep</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
		<span class="n">cfq_clear_cfqq_idle_window</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">dispatched</span> <span class="o">&amp;&amp;</span> <span class="n">cfq_should_idle</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cfqq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">keep_queue</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If group idle is enabled and there are requests dispatched from</span>
<span class="cm">	 * this group, wait for requests to complete.</span>
<span class="cm">	 */</span>
<span class="nl">check_group_idle:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_group_idle</span> <span class="o">&amp;&amp;</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">nr_cfqq</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">dispatched</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">cfq_io_thinktime_big</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cfqq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">keep_queue</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">expire:</span>
	<span class="n">cfq_slice_expired</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">new_queue:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Current queue expired. Check if we have to switch to a new</span>
<span class="cm">	 * service tree</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_cfqq</span><span class="p">)</span>
		<span class="n">cfq_choose_cfqg</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>

	<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cfq_set_active_queue</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">new_cfqq</span><span class="p">);</span>
<span class="nl">keep_queue:</span>
	<span class="k">return</span> <span class="n">cfqq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__cfq_forced_dispatch_cfqq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dispatched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfq_dispatch_insert</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">);</span>
		<span class="n">dispatched</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">fifo</span><span class="p">));</span>

	<span class="cm">/* By default cfqq is not expired if it is empty. Do it explicitly */</span>
	<span class="n">__cfq_slice_expired</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dispatched</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Drain our current requests. Used for barriers and when switching</span>
<span class="cm"> * io schedulers on-the-fly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfq_forced_dispatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dispatched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Expire the timeslice of the current active queue first */</span>
	<span class="n">cfq_slice_expired</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">cfqq</span> <span class="o">=</span> <span class="n">cfq_get_next_queue_forced</span><span class="p">(</span><span class="n">cfqd</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__cfq_set_active_queue</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>
		<span class="n">dispatched</span> <span class="o">+=</span> <span class="n">__cfq_forced_dispatch_cfqq</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">busy_queues</span><span class="p">);</span>

	<span class="n">cfq_log</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="s">&quot;forced_dispatch=%d&quot;</span><span class="p">,</span> <span class="n">dispatched</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dispatched</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cfq_slice_used_soon</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* the queue hasn&#39;t finished any request, can&#39;t estimate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_slice_new</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_idle</span> <span class="o">*</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">dispatched</span><span class="p">,</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_end</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">cfq_may_dispatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_dispatch</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Drain async requests before we start sync IO</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_should_idle</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_in_flight</span><span class="p">[</span><span class="n">BLK_RW_ASYNC</span><span class="p">])</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is an async queue and we have sync IO in flight, let it wait</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_in_flight</span><span class="p">[</span><span class="n">BLK_RW_SYNC</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">max_dispatch</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_quantum</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_class_idle</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="n">max_dispatch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Does this cfqq already have too much IO in flight?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">dispatched</span> <span class="o">&gt;=</span> <span class="n">max_dispatch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">promote_sync</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * idle queue must always only have a single IO in flight</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfq_class_idle</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If there is only one sync queue</span>
<span class="cm">		 * we can ignore async queue here and give the sync</span>
<span class="cm">		 * queue no dispatch limit. The reason is a sync queue can</span>
<span class="cm">		 * preempt async queue, limiting the sync queue doesn&#39;t make</span>
<span class="cm">		 * sense. This is useful for aiostress test.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">busy_sync_queues</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">promote_sync</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We have other queues, don&#39;t allow more IO from this one</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">busy_queues</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">cfq_slice_used_soon</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="n">promote_sync</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Sole queue user, no limit</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">busy_queues</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">promote_sync</span><span class="p">)</span>
			<span class="n">max_dispatch</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/*</span>
<span class="cm">			 * Normally we start throttling cfqq when cfq_quantum/2</span>
<span class="cm">			 * requests have been dispatched. But we can drive</span>
<span class="cm">			 * deeper queue depths at the beginning of slice</span>
<span class="cm">			 * subjected to upper limit of cfq_quantum.</span>
<span class="cm">			 * */</span>
			<span class="n">max_dispatch</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_quantum</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Async queues must wait a bit before being allowed dispatch.</span>
<span class="cm">	 * We also ramp up the dispatch depth gradually for async IO,</span>
<span class="cm">	 * based on the last sync IO we serviced</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_latency</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_sync</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">last_delayed_sync</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>

		<span class="n">depth</span> <span class="o">=</span> <span class="n">last_sync</span> <span class="o">/</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">depth</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">dispatched</span><span class="p">)</span>
			<span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="n">max_dispatch</span><span class="p">)</span>
			<span class="n">max_dispatch</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re below the current max, allow a dispatch</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">dispatched</span> <span class="o">&lt;</span> <span class="n">max_dispatch</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Dispatch a request from cfqq, moving them to the request queue</span>
<span class="cm"> * dispatch list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">cfq_dispatch_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_may_dispatch</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * follow expired path, else get first next available</span>
<span class="cm">	 */</span>
	<span class="n">rq</span> <span class="o">=</span> <span class="n">cfq_check_fifo</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="p">)</span>
		<span class="n">rq</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * insert request into driver dispatch list</span>
<span class="cm">	 */</span>
	<span class="n">cfq_dispatch_insert</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_cic</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span> <span class="o">=</span> <span class="n">RQ_CIC</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

		<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">icq</span><span class="p">.</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_cic</span> <span class="o">=</span> <span class="n">cic</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the cfqq that we need to service and move a request from that to the</span>
<span class="cm"> * dispatch list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfq_dispatch_requests</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">elevator_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">busy_queues</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">force</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">cfq_forced_dispatch</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>

	<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cfq_select_queue</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqq</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Dispatch a request from this cfqq, if it is allowed</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_dispatch_request</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_dispatch</span><span class="o">++</span><span class="p">;</span>
	<span class="n">cfq_clear_cfqq_must_dispatch</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * expire an async queue immediately if it has used up its slice. idle</span>
<span class="cm">	 * queue always expire after 1 dispatch round.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">busy_queues</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="o">!</span><span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_dispatch</span> <span class="o">&gt;=</span> <span class="n">cfq_prio_to_maxrq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">))</span> <span class="o">||</span>
	    <span class="n">cfq_class_idle</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_end</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cfq_slice_expired</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;dispatched a request&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * task holds one reference to the queue, dropped when task exits. each rq</span>
<span class="cm"> * in-flight on this queue also holds a reference, dropped when rq is freed.</span>
<span class="cm"> *</span>
<span class="cm"> * Each cfq queue took a reference on the parent group. Drop it now.</span>
<span class="cm"> * queue lock must be held here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_put_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ref</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;put_queue&quot;</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">[</span><span class="n">READ</span><span class="p">]</span> <span class="o">+</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">[</span><span class="n">WRITE</span><span class="p">]);</span>
	<span class="n">cfqg</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span> <span class="o">==</span> <span class="n">cfqq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__cfq_slice_expired</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cfq_schedule_dispatch</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cfq_cfqq_on_rr</span><span class="p">(</span><span class="n">cfqq</span><span class="p">));</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">cfq_pool</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>
	<span class="n">cfqg_put</span><span class="p">(</span><span class="n">cfqg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_put_cooperator</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">__cfqq</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this queue was scheduled to merge with another queue, be</span>
<span class="cm">	 * sure to drop the reference taken on that queue (and others in</span>
<span class="cm">	 * the merge chain).  See cfq_setup_merge and cfq_merge_cfqqs.</span>
<span class="cm">	 */</span>
	<span class="n">__cfqq</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">new_cfqq</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">__cfqq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__cfqq</span> <span class="o">==</span> <span class="n">cfqq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;cfqq-&gt;new_cfqq loop detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">__cfqq</span><span class="o">-&gt;</span><span class="n">new_cfqq</span><span class="p">;</span>
		<span class="n">cfq_put_queue</span><span class="p">(</span><span class="n">__cfqq</span><span class="p">);</span>
		<span class="n">__cfqq</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_exit_cfqq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cfqq</span> <span class="o">==</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__cfq_slice_expired</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cfq_schedule_dispatch</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cfq_put_cooperator</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>

	<span class="n">cfq_put_queue</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_init_icq</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_cq</span> <span class="o">*</span><span class="n">icq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span> <span class="o">=</span> <span class="n">icq_to_cic</span><span class="p">(</span><span class="n">icq</span><span class="p">);</span>

	<span class="n">cic</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">.</span><span class="n">last_end_request</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_exit_icq</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_cq</span> <span class="o">*</span><span class="n">icq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span> <span class="o">=</span> <span class="n">icq_to_cic</span><span class="p">(</span><span class="n">icq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">cic_to_cfqd</span><span class="p">(</span><span class="n">cic</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">cfqq</span><span class="p">[</span><span class="n">BLK_RW_ASYNC</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">cfq_exit_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cic</span><span class="o">-&gt;</span><span class="n">cfqq</span><span class="p">[</span><span class="n">BLK_RW_ASYNC</span><span class="p">]);</span>
		<span class="n">cic</span><span class="o">-&gt;</span><span class="n">cfqq</span><span class="p">[</span><span class="n">BLK_RW_ASYNC</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">cfqq</span><span class="p">[</span><span class="n">BLK_RW_SYNC</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">cfq_exit_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cic</span><span class="o">-&gt;</span><span class="n">cfqq</span><span class="p">[</span><span class="n">BLK_RW_SYNC</span><span class="p">]);</span>
		<span class="n">cic</span><span class="o">-&gt;</span><span class="n">cfqq</span><span class="p">[</span><span class="n">BLK_RW_SYNC</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_init_prio_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ioprio_class</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_cfqq_prio_changed</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ioprio_class</span> <span class="o">=</span> <span class="n">IOPRIO_PRIO_CLASS</span><span class="p">(</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">ioprio</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ioprio_class</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;cfq: bad prio %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioprio_class</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">IOPRIO_CLASS_NONE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * no prio set, inherit CPU scheduling settings</span>
<span class="cm">		 */</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ioprio</span> <span class="o">=</span> <span class="n">task_nice_ioprio</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ioprio_class</span> <span class="o">=</span> <span class="n">task_nice_ioclass</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IOPRIO_CLASS_RT</span>:
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ioprio</span> <span class="o">=</span> <span class="n">IOPRIO_PRIO_DATA</span><span class="p">(</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">ioprio</span><span class="p">);</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ioprio_class</span> <span class="o">=</span> <span class="n">IOPRIO_CLASS_RT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IOPRIO_CLASS_BE</span>:
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ioprio</span> <span class="o">=</span> <span class="n">IOPRIO_PRIO_DATA</span><span class="p">(</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">ioprio</span><span class="p">);</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ioprio_class</span> <span class="o">=</span> <span class="n">IOPRIO_CLASS_BE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IOPRIO_CLASS_IDLE</span>:
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ioprio_class</span> <span class="o">=</span> <span class="n">IOPRIO_CLASS_IDLE</span><span class="p">;</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ioprio</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">cfq_clear_cfqq_idle_window</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * keep track of original prio settings in case we have to temporarily</span>
<span class="cm">	 * elevate the priority of this queue</span>
<span class="cm">	 */</span>
	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">org_ioprio</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ioprio</span><span class="p">;</span>
	<span class="n">cfq_clear_cfqq_prio_changed</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_ioprio_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ioprio</span> <span class="o">=</span> <span class="n">cic</span><span class="o">-&gt;</span><span class="n">icq</span><span class="p">.</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioprio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">cic_to_cfqd</span><span class="p">(</span><span class="n">cic</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check whether ioprio has changed.  The condition may trigger</span>
<span class="cm">	 * spuriously on a newly created cic but there&#39;s no harm.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="p">)</span> <span class="o">||</span> <span class="n">likely</span><span class="p">(</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">ioprio</span> <span class="o">==</span> <span class="n">ioprio</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cic</span><span class="o">-&gt;</span><span class="n">cfqq</span><span class="p">[</span><span class="n">BLK_RW_ASYNC</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">new_cfqq</span><span class="p">;</span>
		<span class="n">new_cfqq</span> <span class="o">=</span> <span class="n">cfq_get_queue</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">BLK_RW_ASYNC</span><span class="p">,</span> <span class="n">cic</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span>
					 <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_cfqq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cic</span><span class="o">-&gt;</span><span class="n">cfqq</span><span class="p">[</span><span class="n">BLK_RW_ASYNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_cfqq</span><span class="p">;</span>
			<span class="n">cfq_put_queue</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cic</span><span class="o">-&gt;</span><span class="n">cfqq</span><span class="p">[</span><span class="n">BLK_RW_SYNC</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="p">)</span>
		<span class="n">cfq_mark_cfqq_prio_changed</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>

	<span class="n">cic</span><span class="o">-&gt;</span><span class="n">ioprio</span> <span class="o">=</span> <span class="n">ioprio</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_init_cfqq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span>
			  <span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">RB_CLEAR_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
	<span class="n">RB_CLEAR_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">p_node</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">fifo</span><span class="p">);</span>

	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">cfqd</span><span class="p">;</span>

	<span class="n">cfq_mark_cfqq_prio_changed</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_sync</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_class_idle</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
			<span class="n">cfq_mark_cfqq_idle_window</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
		<span class="n">cfq_mark_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CFQ_GROUP_IOSCHED</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_blkcg_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">cic_to_cfqd</span><span class="p">(</span><span class="n">cic</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">sync_cfqq</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">id</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">id</span> <span class="o">=</span> <span class="n">bio_blkcg</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check whether blkcg has changed.  The condition may trigger</span>
<span class="cm">	 * spuriously on a newly created cic but there&#39;s no harm.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="p">)</span> <span class="o">||</span> <span class="n">likely</span><span class="p">(</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">blkcg_id</span> <span class="o">==</span> <span class="n">id</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sync_cfqq</span> <span class="o">=</span> <span class="n">cic_to_cfqq</span><span class="p">(</span><span class="n">cic</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sync_cfqq</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Drop reference to sync queue. A new sync queue will be</span>
<span class="cm">		 * assigned in new group upon arrival of a fresh request.</span>
<span class="cm">		 */</span>
		<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">sync_cfqq</span><span class="p">,</span> <span class="s">&quot;changed cgroup&quot;</span><span class="p">);</span>
		<span class="n">cic_set_cfqq</span><span class="p">(</span><span class="n">cic</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">cfq_put_queue</span><span class="p">(</span><span class="n">sync_cfqq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cic</span><span class="o">-&gt;</span><span class="n">blkcg_id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">check_blkcg_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif  </span><span class="cm">/* CONFIG_CFQ_GROUP_IOSCHED */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span>
<span class="nf">cfq_find_alloc_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_sync</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blkcg</span> <span class="o">*</span><span class="n">blkcg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span> <span class="o">*</span><span class="n">new_cfqq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_group</span> <span class="o">*</span><span class="n">cfqg</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">blkcg</span> <span class="o">=</span> <span class="n">bio_blkcg</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="n">cfqg</span> <span class="o">=</span> <span class="n">cfq_lookup_create_cfqg</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">blkcg</span><span class="p">);</span>
	<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cic_to_cfqq</span><span class="p">(</span><span class="n">cic</span><span class="p">,</span> <span class="n">is_sync</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Always try a new alloc if we fell back to the OOM cfqq</span>
<span class="cm">	 * originally, since it should just be a temporary situation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqq</span> <span class="o">||</span> <span class="n">cfqq</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">oom_cfqq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfqq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_cfqq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cfqq</span> <span class="o">=</span> <span class="n">new_cfqq</span><span class="p">;</span>
			<span class="n">new_cfqq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
			<span class="n">new_cfqq</span> <span class="o">=</span> <span class="n">kmem_cache_alloc_node</span><span class="p">(</span><span class="n">cfq_pool</span><span class="p">,</span>
					<span class="n">gfp_mask</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">,</span>
					<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_cfqq</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cfqq</span> <span class="o">=</span> <span class="n">kmem_cache_alloc_node</span><span class="p">(</span><span class="n">cfq_pool</span><span class="p">,</span>
					<span class="n">gfp_mask</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">,</span>
					<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cfq_init_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">is_sync</span><span class="p">);</span>
			<span class="n">cfq_init_prio_data</span><span class="p">(</span><span class="n">cfqq</span><span class="p">,</span> <span class="n">cic</span><span class="p">);</span>
			<span class="n">cfq_link_cfqq_cfqg</span><span class="p">(</span><span class="n">cfqq</span><span class="p">,</span> <span class="n">cfqg</span><span class="p">);</span>
			<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;alloced&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">cfqq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">oom_cfqq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_cfqq</span><span class="p">)</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">cfq_pool</span><span class="p">,</span> <span class="n">new_cfqq</span><span class="p">);</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">cfqq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">**</span>
<span class="nf">cfq_async_queue_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioprio_class</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioprio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ioprio_class</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IOPRIO_CLASS_RT</span>:
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">async_cfqq</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ioprio</span><span class="p">];</span>
	<span class="k">case</span> <span class="n">IOPRIO_CLASS_NONE</span>:
		<span class="n">ioprio</span> <span class="o">=</span> <span class="n">IOPRIO_NORM</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">IOPRIO_CLASS_BE</span>:
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">async_cfqq</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ioprio</span><span class="p">];</span>
	<span class="k">case</span> <span class="n">IOPRIO_CLASS_IDLE</span>:
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">async_idle_cfqq</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span>
<span class="nf">cfq_get_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_sync</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">ioprio_class</span> <span class="o">=</span> <span class="n">IOPRIO_PRIO_CLASS</span><span class="p">(</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">ioprio</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">ioprio</span> <span class="o">=</span> <span class="n">IOPRIO_PRIO_DATA</span><span class="p">(</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">ioprio</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">**</span><span class="n">async_cfqq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_sync</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">async_cfqq</span> <span class="o">=</span> <span class="n">cfq_async_queue_prio</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">ioprio_class</span><span class="p">,</span> <span class="n">ioprio</span><span class="p">);</span>
		<span class="n">cfqq</span> <span class="o">=</span> <span class="o">*</span><span class="n">async_cfqq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqq</span><span class="p">)</span>
		<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cfq_find_alloc_queue</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">is_sync</span><span class="p">,</span> <span class="n">cic</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * pin the queue now that it&#39;s allocated, scheduler exit will prune it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_sync</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">async_cfqq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ref</span><span class="o">++</span><span class="p">;</span>
		<span class="o">*</span><span class="n">async_cfqq</span> <span class="o">=</span> <span class="n">cfqq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ref</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cfqq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__cfq_update_io_thinktime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_ttime</span> <span class="o">*</span><span class="n">ttime</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">slice_idle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">ttime</span><span class="o">-&gt;</span><span class="n">last_end_request</span><span class="p">;</span>
	<span class="n">elapsed</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">elapsed</span><span class="p">,</span> <span class="mi">2UL</span> <span class="o">*</span> <span class="n">slice_idle</span><span class="p">);</span>

	<span class="n">ttime</span><span class="o">-&gt;</span><span class="n">ttime_samples</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="n">ttime</span><span class="o">-&gt;</span><span class="n">ttime_samples</span> <span class="o">+</span> <span class="mi">256</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">ttime</span><span class="o">-&gt;</span><span class="n">ttime_total</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="n">ttime</span><span class="o">-&gt;</span><span class="n">ttime_total</span> <span class="o">+</span> <span class="mi">256</span><span class="o">*</span><span class="n">elapsed</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">ttime</span><span class="o">-&gt;</span><span class="n">ttime_mean</span> <span class="o">=</span> <span class="p">(</span><span class="n">ttime</span><span class="o">-&gt;</span><span class="n">ttime_total</span> <span class="o">+</span> <span class="mi">128</span><span class="p">)</span> <span class="o">/</span> <span class="n">ttime</span><span class="o">-&gt;</span><span class="n">ttime_samples</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cfq_update_io_thinktime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__cfq_update_io_thinktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_idle</span><span class="p">);</span>
		<span class="n">__cfq_update_io_thinktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">service_tree</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">,</span>
			<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_idle</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_CFQ_GROUP_IOSCHED</span>
	<span class="n">__cfq_update_io_thinktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_group_idle</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cfq_update_io_seektime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span> <span class="n">sdist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">n_sec</span> <span class="o">=</span> <span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">last_request_pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">last_request_pos</span> <span class="o">&lt;</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
			<span class="n">sdist</span> <span class="o">=</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">-</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">last_request_pos</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">sdist</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">last_request_pos</span> <span class="o">-</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">seek_history</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_queue_nonrot</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">seek_history</span> <span class="o">|=</span> <span class="p">(</span><span class="n">n_sec</span> <span class="o">&lt;</span> <span class="n">CFQQ_SECT_THR_NONROT</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">seek_history</span> <span class="o">|=</span> <span class="p">(</span><span class="n">sdist</span> <span class="o">&gt;</span> <span class="n">CFQQ_SEEK_THR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Disable idle window if the process thinks too long or seeks so much that</span>
<span class="cm"> * it doesn&#39;t matter</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cfq_update_idle_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">old_idle</span><span class="p">,</span> <span class="n">enable_idle</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t idle for async or idle io prio class</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">||</span> <span class="n">cfq_class_idle</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">enable_idle</span> <span class="o">=</span> <span class="n">old_idle</span> <span class="o">=</span> <span class="n">cfq_cfqq_idle_window</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">cfq_mark_cfqq_deep</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">next_rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_NOIDLE</span><span class="p">))</span>
		<span class="n">enable_idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">icq</span><span class="p">.</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">active_ref</span><span class="p">)</span> <span class="o">||</span>
		 <span class="o">!</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_idle</span> <span class="o">||</span>
		 <span class="p">(</span><span class="o">!</span><span class="n">cfq_cfqq_deep</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">CFQQ_SEEKY</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)))</span>
		<span class="n">enable_idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sample_valid</span><span class="p">(</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">.</span><span class="n">ttime_samples</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">.</span><span class="n">ttime_mean</span> <span class="o">&gt;</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_idle</span><span class="p">)</span>
			<span class="n">enable_idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">enable_idle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_idle</span> <span class="o">!=</span> <span class="n">enable_idle</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;idle=%d&quot;</span><span class="p">,</span> <span class="n">enable_idle</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">enable_idle</span><span class="p">)</span>
			<span class="n">cfq_mark_cfqq_idle_window</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">cfq_clear_cfqq_idle_window</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if new_cfqq should preempt the currently active queue. Return 0 for</span>
<span class="cm"> * no or if we aren&#39;t sure, a 1 will cause a preempt.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">cfq_should_preempt</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">new_cfqq</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">;</span>

	<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqq</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_class_idle</span><span class="p">(</span><span class="n">new_cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_class_idle</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t allow a non-RT request to preempt an ongoing RT cfqq timeslice.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_class_rt</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cfq_class_rt</span><span class="p">(</span><span class="n">new_cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if the new request is sync, but the currently running queue is</span>
<span class="cm">	 * not, let the sync request have priority.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq_is_sync</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span> <span class="o">!=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_slice_used</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Allow preemption only if we are idling on sync-noidle tree */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_type</span> <span class="o">==</span> <span class="n">SYNC_NOIDLE_WORKLOAD</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cfqq_type</span><span class="p">(</span><span class="n">new_cfqq</span><span class="p">)</span> <span class="o">==</span> <span class="n">SYNC_NOIDLE_WORKLOAD</span> <span class="o">&amp;&amp;</span>
	    <span class="n">new_cfqq</span><span class="o">-&gt;</span><span class="n">service_tree</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
	    <span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * So both queues are sync. Let the new request get disk time if</span>
<span class="cm">	 * it&#39;s a metadata request and the current queue is doing regular IO.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_PRIO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">prio_pending</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow an RT request to pre-empt an ongoing non-RT cfqq timeslice.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_class_rt</span><span class="p">(</span><span class="n">new_cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cfq_class_rt</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* An idle queue should not be idle now for some reason */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cfq_should_idle</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_cic</span> <span class="o">||</span> <span class="o">!</span><span class="n">cfq_cfqq_wait_request</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if this request is as-good as one we would expect from the</span>
<span class="cm">	 * current cfqq, let it preempt</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_rq_close</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="n">rq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cfqq preempts the active queue. if we allowed preempt with no slice left,</span>
<span class="cm"> * let it have half of its nominal slice.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_preempt_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">wl_type_t</span> <span class="n">old_type</span> <span class="o">=</span> <span class="n">cfqq_type</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span><span class="p">);</span>

	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;preempt&quot;</span><span class="p">);</span>
	<span class="n">cfq_slice_expired</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * workload type is changed, don&#39;t save slice, otherwise preempt</span>
<span class="cm">	 * doesn&#39;t happen</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_type</span> <span class="o">!=</span> <span class="n">cfqq_type</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">saved_workload_slice</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Put the new queue at the front of the of the current list,</span>
<span class="cm">	 * so we know that it will be selected next.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cfq_cfqq_on_rr</span><span class="p">(</span><span class="n">cfqq</span><span class="p">));</span>

	<span class="n">cfq_service_tree_add</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cfq_mark_cfqq_slice_new</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when a new fs request (rq) is added (to cfqq). Check if there&#39;s</span>
<span class="cm"> * something we should do about it</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cfq_rq_enqueued</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span> <span class="o">=</span> <span class="n">RQ_CIC</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_queued</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_PRIO</span><span class="p">)</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">prio_pending</span><span class="o">++</span><span class="p">;</span>

	<span class="n">cfq_update_io_thinktime</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="n">cic</span><span class="p">);</span>
	<span class="n">cfq_update_io_seektime</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
	<span class="n">cfq_update_idle_window</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="n">cic</span><span class="p">);</span>

	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">last_request_pos</span> <span class="o">=</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">+</span> <span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span> <span class="o">==</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Remember that we saw a request from this process, but</span>
<span class="cm">		 * don&#39;t start queuing just yet. Otherwise we risk seeing lots</span>
<span class="cm">		 * of tiny requests, because we disrupt the normal plugging</span>
<span class="cm">		 * and merging. If the request is already larger than a single</span>
<span class="cm">		 * page, let it rip immediately. For that case we assume that</span>
<span class="cm">		 * merging is already done. Ditto for a busy system that</span>
<span class="cm">		 * has other work pending, don&#39;t risk delaying until the</span>
<span class="cm">		 * idle timer unplug to continue working.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_wait_request</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">||</span>
			    <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">busy_queues</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cfq_del_timer</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>
				<span class="n">cfq_clear_cfqq_wait_request</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
				<span class="n">__blk_run_queue</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">cfqg_stats_update_idle_time</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">);</span>
				<span class="n">cfq_mark_cfqq_must_dispatch</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cfq_should_preempt</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="n">rq</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * not the active queue - expire current slice if it is</span>
<span class="cm">		 * idle and has expired it&#39;s mean thinktime or this new queue</span>
<span class="cm">		 * has some old slice time left and is of higher priority or</span>
<span class="cm">		 * this new queue is RT and the current one is BE</span>
<span class="cm">		 */</span>
		<span class="n">cfq_preempt_queue</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>
		<span class="n">__blk_run_queue</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_insert_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">elevator_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span> <span class="o">=</span> <span class="n">RQ_CFQQ</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;insert_request&quot;</span><span class="p">);</span>
	<span class="n">cfq_init_prio_data</span><span class="p">(</span><span class="n">cfqq</span><span class="p">,</span> <span class="n">RQ_CIC</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>

	<span class="n">rq_set_fifo_time</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_fifo_expire</span><span class="p">[</span><span class="n">rq_is_sync</span><span class="p">(</span><span class="n">rq</span><span class="p">)]);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">queuelist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">fifo</span><span class="p">);</span>
	<span class="n">cfq_add_rq_rb</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">cfqg_stats_update_io_add</span><span class="p">(</span><span class="n">RQ_CFQG</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">serving_group</span><span class="p">,</span>
				 <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span><span class="p">);</span>
	<span class="n">cfq_rq_enqueued</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update hw_tag based on peak queue depth over 50 samples under</span>
<span class="cm"> * sufficient load.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_update_hw_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_in_driver</span> <span class="o">&gt;</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">hw_tag_est_depth</span><span class="p">)</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">hw_tag_est_depth</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_in_driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">hw_tag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_queued</span> <span class="o">&lt;=</span> <span class="n">CFQ_HW_QUEUE_MIN</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_in_driver</span> <span class="o">&lt;=</span> <span class="n">CFQ_HW_QUEUE_MIN</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If active queue hasn&#39;t enough requests and can idle, cfq might not</span>
<span class="cm">	 * dispatch sufficient requests to hardware. Don&#39;t zero hw_tag in this</span>
<span class="cm">	 * case</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span> <span class="o">&amp;&amp;</span> <span class="n">cfq_cfqq_idle_window</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">dispatched</span> <span class="o">+</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span>
	    <span class="n">CFQ_HW_QUEUE_MIN</span> <span class="o">&amp;&amp;</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_in_driver</span> <span class="o">&lt;</span> <span class="n">CFQ_HW_QUEUE_MIN</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">hw_tag_samples</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">hw_tag_est_depth</span> <span class="o">&gt;=</span> <span class="n">CFQ_HW_QUEUE_MIN</span><span class="p">)</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">hw_tag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">hw_tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">cfq_should_wait_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_cic</span><span class="p">;</span>

	<span class="cm">/* If the queue already has requests, don&#39;t wait */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* If there are other queues in the group, don&#39;t wait */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">nr_cfqq</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* the only queue in the group, but think time is big */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_io_thinktime_big</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_slice_used</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* if slice left is less than think time, wait busy */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cic</span> <span class="o">&amp;&amp;</span> <span class="n">sample_valid</span><span class="p">(</span><span class="n">cic</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">.</span><span class="n">ttime_samples</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_end</span> <span class="o">-</span> <span class="n">jiffies</span> <span class="o">&lt;</span> <span class="n">cic</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">.</span><span class="n">ttime_mean</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If think times is less than a jiffy than ttime_mean=0 and above</span>
<span class="cm">	 * will not be true. It might happen that slice has not expired yet</span>
<span class="cm">	 * but will expire soon (4-5 ns) during select_queue(). To cover the</span>
<span class="cm">	 * case where think time is less than a jiffy, mark the queue wait</span>
<span class="cm">	 * busy if only 1 jiffy is left in the slice.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_end</span> <span class="o">-</span> <span class="n">jiffies</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_completed_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span> <span class="o">=</span> <span class="n">RQ_CFQQ</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqd</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">sync</span> <span class="o">=</span> <span class="n">rq_is_sync</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;complete rqnoidle %d&quot;</span><span class="p">,</span>
		     <span class="o">!!</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_NOIDLE</span><span class="p">));</span>

	<span class="n">cfq_update_hw_tag</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_in_driver</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">dispatched</span><span class="p">);</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_in_driver</span><span class="o">--</span><span class="p">;</span>
	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">dispatched</span><span class="o">--</span><span class="p">;</span>
	<span class="p">(</span><span class="n">RQ_CFQG</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">dispatched</span><span class="o">--</span><span class="p">;</span>
	<span class="n">cfqg_stats_update_completion</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">,</span> <span class="n">rq_start_time_ns</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span>
				     <span class="n">rq_io_start_time_ns</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span><span class="p">);</span>

	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_in_flight</span><span class="p">[</span><span class="n">cfq_cfqq_sync</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)]</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sync</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cfq_rb_root</span> <span class="o">*</span><span class="n">service_tree</span><span class="p">;</span>

		<span class="n">RQ_CIC</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">.</span><span class="n">last_end_request</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_on_rr</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
			<span class="n">service_tree</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">service_tree</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">service_tree</span> <span class="o">=</span> <span class="n">service_tree_for</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">,</span>
				<span class="n">cfqq_prio</span><span class="p">(</span><span class="n">cfqq</span><span class="p">),</span> <span class="n">cfqq_type</span><span class="p">(</span><span class="n">cfqq</span><span class="p">));</span>
		<span class="n">service_tree</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">.</span><span class="n">last_end_request</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_after</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_fifo_expire</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">now</span><span class="p">))</span>
			<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">last_delayed_sync</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CFQ_GROUP_IOSCHED</span>
	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="o">-&gt;</span><span class="n">ttime</span><span class="p">.</span><span class="n">last_end_request</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is the active queue, check if it needs to be expired,</span>
<span class="cm">	 * or if we want to idle in case it has no pending requests.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span> <span class="o">==</span> <span class="n">cfqq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">bool</span> <span class="n">cfqq_empty</span> <span class="o">=</span> <span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_slice_new</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cfq_set_prio_slice</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>
			<span class="n">cfq_clear_cfqq_slice_new</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Should we wait for next request to come in before we expire</span>
<span class="cm">		 * the queue.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfq_should_wait_busy</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">extend_sl</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_idle</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_idle</span><span class="p">)</span>
				<span class="n">extend_sl</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_group_idle</span><span class="p">;</span>
			<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">slice_end</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">extend_sl</span><span class="p">;</span>
			<span class="n">cfq_mark_cfqq_wait_busy</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
			<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;will busy wait&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Idling is not enabled on:</span>
<span class="cm">		 * - expired queues</span>
<span class="cm">		 * - idle-priority queues</span>
<span class="cm">		 * - async queues</span>
<span class="cm">		 * - queues with still some requests queued</span>
<span class="cm">		 * - when there is a close cooperator</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfq_slice_used</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">||</span> <span class="n">cfq_class_idle</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
			<span class="n">cfq_slice_expired</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sync</span> <span class="o">&amp;&amp;</span> <span class="n">cfqq_empty</span> <span class="o">&amp;&amp;</span>
			 <span class="o">!</span><span class="n">cfq_close_cooperator</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cfq_arm_slice_timer</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">rq_in_driver</span><span class="p">)</span>
		<span class="n">cfq_schedule_dispatch</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__cfq_may_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_wait_request</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cfq_cfqq_must_alloc_slice</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cfq_mark_cfqq_must_alloc_slice</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ELV_MQUEUE_MUST</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ELV_MQUEUE_MAY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfq_may_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">elevator_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * don&#39;t force setup of a queue from here, as a call to may_queue</span>
<span class="cm">	 * does not necessarily imply that a request actually will be queued.</span>
<span class="cm">	 * so just lookup a possibly existing queue, or return &#39;may queue&#39;</span>
<span class="cm">	 * if that fails</span>
<span class="cm">	 */</span>
	<span class="n">cic</span> <span class="o">=</span> <span class="n">cfq_cic_lookup</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">io_context</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cic</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ELV_MQUEUE_MAY</span><span class="p">;</span>

	<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cic_to_cfqq</span><span class="p">(</span><span class="n">cic</span><span class="p">,</span> <span class="n">rw_is_sync</span><span class="p">(</span><span class="n">rw</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfq_init_prio_data</span><span class="p">(</span><span class="n">cfqq</span><span class="p">,</span> <span class="n">cic</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">__cfq_may_queue</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ELV_MQUEUE_MAY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * queue lock held here</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_put_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span> <span class="o">=</span> <span class="n">RQ_CFQQ</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">rw</span> <span class="o">=</span> <span class="n">rq_data_dir</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">[</span><span class="n">rw</span><span class="p">]);</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">[</span><span class="n">rw</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/* Put down rq reference on cfqg */</span>
		<span class="n">cfqg_put</span><span class="p">(</span><span class="n">RQ_CFQG</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">elv</span><span class="p">.</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">elv</span><span class="p">.</span><span class="n">priv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">cfq_put_queue</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span>
<span class="nf">cfq_merge_cfqqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;merging with queue %p&quot;</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">new_cfqq</span><span class="p">);</span>
	<span class="n">cic_set_cfqq</span><span class="p">(</span><span class="n">cic</span><span class="p">,</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">new_cfqq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">cfq_mark_cfqq_coop</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">new_cfqq</span><span class="p">);</span>
	<span class="n">cfq_put_queue</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cic_to_cfqq</span><span class="p">(</span><span class="n">cic</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns NULL if a new cfqq should be allocated, or the old cfqq if this</span>
<span class="cm"> * was the last process referring to said cfqq.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span>
<span class="nf">split_cfqq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq_process_refs</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
		<span class="n">cfq_clear_cfqq_coop</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
		<span class="n">cfq_clear_cfqq_split_coop</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">cfqq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cic_set_cfqq</span><span class="p">(</span><span class="n">cic</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">cfq_put_cooperator</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>

	<span class="n">cfq_put_queue</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Allocate cfq data structures associated with this request.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cfq_set_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
		<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">elevator_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_io_cq</span> <span class="o">*</span><span class="n">cic</span> <span class="o">=</span> <span class="n">icq_to_cic</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">elv</span><span class="p">.</span><span class="n">icq</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">rw</span> <span class="o">=</span> <span class="n">rq_data_dir</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">bool</span> <span class="n">is_sync</span> <span class="o">=</span> <span class="n">rq_is_sync</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">;</span>

	<span class="n">might_sleep_if</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="n">check_ioprio_changed</span><span class="p">(</span><span class="n">cic</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="n">check_blkcg_changed</span><span class="p">(</span><span class="n">cic</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
<span class="nl">new_queue:</span>
	<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cic_to_cfqq</span><span class="p">(</span><span class="n">cic</span><span class="p">,</span> <span class="n">is_sync</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqq</span> <span class="o">||</span> <span class="n">cfqq</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">oom_cfqq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cfq_get_queue</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">is_sync</span><span class="p">,</span> <span class="n">cic</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
		<span class="n">cic_set_cfqq</span><span class="p">(</span><span class="n">cic</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="n">is_sync</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the queue was seeky for too long, break it apart.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_coop</span><span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cfq_cfqq_split_coop</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cfq_log_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">,</span> <span class="s">&quot;breaking apart cfqq&quot;</span><span class="p">);</span>
			<span class="n">cfqq</span> <span class="o">=</span> <span class="n">split_cfqq</span><span class="p">(</span><span class="n">cic</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqq</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">new_queue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check to see if this queue is scheduled to merge with</span>
<span class="cm">		 * another, closely cooperating queue.  The merging of</span>
<span class="cm">		 * queues happens here as it must be done in process context.</span>
<span class="cm">		 * The reference on new_cfqq was taken in merge_cfqqs.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">new_cfqq</span><span class="p">)</span>
			<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cfq_merge_cfqqs</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cic</span><span class="p">,</span> <span class="n">cfqq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">[</span><span class="n">rw</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

	<span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">ref</span><span class="o">++</span><span class="p">;</span>
	<span class="n">cfqg_get</span><span class="p">(</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">);</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">elv</span><span class="p">.</span><span class="n">priv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfqq</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">elv</span><span class="p">.</span><span class="n">priv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">cfqg</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_kick_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfq_data</span><span class="p">,</span> <span class="n">unplug_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">__blk_run_queue</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Timer running if the active_queue is currently idling inside its time slice</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_idle_slice_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfq_queue</span> <span class="o">*</span><span class="n">cfqq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timed_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">cfq_log</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="s">&quot;idle timer fired&quot;</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">cfqq</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfqq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">timed_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We saw a request before the queue expired, let it through</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfq_cfqq_must_dispatch</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_kick</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * expired</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfq_slice_used</span><span class="p">(</span><span class="n">cfqq</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">expire</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * only expire and reinvoke request handler, if there are</span>
<span class="cm">		 * other queues with pending requests</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">busy_queues</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_cont</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * not expired and it has a request pending, let it dispatch</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqq</span><span class="o">-&gt;</span><span class="n">sort_list</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_kick</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Queue depth flag is reset only when the idle didn&#39;t succeed</span>
<span class="cm">		 */</span>
		<span class="n">cfq_clear_cfqq_deep</span><span class="p">(</span><span class="n">cfqq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">expire:</span>
	<span class="n">cfq_slice_expired</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">timed_out</span><span class="p">);</span>
<span class="nl">out_kick:</span>
	<span class="n">cfq_schedule_dispatch</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>
<span class="nl">out_cont:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_shutdown_timer_wq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">idle_slice_timer</span><span class="p">);</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">unplug_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_put_async_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IOPRIO_BE_NR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">async_cfqq</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
			<span class="n">cfq_put_queue</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">async_cfqq</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">async_cfqq</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
			<span class="n">cfq_put_queue</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">async_cfqq</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">async_idle_cfqq</span><span class="p">)</span>
		<span class="n">cfq_put_queue</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">async_idle_cfqq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfq_exit_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">elevator_queue</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">elevator_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>

	<span class="n">cfq_shutdown_timer_wq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span><span class="p">)</span>
		<span class="n">__cfq_slice_expired</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">active_queue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">cfq_put_async_queues</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="n">cfq_shutdown_timer_wq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_CFQ_GROUP_IOSCHED</span>
	<span class="n">blkcg_deactivate_policy</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkcg_policy_cfq</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">root_group</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfq_init_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfq_data</span> <span class="o">*</span><span class="n">cfqd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blkcg_gq</span> <span class="o">*</span><span class="n">blkg</span> <span class="n">__maybe_unused</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">cfqd</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cfqd</span><span class="p">),</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="o">-&gt;</span><span class="n">elevator_data</span> <span class="o">=</span> <span class="n">cfqd</span><span class="p">;</span>

	<span class="cm">/* Init root service tree */</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">grp_service_tree</span> <span class="o">=</span> <span class="n">CFQ_RB_ROOT</span><span class="p">;</span>

	<span class="cm">/* Init root group and prefer root group over other groups by default */</span>
<span class="cp">#ifdef CONFIG_CFQ_GROUP_IOSCHED</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">blkcg_activate_policy</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkcg_policy_cfq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">root_group</span> <span class="o">=</span> <span class="n">blkg_to_cfqg</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">root_blkg</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">root_group</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">root_group</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">root_group</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">cfq_init_cfqg_base</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">root_group</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">root_group</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">CFQ_WEIGHT_DEFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Not strictly needed (since RB_ROOT just clears the node and we</span>
<span class="cm">	 * zeroed cfqd on alloc), but better be safe in case someone decides</span>
<span class="cm">	 * to add magic to the rb code</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CFQ_PRIO_LISTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">prio_trees</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Our fallback cfqq if cfq_find_alloc_queue() runs into OOM issues.</span>
<span class="cm">	 * Grab a permanent reference to it, so that the normal code flow</span>
<span class="cm">	 * will not attempt to free it.  oom_cfqq is linked to root_group</span>
<span class="cm">	 * but shouldn&#39;t hold a reference as it&#39;ll never be unlinked.  Lose</span>
<span class="cm">	 * the reference from linking right away.</span>
<span class="cm">	 */</span>
	<span class="n">cfq_init_cfqq</span><span class="p">(</span><span class="n">cfqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">oom_cfqq</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">oom_cfqq</span><span class="p">.</span><span class="n">ref</span><span class="o">++</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">cfq_link_cfqq_cfqg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">oom_cfqq</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">root_group</span><span class="p">);</span>
	<span class="n">cfqg_put</span><span class="p">(</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">root_group</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">idle_slice_timer</span><span class="p">);</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">idle_slice_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">cfq_idle_slice_timer</span><span class="p">;</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">idle_slice_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">cfqd</span><span class="p">;</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">unplug_work</span><span class="p">,</span> <span class="n">cfq_kick_queue</span><span class="p">);</span>

	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_quantum</span> <span class="o">=</span> <span class="n">cfq_quantum</span><span class="p">;</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_fifo_expire</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfq_fifo_expire</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_fifo_expire</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfq_fifo_expire</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_back_max</span> <span class="o">=</span> <span class="n">cfq_back_max</span><span class="p">;</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_back_penalty</span> <span class="o">=</span> <span class="n">cfq_back_penalty</span><span class="p">;</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfq_slice_async</span><span class="p">;</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfq_slice_sync</span><span class="p">;</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_target_latency</span> <span class="o">=</span> <span class="n">cfq_target_latency</span><span class="p">;</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_async_rq</span> <span class="o">=</span> <span class="n">cfq_slice_async_rq</span><span class="p">;</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_idle</span> <span class="o">=</span> <span class="n">cfq_slice_idle</span><span class="p">;</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_group_idle</span> <span class="o">=</span> <span class="n">cfq_group_idle</span><span class="p">;</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_latency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">hw_tag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * we optimistically start assuming sync ops weren&#39;t delayed in last</span>
<span class="cm">	 * second, in order to have larger depth for async operations.</span>
<span class="cm">	 */</span>
	<span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">last_delayed_sync</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cfqd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sysfs parts below --&gt;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">cfq_var_show</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">cfq_var_store</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">page</span><span class="p">;</span>

	<span class="o">*</span><span class="n">var</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define SHOW_FUNCTION(__FUNC, __VAR, __CONV)				\</span>
<span class="cp">static ssize_t __FUNC(struct elevator_queue *e, char *page)		\</span>
<span class="cp">{									\</span>
<span class="cp">	struct cfq_data *cfqd = e-&gt;elevator_data;			\</span>
<span class="cp">	unsigned int __data = __VAR;					\</span>
<span class="cp">	if (__CONV)							\</span>
<span class="cp">		__data = jiffies_to_msecs(__data);			\</span>
<span class="cp">	return cfq_var_show(__data, (page));				\</span>
<span class="cp">}</span>
<span class="n">SHOW_FUNCTION</span><span class="p">(</span><span class="n">cfq_quantum_show</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_quantum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">SHOW_FUNCTION</span><span class="p">(</span><span class="n">cfq_fifo_expire_sync_show</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_fifo_expire</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">SHOW_FUNCTION</span><span class="p">(</span><span class="n">cfq_fifo_expire_async_show</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_fifo_expire</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">SHOW_FUNCTION</span><span class="p">(</span><span class="n">cfq_back_seek_max_show</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_back_max</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">SHOW_FUNCTION</span><span class="p">(</span><span class="n">cfq_back_seek_penalty_show</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_back_penalty</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">SHOW_FUNCTION</span><span class="p">(</span><span class="n">cfq_slice_idle_show</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_idle</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">SHOW_FUNCTION</span><span class="p">(</span><span class="n">cfq_group_idle_show</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_group_idle</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">SHOW_FUNCTION</span><span class="p">(</span><span class="n">cfq_slice_sync_show</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">SHOW_FUNCTION</span><span class="p">(</span><span class="n">cfq_slice_async_show</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">SHOW_FUNCTION</span><span class="p">(</span><span class="n">cfq_slice_async_rq_show</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_async_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">SHOW_FUNCTION</span><span class="p">(</span><span class="n">cfq_low_latency_show</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_latency</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">SHOW_FUNCTION</span><span class="p">(</span><span class="n">cfq_target_latency_show</span><span class="p">,</span> <span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_target_latency</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#undef SHOW_FUNCTION</span>

<span class="cp">#define STORE_FUNCTION(__FUNC, __PTR, MIN, MAX, __CONV)			\</span>
<span class="cp">static ssize_t __FUNC(struct elevator_queue *e, const char *page, size_t count)	\</span>
<span class="cp">{									\</span>
<span class="cp">	struct cfq_data *cfqd = e-&gt;elevator_data;			\</span>
<span class="cp">	unsigned int __data;						\</span>
<span class="cp">	int ret = cfq_var_store(&amp;__data, (page), count);		\</span>
<span class="cp">	if (__data &lt; (MIN))						\</span>
<span class="cp">		__data = (MIN);						\</span>
<span class="cp">	else if (__data &gt; (MAX))					\</span>
<span class="cp">		__data = (MAX);						\</span>
<span class="cp">	if (__CONV)							\</span>
<span class="cp">		*(__PTR) = msecs_to_jiffies(__data);			\</span>
<span class="cp">	else								\</span>
<span class="cp">		*(__PTR) = __data;					\</span>
<span class="cp">	return ret;							\</span>
<span class="cp">}</span>
<span class="n">STORE_FUNCTION</span><span class="p">(</span><span class="n">cfq_quantum_store</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_quantum</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">UINT_MAX</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">STORE_FUNCTION</span><span class="p">(</span><span class="n">cfq_fifo_expire_sync_store</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_fifo_expire</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span>
		<span class="n">UINT_MAX</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">STORE_FUNCTION</span><span class="p">(</span><span class="n">cfq_fifo_expire_async_store</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_fifo_expire</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span>
		<span class="n">UINT_MAX</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">STORE_FUNCTION</span><span class="p">(</span><span class="n">cfq_back_seek_max_store</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_back_max</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UINT_MAX</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">STORE_FUNCTION</span><span class="p">(</span><span class="n">cfq_back_seek_penalty_store</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_back_penalty</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
		<span class="n">UINT_MAX</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">STORE_FUNCTION</span><span class="p">(</span><span class="n">cfq_slice_idle_store</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_idle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UINT_MAX</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">STORE_FUNCTION</span><span class="p">(</span><span class="n">cfq_group_idle_store</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_group_idle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UINT_MAX</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">STORE_FUNCTION</span><span class="p">(</span><span class="n">cfq_slice_sync_store</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">UINT_MAX</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">STORE_FUNCTION</span><span class="p">(</span><span class="n">cfq_slice_async_store</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">UINT_MAX</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">STORE_FUNCTION</span><span class="p">(</span><span class="n">cfq_slice_async_rq_store</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_slice_async_rq</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
		<span class="n">UINT_MAX</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">STORE_FUNCTION</span><span class="p">(</span><span class="n">cfq_low_latency_store</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_latency</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">STORE_FUNCTION</span><span class="p">(</span><span class="n">cfq_target_latency_store</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfqd</span><span class="o">-&gt;</span><span class="n">cfq_target_latency</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">UINT_MAX</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#undef STORE_FUNCTION</span>

<span class="cp">#define CFQ_ATTR(name) \</span>
<span class="cp">	__ATTR(name, S_IRUGO|S_IWUSR, cfq_##name##_show, cfq_##name##_store)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">elv_fs_entry</span> <span class="n">cfq_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">CFQ_ATTR</span><span class="p">(</span><span class="n">quantum</span><span class="p">),</span>
	<span class="n">CFQ_ATTR</span><span class="p">(</span><span class="n">fifo_expire_sync</span><span class="p">),</span>
	<span class="n">CFQ_ATTR</span><span class="p">(</span><span class="n">fifo_expire_async</span><span class="p">),</span>
	<span class="n">CFQ_ATTR</span><span class="p">(</span><span class="n">back_seek_max</span><span class="p">),</span>
	<span class="n">CFQ_ATTR</span><span class="p">(</span><span class="n">back_seek_penalty</span><span class="p">),</span>
	<span class="n">CFQ_ATTR</span><span class="p">(</span><span class="n">slice_sync</span><span class="p">),</span>
	<span class="n">CFQ_ATTR</span><span class="p">(</span><span class="n">slice_async</span><span class="p">),</span>
	<span class="n">CFQ_ATTR</span><span class="p">(</span><span class="n">slice_async_rq</span><span class="p">),</span>
	<span class="n">CFQ_ATTR</span><span class="p">(</span><span class="n">slice_idle</span><span class="p">),</span>
	<span class="n">CFQ_ATTR</span><span class="p">(</span><span class="n">group_idle</span><span class="p">),</span>
	<span class="n">CFQ_ATTR</span><span class="p">(</span><span class="n">low_latency</span><span class="p">),</span>
	<span class="n">CFQ_ATTR</span><span class="p">(</span><span class="n">target_latency</span><span class="p">),</span>
	<span class="n">__ATTR_NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">elevator_type</span> <span class="n">iosched_cfq</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">elevator_merge_fn</span> <span class="o">=</span> 		<span class="n">cfq_merge</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_merged_fn</span> <span class="o">=</span>		<span class="n">cfq_merged_request</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_merge_req_fn</span> <span class="o">=</span>	<span class="n">cfq_merged_requests</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_allow_merge_fn</span> <span class="o">=</span>	<span class="n">cfq_allow_merge</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_bio_merged_fn</span> <span class="o">=</span>	<span class="n">cfq_bio_merged</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_dispatch_fn</span> <span class="o">=</span>		<span class="n">cfq_dispatch_requests</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_add_req_fn</span> <span class="o">=</span>		<span class="n">cfq_insert_request</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_activate_req_fn</span> <span class="o">=</span>	<span class="n">cfq_activate_request</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_deactivate_req_fn</span> <span class="o">=</span>	<span class="n">cfq_deactivate_request</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_completed_req_fn</span> <span class="o">=</span>	<span class="n">cfq_completed_request</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_former_req_fn</span> <span class="o">=</span>	<span class="n">elv_rb_former_request</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_latter_req_fn</span> <span class="o">=</span>	<span class="n">elv_rb_latter_request</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_init_icq_fn</span> <span class="o">=</span>		<span class="n">cfq_init_icq</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_exit_icq_fn</span> <span class="o">=</span>		<span class="n">cfq_exit_icq</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_set_req_fn</span> <span class="o">=</span>		<span class="n">cfq_set_request</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_put_req_fn</span> <span class="o">=</span>		<span class="n">cfq_put_request</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_may_queue_fn</span> <span class="o">=</span>	<span class="n">cfq_may_queue</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_init_fn</span> <span class="o">=</span>		<span class="n">cfq_init_queue</span><span class="p">,</span>
		<span class="p">.</span><span class="n">elevator_exit_fn</span> <span class="o">=</span>		<span class="n">cfq_exit_queue</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">icq_size</span>	<span class="o">=</span>	<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_io_cq</span><span class="p">),</span>
	<span class="p">.</span><span class="n">icq_align</span>	<span class="o">=</span>	<span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_io_cq</span><span class="p">),</span>
	<span class="p">.</span><span class="n">elevator_attrs</span> <span class="o">=</span>	<span class="n">cfq_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">elevator_name</span>	<span class="o">=</span>	<span class="s">&quot;cfq&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">elevator_owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_CFQ_GROUP_IOSCHED</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">blkcg_policy</span> <span class="n">blkcg_policy_cfq</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">pd_size</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfq_group</span><span class="p">),</span>
	<span class="p">.</span><span class="n">cftypes</span>		<span class="o">=</span> <span class="n">cfq_blkcg_files</span><span class="p">,</span>

	<span class="p">.</span><span class="n">pd_init_fn</span>		<span class="o">=</span> <span class="n">cfq_pd_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pd_reset_stats_fn</span>	<span class="o">=</span> <span class="n">cfq_pd_reset_stats</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cfq_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * could be 0 on HZ &lt; 1000 setups</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_slice_async</span><span class="p">)</span>
		<span class="n">cfq_slice_async</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_slice_idle</span><span class="p">)</span>
		<span class="n">cfq_slice_idle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_CFQ_GROUP_IOSCHED</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_group_idle</span><span class="p">)</span>
		<span class="n">cfq_group_idle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">blkcg_policy_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blkcg_policy_cfq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">cfq_group_idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">cfq_pool</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">cfq_queue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfq_pool</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_pol_unreg</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">elv_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosched_cfq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_pool</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_free_pool:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">cfq_pool</span><span class="p">);</span>
<span class="nl">err_pol_unreg:</span>
<span class="cp">#ifdef CONFIG_CFQ_GROUP_IOSCHED</span>
	<span class="n">blkcg_policy_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blkcg_policy_cfq</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cfq_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_CFQ_GROUP_IOSCHED</span>
	<span class="n">blkcg_policy_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blkcg_policy_cfq</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">elv_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosched_cfq</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">cfq_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">cfq_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">cfq_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Jens Axboe&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Completely Fair Queueing IO scheduler&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
